<!DOCTYPE html><html lang="en"><head><title>Help for package mclustAddons</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mclustAddons}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mclustAddons-package'><p>Addons for the <strong>mclust</strong> package</p></a></li>
<li><a href='#cdfDensityBounded'><p>Cumulative distribution and quantiles of univariate model-based mixture</p>
density estimation for bounded data</a></li>
<li><a href='#densityMclustBounded'><p>Model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#EntropyGMM'><p>Gaussian mixture-based estimation of entropy</p></a></li>
<li><a href='#GaussianMixtureMEM'><p>Modal EM algorithm for Gaussian Mixtures</p></a></li>
<li><a href='#GMMlogreturn'><p>Modeling log-returns distribution via Gaussian Mixture Models</p></a></li>
<li><a href='#gold'><p>Gold price log-returns</p></a></li>
<li><a href='#mclustAddons-internal'><p>Internal <span class="pkg">mclustAddons</span> functions</p></a></li>
<li><a href='#MclustBounded'><p>Model-based clustering for bounded data</p></a></li>
<li><a href='#MclustBoundedParameters'><p>Recover parameters in the original scale</p></a></li>
<li><a href='#mclustMarginalParams'><p>Marginal parameters from fitted GMMs via mclust</p></a></li>
<li><a href='#MclustMEM'><p>Modal EM algorithm for Gaussian Mixtures fitted via <em>mclust</em> package</p></a></li>
<li><a href='#plot.densityMclustBounded'><p>Plotting method for model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#plot.MclustBounded'><p>Plotting method for model-based clustering of bounded data</p></a></li>
<li><a href='#plot.MclustMEM'><p>Plotting method for modal-clustering based on Gaussian Mixtures</p></a></li>
<li><a href='#predict.densityMclustBounded'><p>Model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#predict.MclustBounded'><p>Model-based clustering estimation for bounded data</p></a></li>
<li><a href='#racial'><p>Racial data</p></a></li>
<li><a href='#rangepowerTransform'><p>Range–power transformation</p></a></li>
<li><a href='#suicide'><p>Suicide data</p></a></li>
<li><a href='#VaR'><p>Financial risk measures</p></a></li>
<li><a href='#VaR.GMMlogreturn'><p>Risk measures from Gaussian mixtures modeling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Addons for the 'mclust' Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Extend the functionality of the 'mclust' package for Gaussian
    finite mixture modeling by including: density estimation for data with
    bounded support (Scrucca, 2019 &lt;<a href="https://doi.org/10.1002%2Fbimj.201800174">doi:10.1002/bimj.201800174</a>&gt;); modal
    clustering using MEM (Modal EM) algorithm for Gaussian mixtures
    (Scrucca, 2021 &lt;<a href="https://doi.org/10.1002%2Fsam.11527">doi:10.1002/sam.11527</a>&gt;); entropy estimation via
    Gaussian mixture modeling (Robin &amp; Scrucca, 2023
    &lt;<a href="https://doi.org/10.1016%2Fj.csda.2022.107582">doi:10.1016/j.csda.2022.107582</a>&gt;); Gaussian mixtures modeling of 
    financial log-returns (Scrucca, 2024 &lt;<a href="https://doi.org/10.3390%2Fe26110907">doi:10.3390/e26110907</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mclust-org.github.io/mclustAddons/">https://mclust-org.github.io/mclustAddons/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mclust (&ge; 6.1), R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, doParallel, doRNG (&ge; 1.6), foreach, graphics, grDevices,
iterators, knitr (&ge; 1.12), parallel, Rcpp (&ge; 1.0), rmarkdown
(&ge; 0.9), stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-12 09:54:22 UTC; luca</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Scrucca <a href="https://orcid.org/0000-0003-3826-0484"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Scrucca &lt;luca.scrucca@unibo.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-13 08:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='mclustAddons-package'>Addons for the <strong>mclust</strong> package</h2><span id='topic+mclustAddons'></span><span id='topic+mclustAddons-package'></span>

<h3>Description</h3>

<p>An R package extending the functionality of the <strong>mclust</strong> package
(Scrucca et al. 2916, 2023) for Gaussian finite mixture modeling by
including:
</p>

<ul>
<li><p> density estimation for data with bounded support (Scrucca, 2019)
</p>
</li>
<li><p> modal clustering using MEM algorithm for Gaussian mixtures (Scrucca, 2021)
</p>
</li>
<li><p> entropy estimation via Gaussian mixture modeling (Robin &amp; Scrucca, 2023)
</p>
</li></ul>

<p>For a quick introduction to <em>mclustAddons</em> see the vignette
<a href="../doc/mclustAddons.html">A quick tour of mclustAddons</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Luca Scrucca <a href="mailto:luca.scrucca@unibo.it">luca.scrucca@unibo.it</a> (<a href="https://orcid.org/0000-0003-3826-0484">ORCID</a>) [copyright holder]
</p>


<h3>References</h3>

<p>Scrucca L., Fop M., Murphy T. B. and Raftery A. E. (2016)
mclust 5: clustering, classification and density estimation using
Gaussian finite mixture models, <em>The R Journal</em>, 8/1, 205-233.
<a href="https://doi.org/10.32614/RJ-2016-021">doi:10.32614/RJ-2016-021</a>
</p>
<p>Scrucca L., Fraley C., Murphy T.B., Raftery A.E. (2023)
<em>Model-Based Clustering, Classification, and Density  Estimation Using
mclust in R</em>. Chapman and Hall/CRC.
<a href="https://doi.org/10.1201/9781003277965">doi:10.1201/9781003277965</a>
</p>
<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>
<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for Gaussian
mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4, 305–314.
<a href="https://doi.org/10.1002/sam.11527">doi:10.1002/sam.11527</a>
</p>
<p>Robin S. and Scrucca L. (2023) Mixture-based estimation of entropy.
<em>Computational Statistics &amp; Data Analysis</em>, 177, 107582.
<a href="https://doi.org/10.1016/j.csda.2022.107582">doi:10.1016/j.csda.2022.107582</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code> for density estimation of bounded data;
<code><a href="#topic+MclustMEM">MclustMEM()</a></code> for modal clustering;
<code><a href="#topic+EntropyGMM">EntropyGMM()</a></code> for entropy estimation.
</p>

<hr>
<h2 id='cdfDensityBounded'>Cumulative distribution and quantiles of univariate model-based mixture
density estimation for bounded data</h2><span id='topic+cdfDensityBounded'></span><span id='topic+quantileDensityBounded'></span><span id='topic+densityMclustBounded.diagnostic'></span>

<h3>Description</h3>

<p>Compute the cumulative density function (cdf) or quantiles of a
one-dimensional density for bounded data estimated via the
transformation-based approach for Gaussian mixtures in
<code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.
</p>
<p>Diagnostic plots for density estimation of bounded data via
transformation-based approach of Gaussian mixtures. Only available for the
one-dimensional case.
</p>
<p>The two diagnostic plots for density estimation in the one-dimensional case
are discussed in Loader (1999, pp- 87-90).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdfDensityBounded(object, data, ngrid = 100, ...)

quantileDensityBounded(object, p, ...)

densityMclustBounded.diagnostic(
  object,
  type = c("cdf", "qq"),
  col = c("black", "black"),
  lwd = c(2, 1),
  lty = c(1, 1),
  legend = TRUE,
  grid = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdfDensityBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>'mclustDensityBounded'</code> obtained from
a call to <code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code> function.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_data">data</code></td>
<td>
<p>A numeric vector of evaluation points.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_ngrid">ngrid</code></td>
<td>
<p>The number of points in a regular grid to be used as evaluation
points if no <code>data</code> are provided.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities corresponding to quantiles.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_type">type</code></td>
<td>
<p>The type of graph requested:
</p>

<ul>
<li> <p><code>"cdf"</code> A plot of the estimated CDF versus the empirical distribution
function.
</p>
</li>
<li> <p><code>"qq"</code> A Q-Q plot of sample quantiles versus the quantiles obtained from
the inverse of the estimated cdf.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_col">col</code></td>
<td>
<p>A pair of values for the color to be used for plotting,
respectively, the estimated CDF and the empirical cdf.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_lwd">lwd</code></td>
<td>
<p>A pair of values for the line width to be used for plotting,
respectively, the estimated CDF and the empirical cdf.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_lty">lty</code></td>
<td>
<p>A pair of values for the line type to be used for plotting,
respectively, the estimated CDF and the empirical cdf.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_legend">legend</code></td>
<td>
<p>A logical indicating if a legend must be added to the plot of
fitted CDF vs the empirical CDF.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_grid">grid</code></td>
<td>
<p>A logical indicating if a <code><a href="graphics.html#topic+grid">grid()</a></code> should be added to
the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cdf is evaluated at points given by the optional argument <code>data</code>.
If not provided, a regular grid of length <code>ngrid</code> for the evaluation
points is used.
</p>
<p>The quantiles are computed using bisection linear search algorithm.
</p>


<h3>Value</h3>

<p><code>cdfDensityBounded()</code> returns a list of <code>x</code> and <code>y</code> values providing,
respectively, the evaluation points and the estimated cdf.
</p>
<p><code>quantileDensityBounded()</code> returns a vector of quantiles.
</p>
<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Loader C. (1999), Local Regression and Likelihood. New York, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>, <code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded()</a></code>.
</p>
<p><code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>, <code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
dens &lt;- densityMclustBounded(x, lbound = 0)

xgrid &lt;- seq(-2, max(x), length=1000)
cdf &lt;- cdfDensityBounded(dens, xgrid)
str(cdf)
plot(xgrid, pchisq(xgrid, df = 3), type = "l", xlab = "x", ylab = "CDF")
lines(cdf, col = 4, lwd = 2)

q &lt;- quantileDensityBounded(dens, p = c(0.01, 0.1, 0.5, 0.9, 0.99))
cbind(quantile = q, cdf = cdfDensityBounded(dens, q)$y)
plot(cdf, type = "l", col = 4, xlab = "x", ylab = "CDF")
points(q, cdfDensityBounded(dens, q)$y, pch = 19, col = 4)

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)

xgrid &lt;- seq(-0.1, 1.1, length=1000)
cdf &lt;- cdfDensityBounded(dens, xgrid)
str(cdf)
plot(xgrid, pbeta(xgrid, 5, 1.5), type = "l", xlab = "x", ylab = "CDF")
lines(cdf, col = 4, lwd = 2)

q &lt;- quantileDensityBounded(dens, p = c(0.01, 0.1, 0.5, 0.9, 0.99))
cbind(quantile = q, cdf = cdfDensityBounded(dens, q)$y)
plot(cdf, type = "l", col = 4, xlab = "x", ylab = "CDF")
points(q, cdfDensityBounded(dens, q)$y, pch = 19, col = 4)



# univariate case with lower bound
x &lt;- rchisq(200, 3)
dens &lt;- densityMclustBounded(x, lbound = 0)
plot(dens, x, what = "diagnostic")
# or
densityMclustBounded.diagnostic(dens, type = "cdf")
densityMclustBounded.diagnostic(dens, type = "qq")

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
plot(dens, x, what = "diagnostic")
# or
densityMclustBounded.diagnostic(dens, type = "cdf")
densityMclustBounded.diagnostic(dens, type = "qq")


</code></pre>

<hr>
<h2 id='densityMclustBounded'>Model-based mixture density estimation for bounded data</h2><span id='topic+densityMclustBounded'></span><span id='topic+print.densityMclustBounded'></span><span id='topic+summary.densityMclustBounded'></span><span id='topic+print.summary.densityMclustBounded'></span>

<h3>Description</h3>

<p>Density estimation for bounded data via transformation-based approach for
Gaussian mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityMclustBounded(
  data,
  G = NULL,
  modelNames = NULL,
  criterion = c("BIC", "ICL"),
  lbound = NULL,
  ubound = NULL,
  lambda = c(-3, 3),
  prior = NULL,
  initialization = NULL,
  nstart = 25,
  parallel = FALSE,
  seed = NULL,
  ...
)

## S3 method for class 'densityMclustBounded'
summary(object, parameters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="densityMclustBounded_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If a
matrix or data frame, rows correspond to observations and columns correspond
to variables.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_g">G</code></td>
<td>
<p>An integer vector specifying the numbers of mixture components. By
default <code>G=1:3</code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_modelnames">modelNames</code></td>
<td>
<p>A vector of character strings indicating the Gaussian
mixture models to be fitted on the transformed-data space.  See
<code><a href="mclust.html#topic+mclustModelNames">mclust::mclustModelNames()</a></code> for a descripton of available models.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_criterion">criterion</code></td>
<td>
<p>A character string specifying the information criterion for
model selection. Possible values are <code>BIC</code> (default) or <code>ICL</code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_lbound">lbound</code></td>
<td>
<p>Numeric vector proving lower bounds for variables.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_ubound">ubound</code></td>
<td>
<p>Numeric vector proving upper bounds for variables.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector providing the range (min and max) of searched
values for the transformation parameter(s). If a matrix is provided, then
for each variable a row should be provided containing the range of lambda
values for the transformation parameter. If a variable must have a fixed
lambda value, the provided min and max values should be equal. See examples
below.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_prior">prior</code></td>
<td>
<p>A function specifying a prior for Bayesian regularization of
Gaussian mixtures. See <code><a href="mclust.html#topic+priorControl">mclust::priorControl()</a></code> for details.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_initialization">initialization</code></td>
<td>
<p>A list containing one or more of the following
components:
</p>

<ul>
<li> <p><code>noise</code> A logical or numeric vector indicating an initial guess as to
which observations are noise in the data. If numeric the entries should
correspond to row indexes of the data. If logical an automatic
entropy-based guess of noisy observations is made. When supplied, a noise
term will be added to the model in the estimation.
</p>
</li>
<li> <p><code>Vinv</code> When a noise component is included in the model, this is a
numerical optional argument providing the reciprocal of the volume of the
data.  By default, the <code><a href="mclust.html#topic+hypvol">mclust::hypvol()</a></code> is used on the transformed data
from a preliminary model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_nstart">nstart</code></td>
<td>
<p>An integer value specifying the number of replications of
k-means clustering to be used for initializing the EM algorithm. See
<code><a href="stats.html#topic+kmeans">kmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_parallel">parallel</code></td>
<td>
<p>An optional argument which allows to specify if the search
over all possible models should be run sequentially (default) or in
parallel.
</p>
<p>For a single machine with multiple cores, possible values are:
</p>

<ul>
<li><p> a logical value specifying if parallel computing should be used (<code>TRUE</code>)
or not (<code>FALSE</code>, default) for evaluating the fitness function;
</p>
</li>
<li><p> a numerical value which gives the number of cores to employ. By default,
this is obtained from the function <code><a href="parallel.html#topic+detectCores">parallel::detectCores()</a></code>;
</p>
</li>
<li><p> a character string specifying the type of parallelisation to use. This
depends on system OS: on Windows OS only <code>"snow"</code> type functionality is
available, while on Unix/Linux/Mac OSX both <code>"snow"</code> and <code>"multicore"</code>
(default) functionalities are available.
</p>
</li></ul>

<p>In all the cases described above, at the end of the search the cluster is
automatically stopped by shutting down the workers.
</p>
<p>If a cluster of multiple machines is available, evaluation of the fitness
function can be executed in parallel using all, or a subset of, the cores
available to the machines belonging to the cluster. However, this option
requires more work from the user, who needs to set up and register a
parallel back end.  In this case the cluster must be explicitely stopped
with <code><a href="parallel.html#topic+makeCluster">parallel::stopCluster()</a></code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_seed">seed</code></td>
<td>
<p>An integer value containing the random number generator state.
This argument can be used to replicate the result of k-means initialisation
strategy. Note that if parallel computing is required, the <span class="pkg">doRNG</span>
package must be installed.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>'densityMclustBounded'</code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_parameters">parameters</code></td>
<td>
<p>A logical, if <code>TRUE</code> the estimated parameters of mixture
components are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code>vignette("mclustAddons")</code>
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'densityMclustBounded'</code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.densityMclustBounded">predict.densityMclustBounded()</a></code>, <code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
xgrid &lt;- seq(-2, max(x), length=1000)
f &lt;- dchisq(xgrid, 3)  # true density
dens &lt;- densityMclustBounded(x, lbound = 0)
summary(dens)
summary(dens, parameters = TRUE)
plot(dens, what = "BIC")
plot(dens, what = "density")
lines(xgrid, f, lty = 2)
plot(dens, what = "density", data = x, breaks = 15)

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
xgrid &lt;- seq(-0.1, 1.1, length=1000)
f &lt;- dbeta(xgrid, 5, 1.5)  # true density
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
summary(dens)
plot(dens, what = "BIC")
plot(dens, what = "density")
plot(dens, what = "density", data = x, breaks = 9)

# bivariate case with lower bounds
x1 &lt;- rchisq(200, 3)
x2 &lt;- 0.5*x1 + sqrt(1-0.5^2)*rchisq(200, 5)
x &lt;- cbind(x1, x2)
plot(x)
dens &lt;- densityMclustBounded(x, lbound = c(0,0))
summary(dens, parameters = TRUE)
plot(dens, what = "BIC")
plot(dens, what = "density")
plot(dens, what = "density", type = "hdr")
plot(dens, what = "density", type = "persp")
# specify different ranges for the lambda values of each variable
dens1 &lt;- densityMclustBounded(x, lbound = c(0,0), 
                              lambda = matrix(c(-2,2,0,1), 2, 2, byrow=TRUE))
# set lambda = 0 fixed for the second variable
dens2 &lt;- densityMclustBounded(x, lbound = c(0,0), 
                              lambda = matrix(c(0,1,0,0), 2, 2, byrow=TRUE))

dens[c("lambdaRange", "lambda", "loglik", "df")]
dens1[c("lambdaRange", "lambda", "loglik", "df")]
dens2[c("lambdaRange", "lambda", "loglik", "df")]


</code></pre>

<hr>
<h2 id='EntropyGMM'>Gaussian mixture-based estimation of entropy</h2><span id='topic+EntropyGMM'></span><span id='topic+EntropyGMM.densityMclust'></span><span id='topic+EntropyGMM.Mclust'></span><span id='topic+EntropyGMM.densityMclustBounded'></span><span id='topic+EntropyGMM.matrix'></span><span id='topic+EntropyGMM.data.frame'></span><span id='topic+EntropyGauss'></span><span id='topic+nats2bits'></span><span id='topic+bits2nats'></span>

<h3>Description</h3>

<p>Compute an estimate of the (differential) entropy from a Gaussian Mixture
Model (GMM) fitted using the <em>mclust</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EntropyGMM(object, ...)

## S3 method for class 'densityMclust'
EntropyGMM(object, ...)

## S3 method for class 'densityMclustBounded'
EntropyGMM(object, ...)

## S3 method for class 'Mclust'
EntropyGMM(object, ...)

## S3 method for class 'data.frame'
EntropyGMM(object, ...)

## S3 method for class 'matrix'
EntropyGMM(object, ...)

EntropyGauss(sigma)

nats2bits(x)

bits2nats(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EntropyGMM_+3A_object">object</code></td>
<td>
<p>An object of class <code>'Mclust'</code>, <code>'densityMclust'</code>, or
<code>'densityMclustBounded'</code>, obtained by fitting a Gaussian mixture via,
respectively, <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>, <code><a href="mclust.html#topic+densityMclust">mclust::densityMclust()</a></code>, and
<code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.
</p>
<p>If a <code>matrix</code> or <code>data.frame</code> is provided as input, a GMM using the
provided data is estimated preliminary to computing the entropy.
In this case further arguments can be provided to control the fitted model
(e.g. number of mixture components and/or covariances decomposition).</p>
</td></tr>
<tr><td><code id="EntropyGMM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="EntropyGMM_+3A_sigma">sigma</code></td>
<td>
<p>A symmetric covariance matrix.</p>
</td></tr>
<tr><td><code id="EntropyGMM_+3A_x">x</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code>vignette("mclustAddons")</code>
</p>


<h3>Value</h3>


<ul>
<li> <p><code>EntropyGMM()</code> returns an estimate of the entropy based on a
estimated Gaussian mixture model (GMM) fitted using the <strong>mclust</strong>
package. If a matrix of data values is provided, a GMM is preliminary
fitted to the data and then the entropy computed.
</p>
</li>
<li> <p><code>EntropyGauss()</code> returns the entropy for a multivariate Gaussian
distribution with covariance matrix <code>sigma</code>.
</p>
</li>
<li> <p><code>nats2bits()</code> and <code>bits2nats()</code> convert input values in nats to
bits, and viceversa. Information-theoretic quantities have different
units depending on the base of the logarithm used: nats are expressed
in base-2 logarithms, whereas bits in natural logarithms.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Robin S. and Scrucca L. (2023) Mixture-based estimation of
entropy. <em>Computational Statistics &amp; Data Analysis</em>, 177, 107582.
<a href="https://doi.org/10.1016/j.csda.2022.107582">doi:10.1016/j.csda.2022.107582</a>
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>, <code><a href="mclust.html#topic+densityMclust">mclust::densityMclust()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X = iris[,1:4]
mod = densityMclust(X, plot = FALSE)
h = EntropyGMM(mod)
h
bits2nats(h)
EntropyGMM(X)


</code></pre>

<hr>
<h2 id='GaussianMixtureMEM'>Modal EM algorithm for Gaussian Mixtures</h2><span id='topic+GaussianMixtureMEM'></span>

<h3>Description</h3>

<p>A function implementing a fast and efficient Modal EM algorithm for Gaussian
mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianMixtureMEM(
  data,
  pro,
  mu,
  sigma,
  control = list(eps = 1e-05, maxiter = 1000, stepsize = function(t) 1 - exp(-0.1 * t),
    denoise = TRUE, alpha = 0.01, keep.path = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GaussianMixtureMEM_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations.
Categorical variables are not allowed. If a matrix or data frame, rows
correspond to observations (<code class="reqn">n</code>) and columns correspond to variables
(<code class="reqn">d</code>).</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_pro">pro</code></td>
<td>
<p>A <code class="reqn">(G \times 1)</code> vector of mixing probabilities for
a Gaussian mixture of <code class="reqn">G</code> components.</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_mu">mu</code></td>
<td>
<p>A <code class="reqn">(d \times G)</code> matrix of component means for a
<code class="reqn">d</code>-variate Gaussian mixture of <code class="reqn">G</code> components.</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_sigma">sigma</code></td>
<td>
<p>A <code class="reqn">(d \times d \times G)</code> array of component
covariance matrices for a <code class="reqn">d</code>-variate Gaussian mixture of <code class="reqn">G</code>
components.</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_control">control</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;eps, maxiter&#8288;</code> Numerical values setting the tolerance and the maximum
number of iterations of the MEM algorithm;
</p>
</li>
<li> <p><code>stepsize</code> A function controlling the step size of the MEM algorithm;
</p>
</li>
<li> <p><code>denoise</code> A logical, if <code>TRUE</code> a denoising procedure is used when
<code class="reqn">d &gt; 1</code> to discard all modes whose density is negligible;
</p>
</li>
<li> <p><code>alpha</code> A numerical value used when <code>denoise = TRUE</code> for computing the
hypervolume of central <code class="reqn">(1-\alpha)100</code> region of a
multivariate Gaussian;
</p>
</li>
<li> <p><code>keep.path</code> A logical controlling whether or not the full paths
to modes must be returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>

<ul>
<li> <p><code>n</code> The number of input data points.
</p>
</li>
<li> <p><code>d</code> The number of variables/features.
</p>
</li>
<li> <p><code>parameters</code> The Gaussian mixture parameters.
</p>
</li>
<li> <p><code>iter</code> The number of iterations of MEM algorithm.
</p>
</li>
<li> <p><code>nmodes</code> The number of modes estimated by the MEM algorithm.
</p>
</li>
<li> <p><code>modes</code> The coordinates of modes estimated by MEM algorithm.
</p>
</li>
<li> <p><code>path</code> If requested, the coordinates of full paths to modes for each data point.
</p>
</li>
<li> <p><code>logdens</code> The log-density at the estimated modes.
</p>
</li>
<li> <p><code>logvol</code> The log-volume used for denoising (if requested).
</p>
</li>
<li> <p><code>classification</code> The modal clustering classification of input data points.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for
Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4,
305–314. <a href="https://doi.org/%2010.1002/sam.11527">doi: 10.1002/sam.11527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MclustMEM">MclustMEM()</a></code>.
</p>

<hr>
<h2 id='GMMlogreturn'>Modeling log-returns distribution via Gaussian Mixture Models</h2><span id='topic+GMMlogreturn'></span><span id='topic+summary.GMMlogreturn'></span>

<h3>Description</h3>

<p>Gaussian mixtures for modeling the distribution of financial log-returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GMMlogreturn(y, ...)

## S3 method for class 'GMMlogreturn'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GMMlogreturn_+3A_y">y</code></td>
<td>
<p>A numeric vector providing the log-returns of a financial stock.</p>
</td></tr>
<tr><td><code id="GMMlogreturn_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>. For a full
description of available arguments see the corresponding help page.</p>
</td></tr>
<tr><td><code id="GMMlogreturn_+3A_object">object</code></td>
<td>
<p>An object of class <code>'GMMlogreturn'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">P_t</code> be the price of a financial stock for the current time frame
(day for instance), and <code class="reqn">P_{t-1}</code> the price of the previous time frame.
The log-return at time <code class="reqn">t</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> 
  y_t = \log( \frac{P_t}{P_{t-1}} ) 
</code>
</p>

<p>A univariate heteroscedastic GMM using Bayesian regularization
(as described in <code><a href="mclust.html#topic+priorControl">mclust::priorControl()</a></code>) is fitted to the observed
log-returns. The number of mixture components is automatically selected
by BIC, unless specified with the optional <code>G</code> argument.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'GMMlogreturn'</code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2024) Entropy-based volatility analysis of financial
log-returns using Gaussian mixture models. <em>Entropy</em>, 26(11), 907.
<a href="https://doi.org/10.3390/e26110907">doi:10.3390/e26110907</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VaR.GMMlogreturn">VaR.GMMlogreturn()</a></code>, <code><a href="#topic+ES.GMMlogreturn">ES.GMMlogreturn()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gold)
head(gold)
mod = GMMlogreturn(gold$log.returns)
summary(mod)
plot(mod, what = "density", data = gold$log.returns,
     xlab = "log-returns", col = 4, lwd = 2)

</code></pre>

<hr>
<h2 id='gold'>Gold price log-returns</h2><span id='topic+gold'></span>

<h3>Description</h3>

<p>Gold price log-returns for the year 2023 obtained from Yahoo Finance using
the <code>quantmod</code> R package.
Code used to download, format, and save the data:
</p>
<pre>
gold = quantmod::getSymbols("GC=F", src = "yahoo", auto.assign = FALSE)
gold = quantmod::dailyReturn(gold, type = "log")
gold = data.frame("date" = as.Date(zoo::index(gold)),
                  "log.returns" = as.vector(gold$daily.returns), 
                  row.names = NULL)
</pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt>date</dt><dd><p>Date (format: yyyy-mmm-dd).</p>
</dd>
<dt>log.returns</dt><dd><p>Daily log-return.</p>
</dd>
</dl>


<hr>
<h2 id='mclustAddons-internal'>Internal <span class="pkg">mclustAddons</span> functions</h2><span id='topic+mclustAddons-internal'></span><span id='topic+as.MclustBounded'></span><span id='topic+as.MclustBounded.default'></span><span id='topic+as.MclustBounded.densityMclustBounded'></span><span id='topic+as.densityMclustBounded'></span><span id='topic+as.densityMclustBounded.default'></span><span id='topic+as.densityMclustBounded.MclustBounded'></span>

<h3>Description</h3>

<p>Internal functions not intended to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.MclustBounded(x, ...)

## Default S3 method:
as.MclustBounded(x, ...)

## S3 method for class 'densityMclustBounded'
as.MclustBounded(x, ...)

as.densityMclustBounded(x, ...)

## Default S3 method:
as.densityMclustBounded(x, ...)

## S3 method for class 'MclustBounded'
as.densityMclustBounded(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mclustAddons-internal_+3A_x">x</code></td>
<td>
<p>An object of class specific for the method.</p>
</td></tr>
<tr><td><code id="mclustAddons-internal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='MclustBounded'>Model-based clustering for bounded data</h2><span id='topic+MclustBounded'></span><span id='topic+print.MclustBounded'></span><span id='topic+summary.MclustBounded'></span><span id='topic+print.summary.MclustBounded'></span>

<h3>Description</h3>

<p>Clustering of bounded data via transformation-based approach for Gaussian
mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MclustBounded(data, ...)

## S3 method for class 'MclustBounded'
summary(object, classification = TRUE, parameters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MclustBounded_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If a
matrix or data frame, rows correspond to observations and columns correspond
to variables.</p>
</td></tr>
<tr><td><code id="MclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>. For a full
description of available arguments see the corresponding help page.</p>
</td></tr>
<tr><td><code id="MclustBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>'MclustBounded'</code>.</p>
</td></tr>
<tr><td><code id="MclustBounded_+3A_classification">classification</code></td>
<td>
<p>A logical, if <code>TRUE</code> a table of MAP
classification/clustering of observations is printed.</p>
</td></tr>
<tr><td><code id="MclustBounded_+3A_parameters">parameters</code></td>
<td>
<p>A logical, if <code>TRUE</code> the estimated parameters of mixture
components are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code>vignette("mclustAddons")</code>
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'MclustBounded'</code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>, <code><a href="#topic+predict.MclustBounded">predict.MclustBounded()</a></code>, <code><a href="#topic+plot.MclustBounded">plot.MclustBounded()</a></code>.
</p>

<hr>
<h2 id='MclustBoundedParameters'>Recover parameters in the original scale</h2><span id='topic+MclustBoundedParameters'></span>

<h3>Description</h3>

<p>Given a GMM for bounded data, computes the means and variances in the
original scale from the estimated mixture components parameters dataset
using simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MclustBoundedParameters(object, nsim = 1e+06, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MclustBoundedParameters_+3A_object">object</code></td>
<td>
<p>An object of class <code>'MclustBounded'</code> or <code>'densityMclustBounded'</code>.</p>
</td></tr>
<tr><td><code id="MclustBoundedParameters_+3A_nsim">nsim</code></td>
<td>
<p>An integer specifying the number of simulations to employ.</p>
</td></tr>
<tr><td><code id="MclustBoundedParameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x = rlnorm(1000, 0, 1)
mod = densityMclustBounded(x, lbound = 0, lambda = 0)
summary(mod, parameters = TRUE)
plot(mod, what = "density")
# transformed parameters (from log-normal distribution)
# mean
with(mod$parameters, 
     exp(mean + 0.5*variance$sigmasq))
# var
with(mod$parameters,
     (exp(variance$sigmasq) - 1)*exp(2*mean + variance$sigmasq))
# using simulations
MclustBoundedParameters(mod)


</code></pre>

<hr>
<h2 id='mclustMarginalParams'>Marginal parameters from fitted GMMs via mclust</h2><span id='topic+mclustMarginalParams'></span><span id='topic+gmm2margParams'></span>

<h3>Description</h3>

<p>Function to compute the marginal parameters from a fitted Gaussian mixture models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclustMarginalParams(object, ...)

gmm2margParams(pro, mu, sigma, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mclustMarginalParams_+3A_object">object</code></td>
<td>
<p>An object of class <code>Mclust</code> or <code>densityMclust</code>.</p>
</td></tr>
<tr><td><code id="mclustMarginalParams_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="mclustMarginalParams_+3A_pro">pro</code></td>
<td>
<p>A vector of mixing proportions for each mixture component.</p>
</td></tr>
<tr><td><code id="mclustMarginalParams_+3A_mu">mu</code></td>
<td>
<p>A matrix of mean vectors for each mixture component. For
a <code class="reqn">d</code>-variate dataset on <code class="reqn">G</code> components, the matrix has dimension
<code class="reqn">(d \times G)</code>.</p>
</td></tr>
<tr><td><code id="mclustMarginalParams_+3A_sigma">sigma</code></td>
<td>
<p>An array of covariance matrices for each mixture component.
For a <code class="reqn">d</code>-variate dataset on <code class="reqn">G</code> components, the array has dimension
<code class="reqn">(d \times d \times G)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code class="reqn">G</code>-component GMM with estimated mixture weight <code class="reqn">\pi_k</code>,
mean vector <code class="reqn">\mu_{k}</code>, and covariance matrix <code class="reqn">\Sigma_{k}</code>, for
mixture component <code class="reqn">k = 1, \dots, G</code>, then the marginal distribution has:
</p>

<ul>
<li><p> mean vector
</p>
<p style="text-align: center;"><code class="reqn">\mu = \sum_{k=1}^G \pi_k \mu_k</code>
</p>

</li>
<li><p> covariance matrix
</p>
<p style="text-align: center;"><code class="reqn">\Sigma = \sum_{k=1}^G \pi_k \Sigma_k + \pi_k (\mu_k - \mu)'(\mu_k -
\mu)</code>
</p>

</li></ul>



<h3>Value</h3>

<p>Returns a list of two components for the mean and covariance of the
marginal distribution.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Frühwirth-Schnatter S. (2006) <em>Finite Mixture and Markov
Switching Models</em>, Springer, Sec. 6.1.1
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>, <code><a href="mclust.html#topic+densityMclust">mclust::densityMclust()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = iris[,1:4]
mod = Mclust(x, G = 3)
mod$parameters$pro
mod$parameters$mean
mod$parameters$variance$sigma
mclustMarginalParams(mod)

</code></pre>

<hr>
<h2 id='MclustMEM'>Modal EM algorithm for Gaussian Mixtures fitted via <em>mclust</em> package</h2><span id='topic+MclustMEM'></span><span id='topic+print.MclustMEM'></span><span id='topic+summary.MclustMEM'></span><span id='topic+print.summary.MclustMEM'></span>

<h3>Description</h3>

<p>Modal-clustering estimation by applying the Modal EM algorithm to Gaussian
mixtures fitted using the <em>mclust</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MclustMEM(object, data = NULL, ...)

## S3 method for class 'MclustMEM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MclustMEM_+3A_object">object</code></td>
<td>
<p>An object of class <code>'Mclust'</code> or <code>'densityMclust'</code>
obtained by fitting a Gaussian mixture via, respectively, <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>
and <code><a href="mclust.html#topic+densityMclust">mclust::densityMclust()</a></code>.</p>
</td></tr>
<tr><td><code id="MclustMEM_+3A_data">data</code></td>
<td>
<p>If provided, a numeric vector, matrix, or data frame of
observations. If a matrix or data frame, rows correspond to observations
(<code class="reqn">n</code>) and columns correspond to variables (<code class="reqn">d</code>). If not provided,
the data used for fitting the Gaussian mixture model, and provided with the
<code>object</code> argument, are used.</p>
</td></tr>
<tr><td><code id="MclustMEM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code>vignette("mclustAddons")</code>
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'MclustMEM'</code> with elements described in
<code><a href="#topic+GaussianMixtureMEM">GaussianMixtureMEM()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for
Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4,
305–314. <a href="https://doi.org/10.1002/sam.11527">doi:10.1002/sam.11527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussianMixtureMEM">GaussianMixtureMEM()</a></code>, <code><a href="#topic+plot.MclustMEM">plot.MclustMEM()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Baudry_etal_2010_JCGS_examples, package = "mclust")

plot(ex4.1)
GMM &lt;- Mclust(ex4.1)
plot(GMM, what = "classification")
MEM &lt;- MclustMEM(GMM)
MEM
summary(MEM)
plot(MEM)

plot(ex4.4.2)
GMM &lt;- Mclust(ex4.4.2)
plot(GMM, what = "classification")
MEM &lt;- MclustMEM(GMM)
MEM
summary(MEM)
plot(MEM, addDensity = FALSE)

</code></pre>

<hr>
<h2 id='plot.densityMclustBounded'>Plotting method for model-based mixture density estimation for bounded data</h2><span id='topic+plot.densityMclustBounded'></span>

<h3>Description</h3>

<p>Plots for <code>mclustDensityBounded</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densityMclustBounded'
plot(x, what = c("BIC", "density", "diagnostic"), data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.densityMclustBounded_+3A_x">x</code></td>
<td>
<p>An object of class <code>'densityMclustBounded'</code> obtained from a
call to <code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.densityMclustBounded_+3A_what">what</code></td>
<td>
<p>The type of graph requested:
</p>

<ul>
<li> <p><code>"BIC"</code> for a plot of BIC values for the estimated models versus the number
of components.
</p>
</li>
<li> <p><code>"density"</code> for a plot of estimated density; if <code>data</code> is also provided the
density is plotted over the given data points.
</p>
</li>
<li> <p><code>"diagnostic"</code> for diagnostic plots (only available for the one-dimensional
case).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.densityMclustBounded_+3A_data">data</code></td>
<td>
<p>Optional data points.</p>
</td></tr>
<tr><td><code id="plot.densityMclustBounded_+3A_...">...</code></td>
<td>
<p>Further available arguments:
</p>

<ul>
<li><p> For 1-dimensional data:<br />
<code style="white-space: pre;">&#8288;hist.col = "lightgrey", hist.border = "white", breaks = "Sturges"&#8288;</code>
</p>
</li>
<li><p> For 2-dimensional data:<br />
<code style="white-space: pre;">&#8288;type = c("contour", "hdr", "image", "persp"),&#8288;</code>
<code style="white-space: pre;">&#8288;transformation = c("none", "log", "sqrt")},&#8288;</code>
<code style="white-space: pre;">&#8288;grid = 100, nlevels = 11, levels = NULL,&#8288;</code>
<code style="white-space: pre;">&#8288;prob = c(0.25, 0.5, 0.75),&#8288;</code>
<code style="white-space: pre;">&#8288;col = grey(0.6), color.palette = blue2grey.colors,&#8288;</code>
<code style="white-space: pre;">&#8288;points.col = 1, points.cex = 0.8, points.pch = 1&#8288;</code>
</p>
</li>
<li><p> For <code class="reqn">d &gt; 2</code>-dimensional data:<br />
<code style="white-space: pre;">&#8288;type = c("contour", "hdr"), gap = 0.2, grid = 100,&#8288;</code>
<code style="white-space: pre;">&#8288;nlevels = 11, levels = NULL, prob = c(0.25, 0.5, 0.75),&#8288;</code>
<code style="white-space: pre;">&#8288;col = grey(0.6), color.palette = blue2grey.colors,&#8288;</code>
<code style="white-space: pre;">&#8288;code{points.col = 1, points.cex = 0.8, points.pch = 1&#8288;</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>, <code><a href="#topic+predict.densityMclustBounded">predict.densityMclustBounded()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
dens &lt;- densityMclustBounded(x, lbound = 0)
plot(dens, what = "BIC")
plot(dens, what = "density", data = x, breaks = 15)

# univariate case with lower &amp; upper bound
x &lt;- rbeta(200, 5, 1.5)
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
plot(dens, what = "BIC")
plot(dens, what = "density", data = x, breaks = 9)

# bivariate case with lower bounds
x1 &lt;- rchisq(200, 3)
x2 &lt;- 0.5*x1 + sqrt(1-0.5^2)*rchisq(200, 5)
x &lt;- cbind(x1, x2)
dens &lt;- densityMclustBounded(x, lbound = c(0,0))
plot(dens, what = "density")
plot(dens, what = "density", data = x)
plot(dens, what = "density", type = "hdr")
plot(dens, what = "density", type = "persp")

</code></pre>

<hr>
<h2 id='plot.MclustBounded'>Plotting method for model-based clustering of bounded data</h2><span id='topic+plot.MclustBounded'></span>

<h3>Description</h3>

<p>Plotting method for model-based clustering of bounded data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MclustBounded'
plot(x, what = c("BIC", "classification", "uncertainty"), dimens = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MclustBounded_+3A_x">x</code></td>
<td>
<p>An object of class <code>'MclustBounded'</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustBounded_+3A_what">what</code></td>
<td>
<p>A string specifying the type of graph requested.
Available choices are:
</p>

<ul>
<li> <p><code>"BIC"</code> Plot of BIC values used for choosing the number of clusters.
</p>
</li>
<li> <p><code>"classification"</code> Plot showing the clustering. For data in more than two
dimensions, a scatterplot of pairwise coordinate projections using the
specified <code>dimens</code> is produced.
</p>
</li>
<li> <p><code>"uncertainty"</code> Plot of classification uncertainty. For data in more than
two dimensions, a scatterplot of pairwise coordinate projections using the
specified <code>dimens</code> is produced.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.MclustBounded_+3A_dimens">dimens</code></td>
<td>
<p>A vector of integers specifying the dimensions of the coordinate
projections.</p>
</td></tr>
<tr><td><code id="plot.MclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>

<hr>
<h2 id='plot.MclustMEM'>Plotting method for modal-clustering based on Gaussian Mixtures</h2><span id='topic+plot.MclustMEM'></span>

<h3>Description</h3>

<p>Plots for <code>MclustMEM</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MclustMEM'
plot(
  x,
  dimens = NULL,
  addDensity = TRUE,
  addPoints = TRUE,
  symbols = NULL,
  colors = NULL,
  cex = NULL,
  labels = NULL,
  cex.labels = NULL,
  gap = 0.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.MclustMEM_+3A_x">x</code></td>
<td>
<p>An object of class <code>'densityMclustBounded'</code> obtained from a
call to <code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_dimens">dimens</code></td>
<td>
<p>A vector of integers specifying the dimensions of the
coordinate projections.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_adddensity">addDensity</code></td>
<td>
<p>A logical indicating whether or not to add density
estimates to the plot.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_addpoints">addPoints</code></td>
<td>
<p>A logical indicating whether or not to add data points to
the plot.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_symbols">symbols</code></td>
<td>
<p>Either an integer or character vector assigning a plotting
symbol to each unique class in <code>classification</code>. Elements in
<code>symbols</code> correspond to classes in order of appearance in the sequence
of observations (the order used by the function <code>unique</code>). The default
is given by <code>mclust.options("classPlotSymbols")</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_colors">colors</code></td>
<td>
<p>Either an integer or character vector assigning a color to
each unique class in <code>classification</code>. Elements in <code>colors</code>
correspond to classes in order of appearance in the sequence of observations
(the order used by the function <code>unique</code>). The default is given by
<code>mclust.options("classPlotColors")</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_cex">cex</code></td>
<td>
<p>A vector of numerical values specifying the size of the plotting
symbol for each unique class in <code>classification</code>. By default <code>cex
= 1</code> for all classes is used.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings for labelling the variables. The
default is to use the column dimension names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_cex.labels">cex.labels</code></td>
<td>
<p>A numerical value specifying the size of the text labels.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_gap">gap</code></td>
<td>
<p>A numerical argument specifying the distance between subplots
(see <code><a href="graphics.html#topic+pairs">pairs()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for
Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4,
305–314. <a href="https://doi.org/%2010.1002/sam.11527">doi: 10.1002/sam.11527</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MclustMEM">MclustMEM()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1-d example
GMM &lt;- Mclust(iris$Petal.Length)
MEM &lt;- MclustMEM(GMM)
plot(MEM)

# 2-d example
data(Baudry_etal_2010_JCGS_examples)
GMM &lt;- Mclust(ex4.1)
MEM &lt;- MclustMEM(GMM)
plot(MEM)
plot(MEM, addPoints = FALSE)
plot(MEM, addDensity = FALSE)

# 3-d example
GMM &lt;- Mclust(ex4.4.2)
MEM &lt;- MclustMEM(GMM)
plot(MEM)
plot(MEM, addPoints = FALSE)
plot(MEM, addDensity = FALSE)

</code></pre>

<hr>
<h2 id='predict.densityMclustBounded'>Model-based mixture density estimation for bounded data</h2><span id='topic+predict.densityMclustBounded'></span>

<h3>Description</h3>

<p>Predict density estimates for univariate and multivariate bounded data
based on Gaussian finite mixture models estimated by
<code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densityMclustBounded'
predict(
  object,
  newdata,
  what = c("dens", "cdens", "z"),
  logarithm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.densityMclustBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>'densityMclustBounded'</code> resulting
from a call to <code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_newdata">newdata</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If
missing the density is computed for the input data obtained from the call to
<code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_what">what</code></td>
<td>
<p>A character string specifying what to retrieve: <code>"dens"</code>
returns a vector of values for the mixture density; <code>"cdens"</code> returns a
matrix of component densities for each mixture component (along the
columns); <code>"z"</code> returns a matrix of component posterior probabilities.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_logarithm">logarithm</code></td>
<td>
<p>A logical value indicating whether or not the logarithm of
the densities/probabilities should be returned.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or a matrix of values evaluated at <code>newdata</code> depending
on the argument <code>what</code> (see above).
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded()</a></code>, <code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- sample(0:1, size = 200, replace = TRUE, prob = c(0.6, 0.4))
x &lt;- y*rchisq(200, 3) + (1-y)*rchisq(200, 10)
dens &lt;- densityMclustBounded(x, lbound = 0)
summary(dens)
plot(dens, what = "density", data = x, breaks = 11)

xgrid &lt;- seq(0, max(x), length = 201)
densx &lt;- predict(dens, newdata = xgrid, what = "dens")
cdensx &lt;- predict(dens, newdata = xgrid, what = "cdens")
cdensx &lt;- sweep(cdensx, MARGIN = 2, FUN = "*", dens$parameters$pro)
plot(xgrid, densx, type = "l", lwd = 2)
matplot(xgrid, cdensx, type = "l", col = 3:4, lty = 2:3, lwd = 2, add = TRUE)

z &lt;- predict(dens, newdata = xgrid, what = "z")
matplot(xgrid, z, col = 3:4, lty = 2:3, lwd = 2, ylab = "Posterior probabilities")

</code></pre>

<hr>
<h2 id='predict.MclustBounded'>Model-based clustering estimation for bounded data</h2><span id='topic+predict.MclustBounded'></span>

<h3>Description</h3>

<p>Predict clustering for univariate and multivariate bounded data based on
Gaussian finite mixture models estimated by <code><a href="#topic+MclustBounded">MclustBounded()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MclustBounded'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.MclustBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>'MclustBounded'</code> resulting
from a call to <code><a href="#topic+MclustBounded">MclustBounded()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.MclustBounded_+3A_newdata">newdata</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If
missing the density is computed for the input data obtained from the call to
<code><a href="#topic+MclustBounded">MclustBounded()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.MclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of with the following components:
</p>

<ul>
<li> <p><code>classification</code> A factor of predicted cluster labels for newdata.
</p>
</li>
<li> <p><code>z</code> A matrix whose <code class="reqn">[i,k]</code>th entry is the probability that <code class="reqn">i</code>th
observation in <code>newdata</code> belongs to the <code class="reqn">k</code>th cluster.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MclustBounded">MclustBounded()</a></code>, <code><a href="#topic+plot.MclustBounded">plot.MclustBounded()</a></code>.
</p>

<hr>
<h2 id='racial'>Racial data</h2><span id='topic+racial'></span>

<h3>Description</h3>

<p>Proportion of white student enrollment in 56 school districts in Nassau
County (Long Island, New York), for the 1992-1993 school year.
</p>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt>District</dt><dd><p>School district.</p>
</dd>
<dt>PropWhite</dt><dd><p>Proportion of white student enrolled.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simonoff, S.J. (1996) Smoothing Methods in Statistics, Springer-Verlag,
New York, p. 52
</p>

<hr>
<h2 id='rangepowerTransform'>Range–power transformation</h2><span id='topic+rangepowerTransform'></span><span id='topic+rangepowerBackTransform'></span>

<h3>Description</h3>

<p>Functions to compute univariate range–power transformation and its
back-transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangepowerTransform(x, lbound = -Inf, ubound = +Inf, lambda = 1)

rangepowerBackTransform(y, lbound = -Inf, ubound = +Inf, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rangepowerTransform_+3A_x">x</code></td>
<td>
<p>A numeric vector of data values.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_lbound">lbound</code></td>
<td>
<p>A numerical value of variable lower bound.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_ubound">ubound</code></td>
<td>
<p>A numerical value of variable upper bound.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_lambda">lambda</code></td>
<td>
<p>A numerical value for the power transformation.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_y">y</code></td>
<td>
<p>A numeric vector of transformed data values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>range-power transformation</em> can be applied to variables with
bounded support.
</p>
<p><strong>Lower bound case</strong>
</p>
<p>Suppose <code class="reqn">x</code> is a univariate random variable with lower bounded support
<code class="reqn">\mathcal{S}_{\mathcal{X}} \equiv (l,\infty)</code>, where <code class="reqn">l &gt; -\infty</code>.
Consider a preliminary <em>range transformation</em> defined as <code class="reqn">x \mapsto
(x - l)</code>, which maps <code class="reqn">\mathcal{S}_{\mathcal{X}} \to \mathbb{R}^{+}</code>.<br />
The <em>range-power transformation</em> is a continuous monotonic transformation
defined as
</p>
<p style="text-align: center;"><code class="reqn"> t(x; \lambda) = 
\begin{cases} \dfrac{(x-l)^{\lambda} - 1}{\lambda} &amp; 
\quad\text{if}\; \lambda \ne 0 \\[1ex] \log(x-l) &amp;
\quad\text{if}\; \lambda = 0 
\end{cases} </code>
</p>

<p>with back-transformation function
</p>
<p style="text-align: center;"><code class="reqn"> t^{-1}(y; \lambda) = 
\begin{cases} (\lambda y + 1)^{1/\lambda} + l &amp;
\quad\text{if}\; \lambda \ne 0 \\[1ex] \exp(y)+l &amp; 
\quad\text{if}\; \lambda = 0 
\end{cases} </code>
</p>

<p><strong>Lower and upper bound case</strong>
</p>
<p>Suppose <code class="reqn">x</code> is a univariate random variable with bounded support
<code class="reqn">\mathcal{S}_{\mathcal{X}} \equiv (l,u)</code>, where <code class="reqn">-\infty &lt; l &lt; u &lt;
+\infty</code>. Consider a preliminary <em>range transformation</em> defined as
<code class="reqn">x \mapsto (x - l)/(u - x)</code>, which maps <code class="reqn">\mathcal{S}_{\mathcal{X}}
\to \mathbb{R}^{+}</code>.<br />
In this case, the <em>range-power transformation</em> is a continuous monotonic
transformation defined as
</p>
<p style="text-align: center;"><code class="reqn"> t(x; \lambda) =
\begin{cases} 
\dfrac{ \left( \dfrac{x-l}{u-x} \right)^{\lambda} - 1}{\lambda} &amp; 
\quad\text{if}\; \lambda \ne 0 \\[2ex] 
\log \left( \dfrac{x-l}{u-x} \right) &amp; 
\quad\text{if}\; \lambda = 0, 
\end{cases} </code>
</p>
<p> with back-transformation function
</p>
<p style="text-align: center;"><code class="reqn"> t^{-1}(y; \lambda) = 
\begin{cases}
\dfrac{l + u (\lambda y + 1)^{1/\lambda}}{1+(\lambda y + 1)^{1/\lambda}} &amp;
\quad\text{if}\; \lambda \ne 0 \\[1ex] \dfrac{l + u \exp(y)}{1+\exp(y)} &amp;
\quad\text{if}\; \lambda = 0 
\end{cases} </code>
</p>



<h3>Value</h3>

<p>Returns a vector of transformed or back-transformed values.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian
mixture density estimation for bounded data. <em>Biometrical Journal</em>,
61:4, 873–888. <a href="https://doi.org/10.1002/bimj.201800174">doi:10.1002/bimj.201800174</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Lower bound case
x = rchisq(1000, 5)
y = rangepowerTransform(x, lbound = 0, lambda = 1/3)
par(mfrow=c(2,2))
hist(x, main = NULL, breaks = 21); rug(x)
hist(y, xlab = "y = t(x)", main = NULL, breaks = 21); rug(y)
xx = rangepowerBackTransform(y, lbound = 0, lambda = 1/3)
hist(xx, xlab = "t^-1(y) = x", main = NULL, breaks = 21); rug(xx)
plot(x, xx, ylab = "t^-1(y)"); abline(0,1)

# Lower and upper bound case
x = rbeta(1000, 2, 1)
y = rangepowerTransform(x, lbound = 0, ubound = 1, lambda = 0)
par(mfrow=c(2,2))
hist(x, main = NULL, breaks = 21); rug(x)
hist(y, xlab = "y = t(x)", main = NULL, breaks = 21); rug(y)
xx = rangepowerBackTransform(y, lbound = 0, ubound = 1, lambda = 0)
hist(xx, xlab = "t^-1(y) = x", main = NULL, breaks = 21); rug(xx)
plot(x, xx, ylab = "t^-1(y)"); abline(0,1)

</code></pre>

<hr>
<h2 id='suicide'>Suicide data</h2><span id='topic+suicide'></span>

<h3>Description</h3>

<p>Lengths of treatment spells (in days) of control patients in suicide study.
</p>


<h3>Format</h3>

<p>A vector of containing the lengths (days) of 86 spells of
psychiatric treatment undergone by patients used as controls in a study of
suicide risks.
</p>


<h3>Source</h3>

<p>Silverman, B. W. (1986) Density Estimation, Chapman &amp; Hall, Tab 2.1.
</p>

<hr>
<h2 id='VaR'>Financial risk measures</h2><span id='topic+VaR'></span><span id='topic+ES'></span>

<h3>Description</h3>

<p>Generic functions for computing Value-at-Risk (VaR) and Expected
Shortfall (ES).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaR(object, ...)

ES(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VaR_+3A_object">object</code></td>
<td>
<p>An object of class specific for the method.</p>
</td></tr>
<tr><td><code id="VaR_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='VaR.GMMlogreturn'>Risk measures from Gaussian mixtures modeling</h2><span id='topic+VaR.GMMlogreturn'></span><span id='topic+ES.GMMlogreturn'></span>

<h3>Description</h3>

<p>Value-at-Risk (VaR) and Expected Shortfall (ES) from the fit of
Gaussian mixtures provided by <code><a href="#topic+GMMlogreturn">GMMlogreturn()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GMMlogreturn'
VaR(object, alpha, ...)

## S3 method for class 'GMMlogreturn'
ES(object, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VaR.GMMlogreturn_+3A_object">object</code></td>
<td>
<p>An object of class <code>'GMMlogreturn'</code>.</p>
</td></tr>
<tr><td><code id="VaR.GMMlogreturn_+3A_alpha">alpha</code></td>
<td>
<p>A vector of values in the interval <code class="reqn">(0,1)</code> for which
the risk measures should be calculated.</p>
</td></tr>
<tr><td><code id="VaR.GMMlogreturn_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>VaR(<code class="reqn">\alpha</code>) is the maximum potential loss over a specified time
horizon with probability equal to the confidence level <code class="reqn">1-\alpha</code>.
</p>
<p>ES(<code class="reqn">\alpha</code>) is the expected loss given that the loss exceeds the
VaR(<code class="reqn">\alpha</code>) level.
</p>


<h3>Value</h3>

<p>Returns a numerical value corresponding to VaR or ES at
given level(s).
</p>
<p>References:
</p>
<p>Ruppert Matteson (2015) Statistics and Data Analysis for Financial
Engineering, Springer, Chapter 19.
</p>
<p>Cizek Hardle Weron (2011) Statistical Tools for Finance
and Insurance, 2nd ed., Springer, Chapter 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z = sample(1:2, size = 250, replace = TRUE, prob = c(0.8, 0.2))
y = double(length(z))
y[z == 1] = rnorm(sum(z == 1), 0, 1)
y[z == 2] = rnorm(sum(z == 2), -0.5, 2)
GMM = GMMlogreturn(y)
alpha = seq(0.01, 0.1, by = 0.001)
matplot(alpha, data.frame(VaR = VaR(GMM, alpha),
                          ES = ES(GMM, alpha)),
        type = "l", col = c(2,4), lty = 1, lwd = 2,
        xlab = expression(alpha), ylab = "Loss")
legend("topright", col = c(2,4), lty = 1, lwd = 2,
       legend = c("VaR", "ES"), inset = 0.02)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
