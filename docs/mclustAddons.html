<!DOCTYPE html><html><head><title>Help for package mclustAddons</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mclustAddons}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cdfDensityBounded'>
<p>Cumulative distribution and quantiles of univariate model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#densityMclustBounded'><p>Model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#densityMclustBounded.diagnostic'><p>Diagnostic plots for <code>mclustDensityBounded</code> estimation</p></a></li>
<li><a href='#EntropyGMM'><p>Gaussian mixture-based estimation of entropy</p></a></li>
<li><a href='#GaussianMixtureMEM'><p>Modal EM algorithm for Gaussian Mixtures</p></a></li>
<li><a href='#mclustAddons-package'><p>Addons for the <span class="pkg">mclust</span> package</p></a></li>
<li><a href='#MclustMEM'><p>Modal EM algorithm for Gaussian Mixtures fitted via <em>mclust</em> package</p></a></li>
<li><a href='#plot.densityMclustBounded'><p>Plotting method for model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#plot.MclustMEM'><p>Plotting method for modal-clustering based on Gaussian Mixtures</p></a></li>
<li><a href='#predict.densityMclustBounded'><p>Model-based mixture density estimation for bounded data</p></a></li>
<li><a href='#racial'><p>Racial data</p></a></li>
<li><a href='#rangepowerTransform'><p>Range–power transformation</p></a></li>
<li><a href='#suicide'><p>Suicide data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Addons for the 'mclust' Package</td>
</tr>
<tr>
<td>Description:</td>
<td>Extend the functionality of the 'mclust' package for 
  Gaussian finite mixture modeling by including: 
  density estimation for data with bounded support 
  (Scrucca, 2019 &lt;<a href="https://doi.org/10.1002%2Fbimj.201800174">doi:10.1002/bimj.201800174</a>&gt;);
  modal clustering using MEM (Modal EM) algorithm for Gaussian mixtures 
  (Scrucca, 2021 &lt;<a href="https://doi.org/10.1002%2Fsam.11527">doi:10.1002/sam.11527</a>&gt;);
  entropy estimation via Gaussian mixture modeling
  (Robin &amp; Scrucca, 2023 &lt;<a href="https://doi.org/10.1016%2Fj.csda.2022.107582">doi:10.1016/j.csda.2022.107582</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), mclust (&ge; 6.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices, methods, foreach, iterators,
utils, Rcpp (&ge; 1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, doParallel, doRNG (&ge; 1.6), cli, crayon, knitr (&ge;
1.12), rmarkdown (&ge; 0.9)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mclust-org.github.io/mclustAddons/">https://mclust-org.github.io/mclustAddons/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 11:37:43 UTC; luca</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Scrucca [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Scrucca &lt;luca.scrucca@unipg.it&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-01 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cdfDensityBounded'>
Cumulative distribution and quantiles of univariate model-based mixture density estimation for bounded data
</h2><span id='topic+cdfDensityBounded'></span><span id='topic+quantileDensityBounded'></span>

<h3>Description</h3>

<p>Compute the cumulative density function (cdf) or quantiles of a one-dimensional density for bounded data estimated via transformation-based approach for Gaussian mixtures using <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdfDensityBounded(object, data, ngrid = 100, ...)
quantileDensityBounded(object, p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdfDensityBounded_+3A_object">object</code></td>
<td>
<p>a <code>densityMclustBounded</code> model object.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_data">data</code></td>
<td>
<p>a numeric vector of evaluation points.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_ngrid">ngrid</code></td>
<td>
<p>the number of points in a regular grid to be used as evaluation points if no <code>data</code> are provided.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_p">p</code></td>
<td>
<p>a numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="cdfDensityBounded_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cdf is evaluated at points given by the optional argument <code>data</code>. If not provided, a regular grid of length <code>ngrid</code> for the evaluation points is used. 
</p>
<p>The quantiles are computed using bisection linear search algorithm.
</p>


<h3>Value</h3>

<p><code>cdfDensityBounded</code> returns a list of <code>x</code> and <code>y</code> values providing, respectively, the evaluation points and the estimated cdf. 
</p>
<p><code>quantileDensityBounded</code> returns a vector of quantiles.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>, 
<code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
dens &lt;- densityMclustBounded(x, lbound = 0)

xgrid &lt;- seq(-2, max(x), length=1000)
cdf &lt;- cdfDensityBounded(dens, xgrid)
str(cdf)
plot(xgrid, pchisq(xgrid, df = 3), type = "l", xlab = "x", ylab = "CDF")
lines(cdf, col = 4, lwd = 2)

q &lt;- quantileDensityBounded(dens, p = c(0.01, 0.1, 0.5, 0.9, 0.99))
cbind(quantile = q, cdf = cdfDensityBounded(dens, q)$y)
plot(cdf, type = "l", col = 4, xlab = "x", ylab = "CDF")
points(q, cdfDensityBounded(dens, q)$y, pch = 19, col = 4)

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)

xgrid &lt;- seq(-0.1, 1.1, length=1000)
cdf &lt;- cdfDensityBounded(dens, xgrid)
str(cdf)
plot(xgrid, pbeta(xgrid, 5, 1.5), type = "l", xlab = "x", ylab = "CDF")
lines(cdf, col = 4, lwd = 2)

q &lt;- quantileDensityBounded(dens, p = c(0.01, 0.1, 0.5, 0.9, 0.99))
cbind(quantile = q, cdf = cdfDensityBounded(dens, q)$y)
plot(cdf, type = "l", col = 4, xlab = "x", ylab = "CDF")
points(q, cdfDensityBounded(dens, q)$y, pch = 19, col = 4)

</code></pre>

<hr>
<h2 id='densityMclustBounded'>Model-based mixture density estimation for bounded data</h2><span id='topic+densityMclustBounded'></span><span id='topic+print.densityMclustBounded'></span><span id='topic+summary.densityMclustBounded'></span><span id='topic+print.summary.densityMclustBounded'></span>

<h3>Description</h3>

<p>Density estimation for bounded data via transformation-based approach for Gaussian mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityMclustBounded(data, 
                     G = NULL, modelNames = NULL,
                     lbound = NULL, 
                     ubound = NULL, 
                     lambda = c(-3, 3),
                     prior = NULL,
                     noise = NULL,
                     nstart = 25,
                     parallel = FALSE,
                     seed = NULL,
                     ...)

## S3 method for class 'densityMclustBounded'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'densityMclustBounded'
summary(object, parameters = FALSE, classification = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityMclustBounded_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If a matrix or data frame, rows correspond to observations and columns correspond to variables.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_g">G</code></td>
<td>
<p>An integer vector specifying the numbers of mixture components. By default <code>G=1:3</code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_modelnames">modelNames</code></td>
<td>
<p>A vector of character strings indicating the Gaussian mixture models to be fitted on the transformed-data space.  
See <code><a href="mclust.html#topic+mclustModelNames">mclustModelNames</a></code> for a descripton of available models.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_lbound">lbound</code></td>
<td>
<p>Numeric vector proving lower bounds for variables.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_ubound">ubound</code></td>
<td>
<p>Numeric vector proving upper bounds for variables.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_lambda">lambda</code></td>
<td>
<p>A numeric vector providing the range of searched values for the transformation parameter(s).</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_prior">prior</code></td>
<td>
<p>A function specifying a prior for Bayesian regularization of Gaussian mixtures. See <code><a href="mclust.html#topic+priorControl">priorControl</a></code> for details.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_noise">noise</code></td>
<td>
<p>A specification for the noise component. Currently, not available.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_nstart">nstart</code></td>
<td>
<p>An integer value specifying the number of replications of k-means clustering to be used for initializing the EM algorithm. See <a href="stats.html#topic+kmeans">kmeans</a>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_parallel">parallel</code></td>
<td>

<p>An optional argument which allows to specify if the search over all possible models should be run sequentially (default) or in parallel. 
</p>
<p>For a single machine with multiple cores, possible values are: 
</p>

<ul>
<li><p> a logical value specifying if parallel computing should be used (<code>TRUE</code>) or not (<code>FALSE</code>, default) for evaluating the fitness function;
</p>
</li>
<li><p> a numerical value which gives the number of cores to employ. By default, this is obtained from the function <code><a href="parallel.html#topic+detectCores">detectCores</a></code>; 
</p>
</li>
<li><p> a character string specifying the type of parallelisation to use. This depends on system OS: on Windows OS only <code>"snow"</code> type functionality is available, while on Unix/Linux/Mac OSX both <code>"snow"</code> and <code>"multicore"</code> (default) functionalities are available.
</p>
</li></ul>

<p>In all the cases described above, at the end of the search the cluster is automatically stopped by shutting down the workers.
</p>
<p>If a cluster of multiple machines is available, evaluation of the fitness function can be executed in parallel using all, or a subset of, the cores available to the machines belonging to the cluster. However, this option requires more work from the user, who needs to set up and register a parallel back end. 
In this case the cluster must be explicitely stopped with <code><a href="parallel.html#topic+stopCluster">stopCluster</a></code>.
</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_seed">seed</code></td>
<td>
<p>An integer value containing the random number generator state. This argument can be used to replicate the result of k-means initialisation strategy. Note that if parallel computing is required, the <span class="pkg">doRNG</span> package must be installed.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_x">x</code>, <code id="densityMclustBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>"densityMclustBounded"</code>.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use for printing.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_parameters">parameters</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the parameters of mixture components are printed.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_classification">classification</code></td>
<td>
<p>Logical; if <code>TRUE</code>, the MAP classification/clustering of observations is printed.</p>
</td></tr>
<tr><td><code id="densityMclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"densityMclustBounded"</code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian mixture density estimation for bounded data. <em>Biometrical Journal</em>, 61:4, 873–888. https://doi.org/10.1002/bimj.201800174
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.densityMclustBounded">predict.densityMclustBounded</a></code>, 
<code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
xgrid &lt;- seq(-2, max(x), length=1000)
f &lt;- dchisq(xgrid, 3)  # true density
dens &lt;- densityMclustBounded(x, lbound = 0)
summary(dens)
summary(dens, parameters = TRUE)
plot(dens, what = "BIC")
plot(dens, what = "density")
lines(xgrid, f, lty = 2)
plot(dens, what = "density", data = x, breaks = 15)

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
xgrid &lt;- seq(-0.1, 1.1, length=1000)
f &lt;- dbeta(xgrid, 5, 1.5)  # true density
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
summary(dens)
plot(dens, what = "BIC")
plot(dens, what = "density")
plot(dens, what = "density", data = x, breaks = 9)

# bivariate case with lower bounds
x1 &lt;- rchisq(200, 3)
x2 &lt;- 0.5*x1 + sqrt(1-0.5^2)*rchisq(200, 5)
x &lt;- cbind(x1, x2)
plot(x)
dens &lt;- densityMclustBounded(x, lbound = c(0,0))
summary(dens, parameters = TRUE)
plot(dens, what = "BIC")
plot(dens, what = "density")
plot(dens, what = "density", type = "hdr")
plot(dens, what = "density", type = "persp")
</code></pre>

<hr>
<h2 id='densityMclustBounded.diagnostic'>Diagnostic plots for <code>mclustDensityBounded</code> estimation</h2><span id='topic+densityMclustBounded.diagnostic'></span>

<h3>Description</h3>

<p>Diagnostic plots for density estimation of bounded data via transformation-based approach of Gaussian mixtures.
Only available for the one-dimensional case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityMclustBounded.diagnostic(object, type = c("cdf", "qq"), 
                                col = c("black", "black"), 
                                lwd = c(2,1), lty = c(1,1), 
                                legend = TRUE, grid = TRUE, 
                                ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_object">object</code></td>
<td>
<p>An object of class <code>'mclustDensityBounded'</code> obtained from a call to <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code> function.</p>
</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_type">type</code></td>
<td>
<p>The type of graph requested:
</p>

<dl>
<dt><code>"cdf"</code> =</dt><dd><p>a plot of the estimated CDF versus the empirical distribution function.</p>
</dd>
<dt><code>"qq"</code> =</dt><dd><p>a Q-Q plot of sample quantiles versus the quantiles obtained from the inverse of the estimated cdf.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_col">col</code></td>
<td>
<p>A pair of values for the color to be used for plotting, respectively, the estimated CDF and the empirical cdf.</p>
</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_lwd">lwd</code></td>
<td>
<p>A pair of values for the line width to be used for plotting, respectively, the estimated CDF and the empirical cdf.</p>
</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_lty">lty</code></td>
<td>
<p>A pair of values for the line type to be used for plotting, respectively, the estimated CDF and the empirical cdf.</p>
</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_legend">legend</code></td>
<td>
<p>A logical indicating if a legend must be added to the plot of fitted CDF vs the empirical CDF.</p>
</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_grid">grid</code></td>
<td>
<p>A logical indicating if a <code><a href="graphics.html#topic+grid">grid</a></code> should be added to the plot.</p>
</td></tr>
<tr><td><code id="densityMclustBounded.diagnostic_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two diagnostic plots for density estimation in the one-dimensional case are discussed in Loader (1999, pp- 87-90).
</p>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Loader C. (1999), Local Regression and Likelihood. New York, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>, 
<code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
dens &lt;- densityMclustBounded(x, lbound = 0)
plot(dens, x, what = "diagnostic")
# or
densityMclustBounded.diagnostic(dens, type = "cdf")
densityMclustBounded.diagnostic(dens, type = "qq")

# univariate case with lower &amp; upper bounds
x &lt;- rbeta(200, 5, 1.5)
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
plot(dens, x, what = "diagnostic")
# or
densityMclustBounded.diagnostic(dens, type = "cdf")
densityMclustBounded.diagnostic(dens, type = "qq")

</code></pre>

<hr>
<h2 id='EntropyGMM'>Gaussian mixture-based estimation of entropy</h2><span id='topic+EntropyGMM'></span><span id='topic+EntropyGMM.densityMclust'></span><span id='topic+EntropyGMM.Mclust'></span><span id='topic+EntropyGMM.densityMclustBounded'></span><span id='topic+EntropyGMM.matrix'></span><span id='topic+EntropyGMM.data.frame'></span><span id='topic+EntropyGauss'></span><span id='topic+nats2bits'></span><span id='topic+bits2nats'></span>

<h3>Description</h3>

<p>Compute an estimate of the (differential) entropy from a Gaussian Mixture Model (GMM) fitted using the <em>mclust</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
EntropyGMM(object, ...) 

## S3 method for class 'densityMclust'
EntropyGMM(object, ...)
## S3 method for class 'Mclust'
EntropyGMM(object, ...)
## S3 method for class 'densityMclustBounded'
EntropyGMM(object, ...)
## S3 method for class 'matrix'
EntropyGMM(object, ...)
## S3 method for class 'data.frame'
EntropyGMM(object, ...)

EntropyGauss(sigma)

nats2bits(x)
bits2nats(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EntropyGMM_+3A_object">object</code></td>
<td>
<p>An object of class <code>'Mclust'</code>, <code>'densityMclust'</code>, or <code>'densityMclustBounded'</code>, obtained by fitting a Gaussian mixture via, respectively, <code><a href="mclust.html#topic+Mclust">Mclust</a>()</code>, <code><a href="mclust.html#topic+densityMclust">densityMclust</a>()</code>, and <code><a href="#topic+densityMclustBounded">densityMclustBounded</a>()</code>. 
If a <code>'matrix'</code> or <code>'data.frame'</code> is provided as input, a GMM using the provided data is estimated preliminary to computing the entropy. In this case further arguments can be provided to control the fitted model (e.g. number of mixture components and/or covariances decomposition).</p>
</td></tr>
<tr><td><code id="EntropyGMM_+3A_sigma">sigma</code></td>
<td>
<p>A symmetric covariance matrix.</p>
</td></tr>
<tr><td><code id="EntropyGMM_+3A_x">x</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="EntropyGMM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>EntropyGMM()</code> returns an estimate of the entropy based on a estimated Gaussian mixture model (GMM) fitted using the <em>mclust</em> package. If a matrix of data values is provided, a GMM is preliminary fitted to the data and then the entropy computed.
</p>
<p><code>EntropyGauss()</code> returns the entropy for a multivariate Gaussian distribution with covariance matrix <code>sigma</code>.
</p>
<p><code>nats2bits()</code> and <code>bits2nats()</code> convert input values in nats to bits, and viceversa. Information-theoretic quantities have different units depending on the base of the logarithm used: nats are expressed in base-2 logarithms, whereas bits in natural logarithms.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Robin S. and Scrucca L. (2023) Mixture-based estimation of entropy. <em>Computational Statistics &amp; Data Analysis</em>, 177, 107582. https://doi.org/10.1016/j.csda.2022.107582
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+Mclust">Mclust</a></code>, <code><a href="mclust.html#topic+densityMclust">densityMclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X = iris[,1:4]
mod = densityMclust(X, plot = FALSE)
h = EntropyGMM(mod)
h
bits2nats(h)
EntropyGMM(X)
</code></pre>

<hr>
<h2 id='GaussianMixtureMEM'>Modal EM algorithm for Gaussian Mixtures</h2><span id='topic+GaussianMixtureMEM'></span>

<h3>Description</h3>

<p>A function implementing a fast and efficient Modal EM algorithm for Gaussian mixtures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianMixtureMEM(data, pro, mu, sigma,
                   control = list(eps = 1e-5, 
                                  maxiter = 1e3, 
                                  stepsize = function(t) 1-exp(-0.1*t),
                                  denoise = TRUE,
                                  alpha = 0.01,
                                  keep.path = FALSE),
                   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianMixtureMEM_+3A_data">data</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. Categorical variables are not allowed. If a matrix or data frame, rows correspond to observations (<code class="reqn">n</code>) and columns correspond to variables (<code class="reqn">d</code>).</p>
</td></tr> 
<tr><td><code id="GaussianMixtureMEM_+3A_pro">pro</code></td>
<td>
<p>A <code class="reqn">(G \times 1)</code> vector of mixing probabilities for a Gaussian mixture of <code class="reqn">G</code> components.</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_mu">mu</code></td>
<td>
<p>A <code class="reqn">(d \times G)</code> matrix of component means for a <code class="reqn">d</code>-variate Gaussian mixture of <code class="reqn">G</code> components.</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_sigma">sigma</code></td>
<td>
<p>A <code class="reqn">(d \times d \times G)</code> array of component covariance matrices for a <code class="reqn">d</code>-variate Gaussian mixture of <code class="reqn">G</code> components.</p>
</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_control">control</code></td>
<td>
<p>A list of control parameters:
</p>

<dl>
<dt><code>eps, maxiter</code></dt><dd><p>numerical values setting the tolerance and the maximum number of iterations of the MEM algorithm;</p>
</dd>
<dt><code>stepsize</code></dt><dd><p>a function controlling the step size of the MEM algorithm;</p>
</dd>
<dt><code>denoise</code></dt><dd><p>a logical, if <code>TRUE</code> a denoising procedure is used when <code class="reqn">d &gt; 1</code> to discard all modes whose density is negligible;</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a numerical value used when <code>denoise = TRUE</code> for computing the hypervolume of central <code class="reqn">(1-\alpha)100</code> region of a multivariate Gaussian:</p>
</dd>
<dt><code>keep.path</code></dt><dd><p>a logical controlling whether or not the full paths to modes must be returned.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="GaussianMixtureMEM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>The number of input data points.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The number of variables/features.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The Gaussian mixture parameters.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations of MEM algorithm.</p>
</td></tr>
<tr><td><code>nmodes</code></td>
<td>
<p>The number of modes estimated by the MEM algorithm.</p>
</td></tr>
<tr><td><code>modes</code></td>
<td>
<p>The coordinates of modes estimated by MEM algorithm.</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>If requested, the coordinates of full paths to modes for each data point.</p>
</td></tr>
<tr><td><code>logdens</code></td>
<td>
<p>The log-density at the estimated modes.</p>
</td></tr>
<tr><td><code>logvol</code></td>
<td>
<p>The log-volume used for denoising (if requested).</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>The modal clustering classification of input data points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4, 305–314. https://doi.org/10.1002/sam.11527
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MclustMEM">MclustMEM</a></code>.
</p>

<hr>
<h2 id='mclustAddons-package'>Addons for the <span class="pkg">mclust</span> package</h2><span id='topic+mclustAddons-package'></span><span id='topic+mclustAddons'></span>

<h3>Description</h3>

<p>Extend the functionality of the <span class="pkg">mclust</span> package for Gaussian finite mixture modeling by including: 
</p>

<ul>
<li><p> density estimation for data with bounded support (Scrucca, 2019)
</p>
</li>
<li><p> modal clustering using MEM algorithm for Gaussian mixtures (Scrucca, 2021)
</p>
</li>
<li><p> entropy estimation via Gaussian mixture modeling (Robin &amp; Scrucca, 2023)
</p>
</li></ul>



<h3>Details</h3>

<p>For a quick introduction to <span class="pkg">mclustAddons</span> see the vignette <a href="../doc/mclustAddons.html">A quick tour of mclustAddons</a>.
</p>
<p>See also:
</p>

<ul>
<li> <p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a>()</code> for density estimation of bounded data;
</p>
</li>
<li> <p><code><a href="#topic+MclustMEM">MclustMEM</a>()</code> for modal clustering;
</p>
</li>
<li>  <p><code><a href="#topic+EntropyGMM">EntropyGMM</a>()</code> for entropy estimation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Luca Scrucca.
</p>
<p>Maintainer: Luca Scrucca <a href="mailto:luca.scrucca@unipg.it">luca.scrucca@unipg.it</a>
</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian mixture density estimation for bounded data. <em>Biometrical Journal</em>, 61:4, 873–888. https://doi.org/10.1002/bimj.201800174
</p>
<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4, 305–314. https://doi.org/10.1002/sam.11527
</p>
<p>Robin S. and Scrucca L. (2023) Mixture-based estimation of entropy. <em>Computational Statistics &amp; Data Analysis</em>, 177, 107582. https://doi.org/10.1016/j.csda.2022.107582
</p>

<hr>
<h2 id='MclustMEM'>Modal EM algorithm for Gaussian Mixtures fitted via <em>mclust</em> package</h2><span id='topic+MclustMEM'></span><span id='topic+print.MclustMEM'></span><span id='topic+summary.MclustMEM'></span><span id='topic+print.summary.MclustMEM'></span>

<h3>Description</h3>

<p>Modal-clustering estimation by applying the Modal EM algorithm to Gaussian mixtures fitted using the <em>mclust</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MclustMEM(mclustObject, data = NULL, ...)

## S3 method for class 'MclustMEM'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'MclustMEM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MclustMEM_+3A_mclustobject">mclustObject</code></td>
<td>
<p>An object of class <code>'Mclust'</code> or <code>'densityMclust'</code> obtained by fitting a Gaussian mixture via, respectively, <code><a href="mclust.html#topic+Mclust">Mclust</a></code> and <code><a href="mclust.html#topic+densityMclust">densityMclust</a></code>.</p>
</td></tr>
<tr><td><code id="MclustMEM_+3A_data">data</code></td>
<td>
<p>If provided, a numeric vector, matrix, or data frame of observations. If a matrix or data frame, rows correspond to observations (<code class="reqn">n</code>) and columns correspond to variables (<code class="reqn">d</code>). If not provided, the data used for fitting the Gaussian mixture model, and provided with the <code>object</code> argument, are used.</p>
</td></tr>
<tr><td><code id="MclustMEM_+3A_x">x</code>, <code id="MclustMEM_+3A_object">object</code></td>
<td>
<p>An object of class <code>'MclustMEM'</code>.</p>
</td></tr>
<tr><td><code id="MclustMEM_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use for printing.</p>
</td></tr>
<tr><td><code id="MclustMEM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>'MclustMEM'</code>. See also the output returned by <code><a href="#topic+GaussianMixtureMEM">GaussianMixtureMEM</a></code>.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4, 305–314. https://doi.org/10.1002/sam.11527
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussianMixtureMEM">GaussianMixtureMEM</a></code>, <code><a href="#topic+plot.MclustMEM">plot.MclustMEM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Baudry_etal_2010_JCGS_examples, package = "mclust")

plot(ex4.1)
GMM &lt;- Mclust(ex4.1)
plot(GMM, what = "classification")
MEM &lt;- MclustMEM(GMM)
MEM
summary(MEM)
plot(MEM)

plot(ex4.4.2)
GMM &lt;- Mclust(ex4.4.2)
plot(GMM, what = "classification")
MEM &lt;- MclustMEM(GMM)
MEM
summary(MEM)
plot(MEM, addDensity = FALSE)
</code></pre>

<hr>
<h2 id='plot.densityMclustBounded'>Plotting method for model-based mixture density estimation for bounded data</h2><span id='topic+plot.densityMclustBounded'></span>

<h3>Description</h3>

<p>Plots for <code>mclustDensityBounded</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densityMclustBounded'
plot(x, what = c("BIC", "density", "diagnostic"), 
     data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.densityMclustBounded_+3A_x">x</code></td>
<td>
<p>An object of class <code>"densityMclustBounded"</code> obtained from a call to <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.</p>
</td></tr>
<tr><td><code id="plot.densityMclustBounded_+3A_what">what</code></td>
<td>
<p>The type of graph requested:
</p>

<dl>
<dt><code>"BIC"</code> =</dt><dd><p>a plot of BIC values for the estimated models versus the number of components.</p>
</dd>
<dt><code>"density"</code> =</dt><dd><p>a plot of estimated density; if <code>data</code> is also provided the density is plotted over data points.</p>
</dd>
<dt><code>"diagnostic"</code> =</dt><dd><p>diagnostic plots (only available for the one-dimensional case).</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plot.densityMclustBounded_+3A_data">data</code></td>
<td>
<p>Optional data points.</p>
</td></tr>
<tr><td><code id="plot.densityMclustBounded_+3A_...">...</code></td>
<td>
<p>Further available arguments.
</p>

<ul>
<li><p> For 1-dimensional data:
</p>
<p><code>hist.col = "lightgrey",  hist.border = "white", breaks = "Sturges"</code>
</p>
</li>
<li><p> For 2-dimensional data:
</p>
<p><code>type = c("contour", "hdr", "image", "persp")</code> <br />
<code>transformation = c("none", "log", "sqrt")</code> <br />
<code>grid = 100, nlevels = 11, levels = NULL</code> <br />
<code>prob = c(0.25, 0.5, 0.75)</code> <br />
<code>col = grey(0.6), color.palette = blue2grey.colors</code> <br />
<code>points.col = 1, points.cex = 0.8, points.pch = 1</code>
</p>
</li>
<li><p> For <code class="reqn">d &gt; 2</code>-dimensional data:
</p>
<p><code>type = c("contour", "hdr"), gap = 0.2</code> <br />
<code>grid = 100, nlevels = 11, levels = NULL</code> <br />
<code>prob = c(0.25, 0.5, 0.75)</code> <br />
<code>col = grey(0.6), color.palette = blue2grey.colors</code> <br />
<code>points.col = 1, points.cex = 0.8, points.pch = 1</code>
</p>
</li></ul>

</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian mixture density estimation for bounded data. <em>Biometrical Journal</em>, 61:4, 873–888. https://doi.org/10.1002/bimj.201800174
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>,
<code><a href="#topic+predict.densityMclustBounded">predict.densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# univariate case with lower bound
x &lt;- rchisq(200, 3)
dens &lt;- densityMclustBounded(x, lbound = 0)
plot(dens, what = "BIC")
plot(dens, what = "density", data = x, breaks = 15)

# univariate case with lower &amp; upper bound
x &lt;- rbeta(200, 5, 1.5)
dens &lt;- densityMclustBounded(x, lbound = 0, ubound = 1)
plot(dens, what = "BIC")
plot(dens, what = "density", data = x, breaks = 9)

# bivariate case with lower bounds
x1 &lt;- rchisq(200, 3)
x2 &lt;- 0.5*x1 + sqrt(1-0.5^2)*rchisq(200, 5)
x &lt;- cbind(x1, x2)
dens &lt;- densityMclustBounded(x, lbound = c(0,0))
plot(dens, what = "density")
plot(dens, what = "density", data = x)
plot(dens, what = "density", type = "hdr")
plot(dens, what = "density", type = "persp")
</code></pre>

<hr>
<h2 id='plot.MclustMEM'>Plotting method for modal-clustering based on Gaussian Mixtures</h2><span id='topic+plot.MclustMEM'></span>

<h3>Description</h3>

<p>Plots for <code>MclustMEM</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MclustMEM'
plot(x, dimens = NULL, addDensity = TRUE, addPoints = TRUE, 
     symbols = NULL, colors = NULL, cex = NULL, 
     labels = NULL, cex.labels = NULL, gap = 0.2,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MclustMEM_+3A_x">x</code></td>
<td>
<p>An object of class <code>"densityMclustBounded"</code> obtained from a call to <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_dimens">dimens</code></td>
<td>
<p>A vector of integers specifying the dimensions of the coordinate projections.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_adddensity">addDensity</code></td>
<td>
<p>A logical indicating whether or not to add density estimates to the plot.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_addpoints">addPoints</code></td>
<td>
<p>A logical indicating whether or not to add data points to the plot.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_symbols">symbols</code></td>
<td>
<p>Either an integer or character vector assigning a plotting symbol to each unique class in <code>classification</code>. Elements in <code>symbols</code> correspond to classes in order of appearance in the sequence of observations (the order used by the function <code>unique</code>). The default is given by <code>mclust.options("classPlotSymbols")</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_colors">colors</code></td>
<td>
<p>Either an integer or character vector assigning a color to each unique class in <code>classification</code>. Elements in <code>colors</code> correspond to classes in order of appearance in the sequence of observations (the order used by the function <code>unique</code>). The default is given by <code>mclust.options("classPlotColors")</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_cex">cex</code></td>
<td>
<p>A vector of numerical values specifying the size of the plotting symbol for each unique class in <code>classification</code>. By default <code>cex = 1</code> for all classes is used.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings for labelling the variables. The default is to use the column dimension names of <code>data</code>.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_cex.labels">cex.labels</code></td>
<td>
<p>A numerical value specifying the size of the text labels.</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_gap">gap</code></td>
<td>
<p>A numerical argument specifying the distance between subplots (see <code><a href="graphics.html#topic+pairs">pairs</a></code>).</p>
</td></tr>
<tr><td><code id="plot.MclustMEM_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2021) A fast and efficient Modal EM algorithm for Gaussian mixtures. <em>Statistical Analysis and Data Mining</em>, 14:4, 305–314. https://doi.org/10.1002/sam.11527
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MclustMEM">MclustMEM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 1-d example
GMM &lt;- Mclust(iris$Petal.Length)
MEM &lt;- MclustMEM(GMM)
plot(MEM)

# 2-d example
data(Baudry_etal_2010_JCGS_examples)
GMM &lt;- Mclust(ex4.1)
MEM &lt;- MclustMEM(GMM)
plot(MEM)
plot(MEM, addPoints = FALSE)
plot(MEM, addDensity = FALSE)

# 3-d example
GMM &lt;- Mclust(ex4.4.2)
MEM &lt;- MclustMEM(GMM)
plot(MEM)
plot(MEM, addPoints = FALSE)
plot(MEM, addDensity = FALSE)
</code></pre>

<hr>
<h2 id='predict.densityMclustBounded'>Model-based mixture density estimation for bounded data</h2><span id='topic+predict.densityMclustBounded'></span>

<h3>Description</h3>

<p>Compute density estimation for univariate and multivariate bounded data based on Gaussian finite mixture models estimated by <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'densityMclustBounded'
predict(object, newdata, 
        what = c("dens", "cdens", "z"), 
        logarithm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.densityMclustBounded_+3A_object">object</code></td>
<td>
<p>An object of class <code>"densityMclustBounded"</code> resulting from a call to <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_newdata">newdata</code></td>
<td>
<p>A numeric vector, matrix, or data frame of observations. If missing the density is computed for the input data obtained from the call to <code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_what">what</code></td>
<td>
<p>A character string specifying what to retrieve: <code>"dens"</code> returns a vector of values for the mixture density; <code>"cdens"</code> returns a matrix of component densities for each mixture component (along the columns); <code>"z"</code> returns a matrix of component posterior probabilities.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_logarithm">logarithm</code></td>
<td>
<p>A logical value indicating whether or not the logarithm of the densities/probabilities should be returned.</p>
</td></tr>
<tr><td><code id="predict.densityMclustBounded_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector or a matrix of values evaluated at <code>newdata</code> depending on the argument <code>what</code> (see above).
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian mixture density estimation for bounded data. <em>Biometrical Journal</em>, 61:4, 873–888. https://doi.org/10.1002/bimj.201800174
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>, 
<code><a href="#topic+plot.densityMclustBounded">plot.densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- sample(0:1, size = 200, replace = TRUE, prob = c(0.6, 0.4))
x &lt;- y*rchisq(200, 3) + (1-y)*rchisq(200, 10)
dens &lt;- densityMclustBounded(x, lbound = 0)
summary(dens)
plot(dens, what = "density", data = x, breaks = 11)

xgrid &lt;- seq(0, max(x), length = 201)
densx &lt;- predict(dens, newdata = xgrid, what = "dens")
cdensx &lt;- predict(dens, newdata = xgrid, what = "cdens")
cdensx &lt;- sweep(cdensx, MARGIN = 2, FUN = "*", dens$parameters$pro)
plot(xgrid, densx, type = "l", lwd = 2)
matplot(xgrid, cdensx, type = "l", col = 3:4, lty = 2:3, lwd = 2, add = TRUE)

z &lt;- predict(dens, newdata = xgrid, what = "z")
matplot(xgrid, z, col = 3:4, lty = 2:3, lwd = 2, ylab = "Posterior probabilities")
</code></pre>

<hr>
<h2 id='racial'>Racial data</h2><span id='topic+racial'></span>

<h3>Description</h3>

<p>Proportion of white student enrollment in 56 school districts in Nassau County (Long Island, New York), for the 1992-1993 school year.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(racial)</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<dl>
<dt>District</dt><dd><p>School district.</p>
</dd>
<dt>PropWhite</dt><dd><p>Proportion of white student enrolled.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simonoff, S.J. (1996) Smoothing Methods in Statistics, Springer-Verlag, New York, p. 52</p>

<hr>
<h2 id='rangepowerTransform'>Range–power transformation</h2><span id='topic+rangepowerTransform'></span><span id='topic+rangepowerBackTransform'></span>

<h3>Description</h3>

<p>Functions to compute univariate range–power transformation and its back-transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rangepowerTransform(x, lbound = -Inf, ubound = +Inf, lambda = 1)

rangepowerBackTransform(y, lbound = -Inf, ubound = +Inf, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangepowerTransform_+3A_x">x</code></td>
<td>
<p>A numeric vector of data values.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_y">y</code></td>
<td>
<p>A numeric vector of transformed data values.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_lbound">lbound</code></td>
<td>
<p>A numerical value of variable lower bound.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_ubound">ubound</code></td>
<td>
<p>A numerical value of variable upper bound.</p>
</td></tr>
<tr><td><code id="rangepowerTransform_+3A_lambda">lambda</code></td>
<td>
<p>A numerical value for the power transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>range-power transformation</em> can be applied to variables with bounded support.
</p>
<p><b>Lower bound case</b>
</p>
<p>Suppose <code class="reqn">x</code> is a univariate random variable with lower bounded support <code class="reqn">\mathcal{S}_{\mathcal{X}}  \equiv (l,\infty)</code>, where <code class="reqn">l &gt; -\infty</code>.
Consider a preliminary <em>range transformation</em> defined as <code class="reqn">x \mapsto (x - l)</code>, which maps <code class="reqn">\mathcal{S}_{\mathcal{X}} \to \mathbb{R}^{+}</code>.
The <em>range-power transformation</em> is a continuous monotonic transformation defined as
</p>
<p style="text-align: center;"><code class="reqn">
t(x; \lambda) = 
\begin{cases}
\dfrac{(x-l)^{\lambda} - 1}{\lambda} &amp; 
\quad\text{if}\; \lambda \ne 0 \\[1ex]
\log(x-l)                            &amp; 
\quad\text{if}\; \lambda = 0
\end{cases}
</code>
</p>

<p>with back-transformation function
</p>
<p style="text-align: center;"><code class="reqn">
t^{-1}(y; \lambda) = 
\begin{cases}
(\lambda y + 1)^{1/\lambda} + l   &amp; 
\quad\text{if}\; \lambda \ne 0 \\[1ex]
\exp(y)+l                        &amp; 
\quad\text{if}\; \lambda = 0
\end{cases}
</code>
</p>

<p><b>Lower and upper bound case</b>
</p>
<p>Suppose <code class="reqn">x</code> is a univariate random variable with bounded support <code class="reqn">\mathcal{S}_{\mathcal{X}}  \equiv (l,u)</code>, where <code class="reqn">-\infty &lt; l &lt; u &lt; +\infty</code>. Consider a preliminary <em>range transformation</em> defined as <code class="reqn">x \mapsto (x - l)/(u - x)</code>, which maps <code class="reqn">\mathcal{S}_{\mathcal{X}} \to \mathbb{R}^{+}</code>.
In this case, the <em>range-power transformation</em> is a continuous monotonic transformation defined as
</p>
<p style="text-align: center;"><code class="reqn">
t(x; \lambda) = 
\begin{cases}
\dfrac{ \left( \dfrac{x-l}{u-x} \right)^{\lambda} - 1}{\lambda}
  &amp; \quad\text{if}\; \lambda \ne 0 \\[2ex]
\log \left( \dfrac{x-l}{u-x} \right)
  &amp; \quad\text{if}\; \lambda = 0,
\end{cases}
</code>
</p>

<p>with back-transformation function
</p>
<p style="text-align: center;"><code class="reqn">
t^{-1}(y; \lambda) = 
\begin{cases}
\dfrac{l + u (\lambda y + 1)^{1/\lambda}}{1+(\lambda y + 1)^{1/\lambda}} &amp; 
\quad\text{if}\; \lambda \ne 0 \\[1ex]
\dfrac{l + u \exp(y)}{1+\exp(y)}  &amp; 
\quad\text{if}\; \lambda = 0
\end{cases}
</code>
</p>



<h3>Value</h3>

<p>Returns a vector of transformed or back-transformed values.
</p>


<h3>Author(s)</h3>

<p>Luca Scrucca</p>


<h3>References</h3>

<p>Scrucca L. (2019) A transformation-based approach to Gaussian mixture density estimation for bounded data. <em>Biometrical Journal</em>, 61:4, 873–888. https://doi.org/10.1002/bimj.201800174
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityMclustBounded">densityMclustBounded</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lower bound case
x = rchisq(1000, 5)
y = rangepowerTransform(x, lbound = 0, lambda = 1/3)
par(mfrow=c(2,2))
hist(x, main = NULL, breaks = 21); rug(x)
hist(y, xlab = "y = t(x)", main = NULL, breaks = 21); rug(y)
xx = rangepowerBackTransform(y, lbound = 0, lambda = 1/3)
hist(xx, xlab = "t^-1(y) = x", main = NULL, breaks = 21); rug(xx)
plot(x, xx, ylab = "t^-1(y)"); abline(0,1)

# Lower and upper bound case
x = rbeta(1000, 2, 1)
y = rangepowerTransform(x, lbound = 0, ubound = 1, lambda = 0)
par(mfrow=c(2,2))
hist(x, main = NULL, breaks = 21); rug(x)
hist(y, xlab = "y = t(x)", main = NULL, breaks = 21); rug(y)
xx = rangepowerBackTransform(y, lbound = 0, ubound = 1, lambda = 0)
hist(xx, xlab = "t^-1(y) = x", main = NULL, breaks = 21); rug(xx)
plot(x, xx, ylab = "t^-1(y)"); abline(0,1)
</code></pre>

<hr>
<h2 id='suicide'>Suicide data</h2><span id='topic+suicide'></span>

<h3>Description</h3>

<p>Lengths of treatment spells (in days) of control patients in suicide study.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(suicide)</code></pre>


<h3>Format</h3>

<p>A vector of containing the lengths (days) of 86 spells of psychiatric treatment undergone by patients used as controls in a study of suicide risks.</p>


<h3>Source</h3>

<p>Silverman, B. W. (1986) Density Estimation, Chapman &amp; Hall, Tab 2.1.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
