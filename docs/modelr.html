<!DOCTYPE html><html><head><title>Help for package modelr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modelr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#modelr-package'><p>modelr: Modelling Functions that Work with the Pipe</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_predictions'><p>Add predictions to a data frame</p></a></li>
<li><a href='#add_predictors'><p>Add predictors to a formula</p></a></li>
<li><a href='#add_residuals'><p>Add residuals to a data frame</p></a></li>
<li><a href='#bootstrap'><p>Generate <code>n</code> bootstrap replicates.</p></a></li>
<li><a href='#crossv_mc'><p>Generate test-training pairs for cross-validation</p></a></li>
<li><a href='#data_grid'><p>Generate a data grid.</p></a></li>
<li><a href='#fit_with'><p>Fit a list of formulas</p></a></li>
<li><a href='#formulas'><p>Create a list of formulas</p></a></li>
<li><a href='#geom_ref_line'><p>Add a reference line (ggplot2).</p></a></li>
<li><a href='#heights'><p>Height and income data.</p></a></li>
<li><a href='#model_matrix'><p>Construct a design matrix</p></a></li>
<li><a href='#model-quality'><p>Compute model quality for a given dataset</p></a></li>
<li><a href='#na.warn'><p>Handle missing values with a warning</p></a></li>
<li><a href='#permute'><p>Generate <code>n</code> permutation replicates.</p></a></li>
<li><a href='#resample'><p>A &quot;lazy&quot; resample.</p></a></li>
<li><a href='#resample_bootstrap'><p>Generate a boostrap replicate</p></a></li>
<li><a href='#resample_partition'><p>Generate an exclusive partitioning of a data frame</p></a></li>
<li><a href='#resample_permutation'><p>Create a resampled permutation of a data frame</p></a></li>
<li><a href='#seq_range'><p>Generate a sequence over the range of a vector</p></a></li>
<li><a href='#sim'><p>Simple simulated datasets</p></a></li>
<li><a href='#typical'><p>Find the typical value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Modelling Functions that Work with the Pipe</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for modelling that help you seamlessly integrate
    modelling into a pipeline of data manipulation and visualisation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://modelr.tidyverse.org">https://modelr.tidyverse.org</a>, <a href="https://github.com/tidyverse/modelr">https://github.com/tidyverse/modelr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/modelr/issues">https://github.com/tidyverse/modelr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, magrittr, purrr (&ge; 0.2.2), rlang (&ge; 1.0.6), tibble,
tidyr (&ge; 0.8.0), tidyselect, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>compiler, covr, ggplot2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-21 14:12:54 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 13:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='modelr-package'>modelr: Modelling Functions that Work with the Pipe</h2><span id='topic+modelr'></span><span id='topic+modelr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Functions for modelling that help you seamlessly integrate modelling into a pipeline of data manipulation and visualisation.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://modelr.tidyverse.org">https://modelr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/modelr">https://github.com/tidyverse/modelr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/modelr/issues">https://github.com/tidyverse/modelr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_predictions'>Add predictions to a data frame</h2><span id='topic+add_predictions'></span><span id='topic+spread_predictions'></span><span id='topic+gather_predictions'></span>

<h3>Description</h3>

<p>Add predictions to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_predictions(data, model, var = "pred", type = NULL)

spread_predictions(data, ..., type = NULL)

gather_predictions(data, ..., .pred = "pred", .model = "model", type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_predictions_+3A_data">data</code></td>
<td>
<p>A data frame used to generate the predictions.</p>
</td></tr>
<tr><td><code id="add_predictions_+3A_model">model</code></td>
<td>
<p><code>add_predictions</code> takes a single <code>model</code>;</p>
</td></tr>
<tr><td><code id="add_predictions_+3A_var">var</code></td>
<td>
<p>The name of the output column, default value is <code>pred</code></p>
</td></tr>
<tr><td><code id="add_predictions_+3A_type">type</code></td>
<td>
<p>Prediction type, passed on to <code>stats::predict()</code>. Consult
<code>predict()</code> documentation for given <code>model</code> to determine valid values.</p>
</td></tr>
<tr><td><code id="add_predictions_+3A_...">...</code></td>
<td>
<p><code>gather_predictions</code> and <code>spread_predictions</code> take
multiple models. The name will be taken from either the argument
name of the name of the model.</p>
</td></tr>
<tr><td><code id="add_predictions_+3A_.pred">.pred</code>, <code id="add_predictions_+3A_.model">.model</code></td>
<td>
<p>The variable names used by <code>gather_predictions</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. <code>add_prediction</code> adds a single new column,
with default name <code>pred</code>, to the input <code>data</code>.
<code>spread_predictions</code> adds one column for each model. <code>gather_predictions</code>
adds two columns <code>.model</code> and <code>.pred</code>, and repeats the input rows for each
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(
  x = sort(runif(100)),
  y = 5 * x + 0.5 * x ^ 2 + 3 + rnorm(length(x))
)
plot(df)

m1 &lt;- lm(y ~ x, data = df)
grid &lt;- data.frame(x = seq(0, 1, length = 10))
grid %&gt;% add_predictions(m1)

m2 &lt;- lm(y ~ poly(x, 2), data = df)
grid %&gt;% spread_predictions(m1, m2)
grid %&gt;% gather_predictions(m1, m2)
</code></pre>

<hr>
<h2 id='add_predictors'>Add predictors to a formula</h2><span id='topic+add_predictors'></span>

<h3>Description</h3>

<p>This merges a one- or two-sided formula <code>f</code> with the
right-hand sides of all formulas supplied in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_predictors(f, ..., fun = "+")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_predictors_+3A_f">f</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="add_predictors_+3A_...">...</code></td>
<td>
<p>Formulas whose right-hand sides will be merged to
<code>f</code>.</p>
</td></tr>
<tr><td><code id="add_predictors_+3A_fun">fun</code></td>
<td>
<p>A function name indicating how to merge the right-hand
sides.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- lhs ~ rhs
add_predictors(f, ~var1, ~var2)

# Left-hand sides are ignored:
add_predictors(f, lhs1 ~ var1, lhs2 ~ var2)

# fun can also be set to a function like "*":
add_predictors(f, ~var1, ~var2, fun = "*")
</code></pre>

<hr>
<h2 id='add_residuals'>Add residuals to a data frame</h2><span id='topic+add_residuals'></span><span id='topic+spread_residuals'></span><span id='topic+gather_residuals'></span>

<h3>Description</h3>

<p>Add residuals to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_residuals(data, model, var = "resid")

spread_residuals(data, ...)

gather_residuals(data, ..., .resid = "resid", .model = "model")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_residuals_+3A_data">data</code></td>
<td>
<p>A data frame used to generate the residuals</p>
</td></tr>
<tr><td><code id="add_residuals_+3A_model">model</code>, <code id="add_residuals_+3A_var">var</code></td>
<td>
<p><code>add_residuals</code> takes a single <code>model</code>; the
output column will be called <code>resid</code></p>
</td></tr>
<tr><td><code id="add_residuals_+3A_...">...</code></td>
<td>
<p><code>gather_residuals</code> and <code>spread_residuals</code> take
multiple models. The name will be taken from either the argument
name of the name of the model.</p>
</td></tr>
<tr><td><code id="add_residuals_+3A_.resid">.resid</code>, <code id="add_residuals_+3A_.model">.model</code></td>
<td>
<p>The variable names used by <code>gather_residuals</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. <code>add_residuals</code> adds a single new column,
<code>.resid</code>, to the input <code>data</code>. <code>spread_residuals</code> adds
one column for each model. <code>gather_predictions</code> adds two columns
<code>.model</code> and <code>.resid</code>, and repeats the input rows for
each model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(
  x = sort(runif(100)),
  y = 5 * x + 0.5 * x ^ 2 + 3 + rnorm(length(x))
)
plot(df)

m1 &lt;- lm(y ~ x, data = df)
df %&gt;% add_residuals(m1)

m2 &lt;- lm(y ~ poly(x, 2), data = df)
df %&gt;% spread_residuals(m1, m2)
df %&gt;% gather_residuals(m1, m2)
</code></pre>

<hr>
<h2 id='bootstrap'>Generate <code>n</code> bootstrap replicates.</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Generate <code>n</code> bootstrap replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(data, n, id = ".id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_n">n</code></td>
<td>
<p>Number of bootstrap replicates to generate</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_id">id</code></td>
<td>
<p>Name of variable that gives each model a unique integer id.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code>n</code> rows and one column: <code>strap</code>
</p>


<h3>See Also</h3>

<p>Other resampling techniques: 
<code><a href="#topic+resample_bootstrap">resample_bootstrap</a>()</code>,
<code><a href="#topic+resample_partition">resample_partition</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(purrr)
boot &lt;- bootstrap(mtcars, 100)

models &lt;- map(boot$strap, ~ lm(mpg ~ wt, data = .))
tidied &lt;- map_df(models, broom::tidy, .id = "id")

hist(subset(tidied, term == "wt")$estimate)
hist(subset(tidied, term == "(Intercept)")$estimate)
</code></pre>

<hr>
<h2 id='crossv_mc'>Generate test-training pairs for cross-validation</h2><span id='topic+crossv_mc'></span><span id='topic+crossv_kfold'></span><span id='topic+crossv_loo'></span>

<h3>Description</h3>

<p><code>crossv_kfold</code> splits the data into <code>k</code> exclusive partitions,
and uses each partition for a test-training split. <code>crossv_mc</code>
generates <code>n</code> random partitions, holding out <code>test</code> of the
data for training. <code>crossv_loo</code> performs leave-one-out
cross-validation, i.e., <code>n = nrow(data)</code> training partitions containing
<code>n - 1</code> rows each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossv_mc(data, n, test = 0.2, id = ".id")

crossv_kfold(data, k = 5, id = ".id")

crossv_loo(data, id = ".id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossv_mc_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="crossv_mc_+3A_n">n</code></td>
<td>
<p>Number of test-training pairs to generate (an integer).</p>
</td></tr>
<tr><td><code id="crossv_mc_+3A_test">test</code></td>
<td>
<p>Proportion of observations that should be held out for testing
(a double).</p>
</td></tr>
<tr><td><code id="crossv_mc_+3A_id">id</code></td>
<td>
<p>Name of variable that gives each model a unique integer id.</p>
</td></tr>
<tr><td><code id="crossv_mc_+3A_k">k</code></td>
<td>
<p>Number of folds (an integer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>test</code>, <code>train</code>, and <code>.id</code>.
<code>test</code> and <code>train</code> are list-columns containing <code><a href="#topic+resample">resample()</a></code> objects.
The number of rows is <code>n</code> for <code>crossv_mc()</code>, <code>k</code> for <code>crossv_kfold()</code>
and <code>nrow(data)</code> for <code>crossv_loo()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cv1 &lt;- crossv_kfold(mtcars, 5)
cv1

library(purrr)
cv2 &lt;- crossv_mc(mtcars, 100)
models &lt;- map(cv2$train, ~ lm(mpg ~ wt, data = .))
errs &lt;- map2_dbl(models, cv2$test, rmse)
hist(errs)
</code></pre>

<hr>
<h2 id='data_grid'>Generate a data grid.</h2><span id='topic+data_grid'></span>

<h3>Description</h3>

<p>To visualise a model, it is very useful to be able to generate an
evenly spaced grid of points from the data. <code>data_grid</code> helps you
do this by wrapping around <code><a href="tidyr.html#topic+expand">tidyr::expand()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_grid(data, ..., .model = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_grid_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="data_grid_+3A_...">...</code></td>
<td>
<p>Variables passed on to <code><a href="tidyr.html#topic+expand">tidyr::expand()</a></code></p>
</td></tr>
<tr><td><code id="data_grid_+3A_.model">.model</code></td>
<td>
<p>A model.  If supplied, any predictors needed for the model
not present in <code>...</code> will be filled in with &quot;<a href="#topic+typical">typical</a>&quot; values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+seq_range">seq_range()</a></code> for generating ranges from continuous
variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_grid(mtcars, vs, am)

# For continuous variables, seq_range is useful
data_grid(mtcars, mpg = mpg)
data_grid(mtcars, mpg = seq_range(mpg, 10))

# If you supply a model, missing predictors will be filled in with
# typical values
mod &lt;- lm(mpg ~ wt + cyl + vs, data = mtcars)
data_grid(mtcars, .model = mod)
data_grid(mtcars, cyl = seq_range(cyl, 9), .model = mod)
</code></pre>

<hr>
<h2 id='fit_with'>Fit a list of formulas</h2><span id='topic+fit_with'></span>

<h3>Description</h3>

<p><code>fit_with()</code> is a pipe-friendly tool that applies a list of
formulas to a fitting function such as <code><a href="stats.html#topic+lm">stats::lm()</a></code>.
The list of formulas is typically created with <code><a href="#topic+formulas">formulas()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_with(data, .f, .formulas, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_with_+3A_data">data</code></td>
<td>
<p>A dataset used to fit the models.</p>
</td></tr>
<tr><td><code id="fit_with_+3A_.f">.f</code></td>
<td>
<p>A fitting function such as <code><a href="stats.html#topic+lm">stats::lm()</a></code>,
<code><a href="lme4.html#topic+lmer">lme4::lmer()</a></code> or <code><a href="rstanarm.html#topic+stan_glmer">rstanarm::stan_glmer()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_with_+3A_.formulas">.formulas</code></td>
<td>
<p>A list of formulas specifying a model.</p>
</td></tr>
<tr><td><code id="fit_with_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that <code>.f</code> takes the formula either as first argument
or as second argument if the first argument is <code>data</code>.  Most
fitting functions should fit these requirements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+formulas">formulas()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit_with() is typically used with formulas().
disp_fits &lt;- mtcars %&gt;% fit_with(lm, formulas(~disp,
  additive = ~drat + cyl,
  interaction = ~drat * cyl,
  full = add_predictors(interaction, ~am, ~vs)
))

# The list of fitted models is named after the names of the list of
# formulas:
disp_fits$full

# Additional arguments are passed on to .f
mtcars %&gt;% fit_with(glm, list(am ~ disp), family = binomial)
</code></pre>

<hr>
<h2 id='formulas'>Create a list of formulas</h2><span id='topic+formulas'></span><span id='topic+formulae'></span>

<h3>Description</h3>

<p><code>formulas()</code> creates a list of two-sided formulas by merging a
unique left-hand side to a list of right-hand sides.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formulas(.response, ...)

formulae(.response, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formulas_+3A_.response">.response</code></td>
<td>
<p>A one-sided formula used as the left-hand side of
all resulting formulas.</p>
</td></tr>
<tr><td><code id="formulas_+3A_...">...</code></td>
<td>
<p>List of formulas whose right-hand sides will be merged
to <code>.response</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Provide named arguments to create a named list of formulas:
models &lt;- formulas(~lhs,
  additive = ~var1 + var2,
  interaction = ~var1 * var2
)
models$additive

# The formulas are created sequentially, so that you can refer to
# previously created formulas:
formulas(~lhs,
  linear = ~var1 + var2,
  hierarchical = add_predictors(linear, ~(1 | group))
)
</code></pre>

<hr>
<h2 id='geom_ref_line'>Add a reference line (ggplot2).</h2><span id='topic+geom_ref_line'></span>

<h3>Description</h3>

<p>Add a reference line (ggplot2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_ref_line(h, v, size = 2, colour = "white")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_ref_line_+3A_h">h</code>, <code id="geom_ref_line_+3A_v">v</code></td>
<td>
<p>Position of horizontal or vertical reference line</p>
</td></tr>
<tr><td><code id="geom_ref_line_+3A_size">size</code></td>
<td>
<p>Line size</p>
</td></tr>
<tr><td><code id="geom_ref_line_+3A_colour">colour</code></td>
<td>
<p>Line colour</p>
</td></tr>
</table>

<hr>
<h2 id='heights'>Height and income data.</h2><span id='topic+heights'></span>

<h3>Description</h3>

<p>You might have heard that taller people earn more. Is it true? You can
try and answer the question by exploring this dataset extracted from the
<a href="https://www.nlsinfo.org">National Longitudinal Study</a>, which is
sponsored by the U.S. Bureau of Labor Statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heights
</code></pre>


<h3>Format</h3>


<dl>
<dt>income</dt><dd><p>Yearly income. The top two percent of values were averaged
and that average was used to replace all values in the top range. </p>
</dd>
<dt>height</dt><dd><p>Height, in inches</p>
</dd>
<dt>weight</dt><dd><p>Weight, in pounds</p>
</dd>
<dt>age</dt><dd><p>Age, in years, between 47 and 56.</p>
</dd>
<dt>marital</dt><dd><p>Marital status</p>
</dd>
<dt>sex</dt><dd><p>Sex</p>
</dd>
<dt>education</dt><dd><p>Years of education</p>
</dd>
<dt>afqt</dt><dd><p>Percentile score on Armed Forces Qualification Test.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This contains data as at 2012.
</p>

<hr>
<h2 id='model_matrix'>Construct a design matrix</h2><span id='topic+model_matrix'></span>

<h3>Description</h3>

<p>This is a thin wrapper around <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> which
returns a tibble. Use it to determine how your modelling formula is
translated into a matrix, an thence into an equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_matrix(data, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_matrix_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_formula">formula</code></td>
<td>
<p>A modelling formula</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_...">...</code></td>
<td>
<p>Other arguments passed onto <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model_matrix(mtcars, mpg ~ cyl)
model_matrix(iris, Sepal.Length ~ Species)
model_matrix(iris, Sepal.Length ~ Species - 1)
</code></pre>

<hr>
<h2 id='model-quality'>Compute model quality for a given dataset</h2><span id='topic+model-quality'></span><span id='topic+mse'></span><span id='topic+rmse'></span><span id='topic+mae'></span><span id='topic+rsquare'></span><span id='topic+qae'></span><span id='topic+mape'></span><span id='topic+rsae'></span>

<h3>Description</h3>

<p>Three summaries are immediately interpretible on the scale of the response
variable:
</p>

<ul>
<li> <p><code>rmse()</code> is the root-mean-squared-error
</p>
</li>
<li> <p><code>mae()</code> is the mean absolute error
</p>
</li>
<li> <p><code>qae()</code> is quantiles of absolute error.
</p>
</li></ul>

<p>Other summaries have varying scales and interpretations:
</p>

<ul>
<li> <p><code>mape()</code> mean absolute percentage error.
</p>
</li>
<li> <p><code>rsae()</code> is the relative sum of absolute errors.
</p>
</li>
<li> <p><code>mse()</code> is the mean-squared-error.
</p>
</li>
<li> <p><code>rsquare()</code> is the variance of the predictions divided by the
variance of the response.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mse(model, data)

rmse(model, data)

mae(model, data)

rsquare(model, data)

qae(model, data, probs = c(0.05, 0.25, 0.5, 0.75, 0.95))

mape(model, data)

rsae(model, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model-quality_+3A_model">model</code></td>
<td>
<p>A model</p>
</td></tr>
<tr><td><code id="model-quality_+3A_data">data</code></td>
<td>
<p>The dataset</p>
</td></tr>
<tr><td><code id="model-quality_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(mpg ~ wt, data = mtcars)
mse(mod, mtcars)
rmse(mod, mtcars)
rsquare(mod, mtcars)
mae(mod, mtcars)
qae(mod, mtcars)
mape(mod, mtcars)
rsae(mod, mtcars)
</code></pre>

<hr>
<h2 id='na.warn'>Handle missing values with a warning</h2><span id='topic+na.warn'></span>

<h3>Description</h3>

<p>This NA handler ensures that those models that support the
<code>na.action</code> parameter do not silently drop missing values. It
wraps around <code><a href="stats.html#topic+na.fail">stats::na.exclude()</a></code> so that there is one
prediction/residual for input row. To apply it globally, run
<code>options(na.action = na.warn)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.warn(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.warn_+3A_object">object</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(
  x = 1:10,
  y = c(5.1, 9.7, NA, 17.4, 21.2, 26.6, 27.9, NA, 36.3, 40.4)
)
# Default behaviour is to silently drop
m1 &lt;- lm(y ~ x, data = df)
resid(m1)

# Use na.action = na.warn to warn
m2 &lt;- lm(y ~ x, data = df, na.action = na.warn)
resid(m2)
</code></pre>

<hr>
<h2 id='permute'>Generate <code>n</code> permutation replicates.</h2><span id='topic+permute'></span><span id='topic+permute_'></span>

<h3>Description</h3>

<p>A permutation test involves permuting one or more variables in a data set
before performing the test, in order to break any existing relationships
and simulate the null hypothesis. One can then compare the true statistic
to the generated distribution of null statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute(data, n, ..., .id = ".id")

permute_(data, n, columns, .id = ".id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="permute_+3A_n">n</code></td>
<td>
<p>Number of permutations to generate.</p>
</td></tr>
<tr><td><code id="permute_+3A_...">...</code></td>
<td>
<p>Columns to permute. This supports bare column names or dplyr
<a href="dplyr.html#topic+reexports">dplyr::select_helpers</a></p>
</td></tr>
<tr><td><code id="permute_+3A_.id">.id</code></td>
<td>
<p>Name of variable that gives each model a unique integer id.</p>
</td></tr>
<tr><td><code id="permute_+3A_columns">columns</code></td>
<td>
<p>In <code>permute_</code>, vector of column names to permute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code>n</code> rows and one column: <code>perm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(purrr)
perms &lt;- permute(mtcars, 100, mpg)

models &lt;- map(perms$perm, ~ lm(mpg ~ wt, data = .))
glanced &lt;- map_df(models, broom::glance, .id = "id")

# distribution of null permutation statistics
hist(glanced$statistic)
# confirm these are roughly uniform p-values
hist(glanced$p.value)

# test against the unpermuted model to get a permutation p-value
mod &lt;- lm(mpg ~ wt, mtcars)
mean(glanced$statistic &gt; broom::glance(mod)$statistic)

</code></pre>

<hr>
<h2 id='resample'>A &quot;lazy&quot; resample.</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Often you will resample a dataset hundreds or thousands of times. Storing
the complete resample each time would be very inefficient so this class
instead stores a &quot;pointer&quot; to the original dataset, and a vector of row
indexes. To turn this into a regular data frame, call <code>as.data.frame</code>,
to extract the indices, use <code>as.integer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(data, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_data">data</code></td>
<td>
<p>The data frame</p>
</td></tr>
<tr><td><code id="resample_+3A_idx">idx</code></td>
<td>
<p>A vector of integer indexes indicating which rows have
been selected. These values should lie between 1 and <code>nrow(data)</code>
but they are not checked by this function in the interests of performance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other resampling techniques: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+resample_bootstrap">resample_bootstrap</a>()</code>,
<code><a href="#topic+resample_partition">resample_partition</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>resample(mtcars, 1:10)

b &lt;- resample_bootstrap(mtcars)
b
as.integer(b)
as.data.frame(b)

# Many modelling functions will do the coercion for you, so you can
# use a resample object directly in the data argument
lm(mpg ~ wt, data = b)
</code></pre>

<hr>
<h2 id='resample_bootstrap'>Generate a boostrap replicate</h2><span id='topic+resample_bootstrap'></span>

<h3>Description</h3>

<p>Generate a boostrap replicate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_bootstrap(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_bootstrap_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other resampling techniques: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+resample_partition">resample_partition</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coef(lm(mpg ~ wt, data = resample_bootstrap(mtcars)))
coef(lm(mpg ~ wt, data = resample_bootstrap(mtcars)))
coef(lm(mpg ~ wt, data = resample_bootstrap(mtcars)))
</code></pre>

<hr>
<h2 id='resample_partition'>Generate an exclusive partitioning of a data frame</h2><span id='topic+resample_partition'></span>

<h3>Description</h3>

<p>Generate an exclusive partitioning of a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_partition(data, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_partition_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="resample_partition_+3A_p">p</code></td>
<td>
<p>A named numeric vector giving where the value is the probability
that an observation will be assigned to that group.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other resampling techniques: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+resample_bootstrap">resample_bootstrap</a>()</code>,
<code><a href="#topic+resample">resample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- resample_partition(mtcars, c(test = 0.3, train = 0.7))
mod &lt;- lm(mpg ~ wt, data = ex$train)
rmse(mod, ex$test)
rmse(mod, ex$train)
</code></pre>

<hr>
<h2 id='resample_permutation'>Create a resampled permutation of a data frame</h2><span id='topic+resample_permutation'></span>

<h3>Description</h3>

<p>Create a resampled permutation of a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_permutation(data, columns, idx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_permutation_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="resample_permutation_+3A_columns">columns</code></td>
<td>
<p>Columns to be permuted</p>
</td></tr>
<tr><td><code id="resample_permutation_+3A_idx">idx</code></td>
<td>
<p>Indices to permute by. If not given, generates them randomly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A permutation object; use as.data.frame to convert to a permuted
data frame
</p>

<hr>
<h2 id='seq_range'>Generate a sequence over the range of a vector</h2><span id='topic+seq_range'></span>

<h3>Description</h3>

<p>Generate a sequence over the range of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_range(x, n, by, trim = NULL, expand = NULL, pretty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_range_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="seq_range_+3A_n">n</code>, <code id="seq_range_+3A_by">by</code></td>
<td>
<p>Specify the output sequence either by supplying the
length of the sequence with <code>n</code>, or the spacing between value
with <code>by</code>. Specifying both is an error.
</p>
<p>I recommend that you name these arguments in order to make it clear to
the reader.</p>
</td></tr>
<tr><td><code id="seq_range_+3A_trim">trim</code></td>
<td>
<p>Optionally, trim values off the tails.
<code>trim / 2 * length(x)</code> values are removed from each tail.</p>
</td></tr>
<tr><td><code id="seq_range_+3A_expand">expand</code></td>
<td>
<p>Optionally, expand the range by <code style="white-space: pre;">&#8288;expand * (1 + range(x)&#8288;</code>
(computed after trimming).</p>
</td></tr>
<tr><td><code id="seq_range_+3A_pretty">pretty</code></td>
<td>
<p>If <code>TRUE</code>, will generate a pretty sequence. If <code>n</code>
is supplied, this will use <code><a href="base.html#topic+pretty">pretty()</a></code> instead of
<code><a href="base.html#topic+seq">seq()</a></code>. If <code>by</code> is supplied, it will round the first
value to a multiple of <code>by</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rcauchy(100)
seq_range(x, n = 10)
seq_range(x, n = 10, trim = 0.1)
seq_range(x, by = 1, trim = 0.1)

# Make pretty sequences
y &lt;- runif(100)
seq_range(y, n = 10)
seq_range(y, n = 10, pretty = TRUE)
seq_range(y, n = 10, expand = 0.5, pretty = TRUE)

seq_range(y, by = 0.1)
seq_range(y, by = 0.1, pretty = TRUE)
</code></pre>

<hr>
<h2 id='sim'>Simple simulated datasets</h2><span id='topic+sim'></span><span id='topic+sim1'></span><span id='topic+sim2'></span><span id='topic+sim3'></span><span id='topic+sim4'></span>

<h3>Description</h3>

<p>These simple simulated datasets are useful for teaching modelling
basics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim1

sim2

sim3

sim4
</code></pre>

<hr>
<h2 id='typical'>Find the typical value</h2><span id='topic+typical'></span>

<h3>Description</h3>

<p>For numeric, integer, and ordered factor vectors, it returns the median.
For factors, characters, and logical vectors, it returns the most
frequent value. If multiple values are tied for most frequent, it returns
them all. <code>NA</code> missing values are always silently dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>typical(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typical_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="typical_+3A_...">...</code></td>
<td>
<p>Arguments used by methods</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># median of numeric vector
typical(rpois(100, lambda = 10))

# most frequent value of character or factor
x &lt;- sample(c("a", "b", "c"), 100, prob = c(0.6, 0.2, 0.2), replace = TRUE)
typical(x)
typical(factor(x))

# if tied, returns them all
x &lt;- c("a", "a", "b", "b", "c")
typical(x)

# median of an ordered factor
typical(ordered(c("a", "a", "b", "c", "d")))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
