<!DOCTYPE html><html><head><title>Help for package matsindf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matsindf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#:='><p>Pipe operator</p></a></li>
<li><a href='#.data'><p>Data pronoun</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#add_UKEnergy2000_matnames'><p>Add a column of matrix names to tidy data frame</p></a></li>
<li><a href='#add_UKEnergy2000_row_col_meta'><p>Add row, column, row type, and column type metadata</p></a></li>
<li><a href='#build_keep_args'><p>Build a list of arguments to keep</p></a></li>
<li><a href='#build_matsindf_apply_data_frame'><p>Create a data frame consisting of the input data for matsindf_apply()</p></a></li>
<li><a href='#collapse_to_matrices'><p>Collapse a &quot;tidy&quot; data frame to matrices in a data frame <code>matsindf</code>)</p></a></li>
<li><a href='#df_to_msg'><p>Create a message from a data frame</p></a></li>
<li><a href='#everything_except'><p>Get symbols for all columns except ...</p></a></li>
<li><a href='#expand_to_tidy'><p>Expand a <code>matsindf</code> data frame</p></a></li>
<li><a href='#get_useable_default_args'><p>Create a usable list of default arguments to a function</p></a></li>
<li><a href='#group_by_everything_except'><p>Group by all variables except some</p></a></li>
<li><a href='#handle_empty_data'><p>Gracefully handle empty data</p></a></li>
<li><a href='#handle_null_args'><p>Gracefully handle <code>NULL</code> arguments</p></a></li>
<li><a href='#index_column'><p>Index a column in a data frame by groups relative to an initial year</p></a></li>
<li><a href='#mat_to_rowcolval'><p>Convert a matrix to a data frame with rows, columns, and values.</p></a></li>
<li><a href='#matrix_cols'><p>Find columns that contain matrices</p></a></li>
<li><a href='#matsindf_apply'><p>Apply a function to a <code>matsindf</code> data frame (and more)</p></a></li>
<li><a href='#matsindf_apply_types'><p>Determine types of <code>.dat</code> and <code>...</code> arguments for matsindf_apply()</p></a></li>
<li><a href='#rowcolval_to_mat'><p>Collapse a tidy data frame into a matrix with named rows and columns</p></a></li>
<li><a href='#should_unlist'><p>Tell whether a column can be unlisted</p></a></li>
<li><a href='#UKEnergy2000'><p>Energy consumption in the UK in 2000</p></a></li>
<li><a href='#verify_cols_missing'><p>Verify that column names in a data frame are not already present</p></a></li>
<li><a href='#where_to_get_args'><p>Decide where to get each argument to FUN</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matrices in Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Heun &lt;matthew.heun@me.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to collapse a tidy data frame into matrices in a data frame
    and expand a data frame of matrices into a tidy data frame.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>collapse, matsindf_apply</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, lifecycle, magrittr, matsbyname, purrr,
rlang, tibble, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, Hmisc, knitr, Matrix, RCLabels, rmarkdown,
spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MatthewHeun/matsindf">https://github.com/MatthewHeun/matsindf</a>,
<a href="https://matthewheun.github.io/matsindf/">https://matthewheun.github.io/matsindf/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MatthewHeun/matsindf/issues">https://github.com/MatthewHeun/matsindf/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 02:40:07 UTC; mkh2</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Heun <a href="https://orcid.org/0000-0002-7438-214X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-01 05:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+3A+3D'>Pipe operator</h2><span id='topic++3A+3D'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;:=&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x := y
</code></pre>

<hr>
<h2 id='.data'>Data pronoun</h2><span id='topic+.data'></span>

<h3>Description</h3>

<p>See <code>rlang::.data</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.data
</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_UKEnergy2000_matnames'>Add a column of matrix names to tidy data frame</h2><span id='topic+add_UKEnergy2000_matnames'></span>

<h3>Description</h3>

<p>Add a column of matrix names to tidy data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_UKEnergy2000_matnames(
  .DF,
  ledger_side_colname = "Ledger.side",
  energy_colname = "E.ktoe",
  supply_side = "Supply",
  consumption_side = "Consumption",
  matname_colname = "matname",
  U_name = "U",
  V_name = "V",
  Y_name = "Y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_.df">.DF</code></td>
<td>
<p>a data frame with <code>ledger_side_colname</code> and <code>energy_colname</code>.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_ledger_side_colname">ledger_side_colname</code></td>
<td>
<p>the name of the column in <code>.DF</code> that contains ledger side
(a string). Default is &quot;<code>Ledger.side</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_energy_colname">energy_colname</code></td>
<td>
<p>the name of the column in <code>.DF</code> that contains energy values
(a string). Default is &quot;<code>E.ktoe</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_supply_side">supply_side</code></td>
<td>
<p>the identifier for items on the supply side of the ledger (a string).
Default is &quot;<code>Supply</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_consumption_side">consumption_side</code></td>
<td>
<p>the identifier for items on the consumption side
of the ledger (a string). Default is &quot;<code>Consumption</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_matname_colname">matname_colname</code></td>
<td>
<p>the name of the output column containing the name of the matrix
in which this row belongs (a string). Default is &quot;<code>UVY</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_u_name">U_name</code></td>
<td>
<p>the name for the use matrix (a string). Default is &quot;<code>U</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_v_name">V_name</code></td>
<td>
<p>the name for the make matrix (a string). Default is &quot;<code>V</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_matnames_+3A_y_name">Y_name</code></td>
<td>
<p>the name for the final demand matrix (a string). Default is &quot;<code>Y</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.DF</code> with an added column, <code>UVY_colname</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matsindf:::add_UKEnergy2000_matnames(UKEnergy2000)
</code></pre>

<hr>
<h2 id='add_UKEnergy2000_row_col_meta'>Add row, column, row type, and column type metadata</h2><span id='topic+add_UKEnergy2000_row_col_meta'></span>

<h3>Description</h3>

<p>Add row, column, row type, and column type metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_UKEnergy2000_row_col_meta(
  .DF,
  matname_colname = "matname",
  U_name = "U",
  V_name = "V",
  Y_name = "Y",
  product_colname = "Product",
  flow_colname = "Flow",
  industry_type = "Industry",
  product_type = "Product",
  sector_type = "Sector",
  rowname_colname = "rowname",
  colname_colname = "colname",
  rowtype_colname = "rowtype",
  coltype_colname = "coltype"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_.df">.DF</code></td>
<td>
<p>a data frame containing <code>matname_colname</code>.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_matname_colname">matname_colname</code></td>
<td>
<p>the name of the column in <code>.DF</code> that contains names of matrices
(a string).  Default is &quot;<code>matname</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_u_name">U_name</code></td>
<td>
<p>the name for use matrices (a string). Default is &quot;<code>U</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_v_name">V_name</code></td>
<td>
<p>the name for make matrices (a string). Default is &quot;<code>V</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_y_name">Y_name</code></td>
<td>
<p>the name for final demand matrices (a string). Default is &quot;<code>Y</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_product_colname">product_colname</code></td>
<td>
<p>the name of the column in <code>.DF</code> where Product names
is found (a string). Default is &quot;<code>Product</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_flow_colname">flow_colname</code></td>
<td>
<p>the name of the column in <code>.DF</code> where Flow information is found
(a string).
The Flow column usually contains the industries involved in this flow.
Default is &quot;<code>Flow</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_industry_type">industry_type</code></td>
<td>
<p>the name that identifies production industries and
and transformation processes (a string). Default is &quot;<code>Industry</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_product_type">product_type</code></td>
<td>
<p>the name that identifies energy carriers (a string).
Default is &quot;<code>Product</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_sector_type">sector_type</code></td>
<td>
<p>the name that identifies final demand sectors (a string).
Default is &quot;<code>Sector</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_rowname_colname">rowname_colname</code></td>
<td>
<p>the name of the output column that contains row names for matrices
(a string). Default is &quot;<code>rowname</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_colname_colname">colname_colname</code></td>
<td>
<p>the name of the output column that contains column names for matrices
(a string). Default is &quot;<code>colname</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_rowtype_colname">rowtype_colname</code></td>
<td>
<p>the name of the output column that contains row types for matrices
(a string). Default is &quot;<code>rowtype</code>&quot;.</p>
</td></tr>
<tr><td><code id="add_UKEnergy2000_row_col_meta_+3A_coltype_colname">coltype_colname</code></td>
<td>
<p>the name of the output column that contains column types for matrices
(a string). Default is &quot;<code>coltype</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>.DF</code> with additional columns named
<code>rowname_colname</code>, <code>colname_colname</code>,
<code>rowtype_colname</code>, and <code>coltype_colname</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UKEnergy2000 %&gt;%
  matsindf:::add_UKEnergy2000_matnames(.) %&gt;%
  matsindf:::add_UKEnergy2000_row_col_meta(.)
</code></pre>

<hr>
<h2 id='build_keep_args'>Build a list of arguments to keep</h2><span id='topic+build_keep_args'></span>

<h3>Description</h3>

<p>In the process of building data frames of arguments to <code>FUN</code>,
we need to decide which arguments to keep from each source,
<code>...</code>, <code>.dat</code>, and defaults to <code>FUN</code>.
This function does that work in one place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_keep_args(where_to_find_args)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_keep_args_+3A_where_to_find_args">where_to_find_args</code></td>
<td>
<p>A list created by <code>where_to_get_args()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with names <code>.dat</code>, <code>dots</code>, and <code>FUN</code> which
gives items to keep from each source.
</p>

<hr>
<h2 id='build_matsindf_apply_data_frame'>Create a data frame consisting of the input data for matsindf_apply()</h2><span id='topic+build_matsindf_apply_data_frame'></span>

<h3>Description</h3>

<p>This is an internal helper function that takes the types list
and creates a data frame from which calculations
can proceed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_matsindf_apply_data_frame(
  .dat = NULL,
  FUN,
  ...,
  types = matsindf_apply_types(.dat, FUN = FUN, ... = ...)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_matsindf_apply_data_frame_+3A_.dat">.dat</code></td>
<td>
<p>The value of the <code>.dat</code> argument to <code>matsindf_apply()</code>, as a list or a data frame.</p>
</td></tr>
<tr><td><code id="build_matsindf_apply_data_frame_+3A_fun">FUN</code></td>
<td>
<p>The function supplied to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="build_matsindf_apply_data_frame_+3A_...">...</code></td>
<td>
<p>The <code>...</code> argument supplied to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="build_matsindf_apply_data_frame_+3A_types">types</code></td>
<td>
<p>The types for <code>matsindf_apply()</code>. Supply if already calculated externally.
Default is <code>types = matsindf_apply_types(.dat, FUN = FUN, ... = ...)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enforces the precedence rules for <code>matsindf_apply()</code>, namely that
variables found in <code>...</code> take priority over
variables found in <code>.dat</code>, which take priority over
variables found in the default values of <code>FUN</code>.
</p>


<h3>Value</h3>

<p>A data frame (actually, a <code>tibble</code>)
with columns from <code>dots</code>, <code>.dat</code>, and the default values to <code>FUN</code>,
according to precedence rules for <code>matsindf_apply()</code>.
</p>

<hr>
<h2 id='collapse_to_matrices'>Collapse a &quot;tidy&quot; data frame to matrices in a data frame <code>matsindf</code>)</h2><span id='topic+collapse_to_matrices'></span>

<h3>Description</h3>

<p>A &quot;tidy&quot; data frame contains information that can be collapsed into matrices,
including columns for
matrix names, row names, column names, row types, column types, and values (entries in matrices).
These column names are specified as strings by the <code>matnames</code>, <code>rownames</code>, <code>colnames</code>,
<code>rowtypes</code>, <code>coltypes</code>, and <code>values</code> arguments to <code>collapse_to_matrices()</code>, respectively.
A <code>matsindf</code>-style matrix has named rows and columns.
In addition, <code>matsindf</code>-style matrices have &quot;types&quot; for row and column information,
such as &quot;Commodities&quot;, &quot;Industries&quot;, &quot;Products&quot;, or &quot;Machines&quot;.
The row and column types for the <code>matsindf</code>-style matrices are stored as attributes on the matrix
(<code>rowtype</code> and <code>coltype</code>),
which can be accessed with the functions <code>matsbyname::rowtype()</code> and <code>matsbyname::coltype()</code>.
Row and column types are both respected and propagated by the various <code style="white-space: pre;">&#8288;*_byname&#8288;</code> functions
of the <code>matsbyname</code> package.
Use the <code style="white-space: pre;">&#8288;*_byname&#8288;</code> functions when you do operations on the <code>matsindf</code>-style matrices.
The <code>matsindf</code>-style matrices will be stored
in a column with same name as the incoming <code>values</code> column.
This function is similar to <code>tidyr::nest()</code>, which stores data frames into a cell of a data frame.
With <code>collapse_to_matrices</code>, matrices are created.
This function respects groups, like <code>dplyr::summarise()</code>.
(In fact, calls to this function may not work properly unless grouping is provided.
Errors of the form &quot;Error: Duplicate identifiers for rows ...&quot; are usually fixed by
grouping <code>.DF</code> prior to calling this function.)
The usual approach is to <code>dplyr::group_by()</code> the <code>matnames</code> column
and any other columns to be preserved in the output.
Note that execution is halted if any of
<code>rownames</code>, <code>colnames</code>, <code>rowtypes</code>, <code>coltypes</code>, or <code>values</code> is a grouping variable in <code>.DF</code>.
<code>rowtypes</code> and <code>coltypes</code> should be the same for all rows of the same matrix in <code>.DF</code>;
execution is halted if that is not the case.
<code>tidyr::pivot_wider()</code>ing the output by <code>matnames</code> may be necessary before
calculations are done on the collapsed matrices.
See the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_to_matrices(
  .DF,
  matnames = "matnames",
  matvals = "matvals",
  rownames = "rownames",
  colnames = "colnames",
  rowtypes = if ("rowtypes" %in% names(.DF)) "rowtypes" else NULL,
  coltypes = if ("coltypes" %in% names(.DF)) "coltypes" else NULL,
  matrix.class = lifecycle::deprecated(),
  matrix_class = c("matrix", "Matrix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_to_matrices_+3A_.df">.DF</code></td>
<td>
<p>the &quot;tidy&quot; data frame</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_matnames">matnames</code></td>
<td>
<p>A string identifying the column in <code>.DF</code> containing matrix names for matrices to be created.
Default is &quot;matnames&quot;.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_matvals">matvals</code></td>
<td>
<p>A string identifying the column in <code>.DF</code> containing values to be inserted into the matrices to be created.
This will also be the name of the column in the output containing matrices formed from the
data in the <code>matvals</code> column.
Default is &quot;matvals&quot;.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_rownames">rownames</code></td>
<td>
<p>A string identifying the column in <code>.DF</code> containing row names for matrices to be created.
Default is &quot;rownames&quot;.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_colnames">colnames</code></td>
<td>
<p>A string identifying the column in <code>.DF</code> containing column names for matrices to be created.
Default is &quot;colnames&quot;.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_rowtypes">rowtypes</code></td>
<td>
<p>An optional string identifying the column in <code>.DF</code> containing the type of values in rows of the matrices to be created.
Default is <code>if ("rowtypes" %in% names(.DF)) "rowtypes" else NULL</code>,
so that failure to set the rowtypes argument will give <code>NULL</code>, as appropriate.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_coltypes">coltypes</code></td>
<td>
<p>An optional string identifying the column in <code>.DF</code> containing the type of values in columns of the matrices to be created
Default is <code>if ("coltypes" %in% names(.DF)) "rowtypes" else NULL</code>,
so that failure to set the coltypes argument will give <code>NULL</code>, as appropriate.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_matrix.class">matrix.class</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>matrix_class</code> instead.</p>
</td></tr>
<tr><td><code id="collapse_to_matrices_+3A_matrix_class">matrix_class</code></td>
<td>
<p>One of &quot;matrix&quot; or &quot;Matrix&quot;.
&quot;matrix&quot; creates a <code>base::matrix</code> object with the <code>matrix()</code> function.
&quot;Matrix&quot; creates a <code>Matrix::Matrix</code> object using the <code>matsbyname::Matrix()</code> function.
This could be a sparse matrix.
Default is &quot;matrix&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Groups are not preserved on output.
</p>
<p>Note that two types of matrices can be created, a <code>matrix</code> or a <code>Matrix</code>.
<code>Matrix</code> has the advantage of representing sparse matrices with less memory
(and disk space).
<code>Matrix</code> objects are created by <code>matsbyname::Matrix()</code>.
</p>


<h3>Value</h3>

<p>A data frame with matrices in the <code>matvals</code> column.
</p>


<h3>See Also</h3>

<p><code>tidyr::nest()</code> and <code>dplyr::summarise()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidyr)
library(tibble)
ptype &lt;- "Products"
itype &lt;- "Industries"
tidy &lt;- data.frame(Country = c( "GH",  "GH",  "GH",  "GH",  "GH",  "GH",  "GH",
                                "US",  "US",  "US",  "US", "GH", "US"),
                  Year    = c(  1971,  1971,  1971,  1971,  1971,  1971,  1971,
                                1980,  1980,  1980,  1980, 1971, 1980),
                  matrix  = c(   "U",   "U",   "E",   "E",   "E",   "V",   "V",
                                 "U",   "U",   "E",   "E", "eta", "eta"),
                  row     = c( "c 1", "c 2", "c 1", "c 2", "c 2", "i 1", "i 2",
                               "c 1", "c 1", "c 1", "c 2", NA, NA),
                  col     = c( "i 1", "i 2", "i 1", "i 2", "i 3", "c 1", "c 2",
                               "i 1", "i 2", "i 1", "i 2", NA, NA),
                  rowtypes = c( ptype, ptype, ptype, ptype, ptype, itype, itype,
                                ptype, ptype, ptype, ptype, NA, NA),
                  coltypes = c( itype, itype, itype, itype, itype, ptype, ptype,
                                itype, itype, itype, itype, NA, NA),
                  vals  = c(    11  ,  22,    11 ,   22 ,   23 ,   11 ,   22 ,
                                11 ,   12 ,   11 ,   22,   0.2, 0.3)
) %&gt;% group_by(Country, Year, matrix)
mats &lt;- collapse_to_matrices(tidy, matnames = "matrix", matvals = "vals",
                             rownames = "row", colnames = "col",
                             rowtypes = "rowtypes", coltypes = "coltypes")
mats %&gt;% pivot_wider(names_from = matrix, values_from = vals)
</code></pre>

<hr>
<h2 id='df_to_msg'>Create a message from a data frame</h2><span id='topic+df_to_msg'></span>

<h3>Description</h3>

<p>This function is especially helpful for cases when a data frame
of missing or unset values is at hand.
Trim unneeded columns, then call this function
to create a string with rows separated by semicolons and entries separated by commas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_msg(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_to_msg_+3A_df">df</code></td>
<td>
<p>The data frame to be converted to a message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with rows separated by semicolons and entries separated by commas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.frame(a = c(1, 2, 3), b = c("a", "b", "c")) |&gt;
  df_to_msg()
</code></pre>

<hr>
<h2 id='everything_except'>Get symbols for all columns except ...</h2><span id='topic+everything_except'></span>

<h3>Description</h3>

<p>This convenience function performs a set difference between
the columns of <code>.DF</code> and the variable names (or symbols) given in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>everything_except(.DF, ..., .symbols = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="everything_except_+3A_.df">.DF</code></td>
<td>
<p>A data frame whose variable names are to be differenced.</p>
</td></tr>
<tr><td><code id="everything_except_+3A_...">...</code></td>
<td>
<p>A string, strings, vector of strings, or list of strings representing column names to be subtracted from the names of <code>.DF</code>/</p>
</td></tr>
<tr><td><code id="everything_except_+3A_.symbols">.symbols</code></td>
<td>
<p>A boolean that defines the return type: <code>TRUE</code> for symbols, <code>FALSE</code> for strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of symbols (when <code>.symbols = TRUE</code>) or
strings (when <code>symbol = FALSE</code>) containing all variables names except those given in <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DF &lt;- data.frame(a = c(1, 2), b = c(3, 4), c = c(5, 6))
everything_except(DF, "a", "b")
everything_except(DF, "a", "b", symbols = FALSE)
everything_except(DF, c("a", "b"))
everything_except(DF, list("a", "b"))
</code></pre>

<hr>
<h2 id='expand_to_tidy'>Expand a <code>matsindf</code> data frame</h2><span id='topic+expand_to_tidy'></span>

<h3>Description</h3>

<p>Any tidy data frame of matrices (in which each row represents one matrix observation)
can also be represented as a tidy data frame
with each non-zero matrix entry as an observation on its own row.
This function (and <code>collapse_to_matrices()</code>) convert between the two representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_to_tidy(
  .DF,
  matnames = "matnames",
  matvals = "matvals",
  rownames = "rownames",
  colnames = "colnames",
  rowtypes = "rowtypes",
  coltypes = "coltypes",
  drop = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_to_tidy_+3A_.df">.DF</code></td>
<td>
<p>The data frame containing <span class="pkg">matsindf</span>-style matrices.
(<code>.DF</code> may also be a named list of matrices, in which case
names of the matrices are taken from the names of items in the list and
list items are expected to be matrices.)</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_matnames">matnames</code></td>
<td>
<p>The name of the column in <code>.DF</code> containing matrix names (a string).
Default is &quot;matnames&quot;.</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_matvals">matvals</code></td>
<td>
<p>The name of the column in <code>.DF</code> containing IO-style matrices or constants (a string),
This will also be the name of the column containing matrix entries in the output data frame.
Default is &quot;matvals&quot;.</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_rownames">rownames</code></td>
<td>
<p>The name for the output column of row names (a string).
Default is &quot;rownames&quot;.</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_colnames">colnames</code></td>
<td>
<p>The name for the output column of column names (a string).
Default is &quot;colnames&quot;.</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_rowtypes">rowtypes</code></td>
<td>
<p>An optional name for the output column of row types (a string).
Default is &quot;rowtypes&quot;.</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_coltypes">coltypes</code></td>
<td>
<p>The optional name for the output column of column types (a string)
Default is &quot;coltypes&quot;.</p>
</td></tr>
<tr><td><code id="expand_to_tidy_+3A_drop">drop</code></td>
<td>
<p>If specified, the value to be dropped from output,
For example, <code>drop = 0</code> will cause <code>0</code> entries in the matrices to be deleted from output.
If <code>NA</code>, no values are dropped from output.
Default is <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names for output columns are specified in the <code>rownames</code>, <code>colnames</code>,
<code>rowtypes</code>, and <code>coltypes</code>, arguments.
The entries of the <span class="pkg">matsindf</span>-style matrices are stored in an output column named <code>values.</code>
</p>


<h3>Value</h3>

<p>A tidy data frame containing expanded <span class="pkg">matsindf</span>-style matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(matsbyname)
ptype &lt;- "Products"
itype &lt;- "Industries"
tidy &lt;- data.frame(Country  = c( "GH",  "GH",  "GH",  "GH",  "GH",  "GH",  "GH",
                                 "US",  "US",  "US",  "US", "GH", "US"),
                  Year      = c( 1971,  1971,  1971,  1971,  1971,  1971,  1971,
                                 1980,  1980,  1980,  1980, 1971, 1980),
                  matrix    = c(  "U",   "U",   "Y",   "Y",   "Y",   "V",   "V",
                                  "U",   "U",   "Y",   "Y", "eta", "eta"),
                  row       = c(  "c1",  "c2",  "c1",  "c2",  "c2",  "i1",  "i2",
                                  "c1",  "c1",  "c1",  "c2", NA, NA),
                  col       = c(  "i1",  "i2",  "i1",  "i2",  "i3",  "c1",  "c2",
                                  "i1",  "i2",  "i1",  "i2", NA, NA),
                  rowtypes  = c( ptype, ptype, ptype, ptype, ptype, itype, itype,
                                 ptype, ptype, ptype, ptype, NA, NA),
                  coltypes  = c(itype, itype, itype, itype, itype, ptype, ptype,
                                itype, itype, itype, itype, NA, NA),
                  vals      = c(11  ,  22,    11 ,   22 ,   23 ,   11 ,   22 ,
                                11 ,   12 ,   11 ,   22,   0.2, 0.3)) %&gt;%
  group_by(Country, Year, matrix)
mats &lt;- collapse_to_matrices(tidy, matnames = "matrix", rownames = "row", colnames = "col",
                             rowtypes = "rowtypes", coltypes = "coltypes",
                             matvals = "vals") %&gt;%
  ungroup()
expand_to_tidy(mats, matnames = "matrix", matvals = "vals",
                     rownames = "rows", colnames = "cols",
                     rowtypes = "rt",   coltypes = "ct")
expand_to_tidy(mats, matnames = "matrix", matvals = "vals",
                     rownames = "rows", colnames = "cols",
                     rowtypes = "rt",   coltypes = "ct", drop = 0)
</code></pre>

<hr>
<h2 id='get_useable_default_args'>Create a usable list of default arguments to a function</h2><span id='topic+get_useable_default_args'></span>

<h3>Description</h3>

<p><code>formals(FUN)</code> does not handle arguments without a default well,
returning a <code>name</code> vector of length <code>1</code>,
which when converted to character is &quot;&quot;.
This function detects that condition and replaces the no-default argument with
the value of <code>.no_default</code>, by default <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_useable_default_args(FUN, which = c("values", "names"), no_default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_useable_default_args_+3A_fun">FUN</code></td>
<td>
<p>A function from which values of default arguments are to be extracted.</p>
</td></tr>
<tr><td><code id="get_useable_default_args_+3A_which">which</code></td>
<td>
<p>Tells whether to get &quot;names&quot; of arguments or &quot;values&quot; of arguments.
Default is &quot;values&quot;.</p>
</td></tr>
<tr><td><code id="get_useable_default_args_+3A_no_default">no_default</code></td>
<td>
<p>The placeholder value for arguments with no default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of default arguments to <code>FUN</code>.
Names are the argument names.
Values are the default argument values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- function(a = 42, b) {
  return(a + b)
}
matsindf:::get_useable_default_args(f)
matsindf:::get_useable_default_args(f, no_default = logical())
</code></pre>

<hr>
<h2 id='group_by_everything_except'>Group by all variables except some</h2><span id='topic+group_by_everything_except'></span>

<h3>Description</h3>

<p>This is a convenience function
that allows grouping of a data frame by all variables (columns)
except those variables specified in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_everything_except(.DF, ..., .add = FALSE, .drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_everything_except_+3A_.df">.DF</code></td>
<td>
<p>A data frame to be grouped.</p>
</td></tr>
<tr><td><code id="group_by_everything_except_+3A_...">...</code></td>
<td>
<p>A string, strings, vector of strings, or list of strings representing column names to be excluded from grouping.</p>
</td></tr>
<tr><td><code id="group_by_everything_except_+3A_.add">.add</code></td>
<td>
<p>When <code>.add = FALSE</code>, the default, <code>dplyr::group_by()</code> will override existing groups.
To add to the existing groups, use <code>.add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="group_by_everything_except_+3A_.drop">.drop</code></td>
<td>
<p>When <code>.drop = TRUE</code>, empty groups are dropped. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grouped version of <code>.DF</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
DF &lt;- data.frame(a = c(1, 2), b = c(3, 4), c = c(5, 6))
group_by_everything_except(DF) %&gt;% group_vars()
group_by_everything_except(DF, NULL) %&gt;% group_vars()
group_by_everything_except(DF, c()) %&gt;% group_vars()
group_by_everything_except(DF, list()) %&gt;% group_vars()
group_by_everything_except(DF, c) %&gt;% group_vars()
group_by_everything_except(DF, "a") %&gt;% group_vars()
group_by_everything_except(DF, "c") %&gt;% group_vars()
group_by_everything_except(DF, c("a", "c")) %&gt;% group_vars()
group_by_everything_except(DF, c("a")) %&gt;% group_vars()
group_by_everything_except(DF, list("a")) %&gt;% group_vars()
</code></pre>

<hr>
<h2 id='handle_empty_data'>Gracefully handle empty data</h2><span id='topic+handle_empty_data'></span>

<h3>Description</h3>

<p>When empty data are provided to <code>matsindf_apply()</code>,
care must be take with the return value.
This function assembles the correct zero-row data frame or
zero-length lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_empty_data(.dat = NULL, FUN, DF, types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_empty_data_+3A_.dat">.dat</code></td>
<td>
<p>The <code>.dat</code> argument to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="handle_empty_data_+3A_fun">FUN</code></td>
<td>
<p>The <code>FUN</code> argument to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="handle_empty_data_+3A_df">DF</code></td>
<td>
<p>The assembled <code>DF</code> inside <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="handle_empty_data_+3A_types">types</code></td>
<td>
<p>The <code>types</code> object assembled inside <code>matsindf_apply()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The appropriate return value from <code>matsindf_apply()</code>,
either a zero-length list or a zero-row data frame.
</p>

<hr>
<h2 id='handle_null_args'>Gracefully handle <code>NULL</code> arguments</h2><span id='topic+handle_null_args'></span>

<h3>Description</h3>

<p>When <code>NULL</code> is passed as an element of the <code>.dat</code> or <code>...</code> arguments
to <code>matsindf_apply()</code>, special care must be taken.
This function helps in those situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_null_args(.arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_null_args_+3A_.arg">.arg</code></td>
<td>
<p>One of <code>.dat</code> or <code>...</code> (as a list) arguments to <code>matsindf_apply()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list representation of <code>.arg</code> with <code>NULL</code> values handled appropriately.
</p>

<hr>
<h2 id='index_column'>Index a column in a data frame by groups relative to an initial year</h2><span id='topic+index_column'></span>

<h3>Description</h3>

<p>This function indexes (by ratio) variables in <code>vars_to_index</code>
to the first time in <code>time_var</code>
or to <code>index_time</code> (if specified).
Groups in <code>.DF</code> are both respected and required.
Neither <code>var_to_index</code> nor <code>time_var</code> can be in the grouping variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_column(
  .DF,
  var_to_index,
  time_var = "Year",
  index_time = NULL,
  indexed_var = paste0(var_to_index, suffix),
  suffix = "_indexed"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_column_+3A_.df">.DF</code></td>
<td>
<p>the data frame in which the variables are contained</p>
</td></tr>
<tr><td><code id="index_column_+3A_var_to_index">var_to_index</code></td>
<td>
<p>the column name representing the variable to be indexed (a string)</p>
</td></tr>
<tr><td><code id="index_column_+3A_time_var">time_var</code></td>
<td>
<p>the name of the column containing time information.
Default is &quot;<code>Year</code>&quot;.</p>
</td></tr>
<tr><td><code id="index_column_+3A_index_time">index_time</code></td>
<td>
<p>the time to which data in <code>var_to_index</code> are indexed.
If <code>NULL</code> (the default), <code>index_time</code> is set to the first time of each group.</p>
</td></tr>
<tr><td><code id="index_column_+3A_indexed_var">indexed_var</code></td>
<td>
<p>the name of the indexed variable. Default is &quot;<code>&lt;&lt;var_to_index&gt;&gt;_&lt;&lt;suffix&gt;&gt;</code>&quot;.</p>
</td></tr>
<tr><td><code id="index_column_+3A_suffix">suffix</code></td>
<td>
<p>the suffix to be appended to the indexed variable. Default is &quot;<code>_indexed</code>&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function works when the variable to index is
a column of numbers or a column of matrices.
</p>


<h3>Value</h3>

<p>a data frame with same number of rows as <code>.DF</code> and the following columns:
grouping variables of <code>.DF</code>, <code>var_to_index</code>, <code>time_var</code>,
and one additional column containing indexed <code>var_to_index</code>
named with the value of <code>indexed_var</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidyr)
DF &lt;- data.frame(Year = c(2000, 2005, 2010), a = c(10, 15, 20), b = c(5, 5.5, 6)) %&gt;%
  gather(key = name, value = var, a, b) %&gt;%
  group_by(name)
index_column(DF, var_to_index = "var", time_var = "Year", suffix = "_ratioed")
index_column(DF, var_to_index = "var", time_var = "Year", indexed_var = "now.indexed")
index_column(DF, var_to_index = "var", time_var = "Year", index_time = 2005,
             indexed_var = "now.indexed")
## Not run: 
  DF %&gt;%
    ungroup() %&gt;%
    group_by(name, var) %&gt;%
    index_column(var_to_index = "var", time_var = "Year") # Fails! Do not group on var_to_index.
  DF %&gt;%
    ungroup() %&gt;%
    group_by(name, Year) %&gt;%
    index_column(var_to_index = "var", time_var = "Year") # Fails! Do not group on time_var.

## End(Not run)
</code></pre>

<hr>
<h2 id='mat_to_rowcolval'>Convert a matrix to a data frame with rows, columns, and values.</h2><span id='topic+mat_to_rowcolval'></span>

<h3>Description</h3>

<p>This function &quot;expands&quot; a matrix into a tidy data frame with
a values column and
factors for row names, column names, row types, and column types.
Optionally, values can be dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_to_rowcolval(
  .matrix,
  matvals = "matvals",
  rownames = "rownames",
  colnames = "colnames",
  rowtypes = "rowtypes",
  coltypes = "coltypes",
  drop = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_to_rowcolval_+3A_.matrix">.matrix</code></td>
<td>
<p>The IO-style matrix to be converted to a data frame with rows, columns, and values.</p>
</td></tr>
<tr><td><code id="mat_to_rowcolval_+3A_matvals">matvals</code></td>
<td>
<p>A string for the name of the output column containing values. Default is &quot;matvals&quot;.</p>
</td></tr>
<tr><td><code id="mat_to_rowcolval_+3A_rownames">rownames</code></td>
<td>
<p>A string for the name of the output column containing row names. Default is &quot;rownames&quot;.</p>
</td></tr>
<tr><td><code id="mat_to_rowcolval_+3A_colnames">colnames</code></td>
<td>
<p>A string for the name of the output column containing column names. Default is &quot;colnames&quot;.</p>
</td></tr>
<tr><td><code id="mat_to_rowcolval_+3A_rowtypes">rowtypes</code></td>
<td>
<p>A string for the name of the output column containing row types. Default is &quot;rowtypes&quot;.</p>
</td></tr>
<tr><td><code id="mat_to_rowcolval_+3A_coltypes">coltypes</code></td>
<td>
<p>A string for the name of the output column containing column types. Default is &quot;coltypes&quot;.</p>
</td></tr>
<tr><td><code id="mat_to_rowcolval_+3A_drop">drop</code></td>
<td>
<p>If specified, the value to be dropped from output. Default is <code>NA</code>.
For example, <code>drop = 0</code> will cause <code>0</code> entries in the matrices to be deleted from output.
If <code>NA</code>, no values are dropped from output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with rows, columns, and values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(matsbyname)
data &lt;- data.frame(Country  = c("GH", "GH", "GH"),
                   rows = c( "c1",  "c1", "c2"),
                   cols = c( "i1",  "i2", "i2"),
                   rt = c("Commodities", "Commodities", "Commodities"),
                   ct = c("Industries", "Industries", "Industries"),
                   vals = c(  11  ,  12,   22 ))
data
A &lt;- data %&gt;%
  rowcolval_to_mat(rownames = "rows", colnames = "cols",
                   rowtypes = "rt",   coltypes = "ct", matvals = "vals")
A
mat_to_rowcolval(A, rownames = "rows", colnames = "cols",
                 rowtypes = "rt", coltypes = "ct", matvals = "vals")
mat_to_rowcolval(A, rownames = "rows", colnames = "cols",
                 rowtypes = "rt", coltypes = "ct", matvals = "vals", drop = 0)
# This also works for single values
mat_to_rowcolval(2, matvals = "vals",
                 rownames = "rows", colnames = "cols",
                 rowtypes = "rt", coltypes = "ct")
mat_to_rowcolval(0, matvals = "vals",
                 rownames = "rows", colnames = "cols",
                 rowtypes = "rt", coltypes = "ct", drop = 0)
</code></pre>

<hr>
<h2 id='matrix_cols'>Find columns that contain matrices</h2><span id='topic+matrix_cols'></span>

<h3>Description</h3>

<p>It is often helpful to find the columns of a <code>matsindf</code>
data frame that contain exclusively or some matrices.
This function helps with that task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_cols(.df, .drop_names = FALSE, .any = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_cols_+3A_.df">.df</code></td>
<td>
<p>The data frame to be queried for matrix columns.</p>
</td></tr>
<tr><td><code id="matrix_cols_+3A_.drop_names">.drop_names</code></td>
<td>
<p>A boolean that tells whether to remove the names from
the returned integer vector.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="matrix_cols_+3A_.any">.any</code></td>
<td>
<p>A boolean that tells whether a column is reported when
<code>any()</code> of the rows contain matrices
(instead of <code>all()</code> rows contain matrices).
Default is <code>FALSE</code>, in which case
all entries in a column must be a matrix for
the column to be reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a column is considered a matrix column if <code>all()</code> of the
rows contain matrices.
Use the <code>.test_any</code> argument to modify this behavior.
</p>
<p>By default, the vector of integers returned from this function
is named by the columns.
Use the <code>.drop_names</code> function to modify this behavior.
</p>


<h3>Value</h3>

<p>A vector of integers saying which columns contain matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tidy &lt;- tibble::tibble(matrix = c("V1", "V1", "V1", "V2", "V2"),
                         row = c("i1", "i1", "i2", "i1", "i2"),
                         col = c("p1", "p2", "p2", "p1", "p2"),
                         vals = c(1, 2, 3, 4, 5)) %&gt;%
  dplyr::mutate(
    rowtypes = "Industries",
    coltypes  = "Products"
  ) %&gt;%
  dplyr::group_by(matrix)
matsdf &lt;- tidy %&gt;%
  collapse_to_matrices(matnames = "matrix", matvals = "vals",
                       rownames = "row", colnames = "col",
                       rowtypes = "rowtypes", coltypes = "coltypes")
matsdf
matrix_cols(matsdf)
matrix_cols(matsdf, .drop_names = TRUE)
</code></pre>

<hr>
<h2 id='matsindf_apply'>Apply a function to a <code>matsindf</code> data frame (and more)</h2><span id='topic+matsindf_apply'></span>

<h3>Description</h3>

<p>Applies <code>FUN</code> to <code>.dat</code> or
performs the calculation specified by <code>FUN</code>
on numbers or matrices.
<code>FUN</code> must return a named list.
The values of the list returned <code>FUN</code> become
entries in columns in a returned data frame
or entries in the sub-lists of a returned list.
The names of the items in the list returned by <code>FUN</code> become
names of the columns in a returned data frame or
names of the list items in the returned list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matsindf_apply(.dat = NULL, FUN, ..., .warn_missing_FUN_args = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matsindf_apply_+3A_.dat">.dat</code></td>
<td>
<p>A list of named items or a data frame.</p>
</td></tr>
<tr><td><code id="matsindf_apply_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied to <code>.dat</code>.</p>
</td></tr>
<tr><td><code id="matsindf_apply_+3A_...">...</code></td>
<td>
<p>Named arguments to be passed by name to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="matsindf_apply_+3A_.warn_missing_fun_args">.warn_missing_FUN_args</code></td>
<td>
<p>A boolean that tells
whether to warn of missing arguments to <code>FUN</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>is.null(.dat)</code> and <code>...</code> are all named numbers or matrices
of the form <code>argname = m</code>,
<code>m</code>s are passed to <code>FUN</code> by <code>argname</code>s.
The return value is a named list provided by <code>FUN</code>.
The arguments in <code>...</code> are not included in the output.
</p>
<p>If <code>is.null(.dat)</code> and <code>...</code> are all lists of numbers or matrices
of the form <code>argname = l</code>,
<code>FUN</code> is <code>Map</code>ped across the various <code>l</code>s
to obtain a list of named lists returned from <code>FUN</code>.
The return value is a list
whose top-level names are the names of the returned items from <code>FUN</code>
<code>.dat</code> is not included in the return value.
</p>
<p>If <code>!is.null(.dat)</code> and <code>...</code> are all named, <code>length == 1</code> character strings
of the form <code>argname = string</code>,
<code>argname</code>s are expected to be names of arguments to <code>FUN</code>, and
<code>string</code>s are expected to be column names in <code>.dat</code>.
The return value is <code>.dat</code> with additional columns (at right)
whose names are the names of list items returned from <code>FUN</code>.
When <code>.dat</code> contains columns whose names are same as columns added at the right,
a warning is emitted.
</p>
<p><code>.dat</code> can be a list of named items in which case a list will be returned
instead of a data frame.
</p>
<p>If items in <code>.dat</code> have same names as arguments to <code>FUN</code>,
it is not necessary to specify any arguments in <code>...</code>.
<code>matsindf_apply</code> assumes that the appropriately-named items in <code>.dat</code> are
intended to be arguments to <code>FUN</code>.
When an item name appears in both <code>...</code> and <code>.dat</code>,
<code>...</code> takes precedence.
</p>
<p>if <code>.dat</code> is a data frame,
the items in its columns (possibly matrices)
are <code>unname()</code>d before calling <code>FUN</code>.
</p>
<p><code>NULL</code> arguments in <code>...</code> are ignored for the purposes of deciding whether
all arguments are numbers, matrices, lists of numbers of matrices, or named character strings.
However, all <code>NULL</code> arguments are passed to <code>FUN</code>,
so <code>FUN</code> should be able to deal with <code>NULL</code> arguments appropriately.
</p>
<p>If <code>.dat</code> is present, <code>...</code> contains <code>length == 1</code> strings, and one of the <code>...</code> strings is not the name
of a column in <code>.dat</code>,
<code>FUN</code> is called WITHOUT the argument whose column is missing.
I.e., that argument is treated as missing.
If <code>FUN</code> works despite the missing argument, execution proceeds.
If <code>FUN</code> cannot handle the missing argument, an error will occur in <code>FUN</code>.
</p>
<p>It is suggested that <code>FUN</code> is able to handle empty data gracefully,
returning an empty result with the same names as when
non-empty data are fed to <code>FUN</code>.
Attempts are made to handle zero-row data (in <code>.dat</code> or <code>...</code>)
gracefully.
First, <code>FUN</code> is called with the empty (but named) data.
If <code>FUN</code> can handle empty data without error,
the result is returned.
If <code>FUN</code> errors when fed empty data, <code>FUN</code> is called with an empty
argument list in the hopes that <code>FUN</code> has reasonable default values.
If that fails,
<code>.dat</code> is returned unmodified (if not <code>NULL</code>)
or the data in <code>...</code> is returned.
</p>
<p>If <code>.dat</code> is <code>NULL</code> and all named arguments in <code>...</code>
are similarly <code>NULL</code>,
the result will be a list with each named argument
being an empty list.
See examples.
</p>


<h3>Value</h3>

<p>A named list or a data frame. (See details.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(matsbyname)
example_fun &lt;- function(a, b){
  return(list(c = sum_byname(a, b),
              d = difference_byname(a, b)))
}
# Single values for arguments
matsindf_apply(FUN = example_fun, a = 2, b = 2)
# Matrices for arguments
a &lt;- 2 * matrix(c(1,2,3,4), nrow = 2, ncol = 2, byrow = TRUE,
              dimnames = list(c("r1", "r2"), c("c1", "c2")))
b &lt;- 0.5 * a
matsindf_apply(FUN = example_fun, a = a, b = b)
# Single values in lists are treated like columns of a data frame
matsindf_apply(FUN = example_fun, a = list(2, 2), b = list(1, 2))
# Matrices in lists are treated like columns of a data frame
matsindf_apply(FUN = example_fun, a = list(a, a), b = list(b, b))
# Single numbers in a data frame
DF &lt;- data.frame(a = c(4, 4, 5), b = c(4, 4, 4))
matsindf_apply(DF, FUN = example_fun, a = "a", b = "b")
# By default, arguments to FUN come from DF
matsindf_apply(DF, FUN = example_fun)
# Now put some matrices in a data frame.
DF2 &lt;- data.frame(a = I(list(a, a)), b = I(list(b,b)))
matsindf_apply(DF2, FUN = example_fun, a = "a", b = "b")
# All arguments to FUN are supplied by named items in .dat
matsindf_apply(list(a = 1, b = 2), FUN = example_fun)
# All arguments are supplied by named arguments in ..., but mix them up.
# Note that the named arguments override the items in .dat
matsindf_apply(list(a = 1, b = 2, z = 10), FUN = example_fun, a = "z", b = "b")
# A warning is issued when an output item has same name as an input item.
matsindf_apply(list(a = 1, b = 2, c = 10), FUN = example_fun, a = "c", b = "b")
# When a zero-row data frame supplied to .dat,
# .dat is returned unmodified, unless FUN can handle empty data.
DF3 &lt;- DF2[0, ]
DF3
matsindf_apply(DF3, FUN = example_fun, a = "a", b = "b")
# A list of named but empty lists is returned if
# NULL is passed to all named arguments.
matsindf_apply(FUN = example_fun, a = NULL, b = NULL)
</code></pre>

<hr>
<h2 id='matsindf_apply_types'>Determine types of <code>.dat</code> and <code>...</code> arguments for matsindf_apply()</h2><span id='topic+matsindf_apply_types'></span>

<h3>Description</h3>

<p>This is a convenience function that returns a list
for the types of <code>.dat</code> and <code>...</code> as well as names in <code>.dat</code> and <code>...</code>,
with components named <code>.dat_null</code>, <code>.dat_df</code>, <code>.dat_list</code>, <code>.dat_names</code>,
<code>FUN_arg_all_names</code>, <code>FUN_arg_default_names</code>, <code>FUN_arg_default_values</code>,
<code>dots_present</code>, <code>all_dots_num</code>, <code>all_dots_mats</code>,
<code>all_dots_list</code>, <code>all_dots_vect</code>, <code>all_dots_char</code>,
<code>all_dots_longer_than_1</code>, <code>dots_names</code>, and
<code>keep_args</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matsindf_apply_types(.dat = NULL, FUN, ..., .warn_missing_FUN_args = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matsindf_apply_types_+3A_.dat">.dat</code></td>
<td>
<p>The <code>.dat</code> argument to be checked.</p>
</td></tr>
<tr><td><code id="matsindf_apply_types_+3A_fun">FUN</code></td>
<td>
<p>The function sent to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="matsindf_apply_types_+3A_...">...</code></td>
<td>
<p>The list of arguments to <code>matsindf_apply()</code> to be checked.</p>
</td></tr>
<tr><td><code id="matsindf_apply_types_+3A_.warn_missing_fun_args">.warn_missing_FUN_args</code></td>
<td>
<p>A boolean that tells
whether to warn of missing arguments to <code>FUN</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>.dat</code> is a <code>data.frame</code>, both <code>.dat_list</code> and <code>.dat_df</code> are <code>TRUE</code>.
</p>
<p>When arguments are present in <code>...</code>, <code>dots_present</code> is <code>TRUE</code> but <code>FALSE</code> otherwise.
When all items in <code>...</code> are single numbers, <code>all_dots_num</code> is <code>TRUE</code> and all other list members are <code>FALSE</code>.
When all items in <code>...</code> are matrices, <code>all_dots_mats</code> is <code>TRUE</code> and all other list members are <code>FALSE</code>.
When all items in <code>...</code> are lists, <code>all_dots_list</code> is <code>TRUE</code> and all other list members are <code>FALSE</code>.
When all items in <code>...</code> are vectors (including lists), <code>all_dots_vect</code> is <code>TRUE</code>.
When all items in <code>...</code> have length &gt; 1, <code>all_dots_longer_than_1</code> is <code>TRUE</code>.
When all items in <code>...</code> are character strings, <code>all_dots_char</code> is <code>TRUE</code> and all other list members are <code>FALSE</code>.
</p>
<p>The various <code style="white-space: pre;">&#8288;FUN_arg_*&#8288;</code> components give information about the arguments to <code>FUN</code>.
<code>FUN_arg_all_names</code> gives the names of all arguments to <code>FUN</code>,
regardless of whether they have default values.
<code>FUN_arg_default_names</code> gives the names of only those arguments with default values.
<code>FUN_arg_default_values</code> gives the values of the default arguments,
already <code>eval()</code>ed in the global environment.
When there are no values in a category, <code>NULL</code> is returned.
thus, if <code>FUN</code> has no arguments with default values assigned in the signature of the function,
both <code>FUN_arg_default_names</code> and <code>FUN_arg_default_values</code> will be <code>NULL</code>.
If <code>FUN</code> has no arguments, all of
<code>FUN_arg_all_names</code>, <code>FUN_arg_default_names</code> and <code>FUN_arg_default_values</code> will be <code>NULL</code>.
</p>
<p><code>keep_args</code> is a named <code>list()</code> of arguments,
which indicates which arguments to keep from which source
(<code>...</code>, <code>.dat</code>, or default args to <code>FUN</code>)
by order of preference,
<code>...</code> over <code>.dat</code> over default arguments to <code>FUN</code>.
Arguments not used by <code>FUN</code> are kept,
again according to the rules of preference.
</p>


<h3>Value</h3>

<p>A logical list with components named
<code>.dat_null</code>, <code>.dat_df</code>, <code>.dat_list</code>, <code>.dat_names</code>,
<code>FUN_arg_all_names</code>, <code>FUN_arg_default_names</code>, <code>FUN_arg_default_values</code>,
<code>dots_present</code>, <code>all_dots_num</code>, <code>all_dots_mats</code>,
<code>all_dots_list</code>, <code>all_dots_vect</code>, <code>all_dots_char</code>,
<code>all_dots_longer_than_1</code>, <code>dots_names</code>, and
<code>keep_args</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identity_fun &lt;- function(a, b) {list(a = a, b = b)}
matsindf_apply_types(.dat = NULL, FUN = identity_fun, a = 1, b = 2)
matsindf_apply_types(.dat = data.frame(), FUN = identity_fun,
                     a = matrix(c(1, 2)), b = matrix(c(2, 3)))
matsindf_apply_types(.dat = list(), FUN = identity_fun,
                     a = c(1, 2), b = c(3, 4))
matsindf_apply_types(.dat = NULL, FUN = identity_fun,
                     a = list(1, 2), b = list(3, 4))
</code></pre>

<hr>
<h2 id='rowcolval_to_mat'>Collapse a tidy data frame into a matrix with named rows and columns</h2><span id='topic+rowcolval_to_mat'></span>

<h3>Description</h3>

<p>Columns not specified in one of <code>rownames</code>, <code>colnames</code>, <code>rowtype</code>, <code>coltype</code>, or <code>values</code>
are silently dropped.
<code>rowtypes</code> and <code>coltypes</code> are added as attributes to the resulting matrix
(via <code>matsbyname::setrowtype()</code> and <code>matsbyname::setcoltype()</code>.
The resulting matrix is a (under the hood) a data frame.
If both <code>rownames</code> and <code>colnames</code> columns of <code>.DF</code> contain <code>NA</code>,
it is assumed that this is a single value, not a matrix,
in which case the value in the <code>values</code> column is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowcolval_to_mat(
  .DF,
  matvals = "matvals",
  rownames = "rownames",
  colnames = "colnames",
  rowtypes = "rowtypes",
  coltypes = "coltypes",
  fill = 0,
  matrix.class = lifecycle::deprecated(),
  matrix_class = c("matrix", "Matrix"),
  i_colname = "i",
  j_colname = "j"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowcolval_to_mat_+3A_.df">.DF</code></td>
<td>
<p>A tidy data frame containing columns for row names, column names, and values.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_matvals">matvals</code></td>
<td>
<p>The name of the column in <code>.DF</code> containing values with which to fill the matrix (a string). Default is &quot;matvals&quot;.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_rownames">rownames</code></td>
<td>
<p>The name of the column in <code>.DF</code> containing row names (a string). Default is &quot;rownames&quot;.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_colnames">colnames</code></td>
<td>
<p>The name of the column in <code>.DF</code> containing column names (a string). Default is &quot;colnames&quot;.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_rowtypes">rowtypes</code></td>
<td>
<p>An optional string identifying the types of information found in rows of the matrix to be constructed. Default is &quot;rowtypes&quot;.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_coltypes">coltypes</code></td>
<td>
<p>An optional string identifying the types of information found in columns of the matrix to be constructed. Default is &quot;coltypes&quot;.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_fill">fill</code></td>
<td>
<p>The value for missing entries in the resulting matrix. default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_matrix.class">matrix.class</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>matrix_class</code> instead.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_matrix_class">matrix_class</code></td>
<td>
<p>One of &quot;matrix&quot; or &quot;Matrix&quot;.
&quot;matrix&quot; creates a <code>base::matrix</code> object with the <code>matrix()</code> function.
&quot;Matrix&quot; creates a <code>Matrix::Matrix</code> object using the <code>matsbyname::Matrix()</code> function.
This could be a sparse matrix.
Default is &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="rowcolval_to_mat_+3A_i_colname">i_colname</code>, <code id="rowcolval_to_mat_+3A_j_colname">j_colname</code></td>
<td>
<p>Names of index columns used internally. Defaults are &quot;i&quot; and &quot;j&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that two types of matrices can be created, a <code>matrix</code> or a <code>Matrix</code>.
<code>Matrix</code> has the advantage of representing sparse matrices with less memory
(and disk space).
<code>Matrix</code> objects are created by <code>matsbyname::Matrix()</code>.
</p>


<h3>Value</h3>

<p>A matrix with named rows and columns and, optionally, row and column types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(matsbyname)
library(dplyr)
data &lt;- data.frame(Country  = c("GH", "GH", "GH"),
                   rows = c( "c 1",  "c 1", "c 2"),
                   cols = c( "i 1",  "i 2", "i 2"),
                   vals = c(   11  ,   12,    22 ))
A &lt;- rowcolval_to_mat(data, rownames = "rows", colnames = "cols", matvals = "vals")
A
rowtype(A) # NULL, because types not set
coltype(A) # NULL, because types not set
B &lt;- rowcolval_to_mat(data, rownames = "rows", colnames = "cols", matvals = "vals",
                            rowtypes  = "Commodities", coltypes  = "Industries")
B
C &lt;- data %&gt;% bind_cols(data.frame(rt = c("Commodities", "Commodities", "Commodities"),
                                   ct = c("Industries", "Industries", "Industries"))) %&gt;%
  rowcolval_to_mat(rownames = "rows", colnames = "cols", matvals = "vals",
                   rowtypes = "rt", coltypes = "ct")
C
# Also works for single values if both the rownames and colnames columns contain NA
data2 &lt;- data.frame(Country = c("GH"), rows = c(NA), cols = c(NA),
  rowtypes = c(NA), coltypes = c(NA), vals = c(2))
data2 %&gt;% rowcolval_to_mat(rownames = "rows", colnames = "cols", matvals = "vals",
  rowtypes = "rowtypes", coltypes = "coltypes")
data3 &lt;- data.frame(Country = c("GH"), rows = c(NA), cols = c(NA), vals = c(2))
data3 %&gt;% rowcolval_to_mat(rownames = "rows", colnames = "cols", matvals = "vals")
# Fails when rowtypes or coltypes not all same. In data3, column rt is not all same.
data4 &lt;- data %&gt;% bind_cols(data.frame(rt = c("Commodities", "Industries", "Commodities"),
                                       ct = c("Industries", "Industries", "Industries")))
## Not run: rowcolval_to_mat(data4, rownames = "rows", colnames = "cols",
                          matvals = "vals", rowtypes = "rt", coltypes = "ct")
## End(Not run)
</code></pre>

<hr>
<h2 id='should_unlist'>Tell whether a column can be unlisted</h2><span id='topic+should_unlist'></span>

<h3>Description</h3>

<p>When evaluating each row of a data frame in <code>matsindf_apply()</code>,
the result will be a <code>tibble</code> with list columns.
This function tells whether a column can be unlisted.
This is internal helper function and should not be called externally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>should_unlist(this_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="should_unlist_+3A_this_col">this_col</code></td>
<td>
<p>The column to be checked.
Or a <code>data.frame</code>, in which case every column is checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean. <code>TRUE</code> if the column can be unlisted, <code>FALSE</code> otherwise.
When <code>this_col</code> is a <code>data.frame</code>, a named boolean vector,
one entry for each column.
</p>

<hr>
<h2 id='UKEnergy2000'>Energy consumption in the UK in 2000</h2><span id='topic+UKEnergy2000'></span>

<h3>Description</h3>

<p>A dataset containing approximations to
some of the energy flows in the UK in the year 2000.
These data first appeared as the example in
Figures 3, 7, and 11 of
M.K. Heun, A. Owen, and P.E. Brockway. 2018.
A physical supply-use table framework for energy analysis on the energy conversion chain.
Applied Energy,
Vol. 226,
pp. 1134-1162.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UKEnergy2000
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 rows and 7 variables:
</p>

<dl>
<dt>Country</dt><dd><p>country, GB (Great Britain, only one country)</p>
</dd>
<dt>Year</dt><dd><p>year, 2000 (only one year)</p>
</dd>
<dt>Ledger.side</dt><dd><p>Supply or Consumption</p>
</dd>
<dt>Flow.aggregation.point</dt><dd><p>tells where each row should be aggregated</p>
</dd>
<dt>Flow</dt><dd><p>the Industry or Sector involved in this flow</p>
</dd>
<dt>Product</dt><dd><p>the energy product involved in this flow</p>
</dd>
<dt>E.ktoe</dt><dd><p>magnitude of the energy flow in ktoe</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.apenergy.2018.05.109">doi:10.1016/j.apenergy.2018.05.109</a>
</p>

<hr>
<h2 id='verify_cols_missing'>Verify that column names in a data frame are not already present</h2><span id='topic+verify_cols_missing'></span>

<h3>Description</h3>

<p>In the <code>Recca</code> package, many functions add columns to an existing data frame.
If the incoming data frame already contains columns with the names of new columns to be added,
a name collision could occur, deleting the existing column of data.
This function provides a way to quickly check whether <code>newcols</code> are already present in
<code>.DF</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_cols_missing(.DF, newcols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_cols_missing_+3A_.df">.DF</code></td>
<td>
<p>the data frame to which <code>newcols</code> are to be added</p>
</td></tr>
<tr><td><code id="verify_cols_missing_+3A_newcols">newcols</code></td>
<td>
<p>a single string, a single name,
a vector of strings representing the names of new columns to be added to <code>.DF</code>, or
a vector of names of new columns to be added to <code>.DF</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function terminates execution if a column of <code>.DF</code> will be overwritten
by one of the <code>newcols</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code>. This function should be called for its side effect of checking the validity
of the names of <code>newcols</code> to be added to <code>.DF</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(a = c(1,2), b = c(3,4))
verify_cols_missing(df, "d") # Silent. There will be no problem adding column "d".
newcols &lt;- c("c", "d", "a", "b")
## Not run: verify_cols_missing(df, newcols) # Error: a and b are already in df.
</code></pre>

<hr>
<h2 id='where_to_get_args'>Decide where to get each argument to FUN</h2><span id='topic+where_to_get_args'></span>

<h3>Description</h3>

<p>The precedence rules for where to obtain values for the <code>FUN</code> argument to
<code>matsindf_apply()</code> are codified here.
The rules are:
</p>

<ul>
<li><p> Precedence order: <code>...</code>, <code>.dat</code>, defaults arguments to <code>FUN</code>
(highest priority to lowest priority).
</p>
</li>
<li><p> If an element of <code>...</code> is a character string of length <code>1</code>,
the element of <code>...</code> provides a mapping between
an item in <code>.dat</code> (with same name as the value of the character string of length <code>1</code>)
to an argument of <code>FUN</code> (with the same name as the name of the character string of length <code>1</code>).
</p>
</li>
<li><p> If the value of the character string of length <code>1</code> is not a name in <code>.dat</code>,
the default arguments to <code>FUN</code> are checked in this order.
</p>

<ul>
<li><p> If the name of a default argument to <code>FUN</code> is the same as the value of the
string of length <code>1</code> argument in <code>...</code>, a mapping occurs.
</p>
</li>
<li><p> If a mapping is not possible,
the default arg to <code>FUN</code> is used directly.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>where_to_get_args(.dat = NULL, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_to_get_args_+3A_.dat">.dat</code></td>
<td>
<p>The <code>.dat</code> argument to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="where_to_get_args_+3A_fun">FUN</code></td>
<td>
<p>The <code>FUN</code> argument to <code>matsindf_apply()</code>.</p>
</td></tr>
<tr><td><code id="where_to_get_args_+3A_...">...</code></td>
<td>
<p>The <code>...</code> argument to <code>matsindf_apply()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list wherein the names are the argument names to <code>FUN</code>.
Values are character vectors with 2 elements.
The first element is named <code>source</code> and provides
the argument to <code>matsindf_apply()</code> from which the named argument should be found,
one of &quot;.dat&quot;, &quot;FUN&quot;, or &quot;...&quot;.
The second element is named <code>arg_name</code> and provides
the variable name or argument name in the source that contains the input data
for the argument to <code>FUN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example_fun &lt;- function(a = 1, b) {
  list(c = a + b, d = a - b)
}
# b is not available anywhere, likely causing an error later
matsindf:::where_to_get_args(FUN = example_fun)
# b is now available in ...
matsindf:::where_to_get_args(FUN = example_fun, b = 2)
# b is now available in .dat
matsindf:::where_to_get_args(list(b = 2), FUN = example_fun)
# b now comes from ..., because ... takes precedence over .dat
matsindf:::where_to_get_args(list(b = 2), FUN = example_fun, b = 3)
# Mapping from c in .dat to b in FUN
matsindf:::where_to_get_args(list(c = 2),
                             FUN = example_fun, b = "c")
# Redirect from an arg in ... to a different default to FUN
matsindf:::where_to_get_args(FUN = example_fun, b = "a")
# b is found in FUN, not in .dat, because the mapping (b = "a")
# is not available in .dat
matsindf:::where_to_get_args(list(b = 2), FUN = example_fun, b = "a")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
