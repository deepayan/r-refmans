<!DOCTYPE html><html lang="en"><head><title>Help for package listarrays</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {listarrays}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array2'><p>Make or reshape an array with C-style (row-major) semantics</p></a></li>
<li><a href='#bind_as_dim'><p>Bind arrays along a specified dimension</p></a></li>
<li><a href='#DIM'><p>Helpers for working with 1-d arrays</p></a></li>
<li><a href='#drop_dimnames'><p>Drop dimnames</p></a></li>
<li><a href='#expand_dims'><p>Expand the shape of an array</p></a></li>
<li><a href='#extract_dim'><p>Extract with <code>[</code> on a specified dimension</p></a></li>
<li><a href='#map_along_dim'><p>Apply a function across subsets along an array dimension</p></a></li>
<li><a href='#modify_along_dim'><p>Modify an array by mapping over 1 or more dimensions</p></a></li>
<li><a href='#ndim'><p>Length of <code>DIM()</code></p></a></li>
<li><a href='#onehot_with_decoder'><p>Convert vector to a onehot representation (binary class matrix)</p></a></li>
<li><a href='#seq_along_dim'><p>Sequence along a dimension</p></a></li>
<li><a href='#set_as_rows'><p>Reshape an array to send a dimension forward or back</p></a></li>
<li><a href='#set_dim'><p>Reshape an array</p></a></li>
<li><a href='#set_dimnames'><p>Set dimnames</p></a></li>
<li><a href='#shuffle_rows'><p>Shuffle along the first dimension multiple arrays in sync</p></a></li>
<li><a href='#split_on_dim'><p>Split an array along a dimension</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Toolbox for Working with R Arrays in a Functional Programming
Style</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for R arrays. Flexibly split, bind, reshape, modify, 
    subset and name arrays.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/t-kalinowski/listarrays">https://github.com/t-kalinowski/listarrays</a>,
<a href="https://t-kalinowski.github.io/listarrays/">https://t-kalinowski.github.io/listarrays/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/t-kalinowski/listarrays/issues">https://github.com/t-kalinowski/listarrays/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, magrittr, zeallot, rlang, tibble, purrr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-19 13:40:38 UTC; tomasz</td>
</tr>
<tr>
<td>Author:</td>
<td>Tomasz Kalinowski [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tomasz Kalinowski &lt;kalinowskit@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-19 14:02:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='array2'>Make or reshape an array with C-style (row-major) semantics</h2><span id='topic+array2'></span><span id='topic+matrix2'></span><span id='topic+dim2+3C-'></span><span id='topic+set_dim2'></span>

<h3>Description</h3>

<p>These functions reshape or make an array using C-style, row-major semantics.
The returned array is still R's native F-style, (meaning, the underlying
vector has been reordered).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array2(data, dim = length(data), dimnames = NULL)

matrix2(...)

dim2(x) &lt;- value

set_dim2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array2_+3A_data">data</code></td>
<td>
<p>what to fill the array with</p>
</td></tr>
<tr><td><code id="array2_+3A_dim">dim</code></td>
<td>
<p>numeric vector of dimensions</p>
</td></tr>
<tr><td><code id="array2_+3A_dimnames">dimnames</code></td>
<td>
<p>a list of dimnames, must be the same length as <code>dims</code></p>
</td></tr>
<tr><td><code id="array2_+3A_...">...</code></td>
<td>
<p>passed on to <code>set_dim()</code></p>
</td></tr>
<tr><td><code id="array2_+3A_x">x</code></td>
<td>
<p>object to set dimensions on (array or atomic vector)</p>
</td></tr>
<tr><td><code id="array2_+3A_value">value</code></td>
<td>
<p>a numeric (integerish) vector of new dimensions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other than the C-style semantics, these functions behave identically to their
counterparts (<code>array2()</code> behaves identically to <code>array()</code>, <code>`dim2&lt;-`()</code>
to <code>`dim&lt;-`()</code>). <code>set_dim2()</code> is just a wrapper around <code>set_dim(..., order = "C")</code>.
</p>
<p>See examples for a drop-in pure R replacement to <code>reticulate::array_reshape()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>array(1:4, c(2,2))
array2(1:4, c(2,2))

# for a drop-in replacement to reticulate::array_reshape
array_reshape &lt;- listarrays:::array_reshape
array_reshape(1:4, c(2,2))
</code></pre>

<hr>
<h2 id='bind_as_dim'>Bind arrays along a specified dimension</h2><span id='topic+bind_as_dim'></span><span id='topic+bind_as_rows'></span><span id='topic+bind_as_cols'></span><span id='topic+bind_on_dim'></span><span id='topic+bind_on_rows'></span><span id='topic+bind_on_cols'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;bind_as_*&#8288;</code> introduces a new dimension, such that each element in
<code>list_of_arrays</code> corresponds to one index position along the new dimension in
the returned array. <code style="white-space: pre;">&#8288;bind_on_*&#8288;</code> binds all elements along an existing
dimension, (meaning, the returned array has the same number of dimensions as
each of the arrays in the list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_as_dim(list_of_arrays, which_dim)

bind_as_rows(...)

bind_as_cols(...)

bind_on_dim(list_of_arrays, which_dim)

bind_on_rows(...)

bind_on_cols(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_as_dim_+3A_list_of_arrays">list_of_arrays</code></td>
<td>
<p>a list of arrays. All arrays must be of the same
dimension. NULL's in place of arrays are automatically dropped.</p>
</td></tr>
<tr><td><code id="bind_as_dim_+3A_which_dim">which_dim</code></td>
<td>
<p>Scalar integer specifying the index position of where to
introduce the new dimension to introduce. Negative numbers count from the
back. For example, given a 3 dimensional array, <code>-1</code>, is equivalent to <code>3</code>,
<code>-2</code> to <code>2</code> and <code>-3</code> to <code>1</code>.</p>
</td></tr>
<tr><td><code id="bind_as_dim_+3A_...">...</code></td>
<td>
<p>Arrays to be bound, specified individually or supplied as a single
list</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;bind_*_rows()&#8288;</code> is a wrapper for the common case of <code style="white-space: pre;">&#8288;bind_*_dim(X, 1)&#8288;</code>.
<code style="white-space: pre;">&#8288;bind_*_cols()&#8288;</code> is a wrapper for the common case of <code style="white-space: pre;">&#8288;bind_*_dim(X, -1)&#8288;</code>.
</p>


<h3>Value</h3>

<p>An array, with one additional dimension.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_of_arrays &lt;- replicate(10, array(1:8, dim = c(2,3,4)), FALSE)

dim(list_of_arrays[[1]])

# bind on a new dimension
combined_as &lt;- bind_as_rows(list_of_arrays)
dim(combined_as)
dim(combined_as)[1] == length(list_of_arrays)

# each element in `list_of_arrays` corresponds to one "row"
# (i.e., one entry in along the first dimension)
for(i in seq_along(list_of_arrays))
  stopifnot(identical(combined_as[i,,,], list_of_arrays[[i]]))

# bind on an existing dimension
combined_on &lt;- bind_on_rows(list_of_arrays)
dim(combined_on)
dim(combined_on)[1] == sum(sapply(list_of_arrays, function(x) dim(x)[1]))
identical(list_of_arrays[[1]], combined_on[1:2,,])
for (i in seq_along(list_of_arrays))
  stopifnot(identical(
    list_of_arrays[[i]], combined_on[ (1:2) + (i-1)*2,,]
  ))

# bind on any dimension
combined &lt;- bind_as_dim(list_of_arrays, 3)
dim(combined)
for(i in seq_along(list_of_arrays))
   stopifnot(identical(combined[,,i,], list_of_arrays[[i]]))
</code></pre>

<hr>
<h2 id='DIM'>Helpers for working with 1-d arrays</h2><span id='topic+DIM'></span><span id='topic+DROP'></span>

<h3>Description</h3>

<p><code>DIM()</code> is to <code>dim()</code> as <code>NROW()</code> is to <code>nrow()</code>. That is, it is identical to
<code>dim()</code> in most cases except if the input is a bare atomic vector with no
<code>dim</code> attribute, in which case, the length of the vector is returned instead
of <code>NULL</code>.
</p>
<p><code>DROP</code> first calls <code>base::drop</code>  and then completely removes the <code>dim</code>
attribute if the result is a 1-d array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIM(x)

DROP(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DIM_+3A_x">x</code></td>
<td>
<p>an R vector, potentially with a dim attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>DIM</code>, the <code>dim</code> attribute, or if that's not found, then <code>length(x)</code>
</p>
<p>For <code>DROP</code> an array with 2 or more axes, or a vector with no <code>dim</code>
attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
dim(x)
dim(array(x))

DIM(x)
DIM(array(x))

x &lt;- array(1:3)
str(drop(x))
str(DROP(x))
</code></pre>

<hr>
<h2 id='drop_dimnames'>Drop dimnames</h2><span id='topic+drop_dimnames'></span><span id='topic+drop_dim'></span><span id='topic+drop_dim2'></span>

<h3>Description</h3>

<p>A pipe-friendly wrapper for <code>dim(x) &lt;- NULL</code> and <code>dimnames(x) &lt;- NULL</code> or, if
<code>which_dim</code> is not <code>NULL</code>, <code>dimnames(x)[which_dim] &lt;- list(NULL)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_dimnames(x, which_dim = NULL, keep_axis_names = FALSE)

drop_dim(x)

drop_dim2(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_dimnames_+3A_x">x</code></td>
<td>
<p>an object, potentially with dimnames</p>
</td></tr>
<tr><td><code id="drop_dimnames_+3A_which_dim">which_dim</code></td>
<td>
<p>If <code>NULL</code> (the default) then all dimnames are dropped. If
integer vector, then dimnames only at the specified dimensions are dropped.</p>
</td></tr>
<tr><td><code id="drop_dimnames_+3A_keep_axis_names">keep_axis_names</code></td>
<td>
<p>TRUE or FALSE, whether to preserve the axis names when
dropping the dimnames</p>
</td></tr>
</table>

<hr>
<h2 id='expand_dims'>Expand the shape of an array</h2><span id='topic+expand_dims'></span>

<h3>Description</h3>

<p>This is the inverse operation of <code>base::drop()</code>.
It is analogous to python's <code>numpy.expand_dims()</code>, but vectorized on
<code>which_dim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_dims(x, which_dim = -1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_dims_+3A_x">x</code></td>
<td>
<p>an array. Bare vectors are treated as 1-d arrays.</p>
</td></tr>
<tr><td><code id="expand_dims_+3A_which_dim">which_dim</code></td>
<td>
<p>numeric. Desired index position of the new axis or axes in
the returned array. Negative numbers count from the back. Can be any
length.Throws a warning if any duplicates are provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the array <code>x</code> with new dim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:24, 2:4)
dim(x)
dim(expand_dims(x))
dim(expand_dims(x, 2))
dim(expand_dims(x, c(1,2)))
dim(expand_dims(x, c(1,-1)))
dim(expand_dims(x, 6)) # implicitly also expands dims 4,5
dim(expand_dims(x, 4:6))

# error, implicit expansion with negative indexes not supported
try(expand_dims(x, -6))

# supply them explicitly instead
dim(expand_dims(x, -(4:6)))
</code></pre>

<hr>
<h2 id='extract_dim'>Extract with <code>[</code> on a specified dimension</h2><span id='topic+extract_dim'></span><span id='topic+extract_rows'></span><span id='topic+extract_cols'></span>

<h3>Description</h3>

<p>Extract with <code>[</code> on a specified dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dim(X, which_dim, idx, drop = NULL, depth = Inf)

extract_rows(X, idx, drop = NULL, depth = Inf)

extract_cols(X, idx, drop = NULL, depth = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_dim_+3A_x">X</code></td>
<td>
<p>Typically, an array, but any object with a <code>[</code> method is accepted
(e.g., dataframe, vectors)</p>
</td></tr>
<tr><td><code id="extract_dim_+3A_which_dim">which_dim</code></td>
<td>
<p>A scalar integer or character, specifying the dimension to
extract from</p>
</td></tr>
<tr><td><code id="extract_dim_+3A_idx">idx</code></td>
<td>
<p>A numeric, boolean, or character vector to perform subsetting
with.</p>
</td></tr>
<tr><td><code id="extract_dim_+3A_drop">drop</code></td>
<td>
<p>Passed on to <code>[</code>. If <code>NULL</code> (the default), then drop is omitted
from the argument, and the default is used (defaults to TRUE for most
objects, including arrays)</p>
</td></tr>
<tr><td><code id="extract_dim_+3A_depth">depth</code></td>
<td>
<p>Scalar number, how many levels to recurse down if <code>X</code> is a list
of arrays. Set this if you want to explicitly treat a list as a vector
(that is, a one-dimensional array). (You can alternatively set a dim
attribute with <code style="white-space: pre;">&#8288;dim&lt;-&#8288;</code> on the list to prevent recursion)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># extract_rows is useful to keep the same code path for arrays of various sizes
X &lt;- array(1:8, c(4, 3, 2))
y &lt;- c("a", "b", "c", "d")
(Y &lt;- onehot(y))

extract_rows(X, 2)
extract_rows(Y, 2)
extract_rows(y, 2)

library(zeallot)
c(X2, Y2, y2) %&lt;-% extract_rows(list(X, Y, y), 2)
X2
Y2
y2
</code></pre>

<hr>
<h2 id='map_along_dim'>Apply a function across subsets along an array dimension</h2><span id='topic+map_along_dim'></span><span id='topic+map_along_rows'></span><span id='topic+map_along_cols'></span>

<h3>Description</h3>

<p><code>map_along_dim(X, dim, func)</code> is a simple wrapper around <code>split_along_dim(X, dim) %&gt;% map(func)</code>. It is conceptually and functionally equivalent to
<code>base::apply()</code>, with the following key differences:
</p>

<ul>
<li><p> it is guaranteed to return a list (<code>base::apply()</code> attempts to simplify the
output to an array, sometimes unsuccessfully, making the output unstable)
</p>
</li>
<li><p> it accepts the compact lambda notation <code>~.x</code> just like in <code><a href="purrr.html#topic+map">purrr::map</a></code>
(and <code><a href="#topic+modify_along_dim">modify_along_dim()</a></code>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>map_along_dim(X, .dim, .f, ...)

map_along_rows(X, .f, ...)

map_along_cols(X, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_along_dim_+3A_x">X</code></td>
<td>
<p>an R array</p>
</td></tr>
<tr><td><code id="map_along_dim_+3A_.dim">.dim</code></td>
<td>
<p>which dimension to map along. Passed on to <code><a href="#topic+split_along_dim">split_along_dim()</a></code>,
and accepts all the same inputs. Valid inputs include
</p>

<ul>
<li><p> positive integers (index position(s) of dimension),
</p>
</li>
<li><p> negative integers (index positions(s) of dimensions, counting from the back), or
</p>
</li>
<li><p> character vector (corresponding to array dimnames)
</p>
</li></ul>
</td></tr>
<tr><td><code id="map_along_dim_+3A_.f">.f</code></td>
<td>
<p>A function, string of a function name, or <code>purrr</code> style compact lambda syntax (e.g, <code>~.x + 1</code>)</p>
</td></tr>
<tr><td><code id="map_along_dim_+3A_...">...</code></td>
<td>
<p>passed on to <code>.f()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix2(letters[1:15], ncol = 3)

apply(X, 1, function(x) paste(x, collapse = ""))   # simplifies to a vector
map_along_dim(X, 1, ~paste(.x, collapse = ""))     # returns a list

identical(
  map_along_rows(X, identity),
  map_along_dim(X, 1, identity)) # TRUE

identical(
  map_along_cols(X, identity),
  map_along_dim(X, -1, identity)) # TRUE
</code></pre>

<hr>
<h2 id='modify_along_dim'>Modify an array by mapping over 1 or more dimensions</h2><span id='topic+modify_along_dim'></span><span id='topic+modify_along_rows'></span><span id='topic+modify_along_cols'></span>

<h3>Description</h3>

<p>This function can be thought of as a version of <code>base::apply()</code> that is
guaranteed to return a object of the same dimensions as it was input. It also
generally preserves attributes, as it's built on top of <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_along_dim(X, which_dim, .f, ...)

modify_along_rows(X, .f, ...)

modify_along_cols(X, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_along_dim_+3A_x">X</code></td>
<td>
<p>An array, or a list of arrays</p>
</td></tr>
<tr><td><code id="modify_along_dim_+3A_which_dim">which_dim</code></td>
<td>
<p>integer vector of dimensions to modify at</p>
</td></tr>
<tr><td><code id="modify_along_dim_+3A_.f">.f</code></td>
<td>
<p>a function or formula defining a function(same semantics as
<code><a href="purrr.html#topic+map">purrr::map()</a></code>). The function must return either an array the same shape
as it was passed, a vector of the same length, or a scalar, although the
type of the returned object does not need to be the same as was passed in.</p>
</td></tr>
<tr><td><code id="modify_along_dim_+3A_...">...</code></td>
<td>
<p>passed on to <code>.f()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array, or if <code>X</code> was a list, a list of arrays of the same shape as
was passed in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:6, 1:3)
modify_along_dim(x, 3, ~mean(.x))
modify_along_dim(x, 3, ~.x/mean(.x))
</code></pre>

<hr>
<h2 id='ndim'>Length of <code>DIM()</code></h2><span id='topic+ndim'></span>

<h3>Description</h3>

<p>Returns the number of dimensions, or 1 for an atomic vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndim(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ndim_+3A_x">x</code></td>
<td>
<p>a matrix or atomic vector</p>
</td></tr>
</table>

<hr>
<h2 id='onehot_with_decoder'>Convert vector to a onehot representation (binary class matrix)</h2><span id='topic+onehot_with_decoder'></span><span id='topic+onehot'></span><span id='topic+decode_onehot'></span><span id='topic+onehot_decoder'></span>

<h3>Description</h3>

<p>Convert vector to a onehot representation (binary class matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onehot_with_decoder(y, order = NULL, named = TRUE)

onehot(y, order = NULL, named = TRUE)

decode_onehot(
  Y,
  classes = colnames(Y),
  n_classes = ncol(Y) %||% length(classes)
)

onehot_decoder(Y, classes = colnames(Y), n_classes = length(classes))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="onehot_with_decoder_+3A_y">y</code></td>
<td>
<p>character, factor, or numeric vector</p>
</td></tr>
<tr><td><code id="onehot_with_decoder_+3A_order">order</code></td>
<td>
<p><code>NULL</code>, <code>FALSE</code>, or a character vector. If <code>NULL</code> (the default),
then levels are sorted with <code>sort()</code>. If <code>FALSE</code>, then levels are taken in
order of their first appearance in <code>y</code>. If a character vector, then <code>order</code>
must contain all levels found in <code>y</code>.</p>
</td></tr>
<tr><td><code id="onehot_with_decoder_+3A_named">named</code></td>
<td>
<p>if the returned matrix should have column names</p>
</td></tr>
<tr><td><code id="onehot_with_decoder_+3A_y">Y</code></td>
<td>
<p>a matrix, as returned by <code>onehot()</code> or similar.</p>
</td></tr>
<tr><td><code id="onehot_with_decoder_+3A_classes">classes</code></td>
<td>
<p>A character vector of class names in the order corresponding
to <code>Y</code>'s onehot encoding. Typically, <code>colnames(Y)</code>. if <code>NULL</code>, then the
decoder returns the column number.</p>
</td></tr>
<tr><td><code id="onehot_with_decoder_+3A_n_classes">n_classes</code></td>
<td>
<p>The total number of classes expected in <code>Y</code>. Used for input
checking in the returned decoder, also, to reconstruct the correct
dimensions if the passed in <code>Y</code> is missing <code>dim()</code> attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary class matrix
</p>


<h3>See Also</h3>

<p><a href="keras.html#topic+to_categorical">keras::to_categorical</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(zeallot)) {
  y &lt;- letters[1:4]
  c(Y, decode) %&lt;-% onehot_with_decoder(y)
  Y
  decode(Y)
  identical(y, decode(Y))
  decode(Y[2,,drop = TRUE])
  decode(Y[2,,drop = FALSE])
  decode(Y[2:3,])

  rm(Y, decode)
}

# more peicemeal functions
Y &lt;- onehot(y)
decode_onehot(Y)

# if you need to decode a matrix that lost colnames,
# make your own decoder that remembers classes
my_decode &lt;- onehot_decoder(Y)
colnames(Y) &lt;- NULL
my_decode(Y)
decode_onehot(Y)

# factor and numeric vectors also accepted
onehot(factor(letters[1:4]))
onehot(4:8)

</code></pre>

<hr>
<h2 id='seq_along_dim'>Sequence along a dimension</h2><span id='topic+seq_along_dim'></span><span id='topic+seq_along_rows'></span><span id='topic+seq_along_cols'></span>

<h3>Description</h3>

<p>Sequence along a dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_along_dim(x, which_dim)

seq_along_rows(x)

seq_along_cols(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_along_dim_+3A_x">x</code></td>
<td>
<p>a dataframe, array or vector. For <code>seq_along_rows</code>, and
<code>seq_along_cols</code> sequence along the first and last dimensions,
respectively. Atomic vectors are treated as 1 dimensional
arrays (i.e., <code>seq_along_rows</code> is equivalent to <code>seq_along</code> when <code>x</code> is an
atomic vector or list).</p>
</td></tr>
<tr><td><code id="seq_along_dim_+3A_which_dim">which_dim</code></td>
<td>
<p>a scalar integer or character string, specifying which
dimension to generate a sequence for. Negative numbers count from the back.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of integers 1:nrow(x), safe for use in <code>for</code> loops and
vectorized equivalents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>for (r in seq_along_rows(mtcars[1:4,]))
  print(mtcars[r,])

x &lt;- 1:3
identical(seq_along_rows(x), seq_along(x))

</code></pre>

<hr>
<h2 id='set_as_rows'>Reshape an array to send a dimension forward or back</h2><span id='topic+set_as_rows'></span><span id='topic+set_as_cols'></span>

<h3>Description</h3>

<p>Reshape an array to send a dimension forward or back
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_as_rows(X, which_dim)

set_as_cols(X, which_dim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_as_rows_+3A_x">X</code></td>
<td>
<p>an array</p>
</td></tr>
<tr><td><code id="set_as_rows_+3A_which_dim">which_dim</code></td>
<td>
<p>scalar integer or string, which dim to bring forward.
Negative numbers count from the back
</p>
<p>This is a powered by <code>base::aperm()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a reshaped array
</p>


<h3>See Also</h3>

<p><code>base::aperm()</code> <code>set_dim()</code> <code>keras::array_reshape()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:24, 2:4)
y &lt;- set_as_rows(x, 3)

for (i in seq_along_dim(x, 3))
  stopifnot( identical(x[,,i], y[i,,]) )
</code></pre>

<hr>
<h2 id='set_dim'>Reshape an array</h2><span id='topic+set_dim'></span>

<h3>Description</h3>

<p>Pipe friendly <code style="white-space: pre;">&#8288;dim&lt;-()&#8288;</code>, with option to pad to necessary length. Also allows
for filling the array using C style row-major semantics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dim(
  x,
  new_dim,
  pad = getOption("listarrays.autopad_arrays_with", NULL),
  order = c("F", "C"),
  verbose = getOption("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_dim_+3A_x">x</code></td>
<td>
<p>A vector or array to set dimensions on</p>
</td></tr>
<tr><td><code id="set_dim_+3A_new_dim">new_dim</code></td>
<td>
<p>The desired dimensions (an integer(ish) vector)</p>
</td></tr>
<tr><td><code id="set_dim_+3A_pad">pad</code></td>
<td>
<p>The value to pad the vector with. <code>NULL</code> (the default) performs no
padding.</p>
</td></tr>
<tr><td><code id="set_dim_+3A_order">order</code></td>
<td>
<p>whether to use row-major (C) or column major (F) style
semantics. The default, &quot;F&quot;, corresponds to the default behavior of R's
<code style="white-space: pre;">&#8288;dim&lt;-()&#8288;</code>, while &quot;C&quot; corresponds to the default behavior of
<code>reticulate::array_reshape()</code>, numpy, reshaping semantics commonly
encountered in the python world.</p>
</td></tr>
<tr><td><code id="set_dim_+3A_verbose">verbose</code></td>
<td>
<p>Whether to emit a message if padding. By default, <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with dimensions set
</p>


<h3>See Also</h3>

<p><code>set_dim2()</code>, <code>`dim&lt;-`()</code>, <code>reticulate::array_reshape()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_dim(1:10, c(2, 5))
try( set_dim(1:7, c(2, 5)) ) # error by default, just like `dim&lt;-`()
     set_dim(1:7, c(2, 5), pad = 99)
     set_dim(1:7, c(2, 5), pad = 99, order = "C") # fills row-wise

y &lt;- x &lt;- 1:4
# base::dim&lt;- fills the array column wise
dim(x) &lt;- c(2, 2)
x

# dim2 will fill the array row-wise
dim2(y) &lt;- c(2, 2)
y

identical(x, set_dim(1:4, c(2,2)))
identical(y, set_dim(1:4, c(2,2), order = "C"))

## Not run: 
py_reshaped &lt;- reticulate::array_reshape(1:4, c(2,2))
storage.mode(py_reshaped) &lt;- "integer" # reticulate coerces to double
identical(y, py_reshaped)
# if needed, see listarrays:::array_reshape() for
# a drop-in pure R replacement for reticulate::array_reshape()

## End(Not run)
</code></pre>

<hr>
<h2 id='set_dimnames'>Set dimnames</h2><span id='topic+set_dimnames'></span>

<h3>Description</h3>

<p>A more flexible and pipe-friendly version of <code style="white-space: pre;">&#8288;dimnames&lt;-&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dimnames(x, nm, which_dim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_dimnames_+3A_x">x</code></td>
<td>
<p>an array</p>
</td></tr>
<tr><td><code id="set_dimnames_+3A_nm">nm</code></td>
<td>
<p>A list or character vector.</p>
</td></tr>
<tr><td><code id="set_dimnames_+3A_which_dim">which_dim</code></td>
<td>
<p>a character vector or numeric vector or <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is quite flexible. See examples for the complete
picture.
</p>


<h3>Value</h3>

<p>x, with modified dimnames and or axisnames
</p>


<h3>Note</h3>

<p>The word &quot;dimnames&quot; is slightly overloaded. Most commonly it refers to
the names of entries along a particular axis (e.g., date1, date2, date3,
...), but occasionally it is also used to refer to the names of the array
axes themselves (e.g, dates, temperature, pressure, ...). To disambiguate,
in the examples 'dimnames' always refers to the first case, while 'axis
names' refers to the second. <code>set_dimnames()</code> can be used to set either or both
axis names and dimnames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:8, 2:4)

# to set axis names, leave which_dim=NULL and pass a character vector
dimnames(set_dimnames(x, c("a", "b", "c")))

# to set names along a single axis, specify which_dim
dimnames(set_dimnames(x, c("a", "b", "c"), 2))

# to set an axis name and names along the axis, pass a named list
dimnames(set_dimnames(x, list(axis2 = c("a", "b", "c")), 2))
dimnames(set_dimnames(x, list(axis2 = c("a", "b", "c"),
                              axis3 = 1:4), which_dim = 2:3))

# if the array already has axis names, those are used when possible
nx &lt;- set_dimnames(x, paste0("axis", 1:3))
dimnames(nx)
dimnames(set_dimnames(nx, list(axis2 = c("x", "y", "z"))))
dimnames(set_dimnames(nx, c("x", "y", "z"), which_dim = "axis2"))


# pass NULL to drop all dimnames, or just names along a single dimension
nx2 &lt;- set_dimnames(nx, c("x", "y", "z"), which_dim = "axis2")
nx2 &lt;- set_dimnames(nx2, LETTERS[1:4], which_dim = "axis3")
dimnames(nx2)
dimnames(set_dimnames(nx2, NULL))
dimnames(set_dimnames(nx2, NULL, 2))
dimnames(set_dimnames(nx2, NULL, c(2, 3)))
# to preserve an axis name and only drop the dimnames, wrap the NULL in a list()
dimnames(set_dimnames(nx2, list(NULL)))
dimnames(set_dimnames(nx2, list(NULL), 2))
dimnames(set_dimnames(nx2, list(axis2 = NULL)))
dimnames(set_dimnames(nx2, list(axis2 = NULL, axis3 = NULL)))
dimnames(set_dimnames(nx2, list(NULL), 2:3))
</code></pre>

<hr>
<h2 id='shuffle_rows'>Shuffle along the first dimension multiple arrays in sync</h2><span id='topic+shuffle_rows'></span>

<h3>Description</h3>

<p>Shuffle along the first dimension multiple arrays in sync
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_rows(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffle_rows_+3A_...">...</code></td>
<td>
<p>arrays of various dimensions (vectors and data.frames OK too)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects passed on to <code>...</code>, or if a single object was
supplied, then the single object shuffled
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- matrix(1:9, ncol = 3)
z &lt;- array(1:27, c(3,3,3))

if(require(zeallot)) {
  c(xs, ys, zs) %&lt;-% shuffle_rows(x, y, z)

  l &lt;- lapply(seq_along_rows(y), function(r) {
    list(x = x[r], y = y[r,], z = z[r,,])
  })

  ls &lt;- lapply(seq_along_rows(y), function(r) {
    list(x = xs[r], y = ys[r,], z = zs[r,,])
  })

  stopifnot(
    length(unique(c(l, ls))) == length(l))
}
</code></pre>

<hr>
<h2 id='split_on_dim'>Split an array along a dimension</h2><span id='topic+split_on_dim'></span><span id='topic+split_on_rows'></span><span id='topic+split_on_cols'></span><span id='topic+split_along_dim'></span><span id='topic+split_along_rows'></span><span id='topic+split_along_cols'></span>

<h3>Description</h3>

<p>Split an array along a dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_on_dim(
  X,
  which_dim,
  f = dimnames(X)[[which_dim]],
  drop = FALSE,
  depth = Inf
)

split_on_rows(X, f = rownames(X), drop = FALSE, depth = Inf)

split_on_cols(X, f = rownames(X), drop = FALSE, depth = Inf)

split_along_dim(X, which_dim, depth = Inf)

split_along_rows(X, depth = Inf)

split_along_cols(X, depth = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_on_dim_+3A_x">X</code></td>
<td>
<p>an array, or list of arrays. An atomic vector without a dimension
attribute is treated as a 1 dimensional array (Meaning, atomic vectors
without a dim attribute are only accepted if <code>which_dim</code> is <code>1</code>. Names of
the passed list are preserved. If a list of arrays, all the arrays must
have the same length of the dimension being split.</p>
</td></tr>
<tr><td><code id="split_on_dim_+3A_which_dim">which_dim</code></td>
<td>
<p>a scalar string or integer, specifying which dimension to
split along. Negative integers count from the back. If a string, it must
refer to a named dimension (e.g, one of <code>names(dimnames(X))</code>.</p>
</td></tr>
<tr><td><code id="split_on_dim_+3A_f">f</code></td>
<td>
<p>Specify how to split the dimension. </p>

<dl>
<dt>character, integer, factor</dt><dd><p>passed on to <code>base::split()</code>. Must be the
same length as the dimension being split.</p>
</dd>
<dt>a list of vectors</dt><dd><p>Passed on to <code>base::interaction()</code> then
<code>base::split()</code>. Each vector in the list must be the same length as the
dimension being split.</p>
</dd>
<dt>a scalar integer</dt><dd><p>used to split into that many groups of equal size</p>
</dd>
<dt>a numeric vector where <code>all(f&lt;0)</code></dt><dd><p>specifies the relative size
proportions of the groups being split. <code>sum(f)</code> must be <code>1</code>. For
example <code>c(0.2, 0.2, 0.6)</code> will return approximately a 20\
split.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="split_on_dim_+3A_drop">drop</code></td>
<td>
<p>passed on to <code>[</code>.</p>
</td></tr>
<tr><td><code id="split_on_dim_+3A_depth">depth</code></td>
<td>
<p>Scalar number, how many levels to recurse down. Set this if you
want to explicitly treat a list as a vector (that is, a one-dimensional
array). (You can alternatively set dim attributes with <code style="white-space: pre;">&#8288;dim&lt;-&#8288;</code> on the list
to prevent recursion)
</p>
<p><code>split_along_dim(X, which_dim)</code> is equivalent to <code>split_on_dim(X, which_dim, seq_along_dim(X, which_dim))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of arrays, or if a list of arrays was passed in, then a list
of lists of arrays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- array(1:8, c(2,3,4))
X
split_along_dim(X, 2)

# specify f as a factor, akin to base::split()
split_on_dim(X, 2, c("a", "a", "b"), drop = FALSE)

d &lt;- c(10, 3, 3)
X &lt;- array(1:prod(d), d)
y &lt;- letters[1:10]
Y &lt;- onehot(y)

# specify `f`` as relative partition sizes
if(require(zeallot) &amp;&amp; require(magrittr) &amp;&amp; require(purrr)) {

c(train, validate, test) %&lt;-% {
  list(X = X, Y = Y, y = y) %&gt;%
    shuffle_rows() %&gt;%
    split_on_rows(c(0.6, 0.2, 0.2)) %&gt;%
    transpose()
}

str(test)
str(train)
str(validate)

}


# with with array data in a data frame by splitting row-wise
if(require(tibble))
  tibble(y, X = split_along_rows(X))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
