<!DOCTYPE html><html><head><title>Help for package origami</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {origami}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_id_and_time'><p>Check ID and Time Compatibility</p></a></li>
<li><a href='#combine_results'><p>Combine Results from Different Folds</p></a></li>
<li><a href='#combiners'><p>Combiners</p></a></li>
<li><a href='#cross_validate'><p>Main Cross-Validation Function</p></a></li>
<li><a href='#fold_from_foldvec'><p>Build a Fold Object from a Fold Vector</p></a></li>
<li><a href='#fold_funs'><p>Cross-Validation Schemes</p></a></li>
<li><a href='#fold_helpers'><p>Fold Helpers</p></a></li>
<li><a href='#folds2foldvec'><p>Build a Fold Vector from a Fold Object</p></a></li>
<li><a href='#guess_combiner'><p>Flexible Guessing and Mapping for Combining Data Types</p></a></li>
<li><a href='#id_folds_to_folds'><p>Convert ID Folds to Observation Folds</p></a></li>
<li><a href='#make_fold'><p>Fold</p></a></li>
<li><a href='#make_folds'><p>Make List of Folds for cross-validation</p></a></li>
<li><a href='#make_repeated_folds'><p>Repeated Cross-Validation</p></a></li>
<li><a href='#wrap_in_try'><p>Wrap a Function in a Try Statement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Framework for Cross-Validation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Coyle &lt;jeremyrcoyle@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A general framework for the application of cross-validation schemes
    to particular functions. By allowing arbitrary lists of results, origami
    accommodates a range of cross-validation applications. This implementation
    was first described by Coyle and Hejazi (2018) &lt;<a href="https://doi.org/10.21105%2Fjoss.00512">doi:10.21105/joss.00512</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0),</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tlverse.org/origami/">https://tlverse.org/origami/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tlverse/origami/issues">https://github.com/tlverse/origami/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, methods, data.table, assertthat, future, future.apply,
listenv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, class, rmarkdown, knitr, stringr, glmnet, forecast,
randomForest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-19 22:38:23 UTC; jrcoyle</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Coyle <a href="https://orcid.org/0000-0002-9874-6649"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Nima Hejazi <a href="https://orcid.org/0000-0002-7127-2789"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ivana Malenica <a href="https://orcid.org/0000-0002-7404-8088"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rachael Phillips <a href="https://orcid.org/0000-0002-8474-591X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-19 23:22:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_id_and_time'>Check ID and Time Compatibility</h2><span id='topic+check_id_and_time'></span>

<h3>Description</h3>

<p>Check ID and Time Compatibility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_id_and_time(id, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_id_and_time_+3A_id">id</code></td>
<td>
<p>An optional vector of unique identifiers corresponding to the time
vector. These can be used to subset the time vector.</p>
</td></tr>
<tr><td><code id="check_id_and_time_+3A_time">time</code></td>
<td>
<p>An optional vector of integers of time points observed for each
subject in the sample.</p>
</td></tr>
</table>

<hr>
<h2 id='combine_results'>Combine Results from Different Folds</h2><span id='topic+combine_results'></span>

<h3>Description</h3>

<p>Applies <code><a href="#topic+combiners">combiners</a></code>: functions that collapse across a list of
similarly structured results, to a list of such lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_results(results, combiners = NULL, smart_combiners = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_results_+3A_results">results</code></td>
<td>
<p>A <code>list</code> of <code>list</code>s, corresponding to each result,
with the inner <code>list</code>s corresponding to results from each fold.</p>
</td></tr>
<tr><td><code id="combine_results_+3A_combiners">combiners</code></td>
<td>
<p>A <code>list</code> with the same names as results, containing
combiner function names or functions for each result.</p>
</td></tr>
<tr><td><code id="combine_results_+3A_smart_combiners">smart_combiners</code></td>
<td>
<p>A <code>logical</code> indicating whether combiners should
be guessed from the data type of the results if they are missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In theory you should never call this function directly, because it
is called automatically by cross_validate. The defaults, combiners guessed
based on data type, should work in most cases.
</p>


<h3>Value</h3>

<p>A list of combined results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combiners">combiners</a></code>
</p>

<hr>
<h2 id='combiners'>Combiners</h2><span id='topic+combiners'></span><span id='topic+combiner_rbind'></span><span id='topic+combiner_c'></span><span id='topic+combiner_factor'></span><span id='topic+combiner_array'></span>

<h3>Description</h3>

<p>Combiners are functions that collapse across a list of similarly structured
results. These are standard idioms for combining lists of certain data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combiner_rbind(x)

combiner_c(x)

combiner_factor(x)

combiner_array(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combiners_+3A_x">x</code></td>
<td>
<p>A <code>list</code> of similar results to be combined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined results object.
</p>

<hr>
<h2 id='cross_validate'>Main Cross-Validation Function</h2><span id='topic+cross_validate'></span>

<h3>Description</h3>

<p>Applies <code>cv_fun</code> to the folds using <code>future_lapply</code> and combines
the results across folds using <code><a href="#topic+combine_results">combine_results</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validate(
  cv_fun,
  folds,
  ...,
  use_future = TRUE,
  .combine = TRUE,
  .combine_control = list(),
  .old_results = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_validate_+3A_cv_fun">cv_fun</code></td>
<td>
<p>A function that takes a 'fold' as it's first argument and
returns a list of results from that fold. NOTE: the use of an argument
named 'X' is specifically disallowed in any input function for compliance
with the functions <code><a href="future.apply.html#topic+future_lapply">future_lapply</a></code> and
<code>lapply</code>.</p>
</td></tr>
<tr><td><code id="cross_validate_+3A_folds">folds</code></td>
<td>
<p>A list of folds to loop over generated using
<code><a href="#topic+make_folds">make_folds</a></code>.</p>
</td></tr>
<tr><td><code id="cross_validate_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>cvfun</code>.</p>
</td></tr>
<tr><td><code id="cross_validate_+3A_use_future">use_future</code></td>
<td>
<p>A <code>logical</code> option for whether to run the main loop
of cross-validation with <code><a href="future.apply.html#topic+future_lapply">future_lapply</a></code> or with
<code>lapply</code>.</p>
</td></tr>
<tr><td><code id="cross_validate_+3A_.combine">.combine</code></td>
<td>
<p>A <code>logical</code> indicating if <code><a href="#topic+combine_results">combine_results</a></code>
should be called.</p>
</td></tr>
<tr><td><code id="cross_validate_+3A_.combine_control">.combine_control</code></td>
<td>
<p>A <code>list</code> of arguments to
<code><a href="#topic+combine_results">combine_results</a></code>.</p>
</td></tr>
<tr><td><code id="cross_validate_+3A_.old_results">.old_results</code></td>
<td>
<p>A <code>list</code> containing the returned result from a
previous call to this function. Will be combined with the current results.
This is useful for adding additional CV folds to a results object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of results, combined across folds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############################################################################
# This example explains how to use the cross_validate function naively.
###############################################################################
data(mtcars)

# resubstitution MSE
r &lt;- lm(mpg ~ ., data = mtcars)
mean(resid(r)^2)

# function to calculate cross-validated squared error
cv_lm &lt;- function(fold, data, reg_form) {
  # get name and index of outcome variable from regression formula
  out_var &lt;- as.character(unlist(stringr::str_split(reg_form, " "))[1])
  out_var_ind &lt;- as.numeric(which(colnames(data) == out_var))

  # split up data into training and validation sets
  train_data &lt;- training(data)
  valid_data &lt;- validation(data)

  # fit linear model on training set and predict on validation set
  mod &lt;- lm(as.formula(reg_form), data = train_data)
  preds &lt;- predict(mod, newdata = valid_data)

  # capture results to be returned as output
  out &lt;- list(
    coef = data.frame(t(coef(mod))),
    SE = ((preds - valid_data[, out_var_ind])^2)
  )
  return(out)
}

# replicate the resubstitution estimate
resub &lt;- make_folds(mtcars, fold_fun = folds_resubstitution)[[1]]
resub_results &lt;- cv_lm(fold = resub, data = mtcars, reg_form = "mpg ~ .")
mean(resub_results$SE)

# cross-validated estimate
folds &lt;- make_folds(mtcars)
cv_results &lt;- cross_validate(
  cv_fun = cv_lm, folds = folds, data = mtcars,
  reg_form = "mpg ~ ."
)
mean(cv_results$SE)
###############################################################################
# This example explains how to use the cross_validate function with
# parallelization using the framework of the future package.
###############################################################################

suppressMessages(library(data.table))
library(future)
data(mtcars)
set.seed(1)

# make a lot of folds
folds &lt;- make_folds(mtcars, fold_fun = folds_bootstrap, V = 1000)

# function to calculate cross-validated squared error for linear regression
cv_lm &lt;- function(fold, data, reg_form) {
  # get name and index of outcome variable from regression formula
  out_var &lt;- as.character(unlist(str_split(reg_form, " "))[1])
  out_var_ind &lt;- as.numeric(which(colnames(data) == out_var))

  # split up data into training and validation sets
  train_data &lt;- training(data)
  valid_data &lt;- validation(data)

  # fit linear model on training set and predict on validation set
  mod &lt;- lm(as.formula(reg_form), data = train_data)
  preds &lt;- predict(mod, newdata = valid_data)

  # capture results to be returned as output
  out &lt;- list(
    coef = data.frame(t(coef(mod))),
    SE = ((preds - valid_data[, out_var_ind])^2)
  )
  return(out)
}

plan(sequential)
time_seq &lt;- system.time({
  results_seq &lt;- cross_validate(
    cv_fun = cv_lm, folds = folds, data = mtcars,
    reg_form = "mpg ~ ."
  )
})

plan(multicore)
time_mc &lt;- system.time({
  results_mc &lt;- cross_validate(
    cv_fun = cv_lm, folds = folds, data = mtcars,
    reg_form = "mpg ~ ."
  )
})

if (availableCores() &gt; 1) {
  time_mc["elapsed"] &lt; 1.2 * time_seq["elapsed"]
}
</code></pre>

<hr>
<h2 id='fold_from_foldvec'>Build a Fold Object from a Fold Vector</h2><span id='topic+fold_from_foldvec'></span>

<h3>Description</h3>

<p>For V-fold type cross-validation. This takes a fold vector (validation set
IDs) and builds a fold object for fold V.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold_from_foldvec(v, folds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_from_foldvec_+3A_v">v</code></td>
<td>
<p>An identifier of the fold in which observations fall for
cross-validation.</p>
</td></tr>
<tr><td><code id="fold_from_foldvec_+3A_folds">folds</code></td>
<td>
<p>A vector of the fold status for each observation for
cross-validation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fold generation functions: 
<code><a href="#topic+fold_funs">fold_funs</a></code>,
<code><a href="#topic+folds2foldvec">folds2foldvec</a>()</code>,
<code><a href="#topic+make_folds">make_folds</a>()</code>,
<code><a href="#topic+make_repeated_folds">make_repeated_folds</a>()</code>
</p>

<hr>
<h2 id='fold_funs'>Cross-Validation Schemes</h2><span id='topic+fold_funs'></span><span id='topic+folds_vfold'></span><span id='topic+folds_resubstitution'></span><span id='topic+folds_loo'></span><span id='topic+folds_montecarlo'></span><span id='topic+folds_bootstrap'></span><span id='topic+folds_rolling_origin'></span><span id='topic+folds_rolling_window'></span><span id='topic+folds_rolling_origin_pooled'></span><span id='topic+folds_rolling_window_pooled'></span><span id='topic+folds_vfold_rolling_origin_pooled'></span><span id='topic+folds_vfold_rolling_window_pooled'></span>

<h3>Description</h3>

<p>These functions represent different cross-validation schemes that can be
used with <span class="pkg">origami</span>. They should be used as options for the
<code>fold_fun</code> argument to <code><a href="#topic+make_folds">make_folds</a></code>, which will call the
requested function specify <code>n</code>, based on its arguments, and pass any
remaining arguments (e.g. <code>V</code> or <code>pvalidation</code>) on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folds_vfold(n, V = 10L)

folds_resubstitution(n)

folds_loo(n)

folds_montecarlo(n, V = 1000L, pvalidation = 0.2)

folds_bootstrap(n, V = 1000L)

folds_rolling_origin(n, first_window, validation_size, gap = 0L, batch = 1L)

folds_rolling_window(n, window_size, validation_size, gap = 0L, batch = 1L)

folds_rolling_origin_pooled(
  n,
  t,
  id = NULL,
  time = NULL,
  first_window,
  validation_size,
  gap = 0L,
  batch = 1L
)

folds_rolling_window_pooled(
  n,
  t,
  id = NULL,
  time = NULL,
  window_size,
  validation_size,
  gap = 0L,
  batch = 1L
)

folds_vfold_rolling_origin_pooled(
  n,
  t,
  id = NULL,
  time = NULL,
  V = 10L,
  first_window,
  validation_size,
  gap = 0L,
  batch = 1L
)

folds_vfold_rolling_window_pooled(
  n,
  t,
  id = NULL,
  time = NULL,
  V = 10L,
  window_size,
  validation_size,
  gap = 0L,
  batch = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_funs_+3A_n">n</code></td>
<td>
<p>An integer indicating the number of observations.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_v">V</code></td>
<td>
<p>An integer indicating the number of folds.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_pvalidation">pvalidation</code></td>
<td>
<p>A <code>numeric</code> indicating the proportion of observation
to be placed in the validation fold.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_first_window">first_window</code></td>
<td>
<p>An integer indicating the number of observations in the
first training sample.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_validation_size">validation_size</code></td>
<td>
<p>An integer indicating the number of points in the
validation samples; should be equal to the largest forecast horizon.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_gap">gap</code></td>
<td>
<p>An integer indicating the number of points not included in the
training or validation samples. The default is zero.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_batch">batch</code></td>
<td>
<p>An integer indicating increases in the number of time points
added to the training set in each iteration of cross-validation. Applicable
for larger time-series. The default is one.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_window_size">window_size</code></td>
<td>
<p>An integer indicating the number of observations in each
training sample.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_t">t</code></td>
<td>
<p>An integer indicating the total amount of time to consider per
time-series sample.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_id">id</code></td>
<td>
<p>An optional vector of unique identifiers corresponding to the time
vector. These can be used to subset the time vector.</p>
</td></tr>
<tr><td><code id="fold_funs_+3A_time">time</code></td>
<td>
<p>An optional vector of integers of time points observed for each
subject in the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>Fold</code>s.
</p>


<h3>See Also</h3>

<p>Other fold generation functions: 
<code><a href="#topic+fold_from_foldvec">fold_from_foldvec</a>()</code>,
<code><a href="#topic+folds2foldvec">folds2foldvec</a>()</code>,
<code><a href="#topic+make_folds">make_folds</a>()</code>,
<code><a href="#topic+make_repeated_folds">make_repeated_folds</a>()</code>
</p>

<hr>
<h2 id='fold_helpers'>Fold Helpers</h2><span id='topic+fold_helpers'></span><span id='topic+training'></span><span id='topic+validation'></span><span id='topic+fold_index'></span>

<h3>Description</h3>

<p>Accessors and indexers for the different parts of a fold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>training(x = NULL, fold = NULL)

validation(x = NULL, fold = NULL)

fold_index(x = NULL, fold = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fold_helpers_+3A_x">x</code></td>
<td>
<p>an object to be indexed by a training set, validation set, or fold
index. If missing, the index itself will be returned.</p>
</td></tr>
<tr><td><code id="fold_helpers_+3A_fold">fold</code></td>
<td>
<p>Fold; the fold used to do the indexing. If missing, <code>fold</code>
will be pulled from the calling environment, if available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The elements of <code>x</code> corresponding to the indexes, or the
indexes themselves if <code>x</code> is missing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_fold">make_fold</a></code>
</p>

<hr>
<h2 id='folds2foldvec'>Build a Fold Vector from a Fold Object</h2><span id='topic+folds2foldvec'></span>

<h3>Description</h3>

<p>For V-fold type cross-validation. This takes a fold object and returns a fold
vector (containing the validation set IDs) for use with other tools like
<code><a href="glmnet.html#topic+cv.glmnet">cv.glmnet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folds2foldvec(folds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="folds2foldvec_+3A_folds">folds</code></td>
<td>
<p>A <code>fold</code> object as produced by <code><a href="#topic+make_folds">make_folds</a></code>,
from which a <code>numeric</code> vector of the validation set fold IDs are
returned.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fold generation functions: 
<code><a href="#topic+fold_from_foldvec">fold_from_foldvec</a>()</code>,
<code><a href="#topic+fold_funs">fold_funs</a></code>,
<code><a href="#topic+make_folds">make_folds</a>()</code>,
<code><a href="#topic+make_repeated_folds">make_repeated_folds</a>()</code>
</p>

<hr>
<h2 id='guess_combiner'>Flexible Guessing and Mapping for Combining Data Types</h2><span id='topic+guess_combiner'></span>

<h3>Description</h3>

<p>Maps data types into standard combiners that should be sensible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_combiner(result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_combiner_+3A_result">result</code></td>
<td>
<p>A single result; flexibly accepts several object classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function to combine a list of such results.
</p>

<hr>
<h2 id='id_folds_to_folds'>Convert ID Folds to Observation Folds</h2><span id='topic+id_folds_to_folds'></span>

<h3>Description</h3>

<p>This function convertsf olds that subset ids to folds that subset
observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_folds_to_folds(idfolds, cluster_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_folds_to_folds_+3A_idfolds">idfolds</code></td>
<td>
<p>folds that subset ids</p>
</td></tr>
<tr><td><code id="id_folds_to_folds_+3A_cluster_ids">cluster_ids</code></td>
<td>
<p>a vector of cluster ids indicating which observations are
in which clusters</p>
</td></tr>
</table>

<hr>
<h2 id='make_fold'>Fold</h2><span id='topic+make_fold'></span>

<h3>Description</h3>

<p>Functions to make a fold. Current representation is a simple <code>list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_fold(v, training_set, validation_set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_fold_+3A_v">v</code></td>
<td>
<p>An integer index of folds in the larger scheme.</p>
</td></tr>
<tr><td><code id="make_fold_+3A_training_set">training_set</code></td>
<td>
<p>An integer vector of indexes corresponding to the
training set.</p>
</td></tr>
<tr><td><code id="make_fold_+3A_validation_set">validation_set</code></td>
<td>
<p>An integer vector of indexes corresponding to the
validation set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing these elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fold_helpers">fold_helpers</a></code>
</p>

<hr>
<h2 id='make_folds'>Make List of Folds for cross-validation</h2><span id='topic+make_folds'></span>

<h3>Description</h3>

<p>Generates a list of folds for a variety of cross-validation schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_folds(
  n = NULL,
  fold_fun = folds_vfold,
  cluster_ids = NULL,
  strata_ids = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_folds_+3A_n">n</code></td>
<td>
<p>- either an integer indicating the number of observations to
cross-validate over, or an object from which to guess the number of
observations; can also be computed from <code>strata_ids</code> or
<code>cluster_ids</code>.</p>
</td></tr>
<tr><td><code id="make_folds_+3A_fold_fun">fold_fun</code></td>
<td>
<p>- A function indicating the cross-validation scheme to use.
See <code><a href="#topic+fold_funs">fold_funs</a></code> for a list of possibilities.</p>
</td></tr>
<tr><td><code id="make_folds_+3A_cluster_ids">cluster_ids</code></td>
<td>
<p>- a vector of cluster ids. Clusters are treated as a unit
&ndash; that is, all observations within a cluster are placed in either the
training or validation set.</p>
</td></tr>
<tr><td><code id="make_folds_+3A_strata_ids">strata_ids</code></td>
<td>
<p>- a vector of strata ids. Strata are balanced: insofar as
possible the distribution in the sample should be the same as the
distribution in the training and validation sets.</p>
</td></tr>
<tr><td><code id="make_folds_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code>fold_fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of folds objects. Each fold consists of a list with a
<code>training</code> index vector, a <code>validation</code> index vector, and a
<code>fold_index</code> (its order in the list of folds).
</p>


<h3>See Also</h3>

<p>Other fold generation functions: 
<code><a href="#topic+fold_from_foldvec">fold_from_foldvec</a>()</code>,
<code><a href="#topic+fold_funs">fold_funs</a></code>,
<code><a href="#topic+folds2foldvec">folds2foldvec</a>()</code>,
<code><a href="#topic+make_repeated_folds">make_repeated_folds</a>()</code>
</p>

<hr>
<h2 id='make_repeated_folds'>Repeated Cross-Validation</h2><span id='topic+make_repeated_folds'></span>

<h3>Description</h3>

<p>Implementation of repeated window cross-validation: generates fold objects
for repeated cross-validation by making repeated calls to
<code><a href="#topic+make_folds">make_folds</a></code> and concatenating the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_repeated_folds(repeats, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_repeated_folds_+3A_repeats">repeats</code></td>
<td>
<p>An integer indicating the number of repeats.</p>
</td></tr>
<tr><td><code id="make_repeated_folds_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+make_folds">make_folds</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fold generation functions: 
<code><a href="#topic+fold_from_foldvec">fold_from_foldvec</a>()</code>,
<code><a href="#topic+fold_funs">fold_funs</a></code>,
<code><a href="#topic+folds2foldvec">folds2foldvec</a>()</code>,
<code><a href="#topic+make_folds">make_folds</a>()</code>
</p>

<hr>
<h2 id='wrap_in_try'>Wrap a Function in a Try Statement</h2><span id='topic+wrap_in_try'></span>

<h3>Description</h3>

<p>Function factory that generates versions of functions wrapped in <code>try</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_in_try(fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_in_try_+3A_fun">fun</code></td>
<td>
<p>A <code>function</code> to be wrapped in a <code>try</code> statement.</p>
</td></tr>
<tr><td><code id="wrap_in_try_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the previous argument <code>fun</code>.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
