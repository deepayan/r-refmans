<!DOCTYPE html><html><head><title>Help for package rootSolve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rootSolve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gradient'>
<p>Estimates the gradient matrix for a simple function</p></a></li>
<li><a href='#hessian'>
<p>Estimates the hessian matrix</p></a></li>
<li><a href='#jacobian.band'>
<p>Banded jacobian matrix for a system of ODEs (ordinary differential equations)</p></a></li>
<li><a href='#jacobian.full'>
<p>Full square jacobian matrix for a system of ODEs (ordinary differential</p>
equations)</a></li>
<li><a href='#multiroot'>
<p>Solves for n roots of n (nonlinear) equations.</p></a></li>
<li><a href='#multiroot.1D'>
<p>Solves for n roots of n (nonlinear) equations, created by discretizing</p>
ordinary differential equations.</a></li>
<li><a href='#plot.steady1D'>
<p>Plot and Summary Method for steady1D, steady2D and steady3D Objects</p></a></li>
<li><a href='#rootSolve-package'>
<p>Roots and steady-states</p></a></li>
<li><a href='#runsteady'>
<p>Dynamically runs a system of ordinary differential equations (ODE) to</p>
steady-state</a></li>
<li><a href='#steady'>
<p>General steady-state solver for a set of ordinary differential equations.</p></a></li>
<li><a href='#steady.1D'>
<p>Steady-state solver for multicomponent 1-D ordinary differential equations</p></a></li>
<li><a href='#steady.2D'>
<p>Steady-state solver for 2-Dimensional ordinary differential equations</p></a></li>
<li><a href='#steady.3D'>
<p>Steady-state solver for 3-Dimensional ordinary differential equations</p></a></li>
<li><a href='#steady.band'>
<p>Steady-state solver for ordinary differential equations; assumes a</p>
banded jacobian</a></li>
<li><a href='#stode'>
<p>Iterative steady-state solver for ordinary differential equations (ODE)</p>
and a full or banded Jacobian.</a></li>
<li><a href='#stodes'>
<p>Steady-state solver for ordinary differential equations (ODE) with a sparse</p>
jacobian.</a></li>
<li><a href='#uniroot.all'>
<p>Finds many (all) roots of one equation within an interval</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8.2.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Root Finding, Equilibrium and Steady-State Analysis of
Ordinary Differential Equations</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Karline Soetaert [aut, cre],
  Alan C. Hindmarsh [ctb] (files lsodes.f, sparse.f),
  S.C. Eisenstat [ctb] (file sparse.f),
  Cleve Moler [ctb] (file dlinpk.f),
  Jack Dongarra [ctb] (file dlinpk.f),
  Youcef Saad [ctb] (file dsparsk.f)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.01)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, grDevices</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines to find the root of nonlinear functions, and to perform steady-state and equilibrium analysis of ordinary differential equations (ODE). 
  Includes routines that: (1) generate gradient and jacobian matrices (full and banded),
  (2) find roots of non-linear equations by the 'Newton-Raphson' method, 
  (3) estimate steady-state conditions of a system of (differential) equations in full, banded or sparse form, using the 'Newton-Raphson' method, or by dynamically running,
  (4) solve the steady-state conditions for uni-and multicomponent 1-D, 2-D, and 3-D partial differential equations, that have been converted to ordinary differential equations
    by numerical differencing (using the method-of-lines approach).
  Includes fortran code.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-21 07:48:18 UTC; karlines</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-21 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gradient'>
Estimates the gradient matrix for a simple function
</h2><span id='topic+gradient'></span>

<h3>Description</h3>

<p>Given a vector of variables (x), and a function (f) that estimates one
function value or a set of function values (<code class="reqn">f(x)</code>), estimates the
gradient matrix, containing, on rows i and columns j
</p>
<p style="text-align: center;"><code class="reqn">d(f(x)_i)/d(x_j)</code>
</p>

<p>The gradient matrix is not necessarily square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(f, x, centered = FALSE, pert = 1e-8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_f">f</code></td>
<td>
<p>function returning one function value, or a vector of function
values.
</p>
</td></tr>
<tr><td><code id="gradient_+3A_x">x</code></td>
<td>
<p>either one value or a vector containing the x-value(s) at which
the gradient matrix should be estimated.
</p>
</td></tr>
<tr><td><code id="gradient_+3A_centered">centered</code></td>
<td>
<p>if <code>TRUE</code>, uses a centered difference approximation,
else a forward difference approximation.
</p>
</td></tr>
<tr><td><code id="gradient_+3A_pert">pert</code></td>
<td>
<p>numerical perturbation factor; increase depending on precision
of model solution.
</p>
</td></tr>
<tr><td><code id="gradient_+3A_...">...</code></td>
<td>
<p>other arguments passed to function <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function <code>f</code> that estimates the function values will be called as
f(x, ...). If <code>x</code> is a vector, then the first argument passed to
<code>f</code> should also be a vector. 
</p>
<p>The gradient is estimated numerically, by perturbing the x-values.
</p>


<h3>Value</h3>

<p>The gradient matrix where the number of rows equals the length of <code>f</code>
and the number of columns equals the length of <code>x</code>.
</p>
<p>the elements on i-th row and j-th column contain: <code class="reqn">d((f(x))_i)/d(x_j)</code>
</p>


<h3>Note</h3>

<p><code>gradient</code> can be used to calculate so-called <code>sensitivity functions</code>,
that estimate the effect of parameters on output variables.</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p>Soetaert, K. and P.M.J. Herman (2008). A practical guide to ecological modelling -
using R as a simulation platform. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jacobian.full">jacobian.full</a></code>, for generating a full and <b>square</b>
gradient (jacobian) matrix and where the function call is more complex
</p>
<p><code><a href="#topic+hessian">hessian</a></code>, for generating the Hessian matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## 1. Sensitivity analysis of the logistic differential equation
## dN/dt = r*(1-N/K)*N  , N(t0)=N0.
## =======================================================================

# analytical solution of the logistic equation:
logistic &lt;- function (x, times) {

 with (as.list(x),
 {
  N &lt;- K / (1+(K-N0)/N0*exp(-r*times))
  return(c(N = N))
  })
}

# parameters for the US population from 1900
x &lt;- c(N0 = 76.1, r = 0.02, K = 500)

# Sensitivity function: SF: dfi/dxj at
# output intervals from 1900 to 1950
SF &lt;- gradient(f = logistic, x, times = 0:50)

# sensitivity, scaled for the value of the parameter:
# [dfi/(dxj/xj)]= SF*x (columnise multiplication)
sSF &lt;- (t(t(SF)*x))
matplot(sSF, xlab = "time", ylab = "relative sensitivity ",
        main = "logistic equation", pch = 1:3)
legend("topleft", names(x), pch = 1:3, col = 1:3)

# mean scaled sensitivity
colMeans(sSF)

## =======================================================================
## 2. Stability of the budworm model, as a function of its
## rate of increase.
##
## Example from the book of Soetaert and Herman(2009)
## A practical guide to ecological modelling,
## using R as a simulation platform. Springer
## code and theory are explained in this book
## =======================================================================

r   &lt;- 0.05
K   &lt;- 10
bet &lt;- 0.1
alf &lt;- 1

# density-dependent growth and sigmoid-type mortality rate
rate &lt;- function(x, r = 0.05) r*x*(1-x/K) - bet*x^2/(x^2+alf^2)

# Stability of a root ~ sign of eigenvalue of Jacobian 
stability &lt;- function (r)  {
  Eq &lt;- uniroot.all(rate, c(0, 10), r = r)
  eig  &lt;- vector()
  for (i in 1:length(Eq)) 
      eig[i] &lt;- sign (gradient(rate, Eq[i], r = r))
  return(list(Eq = Eq, Eigen = eig))
}

# bifurcation diagram
rseq &lt;- seq(0.01, 0.07, by = 0.0001)

plot(0, xlim = range(rseq), ylim = c(0, 10), type = "n",
     xlab = "r", ylab = "B*", main = "Budworm model, bifurcation",
     sub = "Example from Soetaert and Herman, 2009")

for (r in rseq) {
  st &lt;- stability(r) 
  points(rep(r, length(st$Eq)), st$Eq, pch = 22,
         col = c("darkblue", "black", "lightblue")[st$Eigen+2],
         bg = c("darkblue", "black", "lightblue")[st$Eigen+2]) 
}

legend("topleft", pch = 22, pt.cex = 2, c("stable", "unstable"),
        col = c("darkblue","lightblue"), 
        pt.bg = c("darkblue", "lightblue"))</code></pre>

<hr>
<h2 id='hessian'>
Estimates the hessian matrix
</h2><span id='topic+hessian'></span>

<h3>Description</h3>

<p>Given a vector of variables (x), and a function (f) that estimates one
function value, estimates the hessian matrix by numerical differencing.
The hessian matrix is a square matrix of second-order partial derivatives
of the function f with respect to x. It contains, on rows i and columns j
</p>
<p style="text-align: center;"><code class="reqn">d^2(f(x))/d(x_i)/d(x_j)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>hessian(f, x, centered = FALSE, pert = 1e-8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hessian_+3A_f">f</code></td>
<td>
<p>function returning one function value, or a vector of
function values.
</p>
</td></tr>
<tr><td><code id="hessian_+3A_x">x</code></td>
<td>
<p>either one value or a vector containing the x-value(s) at which
the hessian matrix should be estimated.
</p>
</td></tr>
<tr><td><code id="hessian_+3A_centered">centered</code></td>
<td>
<p>if TRUE, uses a centered difference approximation, else
a forward difference approximation.
</p>
</td></tr>
<tr><td><code id="hessian_+3A_pert">pert</code></td>
<td>
<p>numerical perturbation factor; increase depending on
precision of model solution.
</p>
</td></tr>
<tr><td><code id="hessian_+3A_...">...</code></td>
<td>
<p>other arguments passed to function <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>hessian(f,x)</code> returns a forward or centered difference
approximation of the gradient, which itself is also estimated by differencing.
Because of that, it is not very precise.
</p>


<h3>Value</h3>

<p>The gradient matrix where the number of rows equals the length of <code>f</code>
and the number of columns equals the length of <code>x</code>.
</p>
<p>the elements on i-th row and j-th column contain: <code class="reqn">d((f(x))_i)/d(x_j)</code>
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gradient">gradient</a></code>, for a full (not necessarily square) gradient matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## the banana function
## =======================================================================
   fun &lt;- function(x)  100*(x[2] - x[1]^2)^2 + (1 - x[1])^2
   mm  &lt;- nlm(fun, p = c(0, 0))$estimate
   (Hes &lt;- hessian(fun, mm))
   # can also be estimated by nlm(fun, p=c(0,0), hessian=TRUE)
   solve(Hes)   # estimate of parameter uncertainty
</code></pre>

<hr>
<h2 id='jacobian.band'>
Banded jacobian matrix for a system of ODEs (ordinary differential equations)
</h2><span id='topic+jacobian.band'></span>

<h3>Description</h3>

<p>Given a vector of (state) variables <code>y</code>, and a function that estimates a
function value for each (state) variable (e.g. the rate of change),
estimates the Jacobian matrix (<code class="reqn">d(f(y))/d(y)</code>).
</p>
<p>Assumes a banded structure of the Jacobian matrix, i.e. where the non-zero
elements are restricted to a number of bands above and below the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobian.band(y, func, bandup = 1, banddown = 1, 
              dy = NULL, time = 0, parms = NULL, pert = 1e-8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobian.band_+3A_y">y</code></td>
<td>
<p>(state) variables, a vector; if <code>y</code> has a name attribute,
the names will be used to label the jacobian matrix columns.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_func">func</code></td>
<td>
<p>function that calculates one function value for each element
of <code>y</code>; if an ODE system, <code>func</code> calculates the rate of change
(see details).
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_bandup">bandup</code></td>
<td>
<p>number of nonzero bands above the diagonal of the Jacobian
matrix.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_banddown">banddown</code></td>
<td>
<p>number of nonzero bands below the diagonal of the Jacobian
matrix.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_dy">dy</code></td>
<td>
<p>reference function value; if not specified, it will be estimated
by calling <code>func</code>.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_time">time</code></td>
<td>
<p>time, passed to function <code>func</code>.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_parms">parms</code></td>
<td>
<p>parameter values, passed to function <code>func</code>.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_pert">pert</code></td>
<td>
<p>numerical perturbation factor; increase depending on precision
of model solution.
</p>
</td></tr>
<tr><td><code id="jacobian.band_+3A_...">...</code></td>
<td>
<p>other arguments passed to function <code>func</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>func</code> that estimates the rate of change of the state
variables has to be	consistent with functions called from R-package
<code>deSolve</code>, which contains integration routines.
</p>
<p>This function call is as: <b>function(time,y,parms,...)</b> where
</p>

<ul>
<li> <p><code>y</code> : (state) variable values at which the Jacobian is estimated.
</p>
</li>
<li> <p><code>parms</code>: parameter vector  - need not be used.
</p>
</li>
<li> <p><code>time</code>: time at which the Jacobian is estimated - in general,
<code>time</code> will not be used.
</p>
</li>
<li> <p><code>...</code>: (optional) any other arguments
</p>
</li></ul>

<p>The Jacobian is estimated numerically, by perturbing the x-values.
</p>


<h3>Value</h3>

<p>Jacobian matrix, in banded format, i.e. only the nonzero bands near the
diagonal form the rows of the Jacobian. 
</p>
<p>this matrix has <code>bandup</code>+<code>banddown</code>+1 rows, while the number of
columns equal the length of <code>y</code>.
</p>
<p>Thus, if the full Jacobian is given by:
</p>

<table>
<tr>
 <td style="text-align: left;">
         </td><td style="text-align: left;"> [,1],</td><td style="text-align: left;"> [,2],</td><td style="text-align: left;"> [,3],</td><td style="text-align: left;"> [,4] </td>
</tr>
<tr>
 <td style="text-align: left;">
    [,1] </td><td style="text-align: left;"> 1    </td><td style="text-align: left;"> 2    </td><td style="text-align: left;"> 0    </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
    [,2] </td><td style="text-align: left;"> 3    </td><td style="text-align: left;"> 4    </td><td style="text-align: left;"> 5    </td><td style="text-align: left;"> 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
    [,3] </td><td style="text-align: left;"> 0    </td><td style="text-align: left;"> 6    </td><td style="text-align: left;"> 7    </td><td style="text-align: left;"> 8 </td>
</tr>
<tr>
 <td style="text-align: left;">
    [,4] </td><td style="text-align: left;"> 0    </td><td style="text-align: left;"> 0    </td><td style="text-align: left;"> 9    </td><td style="text-align: left;"> 10
  </td>
</tr>

</table>

<p>the banded jacobian will be:
</p>

<table>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> [,1],</td><td style="text-align: left;"> [,2],</td><td style="text-align: left;"> [,3],</td><td style="text-align: left;"> [,4] </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,1] </td><td style="text-align: left;"> 0    </td><td style="text-align: left;"> 2    </td><td style="text-align: left;"> 5    </td><td style="text-align: left;"> 8 </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,2] </td><td style="text-align: left;"> 1    </td><td style="text-align: left;"> 4    </td><td style="text-align: left;"> 7    </td><td style="text-align: left;"> 10 </td>
</tr>
<tr>
 <td style="text-align: right;">
    [,3] </td><td style="text-align: left;"> 3    </td><td style="text-align: left;"> 6    </td><td style="text-align: left;"> 9    </td><td style="text-align: left;"> 0
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+jacobian.full">jacobian.full</a></code>, estimates the Jacobian matrix
assuming a full matrix.
</p>
<p><code><a href="#topic+hessian">hessian</a></code>, estimates the Hessian matrix.
</p>
<p><code><a href="#topic+gradient">gradient</a></code>, for a full (not necessarily square) gradient matrix
and where the function call is simpler.
</p>
<p><code><a href="#topic+uniroot.all">uniroot.all</a></code>, to solve for all roots of one (nonlinear) equation
</p>
<p><code><a href="#topic+multiroot">multiroot</a></code>, to solve n roots of n (nonlinear) equations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================

mod &lt;- function (t = 0, y, parms = NULL,...) {
  dy1 &lt;-  y[1] + 2*y[2]
  dy2 &lt;-3*y[1] + 4*y[2] + 5*y[3]
  dy3 &lt;-         6*y[2] + 7*y[3] + 8*y[4]
  dy4 &lt;-                  9*y[3] +10*y[4]
  return(as.list(c(dy1, dy2, dy3, dy4)))
}

jacobian.band(y = c(1, 2, 3, 4), func = mod)
</code></pre>

<hr>
<h2 id='jacobian.full'>
Full square jacobian matrix for a system of ODEs (ordinary differential
equations)
</h2><span id='topic+jacobian.full'></span>

<h3>Description</h3>

<p>Given a vector of (state) variables, and a function that estimates one
function value for each (state) variable (e.g. the rate of change),
estimates the Jacobian matrix (<code class="reqn">d(f(x))/d(x)</code>)
</p>
<p>Assumes a full and square Jacobian matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobian.full(y, func, dy = NULL, time = 0, parms = NULL, 
              pert = 1e-8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobian.full_+3A_y">y</code></td>
<td>
<p>(state) variables, a vector; if <code>y</code> has a name attribute,
the names will be used to label the Jacobian matrix columns.
</p>
</td></tr>
<tr><td><code id="jacobian.full_+3A_func">func</code></td>
<td>
<p>function that calculates one function value for each element
of <code>y</code>; if an ODE system, <code>func</code> calculates the rate of change
(see details).
</p>
</td></tr>
<tr><td><code id="jacobian.full_+3A_dy">dy</code></td>
<td>
<p>reference function value; if not specified, it will be estimated
by calling <code>func</code>.
</p>
</td></tr>
<tr><td><code id="jacobian.full_+3A_time">time</code></td>
<td>
<p>time, passed to function <code>func</code>.
</p>
</td></tr>
<tr><td><code id="jacobian.full_+3A_parms">parms</code></td>
<td>
<p>parameter values, passed to function <code>func</code>.
</p>
</td></tr>
<tr><td><code id="jacobian.full_+3A_pert">pert</code></td>
<td>
<p>numerical perturbation factor; increase depending on precision
of model solution.
</p>
</td></tr>
<tr><td><code id="jacobian.full_+3A_...">...</code></td>
<td>
<p>other arguments passed to function <code>func</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>func</code> that estimates the rate of change of the state
variables has to be consistent with functions called from
R-package <code>deSolve</code>, which contains integration routines.
</p>
<p>This function call is as: <b>function(time,y,parms,...)</b> where
</p>

<ul>
<li> <p><code>y</code> : (state) variable values at which the Jacobian is estimated.
</p>
</li>
<li> <p><code>parms</code>: parameter vector  - need not be used.
</p>
</li>
<li> <p><code>time</code>: time at which the Jacobian is estimated - in general,
<code>time</code> will not be used.
</p>
</li>
<li> <p><code>...</code>: (optional) any other arguments.
</p>
</li></ul>

<p>The Jacobian is estimated numerically, by perturbing the x-values.
</p>


<h3>Value</h3>

<p>The square jacobian matrix;  the elements on i-th row and j-th column are
given by: <code class="reqn">d(f(x)_i)/d(x_j)</code>
</p>


<h3>Note</h3>

<p>This function is useful for stability analysis of ODEs, which start by
estimating the Jacobian at equilibrium points.
The type of equilibrium then depends on the eigenvalue of the Jacobian.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jacobian.band">jacobian.band</a></code>, estimates the Jacobian matrix
assuming a banded structure.
</p>
<p><code><a href="#topic+hessian">hessian</a></code>, estimates the Hessian matrix.
</p>
<p><code><a href="#topic+gradient">gradient</a></code>, for a full (not necessarily square) gradient matrix
and where the function call is simpler.
</p>
<p><code><a href="#topic+uniroot.all">uniroot.all</a></code>, to solve for all roots of one (nonlinear) equation
</p>
<p><code><a href="#topic+multiroot">multiroot</a></code>, to solve n roots of n (nonlinear) equations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## 1. Structure of the Jacobian
## =======================================================================
mod &lt;- function (t = 0, y, parms = NULL,...)
{
 dy1&lt;-  y[1] + 2*y[2]
 dy2&lt;-3*y[1] + 4*y[2] + 5*y[3]
 dy3&lt;-         6*y[2] + 7*y[3] + 8*y[4]
 dy4&lt;-                  9*y[3] +10*y[4]
 return(as.list(c(dy1, dy2, dy3, dy4)))
}

jacobian.full(y = c(1, 2, 3, 4), func = mod)

## =======================================================================
## 2. Stability properties of a physical model
## =======================================================================
coriolis &lt;- function (t, velocity, pars, f)
{
  dvelx &lt;- f*velocity[2]
  dvely &lt;- -f*velocity[1]
  list(c(dvelx, dvely))
}

# neutral stability; f is coriolis parameter
Jac &lt;- jacobian.full(y = c(velx = 0, vely = 0), func = coriolis,
                     parms = NULL, f = 1e-4)
print(Jac)
eigen(Jac)$values

## =======================================================================
## 3. Type of equilibrium
## =======================================================================
## From Soetaert and Herman (2009). A practical guide to ecological 
## modelling. Using R as a simulation platform. Springer

eqn &lt;- function (t, state, pars)
 {
  with (as.list(c(state, pars)),  {
  dx &lt;- a*x + cc*y
  dy &lt;- b*y + dd*x
  list(c(dx, dy))
  })
 }

# stable equilibrium
A &lt;- eigen(jacobian.full(y = c(x = 0, y = 0), func = eqn,
              parms = c(a = -0.1, b = -0.3, cc = 0, dd = 0)))$values
# unstable equilibrium
B &lt;- eigen(jacobian.full(y = c(x = 0, y = 0), func = eqn,
              parms = c(a = 0.2, b = 0.2, cc = 0.0, dd = 0.2)))$values
# saddle point
C &lt;- eigen(jacobian.full(y = c(x = 0, y = 0), func = eqn,
              parms = c(a = -0.1, b = 0.1, cc = 0, dd = 0)))$values
# neutral stability
D &lt;- eigen(jacobian.full(y = c(x = 0, y = 0), func = eqn,
              parms = c(a = 0, b = 0, cc = -0.1, dd = 0.1)))$values
# stable focal point
E &lt;- eigen(jacobian.full(y = c(x = 0, y = 0), func = eqn,
              parms = c(a = 0, b = -0.1, cc = -0.1, dd = 0.1)))$values
# unstable focal point
F &lt;- eigen(jacobian.full(y = c(x = 0, y = 0), func=eqn,
              parms = c(a = 0., b = 0.1, cc = 0.1, dd = -0.1)))$values

data.frame(type = c("stable", "unstable", "saddle", "neutral",
           "stable focus", "unstable focus"),
           eigenvalue_1 = c(A[1], B[1], C[1], D[1], E[1], F[1]),
           eigenvalue_2 = c(A[2], B[2], C[2], D[2], E[2], F[2]))

## =======================================================================
## 4. Limit cycles
## =======================================================================
## From Soetaert and Herman (2009). A practical guide to ecological 
## modelling. Using R as a simulation platform. Springer

eqn2 &lt;- function (t, state, pars)
 {
  with (as.list(c(state, pars)),
  {
  dx&lt;-  a*y   + e*x*(x^2+y^2-1)
  dy&lt;-  b*x   + f*y*(x^2+y^2-1)
  list(c(dx, dy))
  })
 }

# stable limit cycle with unstable focus
eigen(jacobian.full(c(x = 0, y = 0), eqn2,
                    parms = c(a = -1, b = 1, e = -1, f = -1)))$values
# unstable limit cycle with stable focus
eigen(jacobian.full(c(x = 0, y = 0), eqn2,
                    parms = c(a = -1, b = 1, e = 1, f = 1)))$values
</code></pre>

<hr>
<h2 id='multiroot'>
Solves for n roots of n (nonlinear) equations.
</h2><span id='topic+multiroot'></span>

<h3>Description</h3>

<p>Given a vector of n variables, and a set of n (nonlinear) equations in
these variables,
</p>
<p>estimates the root of the equations, i.e. the variable values where all
function values = 0.
</p>
<p>Assumes a full Jacobian matrix, uses the Newton-Raphson method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiroot(f, start, maxiter = 100, 
          rtol = 1e-6, atol = 1e-8, ctol = 1e-8, 
          useFortran = TRUE, positive = FALSE,
          jacfunc = NULL, jactype = "fullint",
          verbose = FALSE, bandup = 1, banddown = 1, 
          parms = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiroot_+3A_f">f</code></td>
<td>
<p>function for which the root is sought; it must return a vector
with as many values as the length of <code>start</code>.
It is called either as <code>f(x, ...)</code> if <code>parms = NULL</code> or as
<code>f(x, parms, ...)</code> if <code>parms</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_start">start</code></td>
<td>
<p>vector containing initial guesses for the unknown x;
if <code>start</code> has a name attribute, the names will be used to label
the output vector.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations allowed.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or a vector, one
value for each element in the unknown x.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or a vector, one
value for each element in x.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_ctol">ctol</code></td>
<td>
<p>a scalar. If between two iterations, the maximal change in
the variable values is less than this amount, then it is assumed that
the root is found.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_usefortran">useFortran</code></td>
<td>
<p>logical, if <code>FALSE</code>, then an <span class="rlang"><b>R</b></span> -implementation
of the Newton-Raphson method is used - see details.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_positive">positive</code></td>
<td>
<p>if <code>TRUE</code>, the unknowns y are forced to be
non-negative numbers.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, a user-supplied <span class="rlang"><b>R</b></span> function that
estimates the Jacobian of the system of differential equations
dydot(i)/dy(j). In some circumstances, supplying <code>jacfunc</code>
can speed up the computations.  The <span class="rlang"><b>R</b></span> calling sequence for
<code>jacfunc</code> is identical to that of <code>f</code>.
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a matrix
dydot/dy, where the ith row contains the derivative of <code class="reqn">dy_i/dt</code>
with respect to <code class="reqn">y_j</code>, or a vector containing the matrix elements
by columns.
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix containing
only the nonzero bands of the jacobian, (dydot/dy), rotated row-wise.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of &quot;fullint&quot;, &quot;fullusr&quot;,
&quot;bandusr&quot;, &quot;bandint&quot;, or &quot;sparse&quot; - either full or banded and
estimated internally or by the user, or arbitrary sparse.
If the latter, then the solver will call, <code><a href="#topic+stodes">stodes</a></code>,
else <code><a href="#topic+stode">stode</a></code>
</p>
<p>If the Jacobian is arbitrarily &quot;sparse&quot;, then it will be calculated by
the solver (i.e. it is not possible to also specify <code>jacfunc</code>).
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will output
the steady-state settings.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case the
Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case the
jacobian is banded.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>f</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="multiroot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to function <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>start</code> gives the initial guess for each variable; different initial
guesses may return different roots.
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the <b>error
control</b> performed by the solver.  
</p>
<p>The solver will control the vector
<b>e</b> of estimated local errors in <b>f</b>, according to an
inequality of the form max-norm of ( <b>e</b>/<b>ewt</b> )
<code class="reqn">\leq</code> 1, where <b>ewt</b> is a vector of positive error
weights.  The values of <code>rtol</code> and <code>atol</code> should all be
non-negative.
</p>
<p>The form of <b>ewt</b> is:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{rtol} \times \mathrm{abs}(\mathbf{f}) + \mathbf{atol}</code>
</p>

<p>where multiplication of two vectors is element-by-element.
</p>
<p>In addition, the solver will stop if between two iterations, the maximal
change in the values of <b>x</b> is less than <code>ctol</code>.
</p>
<p>There is no checking whether the requested precision exceeds the capabilities
of the machine.
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>root</code></td>
<td>
<p>the location (x-values) of the root.
</p>
</td></tr>
<tr><td><code>f.root</code></td>
<td>
<p>the value of the function evaluated at the <code>root</code>.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used.
</p>
</td></tr>
<tr><td><code>estim.precis</code></td>
<td>
<p>the estimated precision for <code>root</code>. 
It is defined as the mean of the absolute function values
(mean(abs(<code>f.root</code>))).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Fortran implementation of the Newton-Raphson method function (the
default) is generally faster than the <span class="rlang"><b>R</b></span> implementation.
The <span class="rlang"><b>R</b></span> implementation has been included for didactic purposes.
</p>
<p><code>multiroot</code> makes use of function <code>stode</code>.
Technically, it is just a wrapper around function <code>stode</code>.
If the sparsity structure of the Jacobian is known, it may be more efficiently
to call <code>stode, stodes, steady, steady.1D, steady.2D, steady.3D</code>.
</p>
<p>It is NOT guaranteed that the method will converge to the root.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stode">stode</a></code>, which uses a different function call.
</p>
<p><code><a href="#topic+uniroot.all">uniroot.all</a></code>, to solve for all roots of one (nonlinear) equation
</p>
<p><code><a href="#topic+steady">steady</a></code>, <code><a href="#topic+steady.band">steady.band</a></code>,  <code><a href="#topic+steady.1D">steady.1D</a></code>,
<code><a href="#topic+steady.2D">steady.2D</a></code>, <code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers,
which find the roots of ODEs or PDEs. The function call differs from
<code>multiroot</code>.
</p>
<p><code><a href="#topic+jacobian.full">jacobian.full</a></code>, <code><a href="#topic+jacobian.band">jacobian.band</a></code>, estimates the
Jacobian matrix assuming a full or banded structure.
</p>
<p><code><a href="#topic+gradient">gradient</a></code>, <code><a href="#topic+hessian">hessian</a></code>, estimates the gradient
matrix or the Hessian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## example 1  
## 2 simultaneous equations
## =======================================================================

model &lt;- function(x) c(F1 = x[1]^2+ x[2]^2 -1, 
                       F2 = x[1]^2- x[2]^2 +0.5)

(ss &lt;- multiroot(f = model, start = c(1, 1)))

## =======================================================================
## example 2
## 3 equations, two solutions
## =======================================================================

model &lt;- function(x) c(F1 = x[1] + x[2] + x[3]^2 - 12,
                       F2 = x[1]^2 - x[2] + x[3] - 2,
                       F3 = 2 * x[1] - x[2]^2 + x[3] - 1 )

# first solution
(ss &lt;- multiroot(model, c(1, 1, 1), useFortran = FALSE))
(ss &lt;- multiroot(f = model, start = c(1, 1, 1)))

# second solution; use different start values
(ss &lt;- multiroot(model, c(0, 0, 0)))
model(ss$root)

## =======================================================================
## example 2b: same, but with parameters
## 3 equations, two solutions
## =======================================================================

model2 &lt;- function(x, parms) 
      c(F1 = x[1] + x[2] + x[3]^2 - parms[1],
        F2 = x[1]^2 - x[2] + x[3] - parms[2],
        F3 = 2 * x[1] - x[2]^2 + x[3] - parms[3])

# first solution
parms &lt;- c(12, 2, 1)
multiroot(model2, c(1, 1, 1), parms = parms)
multiroot(model2, c(0, 0, 0), parms = parms*2)

## =======================================================================
## example 3: find a matrix
## =======================================================================

f2&lt;-function(x)   {
 X &lt;- matrix(nrow = 5, x)
 X %*% X %*% X -matrix(nrow = 5, data = 1:25, byrow = TRUE)
}
x &lt;- multiroot(f2, start = 1:25 )$root
X &lt;- matrix(nrow = 5, x)

X%*%X%*%X
</code></pre>

<hr>
<h2 id='multiroot.1D'>
Solves for n roots of n (nonlinear) equations, created by discretizing
ordinary differential equations.
</h2><span id='topic+multiroot.1D'></span>

<h3>Description</h3>

<p>multiroot.1D finds the solution to boundary value problems of ordinary
differential equations, which are approximated using the method-of-lines
approach.
</p>
<p>Assumes a banded Jacobian matrix, uses the Newton-Raphson method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiroot.1D(f, start, maxiter = 100,
             rtol = 1e-6, atol = 1e-8, ctol = 1e-8, 
             nspec = NULL, dimens = NULL, verbose = FALSE, 
             positive = FALSE, names = NULL, parms = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiroot.1D_+3A_f">f</code></td>
<td>
<p>function for which the root is sought; it must return a vector
with as many values as the length of <code>start</code>.
It is called either as <code>f(x, ...)</code> if <code>parms = NULL</code> or as
<code>f(x, parms, ...)</code> if <code>parms</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_start">start</code></td>
<td>
<p>vector containing initial guesses for the unknown x;
if <code>start</code> has a name attribute, the names will be used to label
the output vector.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations allowed.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or a vector, one
value for each element in the unknown x.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or a vector, one
value for each element in x.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_ctol">ctol</code></td>
<td>
<p>a scalar. If between two iterations, the maximal change in
the variable values is less than this amount, then it is assumed that
the root is found.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_nspec">nspec</code></td>
<td>
<p>the number of *species* (components) in the model.
If <code>NULL</code>, then <code>dimens</code> should be specified.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_dimens">dimens</code></td>
<td>
<p>the number of *boxes* in the model. If NULL, then
<code>nspec</code> should be specified.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will output
the steady-state settings.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_positive">positive</code></td>
<td>
<p>if <code>TRUE</code>, the unknowns y are forced to be
non-negative numbers.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_names">names</code></td>
<td>
<p>the names of the components; used to label the output, which
will be written as a matrix.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>f</code>.
</p>
</td></tr>
<tr><td><code id="multiroot.1D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to function <code>f</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>multiroot.1D</code> is similar to <code><a href="#topic+steady.1D">steady.1D</a></code>, except for the
function specification which is simpler in <code>multiroot.1D</code>.
</p>
<p>It is to be used to solve (simple) boundary value problems of
differential equations.
</p>
<p>The following differential equation:
</p>
<p style="text-align: center;"><code class="reqn">0=f(x,y,\frac{dy}{dx},\frac{d^2y}{dx^2})</code>
</p>

<p>with boundary conditions
</p>
<p><code class="reqn">y_{x=a}</code> = ya, at the start and <code class="reqn">y_{x=b}</code>=yb
at the end of the integration interval [a,b] is approximated
</p>
<p>as follows:
</p>
<p>1. First the integration interval x is discretized, for instance:
</p>
<p><code>dx &lt;- 0.01</code>
</p>
<p><code>x &lt;- seq(a,b,by=dx)</code>
</p>
<p>where <code>dx</code> should be small enough to keep numerical errors small.
</p>
<p>2. Then the first- and second-order
derivatives are differenced on this numerical
grid. R's <code>diff</code> function is very efficient in taking numerical
differences, so it is used to approximate the first-, and second-order
derivates as follows.
</p>
<p>A <em>first-order derivative y'</em> can be approximated either as:
</p>

<dl>
<dt>y'=<code>diff(c(ya,y))/dx</code></dt><dd><p>if only the initial condition ya is prescribed,</p>
</dd>
<dt>y'=<code>diff(c(y,yb))/dx</code></dt><dd><p>if only the final condition, yb is prescribed,</p>
</dd>
<dt>y'=<code>0.5*(diff(c(ya,y))/dx+diff(c(y,yb))/dx)</code></dt><dd><p>if initial, ya,
and final condition, yb are prescribed.</p>
</dd>
</dl>

<p>The latter (centered differences) is to be preferred.
</p>
<p>A <em>second-order derivative y&rdquo;</em> can be approximated by differencing twice.
</p>
<p>y&rdquo;=<code>diff(diff(c(ya,y,yb))/dx)/dx</code>
</p>
<p>3. Finally, function <code>multiroot.1D</code> is used to locate the root.
</p>
<p>See the examples
</p>


<h3>Value</h3>

<p>a list containing:
</p>
<table>
<tr><td><code>root</code></td>
<td>
<p>the values of the root.
</p>
</td></tr>
<tr><td><code>f.root</code></td>
<td>
<p>the value of the function evaluated at the <code>root</code>.
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations used.
</p>
</td></tr>
<tr><td><code>estim.precis</code></td>
<td>
<p>the estimated precision for <code>root</code>. 
It is defined as the mean of the absolute function values
(mean(abs(<code>f.root</code>))).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>multiroot.1D</code> makes use of function <code>steady.1D</code>.
</p>
<p>It is NOT guaranteed that the method will converge to the root.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stode">stode</a></code>, which uses a different function call.
</p>
<p><code><a href="#topic+uniroot.all">uniroot.all</a></code>, to solve for all roots of one (nonlinear) equation
</p>
<p><code><a href="#topic+steady">steady</a></code>, <code><a href="#topic+steady.band">steady.band</a></code>,  <code><a href="#topic+steady.1D">steady.1D</a></code>,
<code><a href="#topic+steady.2D">steady.2D</a></code>, <code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers,
which find the roots of ODEs or PDEs. The function call differs from
<code>multiroot</code>.
</p>
<p><code><a href="#topic+jacobian.full">jacobian.full</a></code>, <code><a href="#topic+jacobian.band">jacobian.band</a></code>, estimates the
Jacobian matrix assuming a full or banded structure.
</p>
<p><code><a href="#topic+gradient">gradient</a></code>, <code><a href="#topic+hessian">hessian</a></code>, estimates the gradient
matrix or the Hessian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1: simple standard problem
## solve the BVP ODE:
## d2y/dt^2=-3py/(p+t^2)^2
## y(t= -0.1)=-0.1/sqrt(p+0.01)
## y(t=  0.1)= 0.1/sqrt(p+0.01)
## where p = 1e-5
##
## analytical solution y(t) = t/sqrt(p + t^2).
##
## =======================================================================

bvp &lt;- function(y) {
  dy2 &lt;- diff(diff(c(ya, y, yb))/dx)/dx
  return(dy2 + 3*p*y/(p+x^2)^2)
}

dx &lt;- 0.0001
x &lt;- seq(-0.1, 0.1, by = dx)

p  &lt;- 1e-5
ya &lt;- -0.1/sqrt(p+0.01)
yb &lt;-  0.1/sqrt(p+0.01)

print(system.time(
  y &lt;- multiroot.1D(start = runif(length(x)), f = bvp, nspec = 1)
))

plot(x, y$root, ylab = "y", main = "BVP test problem")

# add analytical solution
curve(x/sqrt(p+x*x), add = TRUE, type = "l", col = "red")

## =======================================================================
## Example 2: bvp test problem 28
## solve:
## xi*y'' + y*y' - y=0
## with boundary conditions:
## y0=1
## y1=3/2
## =======================================================================

prob28 &lt;-function(y, xi) {
 dy2 &lt;- diff(diff(c(ya, y, yb))/dx)/dx          # y''
 dy  &lt;- 0.5*(diff(c(ya, y)) +diff(c(y, yb)))/dx # y' - centered differences

 xi*dy2 +dy*y-y
}

ya &lt;- 1
yb &lt;- 3/2
dx &lt;- 0.001
x &lt;- seq(0, 1, by = dx)
N &lt;- length(x)
print(system.time(
  Y1 &lt;- multiroot.1D(f = prob28, start = runif(N), 
                     nspec = 1, xi = 0.1)
))
Y2&lt;- multiroot.1D(f = prob28, start = runif(N), nspec = 1, xi = 0.01)
Y3&lt;- multiroot.1D(f = prob28, start = runif(N), nspec = 1, xi = 0.001)

plot(x, Y3$root, type = "l", col = "green", main = "bvp test problem 28")
lines(x, Y2$root, col = "red")
lines(x, Y1$root, col = "blue")

</code></pre>

<hr>
<h2 id='plot.steady1D'>
Plot and Summary Method for steady1D, steady2D and steady3D Objects
</h2><span id='topic+plot.steady1D'></span><span id='topic+image.steady2D'></span><span id='topic+subset.steady2D'></span><span id='topic+image.steady3D'></span><span id='topic+summary.rootSolve'></span>

<h3>Description</h3>

<p>Plot the output of steady-state solver routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'steady1D'
plot(x, ..., which = NULL, grid = NULL, 
              xyswap = FALSE, ask = NULL, 
              obs = NULL, obspar = list(), vertical = FALSE)
## S3 method for class 'steady2D'
image(x, which = NULL, add.contour = FALSE, 
              grid = NULL, ask = NULL, 
              method = "image", legend = FALSE, ...)
## S3 method for class 'steady2D'
subset(x, which = NULL, ...)
## S3 method for class 'steady3D'
image(x, which = NULL, dimselect = NULL, 
              add.contour = FALSE, grid = NULL, ask = NULL, 
              method = "image", legend = FALSE, ...)
## S3 method for class 'rootSolve'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.steady1D_+3A_x">x</code></td>
<td>
<p>an object of class <code>steady1D</code>, or <code>steady2D</code> as 
returned by the solvers <code>steady.1D</code> and <code>steady.2D</code>, and 
to be plotted.
</p>
<p>For <code>steady1D</code> objects, it is allowed to pass several objects 
after <code>x</code> (unnamed) - see second example.
</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_which">which</code></td>
<td>
<p>the name(s) or the index to the variables that should be
plotted.  Default = all variables. </p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_grid">grid</code></td>
<td>
<p>For 1-D plots of output generated with <code>steady.1D</code>, 
a vector of values against which the 1-D steady-state solution 
has to be plotted. If <code>NULL</code>, then steady-state solutions 
are plotted against the index. 
</p>
<p>for <code>image</code> plots of output generated with <code>steady.2D</code> or 
<code>steady.3D</code>: the x- and y-grid, as a <code>list</code>.</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, if <code>NULL</code> the user is only asked if more than one
page of plots is necessary and the current graphics device is set
interactive, see <code><a href="graphics.html#topic+par">par</a>(ask=.)</code> and
<code><a href="grDevices.html#topic+dev.interactive">dev.interactive</a></code>.</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_xyswap">xyswap</code></td>
<td>
<p>if <code>TRUE</code>, then x-and y-values are swapped and the 
y-axis is from top to bottom. Useful for drawing vertical profiles.</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_vertical">vertical</code></td>
<td>
<p>if <code>TRUE</code>, then 1. x-and y-values are swapped, the
y-axis is from top to bottom, the x-axis is on top, margin 3 and the
main title gets the value of the x-axis.
Useful for drawing vertical profiles; see example 2.</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_obs">obs</code></td>
<td>
<p>a <code>data.frame</code> or <code>matrix</code> with &quot;observed data&quot; that
will be added as <code>points</code> to the plots. <code>obs</code> can also be a 
<code>list</code> with multiple data.frames and/or matrices containing 
observed data. 
</p>
<p>The first column of <code>obs</code> should contain the grid-variables as 
specified in argument <code>grid</code>. 
The other columns contain the observed values
and they should have names that are known in <code>x</code>.    
</p>
<p>If the first column of <code>obs</code> consists of factors, or characters (strings),
then it is assumed that the data are presented in long (database) format,
where the first three columns contain (name, grid, value).  
</p>
<p>If <code>obs</code> is not <code>NULL</code> and 
<code>which</code> is <code>NULL</code>, then the variables, common to both 
<code>obs</code> and <code>x</code> will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_obspar">obspar</code></td>
<td>
<p>additional graphics arguments passed to <code>points</code>, for 
plotting the observed data. If <code>obs</code> is a <code>list</code> containing multiple
observed data sets, then the graphics arguments can be  a vector
or a list (e.g. for <code>xlim</code>, <code>ylim</code>), specifying each data set 
separately.
</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_dimselect">dimselect</code></td>
<td>
<p>a <code>list</code> or <code>NULL</code>. The dimension over which the 
3-D image loops.  If <code>NULL</code>, will loop over the 3rd (z) dimension. This is
similar as setting <code>dimselect = list(z = 1:Nz)</code> where Nz is the number
of grid cells in the 3rd dimension; setting 
<code>dimselect = list(z = seq(1, Nz, by =2))</code> will loop over the 3rd dimension,
but every 2nd cell; <code>dimselect = list(x = ...)</code> or <code>dimselect = list(y = ...)</code>
will loop over the x respectively y-dimension. See <code><a href="#topic+steady.3D">steady.3D</a></code>
for some examples. 
</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_add.contour">add.contour</code></td>
<td>
<p>if <code>TRUE</code>, will add contours to the image plot. </p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_method">method</code></td>
<td>
<p>the name of the plotting function to use, one of &quot;image&quot;, 
&quot;filled.contour&quot;, &quot;contour&quot; or &quot;persp&quot;.</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_legend">legend</code></td>
<td>
<p>if <code>TRUE</code>, a color legend will be drawn next to 
the &quot;image&quot;, or &quot;persp&quot; plot.</p>
</td></tr>
<tr><td><code id="plot.steady1D_+3A_object">object</code></td>
<td>
<p>object of class <code>rootSolve</code> whose summary has to be 
calculated.
</p>
</td></tr> 
<tr><td><code id="plot.steady1D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the methods.
</p>
<p>The graphical arguments are passed to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> (for 1D) or <code>image</code> (for 2D, 3D)
</p>
<p>For <code>plot.steady1D</code>, the dots may contain other objects of class 
<code>steady1D</code>, as returned by <code>steady.1D</code>, and 
to be plotted on the same graphs as <code>x</code>  - see second example.
<code>x</code> and and these other objects should be compatible, 
i.e. the column names should be the same.
</p>
<p>For <code>plot.steady1D</code>, the arguments after ... must be matched exactly.     
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of panels per page is automatically determined up to 3 x 3
(<code>par(mfrow=c(3, 3))</code>). This default can be overwritten by
specifying user-defined settings for <code>mfrow</code> or <code>mfcol</code>.
Set <code>mfrow</code> equal to <code>NULL</code> to avoid the plotting function to 
change user-defined <code>mfrow</code> or <code>mfcol</code> settings
</p>
<p>Other graphical parameters can be passed as well. Parameters
are vectorized, either according to the number of plots 
(<code>xlab, ylab</code>, <code>main, sub</code>, <code>xlim, ylim</code>, <code>log</code>,
<code>asp, ann, axes, frame.plot</code>,<code>panel.first,panel.last</code>,
<code>cex.lab,cex.axis,cex.main</code>) or 
according to the number of lines within one plot (other parameters 
e.g. <code>col</code>, <code>lty</code>, <code>lwd</code> etc.) so it is possible to
assign specific axis labels to individual plots, resp. different plotting 
style. Plotting parameter <code>ylim</code>, or <code>xlim</code> can also be a list 
to assign different axis limits to individual plots.
</p>
<p>Similarly, the graphical parameters for observed data, as passed by 
<code>obspar</code> can be vectorized, according to the number of observed 
data sets.
</p>
<p>For <code>steady3D</code> objects, 2-D images are generated by looping over
one of the axies; by default the third axis. See  <code><a href="#topic+steady.3D">steady.3D</a></code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>, <code><a href="#topic+steady.3D">steady.3D</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
##  EXAMPLE 1: 1D model, BOD + O2                                
## =======================================================================
## Biochemical Oxygen Demand (BOD) and oxygen (O2) dynamics
## in a river

#==================#
# Model equations  #
#==================#
O2BOD &lt;- function(t, state, pars) {
  BOD &lt;- state[1:N]
  O2  &lt;- state[(N+1):(2*N)]

# BOD dynamics
  FluxBOD &lt;-  v * c(BOD_0, BOD)  # fluxes due to water transport
  FluxO2  &lt;-  v * c(O2_0, O2)
  
  BODrate &lt;- r*BOD*O2/(O2+10)  # 1-st order consumption, Monod in oxygen

#rate of change = flux gradient - consumption  + reaeration (O2)
  dBOD         &lt;- -diff(FluxBOD)/dx  - BODrate
  dO2          &lt;- -diff(FluxO2)/dx   - BODrate + p*(O2sat-O2)

  return(list(c(dBOD = dBOD, dO2 = dO2)))
}    # END O2BOD
 
 
#==================#
# Model application#
#==================#
# parameters
dx      &lt;- 100       # grid size, meters
v       &lt;- 1e2       # velocity, m/day
x       &lt;- seq(dx/2,10000,by=dx)  # m, distance from river
N       &lt;- length(x)
r       &lt;- 0.1       # /day, first-order decay of BOD
p       &lt;- 0.1       # /day, air-sea exchange rate
O2sat   &lt;- 300       # mmol/m3 saturated oxygen conc
O2_0    &lt;- 50        # mmol/m3 riverine oxygen conc
BOD_0   &lt;- 1500      # mmol/m3 riverine BOD concentration

# initial guess:
state &lt;- c(rep(200,N), rep(200,N))

# running the model
out   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                    nspec = 2, pos = TRUE, 
                    names = c("BOD", "O2"))

summary(out)

# output
plot(out, grid = x, type = "l", lwd = 2, 
     ylab = c("mmol/m3", "mmol O2/m3"))

# observations
obs &lt;- matrix (ncol = 2, data = c(seq(0, 10000, 2000),
                                c(1400, 900,400,100,10,10)))

colnames(obs) &lt;- c("Distance", "BOD")

# plot with observations
plot(out, grid = x, type = "l", lwd = 2, ylab = "mmol/m3", obs = obs, 
     pch = 16, cex = 1.5)

# similar but data in "long" format
OUT &lt;- data.frame(name = "BOD", obs)
## Not run: 
plot(out, grid = x, type = "l", lwd = 2, ylab = "mmol/m3", obs = OBS, 
     pch = 16, cex = 1.5)

## End(Not run)

## =======================================================================
##  EXAMPLE 2: 1D model, BOD + O2 - second run                               
## =======================================================================
# new runs with different v
v       &lt;- 50       # velocity, m/day

# running the model a second time
out2   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                     nspec = 2, pos = TRUE, names = c("BOD", "O2"))


v       &lt;- 200       # velocity, m/day

# running the model a second time
out3   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                     nspec = 2, pos = TRUE, names = c("BOD", "O2"))

# output of all three scenarios at once
plot(out, out2, out3, type = "l", lwd = 2, 
     ylab = c("mmol/m3", "mmol O2/m3"), grid = x,
     obs = obs, which = c("BOD", "O2"))
  
# output of all three scenarios at once, and using vertical style
plot(out, out2, out3, type = "l", lwd = 2, vertical = TRUE,
     ylab = "Distance [m]",
     main = c("BOD [mmol/m3]", "O2 [mmol O2/m3]"), grid = x,
     obs = obs, which = c("BOD", "O2"))

# change plot pars
plot(out, out2, out3, type = "l", lwd = 2, 
     ylab = c("mmol/m3", "mmol O2/m3"), 
     grid = x, col = c("blue", "green"), log = "y",  
     obs = obs, obspar = list(pch = 16, col = "red", cex = 2))

## =======================================================================
## EXAMPLE 3: Diffusion in 2-D; zero-gradient boundary conditions
## =======================================================================

diffusion2D &lt;- function(t,Y,par)  {
   y    &lt;- matrix(nr=n,nc=n,data=Y)  # vector to 2-D matrix
   dY   &lt;- -r*y        # consumption
   BND   &lt;- rep(1,n)   # boundary concentration 

   #diffusion in X-direction; boundaries=imposed concentration
   Flux &lt;- -Dx * rbind(y[1,]-BND, (y[2:n,]-y[1:(n-1),]), BND-y[n,])/dx
   dY   &lt;- dY - (Flux[2:(n+1),]-Flux[1:n,])/dx

   #diffusion in Y-direction
   Flux &lt;- -Dy * cbind(y[,1]-BND, (y[,2:n]-y[,1:(n-1)]), BND-y[,n])/dy
   dY    &lt;- dY - (Flux[ ,2:(n+1)]-Flux[ ,1:n])/dy
                                              
   return(list(as.vector(dY)))
}

  # parameters
dy    &lt;- dx &lt;- 1   # grid size
Dy    &lt;- Dx &lt;- 1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.025     # consumption rate

n  &lt;- 100
Y  &lt;- matrix(nrow = n, ncol = n, 10.)

ST &lt;- steady.2D(Y, func = diffusion2D, parms = NULL, pos = TRUE,
                dimens = c(n, n), lrw = 1000000,
                atol = 1e-10, rtol = 1e-10, ctol = 1e-10)
grid &lt;- list(x = seq(dx/2, by = dx, length.out = n), 
             y = seq(dy/2, by = dy, length.out = n))
image(ST, grid = grid)
summary(ST)
</code></pre>

<hr>
<h2 id='rootSolve-package'>
Roots and steady-states
</h2><span id='topic+rootSolve-package'></span><span id='topic+rootSolve'></span>

<h3>Description</h3>

<p>Functions that:
</p>
<p>(1) generate gradient and Jacobian matrices (full and banded),
</p>
<p>(2) find roots of non-linear equations by the Newton-Raphson method,
</p>
<p>(3) estimate steady-state conditions of a system of (differential) equations
in full, banded or sparse form, using the Newton-Raphson method or by
a dynamic run,
</p>
<p>(4) solve the steady-state conditions for uni-and multicomponent 1-D, 2-D
and 3-D partial differential equations, that have been converted to ODEs
by numerical differencing (using the
method-of-lines approach).
</p>


<h3>Details</h3>

<p>rootSolve was created to solve the examples from chapter 7 (stability and
steady-state) from the book of Soetaert and Herman, 2009.
</p>
<p>Please cite this work when using rootSolve.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert
</p>


<h3>References</h3>

<p>Soetaert, K and Herman, PMJ, 2009. A Practical Guide to Ecological Modelling.
Using <span class="rlang"><b>R</b></span> as a Simulation Platform. Springer, 372pp, ISBN 978-1-4020-8623-6.
</p>
<p>Soetaert K., 2009. rootSolve: Nonlinear root finding, equilibrium and 
steady-state analysis of ordinary differential equations.
R-package version 1.6
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uniroot.all">uniroot.all</a></code>, to solve for all roots of one (nonlinear) equation
</p>
<p><code><a href="#topic+multiroot">multiroot</a></code>, to solve n roots of n (nonlinear) equations
</p>
<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>
<p><code><a href="#topic+jacobian.full">jacobian.full</a></code>, <code><a href="#topic+jacobian.band">jacobian.band</a></code>, estimates the
Jacobian matrix assuming a full or banded structure.
</p>
<p><code><a href="#topic+gradient">gradient</a></code>, <code><a href="#topic+hessian">hessian</a></code>, estimates the gradient
matrix or the Hessian.
</p>
<p><code><a href="#topic+plot.steady1D">plot.steady1D</a></code>, ...  for plotting  steady-state solutions.
</p>
<p>package vignette <code>rootSolve</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## run demos
demo("Jacobandroots")
demo("Steadystate")

## open the directory with documents
browseURL(paste(system.file(package="rootSolve"), "/doc", sep=""))

## main package vignette
vignette("rootSolve")

## End(Not run)
</code></pre>

<hr>
<h2 id='runsteady'>
Dynamically runs a system of ordinary differential equations (ODE) to
steady-state
</h2><span id='topic+runsteady'></span>

<h3>Description</h3>

<p>Solves the steady-state condition of ordinary differential equations (ODE)
in the form:
</p>
<p style="text-align: center;"><code class="reqn">dy/dt = f(t,y)</code>
</p>
  
<p>by dynamically running till the summed absolute values of the derivatives
become smaller than some predefined tolerance.
</p>
<p>The <span class="rlang"><b>R</b></span> function <code>runsteady</code> makes use of the FORTRAN ODE solver DLSODE,
written by Alan C. Hindmarsh and Andrew H. Sherman
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or defined in
compiled code that has been dynamically loaded. The user has to specify
whether or not the problem is stiff and choose the appropriate solution
method (e.g. make choices about the type of the Jacobian).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runsteady(y, time = c(0, Inf), func, parms, 
          stol = 1e-8, rtol = 1e-6, atol = 1e-6,  
          jacfunc = NULL, jactype = "fullint", mf = NULL, 
          verbose = FALSE, tcrit = NULL, hmin = 0, hmax = NULL, 
          hini = 0, ynames = TRUE, maxord = NULL, bandup = NULL, 
          banddown = NULL, maxsteps = 100000, dllname = NULL, 
          initfunc = dllname, initpar = parms, rpar = NULL, 
          ipar = NULL, nout = 0, outnames = NULL, 
          forcings = NULL, initforc = NULL, fcontrol = NULL, 
          lrw = NULL, liw = NULL, times = time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runsteady_+3A_y">y</code></td>
<td>
<p>the initial (state) values for the ODE system. If <code>y</code> has a
name attribute, the names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_time">time</code>, <code id="runsteady_+3A_times">times</code></td>
<td>
<p>The simulation time. This should be a 2-valued vector,
consisting of the initial time and the end time.
The last time value should be large enough to make sure that steady-state
is effectively reached in this period.
The simulation will stop either when <code>times[2]</code> has been reached or
when <code>maxsteps</code> have been performed.
(note: since version 1.7, argument time has been added, for consistency with other solvers.)
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ODE system (the <em>model definition</em>) at time
t, or a character string giving the name of a compiled function
in a dynamically loaded shared library.
</p>
<p>If <code>func</code>  is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>.  <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values that are required at
each point in <code>times</code>.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_parms">parms</code></td>
<td>
<p>vector or list of parameters used in <code>func</code> or
<code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_stol">stol</code></td>
<td>
<p>steady-state tolerance; it is assumed that steady-state is
reached if the average of absolute values of the derivatives
drops below this number.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance of integrator, either a scalar or an
array as long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance of integrator, either a scalar or an
array as long as <code>y</code>.  See details.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, an <span class="rlang"><b>R</b></span> function that computes
the jacobian of the system of differential equations
dydot(i)/dy(j), or a string giving the name of a function or
subroutine in &lsquo;<span class="file">dllname</span>&rsquo; that computes the jacobian (see Details
below for more about this option).  In some circumstances, supplying
<code>jacfunc</code> can speed up the computations, if the system is stiff.
The <span class="rlang"><b>R</b></span> calling sequence for <code>jacfunc</code> is identical
to that of <code>func</code>.
</p>
<p>If the jacobian is a full matrix, <code>jacfunc</code> should return a matrix
dydot/dy, where the ith row contains the derivative of <code class="reqn">dy_i/dt</code> with
respect to <code class="reqn">y_j</code>, or a vector containing the matrix elements by
columns (the way <span class="rlang"><b>R</b></span> and Fortran store matrices).
</p>
<p>If the jacobian is banded, <code>jacfunc</code> should return a matrix containing
only the nonzero bands of the jacobian, rotated row-wise. See first example
of <code>lsode</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the jacobian, 
one of &quot;fullint&quot;, &quot;fullusr&quot;, &quot;bandusr&quot;, &quot;bandint&quot;, &quot;sparse&quot; - either full,
banded or sparse and estimated internally or by user; overruled if <code>mf</code>
is not NULL.   If &quot;sparse&quot; then method lsodes is used, else lsode.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_mf">mf</code></td>
<td>
<p>the &quot;method flag&quot; passed to function lsode - overrules
<code>jactype</code> - provides more options than <code>jactype</code> - see details.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will output
the settings of vectors *istate* and *rstate* - see details.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_tcrit">tcrit</code></td>
<td>
<p>if not <code>NULL</code>, then <code>lsode</code> cannot integrate past
<code>tcrit</code>. The Fortran routine <code>lsode</code> overshoots its targets
(times points in the vector <code>times</code>), and interpolates values
for the desired time points.  If there is a time beyond which integration
should not proceed (perhaps because of a singularity),
that should be provided in <code>tcrit</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_hmin">hmin</code></td>
<td>
<p>an optional minimum value of the integration
stepsize. In special situations this parameter may speed up computations
with the cost of precision. Don't use <code>hmin</code> if you don't know why!
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_hmax">hmax</code></td>
<td>
<p>an optional maximum value of the integration stepsize. If not
specified, <code>hmax</code> is set to the largest difference in <code>times</code>,
to avoid that the simulation possibly ignores short-term events. If 0,
no maximal size is specified.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_hini">hini</code></td>
<td>
<p>initial step size to be attempted; if 0, the initial step size
is determined by the solver.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_ynames">ynames</code></td>
<td>
<p>if <code>FALSE</code>: names of state variables are not passed to
function <code>func</code> ; this may speed up the simulation.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_maxord">maxord</code></td>
<td>
<p>the maximum order to be allowed. <code>NULL</code> uses the default,
i.e. order 12 if implicit Adams method (meth=1), order 5 if BDF method
(meth=2) or if <code>jacType</code> == 'sparse'. Reduce maxord to save storage space.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case the
jacobian is banded.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case the
jacobian is banded.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps. The simulation will stop either
when <code>maxsteps</code> have been performed or when <code>times[2]</code> has been
reached.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library (without
extension) that contains all the compiled function or subroutine
definitions refered to in <code>func</code> and <code>jacfunc</code>. See package
vignette.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_initfunc">initfunc</code></td>
<td>
<p>if not NULL, the name of the initialisation function (which
initialises values of parameters), as provided in &lsquo;<span class="file">dllname</span>&rsquo;. See
package vignette.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an initialisation
function <code>initfunc</code> is in the dll: the parameters passed to the
initialiser, to initialise the common blocks (fortran) or global variables
(C, C++).
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with double
precision values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with integer
values passed to the dll-functions whose names are specified by <code>func</code>
and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_nout">nout</code></td>
<td>
<p>only used if <code>dllname</code> is specified and the model is
defined in compiled code: the number of output variables calculated in
the compiled function <code>func</code>, present in the shared library. Note:
it is not automatically checked whether this is indeed the number of output
variables calculed in the dll - you have to perform this check in the code
- See package vignette of deSolve.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with the 
forcing function values, or a list with the forcing function data sets, 
each present as a two-columned matrix, with (time,value); interpolation 
outside the interval [min(<code>times</code>), max(<code>times</code>)] is done by 
taking the value at the closest data extreme.
</p>
<p>This feature is here for compatibility with models defined in compiled code
from package deSolve; see deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_lrw">lrw</code></td>
<td>
<p>Only if jactype = 'sparse', the length of the real work array rwork; due to the
sparsicity, this cannot be readily predicted. If <code>NULL</code>, a
guess will be made, and if not sufficient, <code>lsodes</code> will return
with a message indicating the size of rwork actually required.
Therefore, some experimentation may be necessary to estimate the
value of <code>lrw</code>.
</p>
<p>For instance, if you get the error:
</p>
<pre> 
DLSODES- RWORK length is insufficient to proceed.                               
  Length needed is .ge. LENRW (=I1), exceeds LRW (=I2)                    
  In above message,  I1 =     27627   I2 =     25932 
</pre>    
<p>set <code>lrw</code> equal to 27627 or a higher value
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_liw">liw</code></td>
<td>
<p>Only if jactype = 'sparse', the length of the integer work array iwork; due to the
sparsicity, this cannot be readily predicted. If <code>NULL</code>, a guess will
be made, and if not sufficient, <code>lsodes</code> will return with a
message indicating the size of iwork actually required.  Therefore,
some experimentation may be necessary to estimate the value of
<code>liw</code>.
</p>
</td></tr>
<tr><td><code id="runsteady_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and <code>jacfunc</code>
allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by the Fortran subroutine <code>dlsode</code> or <code>dlsodes</code> (if sparse),
whose documentation should be consulted for details (it is included as
comments in the source file &lsquo;<span class="file">src/lsodes.f</span>&rsquo;).  The implementation is
based on the November, 2003 version of lsode, from Netlib.
</p>
<p>Before using <code>runsteady</code>, the user has to decide whether or not the
problem is stiff. 
</p>
<p>If the problem is nonstiff, use method flag <code>mf</code> = 10, which selects
a nonstiff (Adams) method, no Jacobian used..  
</p>
<p>If the problem is stiff, there are four standard choices
which can be specified with <code>jactype</code> or <code>mf</code>.
</p>
<p>The options for <b>jactype</b> are
</p>

<ul>
<li><p> jactype = &quot;fullint&quot; : a full jacobian, calculated internally by
<code>lsode</code>, corresponds to <code>mf</code>=22.
</p>
</li>
<li><p> jactype = &quot;fullusr&quot; : a full jacobian, specified by user function
<code>jacfunc</code>, corresponds to <code>mf</code>=21.
</p>
</li>
<li><p> jactype = &quot;bandusr&quot; : a banded jacobian, specified by user function
<code>jacfunc</code>; the size of the bands specified by <code>bandup</code> and
<code>banddown</code>, corresponds to <code>mf</code>=24.
</p>
</li>
<li><p> jactype = &quot;bandint&quot; : a banded jacobian, calculated by <code>lsode</code>;
the size of the bands specified by <code>bandup</code> and <code>banddown</code>,
corresponds to <code>mf</code>=25.
</p>
</li>
<li><p> jactype = &quot;sparse&quot; : the soler <code>lsodes</code> is used, and the sparse jacobian is 
calculated by <code>lsodes</code> - not possible to specify <code>jacfunc</code>.
</p>
</li></ul>

<p>More options are available when specifying <b>mf</b> directly. 
</p>
<p>The legal values of <code>mf</code> are 10, 11, 12, 13, 14, 15, 20, 21, 22, 23,
24, 25.
</p>
<p><code>mf</code> is a positive two-digit integer, <code>mf</code> = (10*METH + MITER),
where
</p>

<ul>
<li><p> METH indicates the basic linear multistep method: METH = 1 means
the implicit Adams method. METH = 2 means the method based on backward
differentiation formulas (BDF-s).
</p>
</li>
<li><p> MITER indicates the corrector iteration method: MITER = 0 means
functional iteration (no Jacobian matrix is involved).
MITER = 1 means chord iteration with a user-supplied full (NEQ by NEQ)
Jacobian.
MITER = 2 means chord iteration with an internally generated
(difference quotient) full Jacobian
(using NEQ extra calls to <code>func</code> per df/dy value).
MITER = 3 means chord iteration with an internally generated diagonal
Jacobian approximation
(using 1 extra call to <code>func</code> per df/dy evaluation).
MITER = 4 means chord iteration with a user-supplied banded Jacobian.
MITER = 5 means chord iteration with an internally generated banded
Jacobian (using ML+MU+1 extra calls to <code>func</code> per df/dy evaluation).
</p>
<p>If MITER = 1 or 4, the user must supply a subroutine <code>jacfunc</code>.
</p>
</li></ul>

<p>Inspection of the example below shows how to specify both a banded and full
jacobian. 
</p>
<p>The input parameters <code>rtol</code>, and <code>atol</code> determine the <b>error
control</b> performed by the solver. 
</p>
<p>See <code><a href="#topic+stode">stode</a></code> for details.
</p>
<p><b>Models</b> may be defined in compiled C or Fortran code, as well as in
an R-function. See function <code><a href="#topic+stode">stode</a></code> for details.
</p>
<p>The output will have the <b>attributes *istate*, and *rstate*</b>, two
vectors with several useful elements. 
</p>
<p>if <code>verbose</code> = TRUE, the settings of istate and rstate will be written
to the screen.
</p>
<p>the following elements of <b>istate</b> are meaningful:
</p>

<ul>
<li><p> el 1 : gives the conditions under which the last call to the
integrator returned.
2  if lsode was successful, -1 if excess work done, -2 means excess
accuracy requested. (Tolerances too small),
-3 means illegal input detected. (See printed message.),
-4 means repeated error test failures. (Check all input),
-5 means repeated convergence failures. (Perhaps bad Jacobian
supplied or wrong choice of MF or tolerances.),
-6 means error weight became zero during problem. (Solution
component i vanished, and atol or atol(i) = 0.)
</p>
</li>
<li><p> el 12 : The number of steps taken for the problem so far.
</p>
</li>
<li><p> el 13 : The number of evaluations for the problem so far.,
</p>
</li>
<li><p> el 14 : The number of Jacobian evaluations  and LU decompositions
so far.,
</p>
</li>
<li><p> el 15 : The method order last used (successfully).,
</p>
</li>
<li><p> el 16 : The order to be attempted on the next step.,
</p>
</li>
<li><p> el 17 : if el 1 =-4,-5: the largest component in the error vector,
</p>
</li></ul>

<p><b>rstate</b> contains the following:
</p>

<ul>
<li><p> 1: The step size in t last used (successfully).
</p>
</li>
<li><p> 2: The step size to be attempted on the next step.
</p>
</li>
<li><p> 3: The current value of the independent variable which the solver
has actually reached, i.e. the current internal mesh point in t.
</p>
</li>
<li><p> 4: A tolerance scale factor, greater than 1.0, computed when a
request for too much accuracy was detected.
</p>
</li></ul>

<p>For more information, see the comments in the original code lsode.f</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output
values.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached, the attribute <code>precis</code> with the
precision attained at the last iteration estimated as the mean absolute
rate of change (sum(abs(dy))/n), the attribute <code>time</code> with the
simulation time reached and the attribute <code>steps</code> with the number of
steps performed.
</p>
<p>The output will also have the attributes <code>istate</code>, and <code>rstate</code>,
two vectors with several useful elements of the dynamic simulation.
See details.
The first element of istate returns the conditions under which the last call
to the integrator returned. Normal is <code>istate[1] = 2</code>.
If <code>verbose</code> = <code>TRUE</code>, the settings of istate and rstate will
be written to the screen.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;</p>


<h3>References</h3>

<p> Alan C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE
Solvers,&quot; in Scientific Computing, R. S. Stepleman, et al., Eds.
(North-Holland, Amsterdam, 1983), pp. 55-64.
</p>
<p>S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman, Yale
Sparse Matrix Package: I. The Symmetric Codes,
Int. J. Num. Meth. Eng., 18 (1982), pp. 1145-1151.
</p>
<p>S. C. Eisenstat, M. C. Gursky, M. H. Schultz, and A. H. Sherman, Yale
Sparse Matrix Package: II. The Nonsymmetric Codes, Research Report
No. 114, Dept. of Computer Sciences, Yale University, 1977.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code> steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## A simple sediment biogeochemical model
## =======================================================================

model&lt;-function(t, y, pars) {

with (as.list(c(y, pars)),{

  Min       = r*OM
  oxicmin   = Min*(O2/(O2+ks))
  anoxicmin = Min*(1-O2/(O2+ks))* SO4/(SO4+ks2)

  dOM  = Flux - oxicmin - anoxicmin
  dO2  = -oxicmin      -2*rox*HS*(O2/(O2+ks)) + D*(BO2-O2)
  dSO4 = -0.5*anoxicmin  +rox*HS*(O2/(O2+ks)) + D*(BSO4-SO4)
  dHS  = 0.5*anoxicmin   -rox*HS*(O2/(O2+ks)) + D*(BHS-HS)

  list(c(dOM, dO2, dSO4, dHS), SumS = SO4+HS)
})
}

# parameter values
pars &lt;- c(D = 1, Flux = 100, r = 0.1, rox = 1,
          ks = 1, ks2 = 1, BO2 = 100, BSO4 = 10000, BHS = 0)
# initial conditions
y &lt;- c(OM = 1, O2 = 1, SO4 = 1, HS = 1)

# direct iteration
print( system.time(
  ST &lt;- stode(y = y, func = model, parms = pars, pos = TRUE)
))

print( system.time(
  ST2 &lt;- runsteady(y = y, func = model, parms = pars, times = c(0, 1000))
))

print( system.time(
  ST3 &lt;- runsteady(y = y, func = model, parms = pars, times = c(0, 1000), 
    jactype = "sparse")
))

rbind("Newton Raphson" = ST$y, "Runsteady" = ST2$y, "Run sparse" = ST3$y)
</code></pre>

<hr>
<h2 id='steady'>
General steady-state solver for a set of ordinary differential equations.
</h2><span id='topic+steady'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations.
</p>
<p>This is a wrapper around steady-state solvers <code>stode</code>, <code>stodes</code>
and <code>runsteady</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steady(y, time = NULL, func, parms = NULL, method = "stode", times = time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steady_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
If <code>y</code> has a name attribute, the names will be used to label the output matrix.
</p>
</td></tr>
<tr><td><code id="steady_+3A_time">time</code>, <code id="steady_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; 
the default is <code>times=0</code> (for <code>method = "stode"</code> or 
<code>method = "stodes"</code>, and <code>times = c(0,Inf)</code> for 
<code>method = "runsteady"</code>.   
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="steady_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
If <code>func</code>  is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="steady_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="steady_+3A_method">method</code></td>
<td>
<p>the solution method to use, one of <code>stode</code>, <code>stodes</code>
or <code>runsteady</code>.
</p>
</td></tr>
<tr><td><code id="steady_+3A_...">...</code></td>
<td>
<p>additional arguments passed to function <code>stode</code>,
<code>stodes</code> or <code>runsteady</code>. See examples for the use of argument <code>positive</code> to enforce positive values (positive = TRUE).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a wrapper around the various steady-state solvers.
</p>
<p>See package vignette for information about specifying the
model in compiled code.
</p>
<p>See the selected solver for the additional options.
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output values. </p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute
<code>precis</code> with the precision attained during each iteration.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
##  Bacteria (Bac) growing on a substrate (Sub)
## =======================================================================
  
model &lt;- function(t, state, pars) {
  with (as.list(c(state,pars)), {
  #       substrate uptake             death  respiration
  dBact = gmax*eff*Sub/(Sub+ks)*Bact - dB*Bact - rB*Bact
  dSub  =-gmax    *Sub/(Sub+ks)*Bact + dB*Bact          +input
  
  return(list(c(dBact, dSub)))
                                })
}
  
pars &lt;- list(gmax = 0.5,eff = 0.5,
             ks = 0.5, rB = 0.01, dB = 0.01, input = 0.1)
# Newton-Raphson. pos = TRUE ensures only positive values are generated.
steady(y = c(Bact = 0.1, Sub = 0), time = 0,
       func = model, parms = pars, pos = TRUE)  

  # Dynamic run to steady-state
as.data.frame(steady(y = c(Bact = 0.1, Sub = 0), time = c(0, 1e5),
                     func = model, parms = pars, method = "runsteady"))

</code></pre>

<hr>
<h2 id='steady.1D'>
Steady-state solver for multicomponent 1-D ordinary differential equations
</h2><span id='topic+steady.1D'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations that result from 1-Dimensional partial differential equation
models that have been converted to ODEs by numerical differencing.
</p>
<p>It is assumed that exchange occurs only between adjacent layers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>steady.1D(y, time = NULL, func, parms = NULL, 
          nspec = NULL, dimens = NULL, 
          names = NULL, method = "stode", jactype = NULL, 
          cyclicBnd = NULL, bandwidth = 1, times = time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steady.1D_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_time">time</code>, <code id="steady.1D_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; 
the default is <code>times=0</code> (for <code>method = "stode"</code> or 
<code>method = "stodes"</code>, and <code>times = c(0,Inf)</code> for 
<code>method = "runsteady"</code> ).
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
</p>
<p>If <code>func</code>  is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_nspec">nspec</code></td>
<td>
<p>the number of *species* (components) in the model.
If <code>NULL</code>, then <code>dimens</code> should be specified.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_dimens">dimens</code></td>
<td>
<p>the number of *boxes* in the model. If NULL, then
<code>nspec</code> should be specified.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_names">names</code></td>
<td>
<p>the names of the components; used to label the output, which
will be written as a matrix.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_method">method</code></td>
<td>
<p>the solution method, one of &quot;stode&quot;, &quot;stodes&quot;, or &quot;runsteady&quot;.
When <code>method</code> = 'runsteady', then solver <code>lsode</code> is used by default, 
unless argument <code>jactype</code> is set to <code>"sparse"</code>, 
in which case <code>lsodes</code> is used and the structure of the jacobian is determined by the solver.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_jactype">jactype</code></td>
<td>
<p>the jacobian type - default is a regular 1-D structure where layers only interact with adjacent layers. 
If the structure does not comply with this, the jacobian can be set equal to <code>'sparse'</code> if <code>method = stodes</code>.
If <code>jactype = 'sparse'</code> and <code>method = runsteady</code> then <code>lsodes</code>, the sparse integrator, will be used.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>if a cyclic boundary exists, a value of <code>1</code> else
<code>NULL</code>; see details.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the number of adjacent boxes over which transport occurs.
Normally equal to 1 (box i only interacts with box i-1, and i+1). 
Values larger than 1 will not work with <code>method = "stodes"</code>.
</p>
</td></tr>
<tr><td><code id="steady.1D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the solver function as defined
by <code>method</code>. See example for the use of argument <code>positive</code> to enforce positive values (pos = TRUE).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for multi-species 1-dimensional models, that
are only subjected to transport between adjacent layers
</p>
<p>More specifically, this method is to be used if the state variables are
arranged per species:
</p>
<p>A[1],A[2],A[3],....B[1],B[2],B[3],.... (for species A, B))
</p>
<p>Two methods are implemented.
</p>

<ul>
<li><p> The default method rearranges the state variables as
A[1],B[1],...A[2],B[2],...A[3],B[3],.... This reformulation leads to
a banded Jacobian with (upper and lower) half bandwidth = number of species.
Then function <code>stode</code> solves the banded problem.
</p>
</li>
<li><p> The second method uses function <code>stodes</code>. Based on the
dimension of the problem, the method first calculates the sparsity pattern
of the Jacobian, under the assumption that transport is only occurring
between adjacent layers. Then <code>stodes</code> is called to solve the problem.
</p>
<p>As <code>stodes</code> is used to estimate steady-state, it may be necessary to
specify the length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it is possible that
this will be too low.
In this case, <code>steady.1D</code> will return with an error message telling
the size of the work array actually needed. In the second try then,
set <code>lrw</code> equal to this number.
</p>
</li></ul>

<p>For single-species 1-D models, use <code><a href="#topic+steady.band">steady.band</a></code>. 
</p>
<p>If state variables are arranged as (e.g. A[1],B[1],A[2],B[2],A[3],B[3],...
then the model should be solved with  <code><a href="#topic+steady.band">steady.band</a></code>
</p>
<p>In some cases, a cyclic boundary condition exists. This is when the first
box interacts with the last box and vice versa. In this case, there
will be extra non-zero fringes in the Jacobian which need to be taken
into account. The occurrence of cyclic boundaries can be
toggled on by specifying argument <code>cyclicBnd=1</code>. If this is the
case, then the steady-state will be estimated using <code>stodes</code>.
The default is no cyclic boundaries.
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> if <code>names</code> is not given: a vector with the state variable
values from the last iteration during estimation of steady-state condition
of the system of equations.
if <code>names</code> is given, a matrix with one column for every steady-state
*component*.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns TRUE, if
steady-state has been reached and the attribute
<code>precis</code> with the precision attained during each iteration.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify BOTH <code>nspec</code> and
<code>dimens</code>.
In this case, the solver can check whether the input makes sense
(i.e. if  nspec*dimens = length(y))
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.steady1D">plot.steady1D</a></code> for plotting the output of steady.1D
</p>
<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers for 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
##  EXAMPLE 1: BOD + O2                                
## =======================================================================
## Biochemical Oxygen Demand (BOD) and oxygen (O2) dynamics
## in a river

#==================#
# Model equations  #
#==================#
O2BOD &lt;- function(t, state, pars) {

  BOD &lt;- state[1:N]
  O2  &lt;- state[(N+1):(2*N)]

# BOD dynamics
  FluxBOD &lt;-  v * c(BOD_0, BOD)  # fluxes due to water transport
  FluxO2  &lt;-  v * c(O2_0, O2)
  
  BODrate &lt;- r*BOD*O2/(O2+10)  # 1-st order consumption, Monod in oxygen

#rate of change = flux gradient - consumption  + reaeration (O2)
  dBOD         &lt;- -diff(FluxBOD)/dx  - BODrate
  dO2          &lt;- -diff(FluxO2)/dx   - BODrate + p*(O2sat-O2)

  return(list(c(dBOD = dBOD, dO2 = dO2), BODrate = BODrate))

}    # END O2BOD
 
 
#==================#
# Model application#
#==================#
# parameters
dx      &lt;- 100       # grid size, meters
v       &lt;- 1e2       # velocity, m/day
x       &lt;- seq(dx/2, 10000, by = dx)  # m, distance from river
N       &lt;- length(x)
r       &lt;- 0.1       # /day, first-order decay of BOD
p       &lt;- 0.1       # /day, air-sea exchange rate
O2sat   &lt;- 300       # mmol/m3 saturated oxygen conc
O2_0    &lt;- 50        # mmol/m3 riverine oxygen conc
BOD_0   &lt;- 1500      # mmol/m3 riverine BOD concentration

# initial guess:
state &lt;- c(rep(200, N), rep(200, N))

# solving the model - note: pos=TRUE only allows positive concentrations
print(system.time(
 out   &lt;- steady.1D (y = state, func = O2BOD, parms = NULL,
                     nspec = 2, pos = TRUE, names = c("BOD", "O2"))))

#==================#
# Plotting output  #
#==================#
mf &lt;- par(mfrow = c(2, 2))
plot(x, out$y[ ,"O2"], xlab =  "Distance from river",
     ylab = "mmol/m3", main = "Oxygen", type = "l")

plot(x, out$y[ ,"BOD"], xlab = "Distance from river",
     ylab = "mmol/m3", main = "BOD", type = "l")

plot(x, out$BODrate, xlab = "Distance from river",
     ylab = "mmol/m3/d", main = "BOD decay rate", type = "l")
par(mfrow=mf)

# same plot in one command
plot(out, which = c("O2","BOD","BODrate"),xlab = "Distance from river",
     ylab = c("mmol/m3","mmol/m3","mmol/m3/d"), 
     main = c("Oxygen","BOD","BOD decay rate"), type = "l")

# same, but now running dynamically to steady-state - no need to set pos = TRUE
print(system.time(
out2 &lt;- steady.1D (y = state, func = O2BOD, parms = NULL, nspec = 2,
                   time = c(0, 1000), method = "runsteady", 
                   names = c("BOD", "O2"))))
                    
# plot all state variables at once, against "x":
plot(out2, grid=x, xlab = "Distance from river",
     ylab = "mmol/m3", type = "l", lwd = 2)
                         
plot(out, out2, grid=x, xlab = "Distance from river", which = "BODrate",
     ylab = "mmol/m3", type = "l", lwd = 2)

## =======================================================================
##   EXAMPLE 2: Silicate diagenesis                      
## =======================================================================
## Example from the book:
## Soetaert and Herman (2009).
## a practical guide to ecological modelling -
## using R as a simulation platform.
## Springer

#====================#
# Model equations    #
#====================#

SiDIAmodel &lt;- function (time = 0,    # time, not used here
                        Conc,        # concentrations: BSi, DSi
                        parms = NULL) # parameter values; not used
{
 BSi&lt;- Conc[1:N]
 DSi&lt;- Conc[(N+1):(2*N)]

# transport           
# diffusive fluxes at upper interface of each layer

# upper concentration imposed (bwDSi), lower: zero gradient
 DSiFlux &lt;- -SedDisp *   IntPor *diff(c(bwDSi ,DSi,DSi[N]))/thick    
 BSiFlux &lt;- -Db      *(1-IntPor)*diff(c(BSi[1],BSi,BSi[N]))/thick 

 BSiFlux[1] &lt;- BSidepo                # upper boundary flux is imposed

# BSi dissolution     
 Dissolution &lt;- rDissSi * BSi*(1.- DSi/EquilSi )^pow 
 Dissolution &lt;- pmax(0,Dissolution)

# Rate of change= Flux gradient, corrected for porosity + dissolution
 dDSi     &lt;- -diff(DSiFlux)/thick/Porosity      +    # transport
              Dissolution * (1-Porosity)/Porosity    # biogeochemistry

 dBSi     &lt;- -diff(BSiFlux)/thick/(1-Porosity)  - Dissolution				

 return(list(c(dBSi, dDSi),           # Rates of changes
        Dissolution = Dissolution,    # Profile of dissolution rates
        DSiSurfFlux = DSiFlux[1],     # DSi sediment-water exchange rate 
        DSIDeepFlux = DSiFlux[N+1],   # DSi deep-water (burial) flux
        BSiDeepFlux = BSiFlux[N+1]))  # BSi deep-water (burial) flux
}

#====================#
# Model run          #
#====================#
# sediment parameters
thick    &lt;- 0.1                       # thickness of sediment layers (cm)
Intdepth &lt;- seq(0, 10, by = thick)    # depth at upper interface of layers
Nint     &lt;- length(Intdepth)          # number of interfaces
Depth    &lt;- 0.5*(Intdepth[-Nint] +Intdepth[-1]) # depth at middle of layers
N        &lt;- length(Depth)                       # number of layers

por0    &lt;- 0.9                         # surface porosity (-)
pordeep &lt;- 0.7                         # deep porosity    (-)
porcoef &lt;- 2                           # porosity decay coefficient  (/cm)
# porosity profile, middle of layers
Porosity &lt;- pordeep + (por0-pordeep)*exp(-Depth*porcoef)    
# porosity profile, upper interface 
IntPor   &lt;- pordeep + (por0-pordeep)*exp(-Intdepth*porcoef)  

dB0      &lt;- 1/365           # cm2/day      - bioturbation coefficient
dBcoeff  &lt;- 2
mixdepth &lt;- 5               # cm
Db       &lt;- pmin(dB0, dB0*exp(-(Intdepth-mixdepth)*dBcoeff))

# biogeochemical parameters
SedDisp  &lt;- 0.4             # diffusion coefficient, cm2/d
rDissSi  &lt;- 0.005           # dissolution rate, /day
EquilSi  &lt;- 800             # equilibrium concentration
pow      &lt;- 1
BSidepo  &lt;- 0.2*100         # nmol/cm2/day
bwDSi    &lt;- 150             # mmol/m3

# initial guess of state variables-just random numbers between 0,1
Conc     &lt;- runif(2*N)

# three runs with different deposition rates                                      
BSidepo  &lt;- 0.2*100          # nmol/cm2/day
sol  &lt;- steady.1D (Conc, func = SiDIAmodel, parms = NULL, nspec = 2, 
                   names = c("DSi", "BSi"))

BSidepo  &lt;- 2*100          # nmol/cm2/day
sol2 &lt;- steady.1D (Conc, func = SiDIAmodel, parms = NULL, nspec = 2, 
                   names = c("DSi", "BSi"))

BSidepo  &lt;- 3*100          # nmol/cm2/day
sol3 &lt;- steady.1D (Conc, func = SiDIAmodel, parms = NULL, nspec = 2, 
                   names = c("DSi", "BSi"))

#====================#
# plotting output    #
#====================#
par(mfrow=c(2,2))

# Plot 3 runs 
plot(sol, sol2, sol3, xyswap = TRUE, mfrow = c(2, 2),
     xlab = c("mmolSi/m3 liquid", "mmolSi/m3 solid"), 
     ylab = "Depth", lwd = 2, lty = 1)
legend("bottom", c("0.2", "2", "3"), title = "mmol/m2/d",
       lwd = 2, col = 1:3)
plot(Porosity, Depth, ylim = c(10, 0), xlab = "-" ,
     main = "Porosity",    type = "l", lwd = 2)
plot(Db, Intdepth, ylim = c(10, 0), xlab = "cm2/d",
     main = "Bioturbation", type = "l", lwd = 2)
mtext(outer = TRUE, side = 3, line = -2, cex = 1.5, "SiDIAmodel")

# similar, but shorter
plot(sol, sol2, sol3, vertical =TRUE,
     lwd = 2, lty = 1,
     main = c("DSi [mmol/m3 liq]","BSi [mmol/m3 sol]"),
     ylab= "depth [cm]")
legend("bottom", c("0.2", "2", "3"), title = "mmol/m2/d",
       lwd = 2, col = 1:3)


</code></pre>

<hr>
<h2 id='steady.2D'>
Steady-state solver for 2-Dimensional ordinary differential equations
</h2><span id='topic+steady.2D'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations that result from 2-Dimensional partial differential equation
models that have been converted to ODEs by numerical differencing.
</p>
<p>It is assumed that exchange occurs only between adjacent layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steady.2D(y, time = 0, func, parms = NULL, nspec = NULL, 
          dimens, names = NULL, method = "stodes", 
          jactype = NULL, cyclicBnd = NULL, times = time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steady.2D_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_time">time</code>, <code id="steady.2D_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; 
the default is <code>times=0</code> (for <code>method = "stodes"</code>, 
and <code>times = c(0,Inf)</code> for <code>method = "runsteady"</code>).
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
If <code>func</code>  is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_nspec">nspec</code></td>
<td>
<p>the number of *species* (components) in the model.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_dimens">dimens</code></td>
<td>
<p>a 2-valued vector with the dimensionality of the model,
i.e. the number of *boxes* in x- and y-direction.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_method">method</code></td>
<td>
<p>the solution method, one of &quot;stodes&quot;, or &quot;runsteady&quot;.
When <code>method</code> = 'runsteady', then solver <code>lsodes</code>, the sparse solver is used by default, 
unless argument <code>jactype</code> is set to <code>"2D"</code>, in which case <code>lsode</code> will be used (likely less efficient).
in which case <code>lsodes</code> is used and the structure of the jacobian is determined by the solver.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_jactype">jactype</code></td>
<td>
<p>the jacobian type - default is a regular 2-D structure where layers only interact with adjacent layers in both directions. 
If the structure does not comply with this, the jacobian can be set equal to <code>'sparse'</code>.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>if not <code>NULL</code> then a number or a 2-valued vector
with the dimensions where a cyclic boundary is used - <code>1</code>: x-dimension,
<code>2</code>: y-dimension; see details.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_names">names</code></td>
<td>
<p>the names of the components; used to label the output, 
and for plotting.
</p>
</td></tr>
<tr><td><code id="steady.2D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to function <a href="#topic+stodes">stodes</a>. 
See example for the use of argument <code>positive</code> to enforce positive values (pos = TRUE).
See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for 2-dimensional models, that are only
subjected to transport between adjacent layers.
</p>
<p>Based on the dimension of the problem, the method first calculates the
sparsity pattern of the Jacobian, under the assumption 
that transport is only occurring between adjacent layers.
Then <code>stodes</code> is called to find the steady-state.
</p>
<p>In some cases, a cyclic boundary condition exists. This is when the first
boxes in x-or y-direction interact with the last boxes. In this case, there
will be extra non-zero fringes in the Jacobian which need to be taken
into account. The occurrence of cyclic boundaries can be
toggled on by specifying argument <code>cyclicBnd</code>. For innstance,
<code>cyclicBnd = 1</code> indicates that a cyclic boundary is required only for
the x-direction, whereas <code>cyclicBnd = c(1,2)</code> imposes a cyclic boundary
for both x- and y-direction. The default is no cyclic boundaries.
</p>
<p>As <code>stodes</code> is used, it will probably be necessary to specify the
length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it may occur that this
will be too low.
In this case, <code>steady.2D</code> will return with an error message telling
that there was insufficient storage. In the second try then, increase
<code>lrw</code>. you may need to experiment to find suitable value. The smaller the better.
</p>
<p>An error message that says to increase <code>lrw</code> may look like this:
</p>
<pre>   
 In stodes(y = y, time = time, func = func, parms = parms, nnz = c(nspec,  :
  insufficient storage in nnfc
</pre>      
<p>See <code>stodes</code> for the additional options.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the <code>attribute</code> <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute
<code>precis</code> with the precision attained during each iteration.
Another attribute, called <code>dims</code> returns a.o. the length of the work 
array actually required. 
This can be specified with input argument <code>lrw</code>. See note and first example
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify BOTH <code>nspec</code> and
<code>dimens</code>. In this case, the solver can check whether the input makes
sense (as nspec*dimens[1]*dimens[2] = length(y))
</p>
<p>do NOT use this method for problems that are not 2D.
</p>
<p>It is likely that the estimated length of the work array (argument <code>lrw</code>),
required for the solver <a href="#topic+stodes">stodes</a> will be too small. 
If that is the case, the solver will return with an error
saying to increase <code>lrw</code>. The current value of the work array can be 
found via the <code>attributes</code> of the output. See first example.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers for 1-Dand 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Diffusion in 2-D; imposed boundary conditions
## =======================================================================
diffusion2D &lt;- function(t, Y, par)   {

   y    &lt;- matrix(nr=n,nc=n,data=Y)  # vector to 2-D matrix
   dY   &lt;- -r*y        # consumption
   BND   &lt;- rep(1,n)   # boundary concentration 

   #diffusion in X-direction; boundaries=imposed concentration
   Flux &lt;- -Dx * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dx
   dY   &lt;- dY - (Flux[2:(n+1),]-Flux[1:n,])/dx

   #diffusion in Y-direction
   Flux &lt;- -Dy * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dy
   dY    &lt;- dY - (Flux[,2:(n+1)]-Flux[,1:n])/dy

   return(list(as.vector(dY)))
}

# parameters
dy    &lt;- dx &lt;- 1   # grid size
Dy    &lt;- Dx &lt;- 1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.025     # consumption rate

n  &lt;- 100
y  &lt;- matrix(nrow = n, ncol = n, 10.)

# stodes is used, so we should specify the size of the work array (lrw)
# We take a rather large value
# By specifying pos = TRUE, only positive values are allowed.

system.time(
ST2 &lt;- steady.2D(y, func = diffusion2D, parms = NULL, pos = TRUE,
                 dimens = c(n, n), lrw = 1000000, 
                 atol = 1e-10, rtol = 1e-10, ctol = 1e-10)
)

## Not run:   # this takes a long time...
system.time(
ST3 &lt;- steady.2D(y, func = diffusion2D, parms = NULL, 
                 dimens = c(n, n), lrw = 1000000, method = "runsteady", 
                 time = c(0, 1e6), atol = 1e-10, rtol = 1e-10)
)

## End(Not run)

# the actual size of lrw is in the attributes()$dims vector.     
# it is best to set lrw as small as possible 
attributes(ST2)     

image(ST2, legend = TRUE)

# The hard way of plotting:    
#y &lt;- matrix(nr = n, nc = n, data = ST2$y)
#     filled.contour(y, color.palette = terrain.colors)

## =======================================================================
## Diffusion in 2-D; extra flux on 2 boundaries, cyclic in y
## =======================================================================

diffusion2Db &lt;- function(t, Y, par)  {

   y    &lt;- matrix(nr=nx,nc=ny,data=Y)  # vector to 2-D matrix
   dY   &lt;- -r*y        # consumption

   BNDx   &lt;- rep(1,nx)   # boundary concentration
   BNDy   &lt;- rep(1,ny)   # boundary concentration

   #diffusion in X-direction; boundaries=imposed concentration
   Flux &lt;- -Dx * rbind(y[1,]-BNDy,(y[2:nx,]-y[1:(nx-1),]),BNDy-y[nx,])/dx
   dY   &lt;- dY - (Flux[2:(nx+1),]-Flux[1:nx,])/dx

   #diffusion in Y-direction
   Flux &lt;- -Dy * cbind(y[,1]-BNDx,(y[,2:ny]-y[,1:(ny-1)]),BNDx-y[,ny])/dy
   dY    &lt;- dY - (Flux[,2:(ny+1)]-Flux[,1:ny])/dy

   # extra flux on two sides
   dY[,1] &lt;- dY[,1]+  10
   dY[1,] &lt;- dY[1,]+  10

   # and exchange between sides on y-direction
   dY[,ny] &lt;- dY[,ny]+ (y[,1]-y[,ny])*10

   return(list(as.vector(dY)))
}

# parameters
dy    &lt;- dx &lt;- 1   # grid size
Dy    &lt;- Dx &lt;- 1   # diffusion coeff, X- and Y-direction
r     &lt;- 0.025     # consumption rate

nx  &lt;- 50
ny  &lt;- 100
y  &lt;- matrix(nrow = nx, ncol = ny, 10.)

print(system.time(
  ST2 &lt;- steady.2D(y, func = diffusion2Db, parms = NULL, pos = TRUE,
          dimens = c(nx, ny), verbose = TRUE, lrw = 283800, 
          atol = 1e-10, rtol = 1e-10, ctol = 1e-10, 
          cyclicBnd = 2)       # y-direction: cyclic boundary
))

image(ST2)
#y &lt;- matrix(nrow = nx, ncol = ny, data = ST2$y)
#    filled.contour(y,color.palette=terrain.colors)


</code></pre>

<hr>
<h2 id='steady.3D'>
Steady-state solver for 3-Dimensional ordinary differential equations
</h2><span id='topic+steady.3D'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations that result from 3-Dimensional partial differential equation
models that have been converted to ODEs by numerical differencing.
</p>
<p>It is assumed that exchange occurs only between adjacent layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steady.3D(y, time = 0, func, parms = NULL, nspec = NULL, 
          dimens, names = NULL, method = "stodes", 
          jactype = NULL, cyclicBnd = NULL, times = time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steady.3D_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_time">time</code>, <code id="steady.3D_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; the default is <code>times=0</code>.
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
If <code>func</code>  is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_nspec">nspec</code></td>
<td>
<p>the number of *species* (components) in the model.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_dimens">dimens</code></td>
<td>
<p>a 3-valued vector with the dimensionality of the model,
i.e. the number of *boxes* in x-, y- and z- direction.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_method">method</code></td>
<td>
<p>the solution method, one of &quot;stodes&quot;, or &quot;runsteady&quot;.
When <code>method</code> = 'runsteady', then solver <code>lsodes</code>, the sparse solver is used by default, 
unless argument <code>jactype</code> is set to <code>"2D"</code>, in which case <code>lsode</code> will be used (likely less efficient).
in which case <code>lsodes</code> is used and the structure of the jacobian is determined by the solver.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_jactype">jactype</code></td>
<td>
<p>the jacobian type - default is a regular 2-D structure where layers only interact with adjacent layers in both directions. 
If the structure does not comply with this, the jacobian can be set equal to <code>'sparse'</code>.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_cyclicbnd">cyclicBnd</code></td>
<td>
<p>if not <code>NULL</code> then a number or a 3-valued vector
with the dimensions where a cyclic boundary is used - <code>1</code>: x-dimension,
<code>2</code>: y-dimension; <code>3</code>: z-dimension;see details.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_names">names</code></td>
<td>
<p>the names of the components; used to label the output, 
and for plotting.
</p>
</td></tr>
<tr><td><code id="steady.3D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to function <a href="#topic+stodes">stodes</a>.
See note.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice to find the steady-state for 
3-dimensional models, that are only subjected to transport between 
adjacent layers.
</p>
<p>Based on the dimension of the problem, the method first calculates the
sparsity pattern of the Jacobian, under the assumption 
that transport is only occurring between adjacent layers.
Then <code>stodes</code> is called to find the steady-state.
</p>
<p>In some cases, a cyclic boundary condition exists. This is when the first
boxes in x-, y-, or z-direction interact with the last boxes.
In this case, there will be extra non-zero fringes in the Jacobian which
need to be taken into account. The occurrence of cyclic boundaries can be
toggled on by specifying argument <code>cyclicBnd</code>. For innstance,
<code>cyclicBnd = 1</code> indicates that a cyclic boundary is required only for
the x-direction, whereas <code>cyclicBnd = c(1,2)</code> imposes a cyclic boundary
for both x- and y-direction. The default is no cyclic boundaries.
</p>
<p>As <code>stodes</code> is used, it will probably be necessary to specify the
length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it may occur that this
will be too low.
In this case, <code>steady.3D</code> will return with an error message telling
the size of the work array actually needed. In the second try then, set
<code>lrw</code> equal to this number.
</p>
<p>As <code>stodes</code> is used, it will probably be necessary to specify the
length of the real work array, <code>lrw</code>.
</p>
<p>Although a reasonable guess of <code>lrw</code> is made, it may occur that this
will be too low.
In this case, <code>steady.2D</code> will return with an error message telling
that there was insufficient storage. In the second try then, increase
<code>lrw</code>. you may need to experiment to find suitable value. The smaller the better.
</p>
<p>The error message that says to increase <code>lrw</code> may look like this:
</p>
<pre>   
 In stodes(y = y, time = time, func = func, parms = parms, nnz = c(nspec,  :
  insufficient storage in nnfc
</pre>      
<p>See <code>stodes</code> for the additional options.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute
</p>
<p><code>precis</code> with the precision attained during each iteration.
Another attribute, called <code>dims</code> returns a.o. the length of the work 
array actually required. 
This can be specified with input argument <code>lrw</code>. See note and first example.
</p>


<h3>Note</h3>

<p>It is advisable though not mandatory to specify BOTH <code>nspec</code> and
<code>dimens</code>. In this case, the solver can check whether the input makes
sense (as nspec*dimens[1]*dimens[2]*dimens[3] = length(y))
</p>
<p>do NOT use this method for problems that are not 3D.
</p>
<p>It is likely that the estimated length of the work array (argument <code>lrw</code>),
required for the solver <a href="#topic+stodes">stodes</a> will be too small. 
If that is the case, the solver will return with an error
saying to increase <code>lrw</code>. The current value of the work array can be 
found via the <code>attributes</code> of the output. See first example.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
steady-state solvers for 1-D and 2-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Diffusion in 3-D; imposed boundary conditions
## =======================================================================
diffusion3D &lt;- function(t, Y, par)   {
   yy    &lt;- array(dim=c(n,n,n),data=Y)  # vector to 3-D array
   dY   &lt;- -r*yy        # consumption
   BND   &lt;- rep(1,n)   # boundary concentration
   for (i in 1:n) {
     y &lt;- yy[i,,]
     #diffusion in X-direction; boundaries=imposed concentration
     Flux &lt;- -Dy * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dy
     dY[i,,]   &lt;- dY[i,,] - (Flux[2:(n+1),]-Flux[1:n,])/dy

     #diffusion in Y-direction
     Flux &lt;- -Dz * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dz
     dY[i,,]    &lt;- dY[i,,] - (Flux[,2:(n+1)]-Flux[,1:n])/dz
   }
   for (j in 1:n) {
     y &lt;- yy[,j,]
     #diffusion in X-direction; boundaries=imposed concentration
     Flux &lt;- -Dx * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dx
     dY[,j,]   &lt;- dY[,j,] - (Flux[2:(n+1),]-Flux[1:n,])/dx

     #diffusion in Y-direction
     Flux &lt;- -Dz * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dz
     dY[,j,]    &lt;- dY[,j,] - (Flux[,2:(n+1)]-Flux[,1:n])/dz
   }
   for (k in 1:n) {
     y &lt;- yy[,,k]
     #diffusion in X-direction; boundaries=imposed concentration
     Flux &lt;- -Dx * rbind(y[1,]-BND,(y[2:n,]-y[1:(n-1),]),BND-y[n,])/dx
     dY[,,k]   &lt;- dY[,,k] - (Flux[2:(n+1),]-Flux[1:n,])/dx

     #diffusion in Y-direction
     Flux &lt;- -Dy * cbind(y[,1]-BND,(y[,2:n]-y[,1:(n-1)]),BND-y[,n])/dy
     dY[,,k]    &lt;- dY[,,k] - (Flux[,2:(n+1)]-Flux[,1:n])/dy
   }
   return(list(as.vector(dY)))
}

  # parameters
  dy    &lt;- dx &lt;- dz &lt;-1   # grid size
  Dy    &lt;- Dx &lt;- Dz &lt;-1   # diffusion coeff, X- and Y-direction
  r     &lt;- 0.025     # consumption rate

  n  &lt;- 10
  y  &lt;- array(dim=c(n, n, n), data = 10.)

  # stodes is used, so we should specify the size of the work array (lrw)
  # We take a rather large value initially

  print(system.time(
  ST3 &lt;- steady.3D(y, func =diffusion3D, parms = NULL, pos = TRUE,
                   dimens = c(n, n, n), lrw = 100000,
                   atol = 1e-10, rtol = 1e-10, ctol = 1e-10, 
                   verbose = TRUE)
  ))

  # the actual size of lrw is in the attributes()$dims vector.     
  # it is best to set lrw as small as possible 
  attributes(ST3)     

  # image plot
  y &lt;- array(dim=c(n, n, n), data = ST3$y)
  filled.contour(y[ , ,n/2], color.palette = terrain.colors)
    
  # rootSolve's image plot, looping over 3rd dimension
  image(ST3, mfrow = c(4,3))

  # loop over 1st dimension, contours, legends added
  image(ST3, mfrow = c(2, 2), add.contour = TRUE, legend = TRUE,
        dimselect = list(x = c(1, 4, 8, 10)))

</code></pre>

<hr>
<h2 id='steady.band'>
Steady-state solver for ordinary differential equations; assumes a
banded jacobian
</h2><span id='topic+steady.band'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of ordinary differential
equations.
</p>
<p>Assumes a banded jacobian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steady.band(y, time = 0, func, parms = NULL, 
            nspec = NULL, bandup = nspec, banddown = nspec, 
            times = time, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steady.band_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ODE system, a vector.
If <code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_time">time</code>, <code id="steady.band_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; the default is
<code>times</code>=0.
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_func">func</code></td>
<td>
<p>either an <span class="rlang"><b>R</b></span>-function that computes the values of the
derivatives in the ode system (the model defininition) at time <code>time</code>,
or a character string giving the name of a compiled function in a
dynamically loaded shared library.
If <code>func</code>  is an <span class="rlang"><b>R</b></span>-function, it must be defined as:
<code>yprime = func(t, y, parms,...)</code>.  <code>t</code> is the current time point
in the integration, <code>y</code> is the current estimate of the variables
in the ODE system.  If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>. <code>parms</code> is
a vector or list of parameters; ... (optional) are any other arguments
passed to the function.
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements are global values whose steady-state
value is also required.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_parms">parms</code></td>
<td>
<p>parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_nspec">nspec</code></td>
<td>
<p>the number of *species* (components) in the model.
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_bandup">bandup</code></td>
<td>
<p>the number of nonzero bands above the Jacobian diagonal.
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_banddown">banddown</code></td>
<td>
<p>the number of nonzero bands below the Jacobian diagonal.
</p>
</td></tr>
<tr><td><code id="steady.band_+3A_...">...</code></td>
<td>
<p>additional arguments passed to function <code>stode</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the method of choice for single-species 1-D models.
</p>
<p>For multi-species 1-D models, this method can only be used if the state
variables are arranged per box, per species (e.g.
A[1],B[1],A[2],B[2],A[3],B[3],.... for species A, B).
</p>
<p>Usually a 1-D *model* function will have the species arranged as
A[1],A[2],A[3],....B[1],B[2],B[3],....
in this case, use <code>steady.1D</code>
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output
values.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute
<code>precis</code> with the precision attained during each iteration.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## 1000 simultaneous equations, solved 6 times for different 
## values of parameter "decay"
## =======================================================================

model &lt;- function (time, OC, parms, decay)  {
  # model of particles (OC) that sink out of the water and decay
  # exponentially declining sinking rate, maximal 100 m/day
  sink &lt;- 100 * exp(-0.01*dist)
  
  # boundary flux; upper boundary=imposed concentration (100)
  Flux &lt;- sink * c(100 ,OC)     
   
  # Rate of change= Flux gradient and first-order consumption
  dOC  &lt;- -diff(Flux)/dx - decay*OC
  list(dOC, maxC = max(OC))
}

dx   &lt;- 1                          # thickness of boxes
dist &lt;- seq(0, 1000, by = dx)      # water depth at each modeled box interface

ss   &lt;- NULL 
for (decay in seq(from = 0.1, to = 1.1, by = 0.2))
  ss   &lt;- cbind(ss, steady.band(runif(1000), func = model,
                parms = NULL, nspec = 1, decay = decay)$y)  

matplot(ss, 1:1000, type = "l", lwd = 2, main = "steady.band", 
  ylim=c(1000, 0), ylab = "water depth, m", 
  xlab = "concentration of sinking particles")

legend("bottomright", legend = seq(from = 0.1, to = 1.1, by = 0.2),
   lty = 1:10, title = "decay rate", col = 1:10, lwd = 2)

## =======================================================================
## 5001 simultaneous equations: solve
## dy/dt = 0 = d2y/dx2 + 1/x*dy/dx + (1-1/(4x^2)y - sqrx(x)*cos(x),
## over the interval [1,6], with boundary conditions: y(1)=1, y(6)=-0.5
## =======================================================================

derivs &lt;- function(t, y, parms, x, dx, N, y1, y6)  {

  # Numerical approximation of derivates:
  # d2y/dx2 = (yi+1-2yi+yi-1)/dx^2
   d2y &lt;- (c(y[-1],y6) -2*y + c(y1,y[-N])) /dx/dx

  # dy/dx = (yi+1-yi-1)/(2dx)
   dy  &lt;- (c(y[-1],y6) - c(y1,y[-N])) /2/dx

   res &lt;- d2y+dy/x+(1-1/(4*x*x))*y-sqrt(x)*cos(x)
   return(list(res))
}

dx     &lt;- 0.001
x      &lt;- seq(1,6,by=dx)
N      &lt;- length(x)
y  &lt;- steady.band(y = rep(1, N), time = 0, func = derivs, x = x, dx = dx,
                  N = N, y1 = 1, y6 = -0.5, nspec = 1)$y
plot(x, y, type = "l", main = "5001 nonlinear equations - banded Jacobian")

# add the analytic solution for comparison:
xx     &lt;- seq(1, 6, by = 0.1)
ana &lt;- 0.0588713*cos(xx)/sqrt(xx)+1/4*sqrt(xx)*cos(xx)+
       0.740071*sin(xx)/sqrt(xx)+1/4*xx^(3/2)*sin(xx)
points(xx, ana)
legend("topright", pch = c(NA, 1), lty = c(1, NA),
       c("numeric", "analytic"))

</code></pre>

<hr>
<h2 id='stode'>
Iterative steady-state solver for ordinary differential equations (ODE)
and a full or banded Jacobian.
</h2><span id='topic+stode'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of 
ordinary differential equations (ODE) written in the form:
</p>
<p style="text-align: center;"><code class="reqn">dy/dt = f(t,y)</code>
</p>
   
<p>i.e. finds the values of <code>y</code> for which f(t,y) = 0.
</p>
<p>Uses a newton-raphson method, implemented in Fortran 77.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or defined in
compiled code that has been dynamically loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stode(y, time = 0, func, parms = NULL, 
      rtol = 1e-6, atol = 1e-8, ctol = 1e-8, 
      jacfunc = NULL, jactype = "fullint", verbose = FALSE, 
      bandup = 1, banddown = 1, positive = FALSE, 
      maxiter = 100, ynames = TRUE, 
      dllname = NULL, initfunc = dllname, initpar = parms, 
      rpar = NULL, ipar = NULL, nout = 0, outnames = NULL, 
      forcings = NULL, initforc = NULL, fcontrol = NULL, 
      times = time, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stode_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ode system, a vector.
If <code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="stode_+3A_time">time</code>, <code id="stode_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; the default is
<code>times</code>=0.    
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="stode_+3A_func">func</code></td>
<td>
<p>either a user-supplied function that computes the values of the
derivatives in the ode system (the <em>model definition</em>) at time
<code>time</code>, or a character string giving the name of a compiled function
in a dynamically loaded shared library.
</p>
<p>If <code>func</code>  is a user-supplied function, it must be called as:
<code>yprime = func(t, y, parms, ...)</code>.  <code>t</code> is the time point
at which the steady-state is wanted, <code>y</code> is the current estimate of
the variables in the ode system. If the initial values <code>y</code> has a names
attribute, the names will be available inside <code>func</code>.  <code>parms</code> is
a vector of parameters (which may have a names attribute).
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements (possibly with a
<code><a href="base.html#topic+names">names</a></code> attribute) are global values that are required as
output.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>stode()</code> is called. see Details for more information.
</p>
</td></tr>
<tr><td><code id="stode_+3A_parms">parms</code></td>
<td>
<p>other parameters passed to <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or a vector, one
value for each <code>y</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or a vector, one
value for each <code>y</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_ctol">ctol</code></td>
<td>
<p>if between two iterations, the maximal change in <code>y</code> is
less than this amount, steady-state is assumed to be reached.
</p>
</td></tr>
<tr><td><code id="stode_+3A_jacfunc">jacfunc</code></td>
<td>
<p>if not <code>NULL</code>, either a user-supplied <span class="rlang"><b>R</b></span> function that
estimates the Jacobian of the system of differential equations
dydot(i)/dy(j), or a character string giving the name of a compiled
function in a dynamically loaded shared library as provided in
<code>dllname</code>. In some circumstances, supplying <code>jacfunc</code>
can speed up the computations.  The <span class="rlang"><b>R</b></span> calling sequence for
<code>jacfunc</code> is identical to that of <code>func</code>.      
</p>
<p>If the Jacobian is a full matrix, <code>jacfunc</code> should return a matrix
dydot/dy, where the ith row contains the derivative of <code class="reqn">dy_i/dt</code>
with respect to <code class="reqn">y_j</code>, or a vector containing the matrix elements
by columns (the way <span class="rlang"><b>R</b></span> and Fortran store matrices).
</p>
<p>If the Jacobian is banded, <code>jacfunc</code> should return a matrix containing
only the nonzero bands of the jacobian, (dydot/dy), rotated row-wise.
</p>
</td></tr>
<tr><td><code id="stode_+3A_jactype">jactype</code></td>
<td>
<p>the structure of the Jacobian, one of &quot;fullint&quot;, &quot;fullusr&quot;,
&quot;bandusr&quot;, or &quot;bandint&quot; - either full or banded and estimated internally
or by the user.
</p>
</td></tr>
<tr><td><code id="stode_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>: full output to the screen, e.g. will output
the steady-state settings.
</p>
</td></tr>
<tr><td><code id="stode_+3A_bandup">bandup</code></td>
<td>
<p>number of non-zero bands above the diagonal, in case the
Jacobian is banded.
</p>
</td></tr>
<tr><td><code id="stode_+3A_banddown">banddown</code></td>
<td>
<p>number of non-zero bands below the diagonal, in case the
jacobian is banded.
</p>
</td></tr>
<tr><td><code id="stode_+3A_positive">positive</code></td>
<td>
<p>either a logical or a vector with indices of the state
variables that have to be non-negative; if <code>TRUE</code>, all state
variables <code>y</code> are forced to be non-negative numbers.
</p>
</td></tr>
<tr><td><code id="stode_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations during one call to the solver.\
</p>
</td></tr>
<tr><td><code id="stode_+3A_ynames">ynames</code></td>
<td>
<p>if FALSE: names of state variables are not passed to function
<code>func</code> ; this may speed up the simulation especially for multi-D
models.
</p>
</td></tr>
<tr><td><code id="stode_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library (without
extension) that contains all the compiled function or subroutine
definitions referred to in <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_initfunc">initfunc</code></td>
<td>
<p>if not NULL, the name of the initialisation function
(which initialises values of parameters), as provided in &lsquo;<span class="file">dllname</span>&rsquo;.
See details.
</p>
</td></tr>
<tr><td><code id="stode_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an initialisation
function <code>initfunc</code> is in the dll: the parameters passed to the
initialiser, to initialise the common blocks (FORTRAN) or global variables
(C, C++).
</p>
</td></tr>
<tr><td><code id="stode_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with double
precision values passed to the dll-functions whose names are specified
by <code>func</code> and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with integer
values passed to the dll-functions whose names are specified by <code>func</code>
and <code>jacfunc</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_nout">nout</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and the model is
defined in compiled code: the number of output variables calculated in
the compiled function <code>func</code>, present in the shared library. Note:
it is not automatically checked whether this is indeed the number of
output variables calculated in the dll - you have to perform this check
in the code - see package vignette.
</p>
</td></tr>
<tr><td><code id="stode_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="stode_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with the 
forcing function values, or a list with the forcing function data sets, 
each present as a two-columned matrix, with (time,value); interpolation 
outside the interval [min(<code>times</code>), max(<code>times</code>)] is done by 
taking the value at the closest data extreme.
</p>
<p>This feature is here for compatibility with models defined in compiled code
from package deSolve; see deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="stode_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> and <code>jacfunc</code>
allowing this to be a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by a Fortran 77 routine that implements the Newton-Raphson
method. It uses code from LINPACK.
</p>
<p>The form of the <b>Jacobian</b> can be specified by <code>jactype</code> which can
take the following values:
</p>

<ul>
<li><p> jactype = &quot;fullint&quot; : a full jacobian, calculated internally by
the solver, the default.
</p>
</li>
<li><p> jactype = &quot;fullusr&quot; : a full jacobian, specified by user function
<code>jacfunc</code>.
</p>
</li>
<li><p> jactype = &quot;bandusr&quot; : a banded jacobian, specified by user function
<code>jacfunc</code>; the size of the bands specified by <code>bandup</code> and
<code>banddown</code>.
</p>
</li>
<li><p> jactype = &quot;bandint&quot; : a banded jacobian, calculated by the solver;
the size of the bands specified by <code>bandup</code> and <code>banddown</code>.
</p>
</li></ul>

<p>if <code>jactype</code>= &quot;fullusr&quot; or &quot;bandusr&quot; then the user must supply a
subroutine <code>jacfunc</code>.
</p>
<p>The input parameters <code>rtol</code>, <code>atol</code> and <code>ctol</code> determine
the <b>error control</b> performed by the solver.
</p>
<p>The solver will control the vector
<b>e</b> of estimated local errors in <b>y</b>, according to an
inequality of the form max-norm of ( <b>e</b>/<b>ewt</b> )
<code class="reqn">\leq</code> 1, where <b>ewt</b> is a vector of positive error
weights.  The values of <code>rtol</code> and <code>atol</code> should all be
non-negative.
The form of <b>ewt</b> is:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf{rtol} \times \mathrm{abs}(\mathbf{y}) + \mathbf{atol}</code>
</p>

<p>where multiplication of two vectors is element-by-element.
</p>
<p>In addition, the solver will stop if between two iterations, the maximal
change in the values of <b>y</b> is less than <code>ctol</code>.
</p>
<p><b>Models</b> may be defined in compiled C or Fortran code, as well as in <span class="rlang"><b>R</b></span>.
</p>
<p>If <code>func</code> or <code>jacfunc</code> are a string, then they are assumed to be
compiled code.
</p>
<p>In this case, <code>dllname</code> must give the name of the shared library
(without extension) which must be loaded before <code>stode()</code> is called.
</p>
<p>See vignette(&quot;rooSolve&quot;) for how a model has to be specified in compiled code.
Also, vignette(&quot;compiledCode&quot;) from package <span class="pkg">deSolve</span> contains examples
of how to do this.
</p>
<p>If <code>func</code> is a user-supplied <b>R-function</b>, it must be called as:
yprime = func(t, y, parms,...).
t is the <code>time</code> at which the steady-state should be estimated,
<code>y</code> is the current estimate of the variables in the ode system.
The return value of <code>func</code> should be a list, whose first element is
a vector containing the derivatives of <code>y</code> with respect to <code>time</code>,
and whose next elements contains output variables whose values at
steady-state are also required.
</p>
<p>An example is given below:
</p>
<p><code>model&lt;-function(t,y,pars)</code><br />
<code>{</code><br />
<code>with (as.list(c(y,pars)),{</code><br /> 
<code>Min       = r*OM</code><br />
<code>oxicmin   = Min*(O2/(O2+ks))</code><br />
<code>anoxicmin = Min*(1-O2/(O2+ks))* SO4/(SO4+ks2</code><br />
<code>dOM  = Flux - oxicmin - anoxicmin</code><br />
<code>dO2  = -oxicmin      -2*rox*HS*(O2/(O2+ks)) + D*(BO2-O2)</code><br />
<code>dSO4 = -0.5*anoxicmin  +rox*HS*(O2/(O2+ks)) + D*(BSO4-SO4)</code><br />
<code>dHS  =  0.5*anoxicmin  -rox*HS*(O2/(O2+ks)) + D*(BHS-HS)</code>
</p>
<p><code>list(c(dOM,dO2,dSO4,dHS),SumS=SO4+HS)</code><br />
<code>})</code><br />
<code>}</code><br />
</p>
<p>This model can be solved as follows:
</p>
<p><code>pars &lt;- c(D=1,Flux=100,r=0.1,rox =1,</code><br />
<code>ks=1,ks2=1,BO2=100,BSO4=10000,BHS = 0)</code><br />       
</p>
<p><code>y&lt;-c(OM=1,O2=1,SO4=1,HS=1)</code><br />                       
<code>ST &lt;- stode(y=y,func=model,parms=pars,pos=TRUE))</code><br />
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p> a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output
values.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute <code>precis</code> with an
estimate of the precision attained during each iteration, the mean absolute
rate of change (sum(abs(dy))/n).
</p>


<h3>Note</h3>

<p>The implementation of <code>stode</code> and substantial parts of the help file
is similar to the implementation of the integration routines (e.g.
<code>lsode</code>) from package deSolve.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>For a description of the Newton-Raphson method, e.g.
</p>
<p>Press, WH, Teukolsky, SA, Vetterling, WT, Flannery, BP, 1996.
Numerical Recipes in FORTRAN. The Art of Scientific computing. 2nd edition.
Cambridge University Press.
</p>
<p>The algorithm uses LINPACK code:
</p>
<p>Dongarra, J.J., J.R. Bunch,  C.B. Moler and G.W. Stewart, 1979.
LINPACK user's guide, SIAM, Philadelphia.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code> steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stodes">stodes</a></code>, iterative steady-state solver for ODEs with arbitrary
sparse Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
## Example 1. A simple sediment biogeochemical model
## =======================================================================

model&lt;-function(t, y, pars)
{

with (as.list(c(y, pars)),{

  Min       = r*OM
  oxicmin   = Min*(O2/(O2+ks))
  anoxicmin = Min*(1-O2/(O2+ks))* SO4/(SO4+ks2)

  dOM  = Flux - oxicmin - anoxicmin
  dO2  = -oxicmin      -2*rox*HS*(O2/(O2+ks)) + D*(BO2-O2)
  dSO4 = -0.5*anoxicmin  +rox*HS*(O2/(O2+ks)) + D*(BSO4-SO4)
  dHS  = 0.5*anoxicmin   -rox*HS*(O2/(O2+ks)) + D*(BHS-HS)

  list(c(dOM, dO2, dSO4, dHS), SumS = SO4+HS)
})
}

# parameter values
pars &lt;- c(D = 1, Flux = 100, r = 0.1, rox = 1,
          ks = 1, ks2 = 1, BO2 = 100, BSO4 = 10000, BHS = 0)
# initial conditions
y&lt;-c(OM = 1, O2 = 1, SO4 = 1, HS = 1)

# direct iteration  - enforces  positivitiy..
ST &lt;- stode(y = y, func = model, parms = pars, pos = TRUE)

ST

## =======================================================================
## Example 2. 1000 simultaneous equations
## =======================================================================

model &lt;- function (time, OC, parms, decay, ing) {
 # model describing organic Carbon (C) in a sediment, 
 # Upper boundary = imposed flux, lower boundary = zero-gradient
 Flux  &lt;- v * c(OC[1] ,OC) +              # advection
          -Kz*diff(c(OC[1],OC,OC[N]))/dx  # diffusion;
 Flux[1]&lt;- flux     # imposed flux
 
 # Rate of change= Flux gradient and first-order consumption
 dOC   &lt;- -diff(Flux)/dx - decay*OC

 # Fraction of OC in first 5 layers is translocated to mean depth
 dOC[1:5]  &lt;- dOC[1:5] - ing*OC[1:5]
 dOC[N/2]  &lt;- dOC[N/2] + ing*sum(OC[1:5])
 list(dOC)
}

v    &lt;- 0.1    # cm/yr
flux &lt;- 10
dx   &lt;- 0.01
N    &lt;- 1000 
dist &lt;- seq(dx/2,by=dx,len=N)
Kz   &lt;- 1  #bioturbation (diffusion), cm2/yr
print( system.time(
ss   &lt;- stode(runif(N), func = model, parms = NULL, positive = TRUE, 
              decay = 5, ing = 20)))

plot(ss$y[1:N], dist, ylim = rev(range(dist)), type = "l", lwd = 2,
     xlab = "Nonlocal exchange", ylab = "sediment depth",
     main = "stode, full jacobian")

## =======================================================================
## Example 3. Solving a system of linear equations
## =======================================================================

# this example is included to demonstrate how to use the "jactype" option.
# (and that stode is quite efficient).

A &lt;- matrix(nrow = 500, ncol = 500, runif(500*500))
B &lt;- 1:500

# this is how one would solve this in R
print(system.time(X1 &lt;- solve(A, B)))

# to use stode:
# 1. create a function that receives the current estimate of x
# and that returns the difference A%*%x-b, as a list:

fun &lt;- function (t, x, p)  # t and p are dummies here...
  list(A%*%x-B)

# 2. jfun returns the Jacobian: here this equals "A"
jfun &lt;- function (t, x, p) # all input parameters are dummies
  A

# 3. solve with jactype="fullusr" (a full Jacobian, specified by user)
print (system.time(
  X &lt;- stode(y = 1:500, func = fun, jactype = "fullusr", jacfunc = jfun)
  ))

# the results are the same (within precision)
sum((X1-X$y)^2)
</code></pre>

<hr>
<h2 id='stodes'>
Steady-state solver for ordinary differential equations (ODE) with a sparse
jacobian.
</h2><span id='topic+stodes'></span>

<h3>Description</h3>

<p>Estimates the steady-state condition for a system of
ordinary differential equations (ODE) in the form:
</p>
<p style="text-align: center;"><code class="reqn">dy/dt = f(t,y)</code>
</p>

<p>and where the jacobian matrix df/dy has an arbitrary sparse structure.
</p>
<p>Uses a newton-raphson method, implemented in Fortran.
</p>
<p>The system of ODE's is written as an <span class="rlang"><b>R</b></span> function or defined in
compiled code that has been dynamically loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stodes(y, time = 0, func, parms = NULL, rtol = 1e-6, atol = 1e-8,
       ctol = 1e-8, sparsetype = "sparseint", verbose = FALSE,
       nnz = NULL, inz = NULL, lrw = NULL, ngp = NULL, 
       positive = FALSE, maxiter = 100, ynames = TRUE, 
       dllname = NULL, initfunc = dllname, initpar = parms,
       rpar = NULL, ipar = NULL, nout = 0, outnames = NULL, 
       forcings = NULL, initforc = NULL, fcontrol = NULL,
       spmethod = "yale", control = NULL, times = time, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stodes_+3A_y">y</code></td>
<td>
<p>the initial guess of (state) values for the ode system, a vector.
If <code>y</code> has a name attribute, the names will be used to label the
output matrix.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_time">time</code>, <code id="stodes_+3A_times">times</code></td>
<td>
<p>time for which steady-state is wanted; the default is
<code>times</code>=0.
(note- since version 1.7, 'times' has been added as an alias to 'time').
</p>
</td></tr>
<tr><td><code id="stodes_+3A_func">func</code></td>
<td>
<p>either a user-supplied function that computes the values of the
derivatives in the ode system (the <em>model definition</em>) at time
<code>time</code>, or a character string giving the name of a
compiled function in a dynamically loaded shared library.
</p>
<p>If <code>func</code>  is a user-supplied function, it must be called as:
<code>yprime = func(t, y, parms)</code>.  <code>t</code> is the time point
at which the steady-state is wanted, <code>y</code> is the current estimate of
the variables in the ode system.  If the initial values <code>y</code> has a
names attribute, the names will be available inside <code>func</code>.
<code>parms</code> is a vector of parameters (which may have a names attribute).
</p>
<p>The return value of <code>func</code> should be a list, whose first element is a
vector containing the derivatives of <code>y</code> with respect to
<code>time</code>, and whose next elements (possibly with a
<code><a href="base.html#topic+names">names</a></code> attribute) are global values that are required as
output.
</p>
<p>The derivatives
should be specified in the same order as the state variables <code>y</code>.
</p>
<p>If <code>func</code> is a string, then <code>dllname</code> must give the name
of the shared library (without extension) which must be loaded
before <code>stodes()</code> is called.  see Details for more information.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_parms">parms</code></td>
<td>
<p>other parameters passed to <code>func</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_rtol">rtol</code></td>
<td>
<p>relative error tolerance, either a scalar or a vector, one
value for each y.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_atol">atol</code></td>
<td>
<p>absolute error tolerance, either a scalar or a vector, one
value for each y.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_ctol">ctol</code></td>
<td>
<p>if between two iterations, the maximal change in y is less
than this amount, steady-state is assumed to be reached.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_sparsetype">sparsetype</code></td>
<td>
<p>the sparsity structure of the Jacobian, one of
&quot;sparseint&quot;, &quot;sparseusr&quot;, &quot;sparsejan&quot;, &quot;sparsereturn&quot;, ..., 
The sparsity can be estimated internally by stodes (first and last option)
or given by the user (other two). See details.
Note: setting <code>sparsetype</code> equal to &quot;sparsereturn&quot; will not solve for 
steady-state but solely return the <code>ian</code> and <code>jan</code> vectors.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE: full output to the screen, e.g. will output the
steady-state settings.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_nnz">nnz</code></td>
<td>
<p>the number of nonzero elements in the sparse Jacobian (if
this is unknown, use an estimate); If NULL, a guess will be made, and
if not sufficient, <code>stodes</code> will return with a message indicating
the size actually required.
</p>
<p>If a solution is found, the minimal value of <code>nnz</code> actually required
is returned by the solver (1st element of attribute <code>dims</code>).
</p>
</td></tr>
<tr><td><code id="stodes_+3A_inz">inz</code></td>
<td>
<p>if <code>sparsetype</code> equal to &quot;sparseusr&quot;, a two-columned matrix
with the (row, column) indices to the nonzero elements in the sparse
Jacobian. If <code>sparsetype</code> = &quot;sparsejan&quot;, a vector with the elements 
ian followed by the elements jan as used in the stodes code. See details.
In all other cases, ignored. 
If <code>inz</code> is NULL, the sparsity will be determined by <code>stodes</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_lrw">lrw</code></td>
<td>
<p>the length of the work array of the solver; due to the sparsicity,
this cannot be readily predicted. If <code>NULL</code>, a guess will be made, and
if not sufficient, <code>stodes</code> will return with a message indicating
that lrw should be increased. Therefore, some experimentation may be
necessary to estimate the value of <code>lrw</code>. 
</p>
<p>If a solution is found, the minimal value of <code>lrw</code> actually required
is returned by the solver (3rd element of attribute <code>dims</code>).
</p>
<p>In case of an error induced by a too small value of <code>lrw</code>, its value
can be assessed by the <code>attributes()$dims</code> value.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_ngp">ngp</code></td>
<td>
<p>number of groups of independent state variables. Due to the
sparsicity, this cannot be readily predicted. If NULL, a guess will be
made, and if not sufficient, <code>stodes</code> will return with a message
indicating the size actually required. Therefore, some experimentation
may be necessary to estimate the value of <code>ngp</code>
</p>
<p>If a solution is found, the minimal value of <code>ngp</code> actually required
is returned by the solver (2nd element of attribute <code>dims</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_positive">positive</code></td>
<td>
<p>either a logical or a vector with indices of the state
variables that have to be non-negative; if TRUE, the state variables are
forced to be non-negative numbers.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations during one call to the solver.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_ynames">ynames</code></td>
<td>
<p>if FALSE: names of state variables are not passed to
function <code>func</code> ; this may speed up the simulation especially
for multi-D models.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_dllname">dllname</code></td>
<td>
<p>a string giving the name of the shared library (without
extension) that contains all the compiled function or subroutine
definitions referred to in <code>func</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_initfunc">initfunc</code></td>
<td>
<p>if not NULL, the name of the initialisation function
(which initialises values of parameters), as provided in &lsquo;<span class="file">dllname</span>&rsquo;.
See details.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_initpar">initpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified and an initialisation
function <code>initfunc</code> is in the dll: the parameters passed to the
initialiser, to initialise the common blocks (FORTRAN) or global variables
(C, C++).
</p>
</td></tr>
<tr><td><code id="stodes_+3A_rpar">rpar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with double
precision values passed to the dll-functions whose names are specified
by <code>func</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_ipar">ipar</code></td>
<td>
<p>only when &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with integer
values passed to the dll-functions whose names are specified by <code>func</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_nout">nout</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: the number of output
variables calculated in the compiled function <code>func</code>, present in the
shared library.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_outnames">outnames</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified and
<code>nout</code> &gt; 0: the names of output variables calculated in the
compiled function <code>func</code>, present in the shared library.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_spmethod">spmethod</code></td>
<td>
<p>the sparse method to be used, one of <code>"yale", "ilut",
    "ilutp"</code>. The default uses the yale sparse matrix solver; the other 
use preconditioned GMRES (generalised minimum residual method)
solvers from FORTRAN package sparsekit. ilut stands for incomplete LU 
factorisation with trheshold (or tolerances, droptol); the &quot;p&quot; iin ilutp stands for pivoting.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_control">control</code></td>
<td>
<p>only used if <code>spmethod</code> not equal to <code>"yale"</code>,
a list with the control options of the preconditioned solvers. The 
default is <code>list( droptol = 1e-3, permtol = 1e-3, fillin = 10, 
    lenplufac = 2)</code>.  
droptol is the tolerance in ilut, ilutp to decide when to drop a value.
permtol is used in ilutp, to decide whether or not to permute variables.
See Saad 1994, the manual of sparskit and Saad 2003, chapter 10 for details.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_forcings">forcings</code></td>
<td>
<p>only used if &lsquo;<span class="file">dllname</span>&rsquo; is specified: a vector with the 
forcing function values, or a list with the forcing function data sets, 
each present as a two-columned matrix, with (time,value); interpolation 
outside the interval [min(<code>times</code>), max(<code>times</code>)] is done by 
taking the value at the closest data extreme.
</p>
<p>This feature is here for compatibility with models defined in compiled code
from package deSolve; see deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_initforc">initforc</code></td>
<td>
<p>if not <code>NULL</code>, the name of the forcing function
initialisation function, as provided in
&lsquo;<span class="file">dllname</span>&rsquo;. It MUST be present if <code>forcings</code> has been given a
value.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_fcontrol">fcontrol</code></td>
<td>
<p>A list of control parameters for the forcing functions.
See deSolve's package vignette <code>"compiledCode"</code>.
</p>
</td></tr>
<tr><td><code id="stodes_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>func</code> allowing this to be
a generic function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work is done by a Fortran 77 routine that implements the
Newton-Raphson method.
</p>
<p><code>stodes</code> is to be used for problems, where the Jacobian has a sparse
structure.
</p>
<p>There are several choices for the sparsity specification, selected by
argument <code>sparsetype</code>.
</p>

<ul>
<li> <p><code>sparsetype</code> = <code>"sparseint"</code>.  The sparsity is estimated
by the solver, based on numerical differences.
In this case, it is advisable to provide an estimate of the number
of non-zero elements in the Jacobian (<code>nnz</code>).
This value can be approximate; upon return the number of nonzero
elements actually required will be known (1st element of attribute
<code>dims</code>).
In this case, <code>inz</code> need not be specified. 
</p>
</li>
<li> <p><code>sparsetype</code> = <code>"sparseusr"</code>. The sparsity is determined by
the user.
In this case, <code>inz</code> should be a <code>matrix</code>, containing indices 
(row, column) to the  nonzero elements in the Jacobian matrix.
The number of nonzeros <code>nnz</code> will be set equal to the number of rows
in <code>inz</code>.
</p>
</li>
<li> <p><code>sparsetype</code> = <code>"sparsejan"</code>. The sparsity is also determined by
the user.
In this case, <code>inz</code> should be a <code>vector</code>, containting the <code>ian</code> and 
<code>jan</code> elements of the sparse storage format, as used in the sparse solver.
Elements of <code>ian</code> should be the first <code>n+1</code> elements of this vector, and 
contain the starting locations in <code>jan</code> of columns 1.. n. 
<code>jan</code> contains the row indices of the nonzero locations of           
the jacobian, reading in columnwise order.
The number of nonzeros <code>nnz</code> will be set equal to the length of <code>inz</code> - (n+1).
</p>
</li>
<li> <p><code>sparsetype</code> = <code>"1D"</code>, <code>"2D"</code>, <code>"3D"</code>. 
The sparsity is estimated by the solver, based on numerical differences.
Assumes finite differences in a 1D, 2D or 3D regular grid - used by 
functions <code>ode.1D</code>, <code>ode.2D</code>, <code>ode.3D</code>.
Similar are <code>"2Dmap"</code>, and <code>"3Dmap"</code>, which also include a 
mapping variable (passed in nnz). 
</p>
</li></ul>

<p>The Jacobian itself is always generated by the solver (i.e.
there is no provision to provide an analytic Jacobian).
</p>
<p>This is done by perturbing simulataneously a combination of state variables
that do not affect each other.
</p>
<p>This significantly reduces computing time. The number of groups with
independent state variables can be given by <code>ngp</code>.
</p>
<p>The input parameters <code>rtol</code>, <code>atol</code> and <code>ctol</code> determine
the <b>error control</b> performed by the solver. See help for <code>stode</code>
for details.
</p>
<p><b>Models</b> may be defined in compiled C or Fortran code, as well as in
<span class="rlang"><b>R</b></span>. See package vignette for details on how to write models in compiled code.
</p>
<p>When the <code>spmethod</code> equals <code>ilut</code> or <code>ilutp</code>, a number of parameters
can be specified in argument <code>control</code>. They are:
</p>
<p>fillin, the fill-in parameter. Each row of L and each row
of U will have a maximum of lfil elements (excluding the 
diagonal element). lfil must be &gt;= 0.
</p>
<p>droptol, sets the threshold for dropping small terms in the
factorization. 
</p>
<p>When <code>ilutp</code> is chosen the following arguments can also be specified:           
</p>
<p>permtol = tolerance ratio used to  determne whether or not to permute
two columns.  At step i columns i and j are permuted when 
abs(a(i,j))*permtol .gt. abs(a(i,i))
[0 &ndash;&gt; never permute; good values 0.1 to 0.01]
</p>
<p>lenplufac   = sets the working array - increase its value if a warning.
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>a vector with the state variable values from the last iteration
during estimation of steady-state condition of the system of equations.
If <code>y</code> has a names attribute, it will be used to label the output
values.
</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the number of &quot;global&quot; values returned.
</p>
</td></tr>
</table>
<p>The output will have the attribute <code>steady</code>, which returns <code>TRUE</code>,
if steady-state has been reached and the attribute <code>precis</code> with an
estimate of the precision attained during each iteration, the mean absolute
rate of change (sum(abs(dy))/n).
</p>
<p>In case the argument <code>sparsetype</code> is set to &quot;sparsereturn&quot;, 
then two extra attributes will be returned, i.e. <code>ian</code> and <code>jan</code>.
These can then be used to speed up subsequent calculations - see last example.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>References</h3>

<p>For a description of the Newton-Raphson method, e.g.
</p>
<p>Press, WH, Teukolsky, SA, Vetterling, WT, Flannery, BP, 1996.
Numerical Recipes in FORTRAN. The Art of Scientific computing. 2nd edition.
Cambridge University Press.
</p>
<p>When spmethod = &quot;yale&quot; then the algorithm uses linear algebra routines from 
the Yale sparse matrix package:
</p>
<p>Eisenstat, S.C., Gursky, M.C., Schultz, M.H., Sherman, A.H., 1982.
Yale Sparse Matrix Package.
i. The symmetric codes. Int. J. Num. meth. Eng. 18, 1145-1151.
</p>
<p>else the functions ilut and ilutp from sparsekit package are used:
</p>
<p>Yousef Saad, 1994. SPARSKIT: a basic tool kit for
sparse matrix computations. VERSION 2
</p>
<p>Yousef Saad, 2003. Iterative methods for Sparse Linear Systems. Society for
Industrial and Applied Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+steady">steady</a></code>, for a general interface to most of the steady-state
solvers
</p>
<p><code><a href="#topic+steady.band">steady.band</a></code>, to find the steady-state of ODE models with a
banded Jacobian
</p>
<p><code><a href="#topic+steady.1D">steady.1D</a></code>, <code><a href="#topic+steady.2D">steady.2D</a></code>,
<code><a href="#topic+steady.3D">steady.3D</a></code>, steady-state solvers for 1-D, 2-D and 3-D
partial differential equations.
</p>
<p><code><a href="#topic+stode">stode</a></code>, iterative steady-state solver for ODEs with full
or banded Jacobian.
</p>
<p><code><a href="#topic+runsteady">runsteady</a></code>, steady-state solver by dynamically running to
steady-state
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## =======================================================================
## 1000 simultaneous equations
## =======================================================================

model &lt;- function (time, OC, parms, decay, ing)
{
 # model describing C in a sediment,
 # Upper boundary = imposed flux, lower boundary = zero-gradient
 Flux  &lt;- v * c(OC[1] ,OC) +              # advection
          -Kz*diff(c(OC[1],OC,OC[N]))/dx  # diffusion;
 Flux[1]&lt;- flux     # imposed flux

 # Rate of change= Flux gradient and first-order consumption
 dOC   &lt;- -diff(Flux)/dx - decay*OC

 # Fraction of OC in first 5 layers is translocated to mean depth
 # (layer N/2)
 dOC[1:5]  &lt;- dOC[1:5] - ing*OC[1:5]
 dOC[N/2]  &lt;- dOC[N/2] + ing*sum(OC[1:5])
 list(dOC)
}

v    &lt;- 0.1    # cm/yr
flux &lt;- 10
dx   &lt;- 0.01
N    &lt;- 1000
dist &lt;- seq(dx/2, by = dx, len = N)
Kz   &lt;- 1  #bioturbation (diffusion), cm2/yr
print(system.time(
  ss   &lt;- stodes(runif(N), func = model, parms = NULL,
               positive = TRUE, decay = 5, ing = 20, verbose = TRUE)
))
plot(ss$y[1:N], dist, ylim = rev(range(dist)), type = "l", lwd = 2,
     xlab = "Nonlocal exchange", ylab = "sediment depth",
     main = "stodes, sparse jacobian")

# the size of lrw is in the attributes()$dims vector.     
attributes(ss)     

## =======================================================================
## deriving sparsity structure and speeding up calculations
## =======================================================================

sparse &lt;- stodes(runif(N), func = model, parms = NULL,
                 sparsetype = "sparsereturn", decay = 5, ing = 20)

ian &lt;- attributes(sparse)$ian
jan &lt;- attributes(sparse)$jan
nnz &lt;- length(jan)
inz &lt;- c(ian, jan)

print(system.time(
s2   &lt;- stodes(runif(N), func = model, parms = NULL, positive = TRUE,
               sparsetype = "sparsejan", inz = inz, decay = 5, ing = 20)
))

# Can also be used with steady.1D, by setting jactype = "sparsejan".
# The advantage is this allows easy plotting...

print(system.time(
s2b   &lt;- steady.1D(runif(N), func = model, parms = NULL, method = "stodes", 
                   nspec = 1, jactype = "sparsejan", inz = inz, 
               decay = 5, ing = 20, verbose = FALSE)
))

plot(s2b, grid = dist, xyswap = TRUE, type = "l", lwd = 2,
     xlab = "Nonlocal exchange", ylab = "sediment depth",
     main = "steady 1-D, sparse jacobian imposed")

</code></pre>

<hr>
<h2 id='uniroot.all'>
Finds many (all) roots of one equation within an interval
</h2><span id='topic+uniroot.all'></span>

<h3>Description</h3>

<p>The function <code>uniroot.all</code> searches the interval from lower to upper
for several roots (i.e., zero's) of a function <code>f</code> with respect to
its first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniroot.all(f, interval, lower = min(interval), upper = max(interval), 
            tol = .Machine$double.eps^0.2, maxiter = 1000, 
            trace = 0, n = 100, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniroot.all_+3A_f">f</code></td>
<td>
<p>the function for which the root is sought.
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to
be searched for the root.
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_lower">lower</code></td>
<td>
<p>the lower end point of the interval to be searched.
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_upper">upper</code></td>
<td>
<p>the upper end point of the interval to be searched.
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance).  Passed to function <a href="stats.html#topic+uniroot">uniroot</a>
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations.  Passed to function <a href="stats.html#topic+uniroot">uniroot</a>
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_trace">trace</code></td>
<td>
<p>integer number; if positive, tracing information is produced. 
Higher values giving more details. Passed to function <a href="stats.html#topic+uniroot">uniroot</a></p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_n">n</code></td>
<td>
<p>number of subintervals in which the root is sought.
</p>
</td></tr>
<tr><td><code id="uniroot.all_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed to <code>f</code>
(but beware of partial matching to other arguments).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f</code> will be called as <code>f(x, ...)</code> for a numeric value of <code>x</code>.
</p>
<p>Run <code>demo(Jacobandroots)</code> for an example of the use of <code>uniroot.all</code>
for steady-state analysis.
</p>
<p>See also second example of <code><a href="#topic+gradient">gradient</a></code>
This example is discussed in the book by Soetaert and Herman (2009).
</p>


<h3>Value</h3>

<p>a vector with the roots found in the interval
</p>


<h3>Note</h3>

<p>The function calls <code>uniroot</code>, the basic R-function.
</p>
<p>It is not guaranteed that all roots will be recovered.
</p>
<p>This will depend on <code>n</code>, the number of subintervals in which the
interval is divided.
</p>
<p>If the function &quot;touches&quot; the X-axis (i.e. the root is a saddle point),
then this root will generally not be retrieved.
(but chances of this are pretty small).
</p>
<p>Whereas <code>unitroot</code> passes values one at a time to the function,
<code>uniroot.all</code> passes a vector of values to the function. 
Therefore <code>f</code> should be written such that it can handle a vector of values.
See last example.
</p>


<h3>Author(s)</h3>

<p>Karline Soetaert &lt;karline.soetaert@nioz.nl&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code> for more information about input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## =======================================================================
##   Mathematical examples  
## =======================================================================

# a well-behaved case...
fun &lt;- function (x) cos(2*x)^3

curve(fun(x), 0, 10,main = "uniroot.all")

All &lt;- uniroot.all(fun, c(0, 10))
points(All, y = rep(0, length(All)), pch = 16, cex = 2)

# a difficult case...
f &lt;- function (x) 1/cos(1+x^2)
AA &lt;- uniroot.all(f, c(-5, 5))
curve(f(x), -5, 5, n = 500, main = "uniroot.all")
points(AA, rep(0, length(AA)), col = "red", pch = 16)

f(AA)  # !!!

## =======================================================================
## Ecological modelling example  
## =======================================================================

# Example from the book of Soetaert and Herman(2009)
# A practical guide to ecological modelling -
# using R as a simulation platform. Springer

r   &lt;- 0.05
K   &lt;- 10
bet &lt;- 0.1
alf &lt;- 1

# the model : density-dependent growth and sigmoid-type mortality rate
rate &lt;- function(x, r = 0.05) r*x*(1-x/K) - bet*x^2/(x^2+alf^2)

# find all roots within the interval [0,10]
Eq   &lt;- uniroot.all(rate, c(0, 10))

# jacobian evaluated at all roots: 
# This is just one value - and therefore jacobian = eigenvalue
# the sign of eigenvalue: stability of the root: neg=stable, 0=saddle, pos=unstable

eig &lt;- vector()
for (i in 1:length(Eq)) 
  eig[i] &lt;- sign (gradient(rate, Eq[i]))

curve(rate(x), ylab = "dx/dt", from = 0, to = 10,
      main = "Budworm model, roots", 
      sub = "Example from Soetaert and Herman, 2009")
abline(h = 0)
points(x = Eq, y = rep(0, length(Eq)), pch = 21, cex = 2,
       bg = c("grey", "black", "white")[eig+2] )
legend("topleft", pch = 22, pt.cex = 2,
       c("stable", "saddle", "unstable"),
       col = c("grey", "black", "white"), 
       pt.bg = c("grey", "black", "white"))
       
## =======================================================================
## Vectorisation:
## =======================================================================
# from R-help Digest, Vol 130, Issue 27
#https://stat.ethz.ch/pipermail/r-help/2013-December/364799.html

integrand1 &lt;- function(x) 1/x*dnorm(x) 
integrand2 &lt;- function(x) 1/(2*x-50)*dnorm(x) 
integrand3 &lt;- function(x, C) 1/(x+C)

res &lt;- function(C) {
  integrate(integrand1, lower = 1, upper = 50)$value + 
  integrate(integrand2, lower = 50, upper = 100)$value - 
  integrate(integrand3, C = C, lower = 1, upper = 100)$value
}

# uniroot passes one value at a time to the function, so res can be used as such
uniroot(res, c(1, 1000))

# Need to vectorise the function to use uniroot.all:
res &lt;- Vectorize(res)
uniroot.all(res, c(1,1000))
       
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
