<!DOCTYPE html><html><head><title>Help for package h3jsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {h3jsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#h3jsr-package'><p>h3jsr: Access Uber's H3 library</p></a></li>
<li><a href='#are_neighbours'><p>check if H3 cells are neighbours</p></a></li>
<li><a href='#cell_area'><p>Get exact cell area</p></a></li>
<li><a href='#cell_to_childpos'><p>Cell to Child position</p></a></li>
<li><a href='#cell_to_children_size'><p>Cell to children size</p></a></li>
<li><a href='#cell_to_line'><p>Convert H3 cell indexes to a line</p></a></li>
<li><a href='#cell_to_point'><p>Convert H3 cell index to point location</p></a></li>
<li><a href='#cell_to_polygon'><p>Get the boundary of an H3 cell index</p></a></li>
<li><a href='#cell_to_splitlong'><p>H3 cell to split long</p></a></li>
<li><a href='#cells_to_multipolygon'><p>Get geometry for a set of H3 cells</p></a></li>
<li><a href='#childpos_to_cell'><p>Child position to cell</p></a></li>
<li><a href='#compact'><p>Compact H3 cells</p></a></li>
<li><a href='#degs_to_rads'><p>Convert degrees to radians</p></a></li>
<li><a href='#edge_length'><p>Get exact cell edge length</p></a></li>
<li><a href='#get_base_cell'><p>get the base cell of an H3 cell index</p></a></li>
<li><a href='#get_cell_vertex'><p>Get a vertex index</p></a></li>
<li><a href='#get_cell_vertexes'><p>Get all vertex indexes</p></a></li>
<li><a href='#get_centerchild'><p>get central child H3 cell index</p></a></li>
<li><a href='#get_children'><p>get child H3 cell indices</p></a></li>
<li><a href='#get_disk'><p>Get nearby H3 cell indices</p></a></li>
<li><a href='#get_disk_list'><p>Get nearby H3 cell indexes separated by distance</p></a></li>
<li><a href='#get_faces'><p>get the icosahedron faces of an H3 cell index</p></a></li>
<li><a href='#get_gcdist'><p>Great circle distance</p></a></li>
<li><a href='#get_local_cell'><p>Get H3 cell from local i, j coordinates</p></a></li>
<li><a href='#get_local_ij'><p>Get local i, j coordinates</p></a></li>
<li><a href='#get_parent'><p>get parent H3 cell index</p></a></li>
<li><a href='#get_pentagons'><p>get the pentagon indices for an H3 resolution</p></a></li>
<li><a href='#get_res'><p>get the resolution of an H3 cell index</p></a></li>
<li><a href='#get_res0'><p>Get resolution 0 indexes</p></a></li>
<li><a href='#get_ring'><p>Get a ring of H3 cell indexes</p></a></li>
<li><a href='#get_uddest'><p>Get destination cell from directed edge</p></a></li>
<li><a href='#get_udedge'><p>Get a unidirectional edge index</p></a></li>
<li><a href='#get_udedges'><p>Get all directed edge indexes for a given H3 cell</p></a></li>
<li><a href='#get_udends'><p>Get origin and destination indexes of directed edge</p></a></li>
<li><a href='#get_udorigin'><p>Get origin cell index from directed edge</p></a></li>
<li><a href='#grid_distance'><p>Grid distance between H3 cells</p></a></li>
<li><a href='#grid_path'><p>Path between H3 cells</p></a></li>
<li><a href='#h3_info_table'><p>H3 index utility information table</p></a></li>
<li><a href='#is_pentagon'><p>check if H3 cell index is a pentagon</p></a></li>
<li><a href='#is_rc3'><p>check if H3 cell index is in a Class III resolution</p></a></li>
<li><a href='#is_valid'><p>check H3 cell index</p></a></li>
<li><a href='#is_valid_edge'><p>Check H3 unidirectional edge index</p></a></li>
<li><a href='#is_valid_vertex'><p>check H3 cell index</p></a></li>
<li><a href='#num_cells'><p>Get total H3 cells</p></a></li>
<li><a href='#point_to_cell'><p>Convert point location to H3 cell index</p></a></li>
<li><a href='#polygon_to_cells'><p>Get H3 cell index within a polygon</p></a></li>
<li><a href='#prep_for_polyfill'><p>Prepare geometry for polygon_to_cells</p></a></li>
<li><a href='#prep_for_pt2cell'><p>Prepare inputs for point_to_cell</p></a></li>
<li><a href='#rads_to_degs'><p>Convert radians to degrees</p></a></li>
<li><a href='#res_area'><p>Get average cell area</p></a></li>
<li><a href='#res_cendist'><p>Get average distance between H3 cell centers</p></a></li>
<li><a href='#res_length'><p>Get average cell edge length</p></a></li>
<li><a href='#splitlong_to_cell'><p>Split long to H3 cell</p></a></li>
<li><a href='#udedge_to_line'><p>Get the geometry of an H3 edge</p></a></li>
<li><a href='#uncompact'><p>Uncompact H3 cell indices</p></a></li>
<li><a href='#vertex_to_point'><p>Convert H3 cell vertex index to point location</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Access Uber's H3 Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-21</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides access to Uber's H3 library for geospatial indexing via its JavaScript transpile 'h3-js' <a href="https://github.com/uber/h3-js">https://github.com/uber/h3-js</a> and 'V8' <a href="https://github.com/jeroen/v8">https://github.com/jeroen/v8</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>V8 engine version 6+ is needed for modern JS and
WASM support. On Debian / Ubuntu install either libv8-dev or
libnode-dev, on Fedora use v8-devel.</td>
</tr>
<tr>
<td>Imports:</td>
<td>geojsonsf, methods, sf, tidyr, utils, V8 (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, ggplot2, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://obrl-soil.github.io/h3jsr/">https://obrl-soil.github.io/h3jsr/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-21 02:49:07 UTC; leobr</td>
</tr>
<tr>
<td>Author:</td>
<td>Lauren O'Brien <a href="https://orcid.org/0000-0002-7336-2171"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lauren O'Brien &lt;obrlsoilau@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-21 09:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='h3jsr-package'>h3jsr: Access Uber's H3 library</h2><span id='topic+h3jsr'></span><span id='topic+h3jsr-package'></span>

<h3>Description</h3>

<p>This package uses package <a href="https://github.com/jeroen/v8">V8</a> to access the
<a href="https://github.com/uber/h3-js">javascript bindings for Uber's H3 library</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lauren O'Brien <a href="mailto:obrlsoilau@gmail.com">obrlsoilau@gmail.com</a> (<a href="https://orcid.org/0000-0002-7336-2171">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://obrl-soil.github.io/h3jsr/">https://obrl-soil.github.io/h3jsr/</a>
</p>
</li></ul>


<hr>
<h2 id='are_neighbours'>check if H3 cells are neighbours</h2><span id='topic+are_neighbours'></span>

<h3>Description</h3>

<p>This function checks whether two H3 cells share an edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_neighbours(origin = NULL, destination = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_neighbours_+3A_origin">origin</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A vector of
indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="are_neighbours_+3A_destination">destination</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A vector
of indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="are_neighbours_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical; <code>TRUE</code> if neighbours.
</p>


<h3>Note</h3>


<ul>
<li><p>The number of indexes supplied to origin and destination must be
equal.
</p>
</li>
<li><p>This function will always return false if the indexes are of different
resolutions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Are the following cells neighbours?
are_neighbours(origin = '86be8d12fffffff', destination = '86be8d127ffffff')

</code></pre>

<hr>
<h2 id='cell_area'>Get exact cell area</h2><span id='topic+cell_area'></span>

<h3>Description</h3>

<p>This function calculates the exact area of an H3 cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_area(h3_address = NULL, units = c("m2", "km2", "rads2"), simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_area_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="cell_area_+3A_units">units</code></td>
<td>
<p>Length unit to report in. Options are square meters, square
kilometers, or steradians.</p>
</td></tr>
<tr><td><code id="cell_area_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a numeric vector of length(h3_address).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cell_area(h3_address = '8abe8d12acaffff', 'm2')
</code></pre>

<hr>
<h2 id='cell_to_childpos'>Cell to Child position</h2><span id='topic+cell_to_childpos'></span>

<h3>Description</h3>

<p>Get the position of the cell within an ordered list of all children of the cell's parent at the specified resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_to_childpos(h3_address = NULL, parent_res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_to_childpos_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="cell_to_childpos_+3A_parent_res">parent_res</code></td>
<td>
<p>numeric; resolution of reference parent cell.</p>
</td></tr>
<tr><td><code id="cell_to_childpos_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, Position of child within parent at 'parent_res'.
</p>


<h3>Note</h3>

<p>Function will return 0 if 'parent_res' is the same as the resolution of the supplied cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example address has resolution 7
cell_to_childpos('872830b82ffffff', c(3,4,5,6), simple = FALSE)
</code></pre>

<hr>
<h2 id='cell_to_children_size'>Cell to children size</h2><span id='topic+cell_to_children_size'></span>

<h3>Description</h3>

<p>Get the number of children for a cell at a given resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_to_children_size(h3_address = NULL, child_res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_to_children_size_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="cell_to_children_size_+3A_child_res">child_res</code></td>
<td>
<p>numeric; child resolution to report on.</p>
</td></tr>
<tr><td><code id="cell_to_children_size_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric; number of children at the requested resolution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example address has resolution 7:
cell_to_children_size('872830b82ffffff', c(8,9,10,11), simple = FALSE)
</code></pre>

<hr>
<h2 id='cell_to_line'>Convert H3 cell indexes to a line</h2><span id='topic+cell_to_line'></span><span id='topic+cell_to_line.data.frame'></span><span id='topic+cell_to_line.list'></span><span id='topic+cell_to_line.character'></span>

<h3>Description</h3>

<p>Return line geometry for a sequence of H3 cell indexes in WGS84 coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_to_line(input = NULL, simple = TRUE)

## S3 method for class 'data.frame'
cell_to_line(input = NULL, simple = TRUE)

## S3 method for class 'list'
cell_to_line(input = NULL, simple = TRUE)

## S3 method for class 'character'
cell_to_line(input = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_to_line_+3A_input">input</code></td>
<td>
<p>Character vector of 15-character indexes generated by H3, a
list of such, or a data frame where the last column is a list-column of H3
cell indexes (usually the output of
<code><a href="#topic+grid_path">h3jsr::grid_path()</a></code>.</p>
</td></tr>
<tr><td><code id="cell_to_line_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return an <code>sfc_LINESTRING</code> object or
an <code>sf</code> data frame containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sfc_LINESTRING</code> object containing a line for each vector of
H3 cell indexes supplied. If <code>simple = FALSE</code>, an <code>sf</code> object
including the input data.
</p>


<h3>Note</h3>

<p>This function can accept any arbitrary vector of cell indexes (including
cells at multiple resolutions) but results may be unexpected. It is
assumed that indexes are supplied in a pre-ordered fashion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What is the cell index over the Brisbane Town Hall at resolution 10?
brisbane_hex_10 &lt;- cell_to_polygon(input = '8abe8d12acaffff')

# Give me a some nearby cells
hex_sample &lt;- get_disk_list('8abe8d12acaffff', 4)[[1]][[4]][seq(1,18,3)]
hex_sample_polys &lt;- cell_to_polygon(hex_sample)

# find connecting paths
paths &lt;- grid_path(rep('8abe8d12acaffff', 6), hex_sample)

# make lines
lines &lt;- cell_to_line(paths)

## Not run: 
plot(hex_sample_polys, reset = FALSE)
plot(brisbane_hex_10, add = TRUE)
plot(lines, col = 'red', add = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='cell_to_point'>Convert H3 cell index to point location</h2><span id='topic+cell_to_point'></span>

<h3>Description</h3>

<p>This function takes a H3 cell index and returns its center coordinates in
WGS84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_to_point(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_to_point_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="cell_to_point_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an <code>sfc_POINT</code> object of <code>length(h3_address)</code>.
EPSG:WGS84.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where is the center of the hexagon over the Brisbane Town Hall at resolution 10?
brisbane_10 &lt;- cell_to_point(h3_address = '8abe8d12acaffff')

</code></pre>

<hr>
<h2 id='cell_to_polygon'>Get the boundary of an H3 cell index</h2><span id='topic+cell_to_polygon'></span>

<h3>Description</h3>

<p>This function takes an H3 cell index and returns its bounding shape (usually a
hexagon) in WGS84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_to_polygon(input = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_to_polygon_+3A_input">input</code></td>
<td>
<p>Character; 15-character index generated by H3, or a
vector or list of same, or a data frame where the first column contains H3
addresses.</p>
</td></tr>
<tr><td><code id="cell_to_polygon_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return an <code>sfc_POLYGON</code> object or an <code>sf</code>
data frame containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an <code>sfc_POLYGON</code> object of <code>length(input)</code>. If an
appropriately formatted data frame is supplied, an <code>sf</code> data frame
containing input attributes and geometry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What is the hexagon over the Brisbane Town Hall at resolution 10?
brisbane_hex_10 &lt;- cell_to_polygon(input = '8abe8d12acaffff')

# Give me some of the cells over Brisbane Town Hall as an sf object
bth &lt;- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
bth_addys &lt;- unlist(point_to_cell(bth, res = seq(10, 15)), use.names = FALSE)
bth_hexes &lt;- cell_to_polygon(input = bth_addys)
plot(bth_hexes, axes = TRUE)
</code></pre>

<hr>
<h2 id='cell_to_splitlong'>H3 cell to split long</h2><span id='topic+cell_to_splitlong'></span>

<h3>Description</h3>

<p>Convert an H3 cell (64-bit hexidecimal string) into a &quot;split long&quot; - a pair
of 32-bit integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_to_splitlong(h3_address, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_to_splitlong_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="cell_to_splitlong_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of integer pairs, one for each address supplied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cell_to_splitlong(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='cells_to_multipolygon'>Get geometry for a set of H3 cells</h2><span id='topic+cells_to_multipolygon'></span>

<h3>Description</h3>

<p>This function returns geometry associated with a set of H3 cells, as a
single <code>sfc_MULTIPOLYGON</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cells_to_multipolygon(h3_addresses = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cells_to_multipolygon_+3A_h3_addresses">h3_addresses</code></td>
<td>
<p>Character vector or list of 15-character cell indices
generated by H3.</p>
</td></tr>
<tr><td><code id="cells_to_multipolygon_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return an <code>sfc_MULTIPOLYGON</code> or an
<code>sf</code> object including the input cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, object of type <code>sfc_MULTIPOLYGON</code> of length 1.
</p>


<h3>Note</h3>

<p>The geometry returned by this function will not be valid where the
addresses supplied overlap at the same resolution. The main use case for
this function appears to be visualising the outputs of
<code><a href="#topic+polygon_to_cells">polygon_to_cells</a></code> and
<code><a href="#topic+compact">compact</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Give me the outline of the cells around Brisbane Town Hall at
# resolution 10 (not run as slow-ish)
bth &lt;- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
bth_10 &lt;- point_to_h3(bth, res = 10)
bth_patch &lt;- get_disk(h3_address = bth_10, ring_size = 2)
bth_patch_sf &lt;- cells_to_multipolygon(bth_patch)

## End(Not run)
</code></pre>

<hr>
<h2 id='childpos_to_cell'>Child position to cell</h2><span id='topic+childpos_to_cell'></span>

<h3>Description</h3>

<p>Get the child cell at a given position within an ordered list of all children at the specified resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>childpos_to_cell(
  child_pos = NULL,
  h3_address = NULL,
  child_res = NULL,
  simple = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="childpos_to_cell_+3A_child_pos">child_pos</code></td>
<td>
<p>numeric; position of the child cell to get.</p>
</td></tr>
<tr><td><code id="childpos_to_cell_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="childpos_to_cell_+3A_child_res">child_res</code></td>
<td>
<p>numeric; resolution of the child cell to return.</p>
</td></tr>
<tr><td><code id="childpos_to_cell_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character, H3 address of child
</p>


<h3>Note</h3>

<p>'child_pos' is 0-indexed and capped at the maximum number of hexagons within the parent cell at the supplied resolution. This figure can be determined using <code><a href="#topic+cell_to_children_size">cell_to_children_size</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example address has resolution 7:
childpos_to_cell(0, '872830b82ffffff', 9, simple = FALSE)
</code></pre>

<hr>
<h2 id='compact'>Compact H3 cells</h2><span id='topic+compact'></span>

<h3>Description</h3>

<p>This function compacts a set of cells of the same resolution into a set of
cells across multiple resolutions that represents the same area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact(h3_addresses = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compact_+3A_h3_addresses">h3_addresses</code></td>
<td>
<p>Character vector or list of 15-character indices
generated by H3 at a single resolution, generally the output of
<code><a href="#topic+polygon_to_cells">polygon_to_cells</a></code>.</p>
</td></tr>
<tr><td><code id="compact_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a list object
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of H3 cells with multiple resolutions. The minimum
resolution of the output list matches the resolution of the input list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Give me a compacted representation of County Ashe, NC
nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc1 &lt;- nc[1, ]
nc1 &lt;- sf::st_cast(nc1, 'POLYGON')
fillers &lt;- polygon_to_cells(geometry = nc1, res = 6)
compacted &lt;- compact(fillers)

## End(Not run)
</code></pre>

<hr>
<h2 id='degs_to_rads'>Convert degrees to radians</h2><span id='topic+degs_to_rads'></span>

<h3>Description</h3>

<p>Convert degrees to radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degs_to_rads(degree = NULL, lang = c("r", "h3"), simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degs_to_rads_+3A_degree">degree</code></td>
<td>
<p>Numeric, value in degrees</p>
</td></tr>
<tr><td><code id="degs_to_rads_+3A_lang">lang</code></td>
<td>
<p>Character; whether to perform the conversion using base R
or the H3 library. Defaults to R for speed.</p>
</td></tr>
<tr><td><code id="degs_to_rads_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, value in radians
</p>


<h3>Examples</h3>

<pre><code class='language-R'>degs_to_rads(120)
</code></pre>

<hr>
<h2 id='edge_length'>Get exact cell edge length</h2><span id='topic+edge_length'></span>

<h3>Description</h3>

<p>This function calculates the exact length of an H3 cell edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_length(h3_edge = NULL, units = c("m", "km", "rads"), simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_length_+3A_h3_edge">h3_edge</code></td>
<td>
<p>Character; address of unidirectional edge.</p>
</td></tr>
<tr><td><code id="edge_length_+3A_units">units</code></td>
<td>
<p>Length unit to report in. Options are meters, kilometers, or
radians.</p>
</td></tr>
<tr><td><code id="edge_length_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a numeric vector of length(h3_address).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edge_length(h3_edge = '166be8d12fffffff', 'm')
</code></pre>

<hr>
<h2 id='get_base_cell'>get the base cell of an H3 cell index</h2><span id='topic+get_base_cell'></span>

<h3>Description</h3>

<p>This function returns the number of the base (Level 1) cell for an H3
cell idnex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_base_cell(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_base_cell_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_base_cell_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an integer vector of <code>length(h3_address)</code>, ranging from
0 to 121.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What is Brisbane Town Hall's base cell number?
get_base_cell(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='get_cell_vertex'>Get a vertex index</h2><span id='topic+get_cell_vertex'></span>

<h3>Description</h3>

<p>This function returns the vertex index for a supplied H3 cell and vertex
number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cell_vertex(h3_address = NULL, v_num = 0, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cell_vertex_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A
vector of indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_cell_vertex_+3A_v_num">v_num</code></td>
<td>
<p>Numeric; the vertex number required. Options are 0-5 inclusive.</p>
</td></tr>
<tr><td><code id="get_cell_vertex_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get vertex 3 for this cell
get_cell_vertex(h3_address = '86be8d12fffffff', 3)

</code></pre>

<hr>
<h2 id='get_cell_vertexes'>Get all vertex indexes</h2><span id='topic+get_cell_vertexes'></span>

<h3>Description</h3>

<p>This function returns all 6 vertex indices for a supplied H3 cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cell_vertexes(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cell_vertexes_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A
vector of indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_cell_vertexes_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get vertexes for this cell
get_cell_vertexes(h3_address = '86be8d12fffffff')

</code></pre>

<hr>
<h2 id='get_centerchild'>get central child H3 cell index</h2><span id='topic+get_centerchild'></span>

<h3>Description</h3>

<p>This function returns the central child of a particular H3 cell index at the
requested resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_centerchild(h3_address = NULL, res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_centerchild_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_centerchild_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="get_centerchild_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element contains
a vector of H3 cells.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What is the central child of this resolution 6 index at resolution 8?
get_centerchild(h3_address = '86be8d12fffffff', res = 8)
</code></pre>

<hr>
<h2 id='get_children'>get child H3 cell indices</h2><span id='topic+get_children'></span>

<h3>Description</h3>

<p>This function returns the children of a particular H3 cell at the
requested resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_children(h3_address = NULL, res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_children_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_children_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="get_children_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element contains
a vector of H3 cell indexes.
</p>


<h3>Note</h3>

<p>The number of cells returned for each request is <code>7 ^ (parent_res -
  child_res)</code>, so jumping three levels will return 343 indexes per request.
This can cause memory issues with larger requests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What are the children of this resolution 6 cell index at resolution 8?
get_children(h3_address = '86be8d12fffffff', res = 8)
</code></pre>

<hr>
<h2 id='get_disk'>Get nearby H3 cell indices</h2><span id='topic+get_disk'></span>

<h3>Description</h3>

<p>This function returns all the H3 cell indices within a specified number of
steps from the index supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_disk(h3_address = NULL, ring_size = 1, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_disk_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character cell index generated by H3.</p>
</td></tr>
<tr><td><code id="get_disk_+3A_ring_size">ring_size</code></td>
<td>
<p>Character; number of steps away from the central cell.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="get_disk_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element
contains a character vector of H3 cells.
</p>


<h3>Note</h3>

<p>The number of cells returned for each input index conforms to the
<a href="https://en.wikipedia.org/wiki/Centered_hexagonal_number">centered
hexagonal number sequence</a>, so at <code>ring_size = 5</code>, 91 addresses are
returned. The first address returned is the input address, the rest follow
in a spiral anticlockwise order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What are all the neighbours of this cell within two steps?
get_disk(h3_address = '86be8d12fffffff', ring_size = 2)
</code></pre>

<hr>
<h2 id='get_disk_list'>Get nearby H3 cell indexes separated by distance</h2><span id='topic+get_disk_list'></span>

<h3>Description</h3>

<p>This function returns all the H3 cell indexes within a specified number of steps
from the address supplied, grouped by step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_disk_list(h3_address = NULL, ring_size = 1, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_disk_list_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character cell index generated by H3.</p>
</td></tr>
<tr><td><code id="get_disk_list_+3A_ring_size">ring_size</code></td>
<td>
<p>Character; number of steps away from the central cell.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="get_disk_list_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element
contains a list of <code>length(ring_size + 1)</code>. Each of those lists
contains a character vector of H3 cell indices belonging to that step away
from the input cell.
</p>


<h3>Note</h3>

<p>In total, the number of indices returned for each input cell conforms
to the
<a href="https://en.wikipedia.org/wiki/Centered_hexagonal_number">centered
hexagonal number sequence</a>, so at <code>ring_size = 5</code>, 91 cells are
returned. Cells are returned in separate lists, one for each step.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What are the nested neighbours of this cell within two steps?
get_disk_list(h3_address = '86be8d12fffffff', ring_size = 2)
</code></pre>

<hr>
<h2 id='get_faces'>get the icosahedron faces of an H3 cell index</h2><span id='topic+get_faces'></span>

<h3>Description</h3>

<p>This function returns the indices of all icosahedron faces intersected by a
given H3 cell index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_faces(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_faces_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_faces_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an integer vector of <code>length(h3_address)</code>, ranging
from 1 to 20. If <code>simple = FALSE</code>, a data.frame with a column of H3
cell indexes and a list-column of faces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Which faces does this h3 cell index intersect?
get_faces(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='get_gcdist'>Great circle distance</h2><span id='topic+get_gcdist'></span>

<h3>Description</h3>

<p>Get the great circle distance between WGS84 lat/long points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gcdist(pt1 = NULL, pt2 = NULL, units = c("m", "km", "rads"), simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gcdist_+3A_pt1">pt1</code></td>
<td>
<p>'sf' object with point geometry, 'sfc_POINT' object, 'sfg'
point, data frame or matrix.</p>
</td></tr>
<tr><td><code id="get_gcdist_+3A_pt2">pt2</code></td>
<td>
<p>'sf' object with point geometry, 'sfc_POINT' object, 'sfg'
point, data frame or matrix.</p>
</td></tr>
<tr><td><code id="get_gcdist_+3A_units">units</code></td>
<td>
<p>whether to return the great circle distance in meters,
kilometers, or radians.</p>
</td></tr>
<tr><td><code id="get_gcdist_+3A_simple">simple</code></td>
<td>
<p>whether to return a numeric vector of distances or a
'data.frame' containing start and end coordinates as well as distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of point to point distances, or data frame of origin
and destination coordinates accompanied by their distances.
</p>


<h3>Note</h3>

<p>This functionality also exists in R packages <code>sp</code>, <code>sf</code>,
<code>geosphere</code> and <code>fields</code>. H3's version appears to return slightly
shorter distances than most other implementations, but is included here
for completeness.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># distance between Brisbane and Melbourne
bne &lt;- c(153.028, -27.468)
mlb &lt;- c(144.963, -37.814)
get_gcdist(bne, mlb, 'km')
</code></pre>

<hr>
<h2 id='get_local_cell'>Get H3 cell from local i, j coordinates</h2><span id='topic+get_local_cell'></span>

<h3>Description</h3>

<p>This function returns H3 destination cells for local i, j coordinate
pairs anchored by an H3 origin cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_local_cell(origin = NULL, i = NULL, j = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_local_cell_+3A_origin">origin</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A vector of
indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_local_cell_+3A_i">i</code></td>
<td>
<p>a single i coordinate or vector of same, generated by
<code><a href="#topic+get_local_ij">get_local_ij</a></code></p>
</td></tr>
<tr><td><code id="get_local_cell_+3A_j">j</code></td>
<td>
<p>a single j coordinate or vector of same, generated by
<code><a href="#topic+get_local_ij">get_local_ij</a></code></p>
</td></tr>
<tr><td><code id="get_local_cell_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>simple = TRUE</code>, a character vector of destination H3 cells.
If not, a data frame containing columns origin, i, j, destination.
</p>


<h3>Note</h3>


<ul>
<li><p>The coordinate space used by this function may have deleted regions
or warping due to pentagonal distortion.
</p>
</li>
<li><p>Coordinates are only comparable if they come from the same origin
cell.
</p>
</li>
<li><p>Failure may occur if the destination is too far away from the origin
or if the destination is on the other side of a pentagon.
</p>
</li>
<li><p>This function is experimental, and its output is not guaranteed to be
compatible across different versions of H3.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get local coordinates for a nearby cell
local &lt;- get_local_ij(origin = '86be8d12fffffff', destination = '86be8d127ffffff')

# Convert back to destination cell
get_local_cell(origin = '86be8d12fffffff', i = local[, 1], j = local[, 2])

</code></pre>

<hr>
<h2 id='get_local_ij'>Get local i, j coordinates</h2><span id='topic+get_local_ij'></span>

<h3>Description</h3>

<p>This function defines local i, j coordinates for an H3 destination cell
relative to an H3 origin cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_local_ij(origin = NULL, destination = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_local_ij_+3A_origin">origin</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A vector of
indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_local_ij_+3A_destination">destination</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A
vector of indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_local_ij_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to include an unprojected sfc_POINT geometry
column in the output object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>simple = TRUE</code>, a matrix where each row contains the local
i, j coordinates for the supplied destination indexes. If not, an <code>sf</code>
object with origin and destination attributes, point geometry of the
destination cell centers, and an undefined coordinate reference system.
</p>


<h3>Note</h3>


<ul>
<li><p>The number of indexes supplied to origin and destination must be
equal.
</p>
</li>
<li><p>The coordinate space used by this function may have deleted regions
or warping due to pentagonal distortion.
</p>
</li>
<li><p>Coordinates are only comparable if they come from the same origin
index.
</p>
</li>
<li><p>Failure may occur if the index is too far away from the origin or if
the index is on the other side of a pentagon.
</p>
</li>
<li><p>This function is experimental, and its output is not guaranteed to be
compatible across different versions of H3.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get local coordinates for a nearby cell
get_local_ij(origin = '86be8d12fffffff', destination = '86be8d127ffffff')

# Get local coordinates for a donut of nearby cells
destinations &lt;- get_ring(h3_address = '86be8d12fffffff', ring_size = 2)
local_coords &lt;- get_local_ij(origin = rep('86be8d12fffffff', length(destinations[[1]])),
                             destination = destinations[[1]],
                             simple = FALSE)

plot(local_coords['destination'], pch = 19) # note origin is (0,0)

</code></pre>

<hr>
<h2 id='get_parent'>get parent H3 cell index</h2><span id='topic+get_parent'></span>

<h3>Description</h3>

<p>This function returns the parent of a particular H3 cell index at the requested
resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parent(h3_address = NULL, res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parent_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_parent_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="get_parent_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a logical vector of <code>length(h3_address)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What is the parent of this cell at resolution 6?
get_parent(h3_address = '8abe8d12acaffff', res = 6)
</code></pre>

<hr>
<h2 id='get_pentagons'>get the pentagon indices for an H3 resolution</h2><span id='topic+get_pentagons'></span>

<h3>Description</h3>

<p>This function returns the indices of all pentagons occurring at a
given H3 resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pentagons(res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pentagons_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="get_pentagons_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return outputs as list of outputs (TRUE) or
data frame with both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element
contains a vector of twelve H3 addresses. If <code>simple = FALSE</code>, a data
frame with a column of input resolutions and a list-column of pentagon
indexes for each.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Which indexes are pentagons at resolution 7?
get_pentagons(res = 7)
</code></pre>

<hr>
<h2 id='get_res'>get the resolution of an H3 cell index</h2><span id='topic+get_res'></span>

<h3>Description</h3>

<p>This function returns an H3 cell index's resolution level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_res(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_res_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_res_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an integer vector of <code>length(h3_address)</code>, ranging
from 1 to 15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What is the resolution of this H3 cell index?
get_res(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='get_res0'>Get resolution 0 indexes</h2><span id='topic+get_res0'></span>

<h3>Description</h3>

<p>Get all H3 cell indexes at resolution 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_res0()
</code></pre>


<h3>Value</h3>

<p>length 122 character vector of top-level H3 cell indices.
</p>


<h3>Note</h3>

<p>As every index at every resolution &gt; 0 is
the descendant of a res 0 index, this can be used with
<code><a href="#topic+get_children">get_children</a></code> to iterate over H3 indexes at
any resolution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res0 &lt;- get_res0()
cell_area(res0[1], 'km2')
</code></pre>

<hr>
<h2 id='get_ring'>Get a ring of H3 cell indexes</h2><span id='topic+get_ring'></span>

<h3>Description</h3>

<p>This function returns all the H3 cell indexes at the specified step from the
address supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ring(h3_address = NULL, ring_size = 1, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ring_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character cell index generated by H3.</p>
</td></tr>
<tr><td><code id="get_ring_+3A_ring_size">ring_size</code></td>
<td>
<p>Character; number of steps away from the central cell.
Defaults to 1.</p>
</td></tr>
<tr><td><code id="get_ring_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element
contains a character vector of H3 cells belonging to that step away from
the input address.
</p>


<h3>Note</h3>

<p>In total, the number of cells returned for each input index is
<code>ring_size * 6</code>. This function will throw an error if there is a
pentagon anywhere in the ring.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># What are the neighbours of this cell at step 2?
get_ring(h3_address = '86be8d12fffffff', ring_size = 2)
</code></pre>

<hr>
<h2 id='get_uddest'>Get destination cell from directed edge</h2><span id='topic+get_uddest'></span>

<h3>Description</h3>

<p>Get an H3 index representing the destination of a directed edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_uddest(h3_edge = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_uddest_+3A_h3_edge">h3_edge</code></td>
<td>
<p>Character; address of unidirectional edge.</p>
</td></tr>
<tr><td><code id="get_uddest_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, character vector of h3 cell indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the destination cell index of this directed edge index
get_uddest(h3_edge = '166be8d12fffffff')

</code></pre>

<hr>
<h2 id='get_udedge'>Get a unidirectional edge index</h2><span id='topic+get_udedge'></span>

<h3>Description</h3>

<p>Returns an H3 index representing a unidirectional edge for a given origin and
destination cell pair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_udedge(origin = NULL, destination = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_udedge_+3A_origin">origin</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A vector of
indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_udedge_+3A_destination">destination</code></td>
<td>
<p>Character; 15-character cell index generated by H3. A vector
of indexes can also be supplied.</p>
</td></tr>
<tr><td><code id="get_udedge_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, character vector of unidirectional edge indexes.
</p>


<h3>Note</h3>

<p>The number of cell indexes supplied to origin and destination must be
equal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the unidirectional edge representing the transition between these two cells:
get_udedge(origin = '86be8d12fffffff', destination = '86be8d127ffffff')

</code></pre>

<hr>
<h2 id='get_udedges'>Get all directed edge indexes for a given H3 cell</h2><span id='topic+get_udedges'></span>

<h3>Description</h3>

<p>Get all directed edge indexes for a given H3 cell index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_udedges(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_udedges_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="get_udedges_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, list of <code>length(h3_address)</code>. Each list contains a
character vector of H3 edge indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get all the edge indexes for this cell
get_udedges(h3_address = '86be8d12fffffff')

</code></pre>

<hr>
<h2 id='get_udends'>Get origin and destination indexes of directed edge</h2><span id='topic+get_udends'></span>

<h3>Description</h3>

<p>Get H3 cell indexes representing the origin and destination of a directed
edge index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_udends(h3_edge = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_udends_+3A_h3_edge">h3_edge</code></td>
<td>
<p>Character; address of unidirectional edge.</p>
</td></tr>
<tr><td><code id="get_udends_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, character matrix of h3 cell indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the origin and destination of this directed edge
get_udends(h3_edge = '166be8d12fffffff')

</code></pre>

<hr>
<h2 id='get_udorigin'>Get origin cell index from directed edge</h2><span id='topic+get_udorigin'></span>

<h3>Description</h3>

<p>Get an H3 cell index representing the origin of a directed edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_udorigin(h3_edge = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_udorigin_+3A_h3_edge">h3_edge</code></td>
<td>
<p>Character; address of unidirectional edge.</p>
</td></tr>
<tr><td><code id="get_udorigin_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, character vector of H3 indexes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the origin cell of this directed edge
get_udorigin(h3_edge = '166be8d12fffffff')

</code></pre>

<hr>
<h2 id='grid_distance'>Grid distance between H3 cells</h2><span id='topic+grid_distance'></span>

<h3>Description</h3>

<p>This function gets the grid distance between two H3 cell indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_distance(origin = NULL, destination = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_distance_+3A_origin">origin</code></td>
<td>
<p>Character vector or list of 15-character indices generated by
H3.</p>
</td></tr>
<tr><td><code id="grid_distance_+3A_destination">destination</code></td>
<td>
<p>Character vector or list of 15-character indices
generated by H3.</p>
</td></tr>
<tr><td><code id="grid_distance_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a list object
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between two H3 cells, expressed as the minimum
number of hexagon 'steps' required to get from the origin to the
destination. Thus, a neighbour cell is one step away, and two cells
with one hexagon between them are two steps apart.
</p>


<h3>Note</h3>

<p>Input H3 indices must be of the same resolution or results cannot be
computed. This function may fail to find the distance between two indices
if they are very far apart or on opposite sides of a pentagon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc_pts &lt;- sf::st_centroid(nc[c(1, 2), ])
nc_6 &lt;- point_to_cell(nc_pts, res = 6)
# how far apart are these two addresses?
grid_distance(nc_6[1], nc_6[2])

## End(Not run)
</code></pre>

<hr>
<h2 id='grid_path'>Path between H3 cells</h2><span id='topic+grid_path'></span>

<h3>Description</h3>

<p>This function returns a path of H3 cells between a start and end cell
(inclusive).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_path(origin = NULL, destination = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_path_+3A_origin">origin</code></td>
<td>
<p>Character vector or list of 15-character indices generated by
H3.</p>
</td></tr>
<tr><td><code id="grid_path_+3A_destination">destination</code></td>
<td>
<p>Character vector or list of 15-character indices
generated by H3.</p>
</td></tr>
<tr><td><code id="grid_path_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a list object
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of h3 cells of form c(origin, c(path), destination).
</p>


<h3>Note</h3>


<ul>
<li><p>Input H3 cells must be of the same resolution or results cannot
be computed. This function may fail to find the distance between two
indexes if they are very far apart or on opposite sides of a pentagon.
</p>
</li>
<li><p>The specific output of this function should not be considered stable
across library versions. The only guarantees the library provides are that
the line length will be <code>h3_distance(start, end) + 1</code> and that every
index in the line will be a neighbor of the preceding index.
</p>
</li>
<li><p>Lines are drawn in grid space, and may not correspond exactly to
either Cartesian lines or great arcs
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc_pts &lt;- sf::st_centroid(nc[c(1, 2), ])
nc_6 &lt;- point_to_cell(nc_pts, res = 6)
# find a path between these two addresses:
grid_path(nc_6[1], nc_6[2], simple = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='h3_info_table'>H3 index utility information table</h2><span id='topic+h3_info_table'></span>

<h3>Description</h3>

<p>A dataset containing information about h3 cell indexes at each resolution,
calculated using H3's built-in functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h3_info_table
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 6 variables: </p>

<dl>
<dt>h3_resolution</dt><dd><p>H3 resolution index number</p>
</dd>
<dt>avg_area_sqm</dt><dd><p>Average area of an H3 cell index at the given
resolution, in square meters.</p>
</dd>
<dt>avg_area_sqkm</dt><dd><p>Average area of an
H3 cell index at the given resolution, in square kilometers.</p>
</dd>
<dt>avg_edge_m</dt><dd><p>Average edge length of an H3 cell index at the given
resolution, in meters.</p>
</dd>
<dt>avg_edge_km</dt><dd><p>Average edge length of an H3
cell index at the given resolution, in kilometers.</p>
</dd>
<dt>avg_cendist_m</dt><dd><p>Average distance between cell centers at the given
resolution, in meters.</p>
</dd>
<dt>avg_cendist_km</dt><dd><p>Average distance between cellcenters at the given
resolution, in kilometers.</p>
</dd>
<dt>total_unique_indexes</dt><dd><p>Total number of H3 cells at the given
resolution.</p>
</dd></dl>



<h3>Source</h3>

<p>See also
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a>
</p>

<hr>
<h2 id='is_pentagon'>check if H3 cell index is a pentagon</h2><span id='topic+is_pentagon'></span>

<h3>Description</h3>

<p>This function checks whether a H3 cell index refers to one of the pentagons
that occur at icosahedron corners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_pentagon(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_pentagon_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="is_pentagon_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a logical vector of <code>length(h3_address)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is the following cell index a pentagon?
is_pentagon(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='is_rc3'>check if H3 cell index is in a Class III resolution</h2><span id='topic+is_rc3'></span>

<h3>Description</h3>

<p>This function checks whether a H3 cell index is in a Class III resolution
(rotated versus the icosahedron and subject to shape distortion adding extra
points on icosahedron edges).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rc3(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rc3_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="is_rc3_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a logical vector of <code>length(h3_address)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is the following cell index Class III?
is_rc3(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='is_valid'>check H3 cell index</h2><span id='topic+is_valid'></span>

<h3>Description</h3>

<p>This function checks whether an H3 cell index is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid(h3_address = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_valid_+3A_h3_address">h3_address</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="is_valid_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a logical vector of <code>length(h3_address)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is the following cell index valid?
is_valid(h3_address = '8abe8d12acaffff')
</code></pre>

<hr>
<h2 id='is_valid_edge'>Check H3 unidirectional edge index</h2><span id='topic+is_valid_edge'></span>

<h3>Description</h3>

<p>This function checks whether an H3 unidirectional edge index is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_edge(h3_edge = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_valid_edge_+3A_h3_edge">h3_edge</code></td>
<td>
<p>Character; address of unidirectional edge.</p>
</td></tr>
<tr><td><code id="is_valid_edge_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a logical vector of <code>length(h3_edge)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is the following unidirectional edge index valid?
is_valid_edge(h3_edge = '166be8d12fffffff')

</code></pre>

<hr>
<h2 id='is_valid_vertex'>check H3 cell index</h2><span id='topic+is_valid_vertex'></span>

<h3>Description</h3>

<p>This function checks whether an H3 cell index is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_vertex(h3_vertex = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_valid_vertex_+3A_h3_vertex">h3_vertex</code></td>
<td>
<p>Character; 15-character index generated by H3.</p>
</td></tr>
<tr><td><code id="is_valid_vertex_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a logical vector of <code>length(h3_vertex)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is the following cell index valid?
is_valid_vertex(h3_vertex = '25abe8d12ac87fff')
</code></pre>

<hr>
<h2 id='num_cells'>Get total H3 cells</h2><span id='topic+num_cells'></span>

<h3>Description</h3>

<p>This function returns total number of H3 cells at a given resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_cells(res = NULL, fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_cells_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="num_cells_+3A_fast">fast</code></td>
<td>
<p>Logical; whether to retrieve values from a locally stored table or
recalculate from source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric; H3 cell count.
</p>


<h3>Note</h3>

<p>Above resolution 8 the exact count cannot be represented in a
JavaScript 32-bit number, so consumers should use caution when applying
further operations to the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return cell count for resolution 8
num_cells(res = 8)

</code></pre>

<hr>
<h2 id='point_to_cell'>Convert point location to H3 cell index</h2><span id='topic+point_to_cell'></span>

<h3>Description</h3>

<p>This function takes point location data and returns a H3 cell index for each
point at the chosen resolution(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_to_cell(input = NULL, res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_to_cell_+3A_input">input</code></td>
<td>
<p><code>sf</code> object with point geometry, <code>sfc_POINT</code> object,
<code>sfg</code> point, data frame or matrix.</p>
</td></tr>
<tr><td><code id="point_to_cell_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="point_to_cell_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return outputs as character vector where
possible.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p>if <code>simple = TRUE</code> and one resolution is requested, a character vector
of H3 addresses.
</p>
</li>
<li> <p>if <code>simple = TRUE</code> and multiple resolutions are requested, a data
frame of H3 addresses.
</p>
</li>
<li> <p>if <code>simple = FALSE</code> and a matrix, sfc or sfg object is supplied, a
data frame of H3 addresses.
</p>
</li>
<li> <p>if <code>simple = FALSE</code> and a data frame or sf object with other
attributes is supplied, a data frame of non-spatial attributes with new
columns containing addresses for one or more H3 resolutions.
</p>
</li></ul>



<h3>Note</h3>

<p>While multiple resolutions can be requested for multiple points, be
aware of the memory demand on large datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># where is the Brisbane Town Hall at resolution 15?
bth &lt;- sf::st_sfc(sf::st_point(c(153.023503, -27.468920)), crs = 4326)
bth_15 &lt;- point_to_cell(bth, res = 15)

# where is it at several resolutions?
bth_many &lt;- point_to_cell(bth, res = seq(10, 15), simple = FALSE)
</code></pre>

<hr>
<h2 id='polygon_to_cells'>Get H3 cell index within a polygon</h2><span id='topic+polygon_to_cells'></span>

<h3>Description</h3>

<p>This function returns all the H3 cell indexes within the supplied polygon
geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygon_to_cells(geometry = NULL, res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polygon_to_cells_+3A_geometry">geometry</code></td>
<td>
<p><code>sf</code> object of type <code>POLYGON</code> or
<code>MULTIPOLYGON</code>.</p>
</td></tr>
<tr><td><code id="polygon_to_cells_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="polygon_to_cells_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or an sf object
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a list of <code>length(h3_address)</code>. Each list element
contains a character vector of H3 cell indices belonging to that geometry.
A result of NA indicates that no H3 cell indices of the chosen resolution
are centered over the geometry.
</p>


<h3>Note</h3>

<p>This function will be slow with a large number of polygons, and/or
polygons that are large relative to the hexagon area at the chosen
resolution. A message is printed to console where the total input area is
(roughly) &gt; 100000x the area of the chosen H3 resolution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Which level 5 H3 cell indices have centers inside County Ashe, NC?
nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc1 &lt;- nc[1, ]
fillers &lt;- polygon_to_cells(geometry = nc1, res = 5)
</code></pre>

<hr>
<h2 id='prep_for_polyfill'>Prepare geometry for polygon_to_cells</h2><span id='topic+prep_for_polyfill'></span><span id='topic+prep_for_polyfill.sf'></span><span id='topic+prep_for_polyfill.sfc'></span><span id='topic+prep_for_polyfill.sfg'></span>

<h3>Description</h3>

<p>Converts a variety of possible input geometries to geojson for
<code><a href="#topic+polygon_to_cells">h3jsr::polygon_to_cells()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_for_polyfill(polys = NULL)

## S3 method for class 'sf'
prep_for_polyfill(polys = NULL)

## S3 method for class 'sfc'
prep_for_polyfill(polys = NULL)

## S3 method for class 'sfg'
prep_for_polyfill(polys = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_for_polyfill_+3A_polys">polys</code></td>
<td>
<p><code>sf</code>, <code>sfc</code> or <code>sfg</code> POLYGON/MULTIPOLYGON object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'geojson' representation of supplied geometry.
</p>

<hr>
<h2 id='prep_for_pt2cell'>Prepare inputs for point_to_cell</h2><span id='topic+prep_for_pt2cell'></span><span id='topic+prep_for_pt2cell.sf'></span><span id='topic+prep_for_pt2cell.sfc'></span><span id='topic+prep_for_pt2cell.sfg'></span><span id='topic+prep_for_pt2cell.matrix'></span><span id='topic+prep_for_pt2cell.data.frame'></span><span id='topic+prep_for_pt2cell.numeric'></span>

<h3>Description</h3>

<p>Sets up a variety of possible input objects for
<code><a href="#topic+point_to_cell">h3jsr::point_to_cell()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_for_pt2cell(input = NULL)

## S3 method for class 'sf'
prep_for_pt2cell(input = NULL)

## S3 method for class 'sfc'
prep_for_pt2cell(input = NULL)

## S3 method for class 'sfg'
prep_for_pt2cell(input = NULL)

## S3 method for class 'matrix'
prep_for_pt2cell(input = NULL)

## S3 method for class 'data.frame'
prep_for_pt2cell(input = NULL)

## S3 method for class 'numeric'
prep_for_pt2cell(input = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_for_pt2cell_+3A_input">input</code></td>
<td>
<p><code>sf</code>, <code>sfc</code> or <code>sfg</code> POINT/MULTIPOINT object,
data frame or matrix. Data frames or matrices must have x, y coordinates in
their first two columns. WGS84 input is assumed in all cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix representation of supplied coordinates.
</p>

<hr>
<h2 id='rads_to_degs'>Convert radians to degrees</h2><span id='topic+rads_to_degs'></span>

<h3>Description</h3>

<p>Convert radians to degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rads_to_degs(radian = NULL, lang = c("r", "h3"), simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rads_to_degs_+3A_radian">radian</code></td>
<td>
<p>Numeric, value in radians</p>
</td></tr>
<tr><td><code id="rads_to_degs_+3A_lang">lang</code></td>
<td>
<p>Character; whether to perform the conversion using base R
or the H3 library. Defaults to R for speed.</p>
</td></tr>
<tr><td><code id="rads_to_degs_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, value in degrees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rads_to_degs(1.5)
</code></pre>

<hr>
<h2 id='res_area'>Get average cell area</h2><span id='topic+res_area'></span>

<h3>Description</h3>

<p>This function returns the average area of an H3 cell at a given
resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res_area(res = NULL, units = c("m2", "km2"), fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res_area_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="res_area_+3A_units">units</code></td>
<td>
<p>Areal unit to report in. Options are square meters or square
kilometers.</p>
</td></tr>
<tr><td><code id="res_area_+3A_fast">fast</code></td>
<td>
<p>Logical; whether to retrieve values from a locally stored table or
reclaculate from source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric; average H3 cell area.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return average H3 cell area at each resolution in square meters
res_area(res = seq(0, 15), units = 'm2')

</code></pre>

<hr>
<h2 id='res_cendist'>Get average distance between H3 cell centers</h2><span id='topic+res_cendist'></span>

<h3>Description</h3>

<p>This function returns the average distance between the center of H3 cells
at a given resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res_cendist(res = NULL, units = c("m", "km"), fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res_cendist_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="res_cendist_+3A_units">units</code></td>
<td>
<p>Length unit to report in, either meters or kilometers.</p>
</td></tr>
<tr><td><code id="res_cendist_+3A_fast">fast</code></td>
<td>
<p>Logical; whether to retrieve values from a locally stored table or
recalculate from source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric; H3 cell center separation distance.
</p>


<h3>Note</h3>

<p>This isn't in the core library but may be useful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return average H3 cell separation distance at each resolution in kilometers
res_cendist(res = seq(0, 15), units = 'km')

</code></pre>

<hr>
<h2 id='res_length'>Get average cell edge length</h2><span id='topic+res_length'></span>

<h3>Description</h3>

<p>This function returns the average edge length of an H3 cell edge at a given
resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res_length(res = NULL, units = c("m", "km"), fast = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res_length_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="res_length_+3A_units">units</code></td>
<td>
<p>Length unit to report in. Options are meters or kilometers.</p>
</td></tr>
<tr><td><code id="res_length_+3A_fast">fast</code></td>
<td>
<p>Logical; whether to retrieve values from a locally stored table
or recalculate from source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric; H3 cell edge length
</p>


<h3>Note</h3>

<p>This value is also the hexagon circumradius.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return average H3 cell edge length at each resolution in kilometers
res_length(res = seq(0, 15), units = 'km')

</code></pre>

<hr>
<h2 id='splitlong_to_cell'>Split long to H3 cell</h2><span id='topic+splitlong_to_cell'></span>

<h3>Description</h3>

<p>Convert a &quot;split long&quot; - a pair of 32-bit integers - into an H3 cell index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitlong_to_cell(split_lower = NULL, split_upper = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitlong_to_cell_+3A_split_lower">split_lower</code></td>
<td>
<p>Integer; Lower 32 bits of an H3 index.</p>
</td></tr>
<tr><td><code id="splitlong_to_cell_+3A_split_upper">split_upper</code></td>
<td>
<p>Integer; Upper 32 bits of an H3 index.</p>
</td></tr>
<tr><td><code id="splitlong_to_cell_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector or a data frame containing
both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of H3 addresses, one for each split long pair supplied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cell_to_splitlong(h3_address = '8abe8d12acaffff')

splitlong_to_cell(split_lower = x[[1]][1], split_upper = x[[1]][2])
</code></pre>

<hr>
<h2 id='udedge_to_line'>Get the geometry of an H3 edge</h2><span id='topic+udedge_to_line'></span>

<h3>Description</h3>

<p>This function takes an H3 unidirectional edge address and returns the
coordinates of its geometry in WGS84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udedge_to_line(h3_edge = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="udedge_to_line_+3A_h3_edge">h3_edge</code></td>
<td>
<p>Character; address of unidirectional edge.</p>
</td></tr>
<tr><td><code id="udedge_to_line_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an object of type 'sfc_LINESTRING'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get me the shape of this edge
udedge_to_line(h3_edge = '166be8d12fffffff')

</code></pre>

<hr>
<h2 id='uncompact'>Uncompact H3 cell indices</h2><span id='topic+uncompact'></span>

<h3>Description</h3>

<p>This function uncompacts a compacted set of H3 cells to indices of the
target resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncompact(h3_addresses = NULL, res = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncompact_+3A_h3_addresses">h3_addresses</code></td>
<td>
<p>Character vector or list of 15-character cell indices
generated by H3.</p>
</td></tr>
<tr><td><code id="uncompact_+3A_res">res</code></td>
<td>
<p>Integer; Desired H3 resolution. See
<a href="https://h3geo.org/docs/core-library/restable/">https://h3geo.org/docs/core-library/restable/</a> for allowable values and related dimensions.</p>
</td></tr>
<tr><td><code id="uncompact_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a list object
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of H3 cell indices of the chosen resolution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Give me a compacted representation of County Ashe, NC
nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"), quiet = TRUE)
nc1 &lt;- nc[1, ]
nc1 &lt;- sf::st_cast(nc1, 'POLYGON')
fillers &lt;- polygon_to_cells(geometry = nc1, res = 6)
compacted &lt;- compact(fillers)
# uncompact to resolution 7
uncompacted &lt;- uncompact(compacted, res = 7)

## End(Not run)
</code></pre>

<hr>
<h2 id='vertex_to_point'>Convert H3 cell vertex index to point location</h2><span id='topic+vertex_to_point'></span>

<h3>Description</h3>

<p>This function takes a H3 cell vertex index and returns its coordinates in
WGS84.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_to_point(h3_vertex = NULL, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_to_point_+3A_h3_vertex">h3_vertex</code></td>
<td>
<p>Character; vertex address or addresses.</p>
</td></tr>
<tr><td><code id="vertex_to_point_+3A_simple">simple</code></td>
<td>
<p>Logical; whether to return a vector of outputs or a data frame
containing both inputs and outputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, an <code>sfc_POINT</code> object of <code>length(h3_address)</code>.
EPSG:WGS84.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert this vertex to a point
vertex_to_point('246be8d127ffffff')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
