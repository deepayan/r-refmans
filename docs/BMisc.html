<!DOCTYPE html><html><head><title>Help for package BMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addCovToFormla'><p>Add a Covariate to a Formula</p></a></li>
<li><a href='#blockBootSample'><p>Block Bootstrap</p></a></li>
<li><a href='#BMisc'><p>BMisc</p></a></li>
<li><a href='#checkfun'><p>Check Function</p></a></li>
<li><a href='#combineDfs'><p>Combine Two Distribution Functions</p></a></li>
<li><a href='#compareBinary'><p>Compare Variables across Groups</p></a></li>
<li><a href='#compareSingleBinary'><p>Compare a single variable across two groups</p></a></li>
<li><a href='#cs2panel'><p>Cross Section to Panel</p></a></li>
<li><a href='#dropCovFromFormla'><p>Drop a Covariate from a Formula</p></a></li>
<li><a href='#element_wise_mult'><p>element_wise_mult</p></a></li>
<li><a href='#get_first_difference'><p>get_first_difference</p></a></li>
<li><a href='#get_group'><p>get_group</p></a></li>
<li><a href='#get_group_inner'><p>get_group_inner</p></a></li>
<li><a href='#get_lagYi'><p>get_lagYi</p></a></li>
<li><a href='#get_Yi1'><p>get_Yi1</p></a></li>
<li><a href='#get_Yi1_inner'><p>get_Yi1_inner</p></a></li>
<li><a href='#get_Yibar'><p>get_Yibar</p></a></li>
<li><a href='#get_Yibar_inner'><p>get_Yibar_inner</p></a></li>
<li><a href='#get_Yibar_pre'><p>get_Yibar_pre</p></a></li>
<li><a href='#get_Yibar_pre_inner'><p>get_Yibar_pre_inner</p></a></li>
<li><a href='#get_YiGmin1'><p>get_YiGmin1</p></a></li>
<li><a href='#get_YiGmin1_inner'><p>get_YiGmin1_inner</p></a></li>
<li><a href='#get_Yit'><p>get_Yit</p></a></li>
<li><a href='#get_Yit_inner'><p>get_Yit_inner</p></a></li>
<li><a href='#getListElement'><p>Return Particular Element from Each Element in a List</p></a></li>
<li><a href='#getWeightedDf'><p>Weighted Distribution Function</p></a></li>
<li><a href='#getWeightedMean'><p>Weighted Mean</p></a></li>
<li><a href='#getWeightedQuantile'><p>Quantile of a Weighted Check Function</p></a></li>
<li><a href='#getWeightedQuantiles'><p>Get Weighted Quantiles</p></a></li>
<li><a href='#id2rownum'><p>Take particular id and convert to row number</p></a></li>
<li><a href='#ids2rownum'><p>Convert Vector of ids into Vector of Row Numbers</p></a></li>
<li><a href='#invertEcdf'><p>Invert Ecdf</p></a></li>
<li><a href='#lhs.vars'><p>Left-hand Side Variables</p></a></li>
<li><a href='#makeBalancedPanel'><p>Balance a Panel Data Set</p></a></li>
<li><a href='#makeDist'><p>Make a Distribution Function</p></a></li>
<li><a href='#multiplier_bootstrap'><p>multiplier_bootstrap</p></a></li>
<li><a href='#panel2cs'><p>Panel Data to Repeated Cross Sections</p></a></li>
<li><a href='#panel2cs2'><p>Panel Data to Repeated Cross Sections</p></a></li>
<li><a href='#rhs'><p>Right-hand Side of Formula</p></a></li>
<li><a href='#rhs.vars'><p>Right-hand Side Variables</p></a></li>
<li><a href='#source_all'><p>source_all</p></a></li>
<li><a href='#subsample'><p>Subsample of Observations from Panel Data</p></a></li>
<li><a href='#toformula'><p>Variable Names to Formula</p></a></li>
<li><a href='#TorF'><p>TorF</p></a></li>
<li><a href='#weighted.checkfun'><p>Weighted Check Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions for Panel Data, Quantiles, and Printing
Results</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>These are miscellaneous functions for working with panel data, quantiles, and printing results.  For panel data, the package includes functions for making a panel data balanced (that is, dropping missing individuals that have missing observations in any time period), converting id numbers to row numbers, and to treat repeated cross sections as panel data under the assumption of rank invariance.  For quantiles, there are functions to make distribution functions from a set of data points (this is particularly useful when a distribution function is created in several steps), to combine distribution functions based on some external weights, and to invert distribution functions.  Finally, there are several other miscellaneous functions for obtaining weighted means, weighted distribution functions, and weighted quantiles; to generate summary statistics and their differences for two groups; and to add or drop covariates from formulas.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), plm, tibble</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bcallaway11.github.io/BMisc/">https://bcallaway11.github.io/BMisc/</a>,
<a href="https://github.com/bcallaway11/BMisc">https://github.com/bcallaway11/BMisc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bcallaway11/BMisc/issues">https://github.com/bcallaway11/BMisc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-08 19:50:07 UTC; bmc43193</td>
</tr>
<tr>
<td>Author:</td>
<td>Brantly Callaway [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brantly Callaway &lt;brantly.callaway@uga.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-09 16:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='addCovToFormla'>Add a Covariate to a Formula</h2><span id='topic+addCovToFormla'></span>

<h3>Description</h3>

<p><code>addCovFromFormla</code> adds some covariates to a formula;
covs should be a list of variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCovToFormla(covs, formla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCovToFormla_+3A_covs">covs</code></td>
<td>
<p>should be a list of variable names</p>
</td></tr>
<tr><td><code id="addCovToFormla_+3A_formla">formla</code></td>
<td>
<p>which formula to add covariates to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formla &lt;- y ~ x
addCovToFormla(list("w","z"), formla)

formla &lt;- ~x
addCovToFormla("z", formla)

</code></pre>

<hr>
<h2 id='blockBootSample'>Block Bootstrap</h2><span id='topic+blockBootSample'></span>

<h3>Description</h3>

<p>make draws of all observations with the same id in a panel
data context.  This is useful for bootstrapping with panel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBootSample(data, idname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockBootSample_+3A_data">data</code></td>
<td>
<p>data.frame from which you want to bootstrap</p>
</td></tr>
<tr><td><code id="blockBootSample_+3A_idname">idname</code></td>
<td>
<p>column in data which contains an individual identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame bootstrapped from the original dataset; this data.frame
will contain new ids
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("LaborSupply", package="plm")
bbs &lt;- blockBootSample(LaborSupply, "id")
nrow(bbs)
head(bbs$id)

</code></pre>

<hr>
<h2 id='BMisc'>BMisc</h2><span id='topic+BMisc'></span>

<h3>Description</h3>

<p>A set of miscellaneous helper functions
</p>

<hr>
<h2 id='checkfun'>Check Function</h2><span id='topic+checkfun'></span>

<h3>Description</h3>

<p>The check function used for optimizing to get quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkfun(a, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkfun_+3A_a">a</code></td>
<td>
<p>vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="checkfun_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
x[which.min(checkfun(x, 0.5))] ##should be around 0

</code></pre>

<hr>
<h2 id='combineDfs'>Combine Two Distribution Functions</h2><span id='topic+combineDfs'></span>

<h3>Description</h3>

<p>Combines two distribution functions with given weights by pstrat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineDfs(y.seq, dflist, pstrat = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineDfs_+3A_y.seq">y.seq</code></td>
<td>
<p>sequence of possible y values</p>
</td></tr>
<tr><td><code id="combineDfs_+3A_dflist">dflist</code></td>
<td>
<p>list of distribution functions to combine</p>
</td></tr>
<tr><td><code id="combineDfs_+3A_pstrat">pstrat</code></td>
<td>
<p>a vector of weights to put on each distribution function;
if weights are not provided then equal weight is given to each
distribution function</p>
</td></tr>
<tr><td><code id="combineDfs_+3A_...">...</code></td>
<td>
<p>additional arguments that can be past to BMisc::makeDist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ecdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100,1,1)
Fx &lt;- ecdf(x)
Fy &lt;- ecdf(y)
both &lt;- combineDfs(seq(-2,3,0.1), list(Fx,Fy))
plot(Fx, col="green")
plot(Fy, col="blue", add=TRUE)
plot(both, add=TRUE)

</code></pre>

<hr>
<h2 id='compareBinary'>Compare Variables across Groups</h2><span id='topic+compareBinary'></span>

<h3>Description</h3>

<p><code>compareBinary</code> takes in a variable e.g. union
and runs bivariate regression of x on treatment (for summary statistics)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareBinary(
  x,
  on,
  dta,
  w = rep(1, nrow(dta)),
  report = c("diff", "levels", "both")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareBinary_+3A_x">x</code></td>
<td>
<p>variables to run regression on</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_on">on</code></td>
<td>
<p>binary variable</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_dta">dta</code></td>
<td>
<p>the data to use</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_report">report</code></td>
<td>
<p>which type of report to make; diff is the difference between
the two variables by group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of results
</p>

<hr>
<h2 id='compareSingleBinary'>Compare a single variable across two groups</h2><span id='topic+compareSingleBinary'></span>

<h3>Description</h3>

<p><code>compareBinary</code> takes in a variable e.g. union
and runs bivariate regression of x on treatment (for summary statistics)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareSingleBinary(
  x,
  on,
  dta,
  w = rep(1, nrow(dta)),
  report = c("diff", "levels", "both")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareSingleBinary_+3A_x">x</code></td>
<td>
<p>variables to run regression on</p>
</td></tr>
<tr><td><code id="compareSingleBinary_+3A_on">on</code></td>
<td>
<p>binary variable</p>
</td></tr>
<tr><td><code id="compareSingleBinary_+3A_dta">dta</code></td>
<td>
<p>the data to use</p>
</td></tr>
<tr><td><code id="compareSingleBinary_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="compareSingleBinary_+3A_report">report</code></td>
<td>
<p>which type of report to make; diff is the difference between
the two variables by group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of results
</p>

<hr>
<h2 id='cs2panel'>Cross Section to Panel</h2><span id='topic+cs2panel'></span>

<h3>Description</h3>

<p>Turn repeated cross sections data into panel data by
imposing rank invariance; does not require
that the inputs have the same length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs2panel(cs1, cs2, yname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs2panel_+3A_cs1">cs1</code></td>
<td>
<p>data frame, the first cross section</p>
</td></tr>
<tr><td><code id="cs2panel_+3A_cs2">cs2</code></td>
<td>
<p>data frame, the second cross section</p>
</td></tr>
<tr><td><code id="cs2panel_+3A_yname">yname</code></td>
<td>
<p>the name of the variable to calculate difference for (should be the same in each dataset)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the change in outcomes over time
</p>

<hr>
<h2 id='dropCovFromFormla'>Drop a Covariate from a Formula</h2><span id='topic+dropCovFromFormla'></span>

<h3>Description</h3>

<p><code>dropCovFromFormla</code> adds drops some covariates from a
formula; covs should be a list of variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropCovFromFormla(covs, formla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropCovFromFormla_+3A_covs">covs</code></td>
<td>
<p>should be a list of variable names</p>
</td></tr>
<tr><td><code id="dropCovFromFormla_+3A_formla">formla</code></td>
<td>
<p>which formula to drop covariates from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>formla &lt;- y ~ x + w + z
dropCovFromFormla(list("w","z"), formla)

dropCovFromFormla("z", formla)

</code></pre>

<hr>
<h2 id='element_wise_mult'>element_wise_mult</h2><span id='topic+element_wise_mult'></span>

<h3>Description</h3>

<p>This is a function that takes in two matrices of dimension
nxB and nxk and returns a Bxk matrix that comes from
element-wise multiplication of every column
in the first matrix times the entire second matrix and the
averaging over the n-dimension.  It is equivalent (but faster
than) the following R code:
'sapply(1:biters, function(b) sqrt(n)*colMeans(Umat[,b]*inf.func))'
.  This function is particularly useful for fast computations
using the multiplier bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_wise_mult(U, inf_func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element_wise_mult_+3A_u">U</code></td>
<td>
<p>nxB matrix (e.g., these could be a matrix of
Rademachar weights for B bootstrap iterations using the
multiplier bootstrap</p>
</td></tr>
<tr><td><code id="element_wise_mult_+3A_inf_func">inf_func</code></td>
<td>
<p>nxk matrix of (e.g., these could be a matrix
containing the influence function for different parameter
estimates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Bxk matrix
</p>

<hr>
<h2 id='get_first_difference'>get_first_difference</h2><span id='topic+get_first_difference'></span>

<h3>Description</h3>

<p>A function that calculates the first difference in a panel data
setting.  If the data.frame that is passed in has nxT rows, the resulting
vector will also have nxT elements with one element for each unit set to be
NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_first_difference(df, idname, yname, tname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_first_difference_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_first_difference_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_first_difference_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_first_difference_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
</table>

<hr>
<h2 id='get_group'>get_group</h2><span id='topic+get_group'></span>

<h3>Description</h3>

<p>A function to calculate a unit's group in a panel data setting
with a binary treatment and staggered treatment adoption and where
there is a column in the data indicating whether or not a unit is treated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group(df, idname, tname, treatname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_group_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_group_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_group_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_group_+3A_treatname">treatname</code></td>
<td>
<p>name of column with the treatment indicator</p>
</td></tr>
</table>

<hr>
<h2 id='get_group_inner'>get_group_inner</h2><span id='topic+get_group_inner'></span>

<h3>Description</h3>

<p>Calculates the group for a particular unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group_inner(this_df, tname, treatname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_group_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_group_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_group_inner_+3A_treatname">treatname</code></td>
<td>
<p>name of column with the treatment indicator</p>
</td></tr>
</table>

<hr>
<h2 id='get_lagYi'>get_lagYi</h2><span id='topic+get_lagYi'></span>

<h3>Description</h3>

<p>A function that calculates lagged outcomes in a panel data setting.
If the data.frame that is passed in has nxT rows, the resulting vector will
also have nxT elements with one element for each unit set to be NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lagYi(df, idname, yname, tname, nlags = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lagYi_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_nlags">nlags</code></td>
<td>
<p>The number of periods to lag.  The default is 1, which computes
the lag from the previous period.</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yi1'>get_Yi1</h2><span id='topic+get_Yi1'></span>

<h3>Description</h3>

<p>A function to calculate outcomes for units in the first time
period that is available in a panel data setting (this function can also
be used to recover covariates, etc. in the first period).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yi1(df, idname, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yi1_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yi1_inner'>get_Yi1_inner</h2><span id='topic+get_Yi1_inner'></span>

<h3>Description</h3>

<p>Calculates a units outcome in the first time period.
This function operates on a data.frame that is already local to a particular
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yi1_inner(this_df, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yi1_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yi1_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yi1_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yi1_inner_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar'>get_Yibar</h2><span id='topic+get_Yibar'></span>

<h3>Description</h3>

<p>A function to calculate the average outcome across all time
periods separately for each unit in a panel data setting (this function can also
be used to recover covariates, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar(df, idname, yname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yibar_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yibar_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yibar_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar_inner'>get_Yibar_inner</h2><span id='topic+get_Yibar_inner'></span>

<h3>Description</h3>

<p>Calculates a units average outcome across all periods.
This function operates on a data.frame that is already local to a particular
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar_inner(this_df, yname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yibar_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yibar_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar_pre'>get_Yibar_pre</h2><span id='topic+get_Yibar_pre'></span>

<h3>Description</h3>

<p>A function to calculate average outcomes for units in
their pre-treatment periods (this function can also be used to recover
pre-treatment averages of covariates, etc.).
For units that do not
participate in the treatment (and therefore have group==0), the
function calculates their overall average outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar_pre(df, idname, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yibar_pre_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar_pre_inner'>get_Yibar_pre_inner</h2><span id='topic+get_Yibar_pre_inner'></span>

<h3>Description</h3>

<p>Calculates a unit's average outcome in pre-treatment periods
(or also can be used for a covariate).  The unit's group must
be specified at this point.  This function operates on a data.frame
that is already local to a particular unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar_pre_inner(this_df, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yibar_pre_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_inner_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_YiGmin1'>get_YiGmin1</h2><span id='topic+get_YiGmin1'></span>

<h3>Description</h3>

<p>A function to calculate outcomes for units in the period
right before they become treated (this function can also be used to recover
covariates, etc. in the period right before a unit becomes treated).
For units that do not
participate in the treatment (and therefore have group==0), they are
assigned their outcome in the last period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_YiGmin1(df, idname, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_YiGmin1_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_YiGmin1_inner'>get_YiGmin1_inner</h2><span id='topic+get_YiGmin1_inner'></span>

<h3>Description</h3>

<p>Calculates a units outcome (or also can be used for a covariate)
in the period right before it becomes treated.  The unit's group must
be specified at this point.  This function operates on a data.frame
that is already local to a particular unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_YiGmin1_inner(this_df, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_YiGmin1_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_YiGmin1_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_inner_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yit'>get_Yit</h2><span id='topic+get_Yit'></span>

<h3>Description</h3>

<p>A function to calculate outcomes for units in a particular
time period 'tp' in a panel data setting (this function can also
be used to recover covariates, etc. in the first period).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yit(df, tp, idname, yname, tname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yit_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_tp">tp</code></td>
<td>
<p>The time period for which to get the outcome</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of outcomes in period t, the vector
will have the length nT (i.e., this is returned for
each element in the panel, not for a particular period)
</p>

<hr>
<h2 id='get_Yit_inner'>get_Yit_inner</h2><span id='topic+get_Yit_inner'></span>

<h3>Description</h3>

<p>Calculates a units outcome in some particular period 'tp'.
This function operates on a data.frame that is already local to a particular
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yit_inner(this_df, tp, yname, tname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Yit_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yit_inner_+3A_tp">tp</code></td>
<td>
<p>The time period for which to get the outcome</p>
</td></tr>
<tr><td><code id="get_Yit_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yit_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
</table>

<hr>
<h2 id='getListElement'>Return Particular Element from Each Element in a List</h2><span id='topic+getListElement'></span>

<h3>Description</h3>

<p>a function to take a list and get a particular part
out of each element in the list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getListElement(listolists, whichone = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getListElement_+3A_listolists">listolists</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="getListElement_+3A_whichone">whichone</code></td>
<td>
<p>which item to get out of each list (can be numeric or name)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of all the elements 'whichone' from each list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>len &lt;- 100 # number elements in list
lis &lt;- lapply(1:len, function(l) list(x=(-l), y=l^2) ) # create list
getListElement(lis, "x")[1] # should be equal to -1
getListElement(lis, 1)[1] # should be equal to -1

</code></pre>

<hr>
<h2 id='getWeightedDf'>Weighted Distribution Function</h2><span id='topic+getWeightedDf'></span>

<h3>Description</h3>

<p>Get a distribution function from a vector of values
after applying some weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedDf(y, y.seq = NULL, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeightedDf_+3A_y">y</code></td>
<td>
<p>a vector to compute the mean for</p>
</td></tr>
<tr><td><code id="getWeightedDf_+3A_y.seq">y.seq</code></td>
<td>
<p>an optional vector of values to compute the distribution function
for; the default is to use all unique values of y</p>
</td></tr>
<tr><td><code id="getWeightedDf_+3A_weights">weights</code></td>
<td>
<p>the vector of weights, can be NULL, then will just return mean</p>
</td></tr>
<tr><td><code id="getWeightedDf_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ecdf
</p>

<hr>
<h2 id='getWeightedMean'>Weighted Mean</h2><span id='topic+getWeightedMean'></span>

<h3>Description</h3>

<p>Get the mean applying some weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedMean(y, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeightedMean_+3A_y">y</code></td>
<td>
<p>a vector to compute the mean for</p>
</td></tr>
<tr><td><code id="getWeightedMean_+3A_weights">weights</code></td>
<td>
<p>the vector of weights, can be NULL, then will just return mean</p>
</td></tr>
<tr><td><code id="getWeightedMean_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the weighted mean
</p>

<hr>
<h2 id='getWeightedQuantile'>Quantile of a Weighted Check Function</h2><span id='topic+getWeightedQuantile'></span>

<h3>Description</h3>

<p>Finds the quantile by optimizing the weighted check function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedQuantile(tau, cvec, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeightedQuantile_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
<tr><td><code id="getWeightedQuantile_+3A_cvec">cvec</code></td>
<td>
<p>a vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="getWeightedQuantile_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
<tr><td><code id="getWeightedQuantile_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>

<hr>
<h2 id='getWeightedQuantiles'>Get Weighted Quantiles</h2><span id='topic+getWeightedQuantiles'></span>

<h3>Description</h3>

<p>Finds multiple quantiles by repeatedly calling
getWeightedQuantile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedQuantiles(tau, cvec, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWeightedQuantiles_+3A_tau">tau</code></td>
<td>
<p>a vector of values between 0 and 1</p>
</td></tr>
<tr><td><code id="getWeightedQuantiles_+3A_cvec">cvec</code></td>
<td>
<p>a vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="getWeightedQuantiles_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
<tr><td><code id="getWeightedQuantiles_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of quantiles
</p>

<hr>
<h2 id='id2rownum'>Take particular id and convert to row number</h2><span id='topic+id2rownum'></span>

<h3>Description</h3>

<p>id2rownum takes an id and converts it to the right
row number in the dataset; ids should be unique in the dataset
that is, don't pass the function panel data with multiple same ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id2rownum(id, data, idname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id2rownum_+3A_id">id</code></td>
<td>
<p>a particular id</p>
</td></tr>
<tr><td><code id="id2rownum_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="id2rownum_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
</table>

<hr>
<h2 id='ids2rownum'>Convert Vector of ids into Vector of Row Numbers</h2><span id='topic+ids2rownum'></span>

<h3>Description</h3>

<p>ids2rownum takes a vector of ids and converts it to the right
row number in the dataset; ids should be unique in the dataset
that is, don't pass the function panel data with multiple same ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ids2rownum(ids, data, idname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ids2rownum_+3A_ids">ids</code></td>
<td>
<p>vector of ids</p>
</td></tr>
<tr><td><code id="ids2rownum_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="ids2rownum_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of row numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ids &lt;- seq(1,1000,length.out=100)
ids &lt;- ids[order(runif(100))]
df &lt;- data.frame(id=ids)
ids2rownum(df$id, df, "id")

</code></pre>

<hr>
<h2 id='invertEcdf'>Invert Ecdf</h2><span id='topic+invertEcdf'></span>

<h3>Description</h3>

<p>take an ecdf object and invert it to get a step-quantile
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertEcdf(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invertEcdf_+3A_df">df</code></td>
<td>
<p>an ecdf object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stepfun object that contains the quantiles of the df
</p>

<hr>
<h2 id='lhs.vars'>Left-hand Side Variables</h2><span id='topic+lhs.vars'></span>

<h3>Description</h3>

<p>Take a formula and return a vector of the variables
on the left hand side, it will return NULL for a one sided formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs.vars(formla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lhs.vars_+3A_formla">formla</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- yvar ~ x1 + x2
lhs.vars(ff)
</code></pre>

<hr>
<h2 id='makeBalancedPanel'>Balance a Panel Data Set</h2><span id='topic+makeBalancedPanel'></span>

<h3>Description</h3>

<p>This function drops observations from data.frame
that are not part of balanced panel data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBalancedPanel(data, idname, tname, return_data.table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBalancedPanel_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="makeBalancedPanel_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="makeBalancedPanel_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
<tr><td><code id="makeBalancedPanel_+3A_return_data.table">return_data.table</code></td>
<td>
<p>if TRUE, makeBalancedPanel will
return a data.table rather than a data.frame.  Default
is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame that is a balanced panel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- rep(seq(1,100), each = 2) # individual ids for setting up a two period panel
t &lt;- rep(seq(1,2),100) # time periods
y &lt;- rnorm(200) # outcomes
dta &lt;- data.frame(id=id, t=t, y=y) # make into data frame
dta &lt;- dta[-7,] # drop the 7th row from the dataset (which creates an unbalanced panel)
dta &lt;- makeBalancedPanel(dta, idname="id", tname="t")

</code></pre>

<hr>
<h2 id='makeDist'>Make a Distribution Function</h2><span id='topic+makeDist'></span>

<h3>Description</h3>

<p>turn vectors of a values and their distribution function values
into an ecdf.  Vectors should be the same length and both increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDist(
  x,
  Fx,
  sorted = FALSE,
  rearrange = FALSE,
  force01 = FALSE,
  method = "constant"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDist_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="makeDist_+3A_fx">Fx</code></td>
<td>
<p>vector of the distribution function values</p>
</td></tr>
<tr><td><code id="makeDist_+3A_sorted">sorted</code></td>
<td>
<p>boolean indicating whether or not x is already sorted;
computation is somewhat faster if already sorted</p>
</td></tr>
<tr><td><code id="makeDist_+3A_rearrange">rearrange</code></td>
<td>
<p>boolean indicating whether or not should monotize
distribution function</p>
</td></tr>
<tr><td><code id="makeDist_+3A_force01">force01</code></td>
<td>
<p>boolean indicating whether or not to force the values of
the distribution function (i.e. Fx) to be between 0 and 1</p>
</td></tr>
<tr><td><code id="makeDist_+3A_method">method</code></td>
<td>
<p>which method to pass to <code>approxfun</code> to approximate the
distribution function.  Default is &quot;constant&quot;; other possible choice is
&quot;linear&quot;.  &quot;constant&quot; returns a step function, just like an empirical
cdf; &quot;linear&quot; linearly interpolates between neighboring points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ecdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(100)
y &lt;- y[order(y)]
u &lt;- runif(100)
u &lt;- u[order(u)]
F &lt;- makeDist(y,u)

</code></pre>

<hr>
<h2 id='multiplier_bootstrap'>multiplier_bootstrap</h2><span id='topic+multiplier_bootstrap'></span>

<h3>Description</h3>

<p>A function that takes in an influence function (an
nxk matrix) and the number of bootstrap iterations and
returns a Bxk matrix of bootstrap results. This function
uses Rademechar weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplier_bootstrap(inf_func, biters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplier_bootstrap_+3A_inf_func">inf_func</code></td>
<td>
<p>nxk matrix of (e.g., these could be a matrix
containing the influence function for different parameter
estimates)</p>
</td></tr>
<tr><td><code id="multiplier_bootstrap_+3A_biters">biters</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Bxk matrix
</p>

<hr>
<h2 id='panel2cs'>Panel Data to Repeated Cross Sections</h2><span id='topic+panel2cs'></span>

<h3>Description</h3>

<p>panel2cs takes a 2 period dataset and turns it
into a cross sectional dataset.  The data includes the
change in time varying variables between the
time periods.  The default functionality
is to keep all the variables from period 1
and add all the variables listed by name in timevars
from period 2 to those.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel2cs(data, timevars, idname, tname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel2cs_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="panel2cs_+3A_timevars">timevars</code></td>
<td>
<p>vector of names of variables to keep</p>
</td></tr>
<tr><td><code id="panel2cs_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="panel2cs_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='panel2cs2'>Panel Data to Repeated Cross Sections</h2><span id='topic+panel2cs2'></span>

<h3>Description</h3>

<p>panel2cs2 takes a 2 period dataset and turns it
into a cross sectional dataset; i.e., long to wide.
This function considers a particular case where there is some outcome
whose value can change over time.  It returns the dataset from the first
period with the outcome in the second period and the change in outcomes
over time appended to it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel2cs2(data, yname, idname, tname, balance_panel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel2cs2_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_yname">yname</code></td>
<td>
<p>name of outcome variable that can change over time</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_balance_panel">balance_panel</code></td>
<td>
<p>whether to ensure that panel is balanced.  Default is TRUE, but code runs somewhat
faster if this is set to be FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data from first period with .y0 (outcome in first period),
.y1 (outcome in second period), and .dy (change in outcomes
over time) appended to it
</p>

<hr>
<h2 id='rhs'>Right-hand Side of Formula</h2><span id='topic+rhs'></span>

<h3>Description</h3>

<p>Take a formula and return the right hand side
of the formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhs(formla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhs_+3A_formla">formla</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one sided formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- yvar ~ x1 + x2
rhs(ff)

</code></pre>

<hr>
<h2 id='rhs.vars'>Right-hand Side Variables</h2><span id='topic+rhs.vars'></span>

<h3>Description</h3>

<p>Take a formula and return a vector of the variables
on the right hand side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhs.vars(formla)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhs.vars_+3A_formla">formla</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- yvar ~ x1 + x2
rhs.vars(ff)

ff &lt;- y ~ x1 + I(x1^2)
rhs.vars(ff)

</code></pre>

<hr>
<h2 id='source_all'>source_all</h2><span id='topic+source_all'></span>

<h3>Description</h3>

<p>Source all the files in a folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_all(fldr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="source_all_+3A_fldr">fldr</code></td>
<td>
<p>path to a folder</p>
</td></tr>
</table>

<hr>
<h2 id='subsample'>Subsample of Observations from Panel Data</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>returns a subsample of a panel data set; in particular drops
all observations that are not in <code>keepids</code>.  If it is not set,
randomly keeps <code>nkeep</code> observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(dta, idname, tname, keepids = NULL, nkeep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsample_+3A_dta">dta</code></td>
<td>
<p>a data.frame which is a balanced panel</p>
</td></tr>
<tr><td><code id="subsample_+3A_idname">idname</code></td>
<td>
<p>the name of the id variable</p>
</td></tr>
<tr><td><code id="subsample_+3A_tname">tname</code></td>
<td>
<p>the name of the time variable</p>
</td></tr>
<tr><td><code id="subsample_+3A_keepids">keepids</code></td>
<td>
<p>which ids to keep</p>
</td></tr>
<tr><td><code id="subsample_+3A_nkeep">nkeep</code></td>
<td>
<p>how many ids to keep (only used if <code>keepids</code>
is not set); the default is the number of unique ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame that contains a subsample of <code>dta</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("LaborSupply", package="plm")
nrow(LaborSupply)
unique(LaborSupply$year)
ss &lt;- subsample(LaborSupply, "id", "year", nkeep=100)
nrow(ss)

</code></pre>

<hr>
<h2 id='toformula'>Variable Names to Formula</h2><span id='topic+toformula'></span>

<h3>Description</h3>

<p>take a name for a y variable and a vector of names
for x variables and turn them into a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toformula(yname, xnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toformula_+3A_yname">yname</code></td>
<td>
<p>the name of the y variable</p>
</td></tr>
<tr><td><code id="toformula_+3A_xnames">xnames</code></td>
<td>
<p>vector of names for x variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toformula("yvar", c("x1","x2"))

## should return yvar ~ 1
toformula("yvar", rhs.vars(~1))

</code></pre>

<hr>
<h2 id='TorF'>TorF</h2><span id='topic+TorF'></span>

<h3>Description</h3>

<p>A function to replace NA's with FALSE in vector of logicals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TorF(cond, use_isTRUE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TorF_+3A_cond">cond</code></td>
<td>
<p>a vector of conditions to check</p>
</td></tr>
<tr><td><code id="TorF_+3A_use_istrue">use_isTRUE</code></td>
<td>
<p>whether or not to use a vectorized version
of isTRUE.  This is generally slower but covers more cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>

<hr>
<h2 id='weighted.checkfun'>Weighted Check Function</h2><span id='topic+weighted.checkfun'></span>

<h3>Description</h3>

<p>Weights the check function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.checkfun(q, cvec, tau, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.checkfun_+3A_q">q</code></td>
<td>
<p>the value to check</p>
</td></tr>
<tr><td><code id="weighted.checkfun_+3A_cvec">cvec</code></td>
<td>
<p>vector of data to compute quantiles for</p>
</td></tr>
<tr><td><code id="weighted.checkfun_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
<tr><td><code id="weighted.checkfun_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
