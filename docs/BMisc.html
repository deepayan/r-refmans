<!DOCTYPE html><html lang="en"><head><title>Help for package BMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BMisc'><p>BMisc</p></a></li>
<li><a href='#add_cov_to_formula'><p>Add a Covariate to a Formula</p></a></li>
<li><a href='#addCovToFormla'><p>addCovToFormla</p></a></li>
<li><a href='#block_boot_sample'><p>Block Bootstrap</p></a></li>
<li><a href='#blockBootSample'><p>blockBootSample</p></a></li>
<li><a href='#check_staggered'><p>check_staggered</p></a></li>
<li><a href='#check_staggered_inner'><p>check_staggered_inner</p></a></li>
<li><a href='#checkfun'><p>Check Function</p></a></li>
<li><a href='#combine_ecdfs'><p>Combine Two Distribution Functions</p></a></li>
<li><a href='#combineDfs'><p>combineDfs</p></a></li>
<li><a href='#compare_binary'><p>Compare Variables across Groups</p></a></li>
<li><a href='#compare_binary_inner'><p>Compare a single variable across two groups</p></a></li>
<li><a href='#compareBinary'><p>compareBinary</p></a></li>
<li><a href='#cs2panel'><p>Cross Section to Panel</p></a></li>
<li><a href='#drop_collinear'><p>drop_collinear</p></a></li>
<li><a href='#drop_cov_from_formula'><p>Drop a Covariate from a Formula</p></a></li>
<li><a href='#dropCovFromFormla'><p>dropCovFromFormla</p></a></li>
<li><a href='#element_wise_mult'><p>element_wise_mult</p></a></li>
<li><a href='#get_first_difference'><p>get_first_difference</p></a></li>
<li><a href='#get_group'><p>get_group</p></a></li>
<li><a href='#get_group_inner'><p>get_group_inner</p></a></li>
<li><a href='#get_lagYi'><p>get_lagYi</p></a></li>
<li><a href='#get_list_element'><p>Return Particular Element from Each Element in a List</p></a></li>
<li><a href='#get_principal_components'><p>get_principal_components</p></a></li>
<li><a href='#get_Yi1'><p>get_Yi1</p></a></li>
<li><a href='#get_Yi1_inner'><p>get_Yi1_inner</p></a></li>
<li><a href='#get_Yibar'><p>get_Yibar</p></a></li>
<li><a href='#get_Yibar_inner'><p>get_Yibar_inner</p></a></li>
<li><a href='#get_Yibar_pre'><p>get_Yibar_pre</p></a></li>
<li><a href='#get_Yibar_pre_inner'><p>get_Yibar_pre_inner</p></a></li>
<li><a href='#get_YiGmin1'><p>get_YiGmin1</p></a></li>
<li><a href='#get_YiGmin1_inner'><p>get_YiGmin1_inner</p></a></li>
<li><a href='#get_Yit'><p>get_Yit</p></a></li>
<li><a href='#get_Yit_inner'><p>get_Yit_inner</p></a></li>
<li><a href='#getListElement'><p>getListElement</p></a></li>
<li><a href='#getWeightedDf'><p>getWeightedDf</p></a></li>
<li><a href='#getWeightedMean'><p>getWeightedMean</p></a></li>
<li><a href='#getWeightedQuantiles'><p>getWeightedQuantiles</p></a></li>
<li><a href='#id2rownum'><p>Take particular id and convert to row number</p></a></li>
<li><a href='#ids2rownum'><p>Convert Vector of ids into Vector of Row Numbers</p></a></li>
<li><a href='#invert_ecdf'><p>Invert Ecdf</p></a></li>
<li><a href='#invertEcdf'><p>invertEcdf</p></a></li>
<li><a href='#lhs_vars'><p>Left-hand Side Variables</p></a></li>
<li><a href='#lhs.vars'><p>lhs.vars</p></a></li>
<li><a href='#make_balanced_panel'><p>Balance a Panel Data Set</p></a></li>
<li><a href='#make_dist'><p>Make a Distribution Function</p></a></li>
<li><a href='#makeBalancedPanel'><p>makeBalancedPanel</p></a></li>
<li><a href='#makeDist'><p>makeDist</p></a></li>
<li><a href='#multiplier_bootstrap'><p>multiplier_bootstrap</p></a></li>
<li><a href='#mv_mult'><p>Matrix-Vector Multiplication</p></a></li>
<li><a href='#orig2t'><p>orig2t</p></a></li>
<li><a href='#orig2t_inner'><p>orig2t_inner</p></a></li>
<li><a href='#panel2cs'><p>Panel Data to Repeated Cross Sections</p></a></li>
<li><a href='#panel2cs2'><p>Panel Data to Repeated Cross Sections</p></a></li>
<li><a href='#rhs'><p>Right-hand Side of Formula</p></a></li>
<li><a href='#rhs_vars'><p>Right-hand Side Variables</p></a></li>
<li><a href='#rhs.vars'><p>rhs.vars</p></a></li>
<li><a href='#source_all'><p>source_all</p></a></li>
<li><a href='#subsample'><p>Subsample of Observations from Panel Data</p></a></li>
<li><a href='#t2orig'><p>t2orig</p></a></li>
<li><a href='#t2orig_inner'><p>t2orig_inner</p></a></li>
<li><a href='#time_invariant_to_panel'><p>time_invariant_to_panel</p></a></li>
<li><a href='#toformula'><p>Variable Names to Formula</p></a></li>
<li><a href='#TorF'><p>TorF</p></a></li>
<li><a href='#weighted_checkfun'><p>Weighted Check Function</p></a></li>
<li><a href='#weighted_combine_list'><p>weighted_combine_list</p></a></li>
<li><a href='#weighted_ecdf'><p>Weighted Distribution Function</p></a></li>
<li><a href='#weighted_mean'><p>Weighted Mean</p></a></li>
<li><a href='#weighted_quantile'><p>weighted_quantile</p></a></li>
<li><a href='#weighted_quantile_inner'><p>Quantile of a Weighted Check Function</p></a></li>
<li><a href='#weighted.checkfun'><p>weighted.checkfun</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions for Panel Data, Quantiles, and Printing
Results</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.8</td>
</tr>
<tr>
<td>Description:</td>
<td>These are miscellaneous functions for working with panel data, quantiles, and printing results.  For panel data, the package includes functions for making a panel data balanced (that is, dropping missing individuals that have missing observations in any time period), converting id numbers to row numbers, and to treat repeated cross sections as panel data under the assumption of rank invariance.  For quantiles, there are functions to make distribution functions from a set of data points (this is particularly useful when a distribution function is created in several steps), to combine distribution functions based on some external weights, and to invert distribution functions.  Finally, there are several other miscellaneous functions for obtaining weighted means, weighted distribution functions, and weighted quantiles; to generate summary statistics and their differences for two groups; and to add or drop covariates from formulas.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, dplyr, Rcpp, caret, tidyr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), plm, tibble</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bcallaway11.github.io/BMisc/">https://bcallaway11.github.io/BMisc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bcallaway11/BMisc/issues">https://github.com/bcallaway11/BMisc/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-04 14:52:24 UTC; bmc43193</td>
</tr>
<tr>
<td>Author:</td>
<td>Brantly Callaway [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brantly Callaway &lt;brantly.callaway@uga.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-04 15:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='BMisc'>BMisc</h2><span id='topic+BMisc-package'></span><span id='topic+BMisc'></span>

<h3>Description</h3>

<p>A set of miscellaneous helper functions
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Brantly Callaway <a href="mailto:brantly.callaway@uga.edu">brantly.callaway@uga.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://bcallaway11.github.io/BMisc/">https://bcallaway11.github.io/BMisc/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bcallaway11/BMisc/issues">https://github.com/bcallaway11/BMisc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_cov_to_formula'>Add a Covariate to a Formula</h2><span id='topic+add_cov_to_formula'></span>

<h3>Description</h3>

<p><code>add_cov_to_formula</code> adds some covariates to a formula;
covs should be a list of variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cov_to_formula(covs, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_cov_to_formula_+3A_covs">covs</code></td>
<td>
<p>should be a list of variable names</p>
</td></tr>
<tr><td><code id="add_cov_to_formula_+3A_formula">formula</code></td>
<td>
<p>which formula to add covariates to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- y ~ x
add_cov_to_formula(list("w", "z"), ff)

ff &lt;- ~x
add_cov_to_formula("z", ff)

</code></pre>

<hr>
<h2 id='addCovToFormla'>addCovToFormla</h2><span id='topic+addCovToFormla'></span>

<h3>Description</h3>

<p>Legacy version of 'add_cov_to_formula', please
use that function instead.  This function will eventually be
deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCovToFormla(covs, formla)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addCovToFormla_+3A_covs">covs</code></td>
<td>
<p>should be a list of variable names</p>
</td></tr>
</table>

<hr>
<h2 id='block_boot_sample'>Block Bootstrap</h2><span id='topic+block_boot_sample'></span>

<h3>Description</h3>

<p>make draws of all observations with the same id in a panel
data context.  This is useful for bootstrapping with panel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_boot_sample(data, idname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block_boot_sample_+3A_data">data</code></td>
<td>
<p>data.frame from which you want to bootstrap</p>
</td></tr>
<tr><td><code id="block_boot_sample_+3A_idname">idname</code></td>
<td>
<p>column in data which contains an individual identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame bootstrapped from the original dataset; this data.frame
will contain new ids
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("LaborSupply", package = "plm")
bbs &lt;- block_boot_sample(LaborSupply, "id")
nrow(bbs)
head(bbs$id)

</code></pre>

<hr>
<h2 id='blockBootSample'>blockBootSample</h2><span id='topic+blockBootSample'></span>

<h3>Description</h3>

<p>Legacy name for the function 'block_boot_sample',
please use that function going forward.  This function will
eventually be deleted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockBootSample(data, idname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blockBootSample_+3A_data">data</code></td>
<td>
<p>data.frame from which you want to bootstrap</p>
</td></tr>
<tr><td><code id="blockBootSample_+3A_idname">idname</code></td>
<td>
<p>column in data which contains an individual identifier</p>
</td></tr>
</table>

<hr>
<h2 id='check_staggered'>check_staggered</h2><span id='topic+check_staggered'></span>

<h3>Description</h3>

<p>A function to check if treatment is staggered in a panel data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_staggered(df, idname, treatname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_staggered_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="check_staggered_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="check_staggered_+3A_treatname">treatname</code></td>
<td>
<p>name of column with the treatment indicator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical indicating whether treatment is staggered
</p>

<hr>
<h2 id='check_staggered_inner'>check_staggered_inner</h2><span id='topic+check_staggered_inner'></span>

<h3>Description</h3>

<p>A helper function to check if treatment is staggered in a panel data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_staggered_inner(this_df, treatname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_staggered_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="check_staggered_inner_+3A_treatname">treatname</code></td>
<td>
<p>name of column with the treatment indicator</p>
</td></tr>
</table>

<hr>
<h2 id='checkfun'>Check Function</h2><span id='topic+checkfun'></span>

<h3>Description</h3>

<p>The check function used for optimizing to get quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkfun(a, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkfun_+3A_a">a</code></td>
<td>
<p>vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="checkfun_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
x[which.min(checkfun(x, 0.5))] ## should be around 0

</code></pre>

<hr>
<h2 id='combine_ecdfs'>Combine Two Distribution Functions</h2><span id='topic+combine_ecdfs'></span>

<h3>Description</h3>

<p>Combines two distribution functions with given weights by 'weights'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_ecdfs(y.seq, dflist, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_ecdfs_+3A_y.seq">y.seq</code></td>
<td>
<p>sequence of possible y values</p>
</td></tr>
<tr><td><code id="combine_ecdfs_+3A_dflist">dflist</code></td>
<td>
<p>list of distribution functions to combine</p>
</td></tr>
<tr><td><code id="combine_ecdfs_+3A_weights">weights</code></td>
<td>
<p>a vector of weights to put on each distribution function;
if weights are not provided then equal weight is given to each
distribution function</p>
</td></tr>
<tr><td><code id="combine_ecdfs_+3A_...">...</code></td>
<td>
<p>additional arguments that can be past to BMisc::make_dist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ecdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100, 1, 1)
Fx &lt;- ecdf(x)
Fy &lt;- ecdf(y)
both &lt;- combineDfs(seq(-2, 3, 0.1), list(Fx, Fy))
plot(Fx, col = "green")
plot(Fy, col = "blue", add = TRUE)
plot(both, add = TRUE)

</code></pre>

<hr>
<h2 id='combineDfs'>combineDfs</h2><span id='topic+combineDfs'></span>

<h3>Description</h3>

<p>Legacy version of 'combine_ecdfs', please use that
function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineDfs(y.seq, dflist, pstrat = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combineDfs_+3A_y.seq">y.seq</code></td>
<td>
<p>sequence of possible y values</p>
</td></tr>
<tr><td><code id="combineDfs_+3A_dflist">dflist</code></td>
<td>
<p>list of distribution functions to combine</p>
</td></tr>
<tr><td><code id="combineDfs_+3A_...">...</code></td>
<td>
<p>additional arguments that can be past to BMisc::make_dist</p>
</td></tr>
</table>

<hr>
<h2 id='compare_binary'>Compare Variables across Groups</h2><span id='topic+compare_binary'></span>

<h3>Description</h3>

<p><code>compare_binary</code> takes in a variable e.g. union
and runs bivariate regression of x on treatment (for summary statistics)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_binary(
  x,
  on,
  dta,
  w = rep(1, nrow(dta)),
  report = c("diff", "levels", "both")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_binary_+3A_x">x</code></td>
<td>
<p>variables to run regression on</p>
</td></tr>
<tr><td><code id="compare_binary_+3A_on">on</code></td>
<td>
<p>binary variable</p>
</td></tr>
<tr><td><code id="compare_binary_+3A_dta">dta</code></td>
<td>
<p>the data to use</p>
</td></tr>
<tr><td><code id="compare_binary_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="compare_binary_+3A_report">report</code></td>
<td>
<p>which type of report to make; diff is the difference between
the two variables by group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of results
</p>

<hr>
<h2 id='compare_binary_inner'>Compare a single variable across two groups</h2><span id='topic+compare_binary_inner'></span>

<h3>Description</h3>

<p><code>compare_binary_inner</code> takes in a variable e.g. union
and runs bivariate regression of x on treatment (for summary statistics)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_binary_inner(
  x,
  on,
  dta,
  w = rep(1, nrow(dta)),
  report = c("diff", "levels", "both")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_binary_inner_+3A_x">x</code></td>
<td>
<p>variables to run regression on</p>
</td></tr>
<tr><td><code id="compare_binary_inner_+3A_on">on</code></td>
<td>
<p>binary variable</p>
</td></tr>
<tr><td><code id="compare_binary_inner_+3A_dta">dta</code></td>
<td>
<p>the data to use</p>
</td></tr>
<tr><td><code id="compare_binary_inner_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="compare_binary_inner_+3A_report">report</code></td>
<td>
<p>which type of report to make; diff is the difference between
the two variables by group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of results
</p>

<hr>
<h2 id='compareBinary'>compareBinary</h2><span id='topic+compareBinary'></span>

<h3>Description</h3>

<p>Legacy version of 'compare_binary', please use that
function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareBinary(
  x,
  on,
  dta,
  w = rep(1, nrow(dta)),
  report = c("diff", "levels", "both")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareBinary_+3A_x">x</code></td>
<td>
<p>variables to run regression on</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_on">on</code></td>
<td>
<p>binary variable</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_dta">dta</code></td>
<td>
<p>the data to use</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="compareBinary_+3A_report">report</code></td>
<td>
<p>which type of report to make; diff is the difference between
the two variables by group</p>
</td></tr>
</table>

<hr>
<h2 id='cs2panel'>Cross Section to Panel</h2><span id='topic+cs2panel'></span>

<h3>Description</h3>

<p>Turn repeated cross sections data into panel data by
imposing rank invariance; does not require
that the inputs have the same length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs2panel(cs1, cs2, yname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cs2panel_+3A_cs1">cs1</code></td>
<td>
<p>data frame, the first cross section</p>
</td></tr>
<tr><td><code id="cs2panel_+3A_cs2">cs2</code></td>
<td>
<p>data frame, the second cross section</p>
</td></tr>
<tr><td><code id="cs2panel_+3A_yname">yname</code></td>
<td>
<p>the name of the variable to calculate difference for (should be the same in each dataset)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the change in outcomes over time
</p>

<hr>
<h2 id='drop_collinear'>drop_collinear</h2><span id='topic+drop_collinear'></span>

<h3>Description</h3>

<p>A function to check for multicollinearity and drop collinear terms
from a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_collinear(matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_collinear_+3A_matrix">matrix</code></td>
<td>
<p>a matrix for which the function will remove collinear columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with collinear columns removed
</p>

<hr>
<h2 id='drop_cov_from_formula'>Drop a Covariate from a Formula</h2><span id='topic+drop_cov_from_formula'></span>

<h3>Description</h3>

<p><code>drop_cov_from_formula</code> adds drops some covariates from a
formula; covs should be a list of variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_cov_from_formula(covs, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_cov_from_formula_+3A_covs">covs</code></td>
<td>
<p>should be a list of variable names</p>
</td></tr>
<tr><td><code id="drop_cov_from_formula_+3A_formula">formula</code></td>
<td>
<p>the formula to drop covariates from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- y ~ x + w + z
drop_cov_from_formula(list("w", "z"), ff)

drop_cov_from_formula("z", ff)

</code></pre>

<hr>
<h2 id='dropCovFromFormla'>dropCovFromFormla</h2><span id='topic+dropCovFromFormla'></span>

<h3>Description</h3>

<p>Legacy version of 'drop_cov_from_formula', please use
that function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropCovFromFormla(covs, formla)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropCovFromFormla_+3A_covs">covs</code></td>
<td>
<p>should be a list of variable names</p>
</td></tr>
</table>

<hr>
<h2 id='element_wise_mult'>element_wise_mult</h2><span id='topic+element_wise_mult'></span>

<h3>Description</h3>

<p>This is a function that takes in two matrices of dimension
nxB and nxk and returns a Bxk matrix that comes from
element-wise multiplication of every column
in the first matrix times the entire second matrix and the
averaging over the n-dimension.  It is equivalent (but faster
than) the following R code:
'sapply(1:biters, function(b) sqrt(n)*colMeans(Umat[,b]*inf.func))'
.  This function is particularly useful for fast computations
using the multiplier bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element_wise_mult(U, inf_func)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="element_wise_mult_+3A_u">U</code></td>
<td>
<p>nxB matrix (e.g., these could be a matrix of
Rademachar weights for B bootstrap iterations using the
multiplier bootstrap</p>
</td></tr>
<tr><td><code id="element_wise_mult_+3A_inf_func">inf_func</code></td>
<td>
<p>nxk matrix of (e.g., these could be a matrix
containing the influence function for different parameter
estimates)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Bxk matrix
</p>

<hr>
<h2 id='get_first_difference'>get_first_difference</h2><span id='topic+get_first_difference'></span>

<h3>Description</h3>

<p>A function that calculates the first difference in a panel data
setting.  If the data.frame that is passed in has nxT rows, the resulting
vector will also have nxT elements with one element for each unit set to be
NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_first_difference(df, idname, yname, tname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_first_difference_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_first_difference_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_first_difference_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_first_difference_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
</table>

<hr>
<h2 id='get_group'>get_group</h2><span id='topic+get_group'></span>

<h3>Description</h3>

<p>A function to calculate a unit's group in a panel data setting
with a binary treatment and staggered treatment adoption and where
there is a column in the data indicating whether or not a unit is treated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group(df, idname, tname, treatname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_group_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_group_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_group_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_group_+3A_treatname">treatname</code></td>
<td>
<p>name of column with the treatment indicator</p>
</td></tr>
</table>

<hr>
<h2 id='get_group_inner'>get_group_inner</h2><span id='topic+get_group_inner'></span>

<h3>Description</h3>

<p>Calculates the group for a particular unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group_inner(this_df, tname, treatname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_group_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_group_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_group_inner_+3A_treatname">treatname</code></td>
<td>
<p>name of column with the treatment indicator</p>
</td></tr>
</table>

<hr>
<h2 id='get_lagYi'>get_lagYi</h2><span id='topic+get_lagYi'></span>

<h3>Description</h3>

<p>A function that calculates lagged outcomes in a panel data setting.
If the data.frame that is passed in has nxT rows, the resulting vector will
also have nxT elements with one element for each unit set to be NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lagYi(df, idname, yname, tname, nlags = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_lagYi_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_lagYi_+3A_nlags">nlags</code></td>
<td>
<p>The number of periods to lag.  The default is 1, which computes
the lag from the previous period.</p>
</td></tr>
</table>

<hr>
<h2 id='get_list_element'>Return Particular Element from Each Element in a List</h2><span id='topic+get_list_element'></span>

<h3>Description</h3>

<p>a function to take a list and get a particular part
out of each element in the list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_list_element(listolists, whichone = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_list_element_+3A_listolists">listolists</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="get_list_element_+3A_whichone">whichone</code></td>
<td>
<p>which item to get out of each list (can be numeric or name)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of all the elements 'whichone' from each list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>len &lt;- 100 # number elements in list
lis &lt;- lapply(1:len, function(l) list(x = (-l), y = l^2)) # create list
getListElement(lis, "x")[1] # should be equal to -1
getListElement(lis, 1)[1] # should be equal to -1

</code></pre>

<hr>
<h2 id='get_principal_components'>get_principal_components</h2><span id='topic+get_principal_components'></span>

<h3>Description</h3>

<p>A function to calculate unit-specific principal components, given panel data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_principal_components(
  xformula,
  data,
  idname,
  tname,
  n_components = NULL,
  ret_wide = FALSE,
  ret_id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_principal_components_+3A_xformula">xformula</code></td>
<td>
<p>a formula specifying the variables to use in the principal component analysis</p>
</td></tr>
<tr><td><code id="get_principal_components_+3A_data">data</code></td>
<td>
<p>a data.frame containing the panel data</p>
</td></tr>
<tr><td><code id="get_principal_components_+3A_idname">idname</code></td>
<td>
<p>the name of the column containing the unit id</p>
</td></tr>
<tr><td><code id="get_principal_components_+3A_tname">tname</code></td>
<td>
<p>the name of the column containing the time period</p>
</td></tr>
<tr><td><code id="get_principal_components_+3A_n_components">n_components</code></td>
<td>
<p>the number of principal components to retain, the default is NULL which
will result in all principal components being retained</p>
</td></tr>
<tr><td><code id="get_principal_components_+3A_ret_wide">ret_wide</code></td>
<td>
<p>whether to return the data in wide format (where the number of rows
is equal to n = length(unique(data[[idname]])) or long format (where the number
of rows is equal to nT = nrow(data)).  The default is FALSE, so that long data
is returned by default.</p>
</td></tr>
<tr><td><code id="get_principal_components_+3A_ret_id">ret_id</code></td>
<td>
<p>whether to return the id column in the output data.frame.  The default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame containing the original data with the principal components appended
</p>

<hr>
<h2 id='get_Yi1'>get_Yi1</h2><span id='topic+get_Yi1'></span>

<h3>Description</h3>

<p>A function to calculate outcomes for units in the first time
period that is available in a panel data setting (this function can also
be used to recover covariates, etc. in the first period).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yi1(df, idname, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yi1_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yi1_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yi1_inner'>get_Yi1_inner</h2><span id='topic+get_Yi1_inner'></span>

<h3>Description</h3>

<p>Calculates a units outcome in the first time period.
This function operates on a data.frame that is already local to a particular
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yi1_inner(this_df, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yi1_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yi1_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yi1_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yi1_inner_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar'>get_Yibar</h2><span id='topic+get_Yibar'></span>

<h3>Description</h3>

<p>A function to calculate the average outcome across all time
periods separately for each unit in a panel data setting (this function can also
be used to recover covariates, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar(df, idname, yname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yibar_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yibar_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yibar_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar_inner'>get_Yibar_inner</h2><span id='topic+get_Yibar_inner'></span>

<h3>Description</h3>

<p>Calculates a units average outcome across all periods.
This function operates on a data.frame that is already local to a particular
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar_inner(this_df, yname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yibar_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yibar_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar_pre'>get_Yibar_pre</h2><span id='topic+get_Yibar_pre'></span>

<h3>Description</h3>

<p>A function to calculate average outcomes for units in
their pre-treatment periods (this function can also be used to recover
pre-treatment averages of covariates, etc.).
For units that do not
participate in the treatment (and therefore have group==0), the
function calculates their overall average outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar_pre(df, idname, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yibar_pre_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yibar_pre_inner'>get_Yibar_pre_inner</h2><span id='topic+get_Yibar_pre_inner'></span>

<h3>Description</h3>

<p>Calculates a unit's average outcome in pre-treatment periods
(or also can be used for a covariate).  The unit's group must
be specified at this point.  This function operates on a data.frame
that is already local to a particular unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yibar_pre_inner(this_df, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yibar_pre_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_Yibar_pre_inner_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_YiGmin1'>get_YiGmin1</h2><span id='topic+get_YiGmin1'></span>

<h3>Description</h3>

<p>A function to calculate outcomes for units in the period
right before they become treated (this function can also be used to recover
covariates, etc. in the period right before a unit becomes treated).
For units that do not
participate in the treatment (and therefore have group==0), they are
assigned their outcome in the last period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_YiGmin1(df, idname, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_YiGmin1_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_YiGmin1_inner'>get_YiGmin1_inner</h2><span id='topic+get_YiGmin1_inner'></span>

<h3>Description</h3>

<p>Calculates a units outcome (or also can be used for a covariate)
in the period right before it becomes treated.  The unit's group must
be specified at this point.  This function operates on a data.frame
that is already local to a particular unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_YiGmin1_inner(this_df, yname, tname, gname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_YiGmin1_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_YiGmin1_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
<tr><td><code id="get_YiGmin1_inner_+3A_gname">gname</code></td>
<td>
<p>name of column containing the unit's group</p>
</td></tr>
</table>

<hr>
<h2 id='get_Yit'>get_Yit</h2><span id='topic+get_Yit'></span>

<h3>Description</h3>

<p>A function to calculate outcomes for units in a particular
time period 'tp' in a panel data setting (this function can also
be used to recover covariates, etc. in the first period).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yit(df, tp, idname, yname, tname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yit_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_tp">tp</code></td>
<td>
<p>The time period for which to get the outcome</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yit_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of outcomes in period t, the vector
will have the length nT (i.e., this is returned for
each element in the panel, not for a particular period)
</p>

<hr>
<h2 id='get_Yit_inner'>get_Yit_inner</h2><span id='topic+get_Yit_inner'></span>

<h3>Description</h3>

<p>Calculates a units outcome in some particular period 'tp'.
This function operates on a data.frame that is already local to a particular
unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Yit_inner(this_df, tp, yname, tname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_Yit_inner_+3A_this_df">this_df</code></td>
<td>
<p>a data.frame, for this function it should be specific to
a particular unit</p>
</td></tr>
<tr><td><code id="get_Yit_inner_+3A_tp">tp</code></td>
<td>
<p>The time period for which to get the outcome</p>
</td></tr>
<tr><td><code id="get_Yit_inner_+3A_yname">yname</code></td>
<td>
<p>name of column containing the outcome (or other variable)
for which to calculate its outcome in the immediate pre-treatment period</p>
</td></tr>
<tr><td><code id="get_Yit_inner_+3A_tname">tname</code></td>
<td>
<p>name of column that holds the time period</p>
</td></tr>
</table>

<hr>
<h2 id='getListElement'>getListElement</h2><span id='topic+getListElement'></span>

<h3>Description</h3>

<p>Legacy version of 'get_list_element', please use that function
instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getListElement(listolists, whichone = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getListElement_+3A_listolists">listolists</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="getListElement_+3A_whichone">whichone</code></td>
<td>
<p>which item to get out of each list (can be numeric or name)</p>
</td></tr>
</table>

<hr>
<h2 id='getWeightedDf'>getWeightedDf</h2><span id='topic+getWeightedDf'></span>

<h3>Description</h3>

<p>Legacy version of 'weighted_ecdf', please use that function
instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedDf(y, y.seq = NULL, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWeightedDf_+3A_y">y</code></td>
<td>
<p>a vector to compute the mean for</p>
</td></tr>
<tr><td><code id="getWeightedDf_+3A_y.seq">y.seq</code></td>
<td>
<p>an optional vector of values to compute the distribution function
for; the default is to use all unique values of y</p>
</td></tr>
<tr><td><code id="getWeightedDf_+3A_weights">weights</code></td>
<td>
<p>the vector of weights, can be NULL, then will just return mean</p>
</td></tr>
<tr><td><code id="getWeightedDf_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>

<hr>
<h2 id='getWeightedMean'>getWeightedMean</h2><span id='topic+getWeightedMean'></span>

<h3>Description</h3>

<p>Legacy version of 'weighted_mean', please use
that function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedMean(y, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWeightedMean_+3A_y">y</code></td>
<td>
<p>a vector to compute the mean for</p>
</td></tr>
<tr><td><code id="getWeightedMean_+3A_weights">weights</code></td>
<td>
<p>the vector of weights, can be NULL, then will just return mean</p>
</td></tr>
<tr><td><code id="getWeightedMean_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>

<hr>
<h2 id='getWeightedQuantiles'>getWeightedQuantiles</h2><span id='topic+getWeightedQuantiles'></span>

<h3>Description</h3>

<p>Legacy version of 'weighted_quantile', please use that
function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeightedQuantiles(tau, cvec, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWeightedQuantiles_+3A_tau">tau</code></td>
<td>
<p>a vector of values between 0 and 1</p>
</td></tr>
<tr><td><code id="getWeightedQuantiles_+3A_cvec">cvec</code></td>
<td>
<p>a vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="getWeightedQuantiles_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
<tr><td><code id="getWeightedQuantiles_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>

<hr>
<h2 id='id2rownum'>Take particular id and convert to row number</h2><span id='topic+id2rownum'></span>

<h3>Description</h3>

<p>id2rownum takes an id and converts it to the right
row number in the dataset; ids should be unique in the dataset
that is, don't pass the function panel data with multiple same ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id2rownum(id, data, idname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id2rownum_+3A_id">id</code></td>
<td>
<p>a particular id</p>
</td></tr>
<tr><td><code id="id2rownum_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="id2rownum_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
</table>

<hr>
<h2 id='ids2rownum'>Convert Vector of ids into Vector of Row Numbers</h2><span id='topic+ids2rownum'></span>

<h3>Description</h3>

<p>ids2rownum takes a vector of ids and converts it to the right
row number in the dataset; ids should be unique in the dataset
that is, don't pass the function panel data with multiple same ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ids2rownum(ids, data, idname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ids2rownum_+3A_ids">ids</code></td>
<td>
<p>vector of ids</p>
</td></tr>
<tr><td><code id="ids2rownum_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="ids2rownum_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of row numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ids &lt;- seq(1, 1000, length.out = 100)
ids &lt;- ids[order(runif(100))]
df &lt;- data.frame(id = ids)
ids2rownum(df$id, df, "id")

</code></pre>

<hr>
<h2 id='invert_ecdf'>Invert Ecdf</h2><span id='topic+invert_ecdf'></span>

<h3>Description</h3>

<p>take an ecdf object and invert it to get a step-quantile
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_ecdf(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invert_ecdf_+3A_df">df</code></td>
<td>
<p>an ecdf object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stepfun object that contains the quantiles of the df
</p>

<hr>
<h2 id='invertEcdf'>invertEcdf</h2><span id='topic+invertEcdf'></span>

<h3>Description</h3>

<p>Legacy function for 'invert_ecdf', please use that
function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invertEcdf(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invertEcdf_+3A_df">df</code></td>
<td>
<p>an ecdf object</p>
</td></tr>
</table>

<hr>
<h2 id='lhs_vars'>Left-hand Side Variables</h2><span id='topic+lhs_vars'></span>

<h3>Description</h3>

<p>Take a formula and return a vector of the variables
on the left hand side, it will return NULL for a one sided formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs_vars(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lhs_vars_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- yvar ~ x1 + x2
lhs.vars(ff)
</code></pre>

<hr>
<h2 id='lhs.vars'>lhs.vars</h2><span id='topic+lhs.vars'></span>

<h3>Description</h3>

<p>Legacy version of 'lhs_vars', please use that function
instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs.vars(formla)
</code></pre>

<hr>
<h2 id='make_balanced_panel'>Balance a Panel Data Set</h2><span id='topic+make_balanced_panel'></span>

<h3>Description</h3>

<p>This function drops observations from data.frame
that are not part of balanced panel data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_balanced_panel(data, idname, tname, return_data.table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_balanced_panel_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="make_balanced_panel_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="make_balanced_panel_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
<tr><td><code id="make_balanced_panel_+3A_return_data.table">return_data.table</code></td>
<td>
<p>if TRUE, make_balanced_panel will
return a data.table rather than a data.frame.  Default
is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame that is a balanced panel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- rep(seq(1, 100), each = 2) # individual ids for setting up a two period panel
t &lt;- rep(seq(1, 2), 100) # time periods
y &lt;- rnorm(200) # outcomes
dta &lt;- data.frame(id = id, t = t, y = y) # make into data frame
dta &lt;- dta[-7, ] # drop the 7th row from the dataset (which creates an unbalanced panel)
dta &lt;- make_balanced_panel(dta, idname = "id", tname = "t")

</code></pre>

<hr>
<h2 id='make_dist'>Make a Distribution Function</h2><span id='topic+make_dist'></span>

<h3>Description</h3>

<p>turn vectors of a values and their distribution function values
into an ecdf.  Vectors should be the same length and both increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dist(
  x,
  Fx,
  sorted = FALSE,
  rearrange = FALSE,
  force01 = FALSE,
  method = "constant"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dist_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="make_dist_+3A_fx">Fx</code></td>
<td>
<p>vector of the distribution function values</p>
</td></tr>
<tr><td><code id="make_dist_+3A_sorted">sorted</code></td>
<td>
<p>boolean indicating whether or not x is already sorted;
computation is somewhat faster if already sorted</p>
</td></tr>
<tr><td><code id="make_dist_+3A_rearrange">rearrange</code></td>
<td>
<p>boolean indicating whether or not should monotize
distribution function</p>
</td></tr>
<tr><td><code id="make_dist_+3A_force01">force01</code></td>
<td>
<p>boolean indicating whether or not to force the values of
the distribution function (i.e. Fx) to be between 0 and 1</p>
</td></tr>
<tr><td><code id="make_dist_+3A_method">method</code></td>
<td>
<p>which method to pass to <code>approxfun</code> to approximate the
distribution function.  Default is &quot;constant&quot;; other possible choice is
&quot;linear&quot;.  &quot;constant&quot; returns a step function, just like an empirical
cdf; &quot;linear&quot; linearly interpolates between neighboring points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ecdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- rnorm(100)
y &lt;- y[order(y)]
u &lt;- runif(100)
u &lt;- u[order(u)]
F &lt;- make_dist(y, u)

</code></pre>

<hr>
<h2 id='makeBalancedPanel'>makeBalancedPanel</h2><span id='topic+makeBalancedPanel'></span>

<h3>Description</h3>

<p>Legacy version of 'make_balanced_panel',
please use that function name going forward, though this will
still work for now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBalancedPanel(data, idname, tname, return_data.table = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeBalancedPanel_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="makeBalancedPanel_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="makeBalancedPanel_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
<tr><td><code id="makeBalancedPanel_+3A_return_data.table">return_data.table</code></td>
<td>
<p>if TRUE, make_balanced_panel will
return a data.table rather than a data.frame.  Default
is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='makeDist'>makeDist</h2><span id='topic+makeDist'></span>

<h3>Description</h3>

<p>Legacy name of 'make_dist' function, please
use that function instead.  This function will eventually
be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDist(
  x,
  Fx,
  sorted = FALSE,
  rearrange = FALSE,
  force01 = FALSE,
  method = "constant"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeDist_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="makeDist_+3A_fx">Fx</code></td>
<td>
<p>vector of the distribution function values</p>
</td></tr>
<tr><td><code id="makeDist_+3A_sorted">sorted</code></td>
<td>
<p>boolean indicating whether or not x is already sorted;
computation is somewhat faster if already sorted</p>
</td></tr>
<tr><td><code id="makeDist_+3A_rearrange">rearrange</code></td>
<td>
<p>boolean indicating whether or not should monotize
distribution function</p>
</td></tr>
<tr><td><code id="makeDist_+3A_force01">force01</code></td>
<td>
<p>boolean indicating whether or not to force the values of
the distribution function (i.e. Fx) to be between 0 and 1</p>
</td></tr>
<tr><td><code id="makeDist_+3A_method">method</code></td>
<td>
<p>which method to pass to <code>approxfun</code> to approximate the
distribution function.  Default is &quot;constant&quot;; other possible choice is
&quot;linear&quot;.  &quot;constant&quot; returns a step function, just like an empirical
cdf; &quot;linear&quot; linearly interpolates between neighboring points.</p>
</td></tr>
</table>

<hr>
<h2 id='multiplier_bootstrap'>multiplier_bootstrap</h2><span id='topic+multiplier_bootstrap'></span>

<h3>Description</h3>

<p>A function that takes in an influence function (an
nxk matrix) and the number of bootstrap iterations and
returns a Bxk matrix of bootstrap results. This function
uses Rademechar weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplier_bootstrap(inf_func, biters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiplier_bootstrap_+3A_inf_func">inf_func</code></td>
<td>
<p>nxk matrix of (e.g., these could be a matrix
containing the influence function for different parameter
estimates)</p>
</td></tr>
<tr><td><code id="multiplier_bootstrap_+3A_biters">biters</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Bxk matrix
</p>

<hr>
<h2 id='mv_mult'>Matrix-Vector Multiplication</h2><span id='topic+mv_mult'></span>

<h3>Description</h3>

<p>This function multiplies a matrix by a vector and returns a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv_mult(A, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mv_mult_+3A_a">A</code></td>
<td>
<p>an nxk matrix.</p>
</td></tr>
<tr><td><code id="mv_mult_+3A_v">v</code></td>
<td>
<p>a vector (can be stored as numeric or as a kx1 matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector resulting from the multiplication of the matrix by the vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1:9, nrow = 3, ncol = 3)
v &lt;- c(2, 4, 6)
mv_mult(A, v)
</code></pre>

<hr>
<h2 id='orig2t'>orig2t</h2><span id='topic+orig2t'></span>

<h3>Description</h3>

<p>A helper function to switch from original time periods to
&quot;new&quot; time periods (which are just time periods going from 1 to total
number of available periods).  This allows for periods not being
exactly spaced apart by 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orig2t(orig, original_time.periods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orig2t_+3A_orig">orig</code></td>
<td>
<p>a vector of original time periods to convert to new time periods.</p>
</td></tr>
<tr><td><code id="orig2t_+3A_original_time.periods">original_time.periods</code></td>
<td>
<p>vector containing all original time periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new time period converted from original time period
</p>

<hr>
<h2 id='orig2t_inner'>orig2t_inner</h2><span id='topic+orig2t_inner'></span>

<h3>Description</h3>

<p>A helper function to switch from original t values to
&quot;new&quot; t values (which are just time periods going from 1 to total
number of available periods).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orig2t_inner(orig, original_time.periods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orig2t_inner_+3A_orig">orig</code></td>
<td>
<p>a single original time period to convert to new time period</p>
</td></tr>
<tr><td><code id="orig2t_inner_+3A_original_time.periods">original_time.periods</code></td>
<td>
<p>vector containing all original time periods.</p>
</td></tr>
</table>

<hr>
<h2 id='panel2cs'>Panel Data to Repeated Cross Sections</h2><span id='topic+panel2cs'></span>

<h3>Description</h3>

<p>panel2cs takes a 2 period dataset and turns it
into a cross sectional dataset.  The data includes the
change in time varying variables between the
time periods.  The default functionality
is to keep all the variables from period 1
and add all the variables listed by name in timevars
from period 2 to those.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel2cs(data, timevars, idname, tname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel2cs_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="panel2cs_+3A_timevars">timevars</code></td>
<td>
<p>vector of names of variables to keep</p>
</td></tr>
<tr><td><code id="panel2cs_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="panel2cs_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='panel2cs2'>Panel Data to Repeated Cross Sections</h2><span id='topic+panel2cs2'></span>

<h3>Description</h3>

<p>panel2cs2 takes a 2 period dataset and turns it
into a cross sectional dataset; i.e., long to wide.
This function considers a particular case where there is some outcome
whose value can change over time.  It returns the dataset from the first
period with the outcome in the second period and the change in outcomes
over time appended to it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel2cs2(data, yname, idname, tname, balance_panel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel2cs2_+3A_data">data</code></td>
<td>
<p>data.frame used in function</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_yname">yname</code></td>
<td>
<p>name of outcome variable that can change over time</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_idname">idname</code></td>
<td>
<p>unique id</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_tname">tname</code></td>
<td>
<p>time period name</p>
</td></tr>
<tr><td><code id="panel2cs2_+3A_balance_panel">balance_panel</code></td>
<td>
<p>whether to ensure that panel is balanced.  Default is TRUE, but code runs somewhat
faster if this is set to be FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data from first period with .y0 (outcome in first period),
.y1 (outcome in second period), and .dy (change in outcomes
over time) appended to it
</p>

<hr>
<h2 id='rhs'>Right-hand Side of Formula</h2><span id='topic+rhs'></span>

<h3>Description</h3>

<p>Take a formula and return the right hand side
of the formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhs(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhs_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one sided formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- yvar ~ x1 + x2
rhs(ff)

</code></pre>

<hr>
<h2 id='rhs_vars'>Right-hand Side Variables</h2><span id='topic+rhs_vars'></span>

<h3>Description</h3>

<p>Take a formula and return a vector of the variables
on the right hand side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhs_vars(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhs_vars_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- yvar ~ x1 + x2
rhs_vars(ff)

ff &lt;- y ~ x1 + I(x1^2)
rhs_vars(ff)

</code></pre>

<hr>
<h2 id='rhs.vars'>rhs.vars</h2><span id='topic+rhs.vars'></span>

<h3>Description</h3>

<p>Legacy version of 'rhs_vars', please use that
function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhs.vars(formla)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhs.vars_+3A_formla">formla</code></td>
<td>
<p>a formula</p>
</td></tr>
</table>

<hr>
<h2 id='source_all'>source_all</h2><span id='topic+source_all'></span>

<h3>Description</h3>

<p>Source all the files in a folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>source_all(fldr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="source_all_+3A_fldr">fldr</code></td>
<td>
<p>path to a folder</p>
</td></tr>
</table>

<hr>
<h2 id='subsample'>Subsample of Observations from Panel Data</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>returns a subsample of a panel data set; in particular drops
all observations that are not in <code>keepids</code>.  If it is not set,
randomly keeps <code>nkeep</code> observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(dta, idname, tname, keepids = NULL, nkeep = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_+3A_dta">dta</code></td>
<td>
<p>a data.frame which is a balanced panel</p>
</td></tr>
<tr><td><code id="subsample_+3A_idname">idname</code></td>
<td>
<p>the name of the id variable</p>
</td></tr>
<tr><td><code id="subsample_+3A_tname">tname</code></td>
<td>
<p>the name of the time variable</p>
</td></tr>
<tr><td><code id="subsample_+3A_keepids">keepids</code></td>
<td>
<p>which ids to keep</p>
</td></tr>
<tr><td><code id="subsample_+3A_nkeep">nkeep</code></td>
<td>
<p>how many ids to keep (only used if <code>keepids</code>
is not set); the default is the number of unique ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame that contains a subsample of <code>dta</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("LaborSupply", package = "plm")
nrow(LaborSupply)
unique(LaborSupply$year)
ss &lt;- subsample(LaborSupply, "id", "year", nkeep = 100)
nrow(ss)

</code></pre>

<hr>
<h2 id='t2orig'>t2orig</h2><span id='topic+t2orig'></span>

<h3>Description</h3>

<p>A helper function to switch from &quot;new&quot; t values to
original t values.  This allows for periods not being exactly spaced
apart by 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t2orig(t, original_time.periods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t2orig_+3A_t">t</code></td>
<td>
<p>a vector of time periods to convert back to original time
periods.</p>
</td></tr>
<tr><td><code id="t2orig_+3A_original_time.periods">original_time.periods</code></td>
<td>
<p>vector containing all original time periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original time period converted from new time period
</p>

<hr>
<h2 id='t2orig_inner'>t2orig_inner</h2><span id='topic+t2orig_inner'></span>

<h3>Description</h3>

<p>A helper function to switch from &quot;new&quot; t values to
original t values for a single t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t2orig_inner(t, original_time.periods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t2orig_inner_+3A_t">t</code></td>
<td>
<p>a single time period to convert back to original time</p>
</td></tr>
<tr><td><code id="t2orig_inner_+3A_original_time.periods">original_time.periods</code></td>
<td>
<p>vector containing all original time periods.</p>
</td></tr>
</table>

<hr>
<h2 id='time_invariant_to_panel'>time_invariant_to_panel</h2><span id='topic+time_invariant_to_panel'></span>

<h3>Description</h3>

<p>This function takes a time-invariant variable and repeats it
for each period in a panel data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_invariant_to_panel(x, df, idname, balanced_panel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_invariant_to_panel_+3A_x">x</code></td>
<td>
<p>a vector of length equal to the number of unique ids in df.</p>
</td></tr>
<tr><td><code id="time_invariant_to_panel_+3A_df">df</code></td>
<td>
<p>the data.frame used in the function</p>
</td></tr>
<tr><td><code id="time_invariant_to_panel_+3A_idname">idname</code></td>
<td>
<p>name of column that holds the unit id</p>
</td></tr>
<tr><td><code id="time_invariant_to_panel_+3A_balanced_panel">balanced_panel</code></td>
<td>
<p>a logical indicating whether the panel is balanced.
If TRUE, the function will optimize the repetition process.  Default
is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length equal to the number of rows in df.
</p>

<hr>
<h2 id='toformula'>Variable Names to Formula</h2><span id='topic+toformula'></span>

<h3>Description</h3>

<p>take a name for a y variable and a vector of names
for x variables and turn them into a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toformula(yname, xnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toformula_+3A_yname">yname</code></td>
<td>
<p>the name of the y variable</p>
</td></tr>
<tr><td><code id="toformula_+3A_xnames">xnames</code></td>
<td>
<p>vector of names for x variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toformula("yvar", c("x1", "x2"))

## should return yvar ~ 1
toformula("yvar", rhs.vars(~1))

</code></pre>

<hr>
<h2 id='TorF'>TorF</h2><span id='topic+TorF'></span>

<h3>Description</h3>

<p>A function to replace NA's with FALSE in vector of logicals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TorF(cond, use_isTRUE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TorF_+3A_cond">cond</code></td>
<td>
<p>a vector of conditions to check</p>
</td></tr>
<tr><td><code id="TorF_+3A_use_istrue">use_isTRUE</code></td>
<td>
<p>whether or not to use a vectorized version
of isTRUE.  This is generally slower but covers more cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>

<hr>
<h2 id='weighted_checkfun'>Weighted Check Function</h2><span id='topic+weighted_checkfun'></span>

<h3>Description</h3>

<p>Weights the check function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_checkfun(q, cvec, tau, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_checkfun_+3A_q">q</code></td>
<td>
<p>the value to check</p>
</td></tr>
<tr><td><code id="weighted_checkfun_+3A_cvec">cvec</code></td>
<td>
<p>vector of data to compute quantiles for</p>
</td></tr>
<tr><td><code id="weighted_checkfun_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
<tr><td><code id="weighted_checkfun_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>

<hr>
<h2 id='weighted_combine_list'>weighted_combine_list</h2><span id='topic+weighted_combine_list'></span>

<h3>Description</h3>

<p>A function that takes in either a list of vectors or matrices
and computes a weighted average of them, where the weights are applied to
every element in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_combine_list(l, w, normalize_weights = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_combine_list_+3A_l">l</code></td>
<td>
<p>a list that contains either vectors or matrices of the same dimension
that are to be combined</p>
</td></tr>
<tr><td><code id="weighted_combine_list_+3A_w">w</code></td>
<td>
<p>a vector of weights, the weights should have the same number
of elements as 'length(l)'</p>
</td></tr>
<tr><td><code id="weighted_combine_list_+3A_normalize_weights">normalize_weights</code></td>
<td>
<p>whether or not to force the weights to sum to 1,
default is true</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or vector corresponding to the weighted average of
all of the elements in 'l'
</p>

<hr>
<h2 id='weighted_ecdf'>Weighted Distribution Function</h2><span id='topic+weighted_ecdf'></span>

<h3>Description</h3>

<p>Get a distribution function from a vector of values
after applying some weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_ecdf(y, y.seq = NULL, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_ecdf_+3A_y">y</code></td>
<td>
<p>a vector to compute the mean for</p>
</td></tr>
<tr><td><code id="weighted_ecdf_+3A_y.seq">y.seq</code></td>
<td>
<p>an optional vector of values to compute the distribution function
for; the default is to use all unique values of y</p>
</td></tr>
<tr><td><code id="weighted_ecdf_+3A_weights">weights</code></td>
<td>
<p>the vector of weights, can be NULL, then will just return mean</p>
</td></tr>
<tr><td><code id="weighted_ecdf_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ecdf
</p>

<hr>
<h2 id='weighted_mean'>Weighted Mean</h2><span id='topic+weighted_mean'></span>

<h3>Description</h3>

<p>Get the mean applying some weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean(y, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_mean_+3A_y">y</code></td>
<td>
<p>a vector to compute the mean for</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_weights">weights</code></td>
<td>
<p>the vector of weights, can be NULL, then will just return mean</p>
</td></tr>
<tr><td><code id="weighted_mean_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the weighted mean
</p>

<hr>
<h2 id='weighted_quantile'>weighted_quantile</h2><span id='topic+weighted_quantile'></span>

<h3>Description</h3>

<p>function to recover quantiles of a vector with weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_quantile(tau, cvec, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_quantile_+3A_tau">tau</code></td>
<td>
<p>a vector of values between 0 and 1</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_cvec">cvec</code></td>
<td>
<p>a vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
<tr><td><code id="weighted_quantile_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of quantiles
</p>

<hr>
<h2 id='weighted_quantile_inner'>Quantile of a Weighted Check Function</h2><span id='topic+weighted_quantile_inner'></span>

<h3>Description</h3>

<p>Finds the quantile by optimizing the weighted check function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_quantile_inner(tau, cvec, weights = NULL, norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted_quantile_inner_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
<tr><td><code id="weighted_quantile_inner_+3A_cvec">cvec</code></td>
<td>
<p>a vector to compute quantiles for</p>
</td></tr>
<tr><td><code id="weighted_quantile_inner_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
<tr><td><code id="weighted_quantile_inner_+3A_norm">norm</code></td>
<td>
<p>normalize the weights so that they have mean of 1, default is
to normalize</p>
</td></tr>
</table>

<hr>
<h2 id='weighted.checkfun'>weighted.checkfun</h2><span id='topic+weighted.checkfun'></span>

<h3>Description</h3>

<p>Legacy version of 'weighted_checkfun', please use that
function instead.  This function will eventually be deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.checkfun(q, cvec, tau, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted.checkfun_+3A_q">q</code></td>
<td>
<p>the value to check</p>
</td></tr>
<tr><td><code id="weighted.checkfun_+3A_cvec">cvec</code></td>
<td>
<p>vector of data to compute quantiles for</p>
</td></tr>
<tr><td><code id="weighted.checkfun_+3A_tau">tau</code></td>
<td>
<p>between 0 and 1, ex. .5 implies get the median</p>
</td></tr>
<tr><td><code id="weighted.checkfun_+3A_weights">weights</code></td>
<td>
<p>the weights, weighted.checkfun normalizes the weights
to sum to 1.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
