<!DOCTYPE html><html lang="en"><head><title>Help for package mutoss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mutoss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABH_pi0_est'><p>Lowest Slope Line (LSL) method of Hochberg and Benjamini for estimating pi0</p></a></li>
<li><a href='#adaptiveBH'><p>Benjamini-Hochberg (2000) adaptive linear step-up procedure</p></a></li>
<li><a href='#adaptiveSTS'><p>Storey-Taylor-Siegmund (2004) adaptive step-up procedure</p></a></li>
<li><a href='#adjPValuesPlot'><p>A function plotting adjusted p-values...</p></a></li>
<li><a href='#aorc'><p>Step-up-down test based on the asymptotically optimal rejection curve.</p></a></li>
<li><a href='#augmentation'><p>Wrapper function to the augmentation methods of the multtest package.</p></a></li>
<li><a href='#BH'><p>Benjamini-Hochberg (1995) linear step-up procedure</p></a></li>
<li><a href='#BL'><p>Benjamini-Liu (1999) step-down procedure</p></a></li>
<li><a href='#BlaRoq'><p>Blanchard-Roquain (2008) step-up Procedure for arbitrary dependent p-Values...</p></a></li>
<li><a href='#bonferroni'><p>Bonferroni correction...</p></a></li>
<li><a href='#BR_pi0_est'><p>Estimate of pi0 using the one-step Blanchard-Roquain procedure</p></a></li>
<li><a href='#BY'><p>Benjamini-Yekutieli (2001) step-up procedure</p></a></li>
<li><a href='#calculateBetaAdjustment'><p>Calculating the beta adjustment factor for the asymptotically optimal rejection curve.</p></a></li>
<li><a href='#compareMutoss'><p>Functions for comparing outputs of different procedures.</p></a></li>
<li><a href='#ErrorControl-class'><p>Class ErrorControl</p></a></li>
<li><a href='#fisher22_fast'><p>Fisher (2x2) table association analysis for calculating one (marginal) p-value...</p></a></li>
<li><a href='#fisher22.marginal'><p>Fisher (2x2) table association analysis for calculating all marginal p-values...</p></a></li>
<li><a href='#fisher23_fast'><p>Fisher-type (2x3) table association analysis for calculating one (marginal) p-value...</p></a></li>
<li><a href='#fisher23.marginal'><p>Fisher-type (2x3) table association analysis for calculating all marginal p-values...</p></a></li>
<li><a href='#ftest.marginal'><p>Marginal F test</p></a></li>
<li><a href='#gao'><p>Xin Gao's non-parametric multiple test procedure is applied to Data.</p></a></li>
<li><a href='#gatherParameters'><p>Extracts the parameters from the simulation()-Object</p></a></li>
<li><a href='#gatherStatistics'><p>Gathering statistics from simulation()-Object</p></a></li>
<li><a href='#hochberg'><p>Hochberg (1988) step-up procedure</p></a></li>
<li><a href='#holm'><p>Holm's (1979) step-down-procedure</p></a></li>
<li><a href='#hommel'><p>Hommel's (1988) step-up-procedure</p></a></li>
<li><a href='#indepBR'><p>Blanchard-Roquain (2009) 1-stage adaptive step-up</p></a></li>
<li><a href='#jointCDF.orderedUnif'><p>Joint cumulative distribution function of order statistics of n iid. U(0,1)-distributed random variables</p></a></li>
<li><a href='#linearStepUp'><p>Linear Step Up Service Function...</p></a></li>
<li><a href='#mu.test.class'><p>Test for compatible classes for comparison...</p></a></li>
<li><a href='#mu.test.name'><p>Tests if all hypotheses have the same names.</p></a></li>
<li><a href='#mu.test.rates'><p>Tests that different procedures used the same error rates.</p></a></li>
<li><a href='#mu.test.same.data'><p>Tests if the same pvalues were used by different procedures.</p></a></li>
<li><a href='#mu.test.type'><p>Tests that different procedures use the same error types.</p></a></li>
<li><a href='#multcomp.wrapper'><p>Simultaneous confidence intervals for arbitrary parametric contrasts in unbalanced one-way layouts.</p></a></li>
<li><a href='#multiple.down'><p>Benjamini-Krieger-Yekutieli (2006) Multi-Stage Step-Down</p></a></li>
<li><a href='#multiple.down.adjust'><p>A service function used by multiple...</p></a></li>
<li><a href='#Mutoss-class'><p>Class Mutoss</p></a></li>
<li><a href='#mutoss.apply'><p>Applies a function to a Mutoss object.</p></a></li>
<li><a href='#mutoss.models'><p>Mutoss Models</p></a></li>
<li><a href='#mutoss.plotCI'><p>mutoss.plotCI</p></a></li>
<li><a href='#MutossMethod-class'><p>Class MutossMethod</p></a></li>
<li><a href='#notterman'><p>Notterman data set</p></a></li>
<li><a href='#nparcomp'><p>Simultaneous confidence intervals for relative contrast effects...</p></a></li>
<li><a href='#nparcomp.wrapper'><p>Simultaneous confidence intervals for relative contrast effects...</p></a></li>
<li><a href='#onesamp.marginal'><p>Marginal one sample test</p></a></li>
<li><a href='#oracleBH'><p>Bejamini-Hochberg (2000) oracle linear step-up Procedure...</p></a></li>
<li><a href='#paired.marginal'><p>Marginal paired two sample test</p></a></li>
<li><a href='#printRejected'><p>Internal MuTossProjekt-Function</p></a></li>
<li><a href='#pval2locfdr'><p>Strimmer et al.'s fdrtool-based local fdr</p></a></li>
<li><a href='#pval2qval'><p>Strimmer et al.'s fdrtool-based q-values</p></a></li>
<li><a href='#pValuesPlot'><p>A function plotting p-values...</p></a></li>
<li><a href='#Qvalue'><p>Storey's (2001) q-value Procedure...</p></a></li>
<li><a href='#ranktruncated'><p>Rank truncated p-Value procedure...</p></a></li>
<li><a href='#regwq'><p>REGWQ - Ryan / Einot and Gabriel / Welsch  test procedure...</p></a></li>
<li><a href='#reject'><p>reject</p></a></li>
<li><a href='#requireLibrary'><p>Tries to load a package.</p></a></li>
<li><a href='#rom'><p>Rom's (1990) step-up-procedure.</p></a></li>
<li><a href='#SD'><p>A general step-down procedure.</p></a></li>
<li><a href='#sidak'><p>Sidak correction</p></a></li>
<li><a href='#SidakSD'><p>Sidak-like (1987) step-down procedure</p></a></li>
<li><a href='#simulation'><p>Simulation studies</p></a></li>
<li><a href='#snk'><p>Student - Newman - Keuls rejective test procedure.</p></a></li>
<li><a href='#storey_pi0_est'><p>Storey-Taylor-Siegmund estimation of pi0 (finite sample version)</p></a></li>
<li><a href='#SU'><p>A general step-up procedure.</p></a></li>
<li><a href='#SUD'><p>A general step-up-down procedure.</p></a></li>
<li><a href='#TSBKY_pi0_est'><p>Two-step estimation method of Benjamini, Krieger and Yekutieli for estimating pi0</p></a></li>
<li><a href='#tukey.wrapper'><p>Tukey HSD test and simultaneous confidence intervals for all pairs comparisons...</p></a></li>
<li><a href='#two.stage'><p>A p-value procedure which controls the FDR for independent test statistics.</p></a></li>
<li><a href='#twosamp.marginal'><p>Marginal two sample test</p></a></li>
<li><a href='#twostageBR'><p>Blanchard-Roquain (2009) 2-stage adaptive step-up...</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unified Multiple Testing Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-13</td>
</tr>
<tr>
<td>Author:</td>
<td>MuToss Coding Team (Berlin 2010), Gilles Blanchard, Thorsten Dickhaus,
    Niklas Hack, Frank Konietschke, Kornelius Rohmeyer, 
    Jonathan Rosenblatt, Marsel Scheer, Wiebke Werft</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kornelius Rohmeyer &lt;rohmeyer@small-projects.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Designed to ease the application and comparison of multiple
    hypothesis testing procedures for FWER, gFWER, FDR and FDX. Methods are 
    standardized and usable by the accompanying 'mutossGUI'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fdrtool, qvalue, testthat, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>plotrix, multtest (&ge; 2.2.0), multcomp (&ge; 1.1-0), methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kornl/mutoss/">https://github.com/kornl/mutoss/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kornl/mutoss/issues/">https://github.com/kornl/mutoss/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-14 14:56:07 UTC; kornel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-14 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABH_pi0_est'>Lowest Slope Line (LSL) method of Hochberg and Benjamini for estimating pi0</h2><span id='topic+ABH_pi0_est'></span>

<h3>Description</h3>

<p>The Lowest Slope Line (LSL) method of Hochberg and Benjamini for estimating pi0 is applied to pValues.
This method for estimating pi0 is motivated by the graphical approach proposed
by Schweder and Spjotvoll (1982), as developed and presented in Hochberg and Benjamini (1990).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABH_pi0_est(pValues)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ABH_pi0_est_+3A_pvalues">pValues</code></td>
<td>
<p>The raw p-values for the marginal test problems</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pi0.ABH</code></td>
<td>
<p>The estimated proportion of true null hypotheses.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>WerftWiebke</p>


<h3>References</h3>

<p>Hochberg, Y. and Benjamini, Y. (1990). More powerful procedures for multiple significance testing. 
Statistics in Medicine 9, 811-818.
</p>
<p>Schweder, T. and Spjotvoll, E. (1982). Plots of P-values to evaluate many tests simultaneously. 
Biometrika 69, 3, 493-502.</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.pvals &lt;- c(runif(50), runif(50, 0, 0.01))
result &lt;- ABH_pi0_est(my.pvals)</code></pre>

<hr>
<h2 id='adaptiveBH'>Benjamini-Hochberg (2000) adaptive linear step-up procedure</h2><span id='topic+adaptiveBH'></span>

<h3>Description</h3>

<p>The adaptive Benjamini-Hochberg step-up procedure is applied to pValues.
It controls the FDR at level alpha for independent or positive regression dependent test statistics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptiveBH(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adaptiveBH_+3A_pvalues">pValues</code></td>
<td>
<p>The used raw pValues.</p>
</td></tr>
<tr><td><code id="adaptiveBH_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="adaptiveBH_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>In the adaptive Benjamini-Hochberg step-up procedure the number of true null hypotheses is estimated first as in Hochberg and
Benjamini (1990), and this estimate is used in the procedure of Benjamini and
Hochberg (1995) with alpha'=alpha*m/m0.
Please note that this method is not equivalent to multcomp's ABH. They revised the formular of the original paper.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test</p>
</td></tr> 
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>An estimate of the proportion of true null hypotheses among all hypotheses (pi0=m0/m). </p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>WerftWiebke</p>


<h3>References</h3>

<p>Benjamini, Y. and Hochberg, Y. (2000). On the Adaptive Control of the False Discovery Rate
in Multiple Testing With Independent Statistics.
Journal of Educational and Behavioral Statistics, 25(1): 60-83.<code class="reqn">n</code>
</p>
<p>Hochberg, Y. and Benjamini, Y. (1990). More powerful procedures for multiple significance testing. 
Statistics in Medicine 9, 811-818.<code class="reqn">n</code>
</p>
<p>Benjamini, Y. and Hochberg, Y. (1995). Controlling the false discovery rate: A practical and powerful approach to mulitple testing.
Journal of the Royal Statistical Society, Series B, 57:289-300.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9, max=1))
result &lt;- adaptiveBH(p, alpha)
result &lt;- adaptiveBH(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='adaptiveSTS'>Storey-Taylor-Siegmund (2004) adaptive step-up procedure</h2><span id='topic+adaptiveSTS'></span>

<h3>Description</h3>

<p>Storey-Taylor-Siegmund's (2004) adaptive step-up procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptiveSTS(pValues, alpha, lambda=0.5, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adaptiveSTS_+3A_pvalues">pValues</code></td>
<td>
<p>The used raw pValues.</p>
</td></tr>
<tr><td><code id="adaptiveSTS_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="adaptiveSTS_+3A_lambda">lambda</code></td>
<td>
<p>The tuning parameter for the estimation procedure (defaults to 0.5)</p>
</td></tr>
<tr><td><code id="adaptiveSTS_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>The adaptive STS procedure uses a conservative estimate of pi0 which is 
plugged in a linear step-up procedure. The estimation of pi0 requires a 
parameter (lambda) which is set to 0.5 by default.
Note that the estimated pi0 is truncated at 1 as suggested by the author, 
so the implemetation of the procedure is not entirely supported by the proof in the reference.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Werft Wiebke</p>


<h3>References</h3>

<p>Storey, J.D., Taylor, J.E. and Siegmund, D. (2004). Strong control, conservative point estimation and
simultaneous conservative consistency of false discovery rates: a unified approach.
Journal of the Royal Statistical Society, B 66(1):187-205.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9,max=1))
result &lt;- adaptiveSTS(p, alpha, lambda=0.5)
result &lt;- adaptiveSTS(p, alpha, lambda=0.5, silent=TRUE)</code></pre>

<hr>
<h2 id='adjPValuesPlot'>A function plotting adjusted p-values...</h2><span id='topic+adjPValuesPlot'></span>

<h3>Description</h3>

<p>A function plotting adjusted p-values</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjPValuesPlot(adjPValues, alpha)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjPValuesPlot_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>A numeric containing the adjusted pValues to plot.</p>
</td></tr>
<tr><td><code id="adjPValuesPlot_+3A_alpha">alpha</code></td>
<td>
<p>A numeric containing the overall type I error rate alpha..</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='aorc'>Step-up-down test based on the asymptotically optimal rejection curve.</h2><span id='topic+aorc'></span>

<h3>Description</h3>

<p>Performs a step-up-down test on pValues. The critical values are based 
on the asymptotically optimal rejection curve. To have finite FDR control,
an automatic adjustment of the critical values is done (see
details for more).</p>


<h3>Usage</h3>

<pre><code class='language-R'>aorc(pValues, alpha, startIDX_SUD=length(pValues), betaAdjustment,
    silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aorc_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used. They are assumed to be stochastically independent.</p>
</td></tr>
<tr><td><code id="aorc_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="aorc_+3A_startidx_sud">startIDX_SUD</code></td>
<td>
<p>The index at which critical value the 
step-up-down test starts. Default is length(pValues) and thus the function
aorc() by default behaves like an step-up test.</p>
</td></tr>
<tr><td><code id="aorc_+3A_betaadjustment">betaAdjustment</code></td>
<td>
<p>A numeric value to adjust the asymptotically optimal
rejection curve for the finite sample case. If betaAdjustment is not
set an algorithm will calculate it, but this can be time-consuming.</p>
</td></tr>
<tr><td><code id="aorc_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>The graph of the function f(t) = t / (t * (1 - alpha) + alpha) is called the asymptotically
optimal rejection curve. Denote by finv(t) the inverse of f(t). Using the 
critical values finv(i/n) for i = 1, ..., n yields asymptotic FDR control.
To ensure finite control it is possible to adjust f(t) by a factor. The
function calculateBetaAdjustment() calculates a beta such that (1 + beta / n) * f(t)
can be used to control the FDR for a given finite sample size. If the 
parameter betaAdjustment is not provided, calculateBetaAdjustment() will be called automatically.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error (FDR)
controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>References</h3>

<p>Finner, H., Dickhaus, T. &amp; Roters, M. (2009).
On the false discovery rate and an asymptotically optimal rejection curve.
The Annals of Statistics 37, 596-618.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
## Not run:  # Takes more than 6 seconds therefor CRAN should not check it:
r &lt;- c(runif(10), runif(10, 0, 0.01))
result &lt;- aorc(r, 0.05)
result &lt;- aorc(r, 0.05, startIDX_SUD = 1)  ## step-down
result &lt;- aorc(r, 0.05, startIDX_SUD = length(r))  ## step-up
## End(Not run)
</code></pre>

<hr>
<h2 id='augmentation'>Wrapper function to the augmentation methods of the multtest package.</h2><span id='topic+augmentation'></span>

<h3>Description</h3>

<p>Wrapper function to the augmentation methods of the multtest package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>augmentation(adjPValues, newErrorControl, newK, newQ, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augmentation_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>a vector of p-values that are *already* adjusted for FWER</p>
</td></tr>
<tr><td><code id="augmentation_+3A_newerrorcontrol">newErrorControl</code></td>
<td>
<p>new error control type to adjust for. One of (&quot;gFWER&quot;, &quot;FDX&quot;, &quot;FDR&quot;)</p>
</td></tr>
<tr><td><code id="augmentation_+3A_newk">newK</code></td>
<td>
<p>k-parameter if newErrorControl is &quot;gFWER&quot;</p>
</td></tr>
<tr><td><code id="augmentation_+3A_newq">newQ</code></td>
<td>
<p>q-parameter if newErrorControl is &quot;FDX&quot;</p>
</td></tr>
<tr><td><code id="augmentation_+3A_silent">silent</code></td>
<td>
<p>if true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>The augmentation method turns a vector of p-values which are already adjusted for FWER control
into p-values that are adjusted for gFWER, FDX or FDR. The underlying idea (for gFWER and FDX) 
is that the set of hypotheses rejected at a given level alpha under FWER can be &quot;augmented&quot;
by rejecting some additional hypotheses while still ensuring (strong) control of the desired weaker type I criterion.
For FDR, it uses the fact that FDX control for q=alpha=1-sqrt(1-beta) entails FDR control at level beta.
</p>
<p>Use of these augmentation methods is recommended only in the situation where FWER-controlled p-values are
directly available from the data (using some specific method). When only marginal p-values are available,
it is generally prerefable to use other adjustment methods directly aimed at the intended criterion
(as opposed to first adjust for FWER, then augment)
</p>
<p>Note: in the multtest package, two methods (&quot;restricted&quot; and &quot;conservative&quot;) are available for FDR augmentation. 
Here the 'restricted' method is forced for FDR augmentation since it is in fact always valid and better than 
&quot;conservative&quot; (M. van der Laan, personal communication) with respect to power.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the new adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected. Currently always NULL.</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>KornRohm, GillesBlanchard</p>


<h3>References</h3>

<p>Dudoit, S. and van der Laan, M.J. (2008)
Multiple Testing Procedures with Applications to Genomics, Springer. (chapter 6)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  TODO NH (MS) EXAMPLE PROBLEM
p &lt;- c(runif(50), runif(50, 0, 0.01))
fwer_adj &lt;- bonferroni(p)    # adjust for FWER using Bonferroni correction
fdx_adj  &lt;- augmentation(fwer_adj$adjPValues , "FDX", q=0.1, silent = TRUE) #augment to FDX (q=0.1)

## End(Not run)</code></pre>

<hr>
<h2 id='BH'>Benjamini-Hochberg (1995) linear step-up procedure</h2><span id='topic+BH'></span>

<h3>Description</h3>

<p>Benjamini-Hochbergs Linear Step-Up Procedure. 
The procedure controls the FDR when the test statistics are stochastically independent or satisfy positive regression dependency (PRDS) (see Benjamini and Yekutieli 2001 for details).
The Benjamini-Hochberg (BH) step-up procedure considers ordered pValues P_(i). 
It defines k as the largest i for which P_(i) &lt;= i*alpha/m and then 
rejects all associated hypotheses H_(i) for i=1,...,k. In their seminal paper, Benjamini and Hochberg (1995) show 
that for 0 &lt;= m_0 &lt;= m independent pValues corresponding to true null hypotheses 
and for any joint distribution of the m_1 = m-m_0 p-values corresponding to the 
non null hypotheses, the FDR is controlled at level (m_0/m)*alpha.  Under the
assumption of the PRDS property, (for details see Benjamini and Yekutieli 2001). 
In Benjamini et al. (2006) the BH procedure is improved by adaptive procedures
which use an estimate of m_0 and apply the BH method al level alpha'=alpha*m/m_0, to 
fully exhaust the desired level alpha (see Adaptive Benjamini Hochberg and Two Stage Banjamini Yekutieli).</p>


<h3>Usage</h3>

<pre><code class='language-R'>BH(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BH_+3A_pvalues">pValues</code></td>
<td>
<p>The used unadjusted pValues.</p>
</td></tr>
<tr><td><code id="BH_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="BH_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up test</p>
</td></tr> 
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Werft Wiebke</p>


<h3>References</h3>

<p>Benjamini, Y. and Hochberg, Y. (1995). Controlling the false discovery rate: A practical and powerful approach to mulitple testing.
Journal of the Royal Statistical Society, Series B, 57:289-300.<code class="reqn">n</code>
</p>
<p>Benjamini, Y. and Yekutieli, D. (2001). The control of the false discovery rate in multiple testing under dependency.
Annals of Statistics, 29(4):1165-1188.<code class="reqn">n</code>
</p>
<p>Benjamini, Y., Krieger, A. and Yekutieli, D. (2006). Adaptive linear step-up procedures that control the false
discovery rate. Biometrika, 93(3):491-507.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9, max=1))
result &lt;- BH(p, alpha)
result &lt;- BH(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='BL'>Benjamini-Liu (1999) step-down procedure</h2><span id='topic+BL'></span>

<h3>Description</h3>

<p>Benjamini-Liu's step-down procedure is applied to pValues. 
The procedure controls the FDR if the corresponding test statistics are stochastically independent.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BL(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BL_+3A_pvalues">pValues</code></td>
<td>
<p>Numeric vector of p-values</p>
</td></tr>
<tr><td><code id="BL_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR is to be controlled.</p>
</td></tr>
<tr><td><code id="BL_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>The Benjamini-Liu (BL) step-down procedure neither dominates nor is dominated by the Benjamini-Hochberg (BH) step-up procedure.
However, in Benjamini and Liu (1999) a large simulation study concerning the power of the two procedures reveals that the BL step-down procedure is more suitable when the number of hypotheses is small. 
Moreover, if most hypotheses are far from the null then the BL step-down procedure is more powerful than the BH step-up method.
The BL step-down method calculates critical values according to Benjamin and Liu (1999), 
i.e., c_i = 1 - (1 - min(1, (m*alpha)/(m-i+1)))^(1/(m-i+1)) for i = 1,...,m, where m is the number of hypotheses tested. 
Then, let k be the smallest i for which P_(i) &gt; c_i and reject the associated hypotheses H_(1),...,H_(k-1).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues.</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test.</p>
</td></tr> 
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected.</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Werft Wiebke</p>


<h3>References</h3>

<p>Bejamini, Y. and Liu, W. (1999). A step-down multiple hypotheses testing procedure that controls the false discovery rate under independence. 
Journal of Statistical Planning and Inference Vol. 82(1-2): 163-170.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9, max=1))
result &lt;- BL(p, alpha)
result &lt;- BL(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='BlaRoq'>Blanchard-Roquain (2008) step-up Procedure for arbitrary dependent p-Values...</h2><span id='topic+BlaRoq'></span>

<h3>Description</h3>

<p>Blanchard-Roquain (2008) step-up Procedure for arbitrary dependent p-Values
Also proposed independently by Sarkar (2008)</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlaRoq(pValues, alpha, pii, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BlaRoq_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used. They can have arbitrary dependence.</p>
</td></tr>
<tr><td><code id="BlaRoq_+3A_alpha">alpha</code></td>
<td>
<p>the level at which the FDR should be controlled</p>
</td></tr>
<tr><td><code id="BlaRoq_+3A_pii">pii</code></td>
<td>
<p>Prior for the proportion of true null hypotheses, same size as pValues</p>
</td></tr>
<tr><td><code id="BlaRoq_+3A_silent">silent</code></td>
<td>
<p>if true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>A generalization of the Benjamini-Yekutieli procedure, taking as an additional parameter
a distribution pii on [1..k] (k is the number of hypotheses)
representing prior belief on the number of hypotheses that will be rejected.
</p>
<p>It is a step-up Procedure with critical values C_i defined as alpha/k times
the sum for j in [1..i] of j*pii[j]. For any fixed prior pii, the FDR is controlled at
level alpha for arbitrary dependence structure of the p-Values. The particular case of the
Benjamini-Yekutieli step-up is recovered by taking pii[i] proportional to 1/i.
</p>
<p>If pii is missing, a default prior distribution proportional to exp( -i/(0.15*k) ) is taken.
It should perform better than the BY procedure if more than about 0.05 to 0.1 of hypotheses are rejected,
and worse otherwise.
</p>
<p>Note: the procedure automatically normalizes the prior pii to sum to one if this is not the case.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up test</p>
</td></tr> 
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>GillesBlanchard,HackNiklas</p>


<h3>References</h3>

<p>Blanchard, G. and Roquain, E. (2008). Two simple sufficient conditions for FDR control.
Electronic Journal of Statistics, 2:963-992. 
Sarkar, S.K. (2008) On methods controlling the false discovery rate. 
Sankhya, Series A, 70:135-168.</p>

<hr>
<h2 id='bonferroni'>Bonferroni correction...</h2><span id='topic+bonferroni'></span>

<h3>Description</h3>

<p>Bonferroni correction</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonferroni(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bonferroni_+3A_pvalues">pValues</code></td>
<td>

<p>A numeric vector containing the unadjusted pValues. No assumption is made on the dependence structure.
</p>
</td></tr>
<tr><td><code id="bonferroni_+3A_alpha">alpha</code></td>
<td>

<p>The overall type I error at which the FWER shall be controlled (optional).
</p>
</td></tr>
<tr><td><code id="bonferroni_+3A_silent">silent</code></td>
<td>

<p>logical scalar. If <code>TRUE</code> no output is generated.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical Bonferroni correction outputs adjusted p-values, ensuring strong FWER control under arbitrary
dependence of the input p-values. It simply multiplies each input p-value by the total number of hypotheses
(and ceils at value 1).
</p>
<p>It is recommended to use Holm's step-down instead, which is valid under the exact same assumptions and more powerful.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the new adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>(if alpha is given) A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>References</h3>

<p>Bonferroni, C. E. (1935) Il calcolo delle assicurazioni su gruppi di teste. 
'In Studi in Onore del Professore Salvatore Ortu Carboni. Rome: Italy, pp. 13-60.
</p>
<p>Bonferroni, C. E. (1936) Teoria statistica delle classi e calcolo delle probabilita.
Pubblicazioni del R Istituto Superiore di Scienze Economiche e Commerciali di Firenze 8, 3-62, 1936.</p>

<hr>
<h2 id='BR_pi0_est'>Estimate of pi0 using the one-step Blanchard-Roquain procedure</h2><span id='topic+BR_pi0_est'></span>

<h3>Description</h3>

<p>The proportion of true nulls is estimated using the Blanchard-Roquain 1-stage 
procedure with parameter (alpha,lambda) via the formula</p>


<h3>Usage</h3>

<pre><code class='language-R'>BR_pi0_est(pValues, alpha, lambda=1, truncate=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BR_pi0_est_+3A_pvalues">pValues</code></td>
<td>
<p>The raw p-values for the marginal test problems (assumed to be independent)</p>
</td></tr>
<tr><td><code id="BR_pi0_est_+3A_alpha">alpha</code></td>
<td>
<p>The FDR significance level for the BR procedure</p>
</td></tr>
<tr><td><code id="BR_pi0_est_+3A_lambda">lambda</code></td>
<td>
<p>(default 1) The parameter for the BR procedure, shoud belong to (0, 1/alpha)</p>
</td></tr>
<tr><td><code id="BR_pi0_est_+3A_truncate">truncate</code></td>
<td>
<p>(logical, default TRUE) if TRUE, output estimated is truncated to 1</p>
</td></tr></table>


<h3>Details</h3>

<p>estimated pi_0 = ( m - R(alpha,lambda)  + 1) / ( m*( 1 - lambda * alpha ) )
</p>
<p>where R(alpha,lambda) is the number of hypotheses rejected by the BR 1-stage procedure,
alpha is the FDR level for this procedure and lambda a 
parameter belonging to (0, 1/alpha) with default value 1. 
Independence of p-values is assumed.
This estimate may in some cases be larger than 1; it is truncated to 1 if the parameter truncated=TRUE.
The estimate is used in the Blanchard-Roquain 2-stage step-up (using the non-truncated version)</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pi0</code></td>
<td>
<p>The estimated proportion of true null hypotheses.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>GillesBlanchard</p>


<h3>References</h3>

<p>Blanchard</p>

<hr>
<h2 id='BY'>Benjamini-Yekutieli (2001) step-up procedure</h2><span id='topic+BY'></span>

<h3>Description</h3>

<p>The Benjamini-Yekutieli step-up procedure is applied to pValues. 
The procedure ensures FDR control for any dependency structure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BY(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BY_+3A_pvalues">pValues</code></td>
<td>
<p>The used unadjusted pValues.</p>
</td></tr>
<tr><td><code id="BY_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="BY_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>The critical values of the Benjamini-Yekutieli (BY) procedure are calculated by 
replacing the alpha of the Benjamini-Hochberg procedure by alpha/sum(1/1:m)), i.e.,
c(i)=i*alpha/(m*(sum(1/1:m))) for i=1,...,m. For large number m of hypotheses the critical values of the BY procedure and the 
BH procedure differ by a factor log(m). Benjamini and Yekutieli (2001) showed that this step-up procedure controls
the FDR at level alpha*m/m0 for any dependency structure among the test statistics.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test</p>
</td></tr> 
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>WerftWiebke</p>


<h3>References</h3>

<p>Benjamini, Y. and Yekutieli, D. (2001). The control of the false discovery rate in multiple testing under dependency.
Annals of Statistics, 29(4):1165-1188.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9, max=1))
result &lt;- BY(p, alpha)
result &lt;- BY(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='calculateBetaAdjustment'>Calculating the beta adjustment factor for the asymptotically optimal rejection curve.</h2><span id='topic+calculateBetaAdjustment'></span>

<h3>Description</h3>

<p>Calculates the beta to adjust the asymptotically optimal rejection curve
used by the function aorc() for a finite sample size. Then  
aorc(..., betaAdjustment = beta) controls the FDR also in the
finite sample situation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateBetaAdjustment(n, startIDX_SUD, alpha, silent=FALSE,
    initialBeta=1, maxBinarySteps=50, tolerance=1e-04)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateBetaAdjustment_+3A_n">n</code></td>
<td>
<p>Number of tests for which the adjusted beta should be calculated.</p>
</td></tr>
<tr><td><code id="calculateBetaAdjustment_+3A_startidx_sud">startIDX_SUD</code></td>
<td>
<p>Starting index of the step-up-down procedure</p>
</td></tr>
<tr><td><code id="calculateBetaAdjustment_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="calculateBetaAdjustment_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr>
<tr><td><code id="calculateBetaAdjustment_+3A_initialbeta">initialBeta</code></td>
<td>
<p>Initial beta.</p>
</td></tr>
<tr><td><code id="calculateBetaAdjustment_+3A_maxbinarysteps">maxBinarySteps</code></td>
<td>
<p>Maximum number of steps that will be performed.</p>
</td></tr>
<tr><td><code id="calculateBetaAdjustment_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance to search for an upper FDR bound element in [alpha - tolerance, alpha]</p>
</td></tr></table>


<h3>Details</h3>

<p>The asymptotically optimal rejection curve, denoted by f(t), does not 
provide finite control of the FDR. calculateBetaAdjustment() calculates
a factor, denoted by beta, such that (1 + beta/n) * f(t) provides
finite control of the FDR.
</p>
<p>The beta is calculated with the bisection approach. Assume there are beta1
and beta2 such that the choosing beta1 controls the FDR and beta2 not, then the 
optimal beta lies in [beta2, beta1]. If the choice (beta2 + beta1)/2 controls
the FDR, the optimal FDR lies in [(beta2 + beta1)/2, beta1]
and so on.</p>


<h3>Value</h3>

<p>The adjustment factor that is needed to ensure control of
the FDR with the adjusted asymptotically optimal rejection curve
at the specified level and sample size.</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>

<hr>
<h2 id='compareMutoss'>Functions for comparing outputs of different procedures.</h2><span id='topic+compareMutoss'></span><span id='topic+mu.compare.adjusted'></span><span id='topic+mu.compare.critical'></span><span id='topic+mu.compare.summary'></span>

<h3>Description</h3>

<p>Functions for comparing outputs of different procedures.</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareMutoss(...)
mu.compare.adjusted(comparison.list, identify.check=F)
mu.compare.critical(comparison.list, identify.check=F)
mu.compare.summary(comparison.list)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareMutoss_+3A_...">...</code></td>
<td>
<p>An arbitrary number of Motoss class objects.</p>
</td></tr>
<tr><td><code id="compareMutoss_+3A_comparison.list">comparison.list</code></td>
<td>
<p>The output of the <code>compareMutoss</code> function.</p>
</td></tr>
<tr><td><code id="compareMutoss_+3A_identify.check">identify.check</code></td>
<td>
<p>Logical parameter specifying if hypotheses should be identified on the output plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used to compare the results of different multiple comparisons procedures stored as Mutoss class objects.
<code>compareMutoss</code> takes as input an arbitrary number of Mutoss objects and arranges them in a simple list objects (non S4).
<code>mu.compare.adjuted</code>, <code>mu.compare.critical</code> and <code>mu.compare.summary</code> take the output of the <code>compareMutoss</code> and plots or summerize the results textually or graphically.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>compareMutoss</code></td>
<td>
<p>Returns a list with the following components:<br />
<b>types</b>: Character vector of error types corrsponding to each procedure.<br />
<b>rates</b>: Numeric vector of error rates used for each procedure.<br />
<b>pi.nulls</b>: Numeric vector of estimates of the proportion of true null hypothesis if avilable.<br />
<b>raw.pValues</b>: The raw p-values used for each procedure.<br />
<b>adjusted.pvals</b>: Data frame with columns holding procedure specific adjusted p values.<br />
<b>criticalValue</b>: Data frame with columns holding the critical values corresponding to each procedure and error rate.<br />
<b>rejections</b>: Data frame with columns holding logical vectors of rejected hypotheses (TRUE for rejected).<br /></p>
</td></tr>
<tr><td><code>mu.compare.adjusted</code></td>
<td>
<p>Creates a plot with the adjusted p-values for each procedure.</p>
</td></tr>
<tr><td><code>mu.compare.critical</code></td>
<td>
<p>Creates a plot with the critical values for each procedure and error rate.</p>
</td></tr>
<tr><td><code>mu.compare.summary</code></td>
<td>
<p>Creates a short textual summary for comparing results of different procedures.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Jonathan Rosenblatt</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO: EXAMPLE PROBLEMS
## Not run: 
\dontrun{Creating several Mutoss class objects}
mu.test.obj.1 &lt;- mutoss.apply(new(Class="Mutoss", 
                                  pValues=runif(10)), 
                                  f=bonferroni, 
                                  label="Bonferroni Correction", 
                                  alpha=0.05, 
                                  silent=T)
mu.test.obj.2 &lt;- mutoss.apply(new(Class="Mutoss", 
                                  pValues=runif(10)), 
                                  f=holm, 
                                  label="Holm's step-down-procedure", 
                                  alpha=0.05,
                                  silent=T)
mu.test.obj.3 &lt;- mutoss.apply(new(Class="Mutoss", 
                                  pValues=runif(10)), 
                                  f=aorc, 
                                  label="Asymtotically optimal rejection curve", 
                                  alpha=0.05, 
                                  startIDX_SUD = 1, 
                                  silent=T)
\dontrun{Trying to coercing a non-Mutoss object}
compareMutoss(1)
\dontrun{ Coercing several objects into a list}
compare.1&lt;- compareMutoss(mu.test.obj.1, mu.test.obj.2)
compare.2&lt;- compareMutoss(mu.test.obj.1, mu.test.obj.2, mu.test.obj.3)
\dontrun{Plotting the adjusted pvalues. Identification available.}
mu.compare.adjusted(compare.1, T)
mu.compare.adjusted(compare.2, T)
\dontrun{Plotting the critical values. Identification available.}
mu.compare.critical(compare.1, T)
mu.compare.critical(compare.2, T)
\dontrun{Showing a textual sumary}
mu.compare.summary(compare.1)
mu.compare.summary(compare.2)

## End(Not run)</code></pre>

<hr>
<h2 id='ErrorControl-class'>Class ErrorControl</h2><span id='topic+ErrorControl-class'></span>

<h3>Description</h3>

<p>This class holds the information related to the error rate</p>


<h3>Slots</h3>


<dl>
<dt><code>type</code>:</dt><dd><p>a character specifying the error rate. For example FWER, FDR, ... </p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>the level at which the error rate shall be controlled</p>
</dd>
<dt><code>k</code>:</dt><dd><p>an additional parameter for generalised FWER</p>
</dd>
<dt><code>q</code>:</dt><dd><p>an additional parameter for FDX (false discovery exceedance)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='fisher22_fast'>Fisher (2x2) table association analysis for calculating one (marginal) p-value...</h2><span id='topic+fisher22_fast'></span>

<h3>Description</h3>

<p>Fisher (2x2) table association analysis for calculating one (marginal) p-value</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher22_fast(obs, epsilon)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher22_fast_+3A_obs">obs</code></td>
<td>
<p>The observed (2x2) table</p>
</td></tr>
<tr><td><code id="fisher22_fast_+3A_epsilon">epsilon</code></td>
<td>
<p>A threshold for comparing real numbers to zero</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>nonrand_p</code></td>
<td>
<p>The non-randomized (conservative) p-value</p>
</td></tr>
<tr><td><code>rand_p</code></td>
<td>
<p>The randomized (non-conservative) p-value</p>
</td></tr>
<tr><td><code>prob_table</code></td>
<td>
<p>The conditional probability of the observed table (given the merginals)</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>ThorstenDickhaus</p>

<hr>
<h2 id='fisher22.marginal'>Fisher (2x2) table association analysis for calculating all marginal p-values...</h2><span id='topic+fisher22.marginal'></span>

<h3>Description</h3>

<p>Fisher (2x2) table association analysis for calculating all marginal p-values</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher22.marginal(data, model)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher22.marginal_+3A_data">data</code></td>
<td>
<p>A tensor of dimension (2x2xm) where m is the number of endpoints (genes, etc.)</p>
</td></tr>
<tr><td><code id="fisher22.marginal_+3A_model">model</code></td>
<td>
<p>A model object indicating that this type of analysis shall be performed</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing the m marginal p-values</p>


<h3>Author(s)</h3>

<p>ThorstenDickhaus</p>

<hr>
<h2 id='fisher23_fast'>Fisher-type (2x3) table association analysis for calculating one (marginal) p-value...</h2><span id='topic+fisher23_fast'></span>

<h3>Description</h3>

<p>Fisher-type (2x3) table association analysis for calculating one (marginal) p-value</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher23_fast(obs, epsilon)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher23_fast_+3A_obs">obs</code></td>
<td>
<p>The observed (2x3) table</p>
</td></tr>
<tr><td><code id="fisher23_fast_+3A_epsilon">epsilon</code></td>
<td>
<p>A threshold for comparing real numbers to zero</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>nonrand_p</code></td>
<td>
<p>The non-randomized (conservative) p-value</p>
</td></tr>
<tr><td><code>rand_p</code></td>
<td>
<p>The randomized (non-conservative) p-value</p>
</td></tr>
<tr><td><code>prob_table</code></td>
<td>
<p>The conditional probability of the observed table (given the merginals)</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>ThorstenDickhaus</p>

<hr>
<h2 id='fisher23.marginal'>Fisher-type (2x3) table association analysis for calculating all marginal p-values...</h2><span id='topic+fisher23.marginal'></span>

<h3>Description</h3>

<p>Fisher-type (2x3) table association analysis for calculating all marginal p-values</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher23.marginal(data, model)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher23.marginal_+3A_data">data</code></td>
<td>
<p>A tensor of dimension (2x3xm) where m is the number of endpoints (genes, etc.)</p>
</td></tr>
<tr><td><code id="fisher23.marginal_+3A_model">model</code></td>
<td>
<p>A model object indicating that this type of analysis shall be performed</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing the m marginal p-values</p>


<h3>Author(s)</h3>

<p>ThorstenDickhaus</p>

<hr>
<h2 id='ftest.marginal'>Marginal F test</h2><span id='topic+ftest.marginal'></span>

<h3>Description</h3>

<p>The robust version uses the Kruskal-Wallis test, otherwise a F-test will be performed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ftest.marginal(data, model, robust)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ftest.marginal_+3A_data">data</code></td>
<td>
<p>the data set</p>
</td></tr>
<tr><td><code id="ftest.marginal_+3A_model">model</code></td>
<td>
<p>the result of a call to <code>ftest.model(classlabel)</code></p>
</td></tr>
<tr><td><code id="ftest.marginal_+3A_robust">robust</code></td>
<td>
<p>a logical variable indicating whether a F-test or a Kruskal-Wallis test should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A classlabel needs to be provided to distinguish k sample groups.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pValues</code></td>
<td>
<p>A numeric vector containing the unadjusted pValues</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>References</h3>

<p>Kruskal, W.H. und Wallis, W.A. (1952). Use of ranks in one-criterion variance analysis. JASA, 47:583-621</p>

<hr>
<h2 id='gao'>Xin Gao's non-parametric multiple test procedure is applied to Data.</h2><span id='topic+gao'></span><span id='topic+gao.wrapper'></span>

<h3>Description</h3>

<p>Xin Gao's non-parametric multiple test procedure is applied to Data. 
The procedure controls the FWER in the strong sense. Here, only the Many-To-One comparisons are computed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gao(formula, data, alpha=0.05, control=NULL, silent=FALSE)
gao.wrapper(model, data, alpha, control)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gao_+3A_formula">formula</code></td>
<td>
<p>Formula defining the statistical model, containing the response and the factors</p>
</td></tr>
<tr><td><code id="gao_+3A_model">model</code></td>
<td>
<p>Model with formula, containing the response and the factors</p>
</td></tr>
<tr><td><code id="gao_+3A_data">data</code></td>
<td>
<p>Dataset containing the response and the grouping factor</p>
</td></tr>
<tr><td><code id="gao_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FWER shall be controlled. By default it is alpha=0.05.</p>
</td></tr>
<tr><td><code id="gao_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr>
<tr><td><code id="gao_+3A_control">control</code></td>
<td>
<p>The control group for the Many-To-One comparisons. By default it is the first group in lexicographical order.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function computes Xin Gao's nonparametric multiple test procedures in an unbalanced one way layout. 
It is based upon the following purely nonparametric effects: 
Let <code class="reqn">F_i</code> denote the distribution function of sample <code class="reqn">i, i=1,\ldots,a,</code> and let <code class="reqn">G</code> denote the mean distribution function
of all distribution functions <code class="reqn">(G=1/a\sum_i F_i)</code>. The effects <code class="reqn">p_i=\int GdF_i</code> are called unweighted relative effects. If <code class="reqn">p_i&gt;1/2</code>, the random
variables from sample <code class="reqn">i</code> tend (stochastically) to larger values than any randomly chosen number 
from the whole experiment. If <code class="reqn">p_i = 1/2</code>, there is no tendency to smaller nor larger values. However,
this approach tests the hypothesis <code class="reqn">H_0^F: F_1=F_j, j=2,\ldots,a</code> formulated in terms of the
distribution functions, simultaneously.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing the estimates and the lower and upper confidence bound</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Frank Konietschke</p>


<h3>References</h3>

<p>Gao, X. et al. (2008). Nonparametric multiple comparison procedures for unbalanced
one-way factorial designs. 
Journal of Statistical Planning and Inference 77, 2574-2591. <code class="reqn">n</code>
The FWER is controlled by using the Hochberg adjustment
(Hochberg, Y. (1988). A sharper Bonferroni procedure for multiple tests of significance. Biometrika 75, 800-802.)</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=c(rnorm(40))
f1=c(rep(1,10),rep(2,10),rep(3,10),rep(4,10))
my.data &lt;- data.frame(x,f1)
result &lt;- gao(x~f1,data=my.data, alpha=0.05,control=2, silent=FALSE)
result &lt;- gao(x~f1,data=my.data, alpha=0.05,control=2, silent=TRUE)
result &lt;- gao(x~f1,data=my.data, alpha=0.05)</code></pre>

<hr>
<h2 id='gatherParameters'>Extracts the parameters from the simulation()-Object</h2><span id='topic+gatherParameters'></span>

<h3>Description</h3>

<p>Basically, it is a helper function for gatherStatistics(). 
It extracts the parameters from the simObject$results and
creates a data.frame from this. Every used parameter gets its own column.
Every row corresponds to one object in simObject$results. If a object A from
simObject$results does not contain a parameter P that another object B does, 
then the row for object A will have &quot;&quot; in the column for the parameter P.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gatherParameters(simObject)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gatherParameters_+3A_simobject">simObject</code></td>
<td>
<p>An object returned by simulation()</p>
</td></tr></table>


<h3>Value</h3>

<p>A data.frame with rows for every object in simObject$results and columns for
the used parameter.</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # this function generates pValues 
myGen &lt;- function(n, n0) {
  list(procInput=list(pValues = c(runif(n-n0, 0, 0.01), 
       runif(n0))), groundTruth = c(rep(FALSE, times=n-n0), rep(TRUE, times=n0)))
}

# need some simulation()-Object I can work with 
sim &lt;- simulation(replications = 3, list(funName="myGen", fun=myGen, n=200, n0=c(50,100)), 
list(list(funName="BH", fun=function(pValues, alpha) BH(pValues, alpha, silent=TRUE), 
  alpha=c(0.25, 0.5)),
list(funName="holm", fun=holm, alpha=c(0.25, 0.5),silent=TRUE)))

gatherParameters(sim)</code></pre>

<hr>
<h2 id='gatherStatistics'>Gathering statistics from simulation()-Object</h2><span id='topic+gatherStatistics'></span>

<h3>Description</h3>

<p>This function facilitates gathering statistics from the object returned by simulation().</p>


<h3>Usage</h3>

<pre><code class='language-R'>gatherStatistics(simObject, listOfStatisticFunctions,
    listOfAvgFunctions)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gatherStatistics_+3A_simobject">simObject</code></td>
<td>
<p>An object returned by simulation()</p>
</td></tr>
<tr><td><code id="gatherStatistics_+3A_listofstatisticfunctions">listOfStatisticFunctions</code></td>
<td>
<p>List of statistics that shall be calculated for the elements in simObject</p>
</td></tr>
<tr><td><code id="gatherStatistics_+3A_listofavgfunctions">listOfAvgFunctions</code></td>
<td>
<p>List of functions that will be used to summarize/average the calculated statistics for
all elements in simObject$results with the same parameter constellation. If this is argument is missing no averaging
will be done. Instead the resulting data.frame will keep one row
for every object in simObject$results.</p>
</td></tr></table>


<h3>Details</h3>

<p>For every simulation()-Object in simObject$results all statistics in listOfStatisticFunctions are calculated. 
If in addition listOfAvgFunctions is provided then the statistics of the objects that have the same
parameter constellation are averaged by the functions in listOfAvgFunctions. 
The resulting data.frame will then keep only one row for every parameter constellation.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>statisticDF</code></td>
<td>
<p>A data.frame that can be of two different kinds. 
</p>
<p>If listOfAvgFunctions is provided, then the resulting data.frame will have a row for every 
parameter constellation that occurs in the simObject$results. There will be columns for every
parameter used. Also length(listOfAvgFunctions) * length(listOfStatisticFunctions) additional
columns will be created. Every statistic is calculated for every applied procedure and then
all values that belong to a specific parameter constellation are &quot;averaged&quot; by applying all 
function from listOfAvgFunctions. For example, suppose FDP is a function from listOfStatisticFunctions
that calculates the realized false discovery proportion, that is number of true hypotheses that
were rejected divided by the number of all rejected hypotheses. Also suppose mean and sd are 
functions in listOfAvgFunctions, then the mean and the standard deviation of the 
statistic FDP are calculated.  
</p>
<p>If listOfAvgFunctions is not provided, then the resulting data.frame will have a row for every
simObject$results. Every parameter will have its own column. Additional columns for every function
in listOfStatisticFunction will be created.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # this function generates pValues 
myGen &lt;- function(n, n0) {
  list(procInput=list(pValues = c(runif(n-n0, 0, 0.01), runif(n0))), 
       groundTruth = c(rep(FALSE, times=n-n0), rep(TRUE, times=n0)))
}

# need some simulation()-Object I can work with 
sim &lt;- simulation(replications = 10, list(funName="myGen", fun=myGen, n=200, n0=c(50,100)), 
list(list(funName="BH", fun=function(pValues, alpha) BH(pValues, alpha, silent=TRUE), 
  alpha=c(0.25, 0.5)),
list(funName="holm", fun=holm, alpha=c(0.25, 0.5),silent=TRUE)))

# Make my own statistic function
NumberOfType1Error &lt;- function(data, result) sum(data$groundTruth * result$rejected)

# Get now for every object in sim$results one row with the number of Type 1 Errors
result.all &lt;- gatherStatistics(sim, list(NumOfType1Err = NumberOfType1Error))

# Average over all sim$results-Objects with common parameters 
result1 &lt;- gatherStatistics(sim, list(NumOfType1Err = NumberOfType1Error), list(MEAN = mean))
print(result1)  
result2 &lt;- gatherStatistics(sim, list(NumOfType1Err = NumberOfType1Error), 
             list(q05 = function(x) quantile(x, probs=0.05), 
             MEAN = mean, q95 = function(x) quantile(x, probs=0.95)))
print(result2)

# create some plots
require(lattice)
histogram(~NumOfType1Err | method*alpha, data = result.all$statisticDF)
barchart(NumOfType1Err.MEAN ~ method | alpha, data = result2$statisticDF)</code></pre>

<hr>
<h2 id='hochberg'>Hochberg (1988) step-up procedure</h2><span id='topic+hochberg'></span>

<h3>Description</h3>

<p>The Hochberg step-up procedure is based on marginal p-values. It controls the FWER in the strong 
sense under joint null distributions of the test statistics that satisfy Simes' inequality.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hochberg(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hochberg_+3A_pvalues">pValues</code></td>
<td>
<p>The used raw pValues.</p>
</td></tr>
<tr><td><code id="hochberg_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FDR shall be controlled.</p>
</td></tr>
<tr><td><code id="hochberg_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>The Hochberg procedure is more powerful than Holm's (1979) procedure, but the test statistics need to be
independent or have a distribution with multivariate total positivity of order two or a scale mixture
thereof for its validity (Sarkar, 1998).
Both procedures use the same set of critical values c(i)=alpha/(m-i+1). Whereas Holm's procedure is a step-down 
version of the Bonferroni test, and Hochberg's is a step-up version of the Bonferroni test.
Note that Holm's method is based on the Bonferroni inequality and is valid regardless of the joint
distribution of the test statistics.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>WerftWiebke</p>


<h3>References</h3>

<p>Hochberg, Y. (1988). A sharper Bonferroni procedure for multiple tests of significance. 
Biometrika, 75:800-802.<code class="reqn">n</code>
</p>
<p>Huang, Y. and Hsu, J. (2007). Hochberg's step-up method: cutting corners off Holm's step-down method. Biometrika, 94(4):965-975.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9,max=1))
result &lt;- hochberg(p, alpha)
result &lt;- hochberg(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='holm'>Holm's (1979) step-down-procedure</h2><span id='topic+holm'></span>

<h3>Description</h3>

<p>Holm's step-down-procedure is applied to pValues. It controls
the FWER in the strong sense under arbitrary dependency.</p>


<h3>Usage</h3>

<pre><code class='language-R'>holm(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="holm_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used. They can have arbitrary dependency structure.</p>
</td></tr>
<tr><td><code id="holm_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FWER shall be controlled</p>
</td></tr>
<tr><td><code id="holm_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>Holm's procedure uses the same critical values as Hochberg's procedure, namely  c(i)=alpha/(m-i+1), 
but is a step-down version while Hochberg's method is a step-up version of the Bonferroni test.
Holm's method is based on the Bonferroni inequality and is valid regardless of the joint
distribution of the test statistics, whereas Hochberg's method relies on the assumption that 
Simes' inequality holds for the joint null distribution of the test statistics. If this assumption is met, Hochberg's
step-up procedure is more powerful than Holm's step-down procedure.</p>


<h3>Value</h3>

<p>A list containing: 
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-down test</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>References</h3>

<p>S. Holm (1979). A simple sequentially rejective multiple 
test procedure. Scand. J. Statist. Vol. 6, 65-70. <code class="reqn">n</code>
</p>
<p>Huang, Y. and Hsu, J. (2007). Hochberg's step-up method: cutting corners off Holm's step-down method. Biometrika, 94(4):965-975.</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- c(runif(50), runif(50, 0, 0.01))
result 	&lt;- holm(r, 0.05)
result 	&lt;- holm(r, 0.05, silent = TRUE)</code></pre>

<hr>
<h2 id='hommel'>Hommel's (1988) step-up-procedure</h2><span id='topic+hommel'></span>

<h3>Description</h3>

<p>Hommel's step-up-procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>hommel(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hommel_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used. They need a independent structure.</p>
</td></tr>
<tr><td><code id="hommel_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FWER should be controlled</p>
</td></tr>
<tr><td><code id="hommel_+3A_silent">silent</code></td>
<td>
<p>Logical. If true, any output on the console will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is applied to p-values. It controls
the FWER in the strong sense when the hypothesis tests are independent
or when they are non-negatively associated.
</p>
<p>The method is based upon the closure principle and the Simes test.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test.</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>HackNiklas</p>


<h3>References</h3>

<p>G. Hommel (1988). A stagewise rejective multiple test procedure based on a modified Bonferroni test. Biometrika 75, pp. 383-386</p>


<h3>Examples</h3>

<pre><code class='language-R'>pval &lt;- c(runif(50), runif(50, 0, 0.01))
result 	&lt;- hommel(pval, 0.05)
result 	&lt;- hommel(pval, 0.05, silent = TRUE)
</code></pre>

<hr>
<h2 id='indepBR'>Blanchard-Roquain (2009) 1-stage adaptive step-up</h2><span id='topic+indepBR'></span>

<h3>Description</h3>

<p>Blanchard-Roquain (2009) 1-stage adaptive step-up</p>


<h3>Usage</h3>

<pre><code class='language-R'>indepBR(pValues, alpha, lambda=1, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="indepBR_+3A_pvalues">pValues</code></td>
<td>
<p>the used p-values (assumed to be independent)</p>
</td></tr>
<tr><td><code id="indepBR_+3A_alpha">alpha</code></td>
<td>
<p>the level at which the FDR should be controlled.</p>
</td></tr>
<tr><td><code id="indepBR_+3A_lambda">lambda</code></td>
<td>
<p>parameter of the procedure, should belong to
(0, 1/alpha) (lambda=1 default)</p>
</td></tr>
<tr><td><code id="indepBR_+3A_silent">silent</code></td>
<td>
<p>if true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>This is a step-up procedure with critical values
</p>
<p>C_i = alpha * min( i * ( 1 - lambda * alpha) / (m - i + 1) , lambda )
</p>
<p>where alpha is the level at which FDR should be controlled and lambda an 
arbitrary parameter belonging to (0, 1/alpha) with default value 1.
This procedure controls FDR at the desired level when the p-values are independent.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>GillesBlanchard</p>


<h3>References</h3>

<p>Blanchard, G. and Roquain, E. (2009) 
Adaptive False Discovery Rate Control under Independence and Dependence
Journal of Machine Learning Research 10:2837-2871.</p>

<hr>
<h2 id='jointCDF.orderedUnif'>Joint cumulative distribution function of order statistics of n iid. U(0,1)-distributed random variables</h2><span id='topic+jointCDF.orderedUnif'></span>

<h3>Description</h3>

<p>Calculates the joint cumulative distribution function of order statistics 
of n iid. U(0,1)-distributed random variables at argument vec. 
Because of numerical issues n should not be greater than 100.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointCDF.orderedUnif(vec)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointCDF.orderedUnif_+3A_vec">vec</code></td>
<td>
<p>a numeric vector. The length of the vector also
determines the number of random variables considered.</p>
</td></tr></table>


<h3>Details</h3>

<p>Following Shorack, Wellner (1986) or Finner, Roters (2002) by applying
Bolshev's recursion the joint distribution is calculated.</p>


<h3>Value</h3>

<p>The return value is the following probability 
P(U_(1:n) &lt;= vec[1], ..., U_(n:n) &lt;= vec[n]), where
U_1, ..., U_n are assumed to be iid. uniformly 
distributed on [0,1]. The i-th ordered value is denoted by
U_(i:n) and n equals length(vec)</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>References</h3>

<p>Shorack, G. R. and Wellner, J. A. (1986). 
Empirical Processes with Applications to Statistics.
Wiley, New York.
</p>
<p>Finner, H. and Roters, M. (2002). Multiple hypotheses testing and
expected type I errors. Ann. Statist. 30, 220-238.</p>

<hr>
<h2 id='linearStepUp'>Linear Step Up Service Function...</h2><span id='topic+linearStepUp'></span>

<h3>Description</h3>

<p>Linear Step Up Service Function</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearStepUp(sorted, q, m, adjust=FALSE, m0=m, pi0, constant=1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linearStepUp_+3A_sorted">sorted</code></td>
<td>
<p>Numeric vector of sorted pvalues</p>
</td></tr>
<tr><td><code id="linearStepUp_+3A_q">q</code></td>
<td>
<p>Error rate to control for.</p>
</td></tr>
<tr><td><code id="linearStepUp_+3A_m">m</code></td>
<td>
<p>Number of hypothesis tested.</p>
</td></tr>
<tr><td><code id="linearStepUp_+3A_adjust">adjust</code></td>
<td>
<p>Logical value for p-value adjustmet (unusable).</p>
</td></tr>
<tr><td><code id="linearStepUp_+3A_m0">m0</code></td>
<td>
<p>Known or estimated number of true null hypotheses.</p>
</td></tr>
<tr><td><code id="linearStepUp_+3A_pi0">pi0</code></td>
<td>
<p>Known or estimated proportion of true null hypothesis. Is redundant when <code>m0</code> is specified.</p>
</td></tr>
<tr><td><code id="linearStepUp_+3A_constant">constant</code></td>
<td>
<p>A Scaling constant for the denominator of the critical values.</p>
</td></tr></table>


<h3>Details</h3>

<p>A Mutoss service function called by other procedures.</p>


<h3>Value</h3>

<p>A list containing the following objects: 
</p>
<table role = "presentation">
<tr><td><code>Cutoff</code></td>
<td>
<p>The largest p-value of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Pvals</code></td>
<td>
<p>A data frame containing the original p-values, critical values, adjusted p-values and rejections.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>JonathanRosenblatt</p>

<hr>
<h2 id='mu.test.class'>Test for compatible classes for comparison...</h2><span id='topic+mu.test.class'></span>

<h3>Description</h3>

<p>Test for compatible classes for comparison</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.test.class(classes)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu.test.class_+3A_classes">classes</code></td>
<td>
<p>A list of class names.</p>
</td></tr></table>


<h3>Details</h3>

<p>Internal function of muToss package.
Takes list of classes and tests if they are all muToss.</p>


<h3>Value</h3>

<p>True if all classes are muToss. False otherwise.</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team.</p>

<hr>
<h2 id='mu.test.name'>Tests if all hypotheses have the same names.</h2><span id='topic+mu.test.name'></span>

<h3>Description</h3>

<p>Tests if all hypotheses have the same names.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.test.name(hyp.names)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu.test.name_+3A_hyp.names">hyp.names</code></td>
<td>
<p>Character vector of hypotheses names.</p>
</td></tr></table>


<h3>Details</h3>

<p>Internal muToss function.</p>


<h3>Value</h3>

<p>Gives a notice when hypotheses names in different procedures are found different.</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='mu.test.rates'>Tests that different procedures used the same error rates.</h2><span id='topic+mu.test.rates'></span>

<h3>Description</h3>

<p>Tests that different procedures used the same error rates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.test.rates(rates)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu.test.rates_+3A_rates">rates</code></td>
<td>
<p>Numeric vector error rates extracted fomr muToss objects.</p>
</td></tr></table>


<h3>Details</h3>

<p>Internal muToss function.</p>


<h3>Value</h3>

<p>A notice if error rates differ.</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team.</p>

<hr>
<h2 id='mu.test.same.data'>Tests if the same pvalues were used by different procedures.</h2><span id='topic+mu.test.same.data'></span>

<h3>Description</h3>

<p>Tests if the same pvalues were used by different procedures.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.test.same.data(pvals)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu.test.same.data_+3A_pvals">pvals</code></td>
<td>
<p>Data frame of p-values used by each procedure.</p>
</td></tr></table>


<h3>Details</h3>

<p>Internal muToss function.</p>


<h3>Value</h3>

<p>Stops if different data was used by different procedures.</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='mu.test.type'>Tests that different procedures use the same error types.</h2><span id='topic+mu.test.type'></span>

<h3>Description</h3>

<p>Tests that different procedures use the same error types.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mu.test.type(types)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mu.test.type_+3A_types">types</code></td>
<td>
<p>Character vector of error types extracted from muToss objects.</p>
</td></tr></table>


<h3>Details</h3>

<p>Internal muToss function.</p>


<h3>Value</h3>

<p>Returns a notice if error types differ.</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team.</p>

<hr>
<h2 id='multcomp.wrapper'>Simultaneous confidence intervals for arbitrary parametric contrasts in unbalanced one-way layouts.</h2><span id='topic+multcomp.wrapper'></span>

<h3>Description</h3>

<p>Simultaneous confidence intervals for arbitrary parametric contrasts in unbalanced one-way layouts.
The procedure controls the FWER in the strong sense.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multcomp.wrapper(model, hypotheses, alternative, rhs=0, alpha, factorC)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multcomp.wrapper_+3A_model">model</code></td>
<td>
<p>a fitted model, for example an object returned by lm, glm, or aov etc. It is
assumed that coef and vcov methods are available for model.</p>
</td></tr>
<tr><td><code id="multcomp.wrapper_+3A_hypotheses">hypotheses</code></td>
<td>
<p>a specification of the linear hypotheses to be tested.</p>
</td></tr>
<tr><td><code id="multcomp.wrapper_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of 'two.sided'
(default), 'greater' or 'less'.</p>
</td></tr>
<tr><td><code id="multcomp.wrapper_+3A_rhs">rhs</code></td>
<td>
<p>an optional numeric vector specifying the right hand side of the hypothesis.</p>
</td></tr>
<tr><td><code id="multcomp.wrapper_+3A_alpha">alpha</code></td>
<td>
<p>the significance level</p>
</td></tr>
<tr><td><code id="multcomp.wrapper_+3A_factorc">factorC</code></td>
<td>
<p>character string, specifing the factor variable of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function, it is possible to compute simultaneous confidence
for arbitrary parametric contrasts in the unbalanced one way layout. Moreover, it computes
p-values. The simultaneous confidence intervals are computed using
multivariate t-distribution.</p>


<h3>Value</h3>

<p>A list containing:  
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing the estimates and the lower and upper confidence bound</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warpbreaks)
# Tukey contrast on the levels of the factor 'Tension'

multcomp.wrapper(aov(breaks ~ tension, data = warpbreaks), 
  hypotheses = "Tukey", alternative="two.sided", factorC="tension",alpha=0.05)

# Williams contrast on 'Tension'
multcomp.wrapper(aov(breaks ~ tension, data = warpbreaks), 
  hypotheses= "Williams", alternative="two.sided",alpha=0.05,factorC="tension")

# Userdefined contrast matrix
K &lt;-matrix(c(-1,0,1,-1,1,0, -1,0.5,0.5),ncol=3,nrow=3,byrow=TRUE)
multcomp.wrapper(aov(breaks ~ tension, data = warpbreaks), 
  hypotheses=K, alternative="two.sided",alpha=0.05,factorC="tension")

# Two-way anova
multcomp.wrapper(aov(breaks ~ tension*wool, data = warpbreaks), 
  hypotheses="Tukey", alternative="two.sided",alpha=0.05,factorC="wool")
multcomp.wrapper(aov(breaks ~ tension*wool, data = warpbreaks), 
  hypotheses="Tukey", alternative="two.sided",alpha=0.05,factorC="tension")
multcomp.wrapper(aov(breaks ~ tension*wool, data = warpbreaks), 
  hypotheses=K, alternative="two.sided",alpha=0.05, factorC="tension")
data(iris)
multcomp.wrapper(model=lm(Sepal.Length ~ Species, data=iris), 
  hypotheses="Tukey","two.sided",alpha=0.05, factorC="Species")
K &lt;-matrix(c(-1,0,1,-1,1,0, -1,0.5,0.5),ncol=3,nrow=3,byrow=TRUE)
multcomp.wrapper(model=lm(Sepal.Length ~ Species, data=iris),
  hypotheses=K,"two.sided",alpha=0.05, factorC="Species")</code></pre>

<hr>
<h2 id='multiple.down'>Benjamini-Krieger-Yekutieli (2006) Multi-Stage Step-Down</h2><span id='topic+multiple.down'></span>

<h3>Description</h3>

<p>A p-value procedure which controls the FDR for independent test statistics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple.down(pValues, alpha)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiple.down_+3A_pvalues">pValues</code></td>
<td>
<p>A numeric vector of p-values</p>
</td></tr>
<tr><td><code id="multiple.down_+3A_alpha">alpha</code></td>
<td>
<p>The FDR error rate to control</p>
</td></tr></table>


<h3>Details</h3>

<p>A non-linear step-down p-value procedure which control the FDR for independent test 
statistics and enjoys more power then other non-adaptive procedure such as the linear step-up (BH).
For the case of non-independent test statistics, non-adaptive procedures such as the 
linear step-up (BH) or the all-purpose conservative Benjamini-Yekutieli (2001) are recommended.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test.</p>
</td></tr> 
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing adjusted p-values.</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>An estimate of the proportion of true null hypotheses among all hypotheses (pi0=m0/m). </p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Jonathan Rosenblatt</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvals&lt;- runif(100)^2
alpha&lt;- 0.2
result&lt;- multiple.down(pvals, alpha)
result 
plot(result[['criticalValues']]~pvals)
plot(result[['adjPValues']]~pvals)
abline(v=alpha)</code></pre>

<hr>
<h2 id='multiple.down.adjust'>A service function used by multiple...</h2><span id='topic+multiple.down.adjust'></span>

<h3>Description</h3>

<p>A service function used by <code>multiple.down</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple.down.adjust(sorted, m)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiple.down.adjust_+3A_sorted">sorted</code></td>
<td>
<p>A sorted pvalue vector.</p>
</td></tr>
<tr><td><code id="multiple.down.adjust_+3A_m">m</code></td>
<td>
<p>The number of hypotheses tested.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>JonathanRosenblatt</p>

<hr>
<h2 id='Mutoss-class'>Class Mutoss</h2><span id='topic+Mutoss-class'></span>

<h3>Description</h3>

<p>A Mutoss object can store the input for a multiple test procedure and also the output.</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Raw data used in model</p>
</dd>
<dt><code>model</code>:</dt><dd><p>link function,error family and design</p>
</dd>
<dt><code>description</code>:</dt><dd><p>a general description</p>
</dd>
<dt><code>statistic</code>:</dt><dd><p>for Z, T or F statistics</p>
</dd>
<dt><code>hypotheses</code>:</dt><dd><p>of class ANY</p>
</dd>
<dt><code>hypNames</code>:</dt><dd><p>identifiers for the hypotheses tested</p>
</dd>
<dt><code>criticalValues</code>:</dt><dd><p>procedure-specific critical values</p>
</dd>
<dt><code>pValues</code>:</dt><dd><p>raw p-values</p>
</dd>
<dt><code>adjPValues</code>:</dt><dd><p>procedure-specific adjusted p-values</p>
</dd>
<dt><code>errorControl</code>:</dt><dd><p>A Mutoss S4 class of type <code>errorControl</code></p>
</dd>
<dt><code>rejected</code>:</dt><dd><p>Logical vector of the output of a procedure at a given error rate</p>
</dd>
<dt><code>qValues</code>:</dt><dd><p>Storey's estimates of the supremum of the pFDR</p>
</dd>
<dt><code>locFDR</code>:</dt><dd><p>Efron's local fdr estimates</p>
</dd>
<dt><code>pi0</code>:</dt><dd><p>Estimate of the proportion of null hypotheses</p>
</dd>
<dt><code>confIntervals</code>:</dt><dd><p>Confidence intervals for selected parameters</p>
</dd>
<dt><code>commandHistory</code>:</dt><dd><p>commandHistory</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='mutoss.apply'>Applies a function to a Mutoss object.</h2><span id='topic+mutoss.apply'></span>

<h3>Description</h3>

<p>Applies a function to a Mutoss object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutoss.apply(mutossObj, f, label = deparse(substitute(f)) , recordHistory = TRUE , ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutoss.apply_+3A_mutossobj">mutossObj</code></td>
<td>
<p>the Mutoss object the function should be applied to</p>
</td></tr>
<tr><td><code id="mutoss.apply_+3A_f">f</code></td>
<td>
<p>the function that should be applied</p>
</td></tr>
<tr><td><code id="mutoss.apply_+3A_label">label</code></td>
<td>
<p>the label affixed to all slots of the Mutoss object that
are changed by the procedure, defaults to the name of parameter f</p>
</td></tr>
<tr><td><code id="mutoss.apply_+3A_recordhistory">recordHistory</code></td>
<td>
<p>if true, the calling command is concatenated verbatim
to the commandHistory slot</p>
</td></tr>
<tr><td><code id="mutoss.apply_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed to the function</p>
</td></tr></table>


<h3>Details</h3>

<p>This functions is intended for applying functions for multiplicity control on Mutoss class objects using the console and not the Mutoss GUI.</p>


<h3>Value</h3>

<p>A Mutoss object after applying the given function
</p>
<table role = "presentation">
<tr><td><code>mutossObj</code></td>
<td>
<p>Object of S4 class Mutoss</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Kornelius Rohmeyer</p>


<h3>Examples</h3>

<pre><code class='language-R'>newObjectBonf &lt;- mutoss.apply(new(Class="Mutoss", pValues=runif(10)), 
  f=bonferroni, label="Bonferroni Correction", alpha=0.05)
## Not run:  TODO: EXAMPLE PROBLEM
newObjectHolm &lt;- mutoss.apply(new(Class="Mutoss", pValues=runif(10)), 
  f=holm, label="Holm's step-down-procedure", alpha=0.05, silent=T)

newObjectAORC &lt;- mutoss.apply(new(Class="Mutoss", pValues=runif(10)), 
  f=aorc, label="Asymptotically optimal rejection curve", alpha=0.05, startIDX_SUD = 1, silent=T)

## End(Not run)</code></pre>

<hr>
<h2 id='mutoss.models'>Mutoss Models</h2><span id='topic+fisher23.model'></span><span id='topic+fisher22.model'></span><span id='topic+twosamp.model'></span><span id='topic+paired.model'></span><span id='topic+onesamp.model'></span><span id='topic+ftest.model'></span>

<h3>Description</h3>

<p>Fisher-type (2x3) table as model for marginal hypotheses testing problems,
Fisher (2x2) table as model for marginal hypotheses testing problems and others...</p>


<h3>Value</h3>

<p>A list containing the model description</p>

<hr>
<h2 id='mutoss.plotCI'>mutoss.plotCI</h2><span id='topic+mutoss.plotCI'></span>

<h3>Description</h3>

<p>Plots the confidence intervals</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutoss.plotCI(mat)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutoss.plotCI_+3A_mat">mat</code></td>
<td>
<p>Matrix containing the confidence interval limits. TODO specify the matrix layout.</p>
</td></tr></table>

<hr>
<h2 id='MutossMethod-class'>Class MutossMethod</h2><span id='topic+MutossMethod-class'></span><span id='topic+MutossMethod'></span>

<h3>Description</h3>

<p>A <code>MutossMethod</code> object describes a method that is applicable to <code>Mutoss</code> objects.</p>


<h3>Slots</h3>

  

<dl>
<dt><code>label</code>:</dt><dd><p>A character string that contains the label that will be shown in menus.</p>
</dd>
<dt><code>errorControl</code>:</dt><dd><p>One of the following character strings: FWER, FWER.weak, FDR, FDX, gFWER, perComparison.</p>
</dd>
<dt><code>callFunction</code>:</dt><dd><p>A character string that contains the name of the Mutoss-compatible function.</p>
</dd>        
<dt><code>output</code>:</dt><dd><p>A character vector of the <em>possible</em> output of the function.</p>
</dd>
<dt><code>info</code>:</dt><dd><p>A character string with info text. Should contain small description, author, reference etc..</p>
</dd>
<dt><code>assumptions</code>:</dt><dd><p>A character vector of assumptions for this method.</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>A list of optional description of parameters - see MuToss developer handbook.</p>
</dd>
<dt><code>list</code>:</dt><dd><p>For extensions a list where you can put all your miscellaneous stuff.</p>
</dd>
</dl>


<hr>
<h2 id='notterman'>Notterman data set</h2><span id='topic+notterman'></span><span id='topic+notterman.grpLabel'></span><span id='topic+T.Test.tumor.vs.normal'></span>

<h3>Description</h3>

<p>The <code>notterman</code> data set is a data.frame containing 18 paired samples of 7457 gene expression values from Notterman et al. (2001).
</p>
<p>The vector <code>notterman.grpLabel</code> contains 36 labels of type <code>Tumor</code> or <code>Normal</code> specifying the type of tissue for each column of the <code>notterman</code> data set.
</p>
<p>The vector <code>T.Test.tumor.vs.normal</code> contains the resulting 7457 numeric p-values from the 7457 t-tests applied to each row of the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>notterman
notterman.grpLabel
T.Test.tumor.vs.normal
</code></pre>


<h3>Format</h3>


<ul>
<li><p>notterman - A data.frame containing 36 columns with 7457 observations
</p>
</li>
<li><p>notterman.grpLabel - A vector containing 36 labels of type <code>Tumor</code> or <code>Normal</code>
</p>
</li>
<li><p>T.Test.tumor.vs.normal - A vector containing 7457 numeric p-values
</p>
</li></ul>



<h3>Source</h3>

<p>D.A. Notterman, U. Alon, A.J. Sierk, and A.J. Levine:
<em>Transcriptional Gene Expression Profiles of Colorectal
Adenoma, Adenocarcinoma, and Normal Tissue Examined by
Oligonucleotide Arrays</em>, Cancer Research, 2001, vol. 61, pp.
3124-3130.</p>

<hr>
<h2 id='nparcomp'>Simultaneous confidence intervals for relative contrast effects...</h2><span id='topic+nparcomp'></span>

<h3>Description</h3>

<p>Simultaneous confidence intervals for relative contrast effects
The procedure controls the FWER in the strong sense.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nparcomp(formula, data, type=c("UserDefined", "Tukey", "Dunnett",
    "Sequen", "Williams", "Changepoint", "AVE", "McDermott", "Marcus",
    "UmbrellaWilliams"), control=NULL, conflevel=0.95,
    alternative=c("two.sided", "less", "greater"), rounds=3,
    correlation=FALSE, asy.method=c("logit", "probit", "normal",
    "mult.t"), plot.simci=FALSE, info=TRUE, contrastMatrix=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nparcomp_+3A_formula">formula</code></td>
<td>
<p>A two-sided 'formula' specifying a numeric response variable and
a factor with more than two levels. If the factor contains less than 3 levels, an
error message will be returned</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_data">data</code></td>
<td>
<p>data A dataframe containing the variables specified in formula</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_type">type</code></td>
<td>
<p>type Character string defining the type of contrast. It should be one of &quot;Tukey&quot;,
&quot;Dunnett&quot;, &quot;Sequen&quot;, &quot;Williams&quot;, &quot;Changepoint&quot;, &quot;AVE&quot;, &quot;McDermott&quot;, &quot;Marcus&quot;</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_control">control</code></td>
<td>
<p>control Character string defining the control group in Dunnett comparisons.
By default it is the first group by lexicographical ordering</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_conflevel">conflevel</code></td>
<td>
<p>The confidence level for the 1 - conflevel confidence intervals. By
default it is 0.05</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_alternative">alternative</code></td>
<td>
<p>Character string defining the alternative hypothesis, one of
&quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_rounds">rounds</code></td>
<td>
<p>Number of rounds for the numeric values of the output. By default it is rounds=3</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_correlation">correlation</code></td>
<td>
<p>Correlation A logical whether the estimated correlation matrix and covariance
matrix should be printed</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_asy.method">asy.method</code></td>
<td>
<p>asy.method character string defining the asymptotic approximation method,
one of &quot;logit&quot;, for using the logit transformation function, &quot;probit&quot;, for using
the probit transformation function, &quot;normal&quot;, for using the multivariate normal
distribution or &quot;mult.t&quot; for using a multivariate t-distribution with a Satterthwaite
Approximation</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_plot.simci">plot.simci</code></td>
<td>
<p>plot.simci A logical indicating whether you want a plot of the confidence
intervals</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_info">info</code></td>
<td>
<p>info A logical whether you want a brief overview with informations about the
output</p>
</td></tr>
<tr><td><code id="nparcomp_+3A_contrastmatrix">contrastMatrix</code></td>
<td>
<p>arbitrary contrast matrix given by the user</p>
</td></tr></table>


<h3>Details</h3>

<p>With this function, it is possible to compute nonparametric simultaneous confidence
intervals for relative contrast effects in the unbalanced one way layout. Moreover, it computes
adjusted p-values. The simultaneous confidence intervals can be computed using
multivariate normal distribution, multivariate t-distribution with a Satterthwaite Approximation
of the degree of freedom or using multivariate range preserving transformations with Logit or
Probit as transformation function. There is no assumption on the underlying distribution function, only
that the data have to be at least ordinal numbers</p>


<h3>Value</h3>

<p>A list containing:  
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing the estimates and the lower and upper confidence bound</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>FrankKonietschke</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # TODO Check this example and set a seed!
grp &lt;- rep(1:5,10)
x &lt;- rnorm(50, grp)
dataframe &lt;- data.frame(x,grp)
# Williams Contrast
nparcomp(x ~grp, data=dataframe, asy.method = "probit",
type = "Williams", alternative = "two.sided", plot.simci = TRUE, info = TRUE)

# Dunnett Contrast
nparcomp(x ~grp, data=dataframe, asy.method = "probit",control=1,
type = "Dunnett", alternative = "two.sided", plot.simci = TRUE, info = TRUE)

# Dunnett dose 3 is baseline
nparcomp(x ~grp, data=dataframe, asy.method = "probit",
type = "Dunnett", control = "3",alternative = "two.sided",
plot.simci = TRUE, info = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='nparcomp.wrapper'>Simultaneous confidence intervals for relative contrast effects...</h2><span id='topic+nparcomp.wrapper'></span>

<h3>Description</h3>

<p>Simultaneous confidence intervals for relative contrast effects
The procedure controls the FWER in the strong sense.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nparcomp.wrapper(model, data, hypotheses, alpha, alternative,
    asy.method)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nparcomp.wrapper_+3A_model">model</code></td>
<td>
<p>A two-sided formula specifying a numeric response variable and
a factor with more than two levels.</p>
</td></tr>
<tr><td><code id="nparcomp.wrapper_+3A_data">data</code></td>
<td>
<p>A dataframe containing the variables specified the model</p>
</td></tr>
<tr><td><code id="nparcomp.wrapper_+3A_hypotheses">hypotheses</code></td>
<td>
<p>Character string defining the type of contrast. It should be one of &quot;Tukey&quot;,
&quot;Dunnett&quot;, &quot;Sequen&quot;, &quot;Williams&quot;, &quot;Changepoint&quot;, &quot;AVE&quot;, &quot;McDermott&quot;, &quot;Marcus&quot;.</p>
</td></tr>
<tr><td><code id="nparcomp.wrapper_+3A_alpha">alpha</code></td>
<td>
<p>the significance level</p>
</td></tr>
<tr><td><code id="nparcomp.wrapper_+3A_alternative">alternative</code></td>
<td>
<p>Character string defining the alternative hypothesis, one of
&quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;</p>
</td></tr>
<tr><td><code id="nparcomp.wrapper_+3A_asy.method">asy.method</code></td>
<td>
<p>A character string defining the asymptotic approximation method,
one of &quot;logit&quot;, for using the logit transformation function, &quot;probit&quot;, for using
the probit transformation function, &quot;normal&quot;, for using the multivariate normal</p>
</td></tr></table>


<h3>Details</h3>

<p>With this function, it is possible to compute nonparametric simultaneous confidence
intervals for relative contrast effects in the unbalanced one way layout. Moreover, it computes
adjusted p-values. The simultaneous confidence intervals can be computed using
multivariate normal distribution, multivariate t-distribution with a Satterthwaite Approximation
of the degree of freedom or using multivariate range preserving transformations with Logit or
Probit as transformation function. There is no assumption on the underlying distribution function, only
that the data have to be at least ordinal numbers</p>


<h3>Value</h3>

<p>A list containing:  
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing the estimates and the lower and upper confidence bound</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>FrankKonietschke</p>

<hr>
<h2 id='onesamp.marginal'>Marginal one sample test</h2><span id='topic+onesamp.marginal'></span>

<h3>Description</h3>

<p>The robust version uses the Wilcoxon-Mann-Whitney test, otherwise a t-test will be performed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>onesamp.marginal(data, robust, alternative, psi0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="onesamp.marginal_+3A_data">data</code></td>
<td>
<p>the data set</p>
</td></tr>
<tr><td><code id="onesamp.marginal_+3A_robust">robust</code></td>
<td>
<p>a logical variable indicating whether a t-test or a Wilcoxon-Mann-Whitney test should be used.</p>
</td></tr>
<tr><td><code id="onesamp.marginal_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>two.sided</code>, <code>greater</code> or <code>less</code></p>
</td></tr>
<tr><td><code id="onesamp.marginal_+3A_psi0">psi0</code></td>
<td>
<p>a numeric that defines the hypothesized null value</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pValues</code></td>
<td>
<p>A numeric vector containing the unadjusted pValues</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>References</h3>

<p>Wilcoxon, F. (1945). Individual Comparisons by Ranking Methods. Biometrics Bulletin 1:80-83.
Mann, H. and Whitney, D. (1947). On a test of whether one of two random variables is stochastically larger than the other. Annals of Mathematical Statistics 18:50-60
Student (1908). The probable error of a mean. Biometrika, 6(1):1-25.
</p>

<hr>
<h2 id='oracleBH'>Bejamini-Hochberg (2000) oracle linear step-up Procedure...</h2><span id='topic+oracleBH'></span>

<h3>Description</h3>

<p>Bejamini-Hochberg (2000) oracle linear step-up Procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>oracleBH(pValues, alpha, pi0, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oracleBH_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used</p>
</td></tr>
<tr><td><code id="oracleBH_+3A_alpha">alpha</code></td>
<td>
<p>the level at which the FWER should be controlled</p>
</td></tr>
<tr><td><code id="oracleBH_+3A_pi0">pi0</code></td>
<td>
<p>miraculousy known number of true null hypotheses</p>
</td></tr>
<tr><td><code id="oracleBH_+3A_silent">silent</code></td>
<td>
<p>Logical, if true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>Knowledge of the number of true null hypotheses (m0) can be very useful to improve upon the performance of the FDR controlling procedure. 
For the oracle linear step-up procedure we assume that m0 were given to us by an 'oracle', the linear step-up procedure with q0 = q*m/m0
would control the FDR at precisely the desired level q in the independent and continuous case, and
would then be more powerful in rejecting hypotheses for which the alternative holds.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test.</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>HackNiklas</p>


<h3>Examples</h3>

<pre><code class='language-R'>pval &lt;- c(runif(50), runif(50, 0, 0.01))
result &lt;- oracleBH(pValues=pval,alpha=0.05,pi0=0.85)</code></pre>

<hr>
<h2 id='paired.marginal'>Marginal paired two sample test</h2><span id='topic+paired.marginal'></span>

<h3>Description</h3>

<p>The robust version uses the Wilcoxon signed rank test, otherwise a paired t-test will be performed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>paired.marginal(data, model, robust, alternative, psi0, equalvar)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paired.marginal_+3A_data">data</code></td>
<td>
<p>the data set</p>
</td></tr>
<tr><td><code id="paired.marginal_+3A_model">model</code></td>
<td>
<p>the result of a call to <code>paired.model(classlabel)</code></p>
</td></tr>
<tr><td><code id="paired.marginal_+3A_robust">robust</code></td>
<td>
<p>a logical variable indicating whether a paired t-test or a Wilcoxon signed rank test should be used.</p>
</td></tr>
<tr><td><code id="paired.marginal_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>two.sided</code>, <code>greater</code> or <code>less</code></p>
</td></tr>
<tr><td><code id="paired.marginal_+3A_psi0">psi0</code></td>
<td>
<p>a numeric that defines the hypothesized null value</p>
</td></tr>
<tr><td><code id="paired.marginal_+3A_equalvar">equalvar</code></td>
<td>
<p>a logical variable indicating whether to treat the two variances as being equal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector of classlabels needs to be provided to distinguish the two paired groups. The arrangement of group indices does not matter, as long
as the columns are arranged in the same corresponding order between groups. For example, if group 1 is code as 0 and group 2 is 
coded as 1, for 3 pairs of data, it does not matter if the classlabel is coded as (0,0,0,1,1,1) or (1,1,1,0,0,0) or (0,1,0,1,0,1)
or (1,0,1,0,1,0), the paired differences between groups will be calculated as group2 - group1.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pValues</code></td>
<td>
<p>A numeric vector containing the unadjusted pValues</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>References</h3>

<p>Wilcoxon, F. (1945). Individual Comparisons by Ranking Methods. Biometrics Bulletin 1:80-83.
</p>

<hr>
<h2 id='printRejected'>Internal MuTossProjekt-Function</h2><span id='topic+printRejected'></span>

<h3>Description</h3>

<p>Generates standard output for pValues, rejected and
adjustedPValues.</p>


<h3>Usage</h3>

<pre><code class='language-R'>printRejected(rejected, pValues=NULL, adjPValues=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printRejected_+3A_rejected">rejected</code></td>
<td>
<p>logical Vector indicating which pValue is rejected.</p>
</td></tr>
<tr><td><code id="printRejected_+3A_pvalues">pValues</code></td>
<td>
<p>the used pValues.</p>
</td></tr>
<tr><td><code id="printRejected_+3A_adjpvalues">adjPValues</code></td>
<td>
<p>the adjusted pValues.</p>
</td></tr></table>


<h3>Details</h3>

<p>It generates an output on the console with the number of
hypotheses (number of pValues) and the number of rejected
hypotheses (number of rejected pValues). Further a data.frame
is constructed, one column containing the rejected pValues, 
one the index number of the rejected pValues and if given 
one column with the corresponding adjusted pValues.</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>

<hr>
<h2 id='pval2locfdr'>Strimmer et al.'s fdrtool-based local fdr</h2><span id='topic+pval2locfdr'></span>

<h3>Description</h3>

<p>The function <code>pval2locfdr</code> takes a vector of p-values and
estimates for each case the local fdr.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval2locfdr(pValues, cutoff)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval2locfdr_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used.</p>
</td></tr>
<tr><td><code id="pval2locfdr_+3A_cutoff">cutoff</code></td>
<td>
<p>The local fdr cutoff for rejection. Hypotheses with <code>local fdr</code> smaller then <code>cutoff</code> will be rejected.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>locfdr</code></td>
<td>
<p>Numeric vector with local FDR values for each case</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>Logical vector indicating rejection/retention for each hypothesis when a <code>cutoff</code> is supplied.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>JonathanRosenblatt</p>


<h3>References</h3>

<p>Strimmer, K. (2008). fdrtool: a versatile R package for estimating local and tail
area-based false discovery rates. Bioinformatics 24: 1461-1462. <br />
Efron B., Tibshirani R., Storey J. D. and Tusher, V. (2001). Empirical Bayes Analysis of a Microarray Experiment.
Journal of the American Statistical Association 96(456):1151-1160.</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvals&lt;- runif(1000)^2
pval2locfdr(pvals)
pval2locfdr(pValues=pvals, cutoff=0.4)</code></pre>

<hr>
<h2 id='pval2qval'>Strimmer et al.'s fdrtool-based q-values</h2><span id='topic+pval2qval'></span>

<h3>Description</h3>

<p>The function <code>pval2qval</code> takes a vector of p-values and
estimates for each case the tail area-based FDR, which can be regarded as a p-value corrected for multiplicity. 
This is done by calling the <code>fdrtool</code> function.
If a cutoff is supplied, a vector of rejected hypotheses will be returned as well.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval2qval(pValues, cutoff)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pval2qval_+3A_pvalues">pValues</code></td>
<td>
<p>Numeric vector of p-values to be used.</p>
</td></tr>
<tr><td><code id="pval2qval_+3A_cutoff">cutoff</code></td>
<td>
<p>The positive FDR cutoff for rejection. Hypotheses with <code>qValues</code> smaller then <code>cutoff</code> will be rejected.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>qValues</code></td>
<td>
<p>A numeric vector with one q-value for each hypothesis.</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating rejection/retention for each hypothesis when <code>cutoff</code> is supplied.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>JonathanRosenblatt</p>


<h3>References</h3>

<p>Strimmer, K. (2008). fdrtool: a versatile R package for estimating local and tail
area-based false discovery rates. Bioinformatics 24: 1461-1462. <br />
Storey, J. D. (2003)  The Positive False Discovery Rate: A Bayesian Interpretation and the q-Value.
The Annals of Statistics 31(6): 2013-2035</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvals&lt;- runif(1000)^2
pval2qval(pvals)
pval2qval(pValues=pvals, cutoff=0.1)</code></pre>

<hr>
<h2 id='pValuesPlot'>A function plotting p-values...</h2><span id='topic+pValuesPlot'></span>

<h3>Description</h3>

<p>A function plotting p-values</p>


<h3>Usage</h3>

<pre><code class='language-R'>pValuesPlot(pValues)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pValuesPlot_+3A_pvalues">pValues</code></td>
<td>
<p>A numeric containing the pValues to plot.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MarselScheer</p>

<hr>
<h2 id='Qvalue'>Storey's (2001) q-value Procedure...</h2><span id='topic+Qvalue'></span>

<h3>Description</h3>

<p>Storey's (2001) q-value Procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qvalue(pValues, lambda=seq(0, 0.9, 0.05), pi0.method="smoother",
    fdr.level=NULL, robust=FALSE, smooth.df=3, smooth.log.pi0=FALSE,
    silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qvalue_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used (only necessary input)</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_lambda">lambda</code></td>
<td>
<p>Value of the tuning parameter to be used</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_pi0.method">pi0.method</code></td>
<td>
<p>Method for automatically choosing tuning parameter in the estimation of pi_0. Either 'smoother' or 'bootstrap'</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_fdr.level">fdr.level</code></td>
<td>
<p>Level at which to control the FDR</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_robust">robust</code></td>
<td>
<p>Logical, whether to make estimate more robust for small p-values.</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_smooth.df">smooth.df</code></td>
<td>
<p>Number of degrees of freedom to use when estimating pi_0 with the smoother.</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_smooth.log.pi0">smooth.log.pi0</code></td>
<td>
<p>Logical, if TRUE and pi0.method = 'smoother', pi0 will be estimated by applying a smoother 
to a scatterplot of log(pi_0) estimates against the tuning parameter lambda.</p>
</td></tr>
<tr><td><code id="Qvalue_+3A_silent">silent</code></td>
<td>
<p>logical scalar. If <code>TRUE</code> no output is generated.</p>
</td></tr></table>


<h3>Details</h3>

<p>The Qvalue procedure estimates the q-values for a given set of p-values. The q-value of a test measures the
proportion of false positive incurred when that particular test is called sigificant.
It gives the scientist a hypothesis testing error measure for each observed statistic with respect to the pFDR.
</p>
<p>Note: If no options are selected, then the method used to estimate pi0 is the smoother method desribed in Storey and Tibshirani (2003). 
The bootstrap method is described in Storey, Taylor and Siegmund (2004).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>qValues</code></td>
<td>
<p>A vector of the estimated q-values</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>An estimate of the proportion of null hypotheses</p>
</td></tr> 
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>HackNiklas</p>


<h3>References</h3>

<p>Storey, John (2001). The Positive False Discovery Rate: A Baysian Interpretation and the Q-Value.
The Annals of Statistics, Vol. 31, No. 6, 2013-2035.</p>


<h3>Examples</h3>

<pre><code class='language-R'>pval &lt;- c(runif(50), runif(50, 0, 0.01))
result &lt;- Qvalue(pval)
result &lt;- Qvalue(pval, lambda=0.5)</code></pre>

<hr>
<h2 id='ranktruncated'>Rank truncated p-Value procedure...</h2><span id='topic+ranktruncated'></span>

<h3>Description</h3>

<p>Rank truncated p-Value procedure
The program computes the exact distribution and with it the p-Value</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranktruncated(pValues, K, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranktruncated_+3A_pvalues">pValues</code></td>
<td>
<p>Vector of p-Values (not sorted)</p>
</td></tr>
<tr><td><code id="ranktruncated_+3A_k">K</code></td>
<td>
<p>the number of hypotheses / p-Values being in w</p>
</td></tr>
<tr><td><code id="ranktruncated_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function computes the exact distribution of the product of
at most K significant p-values of <code class="reqn">L&gt;K</code> observed p-values. Thus, one gets the
pvalue from the exact distribution. This has certain advantages for genomewide 
association scans: K can be chosen on the basis of a hypothesised 
disease model, and is independent of sample size. Furthermore, 
the alternative hypothesis corresponds more closely to the 
experimental situation where all loci have fixed effects.
</p>
<p>Please note that this method is implemented with factorials and binomial coefficients and the computation becomes numerical instable for large number of p-values.</p>


<h3>Value</h3>

<p>Used.pValue: List information about the used pValues; RTP: Test statistic and pValue</p>


<h3>Author(s)</h3>

<p>Frank Konietschke</p>


<h3>References</h3>

<p>Dubridge, F., Koeleman, B.P.C. (2003). Rank truncated product of P-values, with application to genomewide association scans. Genet Epidemiol. 2003 Dec;25(4):360-6</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvalues&lt;-runif(10)
result &lt;- ranktruncated(pvalues,K=2,silent=FALSE) # take the K=2 smallest pvalues
result &lt;- ranktruncated(pvalues,K=2,silent=TRUE) # take the K=2 smallest pvalues
result &lt;- ranktruncated(pvalues,K=5,silent=TRUE) # take the K=5 smallest pvalues</code></pre>

<hr>
<h2 id='regwq'>REGWQ - Ryan / Einot and Gabriel / Welsch  test procedure...</h2><span id='topic+regwq'></span>

<h3>Description</h3>

<p>REGWQ - Ryan / Einot and Gabriel / Welsch  test procedure
This function computes REGWQ test for given
data including p samples. It is based on a stepwise or 
layer approach to significance testing. Sample means are 
ordered from the smallest to the largest.  
The largest 
difference, which involves means that are r = p steps apart, 
is tested first at <code class="reqn">\alpha</code> level of significance; if significant, 
means that are <code class="reqn">r &lt;p</code> steps apart are tested at a different <code class="reqn">\alpha</code> level 
of significance and so on. Compare to the Student-
Newman-Keuls test, the <code class="reqn">\alpha</code> levels are adjusted for the p-1 different
layers by the formula <code class="reqn">\alpha_p=\alpha</code>, if p=k or p=k-1,
<code class="reqn">\alpha_p = 1-(1-\alpha)^{p/k}</code>  otherwise. It might happen that the
quantiles are not descending in p. In this case, they are adapted by
<code class="reqn">c_k = max_{2\leq r \leq k} c_r, k=2,\ldots,p</code>.
The REGWQ procedure, like Tukey's procedure, requires 
equal sample n's. However, in this algorithm, the procedure is 
adapted to unequal sample sized which can lead to still 
conservative test decisions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>regwq(formula, data, alpha, MSE=NULL, df=NULL, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regwq_+3A_formula">formula</code></td>
<td>
<p>Formula defining the statistical model containing the response and the factors</p>
</td></tr>
<tr><td><code id="regwq_+3A_data">data</code></td>
<td>
<p>dataset containing the response and the grouping factor</p>
</td></tr>
<tr><td><code id="regwq_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the error should be controlled. By default it is alpha=0.05.</p>
</td></tr>
<tr><td><code id="regwq_+3A_mse">MSE</code></td>
<td>
<p>Optional for a given variance of the data</p>
</td></tr>
<tr><td><code id="regwq_+3A_df">df</code></td>
<td>
<p>Optional for a given degree of freedom</p>
</td></tr>
<tr><td><code id="regwq_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>A numeric vector containing the test-statistics</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing only the estimates</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Frank Konietschke</p>


<h3>References</h3>

<p>Hochberg, Y. &amp; Tamhane, A. C. (1987). Multiple Comparison Procedures,  Wiley.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = rnorm(50)
grp = c(rep(1:5,10))
dataframe &lt;- data.frame(x,grp)
result &lt;- regwq(x~grp, data=dataframe, alpha=0.05,MSE=NULL, df=NULL, silent = TRUE)
result &lt;- regwq(x~grp, data=dataframe, alpha=0.05,MSE=NULL, df=NULL, silent = FALSE)
result &lt;- regwq(x~grp, data=dataframe, alpha=0.05,MSE=1, df=Inf, silent = FALSE) # known variance
result &lt;- regwq(x~grp, data=dataframe, alpha=0.05,MSE=1, df=1000, silent = FALSE) # known variance</code></pre>

<hr>
<h2 id='reject'>reject</h2><span id='topic+reject'></span>

<h3>Description</h3>

<p>Returns the highest rejected p-value and its index given some critical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reject(sorted, criticals)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reject_+3A_sorted">sorted</code></td>
<td>

<p>Sorted p-values
</p>
</td></tr>
<tr><td><code id="reject_+3A_criticals">criticals</code></td>
<td>

<p>Critical values
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table role = "presentation">
<tr><td><code>cutoff</code></td>
<td>
<p>highest rejected p-value</p>
</td></tr>
<tr><td><code>cut.index</code></td>
<td>
<p>index of highest rejected p-value</p>
</td></tr>
</table>

<hr>
<h2 id='requireLibrary'>Tries to load a package.</h2><span id='topic+requireLibrary'></span>

<h3>Description</h3>

<p>Tries to load a package.
If this package does not exist, it will ask the user whether the package should be installed and loaded.
If the user negates, we will raise an error via stop.</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireLibrary(package)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="requireLibrary_+3A_package">package</code></td>
<td>
<p>Package to load</p>
</td></tr></table>


<h3>Value</h3>

<p>NULL</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='rom'>Rom's (1990) step-up-procedure.</h2><span id='topic+rom'></span>

<h3>Description</h3>

<p>Rom's step-up-procedure is applied to pValues. The procedure 
controls the FWER in the strong sense if the pValues are
stochastically independent.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rom(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rom_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used. They are assumed to be stochastically independent.</p>
</td></tr>
<tr><td><code id="rom_+3A_alpha">alpha</code></td>
<td>
<p>the level at which the FWER shall be controlled.</p>
</td></tr>
<tr><td><code id="rom_+3A_silent">silent</code></td>
<td>
<p>if true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function calculates the critical values by the formula given
in Finner, H. and Roters, M. (2002) based on the joint distribution
of order statistics. After that a step-up test
is performed to reject hypotheses associated with pValues.
</p>
<p>Since the formula for the critical values is recursive,
the calculation of adjusted pValues is far from obvious and is
not implemented here.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected.</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test.</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Marsel Scheer</p>


<h3>References</h3>

<p>Rom, D. M. (1990). A sequentially rejective test 
procedure based on a modified Bonferroni inequality. 
Biometrika 77, 663-665.
</p>
<p>Finner, H. and Roters, M. (2002). Multiple hypotheses testing and
expected type I errors. Ann. Statist. 30, 220-238.</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- c(runif(50), runif(50, 0, 0.01))
result &lt;- rom(r, 0.05)
result &lt;- rom(r, 0.05, silent = TRUE)</code></pre>

<hr>
<h2 id='SD'>A general step-down procedure.</h2><span id='topic+SD'></span>

<h3>Description</h3>

<p>A general step-down procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SD(pValues, criticalValues)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SD_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used.</p>
</td></tr>
<tr><td><code id="SD_+3A_criticalvalues">criticalValues</code></td>
<td>
<p>criticalValues for the step-down procedure</p>
</td></tr></table>


<h3>Details</h3>

<p>Suppose we have n pValues and they are already sorted.
The procedure starts with comparing pValues[1] with criticalValues[1]. If 
pValues[1] &lt;= criticalValues[1], then the hypothsis associated with pValues[1] is rejected and the algorithm 
carries on with second smallest pValue and criticalValue in the same way. The algorithm stops
rejecting at the first index i for which pValues[i] &gt; criticalValues[i]. 
Thus pValues[j] is rejected if and only if pValues[i] &lt;= criticalValues[i] for all i &lt;= j.</p>


<h3>Value</h3>

<p>rejected logical vector indicating if hypotheses are rejected or retained.</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>

<hr>
<h2 id='sidak'>Sidak correction</h2><span id='topic+sidak'></span>

<h3>Description</h3>

<p>The classical Sidak correction returns adjusted p-values, ensuring strong FWER control under
the assumption of independence of the input p-values. It only uses the fact that the probability of no incorrect
rejection is the product over true nulls of those marginal probabilities (using the assumed independence of p-values).</p>


<h3>Usage</h3>

<pre><code class='language-R'>sidak(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sidak_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used.</p>
</td></tr>
<tr><td><code id="sidak_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FWER shall be controlled (optional).</p>
</td></tr>
<tr><td><code id="sidak_+3A_silent">silent</code></td>
<td>
<p>logical scalar. If <code>TRUE</code> no output is generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is more generally valid for positive orthant dependent test statistics.
</p>
<p>It is recommended to use the step-down version of the Sidak correction instead (see SidakSD), 
which is valid under the exact same assumptions but is more powerful.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>(if alpha is given) A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>References</h3>

<p>Sidak, Z. (1967). Rectangular confidence regions for the means of multivariate normal distributions.
Journal of the American Statistical Association, 62:626-633.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9, max=1))
result &lt;- sidak(p)
result &lt;- sidak(p, alpha)
result &lt;- sidak(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='SidakSD'>Sidak-like (1987) step-down procedure</h2><span id='topic+SidakSD'></span>

<h3>Description</h3>

<p>The Sidak-like (1987) step-down procedure is applied to pValues
The Sidak-like step-down procedure is an improvement over the Holm's (1979) 
step-down procedure. The improvement is analogous to Sidak's correction 
over the original Bonferroni procedure. This Sidak-like step-down procedure 
assumes positive orthant dependent test statistics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SidakSD(pValues, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SidakSD_+3A_pvalues">pValues</code></td>
<td>
<p>The used raw pValues.</p>
</td></tr>
<tr><td><code id="SidakSD_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the FWER shall be controlled.</p>
</td></tr>
<tr><td><code id="SidakSD_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>a numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>a logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>a numeric vector containing critical values used in the step-up-down test</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>WerftWiebke</p>


<h3>References</h3>

<p>Hollander, B.S. and Covenhaver, M.D. (1987). An Improved Sequentially Rejective Bonferroni Test Procedure.
Biometrics, 43(2):417-423, 1987.</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- 0.05
p &lt;-c(runif(10, min=0, max=0.01), runif(10, min=0.9,max=1))
result &lt;- SidakSD(p, alpha)
result &lt;- SidakSD(p, alpha, silent=TRUE)</code></pre>

<hr>
<h2 id='simulation'>Simulation studies</h2><span id='topic+simulation'></span>

<h3>Description</h3>

<p>This function generates data according to a specified function and parameters
and then applies specified procedures to the generated data. The generated data is stored
in $data and the results are stored in $results. In order to recognize which
results and generated data belong together every result contains an element
$data.set.number. The data generating function must return a list which contains a list
$procInput. Every element in $procInput will be used as an input parameter
for the procedures provided by listOfProcedures.</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation(replications, DataGen, listOfProcedures, discardProcInput=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulation_+3A_replications">replications</code></td>
<td>
<p>The number of replications. This means how many simulation runs will be performed.</p>
</td></tr>
<tr><td><code id="simulation_+3A_datagen">DataGen</code></td>
<td>
<p>A list that contains the function and parameters for generating data 
which will be analyzed be the procedures in listOfProcedures. It must contain the elements
$funName (character) $fun (function)</p>
</td></tr>
<tr><td><code id="simulation_+3A_listofprocedures">listOfProcedures</code></td>
<td>
<p>A list of lists which contains the procedures with their  parameters
for the simulation.</p>
</td></tr>
<tr><td><code id="simulation_+3A_discardprocinput">discardProcInput</code></td>
<td>
<p>A list of lists which contains the procedures with their  parameters</p>
</td></tr></table>


<h3>Value</h3>

<p>A list with 2 elements. $data contains the objects generated by DataGen. $results
contains the objects generated by the procedures augmented by the data set number and
the parameter constellation.</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>Examples</h3>

<pre><code class='language-R'># this function generates pValues 
myGen &lt;- function(n, n0) {
  list(procInput=list(pValues = c(runif(n-n0, 0, 0.01), runif(n0))), 
  groundTruth = c(rep(FALSE, times=n-n0), rep(TRUE, times=n0)))
}

sim &lt;- simulation(replications = 10, list(funName="myGen", fun=myGen, n=200, n0=c(50,100)), 
list(list(funName="BH", 
  fun=function(pValues, alpha) BH(pValues, alpha, silent=TRUE), alpha=c(0.25, 0.5)),
list(funName="holm", fun=holm, alpha=c(0.25, 0.5),silent=TRUE)))

# the following happend:
# Call myGen(200,50) and append result to sim$data
# Apply bonferroni and holm each with alpha 0.25 and 0.5 to this data set
# Append the results to sim$restults
# Repeat this 10 times.
# Call myGen(200, 100) and append restult to sim$data
# Apply bonferroni and holm each with alpha 0.25 and 0.5 to this data set
# Append the results to sim$restults
# Repeat this 10 times.

length(sim$data)
length(sim$results)

# we now reproduce the 6th item in results
print(sim$results[[6]]$data.set.number)
print(sim$results[[6]]$parameters)

all(BH(sim$data[[2]]$procInput$pValues, 0.5, silent=TRUE)$adjPValues == sim$results[[6]]$adjPValues)

#
# Just calculating some statistics and making some plots
NumberOfType1Error &lt;- function(data, result) sum(data$groundTruth * result$rejected)
result.all &lt;- gatherStatistics(sim, list(NumOfType1Err = NumberOfType1Error))
result &lt;- gatherStatistics(sim, list(NumOfType1Err = NumberOfType1Error), 
  list(median=median, mean=mean, sd=sd))
print(result)
require(lattice)
histogram(~NumOfType1Err | method*alpha, data = result.all$statisticDF)
barchart(NumOfType1Err.median + NumOfType1Err.mean ~ method | alpha, data = result$statisticDF)</code></pre>

<hr>
<h2 id='snk'>Student - Newman - Keuls rejective test procedure.</h2><span id='topic+snk'></span><span id='topic+snk.wrapper'></span>

<h3>Description</h3>

<p>Student - Newman - Keuls rejective test procedure.
The procedure controls the FWER in the WEAK sense.</p>


<h3>Usage</h3>

<pre><code class='language-R'>snk(formula, data, alpha, MSE=NULL, df=NULL, silent=FALSE)
snk.wrapper(model, data, alpha, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snk_+3A_formula">formula</code></td>
<td>
<p>Formula defining the statistical model containing the response and the factor levels.</p>
</td></tr>
<tr><td><code id="snk_+3A_model">model</code></td>
<td>
<p>Model with formula, containing the response and the factor levels</p>
</td></tr>
<tr><td><code id="snk_+3A_data">data</code></td>
<td>
<p>dataset containing the response and the grouping factor.</p>
</td></tr>
<tr><td><code id="snk_+3A_alpha">alpha</code></td>
<td>
<p>The level at which the error should be controlled. By default it is alpha=0.05.</p>
</td></tr>
<tr><td><code id="snk_+3A_mse">MSE</code></td>
<td>
<p>Optional for a given variance of the data.</p>
</td></tr>
<tr><td><code id="snk_+3A_df">df</code></td>
<td>
<p>Optional for a given degree of freedom.</p>
</td></tr>
<tr><td><code id="snk_+3A_silent">silent</code></td>
<td>
<p>If true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>This function computes the Student-Newman-Keuls test for given
data including p samples. The Newman-Keuls procedure is based on a stepwise or 
layer approach to significance testing. Sample means are 
ordered from the smallest to the largest. The largest 
difference, which involves means that are r = p steps apart, 
is tested first at <code class="reqn">\alpha</code> level of significance; if significant, 
means that are r = p - 1 steps apart are tested at <code class="reqn">\alpha</code> level 
of significance and so on. The Newman-Keuls procedure provides an
r-mean significance level equal to <code class="reqn">\alpha</code> for each group of 
r ordered means, that is, the probability of falsely rejecting 
the hypothesis that all means in an ordered group are equal to 
<code class="reqn">\alpha</code>. It follows that the concept of error rate applies 
neither on an experimentwise nor on a per comparison basis-the
actual error rate falls somewhere between the two. 
The Newman-Keuls procedure, like Tukey's procedure, requires 
equal sample n's. However, in this algorithm, the procedure is 
adapted to unequal sample sized which can lead to still 
conservative test decisions. 
</p>
<p>It should be noted that the Newman-Keuls and Tukey procedures 
require the same critical difference for the first comparison 
that is tested. The Tukey procedure uses this critical difference
for all the remaining tests, whereas the Newman-Keuls procedure 
reduces the size of the critical difference, depending on the 
number of steps separating the ordered means. As a result, the 
Newman-Keuls test is more powerful than Tukey's test. Remember,
however, that the Newman-Keuls procedure does not control the 
experimentwise error rate at <code class="reqn">\alpha</code>.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>statistics</code></td>
<td>
<p>A numeric vector containing the test-statistics</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing only the estimates</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Frank Konietschke</p>


<h3>References</h3>

<p>Keuls M (1952). &quot;The use of the studentized range in connection with an analysis of variance&quot;. Euphytica 1: 112-122</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = rnorm(50)
grp = c(rep(1:5,10))
dataframe &lt;- data.frame(x,grp)
result &lt;- snk(x~grp, data=dataframe, alpha=0.05,MSE=NULL, df=NULL, silent = TRUE)
result &lt;- snk(x~grp, data=dataframe,alpha=0.05,MSE=NULL, df=NULL, silent = FALSE)
result &lt;- snk(x~grp, data=dataframe,alpha=0.05,MSE=1, df=Inf, silent = FALSE) # known variance
result &lt;- snk(x~grp, data=dataframe,alpha=0.05,MSE=1, df=1000, silent = FALSE) # known variance</code></pre>

<hr>
<h2 id='storey_pi0_est'>Storey-Taylor-Siegmund estimation of pi0 (finite sample version)</h2><span id='topic+storey_pi0_est'></span>

<h3>Description</h3>

<p>The Storey-Taylor-Siegmund procedure for estimating pi0 is applied to pValues.
The formula is equivalent to that in Schweder and Spjotvoll (1982),
page 497, except the additional '+1' in the nominator that
introduces a conservative bias which is proven to be sufficiently large
for FDR control in finite families of hypotheses if the estimation
is used for adjusting the nominal level of a linear step-up test.</p>


<h3>Usage</h3>

<pre><code class='language-R'>storey_pi0_est(pValues, lambda)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="storey_pi0_est_+3A_pvalues">pValues</code></td>
<td>
<p>The raw p-values for the marginal test problems</p>
</td></tr>
<tr><td><code id="storey_pi0_est_+3A_lambda">lambda</code></td>
<td>
<p>A tuning parameter in the interval (0, 1)</p>
</td></tr></table>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>pi0</code></td>
<td>
<p>A numeric number containing the estimated value of pi0</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A numeric number containing the tuning parameter for the estimation</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MarselScheer</p>


<h3>References</h3>

<p>Schweder, T. and Spjotvoll, E. (1982). Plots of P-values to evaluate many tests simultaneously. 
Biometrika 69, 3, 493-502.
</p>
<p>Storey, J. D., Taylor, J. E. and Siegmund, D. (2004). Strong control, conservative point estimation and
simultaneous conservative consistency of false discovery rates: a unified approach. JRSS B 66, 1, 187-205.</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.pvals &lt;- c(runif(50), runif(50, 0, 0.01))
result &lt;- storey_pi0_est(my.pvals, 0.5)</code></pre>

<hr>
<h2 id='SU'>A general step-up procedure.</h2><span id='topic+SU'></span>

<h3>Description</h3>

<p>A general step-up procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SU(pValues, criticalValues)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SU_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used.</p>
</td></tr>
<tr><td><code id="SU_+3A_criticalvalues">criticalValues</code></td>
<td>
<p>criticalValues for the step-up procedure</p>
</td></tr></table>


<h3>Details</h3>

<p>Suppose we have n pValues and they are already sorted. 
The procedure starts with comparing pValues[n] with criticalValues[n]. If
pValues[n] &gt; criticalValues[n], then the hypothesis associated with pValues[n] 
is retained and the algorithm carries on with the next pValue and criticalValue, here for example pValues[n-1]
and criticalValues[n-1]. The algorithm stops retaining at the first index i for
which pValues[i] &lt;= criticalValues[i]. Thus pValues[j] is rejected if and only if
their exists an index i with j &lt;= i and pValues[i] &lt;= criticalValues[i].</p>


<h3>Value</h3>

<p>rejected logical vector indicating if hypotheses are rejected or retained.</p>


<h3>Author(s)</h3>

<p>MarselScheer</p>

<hr>
<h2 id='SUD'>A general step-up-down procedure.</h2><span id='topic+SUD'></span>

<h3>Description</h3>

<p>A general step-up-down procedure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SUD(pValues, criticalValues, startIDX_SUD)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SUD_+3A_pvalues">pValues</code></td>
<td>
<p>pValues to be used.</p>
</td></tr>
<tr><td><code id="SUD_+3A_criticalvalues">criticalValues</code></td>
<td>
<p>criticalValues for the step-up-down procedure</p>
</td></tr>
<tr><td><code id="SUD_+3A_startidx_sud">startIDX_SUD</code></td>
<td>
<p>the index (between 1 and length(pValues)) used for the first 
comparison of pValues[startIDX_SUD] and criticalValues[startIDX_SUD]. Depending
on the result of this comparison the algorithm decides to proceed in 
step-up or step-down manner.</p>
</td></tr></table>


<h3>Details</h3>

<p>Suppose we have n pValues and they are already sorted.
The procedure compares pValues[startIDX_SUD] with criticalValues[startIDX_SUD]
and then proceeds in step-up or step-down manner,   
depending on the result of this initial comparision.
</p>
<p>If pValues[startIDX_SUD] &lt;= criticalValues[startIDX_SUD], then the procedure
rejects the hypotheses associated with pValues[1], ..., pValues[startIDX_SUD]  
and carries on in a step-down manner from startIDX_SUD to n to reject additional hypotheses.
</p>
<p>If pValues[startIDX_SUD] &gt; criticalValues[startIDX_SUD], then the procedure
retains hypotheses associated with pValues[startIDX_SUD], ..., pValues[n] and 
carries on in a step-up manner with pValues[startIDX_SUD - 1], ..., pValues[1]. 
</p>
<p>If startIDX_SUD equals n the algorithm behaves like a step-up procedure.
</p>
<p>If startIDX_SUD equals 1 the algorithm behaves like a step-down procedure.</p>


<h3>Value</h3>

<p>rejected logical vector indicating if hypotheses are rejected or retained.</p>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>

<hr>
<h2 id='TSBKY_pi0_est'>Two-step estimation method of Benjamini, Krieger and Yekutieli for estimating pi0</h2><span id='topic+TSBKY_pi0_est'></span>

<h3>Description</h3>

<p>The two-step estimation method of Benjamini, Krieger and Yekutieli for estimating pi0 is applied to pValues.
It consists of the following two steps:
Step 1. Use the linear step-up procedure at level alpha' =alpha/(1+alpha). Let r1 be the number of
rejected hypotheses. If r1=0 do not reject any hypothesis and stop; if r1=m reject all m
hypotheses and stop; otherwise continue.
Step 2. Let <code class="reqn">\hat{m0} =(m - r1)</code> and <code class="reqn">\hat{pi0} = \hat{m0} / m</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSBKY_pi0_est(pValues, alpha)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TSBKY_pi0_est_+3A_pvalues">pValues</code></td>
<td>
<p>The raw p-values for the marginal test problems</p>
</td></tr>
<tr><td><code id="TSBKY_pi0_est_+3A_alpha">alpha</code></td>
<td>
<p>The parameter (to be interpreted as significance level) for the procedure</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pi0.TSBKY</code></td>
<td>
<p>The estimated proportion of true null hypotheses.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>WerftWiebke</p>


<h3>References</h3>

<p>Benjamini, Y., Krieger, A. and Yekutieli, D. (2006). Adaptive linear step-up procedures that control the false discovery rate
Biometrika 93, 3, page 495.</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.pvals &lt;- c(runif(50), runif(50, 0, 0.01))
result &lt;- TSBKY_pi0_est(my.pvals, 0.1)</code></pre>

<hr>
<h2 id='tukey.wrapper'>Tukey HSD test and simultaneous confidence intervals for all pairs comparisons...</h2><span id='topic+tukey.wrapper'></span>

<h3>Description</h3>

<p>Tukey HSD test and simultaneous confidence intervals for all pairs comparisons
in factorial designs. The procedure controls the FWER in the strong sense.</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukey.wrapper(model, alpha, factorC)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tukey.wrapper_+3A_model">model</code></td>
<td>
<p>A fitted model, for example an object returned by lm, glm, or aov etc. It is
assumed that coef and vcov methods are available for model. Usually, it is an aov fit</p>
</td></tr>
<tr><td><code id="tukey.wrapper_+3A_alpha">alpha</code></td>
<td>
<p>The significance level</p>
</td></tr>
<tr><td><code id="tukey.wrapper_+3A_factorc">factorC</code></td>
<td>
<p>Specifies a factor</p>
</td></tr></table>


<h3>Details</h3>

<p>this function, it is possible to compute all pairs comparisons for expectations and 
simultaneous confidence intervals in factorial linear models. Hereby, the all-pairs comparisons
can be performed for user given effects. The overall variance is estimated by the linear model
as well as the degree of freedom used by the studentized range distribution.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing the adjusted pValues</p>
</td></tr>
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>confIntervals</code></td>
<td>
<p>A matrix containing the estimates and the lower and upper confidence bound</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Frank Konietschke et al.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warpbreaks)
# Tukey contrast on the levels of the factor "Tension"

tukey.wrapper(aov(breaks ~ tension, data = warpbreaks), factorC="tension",alpha=0.05)


# Two-way anova with interaction
tukey.wrapper(aov(breaks ~ tension*wool, data = warpbreaks),alpha=0.05,factorC="tension")
# Two-way anova without interaction

tukey.wrapper(aov(breaks ~ tension+wool, data = warpbreaks),alpha=0.05,factorC="tension")
tukey.wrapper(aov(breaks ~ tension, data = warpbreaks),alpha=0.05,factorC="tension")


data(iris)
tukey.wrapper(lm(Sepal.Length ~ Species, data=iris),alpha=0.05, factorC="Species")</code></pre>

<hr>
<h2 id='two.stage'>A p-value procedure which controls the FDR for independent test statistics.</h2><span id='topic+two.stage'></span>

<h3>Description</h3>

<p>A p-value procedure which controls the FDR for independent test statistics.</p>


<h3>Usage</h3>

<pre><code class='language-R'>two.stage(pValues, alpha)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="two.stage_+3A_pvalues">pValues</code></td>
<td>
<p>A numeric vecor of p-values.</p>
</td></tr>
<tr><td><code id="two.stage_+3A_alpha">alpha</code></td>
<td>
<p>The FDR error rate to control.</p>
</td></tr></table>


<h3>Details</h3>

<p>In the Benjamini-Krieger-Yekutieli two-stage procedure the linear step-up procedure is used in
stage one to estimate m0 which is re-plugged in a linear step-up. 
This procedure is more powerful then non-adaptive procedures, while still controlling the FDR. 
On the other hand, error control is not guaranteed under dependence in which case more conservative procedures should be used (e.g. BH).</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>criticalValues</code></td>
<td>
<p>A numeric vector containing critical values used in the step-up-down test.</p>
</td></tr> 
<tr><td><code>adjPValues</code></td>
<td>
<p>A numeric vector containing adjusted p-values.</p>
</td></tr>
<tr><td><code>pi0</code></td>
<td>
<p>An estimate of the proportion of true null hypotheses among all hypotheses (pi0=m0/m). </p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>JonathanRosenblatt</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvals&lt;- runif(100)^2
two.stage(pvals, 0.1)</code></pre>

<hr>
<h2 id='twosamp.marginal'>Marginal two sample test</h2><span id='topic+twosamp.marginal'></span>

<h3>Description</h3>

<p>The robust version uses the Wilcoxon-Mann-Whitney test, otherwise a two-sample t-test will be performed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>twosamp.marginal(data, model, robust, alternative, psi0, equalvar)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twosamp.marginal_+3A_data">data</code></td>
<td>
<p>the data set</p>
</td></tr>
<tr><td><code id="twosamp.marginal_+3A_model">model</code></td>
<td>
<p>the result of a call to <code>twosamp.model(classlabel)</code></p>
</td></tr>
<tr><td><code id="twosamp.marginal_+3A_robust">robust</code></td>
<td>
<p>a logical variable indicating whether a two sample t-test or a Wilcoxon-Mann-Whitney test should be used.</p>
</td></tr>
<tr><td><code id="twosamp.marginal_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must be one of <code>two.sided</code>, <code>greater</code> or <code>less</code></p>
</td></tr>
<tr><td><code id="twosamp.marginal_+3A_psi0">psi0</code></td>
<td>
<p>a numeric that defines the hypothesized null value</p>
</td></tr>
<tr><td><code id="twosamp.marginal_+3A_equalvar">equalvar</code></td>
<td>
<p>a logical variable indicating whether to treat the two variances as being equal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector of classlabels needs to be provided to distinguish the two groups.</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pValues</code></td>
<td>
<p>A numeric vector containing the unadjusted pValues</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>MuToss-Coding Team</p>


<h3>References</h3>

<p>Wilcoxon, F. (1945). Individual Comparisons by Ranking Methods. Biometrics Bulletin 1:80-83.
Mann, H. and Whitney, D. (1947). On a test of whether one of two random variables is stochastically larger than the other. Annals of Mathematical Statistics 18:50-60
Student (1908). The probable error of a mean. Biometrika, 6(1):1-25.
</p>

<hr>
<h2 id='twostageBR'>Blanchard-Roquain (2009) 2-stage adaptive step-up...</h2><span id='topic+twostageBR'></span>

<h3>Description</h3>

<p>Blanchard-Roquain (2009) 2-stage adaptive step-up</p>


<h3>Usage</h3>

<pre><code class='language-R'>twostageBR(pValues, alpha, lambda=1, silent=FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twostageBR_+3A_pvalues">pValues</code></td>
<td>
<p>the used p-values (assumed to be independent)</p>
</td></tr>
<tr><td><code id="twostageBR_+3A_alpha">alpha</code></td>
<td>
<p>the level at which the FDR should be controlled.</p>
</td></tr>
<tr><td><code id="twostageBR_+3A_lambda">lambda</code></td>
<td>
<p>parameter of the procedure, should belong to
(0, 1/alpha) (lambda=1 default)</p>
</td></tr>
<tr><td><code id="twostageBR_+3A_silent">silent</code></td>
<td>
<p>if true any output on the console will be suppressed.</p>
</td></tr></table>


<h3>Details</h3>

<p>This is an adaptive linear step-up procedure where the proportion of true
nulls is estimated using the Blanchard-Roquain 1-stage procedure with parameter lambda,
via the formula
</p>
<p>estimated pi_0 = ( m - R(alpha,lambda)  + 1) / ( m*( 1 - lambda * alpha ) )
</p>
<p>where R(alpha,lambda) is the number of hypotheses rejected by the BR 1-stage procedure,
alpha is the level at which FDR should be controlled and lambda an 
arbitrary parameter belonging to (0, 1/alpha) with default value 1.
This procedure controls FDR at the desired level when the p-values are independent.</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>rejected</code></td>
<td>
<p>A logical vector indicating which hypotheses are rejected</p>
</td></tr>
<tr><td><code>errorControl</code></td>
<td>
<p>A Mutoss S4 class of type <code>errorControl</code>, containing the type of error controlled by the function and the level <code>alpha</code>.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>GillesBlanchard</p>


<h3>References</h3>

<p>Blanchard, G. and Roquain, E. (2009) 
Adaptive False Discovery Rate Control under Independence and Dependence
Journal of Machine Learning Research 10:2837-2871.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
