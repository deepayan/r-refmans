<!DOCTYPE html><html><head><title>Help for package mobr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mobr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#avg_nn_dist'><p>Compute average nearest neighbor distance</p></a></li>
<li><a href='#calc_biodiv'><p>Calculate biodiversity statistics from sites by species table.</p></a></li>
<li><a href='#calc_chao1'><p>Estimation of species richness</p></a></li>
<li><a href='#calc_PIE'><p>Calculate probability of interspecific encounter (PIE)</p></a></li>
<li><a href='#centroid_accumulate'><p>Internal function used by kNCN_average to compute the k-NCN algorithm</p>
starting with a specified focal sample</a></li>
<li><a href='#compare_samp_rarefaction'><p>Compare all sample-based curves (random, spatially constrained-k-NN,</p>
spatially constrained-k-NCN)</a></li>
<li><a href='#fire_comm'><p>Fire data set</p></a></li>
<li><a href='#get_delta_curves'><p>Auxiliary function for computing S and the effect on S of</p>
the three components of community structure: SAD, N, and aggregation</a></li>
<li><a href='#get_delta_stats'><p>Conduct the MoB tests on drivers of biodiversity across scales.</p></a></li>
<li><a href='#get_F_values'><p>Get F statistics from diversity indices and grouping vector</p></a></li>
<li><a href='#get_group_delta'><p>Get gamma-scale differences</p></a></li>
<li><a href='#get_ind_dens'><p>Auxiliary function for get_delta_stats()</p>
Returns the &quot;assumed&quot; density of individuals in
a plot given whether min, max or mean is used</a></li>
<li><a href='#get_inds'><p>Auxiliary function for get_delta_stats()</p>
Returns a vector of abundances where individual-based rarefaction
will be performed</a></li>
<li><a href='#get_mob_stats'><p>Calculate sample based and group based biodiversity statistics.</p></a></li>
<li><a href='#get_null_comm'><p>Generate a null community matrix</p></a></li>
<li><a href='#get_overall_p'><p>Auxiliary function for effect_ functions</p>
Compute an overall p-value for one factor in the discrete case
p-value is based on mean squared difference from zero summed across the scales
Method developed by Loosmore and Ford 2006 but algebraic simplifications
used as developed by Baddeley et al. 2014 Ecological Archives M084-017-A1</a></li>
<li><a href='#get_rand_sad'><p>Randomly sample of a relative abundance distribution (RAD)</p>
to produce an expected species abundance distribution (SAD)</a></li>
<li><a href='#groups_panel1'><p>Panel function for gamma-scale results</p></a></li>
<li><a href='#groups_panel2'><p>Panel function for gamma-scale results with confidence intervals</p></a></li>
<li><a href='#ind_rare_perm'><p>Compute permutation derived individual-based rarefaction curves</p></a></li>
<li><a href='#inv_comm'><p>Invasive plants dataset</p></a></li>
<li><a href='#kNCN_average'><p>Construct spatially constrained sample-based rarefaction (sSBR) curve using</p>
the k-Nearest-Centroid-neighbor (k-NCN) algorithm</a></li>
<li><a href='#make_mob_in'><p>Create the 'mob_in' object.</p></a></li>
<li><a href='#mobr'><p>Measurement of Biodiversity in R</p></a></li>
<li><a href='#mod_sum'><p>Extract coefficients and metrics of fit from model</p></a></li>
<li><a href='#plot_abu'><p>Plot distributions of species abundance</p></a></li>
<li><a href='#plot_N'><p>Plot the relationship between the number of plots and the number of</p>
individuals</a></li>
<li><a href='#plot_rarefaction'><p>Plot rarefaction curves for each treatment group</p></a></li>
<li><a href='#plot.mob_out'><p>Plot the multiscale MoB analysis output generated by <code>get_delta_stats</code>.</p></a></li>
<li><a href='#plot.mob_stats'><p>Plot alpha- and gamma-scale biodiversity statistics for a MoB analysis</p></a></li>
<li><a href='#plotStacked'><p>Stacked plot by Marc Taylor (@marchtaylor on gitHub)</p></a></li>
<li><a href='#print.mob_in'><p>Print a shortened version of the mob_in object</p></a></li>
<li><a href='#rarefaction'><p>Rarefied Species Richness</p></a></li>
<li><a href='#samples_panel1'><p>Panel function for alpha-scale results</p></a></li>
<li><a href='#sphere_dist'><p>Internal function for distance matrix assuming inputs are longitude and</p>
latitudes on a spherical Earth.</a></li>
<li><a href='#subset.mob_in'><p>Subset the rows of the mob data input object</p></a></li>
<li><a href='#tank_comm'><p>Cattle tank data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Measurement of Biodiversity</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-09</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for calculating metrics for the measurement biodiversity
    and its changes across scales, treatments, and gradients. The methods 
    implemented in this package are described in:
    Chase, J.M., et al. (2018) &lt;<a href="https://doi.org/10.1111%2Fele.13151">doi:10.1111/ele.13151</a>&gt;, 
    McGlinn, D.J., et al. (2019) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13102">doi:10.1111/2041-210X.13102</a>&gt;, and
    McGlinn, D.J., et al. (2021) &lt;<a href="https://doi.org/10.1002%2Fecy.3233">doi:10.1002/ecy.3233</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plotrix, scales, dplyr, purrr, tidyr, pbapply, ggplot2, egg,
tibble, vctrs, rlang, geosphere</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-10 02:12:21 UTC; mcglinndj</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel McGlinn [aut, cre],
  Xiao Xiao [aut],
  Brian McGill [aut],
  Felix May [aut],
  Thore Engel [aut],
  Caroline Oliver [aut],
  Shane Blowes [aut],
  Tiffany Knight [aut],
  Oliver Purschke [aut],
  Nicholas Gotelli [aut],
  Jon Chase [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel McGlinn &lt;danmcglinn@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-10 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='avg_nn_dist'>Compute average nearest neighbor distance</h2><span id='topic+avg_nn_dist'></span>

<h3>Description</h3>

<p>This function computes the average distance of the next
nearest sample for a given set of coordinates. This method
of sampling is used  by the function <code>rarefaction</code>
when building the spatial, sample-based rarefaction curves (sSBR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg_nn_dist(coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg_nn_dist_+3A_coords">coords</code></td>
<td>
<p>a matrix with n-dimensional coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of average distances for each sequential number
of accumulated nearest samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># transect spatial arrangement
transect = 1:100
avg_nn_dist(transect)
grid = expand.grid(1:10, 1:10)
avg_nn_dist(grid)
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(1,2)) 
plot(avg_nn_dist(transect), type='o', main='transect',
     xlab='# of samples', ylab='average distance')
# 2-D grid spatial arrangement
plot(avg_nn_dist(grid), type='o', main='grid',
     xlab='# of samples', ylab='average distance')
par(oldpar)
</code></pre>

<hr>
<h2 id='calc_biodiv'>Calculate biodiversity statistics from sites by species table.</h2><span id='topic+calc_biodiv'></span>

<h3>Description</h3>

<p>Calculate biodiversity statistics from sites by species table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_biodiv(
  abund_mat,
  groups,
  index,
  effort,
  extrapolate,
  return_NA,
  rare_thres
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_biodiv_+3A_abund_mat">abund_mat</code></td>
<td>
<p>Sites by species table with species abundances
in the respective cells</p>
</td></tr>
<tr><td><code id="calc_biodiv_+3A_groups">groups</code></td>
<td>
<p>Vector with group labels for the sites. The length
of the vector has to correspond to the number of rows of the
sites by species table.</p>
</td></tr>
<tr><td><code id="calc_biodiv_+3A_index">index</code></td>
<td>
<p>The calculated biodiversity indices. The options are
</p>

<ul>
<li> <p><code>N</code> ... Number of individuals (total abundance)
</p>
</li>
<li> <p><code>S</code> ... Number of species
</p>
</li>
<li> <p><code>S_n</code> ... Rarefied or extrapolated number of species for n individuals
</p>
</li>
<li> <p><code>S_asymp</code> ... Estimated asymptotic species richness
</p>
</li>
<li> <p><code>f_0</code> ... Estimated number of undetected species 
</p>
</li>
<li> <p><code>pct_rare</code> ... The percent of species with abundances below <code>rare_thres</code>
</p>
</li>
<li> <p><code>PIE</code> ... Hurlbert's PIE (Probability of Interspecific Encounter)
</p>
</li>
<li> <p><code>S_PIE</code> ... Effective number of species based on PIE
</p>
</li></ul>

<p>See the documentation of <code><a href="#topic+get_mob_stats">get_mob_stats</a></code> for further details on the
biodiversity indices.</p>
</td></tr>
<tr><td><code id="calc_biodiv_+3A_effort">effort</code></td>
<td>
<p>The standardized number of individuals used for the 
calculation of rarefied species richness. This can a be
single value or an integer vector.</p>
</td></tr>
<tr><td><code id="calc_biodiv_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Boolean which specifies if richness should be extrapolated
when effort is larger than the number of individuals using the chao1
method.</p>
</td></tr>
<tr><td><code id="calc_biodiv_+3A_return_na">return_NA</code></td>
<td>
<p>Boolean in which the rarefaction function
returns the observed S when <code>effort</code> is larger than the number of
individuals. If set to TRUE then NA is returned. Note that this argument
is only relevant when <code>extrapolate = FALSE</code>.</p>
</td></tr>
<tr><td><code id="calc_biodiv_+3A_rare_thres">rare_thres</code></td>
<td>
<p>The threshold that determines how pct_rare is computed.
It can range from (0, 1] and defaults to 0.05 which specifies that any 
species with less than or equal to 5
considered rare. It can also be specified as &quot;N/S&quot; which results in using
average abundance as the threshold which McGill (2011) found to have the 
best small sample behavior.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily intended as auxiliary function used in
<code><a href="#topic+get_mob_stats">get_mob_stats</a></code>, but can be also used directly for data exploration.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with four columns:
</p>

<ul>
<li> <p><code>group</code> ... Group label for sites
</p>
</li>
<li> <p><code>index</code> ... Name of the biodiversity index
</p>
</li>
<li> <p><code>effort</code> ... Sampling effort for rarefied richness 
(NA for the other indices)
</p>
</li>
<li> <p><code>value</code> ... Value of the biodiversity index
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Felix May and Dan McGlinn
</p>


<h3>References</h3>

<p>McGill, B. J. 2011. Species abundance distributions. Pages 105-122 Biological
Diversity: Frontiers in Measurement and Assessment, eds. A.E. Magurran and
B.J. McGill.
</p>

<hr>
<h2 id='calc_chao1'>Estimation of species richness</h2><span id='topic+calc_chao1'></span>

<h3>Description</h3>

<p><code>calc_chao1</code> estimates the number of species at the asymptote
(<code>S_asymp</code>) of the species accumulation curve based on the methods
proposed in Chao (1984, 1987, 2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_chao1(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_chao1_+3A_x">x</code></td>
<td>
<p>a vector of species abundances or a site-by-species matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a trimmed version of <a href="https://github.com/JohnsonHsieh/iNEXT"><code>iNext::ChaoRichess</code></a>.
T. C. Hsieh, K. H. Ma and Anne Chao are the original authors of the
<code>iNEXT</code> package.
</p>


<h3>Value</h3>

<p>a vector of species richness estimates
</p>


<h3>References</h3>

<p>Chao, A. (1984) Nonparametric estimation of the number of classes in a
population. Scandinavian Journal of Statistics, 11, 265-270.
</p>
<p>Chao, A. (1987) Estimating the population size for capture-recapture data with
unequal catchability. Biometrics, 43, 783-791.
</p>
<p>Chao, A. (2005) Species estimation and applications. Pages 7907-7916 in
N. Balakrishnan, C. B. Read, and B. Vidakovic, editors. Encyclopedia of
statistical sciences. Second edition, volume 12. Wiley, New York, New York,
USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
calc_chao1(inv_comm)
</code></pre>

<hr>
<h2 id='calc_PIE'>Calculate probability of interspecific encounter (PIE)</h2><span id='topic+calc_PIE'></span>

<h3>Description</h3>

<p><code>calc_PIE</code> returns the probability of interspecific  encounter (PIE)
which is also known as Simpson's evenness index and Gini-Simpson index. For <code>ENS=TRUE</code>,
PIE will be converted to an asymptotic effective number of species (S_PIE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_PIE(x, ENS = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_PIE_+3A_x">x</code></td>
<td>
<p>can either be a: 1) mob_in object, 2) community matrix-like
object in which rows represent plots and columns represent species, or 3)
a vector which contains the abundance of each species.</p>
</td></tr>
<tr><td><code id="calc_PIE_+3A_ens">ENS</code></td>
<td>
<p>Boolean that determines if the effective number of species should
be returned or the raw PIE value. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula of Hurlbert (1971) is used to calculate PIE:
</p>
<p><code class="reqn">PIE = N /(N - 1) * (1 - p_i^2)</code>
</p>
<p>where N is the total number of individuals and <code class="reqn">p_i</code> is the relative abundance
of species i. This formulation uses sampling without replacement and it is
sometimes referred to as the bias corrected formulation of PIE.
</p>
<p>For <code>ENS = TRUE</code>, S_PIE will be returned which represents the species richness of
a hypothetical community with equally-abundant species and infinitely many individuals
corresponding to the observed value of PIE. It is computed as
<code class="reqn">S_PIE = 1 /(1 - PIE)</code>, which is equal to the
asymptotic estimator for Hill numbers of diversity order 2 provided by Chao et al (2014).
Note that S_PIE is undefined for communities with exactly one individual per species.
</p>
<p>The code in this function borrows heavily from the function vegan::diversity()
but computes a different quantity. The function vegan::diversity() computes
PIE when sampling with replacement is assumed. The difference between the two 
formulations will decrease as N becomes large. Jari Oksanen and Bob O'Hara are
the original authors of the function vegan::diversity().
</p>


<h3>Author(s)</h3>

<p>Dan McGlinn, Thore Engel
</p>


<h3>References</h3>

<p>Hurlbert, S. H. (1971) The nonconcept of species diversity: a critique and
alternative parameters. Ecology 52, 577-586.
</p>
<p>Chao, A., Gotelli, N. J., Hsieh, T. C., Sander, E. L., Ma, K. H., Colwell, R. K., &amp; Ellison, A. M. (2014).
Rarefaction and extrapolation with Hill numbers: A framework for sampling and estimation in species diversity studies.
Ecological Monographs 84(1), 45-67.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
calc_PIE(inv_comm)
calc_PIE(inv_comm, ENS=TRUE)
</code></pre>

<hr>
<h2 id='centroid_accumulate'>Internal function used by kNCN_average to compute the k-NCN algorithm
starting with a specified focal sample</h2><span id='topic+centroid_accumulate'></span>

<h3>Description</h3>

<p>Internal function used by kNCN_average to compute the k-NCN algorithm
starting with a specified focal sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid_accumulate(
  x,
  focal_sample = 1,
  n = NULL,
  coords = NULL,
  latlong = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_accumulate_+3A_x">x</code></td>
<td>
<p>a mob_in object or a community site x species matrix</p>
</td></tr>
<tr><td><code id="centroid_accumulate_+3A_focal_sample">focal_sample</code></td>
<td>
<p>an integer from 1 to the number of samples of x that 
specifies which sample to start with. Defaults to 1</p>
</td></tr>
<tr><td><code id="centroid_accumulate_+3A_n">n</code></td>
<td>
<p>the number of samples to accumulate, defaults to NULL in which 
case all samples are accumulated</p>
</td></tr>
<tr><td><code id="centroid_accumulate_+3A_coords">coords</code></td>
<td>
<p>the spatial coordinates of the samples of x</p>
</td></tr>
<tr><td><code id="centroid_accumulate_+3A_latlong">latlong</code></td>
<td>
<p>if latitude longitude arguments are supplied</p>
</td></tr>
</table>

<hr>
<h2 id='compare_samp_rarefaction'>Compare all sample-based curves (random, spatially constrained-k-NN,
spatially constrained-k-NCN)</h2><span id='topic+compare_samp_rarefaction'></span>

<h3>Description</h3>

<p>This is just plotting all curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_samp_rarefaction(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_samp_rarefaction_+3A_x">x</code></td>
<td>
<p>a mob_in object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
compare_samp_rarefaction(inv_mob_in)

</code></pre>

<hr>
<h2 id='fire_comm'>Fire data set</h2><span id='topic+fire_comm'></span><span id='topic+fire_plot_attr'></span>

<h3>Description</h3>

<p>Woody plant species counts in burned and unburned forest sites
in the Missouri Ozarks, USA.
</p>


<h3>Details</h3>

<p><code>fire_comm</code> is a site-by-species matrix with individual counts.
</p>
<p><code>fire_plot_attr</code> is a data frame with corresponding site variables. The
column <code>group</code> specifies whether a site is &quot;burned&quot; or &quot;unburned&quot;. This
variable is considered a &quot;treatment&quot; in the mob framework. The columns
<code>x</code> and <code>y</code> contain the spatial coordinates of the sites.
</p>
<p>The data were adapted from Myers et al (2015).
</p>


<h3>References</h3>

<p>Myers, J. A., Chase, J. M., Crandall, R. M., &amp; Jimenez, I.
(2015). Disturbance alters beta-diversity but not the relative importance of
community assembly mechanisms. Journal of Ecology, 103: 1291-1299.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fire_comm)
data(fire_plot_attr)
fire_mob_in = make_mob_in(fire_comm, fire_plot_attr)
</code></pre>

<hr>
<h2 id='get_delta_curves'>Auxiliary function for computing S and the effect on S of 
the three components of community structure: SAD, N, and aggregation</h2><span id='topic+get_delta_curves'></span>

<h3>Description</h3>

<p>Auxiliary function for computing S and the effect on S of 
the three components of community structure: SAD, N, and aggregation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_delta_curves(
  x,
  tests = c("SAD", "N", "agg"),
  spat_algo = NULL,
  inds = NULL,
  ind_dens = NULL,
  n_plots = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_delta_curves_+3A_x">x</code></td>
<td>
<p>can either be a: 1) mob_in object or 2) a vector which contains
the abundance of each species (i.e., the SAD). All effects can be computed
when x is a mob_in object but only the SAD effect can be computed when
x is a vector of species abundances.</p>
</td></tr>
<tr><td><code id="get_delta_curves_+3A_tests">tests</code></td>
<td>
<p>what effects to compute defaults to 'SAD', 'N', and 'agg'</p>
</td></tr>
<tr><td><code id="get_delta_curves_+3A_spat_algo">spat_algo</code></td>
<td>
<p>character string that can be either: <code>'kNN'</code> or <code>'kNCN'</code>
for k-nearest neighbor and k-nearest centroid neighbor sampling 
respectively. It defaults to k-nearest neighbor which is a 
more computationally efficient algorithm that closely approximates the 
potentially more correct k-NCN algo (see Details).</p>
</td></tr>
<tr><td><code id="get_delta_curves_+3A_ind_dens">ind_dens</code></td>
<td>
<p>the density of individuals to compare against for computing
N effect</p>
</td></tr>
</table>

<hr>
<h2 id='get_delta_stats'>Conduct the MoB tests on drivers of biodiversity across scales.</h2><span id='topic+get_delta_stats'></span>

<h3>Description</h3>

<p>There are three tests, on effects of 1. the shape of the SAD, 2.
treatment/group-level density, 3. degree of aggregation. The user can
specifically to conduct one or more of these tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_delta_stats(
  mob_in,
  env_var,
  group_var = NULL,
  ref_level = NULL,
  tests = c("SAD", "N", "agg"),
  spat_algo = NULL,
  type = c("continuous", "discrete"),
  stats = NULL,
  inds = NULL,
  log_scale = FALSE,
  min_plots = NULL,
  density_stat = c("mean", "max", "min"),
  n_perm = 1000,
  overall_p = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_delta_stats_+3A_mob_in">mob_in</code></td>
<td>
<p>an object of class mob_in created by make_mob_in()</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_env_var">env_var</code></td>
<td>
<p>a character string specifying the environmental variable in
<code>mob_in$env</code> to be used for explaining the change in richness</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_group_var">group_var</code></td>
<td>
<p>an optional character string 
in <code>mob_in$env</code> which defines how samples are pooled. If not provided
then each unique value of the argument <code>env_var</code> is used define the
groups.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_ref_level">ref_level</code></td>
<td>
<p>a character string used to define the reference level of
<code>env_var</code> to which all other groups are compared with. Only makes sense
if <code>env_var</code> is a factor (i.e. <code>type == 'discrete'</code>)</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_tests">tests</code></td>
<td>
<p>specifies which one or more of the three tests ('SAD', N',
'agg') are to be performed. Default is to include all three tests.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_spat_algo">spat_algo</code></td>
<td>
<p>character string that can be either: <code>'kNN'</code> or
<code>'kNCN'</code> for k-nearest neighbor and k-nearest centroid neighbor
sampling respectively. It defaults to k-nearest neighbor which is a more
computationally efficient algorithm that closely approximates the
potentially more correct k-NCN algo (see Details of ?rarefaction).</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_type">type</code></td>
<td>
<p>&quot;discrete&quot; or &quot;continuous&quot;. If &quot;discrete&quot;, pair-wise comparisons
are conducted between all other groups and the reference group. If
&quot;continuous&quot;, a correlation analysis is conducted between the response
variables and env_var.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_stats">stats</code></td>
<td>
<p>a vector of character strings that specifies what statistics to
summarize effect sizes with. Options include: <code>c('betas', 'r2',
'r2adj', 'f', 'p')</code> for the beta-coefficients, r-squared, adjusted
r-squared, F-statistic, and p-value respectively. The default value of
<code>NULL</code> will result in only betas being calculated when <code>type ==
'discrete'</code> and all possible stats being computed when <code>type ==
'continuous'</code>. Note that for a discrete analysis all non-betas stats are
meaningless because the model has zero degrees of freedom in this context.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_inds">inds</code></td>
<td>
<p>effort size at which the individual-based rarefaction curves are
to be evaluated, and to which the sample-based rarefaction curves are to be
interpolated. It can take three types of values, a single integer, a vector
of integers, and NULL. If <code>inds = NULL</code> (the default), the curves are
evaluated at every possible effort size, from 1 to the total number of
individuals within the group (slow). If inds is a single integer, it is
taken as the number of points at which the curves are evaluated; the
positions of the points are determined by the &quot;log_scale&quot; argument. If inds
is a vector of integers, it is taken as the exact points at which the
curves are evaluated.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_log_scale">log_scale</code></td>
<td>
<p>if &quot;inds&quot; is given a single integer, &quot;log_scale&quot; determines
the position of the points. If log_scale is TRUE, the points are equally
spaced on logarithmic scale. If it is FALSE (default), the points are
equally spaced on arithmetic scale.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_min_plots">min_plots</code></td>
<td>
<p>minimal number of plots for test 'agg', where plots are
randomized within groups as null test. If it is given a value, all groups
with fewer plots than min_plot are removed for this test. If it is NULL
(default), all groups are kept. Warnings are issued if 1. there is only one
group left and &quot;type&quot; is discrete, or 2. there are less than three groups
left and &quot;type&quot; is continuous, or 3. reference group (&quot;ref_group&quot;) is
removed and &quot;type&quot; is discrete. In these three scenarios, the function will
terminate. A different warning is issued if any of the remaining groups
have less than five plots (which have less than 120 permutations), but the 
test will be carried out.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_density_stat">density_stat</code></td>
<td>
<p>reference density used in converting number of plots to
numbers of individuals, a step in test &quot;N&quot;. It can take one of the
three values: &quot;mean&quot;, &quot;max&quot;, or &quot;min&quot;. If it is &quot;mean&quot;, the average
plot-level abundance across plots (all plots when &quot;type&quot; is &quot;continuous,
all plots within the two groups for each pair-wise comparison when &quot;type&quot;
is &quot;discrete&quot;) are used. If it is &quot;min&quot; or &quot;max&quot;, the minimum/maximum
plot-level density is used.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_n_perm">n_perm</code></td>
<td>
<p>number of iterations to run for null tests, defaults to 1000.</p>
</td></tr>
<tr><td><code id="get_delta_stats_+3A_overall_p">overall_p</code></td>
<td>
<p>Boolean defaults to FALSE specifies if overall across scale 
p-values for the null tests. This should be interpreted with caution because
the overall p-values depend on scales of measurement yet do not explicitly 
reflect significance at any particular scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;mob_out&quot; object with attributes
</p>


<h3>Author(s)</h3>

<p>Dan McGlinn and Xiao Xiao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rarefaction">rarefaction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
inv_mob_out = get_delta_stats(inv_mob_in, 'group', ref_level='uninvaded',
                           type='discrete', log_scale=TRUE, n_perm=3)
plot(inv_mob_out)
</code></pre>

<hr>
<h2 id='get_F_values'>Get F statistics from diversity indices and grouping vector</h2><span id='topic+get_F_values'></span>

<h3>Description</h3>

<p>Get F statistics from diversity indices and grouping vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_F_values(div_dat, permute = FALSE)
</code></pre>

<hr>
<h2 id='get_group_delta'>Get gamma-scale differences</h2><span id='topic+get_group_delta'></span>

<h3>Description</h3>

<p>Get gamma-scale differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_group_delta(
  abund_mat,
  groups,
  index,
  effort,
  extrapolate,
  return_NA,
  rare_thres,
  permute = FALSE
)
</code></pre>

<hr>
<h2 id='get_ind_dens'>Auxiliary function for get_delta_stats()
Returns the &quot;assumed&quot; density of individuals in 
a plot given whether min, max or mean is used</h2><span id='topic+get_ind_dens'></span>

<h3>Description</h3>

<p>Auxiliary function for get_delta_stats()
Returns the &quot;assumed&quot; density of individuals in 
a plot given whether min, max or mean is used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ind_dens(comm, density_stat)
</code></pre>

<hr>
<h2 id='get_inds'>Auxiliary function for get_delta_stats()
Returns a vector of abundances where individual-based rarefaction 
will be performed</h2><span id='topic+get_inds'></span>

<h3>Description</h3>

<p>Auxiliary function for get_delta_stats()
Returns a vector of abundances where individual-based rarefaction 
will be performed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_inds(N_max, inds = NULL, log_scale = FALSE)
</code></pre>

<hr>
<h2 id='get_mob_stats'>Calculate sample based and group based biodiversity statistics.</h2><span id='topic+get_mob_stats'></span>

<h3>Description</h3>

<p>Calculate sample based and group based biodiversity statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mob_stats(
  mob_in,
  group_var,
  ref_level = NULL,
  index = c("N", "S", "S_n", "S_PIE"),
  effort_samples = NULL,
  effort_min = 5,
  extrapolate = TRUE,
  return_NA = FALSE,
  rare_thres = 0.05,
  n_perm = 199,
  boot_groups = FALSE,
  conf_level = 0.95,
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mob_stats_+3A_mob_in">mob_in</code></td>
<td>
<p>an object of class mob_in created by make_mob_in()</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_group_var">group_var</code></td>
<td>
<p>String that specifies which field in <code>mob_in$env</code> the
data should be grouped by</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_ref_level">ref_level</code></td>
<td>
<p>String that defines the reference level of <code>group_var</code>
to which all other groups are compared with, defaults to <code>NULL</code>.
If <code>NULL</code> then the default contrasts of <code>group_var</code> are used.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_index">index</code></td>
<td>
<p>The calculated biodiversity indices. The options are
</p>

<ul>
<li> <p><code>N</code> ... Number of individuals (total abundance)
</p>
</li>
<li> <p><code>S</code> ... Number of species
</p>
</li>
<li> <p><code>S_n</code> ... Rarefied or extrapolated number of species for n individuals
</p>
</li>
<li> <p><code>S_asymp</code> ... Estimated asymptotic species richness
</p>
</li>
<li> <p><code>f_0</code> ... Estimated number of undetected species 
</p>
</li>
<li> <p><code>pct_rare</code> ... The percent of rare species as defined by <code>rare_thres</code>
</p>
</li>
<li> <p><code>PIE</code> ... Hurlbert's PIE (Probability of Interspecific Encounter)
</p>
</li>
<li> <p><code>S_PIE</code> ... Effective number of species based on PIE
</p>
</li></ul>

<p>If index is not specified then N, S, S_n, pct_rare, and S_PIE are computed
by default. See <em>Details</em> for additional information on the
biodiversity statistics.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_effort_samples">effort_samples</code></td>
<td>
<p>The standardized number of individuals used for the 
calculation of rarefied species richness at the alpha-scale. This can a be
single value or an integer vector. As default the minimum number of
individuals found across the samples is used, when this is not smaller than
<code>effort_min</code>.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_effort_min">effort_min</code></td>
<td>
<p>The minimum number of individuals considered for the 
calculation of rarefied richness (Default value of 5). Samples with less
individuals then <code>effort_min</code> are excluded from the analysis with a
warning. Accordingly, when <code>effort_samples</code> is set by the user it has
to be higher than <code>effort_min</code>.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Boolean which specifies if richness should be
extrapolated when <code>effort_samples</code> is larger than the number of
individuals using the chao1 method. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_return_na">return_NA</code></td>
<td>
<p>Boolean defaults to FALSE in which the rarefaction function
returns the observed S when <code>effort</code> is larger than the number of
individuals. If set to TRUE then NA is returned. Note that this argument
is only relevant when <code>extrapolate = FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_rare_thres">rare_thres</code></td>
<td>
<p>The threshold that determines how pct_rare is computed.
It can range from (0, 1] and defaults to 0.05 which specifies that any 
species with less than or equal to 5
considered rare. It can also be specified as &quot;N/S&quot; which results in using
average abundance as the threshold which McGill (2011) found to have the 
best small sample behavior.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_n_perm">n_perm</code></td>
<td>
<p>The number of permutations to use for testing for treatment
effects. Defaults to 199.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_boot_groups">boot_groups</code></td>
<td>
<p>Use bootstrap resampling within groups to derive
gamma-scale confidence intervals for all biodiversity indices. Default is
<code>FALSE</code>. See <em>Details</em> for information on the bootstrap approach.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_conf_level">conf_level</code></td>
<td>
<p>Confidence level used for the calculation of gamma-scale 
bootstrapped confidence intervals. Only used when <code>boot_groups =
TRUE</code>.</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
</p>
</td></tr>
<tr><td><code id="get_mob_stats_+3A_...">...</code></td>
<td>

<p>Optional arguments to <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>BIODIVERSITY INDICES</strong>
</p>
<p><strong>S_n: Rarefied species richness</strong> is the expected number of species, given a
defined number of sampled individuals (n) (Gotelli &amp; Colwell 2001). Rarefied
richness at the alpha-scale is calculated for the values provided in 
<code>effort_samples</code> as long as these values are not smaller than the 
user-defined minimum value <code>effort_min</code>. In this case the minimum value 
is used and samples with less individuals are discarded. When no values for
<code>effort_samples</code> are provided the observed minimum number of individuals
of the samples is used, which is the standard in rarefaction analysis
(Gotelli &amp; Colwell 2001). Because the number of individuals is expected to
scale linearly with sample area or effort, at the gamma-scale the number of
individuals for rarefaction is calculated as the minimum number of samples
within groups multiplied by <code>effort_samples</code>. For example, when there are 10
samples within each group, <code>effort_groups</code> equals <code>10 *
effort_samples</code>. If n is larger than the number of individuals in sample and
<code>extrapolate = TRUE</code> then the Chao1 (Chao 1984, Chao 1987) method is
used to extrapolate the rarefaction curve.
</p>
<p><strong>pct_rare: Percent of rare species</strong> Is the ratio of the number of rare
species to the number of observed species x 100 (McGill 2011). Species are 
considered rare in a particular sample if they have fewer individuals than 
<code>rare_thres * N</code> where <code>rare_thres</code> can be set by the user and 
<code>N</code> is the total number of individuals in the sample. The default value 
of <code>rare_thres</code> of 0.05 is arbitrary and was chosen because McGill 
(2011) found this metric of rarity performed well and was generally less 
correlated with other common metrics of biodiversity. Essentially this metric
attempt to estimate what proportion of the species in the same occur in the
tail of the species abundance distribution and is therefore sensitive to
presence of rare species.
</p>
<p><strong>S_asymp: Asymptotic species richness</strong> is the expected number of 
species given complete sampling and here it is calculated using the Chao1
estimator (Chao 1984, Chao 1987) see <code><a href="#topic+calc_chao1">calc_chao1</a></code>. Note: this metric
is typically highly correlated with S (McGill 2011).
</p>
<p><strong>f_0: Undetected species richness</strong> is the number of undetected species
or the number of species observed 0 times which is an indicator of the degree
of rarity in the community. If there is a greater rarity then f_0 is expected
to increase. This metric is calculated as <code>S_asymp - S</code>. This metric is less 
correlated with S than the raw <code>S_asymp</code> metric. 
</p>
<p><strong>PIE: Probability of intraspecific encounter</strong> represents the
probability that two randomly drawn individuals belong to the same species.
Here we use the definition of Hurlbert (1971), which considers sampling
without replacement. PIE is closely related to the well-known Simpson
diversity index, but the latter assumes sampling with replacement.
</p>
<p><strong>S_PIE: Effective number of species for PIE</strong> represents the effective
number of species derived from the PIE. It is calculated using the asymptotic
estimator for Hill numbers of diversity order 2 (Chao et al, 2014). S_PIE
represents the species richness of a hypothetical community with
equally-abundant species and infinitely many individuals corresponding to the
same value of PIE as the real community. An intuitive interpretation of S_PIE
is that it corresponds to the number of dominant (highly abundant) species in
the species pool.
</p>
<p>For species richness <code>S</code>, rarefied richness <code>S_n</code>, undetected
richness <code>f_0</code>, and the Effective Number of Species <code>S_PIE</code> we also
calculate beta-diversity using multiplicative partitioning (Whittaker 1972,
Jost 2007). That means for these indices we estimate beta-diversity as the
ratio of gamma-diversity (total diversity across all plots) divided by
alpha-diversity (i.e., average plot diversity).
</p>
<p><strong>PERMUTATION TESTS AND BOOTSTRAP</strong>
</p>
<p>For both the alpha and gamma scale analyses we summarize effect size in each
biodiversity index by computing <code>D_bar</code>: the average absolute difference
between the groups. At the alpha scale the indices are averaged first before
computing <code>D_bar</code>.
</p>
<p>We used permutation tests for testing differences of the biodiversity
statistics among the groups (Legendre &amp; Legendre 1998). At the alpha-scale,
one-way ANOVA (i.e. F-test) is implemented by shuffling treatment group
labels across samples. The test statistic for this test is the F-statistic
which is a pivotal statistic (Legendre &amp; Legendre 1998). At the gamma-scale
we carried out the permutation test by shuffling the treatment group labels
and using <code>D_bar</code> as the test statistic. We could not use the
F-statistic as the test statistic at the gamma scale because at this scale
there are no replicates and therefore the F-statistic is undefined.
</p>
<p>A bootstrap approach can be used to also test differences at the gamma-scale.
When <code>boot_groups = TRUE</code> instead of the gamma-scale permutation test,
there will be resampling of samples within groups to derive gamma-scale
confidence intervals for all biodiversity indices. The function output
includes lower and upper confidence bounds and the median of the bootstrap
samples. Please note that for the richness indices sampling with replacement
corresponds to rarefaction to ca. 2/3 of the individuals, because the same
samples occur several times in the resampled data sets.
</p>


<h3>Value</h3>

<p>A list of class <code>mob_stats</code> that contains alpha-scale and 
gamma-scale biodiversity statistics, as well as the p-values for
permutation tests at both scales.
</p>
<p>When <code>boot_groups = TRUE</code> there are no p-values at the gamma-scale.
Instead there is lower bound, median, and upper bound for each biodiversity
index derived from the bootstrap within groups.
</p>


<h3>Author(s)</h3>

<p>Felix May and Dan McGlinn
</p>


<h3>References</h3>

<p>Chiu, C.-H., Wang, Y.-T., Walther, B.A. &amp; Chao, A. (2014) An improved
nonparametric lower bound of species richness via a modified good-turing
frequency formula. Biometrics, 70, 671-682.
</p>
<p>Gotelli, N.J. &amp; Colwell, R.K. (2001) Quantifying biodiversity: procedures
and pitfalls in the measurement and comparison of species richness. Ecology
letters, 4, 379-391.
</p>
<p>Hurlbert, S.H. (1971) The Nonconcept of Species Diversity: A Critique and
Alternative Parameters. Ecology, 52, 577-586.
</p>
<p>Jost, L. (2006) Entropy and diversity. Oikos, 113, 363-375.
</p>
<p>Jost, L. (2007) Partitioning Diversity into Independent Alpha and Beta
Components. Ecology, 88, 2427-2439.
</p>
<p>Legendre, P. &amp; Legendre, L.F.J. (1998) Numerical Ecology, Volume 24, 2nd
Edition Elsevier, Amsterdam; Boston.
</p>
<p>McGill, B.J. (2011) Species abundance distributions. 105-122 in Biological 
Diversity: Frontiers in Measurement and Assessment. eds. A.E. Magurran
B.J. McGill.
</p>
<p>Whittaker, R.H. (1972) Evolution and Measurement of Species Diversity.
Taxon, 21, 213-251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a binary grouping variable (uninvaded or invaded)
data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, c('x', 'y'))
inv_stats = get_mob_stats(inv_mob_in, group_var = "group", ref_level = 'uninvaded',
                          n_perm = 19, effort_samples = c(5,10))
plot(inv_stats)


# parallel evaluation using the parallel package 
# run in parallel
library(parallel)
cl = makeCluster(2L)
clusterEvalQ(cl, library(mobr))
clusterExport(cl, 'inv_mob_in')
inv_mob_stats = get_mob_stats(inv_mob_in, 'group', ref_level = 'uninvaded',
                              n_perm=999, cl=cl)

stopCluster(cl)

</code></pre>

<hr>
<h2 id='get_null_comm'>Generate a null community matrix</h2><span id='topic+get_null_comm'></span>

<h3>Description</h3>

<p>Three  null models are implemented that randomize different components of
community structure while keeping other components constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_null_comm(comm, null_model, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_null_comm_+3A_comm">comm</code></td>
<td>
<p>community matrix of abundances with plots as rows and species columns.</p>
</td></tr>
<tr><td><code id="get_null_comm_+3A_null_model">null_model</code></td>
<td>
<p>a string which specifies which null model to use options
include: <code>'rand_SAD'</code>, <code>'rand_N'</code>, and <code>'rand_agg'</code>. See 
Details for description of each null model.</p>
</td></tr>
<tr><td><code id="get_null_comm_+3A_groups">groups</code></td>
<td>
<p>optional argument that is a vector of group ids which specify
which group each site is associated with. If is <code>NULL</code> then all rows
of the community matrix are assumed to be members of the same group</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements three different nested null models. They are considered
nested because at the core of each null model is the random sampling 
with replacement of the relative abundance distribution (RAD) to generate 
a random sample of a species abundance distribution (SAD). Here we describe
each null model:
</p>

<ul>
<li> <p><code>'rand_SAD'</code> ... A random SAD is generated using a sample with
replacement of individuals from the species pool proportional to their
observed relative abundance. This null model will produce an SAD that is
of a similar functional form to the observed SAD (Green and Plotkin 2007).
The total abundance of the random SAD is the same as the observed SAD but
overall species richness will be equal to or less than the observed SAD.
This algorithm ignores the <code>group</code> argument. This sampling algorithm
is also used in the two other null models <code>'rand_N'</code> and
<code>'rand_agg'</code>.
</p>
</li>
<li> <p><code>'rand_N'</code> ... The total number of individuals in a plot is
shuffled across all plots (within and between groups). Then for each plot
that many individuals are drawn randomly from the group specific relative
abundance distribution with replacement for each plot (i.e., using the
<code>'rand_SAD'</code> algorithm described above. This removes group
differences in the total number of individuals in a given plot, but
maintains group level differences in their SADs.
</p>
</li>
<li> <p><code>'rand_agg'</code> ... This null model nullifies the spatial
structure of individuals (i.e., their aggregation), but it is constrained
by the observed total number of individuals in each plot (in contrast to
the <code>'rand_N'</code> null model), and the group specific SAD (in contrast
to the <code>'rand_SAD'</code> null model). The other two null models also
nullify spatial structure. The <code>'rand_agg'</code> null model is identical
to the <code>'rand_N'</code> null model except that plot abundances are not 
shuffled. 
</p>
</li></ul>

<p>Replaces depreciated function 'permute_comm'
</p>


<h3>Value</h3>

<p>a site-by-species matrix
</p>


<h3>References</h3>

<p>Green, J. L., and J. B. Plotkin. 2007. A statistical theory for sampling 
species abundances. Ecology Letters 10:1037-1045.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S = 3
N = 20
nplots = 4
comm = matrix(rpois(S * nplots, 1), ncol = S, nrow = nplots)
comm
groups = rep(1:2, each=2)
groups
set.seed(1)
get_null_comm(comm, 'rand_SAD')
# null model 'rand_SAD' ignores groups argument
set.seed(1)
get_null_comm(comm, 'rand_SAD', groups)
set.seed(1)
get_null_comm(comm, 'rand_N')
# null model 'rand_N' does not ignore the groups argument
set.seed(1)
get_null_comm(comm, 'rand_N', groups)
# note that the 'rand_agg' null model is constrained by observed plot abundances
noagg = get_null_comm(comm, 'rand_agg', groups)
noagg
rowSums(comm)
rowSums(noagg)
</code></pre>

<hr>
<h2 id='get_overall_p'>Auxiliary function for effect_ functions
Compute an overall p-value for one factor in the discrete case
p-value is based on mean squared difference from zero summed across the scales
Method developed by Loosmore and Ford 2006 but algebraic simplifications 
used as developed by Baddeley et al. 2014 Ecological Archives M084-017-A1</h2><span id='topic+get_overall_p'></span>

<h3>Description</h3>

<p>Auxiliary function for effect_ functions
Compute an overall p-value for one factor in the discrete case
p-value is based on mean squared difference from zero summed across the scales
Method developed by Loosmore and Ford 2006 but algebraic simplifications 
used as developed by Baddeley et al. 2014 Ecological Archives M084-017-A1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_overall_p(effort, perm, value)
</code></pre>

<hr>
<h2 id='get_rand_sad'>Randomly sample of a relative abundance distribution (RAD)
to produce an expected species abundance distribution (SAD)</h2><span id='topic+get_rand_sad'></span>

<h3>Description</h3>

<p>Randomly sample of a relative abundance distribution (RAD)
to produce an expected species abundance distribution (SAD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rand_sad(rad, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rand_sad_+3A_rad">rad</code></td>
<td>
<p>the relative abundance of each species</p>
</td></tr>
<tr><td><code id="get_rand_sad_+3A_n">N</code></td>
<td>
<p>the total number of individuals sampled
</p>
<p>Randomly subsampling an RAD with replacement produces an SAD that is of a
similar functional form (Green and Plotkin 2007) but with overall species
richness equal to or less than the relative abundance distribution.
</p>
<p>Literature Cited:
Green, J. L., and J. B. Plotkin. 2007. A statistical theory
for sampling species abundances. Ecology Letters 10:1037-1045.</p>
</td></tr>
</table>

<hr>
<h2 id='groups_panel1'>Panel function for gamma-scale results</h2><span id='topic+groups_panel1'></span>

<h3>Description</h3>

<p>Panel function for gamma-scale results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups_panel1(
  group_dat,
  tests,
  col,
  ylab = "",
  main = expression(gamma * "-scale"),
  cex.axis = 1.2,
  ...
)
</code></pre>

<hr>
<h2 id='groups_panel2'>Panel function for gamma-scale results with confidence intervals</h2><span id='topic+groups_panel2'></span>

<h3>Description</h3>

<p>Panel function for gamma-scale results with confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups_panel2(
  group_dat,
  col,
  ylab = "",
  main = expression(gamma * "-scale"),
  cex.axis = 1.2,
  ...
)
</code></pre>

<hr>
<h2 id='ind_rare_perm'>Compute permutation derived individual-based rarefaction curves</h2><span id='topic+ind_rare_perm'></span>

<h3>Description</h3>

<p>An internal function that can provide an independent derivation of 
the individual rarefaction curve for the purposes of testing the 
performance of the function <code>rarefaction</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind_rare_perm(abu, n_perm = 100, n_indiv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind_rare_perm_+3A_abu">abu</code></td>
<td>
<p>a vector of species abundances</p>
</td></tr>
<tr><td><code id="ind_rare_perm_+3A_n_perm">n_perm</code></td>
<td>
<p>the number of permutations to average across, defaults to 100</p>
</td></tr>
<tr><td><code id="ind_rare_perm_+3A_n_indiv">n_indiv</code></td>
<td>
<p>the number of individuals to evaluate the rarefaction curve
at. The default behavior is to evaluate it on a log2 interval from 1 to N</p>
</td></tr>
</table>

<hr>
<h2 id='inv_comm'>Invasive plants dataset</h2><span id='topic+inv_comm'></span><span id='topic+inv_plot_attr'></span>

<h3>Description</h3>

<p>Herbaceous plant species counts sites invaded and uninvaded by
<em>Lonicera maackii</em> (Amur honeysuckle) which is an invasive shrub.
</p>


<h3>Details</h3>

<p><code>inv_comm</code> is a site-by-species matrix with individual counts.
</p>
<p><code>inv_plot_attr</code> is a data frame with corresponding site variables. The
column <code>group</code> specifies whether a site is &quot;invaded&quot; or &quot;uninvaded&quot;.
This variable is considered a &quot;treatment&quot; in the mob framework. The columns
<code>x</code> and <code>y</code> contain the spatial coordinates of the sites.
</p>
<p>The data were adapted from Powell et al (2013).
</p>


<h3>References</h3>

<p>Powell, K. I., Chase, J. M., &amp; Knight, T. M. (2013). Invasive
plants have scale-dependent effects on diversity by altering species-area
relationships. Science, 339: 316-318.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr)
</code></pre>

<hr>
<h2 id='kNCN_average'>Construct spatially constrained sample-based rarefaction (sSBR) curve using
the k-Nearest-Centroid-neighbor (k-NCN) algorithm</h2><span id='topic+kNCN_average'></span>

<h3>Description</h3>

<p>This function accumulates samples according their proximity to all previously
included samples (their centroid) as opposed to the proximity to the initial
focal sample. This ensures that included samples mutually close to each other
and not all over the place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kNCN_average(
  x,
  n = NULL,
  coords = NULL,
  repetitions = 1,
  no_pb = TRUE,
  latlong = FALSE,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kNCN_average_+3A_x">x</code></td>
<td>
<p>a mob_in object or a community site x species matrix</p>
</td></tr>
<tr><td><code id="kNCN_average_+3A_n">n</code></td>
<td>
<p>number of sites to include.</p>
</td></tr>
<tr><td><code id="kNCN_average_+3A_coords">coords</code></td>
<td>
<p>spatial coordinates of the samples. If x is a mob_in object,
the function uses its 'spat' table as coordinates.</p>
</td></tr>
<tr><td><code id="kNCN_average_+3A_repetitions">repetitions</code></td>
<td>
<p>Number of times to repeat the procedure. Useful in
situations where there are many ties in the distance matrix.</p>
</td></tr>
<tr><td><code id="kNCN_average_+3A_no_pb">no_pb</code></td>
<td>
<p>binary, if TRUE then a progress bar is not printed, defaults to
TRUE</p>
</td></tr>
<tr><td><code id="kNCN_average_+3A_latlong">latlong</code></td>
<td>
<p>if longitude latitudes are supplied</p>
</td></tr>
<tr><td><code id="kNCN_average_+3A_cl">cl</code></td>
<td>

<p>A cluster object created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>,
or an integer to indicate number of child-processes
(integer values are ignored on Windows) for parallel evaluations
(see Details on performance).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally the function constructs one curve per sample whereby each sample
serves as the initial sample repetition times. Finally, the average curve is
returned.
</p>


<h3>Value</h3>

<p>a numeric vector of estimated species richness
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
kNCN_average(inv_mob_in, n = 5)

# parallel evaluation using the parallel package 
# run in parallel
library(parallel)
cl = makeCluster(2L)
clusterEvalQ(cl, library(mobr))
clusterExport(cl, 'inv_mob_in')
S_kNCN = kNCN_average(inv_mob_in, cl=cl)

stopCluster(cl)

</code></pre>

<hr>
<h2 id='make_mob_in'>Create the 'mob_in' object.</h2><span id='topic+make_mob_in'></span>

<h3>Description</h3>

<p>The 'mob_in' object will be passed on for analyses of biodiversity across
scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mob_in(
  comm,
  plot_attr,
  coord_names = NULL,
  binary = FALSE,
  latlong = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mob_in_+3A_comm">comm</code></td>
<td>
<p>community matrix in which rows are samples (e.g., plots) and
columns are species.</p>
</td></tr>
<tr><td><code id="make_mob_in_+3A_plot_attr">plot_attr</code></td>
<td>
<p>matrix which includes the environmental attributes and
spatial coordinates of the plots. Environmental attributes are mandatory,
while spatial coordinates are optional.</p>
</td></tr>
<tr><td><code id="make_mob_in_+3A_coord_names">coord_names</code></td>
<td>
<p>character vector with the names of the columns of
<code>plot_attr</code> that specify the coordinates of the samples. Defaults to
NULL (no coordinates). When providing coordinate names, the order the names
are provided matters when working with latitude-longitude coordinates
(i.e., argument <code>latlong = TRUE</code>, and it is expected that the column
specifying the x-coordinate or the longitude is provided first, y-coordinate
or latitude provided second. To provide coordinate names use the following
syntax: <code>coord_names = c('longitude_col_name','latitude_col_name')</code></p>
</td></tr>
<tr><td><code id="make_mob_in_+3A_binary">binary</code></td>
<td>
<p>Boolean, defaults to FALSE. Whether the plot by species matrix
&quot;comm&quot; is in abundances or presence/absence.</p>
</td></tr>
<tr><td><code id="make_mob_in_+3A_latlong">latlong</code></td>
<td>
<p>Boolean, defaults to FALSE. Whether the coordinates are
latitude-longitudes. If TRUE, distance calculations by downstream functions
are based upon great circle distances rather than Euclidean distances. Note
latitude-longitudes should be in decimal degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;mob_in&quot; object with four attributes. &quot;comm&quot; is the plot by species
matrix. &quot;env&quot; is the environmental attribute matrix, without the spatial
coordinates. &quot;spat&quot; contains the spatial coordinates (1-D or 2-D). &quot;tests&quot;
specifies whether each of the three tests in the biodiversity analyses is
allowed by data.
</p>


<h3>Author(s)</h3>

<p>Dan McGlinn and Xiao Xiao
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(inv_comm)
 data(inv_plot_attr)
 inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
</code></pre>

<hr>
<h2 id='mobr'>Measurement of Biodiversity in R</h2><span id='topic+mobr'></span>

<h3>Description</h3>

<p>The primary aim of this package is to provide ecologist's tools
to examine changes in biodiversity across spatial scales.  Additionally, the
package provides a method to examine how a factor mediates species richness
via its effects on different aspects of community structure: total
abundance, species commonness, and spatial aggregation of conspecifics.
</p>

<hr>
<h2 id='mod_sum'>Extract coefficients and metrics of fit from model</h2><span id='topic+mod_sum'></span>

<h3>Description</h3>

<p>Extract coefficients and metrics of fit from model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_sum(x, stats = c("betas", "r", "r2", "r2adj", "f", "p"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod_sum_+3A_x">x</code></td>
<td>
<p>a fitted model object</p>
</td></tr>
<tr><td><code id="mod_sum_+3A_stats">stats</code></td>
<td>
<p>the statistics to output</p>
</td></tr>
</table>

<hr>
<h2 id='plot_abu'>Plot distributions of species abundance</h2><span id='topic+plot_abu'></span>

<h3>Description</h3>

<p>Plot distributions of species abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_abu(
  mob_in,
  group_var,
  ref_level = NULL,
  type = c("sad", "rad"),
  pooled = FALSE,
  col = NULL,
  lwd = 3,
  log = "",
  leg_loc = "topleft"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_abu_+3A_mob_in">mob_in</code></td>
<td>
<p>a 'mob_in' class object produced by 'make_mob_in'</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_group_var">group_var</code></td>
<td>
<p>String that specifies which field in <code>mob_in$env</code> the
data should be grouped by</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_ref_level">ref_level</code></td>
<td>
<p>String that defines the reference level of <code>group_var</code>
to which all other groups are compared with, defaults to <code>NULL</code>.
If <code>NULL</code> then the default contrasts of <code>group_var</code> are used.</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_type">type</code></td>
<td>
<p>either 'sad' or 'rad' for species abundance vs rank abundance
distribution</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_pooled">pooled</code></td>
<td>
<p>Boolean defaults to FALSE which specifies that abundances should
not be pooled at the group level, TRUE specifies that they should be pooled</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_col">col</code></td>
<td>
<p>optional vector of colors.</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_lwd">lwd</code></td>
<td>
<p>a number which specifies the width of the lines</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_log">log</code></td>
<td>
<p>a string that specifies if any axes are to be log transformed, 
options include 'x', 'y' or 'xy' in which either the x-axis, y-axis, or
both axes are log transformed respectively</p>
</td></tr>
<tr><td><code id="plot_abu_+3A_leg_loc">leg_loc</code></td>
<td>
<p>a string that specifies the location of the legend, 
options include: 'lowerleft', 'topleft', 'loweright','topright'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
plot_abu(inv_mob_in, 'group', 'uninvaded', type='sad', pooled=FALSE, log='x')
plot_abu(inv_mob_in, 'group', 'uninvaded', type='rad', pooled=TRUE, log='x')
</code></pre>

<hr>
<h2 id='plot_N'>Plot the relationship between the number of plots and the number of
individuals</h2><span id='topic+plot_N'></span>

<h3>Description</h3>

<p>The MoB methods assume a linear relationship between the number of 
plots and the number of individuals. This function provides a means of 
verifying the validity of this assumption
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_N(comm, n_perm = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_N_+3A_comm">comm</code></td>
<td>
<p>community matrix with sites as rows and species as columns</p>
</td></tr>
<tr><td><code id="plot_N_+3A_n_perm">n_perm</code></td>
<td>
<p>number of permutations to average across, defaults to 1000</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dan McGlinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
plot_N(inv_comm)
</code></pre>

<hr>
<h2 id='plot_rarefaction'>Plot rarefaction curves for each treatment group</h2><span id='topic+plot_rarefaction'></span>

<h3>Description</h3>

<p>Plot rarefaction curves for each treatment group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rarefaction(
  mob_in,
  group_var,
  ref_level = NULL,
  method,
  dens_ratio = 1,
  pooled = TRUE,
  spat_algo = NULL,
  col = NULL,
  lwd = 3,
  log = "",
  leg_loc = "topleft",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rarefaction_+3A_mob_in">mob_in</code></td>
<td>
<p>an object of class mob_in created by make_mob_in()</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_group_var">group_var</code></td>
<td>
<p>String that specifies which field in <code>mob_in$env</code> the
data should be grouped by</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_ref_level">ref_level</code></td>
<td>
<p>String that defines the reference level of <code>group_var</code>
to which all other groups are compared with, defaults to <code>NULL</code>.
If <code>NULL</code> then the default contrasts of <code>group_var</code> are used.</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_method">method</code></td>
<td>
<p>a character string that specifies the method of rarefaction 
curve construction it can be one of the following: 
</p>

<ul>
<li> <p><code>'IBR'</code> ... individual-based rarefaction in which species
are accumulated by randomly sampling individuals
</p>
</li>
<li> <p><code>'SBR'</code> ... sample-based rarefaction in which species are 
accumulated by randomly sampling samples (i.e., plots). Note that within plot spatial 
aggregation is maintained with this approach. Although this curve
is implemented here, it is not used in the current version of the MoB framework
</p>
</li>
<li> <p><code>'nsSBR'</code> ... non-spatial, sampled-based rarefaction in which
species are accumulated by randomly sampling samples that represent a 
spatially random sample of individuals (i.e., no with-in plot spatial 
aggregation). The argument <code>dens_ratio</code> must also be set otherwise 
this sampling results in a curve identical to the IBR (see Details). 
</p>
</li>
<li> <p><code>'sSBR'</code> ... spatial sample-based rarefaction in which species 
are accumulated by including spatially proximate samples first. 
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_dens_ratio">dens_ratio</code></td>
<td>
<p>the ratio of individual density between a reference group
and the community data (i.e., x) under consideration. This argument is
used to rescale the rarefaction curve when estimating the effect of
individual density on group differences in richness.</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_pooled">pooled</code></td>
<td>
<p>Boolean specifying if samples should be pooled at the group
level or not. Defaults to TRUE. This argument only applies when
the individual based rarefaction is used (i.e., <code>method = 'indiv'</code>)</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_spat_algo">spat_algo</code></td>
<td>
<p>character string that can be either: <code>'kNN'</code> or <code>'kNCN'</code>
for k-nearest neighbor and k-nearest centroid neighbor sampling 
respectively. It defaults to k-nearest neighbor which is a 
more computationally efficient algorithm that closely approximates the 
potentially more correct k-NCN algo (see Details).</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_col">col</code></td>
<td>
<p>optional vector of colors.</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_lwd">lwd</code></td>
<td>
<p>a number which specifies the width of the lines</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_log">log</code></td>
<td>
<p>a string that specifies if any axes are to be log transformed, 
options include 'x', 'y' or 'xy' in which either the x-axis, y-axis, or
both axes are log transformed respectively</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_leg_loc">leg_loc</code></td>
<td>
<p>a string that specifies the location of the legend, 
options include: 'lowerleft', 'topleft', 'loweright','topright'</p>
</td></tr>
<tr><td><code id="plot_rarefaction_+3A_...">...</code></td>
<td>
<p>other arguments to provide to <code><a href="#topic+rarefaction">rarefaction</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
# random individual based rarefaction curves
plot_rarefaction(inv_mob_in, 'group', 'uninvaded', 'IBR',
                 pooled=TRUE, leg_loc='bottomright')
plot_rarefaction(inv_mob_in, 'group', 'uninvaded', 'IBR',
                 pooled=FALSE, log='x')
# random sample based rarefaction curves 
plot_rarefaction(inv_mob_in, 'group', 'uninvaded', 'SBR', log='xy')
# spatial sample based rarefaction curves 
plot_rarefaction(inv_mob_in, 'group', 'uninvaded', 'sSBR', log='xy')
</code></pre>

<hr>
<h2 id='plot.mob_out'>Plot the multiscale MoB analysis output generated by <code>get_delta_stats</code>.</h2><span id='topic+plot.mob_out'></span>

<h3>Description</h3>

<p>Plot the multiscale MoB analysis output generated by <code>get_delta_stats</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mob_out'
plot(
  x,
  stat = "b1",
  log2 = "",
  scale_by = NULL,
  display = c("S ~ effort", "effect ~ grad", "stat ~ effort"),
  eff_sub_effort = TRUE,
  eff_log_base = 2,
  eff_disp_pts = TRUE,
  eff_disp_smooth = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mob_out_+3A_x">x</code></td>
<td>
<p>a mob_out class object</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_stat">stat</code></td>
<td>
<p>a character string that specifies what statistic should be used
in the effect size plots. Options include: <code>c('b0', 'b1', 'r', 'r2',
'r2adj', 'f')</code> for the beta-coefficients, person correlation coefficient,
r-squared, adjusted  r-squared, and F-statistic respectively. If the
explanatory variable is a factor then <code>'b1'</code> is the only reasonable
option. The default is set to the regression slope <code>'b1'</code> because this
appears to have the strongest statistical power.</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_log2">log2</code></td>
<td>
<p>a character string specifying if the x- or y-axis should be
rescale by log base 2. Only applies when <code>display == 'S ~ effort' | 'S
~ effort'</code>. Options include: <code>c('', 'x', 'y', 'xy')</code> for  no
rescaling, x-axis, y-axis, and both x and y-axes respectively. Default is
set to no rescaling.</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_scale_by">scale_by</code></td>
<td>
<p>a character string specifying if sampling effort should be
rescaled. Options include: <code>NULL</code>, <code>'indiv'</code>, and <code>'plot'</code>
for no rescaling, rescaling to number of individuals, and rescaling
to number of plots respectively. The rescaling is carried out using
<code>mob_out$density_stat</code>.</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_display">display</code></td>
<td>
<p>a string that specifies what graphical panels to display. 
Options include:
</p>

<ul>
<li> <p><code>S ~ expl</code> ... plot of S versus the explanatory variable
</p>
</li>
<li> <p><code>S ~ effort</code> ... plot of S versus sampling effort (i.e., a
rarefaction curve) 
</p>
</li>
<li> <p><code>effect ~ expl</code> ... plot of agg., N, and SAD effect size
versus explanatory variable
</p>
</li>
<li> <p><code>stat ~ effort</code> ... plot of summary statistic versus sampling
effort
</p>
</li></ul>

<p>Defaults to <code>'S ~ effort'</code>, <code>'effect ~ expl'</code>, and <code>'stat ~ effort'</code>.</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_eff_sub_effort">eff_sub_effort</code></td>
<td>
<p>Boolean which determines if only a subset of efforts
will be considered in the plot of effect size (i.e., when
<code>display = 'effect ~ expl'</code>. Defaults to TRUE to declutter the plots.</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_eff_log_base">eff_log_base</code></td>
<td>
<p>a positive real number that determines the base of the 
logarithm that efforts were be distributed across, the larger this number
the fewer efforts will be displayed.</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_eff_disp_pts">eff_disp_pts</code></td>
<td>
<p>Boolean to display the raw effect points, defaults to TRUE</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_eff_disp_smooth">eff_disp_smooth</code></td>
<td>
<p>Boolean to display the regressions used to summarize
the linear effect of the explanatory variable on the effect sizes, defaults
to FALSE</p>
</td></tr>
<tr><td><code id="plot.mob_out_+3A_...">...</code></td>
<td>
<p>parameters passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the effect of the SAD, the number of individuals, and spatial
aggregation on the difference in species richness
</p>


<h3>Author(s)</h3>

<p>Dan McGlinn and Xiao Xiao
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
inv_mob_out = get_delta_stats(inv_mob_in, 'group', ref_level='uninvaded',
                              type='discrete', log_scale=TRUE, n_perm=4)
plot(inv_mob_out, 'b1') 
 
plot(inv_mob_out, 'b1', scale_by = 'indiv')

</code></pre>

<hr>
<h2 id='plot.mob_stats'>Plot alpha- and gamma-scale biodiversity statistics for a MoB analysis</h2><span id='topic+plot.mob_stats'></span>

<h3>Description</h3>

<p>Plots a <code>mob_stats</code> object which is produced by the 
function <code>get_mob_stats</code>. The p-value for each statistic
is displayed in the plot title if applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mob_stats'
plot(
  x,
  index = NULL,
  multi_panel = FALSE,
  col = c("#FFB3B5", "#78D3EC", "#6BDABD", "#C5C0FE", "#E2C288", "#F7B0E6", "#AAD28C"),
  cex.axis = 1.2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mob_stats_+3A_x">x</code></td>
<td>
<p>a <code>mob_stats</code> object that has the samples and 
treatment level statistics</p>
</td></tr>
<tr><td><code id="plot.mob_stats_+3A_index">index</code></td>
<td>
<p>The biodiversity statistics that should be plotted.
See <code><a href="#topic+get_mob_stats">get_mob_stats</a></code> for information on the indices. By default there
is one figure for each index, with panels for alpha- and gamma-scale results
as well as for beta-diversity when applicable.</p>
</td></tr>
<tr><td><code id="plot.mob_stats_+3A_multi_panel">multi_panel</code></td>
<td>
<p>A logical variable. If <code>multi_panel = TRUE</code> then a 
multipanel plot is produced, which shows observed, rarefied, and asymptotic 
species richness and S_PIE at the alpha- and gamma-scale.
This set of variables conveys a comprehensive picture of the underlying 
biodiversity changes.</p>
</td></tr>
<tr><td><code id="plot.mob_stats_+3A_col">col</code></td>
<td>
<p>a vector of colors for the groups, set to NA if no color is
preferred</p>
</td></tr>
<tr><td><code id="plot.mob_stats_+3A_cex.axis">cex.axis</code></td>
<td>
<p>The magnification to be used for axis annotation relative to
the current setting of cex. Defaults to 1.2.</p>
</td></tr>
<tr><td><code id="plot.mob_stats_+3A_...">...</code></td>
<td>
<p>additional arguments to provide to <code>boxplot</code>, <code>points</code>,
and confidence interval functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user may specify which results to plot or simply to plot 
all the results.
</p>


<h3>Author(s)</h3>

<p>Felix May, Xiao Xiao, and Dan McGlinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr)
# without bootstrap CI for gamma-scale
inv_stats = get_mob_stats(inv_mob_in, group_var = "group", n_perm = 20)
plot(inv_stats) 
# with bootstrap CI for gamma-scale
inv_stats_boot = get_mob_stats(inv_mob_in, group_var = "group", n_perm = 20,
                               boot_groups=TRUE)
plot(inv_stats_boot)
</code></pre>

<hr>
<h2 id='plotStacked'>Stacked plot by Marc Taylor (@marchtaylor on gitHub)</h2><span id='topic+plotStacked'></span>

<h3>Description</h3>

<p><code>plotStacked</code> makes a stacked plot where each <code>y</code> 
series is plotted on top of each other using filled polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStacked(
  x,
  y,
  order.method = "as.is",
  ylab = "",
  xlab = "",
  border = NULL,
  lwd = 1,
  col = rainbow(length(y[1, ])),
  ylim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStacked_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_y">y</code></td>
<td>
<p>A matrix of data series (columns) corresponding to x</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_order.method">order.method</code></td>
<td>
<p>Method of ordering y plotting order. One of the 
following: <code>c("as.is", "max", "first")</code>. <code>"as.is"</code> - plot in 
order of y column. <code>"max"</code> - plot in order of when each y series 
reaches maximum value. <code>"first"</code> - plot in order of when each y series
first value &gt; 0.</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_ylab">ylab</code></td>
<td>
<p>y-axis labels</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_xlab">xlab</code></td>
<td>
<p>x-axis labels</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_border">border</code></td>
<td>
<p>Border colors for polygons corresponding to y columns (will recycle) (see ?polygon for details)</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_lwd">lwd</code></td>
<td>
<p>Border line width for polygons corresponding to y columns (will recycle)</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_col">col</code></td>
<td>
<p>Fill colors for polygons corresponding to y columns (will recycle).</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits. If <code>ylim=NULL</code>, defaults to <code>c(0, 1.2*max(apply(y,1,sum)</code>.</p>
</td></tr>
<tr><td><code id="plotStacked_+3A_...">...</code></td>
<td>
<p>Other plot arguments</p>
</td></tr>
</table>

<hr>
<h2 id='print.mob_in'>Print a shortened version of the mob_in object</h2><span id='topic+print.mob_in'></span>

<h3>Description</h3>

<p>Print a shortened version of the mob_in object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mob_in'
print(x, nrows = 6, nsp = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mob_in_+3A_x">x</code></td>
<td>
<p>a mob_in class object</p>
</td></tr>
<tr><td><code id="print.mob_in_+3A_nrows">nrows</code></td>
<td>
<p>the number of rows of each matrix to print</p>
</td></tr>
<tr><td><code id="print.mob_in_+3A_nsp">nsp</code></td>
<td>
<p>the number of species columns to print</p>
</td></tr>
<tr><td><code id="print.mob_in_+3A_...">...</code></td>
<td>
<p>parameters passed to other functions</p>
</td></tr>
</table>

<hr>
<h2 id='rarefaction'>Rarefied Species Richness</h2><span id='topic+rarefaction'></span>

<h3>Description</h3>

<p>The expected number of species given a particular number of individuals or
samples under random and spatially explicit nearest neighbor sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rarefaction(
  x,
  method,
  effort = NULL,
  coords = NULL,
  latlong = NULL,
  dens_ratio = 1,
  extrapolate = FALSE,
  return_NA = FALSE,
  quiet_mode = FALSE,
  spat_algo = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rarefaction_+3A_x">x</code></td>
<td>
<p>can either be a: 1) mob_in object, 2) community matrix-like
object in which rows represent plots and columns represent species, or 3)
a vector which contains the abundance of each species.</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_method">method</code></td>
<td>
<p>a character string that specifies the method of rarefaction 
curve construction it can be one of the following: 
</p>

<ul>
<li> <p><code>'IBR'</code> ... individual-based rarefaction in which species
are accumulated by randomly sampling individuals
</p>
</li>
<li> <p><code>'SBR'</code> ... sample-based rarefaction in which species are 
accumulated by randomly sampling samples (i.e., plots). Note that within plot spatial 
aggregation is maintained with this approach. Although this curve
is implemented here, it is not used in the current version of the MoB framework
</p>
</li>
<li> <p><code>'nsSBR'</code> ... non-spatial, sampled-based rarefaction in which
species are accumulated by randomly sampling samples that represent a 
spatially random sample of individuals (i.e., no with-in plot spatial 
aggregation). The argument <code>dens_ratio</code> must also be set otherwise 
this sampling results in a curve identical to the IBR (see Details). 
</p>
</li>
<li> <p><code>'sSBR'</code> ... spatial sample-based rarefaction in which species 
are accumulated by including spatially proximate samples first. 
</p>
</li></ul>
</td></tr>
<tr><td><code id="rarefaction_+3A_effort">effort</code></td>
<td>
<p>optional argument to specify what number of individuals or 
number of samples depending on 'method' to compute rarefied richness as. If
not specified all possible values from 1 to the maximum sampling effort are
used</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_coords">coords</code></td>
<td>
<p>an optional matrix of geographic coordinates of the samples.
Only required when using the spatial rarefaction method and this information
is not already supplied by <code>x</code>. The first column should specify 
the x-coordinate (e.g., longitude) and the second coordinate should 
specify the y-coordinate (e.g., latitude)</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_latlong">latlong</code></td>
<td>
<p>Boolean if coordinates are latitude-longitude decimal degrees</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_dens_ratio">dens_ratio</code></td>
<td>
<p>the ratio of individual density between a reference group
and the community data (i.e., x) under consideration. This argument is
used to rescale the rarefaction curve when estimating the effect of
individual density on group differences in richness.</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Boolean which specifies if richness should be extrapolated
when effort is larger than the number of individuals using the chao1 method.
Defaults to FALSE in which case it returns observed richness. Extrapolation
is only implemented for individual-based rarefaction 
(i.e., <code>method = 'indiv'</code>)</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_return_na">return_NA</code></td>
<td>
<p>Boolean defaults to FALSE in which the function returns the
observed S when <code>effort</code> is larger than the number of individuals or
number of samples (depending on the method of rarefaction). If set to TRUE
then NA is returned. Note that this argument is only relevant when
<code>extrapolate = FALSE</code>.</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_quiet_mode">quiet_mode</code></td>
<td>
<p>Boolean defaults to FALSE, if TRUE then warnings and other
non-error messages are suppressed.</p>
</td></tr>
<tr><td><code id="rarefaction_+3A_spat_algo">spat_algo</code></td>
<td>
<p>character string that can be either: <code>'kNN'</code> or <code>'kNCN'</code>
for k-nearest neighbor and k-nearest centroid neighbor sampling 
respectively. It defaults to k-nearest neighbor which is a 
more computationally efficient algorithm that closely approximates the 
potentially more correct k-NCN algo (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analytical formulas of Cayuela et al. (2015) are used to compute
the random sampling expectation for the individual and sampled based
rarefaction methods. The spatially constrained rarefaction curve (Chiarucci
et al. 2009) also known as the sample-based accumulation curve (Gotelli and
Colwell 2001) can be computed in one of two ways which is determined by the
argument <code>spat_algo</code>. In the kNN approach each plot is accumulated by
the order of their spatial proximity to the original focal cell. If plots
have the same distance from the focal plot then one is chosen randomly to
be sampled first. In the kNCN approach, a new centroid is computed after
each plot is accumulated, then distances are recomputed from that new
centroid to all other plots and the next nearest is sampled. The kNN is
faster because the distance matrix only needs to be computed once, but the
sampling of kNCN which simultaneously minimizes spatial distance and extent
is more similar to an actual person searching a field for species. For both
kNN and kNCN, each plot in the community matrix is treated as a starting
point and then the mean of these n possible accumulation curves is
computed.
</p>
<p>For individual-based rarefaction if effort is greater than the number of
individuals and <code>extrapolate = TRUE</code> then the Chao1 method is used 
(Chao 1984, 1987). The code used to perform the extrapolation was ported
from <code>iNext::D0.hat</code> found at <a href="https://github.com/JohnsonHsieh/iNEXT">https://github.com/JohnsonHsieh/iNEXT</a>. 
T. C. Hsieh, K. H. Ma and Anne Chao are the original authors of the
<code>iNEXT</code> package. 
</p>
<p>If effort is greater than sample size and <code>extrapolate = FALSE</code> then the 
observed number of species is returned.
</p>


<h3>Value</h3>

<p>A vector of rarefied species richness values
</p>


<h3>Author(s)</h3>

<p>Dan McGlinn and Xiao Xiao
</p>


<h3>References</h3>

<p>Cayuela, L., N.J. Gotelli, &amp; R.K. Colwell (2015) Ecological and 
biogeographic null hypotheses for comparing rarefaction curves. Ecological
Monographs, 85, 437-454. Appendix A: 
http://esapubs.org/archive/mono/M085/017/appendix-A.php
</p>
<p>Chao, A. (1984) Nonparametric estimation of the number of classes in a
population. Scandinavian Journal of Statistics, 11, 265-270.
</p>
<p>Chao, A. (1987) Estimating the population size for capture-recapture data
with unequal catchability. Biometrics, 43, 783-791.
</p>
<p>Chiarucci, A., G. Bacaro, D. Rocchini, C. Ricotta, M. Palmer, &amp; S. Scheiner 
(2009) Spatially constrained rarefaction: incorporating the autocorrelated
structure of biological communities into sample-based rarefaction. Community
Ecology, 10, 209-214.
</p>
<p>Gotelli, N.J. &amp; Colwell, R.K. (2001) Quantifying biodiversity: procedures
and pitfalls in the measurement and comparison of species richness. Ecology
Letters, 4, 379-391.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(inv_comm)
data(inv_plot_attr)
sad = colSums(inv_comm)
inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
# rarefaction can be performed on different data inputs
# all three give same answer
# 1) the raw community site-by-species matrix
rarefaction(inv_comm, method='IBR', effort=1:10)
# 2) the SAD of the community
rarefaction(inv_comm, method='IBR', effort=1:10)
# 3) a mob_in class object
# rescaling of individual based rarefaction 
# when the density ratio is 1 the richness values are 
# identical to unscale rarefaction
rarefaction(inv_comm, method='IBR', effort=1:10, dens_ratio=1)
# however the curve is either shrunk when density is higher than 
# the reference value (i.e., dens_ratio &lt; 1)
rarefaction(inv_comm, method='IBR', effort=1:10, dens_ratio=0.5)
# the curve is stretched when density is lower than the 
# reference value (i.e., dens_ratio &gt; 1)
rarefaction(inv_comm, method='IBR', effort=1:10, dens_ratio=1.5)
# sample based rarefaction under random sampling
rarefaction(inv_comm, method='SBR')
 
# sampled based rarefaction under spatially explicit nearest neighbor sampling
rarefaction(inv_comm, method='sSBR', coords=inv_plot_attr[ , c('x','y')],
            latlong=FALSE)
# the syntax is simpler if supplying a mob_in object
rarefaction(inv_mob_in, method='sSBR', spat_algo = 'kNCN')
rarefaction(inv_mob_in, method='sSBR', spat_algo = 'kNN')

</code></pre>

<hr>
<h2 id='samples_panel1'>Panel function for alpha-scale results</h2><span id='topic+samples_panel1'></span>

<h3>Description</h3>

<p>Panel function for alpha-scale results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samples_panel1(
  sample_dat,
  samples_tests,
  col,
  ylab = "",
  main = expression(alpha * "-scale"),
  cex.axis = 1.2,
  ...
)
</code></pre>

<hr>
<h2 id='sphere_dist'>Internal function for distance matrix assuming inputs are longitude and
latitudes on a spherical Earth.</h2><span id='topic+sphere_dist'></span>

<h3>Description</h3>

<p>This calculation uses the Haversine method of computing great
circle distances in kilometers on a spherical Earth (r = 6378.137 km). This
code was taken from fields::rdist.earth by Doug Nychka, John Paige, Florian
Gerber.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere_dist(coords, r = 6378.137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_dist_+3A_coords">coords</code></td>
<td>
<p>a matrix with longitudes and latitudes in decimal degrees. The
longitudes should be provided in the first column (they are the
x-coordinate) and the latitudes should be provided in the second column
(they are the y-coordinate).</p>
</td></tr>
<tr><td><code id="sphere_dist_+3A_r">r</code></td>
<td>
<p>the radius of the Earth, defaults to 6378.137 km</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance matrix between all pairwise coordinates.
</p>

<hr>
<h2 id='subset.mob_in'>Subset the rows of the mob data input object</h2><span id='topic+subset.mob_in'></span>

<h3>Description</h3>

<p>This function subsets the rows of comm, env, and spat attributes of the
mob_in object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mob_in'
subset(x, subset, type = "string", drop_levels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.mob_in_+3A_x">x</code></td>
<td>
<p>an object of class mob_in created by <code><a href="#topic+make_mob_in">make_mob_in</a></code></p>
</td></tr>
<tr><td><code id="subset.mob_in_+3A_subset">subset</code></td>
<td>
<p>expression indicating elements or rows to keep: missing values are taken as false.</p>
</td></tr>
<tr><td><code id="subset.mob_in_+3A_type">type</code></td>
<td>
<p>specifies the type of object the argument <code>subset</code>
specifies, may be: <code>string</code>, <code>integer</code>, or <code>logical</code>,
defaults to <code>string</code></p>
</td></tr>
<tr><td><code id="subset.mob_in_+3A_drop_levels">drop_levels</code></td>
<td>
<p>Boolean if TRUE unused levels are removed from factors in
mob_in$env</p>
</td></tr>
<tr><td><code id="subset.mob_in_+3A_...">...</code></td>
<td>
<p>parameters passed to other functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> data(inv_comm)
 data(inv_plot_attr)
 inv_mob_in = make_mob_in(inv_comm, inv_plot_attr, coord_names = c('x', 'y'))
 subset(inv_mob_in, group == 'invaded')
 subset(inv_mob_in, 1:4, type='integer')
 subset(inv_mob_in, 1:4, type='integer', drop_levels=TRUE)
 sub_log = c(TRUE, FALSE, TRUE, rep(FALSE, nrow(inv_mob_in$comm) - 3))
 subset(inv_mob_in, sub_log, type='logical')
</code></pre>

<hr>
<h2 id='tank_comm'>Cattle tank data set</h2><span id='topic+tank_comm'></span><span id='topic+tank_plot_attr'></span>

<h3>Description</h3>

<p>Species counts of aquatic macro-invertebrates from experimental
freshwater ponds (&quot;cattle tanks&quot;) with two different nutrient treatments.
</p>


<h3>Details</h3>

<p><code>tank_comm</code> is a site-by-species matrix with individual counts.
</p>
<p><code>tank_plot_attr</code> is a data frame with corresponding site variables. The
column <code>group</code> specifies whether a pond has received a &quot;high&quot; or &quot;low&quot;
nutrient treatment. The columns <code>x</code> and <code>y</code> contain the spatial
coordinates of the sites.
</p>
<p>The data were adapted from Chase (2010).
</p>


<h3>References</h3>

<p>Chase, J. M. (2010). Stochastic community assembly causes higher
biodiversity in more productive environments. Science. 328:1388-1391.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tank_comm)
data(tank_plot_attr)
tank_mob_in = make_mob_in(tank_comm, tank_plot_attr)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
