<!DOCTYPE html><html><head><title>Help for package rrcov3way</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rrcov3way}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amino'><p>Amino acids fluorescence data.</p></a></li>
<li><a href='#Arno'>
<p>Chemical composition of water in the main stream of Arno river</p></a></li>
<li><a href='#congruence'><p>Coefficient of factor congruence (phi)</p></a></li>
<li><a href='#cp_als'><p>Alternating Least Squares (ALS) for Candecomp/Parafac (CP)</p></a></li>
<li><a href='#cp_atld'><p>Alternating Trilinear Decomposition (ATLD) for Candecomp/Parafac (CP)</p></a></li>
<li><a href='#cp_gen'><p>Generate PARAFAC data sets, optionally with outliers</p></a></li>
<li><a href='#cp_int2'><p>ATLD-ALS algorithm for Candecomp/Parafac (CP)</p></a></li>
<li><a href='#do3Postprocess'>
<p>Postprocessing: renormalization, reflection and reordering; access to some of the components of the model.</p></a></li>
<li><a href='#do3Rotate'><p>Varimax Rotation for Tucker3 models</p></a></li>
<li><a href='#do3Scale'>
<p>Centering and scaling</p></a></li>
<li><a href='#dorrit'><p>Dorrit fluorescence data.</p></a></li>
<li><a href='#elind'>
<p>OECD Electronics Industries Data</p></a></li>
<li><a href='#girls'><p>Sempe girls' growth curves data</p></a></li>
<li><a href='#Kojima'>
<p>Parental behaviour in Japan</p></a></li>
<li><a href='#krp'><p>The Khatri-Rao product of two matrices</p></a></li>
<li><a href='#mtrace'><p>The trace of a square numeric matrix</p></a></li>
<li><a href='#Parafac'>
<p>Robust Parafac estimator for compositional data</p></a></li>
<li><a href='#permute'><p>Permutation of a matricized array</p></a></li>
<li><a href='#plot.tucker3'><p> Plot a parafac or a tucker3 object</p></a></li>
<li><a href='#toArray'>
<p>Matrix to array conversion</p></a></li>
<li><a href='#Tucker3'>
<p>Robust Tucker3 estimator for compositional data</p></a></li>
<li><a href='#ulabor'>
<p>Undeclared labor by region in Italy</p></a></li>
<li><a href='#unfold'><p>Matrix unfolding</p></a></li>
<li><a href='#va3way'>
<p>Manufacturing value added by technology intensity for several years</p></a></li>
<li><a href='#waterquality'>
<p>Water quality data in Wyoming, USA</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.5-0</td>
</tr>
<tr>
<td>VersionNote:</td>
<td>Released 0.3-0 on 2023-06-24 on CRAN</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Methods for Multiway Data Analysis, Applicable also for
Compositional Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for multiway data analysis by means of Parafac
    and Tucker 3 models. Robust versions (Engelen and Hubert (2011) &lt;<a href="https://doi.org/10.1016%2Fj.aca.2011.04.043">doi:10.1016/j.aca.2011.04.043</a>&gt;) and versions
    for compositional data are also provided (Gallo (2015) &lt;<a href="https://doi.org/10.1080%2F03610926.2013.798664">doi:10.1080/03610926.2013.798664</a>&gt;, Di Palma et al. (2018) &lt;<a href="https://doi.org/10.1080%2F02664763.2017.1381669">doi:10.1080/02664763.2017.1381669</a>&gt;).
    Several optimization methods alternative to ALS are available 
    (Simonacci and Gallo (2019) &lt;<a href="https://doi.org/10.1016%2Fj.chemolab.2019.103822">doi:10.1016/j.chemolab.2019.103822</a>&gt;, Simonacci and Gallo (2020) &lt;<a href="https://doi.org/10.1007%2Fs00500-019-04320-9">doi:10.1007/s00500-019-04320-9</a>&gt;).</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Valentin Todorov &lt;valentin.todorov@chello.at&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rrcov, robustbase, ThreeWay, nnls, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, reshape2, xtable, covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>no</td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/valentint/rrcov3way">https://github.com/valentint/rrcov3way</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/valentint/rrcov3way/issues">https://github.com/valentint/rrcov3way/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 10:00:02 UTC; valen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Valentin Todorov <a href="https://orcid.org/0000-0003-4215-0245"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Violetta Simonacci [aut],
  Maria Anna Di Palma [aut],
  Michele Gallo [aut]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='amino'>Amino acids fluorescence data.</h2><span id='topic+amino'></span>

<h3>Description</h3>

<p>A data set containing five simple laboratory-made samples where each sample contains
different amounts of tyrosine, tryptophan and phenylalanine dissolved in phosphate
buffered water. The samples were measured by fluorescence (excitation 240-300 nm,
emission 250-450 nm, 1 nm intervals) on a PE LS50B spectrofluorometer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amino)
</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension <code>5x201x61</code>.
The first dimension refers to the 5 samples. The second dimension
refers to the emission measurements (250-450nm, 1nm intervals).
The third dimension refers to the excitation (240-300 nm, 1nm intervals).
</p>


<h3>Source</h3>

<p><a href="https://ucphchemometrics.com/datasets/">https://ucphchemometrics.com/datasets/</a>.
</p>


<h3>References</h3>

<p>Bro, R, PARAFAC: Tutorial and applications, Chemometrics and Intelligent Laboratory Systems, 1997, 38, 149-171
Bro, R, Multi-way Analysis in the Food Industry. Models, Algorithms, and Applications. 1998. Ph.D. Thesis,
University of Amsterdam (NL) &amp; Royal Veterinary and Agricultural University (DK).
Kiers, H.A.L. (1998) A three-step algorithm for Candecomp/Parafac analysis of large data
sets with multicollinearity, Journal of Chemometrics, 12, 155-171.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

 data(amino)
 ##  Plotting Emission spectra
 oldpar &lt;- par(mfrow=c(2,1))
 matplot(t(amino[,,1]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence emission spectra")
 matplot(t(amino[,,5]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence emission spectra")
 par(oldpar)

 ##  Plotting excitation spectra
 oldpar &lt;- par(mfrow=c(2,1))
 matplot(t(amino[,1,]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence excitation spectra")
 matplot(t(amino[,30,]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence excitation spectra")
 par(oldpar)


## End(Not run)
</code></pre>

<hr>
<h2 id='Arno'>
Chemical composition of water in the main stream of Arno river
</h2><span id='topic+Arno'></span>

<h3>Description</h3>

<p>Chemical composition of water in the main stream of Arno river.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Arno")</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension 23x11x4. 
The first dimension refers to 23 distances from the spring. 
The second dimension refers to the 11 chemical compositions. 
The third dimension refers to the time of collection - four occasions.
</p>


<h3>Details</h3>

<p>The Arno data example was used in Gallo and Buccinati (2013) to illustrate 
a particular version of the Tucker model, known as the weighted principal component analysis.
The Tucker3 results are usually given in the form of tables or plots and in this work 
for the representation of the Tucker3 results of logratio data, is proposed to use 
one-mode plots, clr-joint biplots (Gallo, 2015), and trajectory plots.
</p>


<h3>Source</h3>

<p>Nisi B., Vaselli O., Buccianti A., Minissale A., Delgado-Huertas A., Tassi F., Montegrossi G. (2008). Geochemical and isotopic investigation of the dissolved load in the running waters from 
the Arno valley: evaluation of the natural and anthropogenic input. 
In Memorie Descrittive della Carta Geologica d'Italia, Nisi (eds.), 79: 1-91.
</p>
<p>Nisi B., Buccianti A., Vaselli O., Perini G., Tassi F., Minissale A., Montegrossi G. (2008) 
Hydrogeochemistry and strontium isotopes in the Arno river basin (Tuscany, Italy): 
Constraints on natural controls by statistical modeling. <em>Journal of Hydrology</em> 360: 166-183.
</p>


<h3>References</h3>

<p>Gallo M. and Buccianti A. (2013). Weighted principal component analysis for
compositional data: application example for the water chemistry of 
the Arno river (Tuscany, central Italy), <em>Environmetrics</em>, 24(4):269-277.
</p>
<p>Gallo M. (2015). Tucker3 model for compositional data. 
<em>Communications in Statistics-Theory and Methods</em>, 44(21):4441-4453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Arno)
dim(Arno)               # [1] 23 11  4
dim(Arno[,,1])          # [1] 23 11
rownames(Arno[,,1])     # the 23 distances from the spring
colnames(Arno[,,1])     # the 11 chemical compositions
dim(Arno[,1,])          # [1] 23  4
colnames(Arno[,1,])     # the four occasions

res &lt;- Tucker3(Arno, robust=FALSE, coda.transform="ilr")
res

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)") 

## Joint biplot
plot(res, which="jbplot", main="Joint biplot") 

## Trajectory
plot(res, which="tjplot", main="Trajectory biplot") 
</code></pre>

<hr>
<h2 id='congruence'>Coefficient of factor congruence (phi)</h2><span id='topic+congruence'></span>

<h3>Description</h3>

<p>The function <code>congruence(x, y)</code> computes the Tucker's
congruence (phi) coefficients among two sets of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruence(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruence_+3A_x">x</code></td>
<td>
<p>A vector or matrix of factor loadings.</p>
</td></tr>
<tr><td><code id="congruence_+3A_y">y</code></td>
<td>
<p>A vector or matrix of factor loadings (may be NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Find the Tucker's coefficient of congruence between two sets of factor loadings.
Factor congruences are the cosines of pairs of vectors defined by the loadings matrix
and based at the origin. Thus, for loadings that differ only by a scaler
(e.g. the size of the eigen value), the factor congruences will be 1.
</p>
<p>For factor loading vectors of X and Y the measure of factor congruence, phi, is
</p>
<p style="text-align: center;"><code class="reqn">
 \phi = \frac{\sum X Y}{\sqrt{\sum(X^2)\sum(Y^2)}}
 .</code>
</p>

<p>If <code>y=NULL</code> and <code>x</code> is a numeric matrix, the congruence
coefficients between the columns of the matrix <code>x</code> are returned.
The result is a symmetric matrix with ones on the diagonal. If two matrices
are provided, they must have the same size and the result is a square matrix containing the
congruence coefficients between all pairs of columns of the two matrices.
</p>


<h3>Value</h3>

<p>A matrix of factor congruences.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>L.R Tucker (1951). A method for synthesis of factor analysis studies. Personnel Research Section Report No. 984. Department of the Army, Washington, DC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> require(rrcov)

 data(delivery, package="robustbase")
 X &lt;- getLoadings(PcaClassic(delivery))
 Y &lt;- getLoadings(PcaHubert(delivery, k=3))
 round(congruence(X,Y),3)

</code></pre>

<hr>
<h2 id='cp_als'>Alternating Least Squares (ALS) for Candecomp/Parafac (CP)</h2><span id='topic+cp_als'></span>

<h3>Description</h3>

<p>Alternating Least Squares (ALS) algorithm with optional
constraints for the minimization of the Candecomp/Parafac (CP) loss
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_als(
  X,
  n,
  m,
  p,
  ncomp,
  const = "none",
  start = "random",
  conv = 1e-06,
  maxit = 10000,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_als_+3A_x">X</code></td>
<td>
<p>A three-way array or a matrix. If <code>X</code> is a matrix
(matricised threeway array), <code>n</code>, <code>m</code> and <code>p</code> must be
given and are the number of A-, B- and C-mode entities respectively</p>
</td></tr>
<tr><td><code id="cp_als_+3A_n">n</code></td>
<td>
<p>Number of A-mode entities</p>
</td></tr>
<tr><td><code id="cp_als_+3A_m">m</code></td>
<td>
<p>Number of B-mode entities</p>
</td></tr>
<tr><td><code id="cp_als_+3A_p">p</code></td>
<td>
<p>Number of C-mode entities</p>
</td></tr>
<tr><td><code id="cp_als_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of components to extract</p>
</td></tr>
<tr><td><code id="cp_als_+3A_const">const</code></td>
<td>
<p>Optional constraints for each mode. Can be a three element
character vector or a single character, one of <code>"none"</code> for no
constraints (default), <code>"orth"</code> for orthogonality constraints,
<code>"nonneg"</code> for nonnegativity constraints or
<code>"zerocor"</code> for zero correlation between the extracted factors.
For example, <code>const="orth"</code> means orthogonality constraints for
all modes, while <code>const=c("orth", "none", "none")</code> sets the
orthogonality constraint only for mode A.</p>
</td></tr>
<tr><td><code id="cp_als_+3A_start">start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be
<code>"svd"</code> for starting point of the algorithm from SVD's,
<code>"random"</code> for random starting point (orthonormalized
component matrices or nonnegative matrices in case of nonnegativity
constraint), or a list containing user specified components.</p>
</td></tr>
<tr><td><code id="cp_als_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion, default is <code>conv=1e-6</code>.</p>
</td></tr>
<tr><td><code id="cp_als_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations, default is <code>maxit=10000</code>.</p>
</td></tr>
<tr><td><code id="cp_als_+3A_trace">trace</code></td>
<td>
<p>Logical, provide trace output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the decomposition as a list with the following
elements:
</p>

<ul>
<li> <p><code>fit</code> Value of the loss function
</p>
</li>
<li> <p><code>fp</code> Fit value expressed as a percentage
</p>
</li>
<li> <p><code>ss</code> Sum of squares
</p>
</li>
<li> <p><code>A</code> Component matrix for the A-mode
</p>
</li>
<li> <p><code>B</code> Component matrix for the B-mode
</p>
</li>
<li> <p><code>C</code> Component matrix for the C-mode
</p>
</li>
<li> <p><code>iter</code> Number of iterations
</p>
</li>
<li> <p><code>tripcos</code> Minimal triple cosine between two components
across the three component matrices, used to inspect degeneracy
</p>
</li>
<li> <p><code>mintripcos</code> Minimal triple cosine during the iterative
algorithm observed at every 10 iterations, used to inspect degeneracy
</p>
</li>
<li> <p><code>ftiter</code> Matrix containing in each row the function value
and the minimal triple cosine at every 10 iterations
</p>
</li>
<li> <p><code>const</code> Optional constraints (same as the input parameter
<code>const</code>)
</p>
</li></ul>



<h3>Note</h3>

<p>The argument <code>const</code> should be a three element character vector.
Set <code>const[j]="none"</code> for unconstrained update in j-th mode weight
matrix (the default),
<code>const[j]="orth"</code> for orthogonal update in j-th mode weight matrix,
<code>const[j]="nonneg"</code> for non-negative constraint on j-th mode or
<code>const[j]="zerocor"</code> for zero correlation between the extracted
factors.
The default is unconstrained update for all modes.
</p>
<p>The loss function to be minimized is <code class="reqn">sum(k)|| X(k) - A D(k) B' ||^2</code>,
where <code class="reqn">D(k)</code> is a diagonal matrix holding the <code>k</code>-th row of
<code>C</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Harshman, R.A. (1970). Foundations of Parafac procedure:
models and conditions for an &quot;explanatory&quot; multi-mode factor
analysis. <em>UCLA Working Papers in Phonetics</em>, 16: 1&ndash;84.
</p>
<p>Harshman, R. A., &amp; Lundy, M. E. (1994). PARAFAC: Parallel factor analysis.
Computational Statistics and Data Analysis, 18, 39&ndash;72.
</p>
<p>Lawson CL, Hanson RJ (1974). Solving Least Squares Problems.
Prentice Hall, Englewood Cliffs, NJ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Example with the OECD data
 data(elind)
 dim(elind)

 res &lt;- cp_als(elind, ncomp=3)
 res$fp
 res$fp
 res$iter

 res &lt;- cp_als(elind, ncomp=3, const="nonneg")
 res$A

## End(Not run)
</code></pre>

<hr>
<h2 id='cp_atld'>Alternating Trilinear Decomposition (ATLD) for Candecomp/Parafac (CP)</h2><span id='topic+cp_atld'></span>

<h3>Description</h3>

<p>Alternating Trilinear Decomposition algorithm for estimating
the Candecomp/Parafac (CP) model. It is based on an alternating least squares
principle and replaces the iterative procedure used in the traditional
PARAFAC algorithm by an improved procedure. This improved procedure
contains Moore-Penrose pseudoinverse computations based on singular
value decomposition (SVD) which should be theoretically more robust
to similarities in spectra and time profiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_atld(
  X,
  n,
  m,
  p,
  ncomp,
  conv = 1e-06,
  start = "random",
  maxit = 5000,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_atld_+3A_x">X</code></td>
<td>
<p>A three-way array or a matrix. If <code>X</code> is a matrix
(matricised threeway array), <code>n</code>, <code>m</code> and <code>p</code> must be
given and are the number of A-, B- and C-mode entities respectively</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_n">n</code></td>
<td>
<p>Number of A-mode entities</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_m">m</code></td>
<td>
<p>Number of B-mode entities</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_p">p</code></td>
<td>
<p>Number of C-mode entities</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of components to extract</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion, default is <code>conv=1e-6</code>.</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_start">start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be
<code>"svd"</code> for starting point of the algorithm from SVD's,
<code>"random"</code> for random starting point (orthonormalized
component matrices or nonnegative matrices in case of nonnegativity
constraint), or a list containing user specified components.</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations, default is <code>maxit=10000</code>.</p>
</td></tr>
<tr><td><code id="cp_atld_+3A_trace">trace</code></td>
<td>
<p>Logical, provide trace output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the decomposition as a list with the following
elements:
</p>

<ul>
<li> <p><code>fit</code> Value of the loss function
</p>
</li>
<li> <p><code>fp</code> Fit value expressed as a percentage
</p>
</li>
<li> <p><code>ss</code> Sum of squares
</p>
</li>
<li> <p><code>A</code> Component matrix for the A-mode
</p>
</li>
<li> <p><code>B</code> Component matrix for the B-mode
</p>
</li>
<li> <p><code>C</code> Component matrix for the C-mode
</p>
</li>
<li> <p><code>iter</code> Number of iterations
</p>
</li>
<li> <p><code>tripcos</code> Minimal triple cosine between two components
across the three component matrices, used to inspect degeneracy
</p>
</li>
<li> <p><code>mintripcos</code> Minimal triple cosine during the iterative
algorithm observed at every 10 iterations, used to inspect degeneracy
</p>
</li>
<li> <p><code>ftiter</code> Matrix containing in each row the function value
and the minimal triple cosine at every 10 iterations
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>; Violetta Simonacci, <a href="mailto:violetta.simonacci@unina.it">violetta.simonacci@unina.it</a>
</p>


<h3>References</h3>

<p>H.-L. Wu, M. Shibukawa, K. Oguma, An alternating trilinear decomposition
algorithm with application to calibration of HPLC-DAD for
simultaneous determination of overlapped chlorinated aromatic hydrocarbons,
<em>Journal of Chemometrics</em> <b>12</b> (1998) 1&ndash;26.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Example with the OECD data
 data(elind)
 dim(elind)

 res &lt;- cp_atld(elind, ncomp=3)
 res$fp
 res$fp
 res$iter

## End(Not run)
</code></pre>

<hr>
<h2 id='cp_gen'>Generate PARAFAC data sets, optionally with outliers</h2><span id='topic+cp_gen'></span>

<h3>Description</h3>

<p>Generates <code>nsim</code> data sets according to the given parameters.
If <code>eps &gt; 0</code>, the specified fraction of random outliers of the identified by the 
parameter <code>type</code> type are added to the data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_gen(
  I = 20,
  J = 20,
  K = 20,
  nsim = 200,
  nf = 3,
  noise = 0.05,
  noise1 = 0,
  Acol = TRUE,
  Bcol = TRUE,
  Ccol = TRUE,
  congA = 0.5,
  congB = 0.5,
  congC = 0.5,
  eps = 0,
  type = c("none", "bl", "gl", "og"),
  c1 = 10,
  c2 = 0.1,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_gen_+3A_i">I</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_j">J</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_k">K</code></td>
<td>
<p>number of occasions</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_nsim">nsim</code></td>
<td>
<p>number of data sets to generate</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_nf">nf</code></td>
<td>
<p>number of PARAFAC components</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_noise">noise</code></td>
<td>
<p>level of homoscedastic (HO) noise</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_noise1">noise1</code></td>
<td>
<p>level of heteroscedastic (HE) noise</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_acol">Acol</code></td>
<td>
<p>whether to apply collinearity with factor congA to mode A</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_bcol">Bcol</code></td>
<td>
<p>whether to apply collinearity with factor congB to mode B</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_ccol">Ccol</code></td>
<td>
<p>whether to apply collinearity with factor congC to mode C</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_conga">congA</code></td>
<td>
<p>collinearity factor for mode A</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_congb">congB</code></td>
<td>
<p>collinearity factor for mode B</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_congc">congC</code></td>
<td>
<p>collinearity factor for mode C</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_eps">eps</code></td>
<td>
<p>fraction of outliers (percent contamination)</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_type">type</code></td>
<td>
<p>type of outliers: one of <code>"none"</code> for no outliers (possible only of <code>eps==0</code>), 
<code>"bl"</code> for bad leverage points, <code>"gl"</code> for good leverage points and
<code>"og"</code> for orthogonal outliers</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_c1">c1</code></td>
<td>
<p>parameter for outlier generation (<code>c1=10</code> for <code>type="bl"</code> 
or  <code>type="gl"</code> and <code>c1=1</code> for <code>type="og"</code>)</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_c2">c2</code></td>
<td>
<p>parameter for outlier generation (<code>c2=0.1</code> for <code>type="bl"</code>
or <code>type="og"</code> and <code>c2=0</code> for <code>type="gl"</code>)</p>
</td></tr>
<tr><td><code id="cp_gen_+3A_silent">silent</code></td>
<td>
<p>whether to issue warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the following lists:
</p>

<ul>
<li><p> As list of <code>nsim</code> matrices for the mode A
</p>
</li>
<li><p> Bs list of <code>nsim</code> matrices for the mode B
</p>
</li>
<li><p> Cs list of <code>nsim</code> matrices for the mode C
</p>
</li>
<li><p> Xs list of <code>nsim</code> PARAFAC data sets, each with dimension IxJxK
</p>
</li>
<li><p> Os list of <code>nsim</code> vectors containing the added outliers (if any)
</p>
</li>
<li><p> param list of parameters used for generation of the data sets
</p>
</li></ul>



<h3>References</h3>

<p>Todorov, V. and Simonacci, V. and Gallo, M. and Trendafilov, N. (2023). A novel 
estimation procedure for robust CANDECOMP/PARAFAC model fitting. 
<em>Econometrics and Statistics</em>. In press.
</p>
<p>Tomasi, G. and Bro, R., (2006). A comparison of algorithms for fitting the PARAFAC model. 
<em>Computational Statistics &amp; Data Analysis</em> <b>50</b> (7), 1700&ndash;1734.
</p>
<p>Faber, N.M. and Bro, R. and Hopke, P.K. (2003). Recent developments in CANDECOMP/PARAFAC algorithms: 
A critical review. <em>Chemometrics and Intelligent Laboratory Systems</em> <b>65</b>, 119&ndash;137.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ##  Generate one PARAFAC data set (nsim=1) with R=2 components (nf=2) and dimensions
 ##  50x10x10. Apply 0.15 homoscedastic noise and 0.10 heteroscedastic noise, apply 
 ##  collinearity with congruence factor 0.5 to all modes. Add 20% bad leverage points.

 library(rrcov3way)
 xdat &lt;- cp_gen(I=50, J=100, K=10, nsim=1, nf=2,
     noise=0.15, noise1=0.10, Acol=TRUE, Bcol=TRUE, Ccol=TRUE,
     congA=0.5, congB=0.5, congC=0.5,
     eps=0.2, type="bl")
 names(xdat)
   
</code></pre>

<hr>
<h2 id='cp_int2'>ATLD-ALS algorithm for Candecomp/Parafac (CP)</h2><span id='topic+cp_int2'></span>

<h3>Description</h3>

<p>Integrated algorithm combining ATLD and ALS for the
minimization of the Candecomp/Parafac (CP) loss function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_int2(
  X,
  n,
  m,
  p,
  ncomp,
  initconv = 0.01,
  conv = 1e-06,
  const = "none",
  start = "random",
  maxit = 5000,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cp_int2_+3A_x">X</code></td>
<td>
<p>A three-way array or a matrix. If <code>X</code> is a matrix
(matricised threeway array), <code>n</code>, <code>m</code> and <code>p</code> must be
given and are the number of A-, B- and C-mode entities respectively</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_n">n</code></td>
<td>
<p>Number of A-mode entities</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_m">m</code></td>
<td>
<p>Number of B-mode entities</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_p">p</code></td>
<td>
<p>Number of C-mode entities</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of components to extract</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_initconv">initconv</code></td>
<td>
<p>Convergence criterion for the initialization phase (ATLD),
default is <code>conv=1e-2</code>.</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion, default is <code>conv=1e-6</code>.</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_const">const</code></td>
<td>
<p>Optional constraints for each mode. Can be a three element
character vector or a single character, one of <code>"none"</code> for no
constraints (default), <code>"orth"</code> for orthogonality constraints or
<code>"zerocor"</code> for zero correlation between the extracted factors.
For example, <code>const="orth"</code> means orthogonality constraints for
all modes, while <code>const=c("orth", "none", "none")</code> sets the
orthogonality constraint only for mode A.</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_start">start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be
<code>"svd"</code> for starting point of the algorithm from SVD's,
<code>"random"</code> for random starting point (orthonormalized
component matrices or nonnegative matrices in case of nonnegativity
constraint), or a list containing user specified components.</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations, default is <code>maxit=10000</code>.</p>
</td></tr>
<tr><td><code id="cp_int2_+3A_trace">trace</code></td>
<td>
<p>Logical, provide trace output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the decomposition as a list with the following
elements:
</p>

<ul>
<li> <p><code>fit</code> Value of the loss function
</p>
</li>
<li> <p><code>fp</code> Fit value expressed as a percentage
</p>
</li>
<li> <p><code>ss</code> Sum of squares
</p>
</li>
<li> <p><code>A</code> Component matrix for the A-mode
</p>
</li>
<li> <p><code>B</code> Component matrix for the B-mode
</p>
</li>
<li> <p><code>C</code> Component matrix for the C-mode
</p>
</li>
<li> <p><code>iter</code> Number of iterations
</p>
</li>
<li> <p><code>tripcos</code> Minimal triple cosine between two components
across the three component matrices, used to inspect degeneracy
</p>
</li>
<li> <p><code>mintripcos</code> Minimal triple cosine during the iterative
algorithm observed at every 10 iterations, used to inspect degeneracy
</p>
</li>
<li> <p><code>ftiter</code> Matrix containing in each row the function value
and the minimal triple cosine at every 10 iterations
</p>
</li>
<li> <p><code>const</code> Optional constraints (same as the input parameter
<code>const</code>)
</p>
</li></ul>



<h3>Note</h3>

<p>The argument <code>const</code> should be a three element character vector.
Set <code>const[j]="none"</code> for unconstrained update in j-th mode weight
matrix (the default),
<code>const[j]="orth"</code> for orthogonal update in j-th mode weight matrix or
<code>const[j]="zerocor"</code> for zero correlation between the extracted
factors.
The default is unconstrained update for all modes.
</p>
<p>The loss function to be minimized is <code class="reqn">sum(k)|| X(k) - A D(k) B' ||^2</code>,
where <code class="reqn">D(k)</code> is a diagonal matrix holding the <code>k</code>-th row of
<code>C</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>; Violetta Simonacci, <a href="mailto:violetta.simonacci@unina.it">violetta.simonacci@unina.it</a>
</p>


<h3>References</h3>

<p>H.-L. Wu, M. Shibukawa, K. Oguma, An alternating trilinear decomposition
algorithm with application to calibration of HPLC-DAD for
simultaneous determination of overlapped chlorinated aromatic hydrocarbons,
<em>Journal of Chemometrics</em> <b>12</b> (1998) 1&ndash;26.
</p>
<p>Simonacci, V. and Gallo, M. (2020). An ATLD&ndash;ALS method for the trilinear decomposition
of large third-order tensors, <em>Soft Computing</em> 24 13535&ndash;13546.
</p>
<p>Todorov, V. and Simonacci, V. and Gallo, M. and Trendafilov, N. (2023). A novel 
estimation procedure for robust CANDECOMP/PARAFAC model fitting. 
<em>Econometrics and Statistics</em>. In press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Example with the OECD data
 data(elind)
 dim(elind)

 res &lt;- cp_int2(elind, ncomp=3)
 res$fp
 res$fp
 res$iter

 res &lt;- cp_int2(elind, ncomp=3, const="orth")
 res$A

## End(Not run)
</code></pre>

<hr>
<h2 id='do3Postprocess'>
Postprocessing: renormalization, reflection and reordering; access to some of the components of the model.
</h2><span id='topic+do3Postprocess'></span><span id='topic+do3Postprocess.default'></span><span id='topic+do3Postprocess.parafac'></span><span id='topic+do3Postprocess.tucker3'></span><span id='topic+tallArray'></span><span id='topic+wideArray'></span><span id='topic+tall2wide'></span><span id='topic+coordinates'></span><span id='topic+coordinates.parafac'></span><span id='topic+coordinates.tucker3'></span><span id='topic+weights'></span><span id='topic+weights.parafac'></span><span id='topic+weights.tucker3'></span><span id='topic+reflect'></span><span id='topic+reflect.parafac'></span><span id='topic+reflect.tucker3'></span><span id='topic+reorder'></span><span id='topic+reorder.parafac'></span><span id='topic+reorder.tucker3'></span><span id='topic+is.orthogonal'></span><span id='topic+is.orthonormal'></span>

<h3>Description</h3>

<p>The estimated model will be renormalized, reflected (change of sign) or the components will be reordered.
Functions that provide access to some components of the model: coordinates, weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'tucker3'
do3Postprocess(x, reflectA, reflectB, reflectC, reorderA, reorderB, reorderC, ...)
    ## S3 method for class 'parafac'
do3Postprocess(x, reflectA, reflectB, reflectC, reorder, ...)
    ## S3 method for class 'parafac'
coordinates(x, mode = c("A", "B", "C"), type = c("normalized", "unit", "principal"), ...)
    ## S3 method for class 'tucker3'
coordinates(x, mode = c("A", "B", "C"), type = c("normalized", "unit", "principal"), ...)
    ## S3 method for class 'parafac'
weights(object, ...)
    ## S3 method for class 'tucker3'
weights(object, mode = c("A", "B", "C"), ...)
    ## S3 method for class 'parafac'
reflect(x, mode = c("A", "B", "C"), rsign = 1, ...)
    ## S3 method for class 'tucker3'
reflect(x, mode = c("A", "B", "C"), rsign = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do3Postprocess_+3A_x">x</code></td>
<td>
<p>Tucker3 or Parafac solution</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_object">object</code></td>
<td>
<p>Tucker3 or Parafac solution (alternative of <code>x</code> for the generic function <code>weights()</code>)</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reflecta">reflectA</code></td>
<td>
<p>How to handle the signs of the components of mode A - can be a single number or a vector with length of the number of components of A</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reflectb">reflectB</code></td>
<td>
<p>How to handle the signs of the components of mode B - can be a single number or a vector with length of the number of components of B</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reflectc">reflectC</code></td>
<td>
<p>How to handle the signs of the components of mode C - can be a single number or a vector with length of the number of components of C</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reorder">reorder</code></td>
<td>
<p>How to reorder the components of a Parafac solution - a vector with length of the number of components</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reordera">reorderA</code></td>
<td>
<p>How to reorder the components of mode A - a vector with length of the number of components of A giving the new order</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reorderb">reorderB</code></td>
<td>
<p>How to reorder the components of mode B - a vector with length of the number of components of B giving the new order</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_reorderc">reorderC</code></td>
<td>
<p>How to reorder the components of mode C - a vector with length of the number of components of C giving the new order</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_mode">mode</code></td>
<td>
<p>For which mode to provide the coordinates or weights. Default is mode A</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_type">type</code></td>
<td>
<p>Which type of coordinates to provide. Default is &quot;normalized&quot;</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_rsign">rsign</code></td>
<td>
<p>How to change the sign of the components of the given mode. Can be a single number or a vector with length of the number of components of the corresponding mode.</p>
</td></tr>
<tr><td><code id="do3Postprocess_+3A_...">...</code></td>
<td>
<p>Potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output value of do3Postproces() is the postprocessed solution, Parafac or Tucker3. 
The output of <code>weights()</code> and <code>coordinates()</code> are the respective values.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>Kroonenberg (2008). Applied multiway data analysis. Wiley series 
in probability and statistics. Hoboken NJ, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(elind)
    x1 &lt;- do3Scale(elind, center=TRUE, scale=TRUE)
    (cp &lt;- Parafac(x1, ncomp=3, const=c("orth", "none", "none")))
    
    cp$B
    cp1 &lt;- do3Postprocess(cp, reflectB=-1)      # change the sign of all components of B
    cp1$B
    weights(cp1)
    coordinates(cp1)
    coordinates(cp1, type="principal")

    ## Same as above - the centering and scaling is done inside the Parafac procedure
    (cp1 &lt;- Parafac(elind, ncomp=3, const=c("orth", "none", "none"), 
        center=TRUE, scale=TRUE))

    ## Robust estimation with robust scaling with median and mad
    (cp1 &lt;- Parafac(elind, ncomp=3, const=c("orth", "none", "none"), 
        center=median, scale=mad, robust=TRUE))

    ## Robust estimation with robust scaling with median and Qn (Rousseeuw and Croux, 1993)
    require(robustbase)
    (cp1 &lt;- Parafac(elind, ncomp=3, const=c("orth", "none", "none"), 
        center=median, scale=Qn, robust=TRUE))
</code></pre>

<hr>
<h2 id='do3Rotate'>Varimax Rotation for Tucker3 models</h2><span id='topic+do3Rotate'></span><span id='topic+do3Rotate.tucker3'></span>

<h3>Description</h3>

<p>Computes <em>varimax</em> rotation of the core and component matrix of a Tucker3 model to simple structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do3Rotate(x, ...)

## S3 method for class 'tucker3'
do3Rotate(x, weights = c(0, 0, 0), rotate = c("A", "B", "C"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do3Rotate_+3A_x">x</code></td>
<td>
<p>A Tucker 3 object</p>
</td></tr>
<tr><td><code id="do3Rotate_+3A_...">...</code></td>
<td>
<p>Potential further arguments passed to called functions.</p>
</td></tr>
<tr><td><code id="do3Rotate_+3A_weights">weights</code></td>
<td>
<p>A numeric vector with length 3: relative weights (greater or
equal 0) for the simplicity of the component matrices <code>A</code>, <code>B</code>
and <code>C</code> respectively.</p>
</td></tr>
<tr><td><code id="do3Rotate_+3A_rotate">rotate</code></td>
<td>
<p>Within which mode to rotate the Tucker3 solution:
<code>rotate="A"</code> means to rotate the component matrix <code>A</code> of mode A;
<code>rotate=c("A", "B")</code> means to rotate the component matrices <code>A</code>
and <code>B</code> of modes A and B respectively. Default is to rotate all modes,
i.e. <code>rotate=c("A", "B", "C")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the following components:
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Rotation of a Tucker3 solution
 data(elind)
 (t3 &lt;- Tucker3(elind, 3, 2, 2))
 xout &lt;- do3Rotate(t3, c(3, 3, 3), rotate=c("A", "B", "C"))
 xout$vvalue

</code></pre>

<hr>
<h2 id='do3Scale'>
Centering and scaling
</h2><span id='topic+do3Scale'></span><span id='topic+do3Scale.default'></span><span id='topic+do3Scale.parafac'></span><span id='topic+do3Scale.tucker3'></span>

<h3>Description</h3>

<p>Centering and/or normalization of a three way array or a matricized 
array across one mode (modes indicated by &quot;A&quot;, &quot;B&quot; or &quot;C&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'tucker3'
do3Scale(x, renorm.mode = c("A", "B", "C"), ...)
    ## S3 method for class 'parafac'
do3Scale(x, renorm.mode = c("A", "B", "C"), ...)
    ## Default S3 method:
do3Scale(x, center = FALSE, scale = FALSE, 
        center.mode = c("A", "B", "C", "AB", "AC", "BC", "ABC"), 
        scale.mode = c("B", "A", "C"), 
        only.data=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do3Scale_+3A_x">x</code></td>
<td>
<p>Three dimensional array of order (I x J x K) or a matrix 
(or data.frame coerced to a matrix) of order (I x JK) containing 
the matricized array (frontal slices)</p>
</td></tr>
<tr><td><code id="do3Scale_+3A_center">center</code></td>
<td>
<p>Whether and how to center the data. Can be <code>NULL</code>, 
logical <code>TRUE</code> or <code>FALSE</code>, function or a numeric vector with 
length corresponding to the number of columns in the corresponding mode.
If <code>center=TRUE</code>, <code>mean()</code> is used; default is <code>center=FALSE</code>.</p>
</td></tr>
<tr><td><code id="do3Scale_+3A_scale">scale</code></td>
<td>
<p>Whether and how to scale the data. Can be <code>NULL</code>, 
logical <code>TRUE</code> or <code>FALSE</code>, function or a numeric vector with 
length corresponding to the number of columns in the corresponding mode. 
If <code>scale=TRUE</code>, <code>sd()</code> is used; default is <code>scale=FALSE</code>.</p>
</td></tr>
<tr><td><code id="do3Scale_+3A_center.mode">center.mode</code></td>
<td>
<p>Across which mode to center. Default is <code>center.mode="A"</code></p>
</td></tr>
<tr><td><code id="do3Scale_+3A_scale.mode">scale.mode</code></td>
<td>
<p>Within which mode to scale. Default is <code>scale.mode="B"</code></p>
</td></tr>
<tr><td><code id="do3Scale_+3A_renorm.mode">renorm.mode</code></td>
<td>
<p>Within which mode to renormalize a Parafac or Tucker3 solution. 
See in Details how this is performed for the different models. 
Default is <code>renorm.mode="A"</code></p>
</td></tr>
<tr><td><code id="do3Scale_+3A_only.data">only.data</code></td>
<td>
<p>Whether to return only the centered/scaled data or also 
the center and the scale themselves. Default is <code>only.data=TRUE</code></p>
</td></tr>
<tr><td><code id="do3Scale_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to lower level functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, consisting of the centered and/or scaled data, a center vector, 
a scale vector and the mode in which the data were centered/scaled. 
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>Kiers, H.A.L. (2000).Towards a standardizrd notation and terminology 
in multiway analysis. <em>Journal of Chemometrics</em>, 14:105-122.
</p>
<p>Kroonenberg, P.M. (1983).Three-mode principal component analysis: 
Theory and applications (Vol. 2), DSWO press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(elind)
    (x1 &lt;- do3Scale(elind, center=TRUE, scale=TRUE))
    (x2 &lt;- do3Scale(elind, center=TRUE, scale=TRUE, center.mode="B"))
    (x3 &lt;- do3Scale(elind, center=TRUE, scale=TRUE, center.mode="C", scale.mode="C"))
</code></pre>

<hr>
<h2 id='dorrit'>Dorrit fluorescence data.</h2><span id='topic+dorrit'></span>

<h3>Description</h3>

<p>A data set with 27 synthetic samples containing different concentrations of four analytes
(hydroquinone, tryptophan, phenylalanine and dopa) measured in a Perkin-Elmer
LS50 B fluorescence spectrometer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dorrit)
</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension <code>27 x 116 x 18</code>.
The first dimension refers to the 27 samples. The second dimension
refers to the emission measurements (251-481nm, 2nm intervals).
The third dimension refers to the excitation (230-315nm, 5nm intervals).
</p>


<h3>Details</h3>

<p>Each fluorescence landscape corresponding to each
sample in the original data set consists of 233 emission wavelengths
(250-482 nm) and 24 excitation wavelengths
(200-315 nm taken each 5 nm). The fluorescence data is three-way.
Ideally, the data is trilinear, the components
of the modes corresponding to concentrations (27), emission
spectra (233) and excitation spectra (24). Hence a three-way
PARAFAC model should be capable of uniquely and meaningfully
describing the variation in the data set.
</p>
<p>The data set is modified as described in Engelen and Hubert (2011):
the emission wavelengths are taken at 2 nm,
noisy parts situated at the excitation wavelengths from 200 to 230 nm and
at emission wavelengths below 250 nm are excluded. The severe Rayleigh
scattering areas present in all samples are replaced by interpolated values.
Thus we end up with a <code>(27 x 116 x 18)</code> data array.
</p>


<h3>Source</h3>

<p><a href="https://ucphchemometrics.com/datasets/">https://ucphchemometrics.com/datasets/</a>.
</p>


<h3>References</h3>

<p>Bro, R, Sidiropoulos, ND and Smilde, AK (2002). Maximum likelihood
fitting using ordinary least squares algorithms.
<em>Journal of Chemometrics</em>, <b>16</b>(8&ndash;10), 387&ndash;400.
</p>
<p>Riu, J and Bro, R (2003) Jack-knife estimation of standard errors and outlier detection in PARAFAC models.
<em>Chemometrics and Intelligent Laboratory Systems</em>, 65(1), 35&ndash;49
</p>
<p>Engelen, S and Hubert, M (2011) Detecting outlying samples in a parallel factor analysis model,
<em>Analytica Chemica Acta</em> 705 155&ndash;165.
</p>
<p>Baunsgaard, D (1999) Factors Affecting 3-way Modelling (PARAFAC) of Fluorescence
Landscapes, Royal Veterinary and Agricultural University,
Department of Dairy and Food Science, Frederiksberg, Denmark.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 

 data(dorrit)
 ##  Plotting Emission spectra
 oldpar &lt;- par(mfrow=c(2,1))
 matplot(t(dorrit[,,1]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence emission spectra")
 matplot(t(dorrit[,,5]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence emission spectra")
 par(oldpar)

 ##  Plotting excitation spectra
 oldpar &lt;- par(mfrow=c(2,1))
 matplot(t(dorrit[,1,]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence excitation spectra")
 matplot(t(dorrit[,30,]), type="l",
     xlab="Wavelength/nm", ylab="Intensity",
     main="Fluorescence excitation spectra")
 par(oldpar)

 persp(as.numeric(dimnames(dorrit)[[2]]),
     as.numeric(dimnames(dorrit)[[3]]), dorrit[4,,],
     xlab="Emission", ylab="Excitation", zlab="Intensity",
     theta = 30, phi = 30, expand = 0.5, col = "lightblue",
     ticktype="detailed")

 pp &lt;- Parafac(dorrit, ncomp=4, robust=TRUE)
 plot(pp)


## End(Not run)
</code></pre>

<hr>
<h2 id='elind'>
OECD Electronics Industries Data
</h2><span id='topic+elind'></span>

<h3>Description</h3>

<p>OECD publishes comparative statistics of the export size of various 
sectors of the electronics industry: 
</p>

<ol>
<li><p> information science, 
</p>
</li>
<li><p> telecommunication products, 
</p>
</li>
<li><p> radio and television equipment, 
</p>
</li>
<li><p> components and parts, 
</p>
</li>
<li><p> electromedical equipment, and 
</p>
</li>
<li><p> scientific equipment. 
</p>
</li></ol>

<p>The data consist of specialisation indices of electronics industries 
of 23 European countries for the years 1973&ndash;1979. The specialization 
index is defined as the proportion of the monetary value of an electronic 
industry compared to the total export value of manufactured goods of 
a country compared to the similar proportion for the world as 
a whole (see D'Ambra, 1985, p. 249 and Kroonenberg, 2008, p.282).   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(elind)</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension 23x6x7. 
The first dimension refers to 23 countries. 
The second dimension refers to the six indices of electronics industries. 
The third dimension refers to the years in the period 1978&ndash;1985.
</p>


<h3>Source</h3>

<p>The data set is available from Pieter Kroonenberg's web site at: 
&quot;three-mode.leidenuniv.nl/data/electronicindustriesinfo.htm&quot;
</p>


<h3>References</h3>

<p>D'Ambra, L. (1985). Alcune estensione dell'analisi in componenti principali 
per lo studio dei sistemi evolutivi. Uno studio sul commercio internazionale 
dell'elettronica. 
In: Ricerche Economiche. 2. del Dipartimento di Scienze Economiche Ca'Foscari, Venezia.
</p>
<p>Kroonenberg PM (2008). Applied multiway data analysis. Wiley series in probability and
statistics. John Wiley and Sons, Hoboken, NJ, p.282.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(elind)

res &lt;- Parafac(elind, robust=FALSE, coda.transform="none")

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)") 

## Per-component plot
plot(res, which="percomp", comp=1, main="Per component plot") 

## all components plot
plot(res, which="allcomp", main="All components plot", legend.position="topright") 

</code></pre>

<hr>
<h2 id='girls'>Sempe girls' growth curves data
</h2><span id='topic+girls'></span>

<h3>Description</h3>

<p>Thirty girls selected from a French auxiological study (1953-1975) to get 
insight into the physical growth patterns of children from ages four to fifteen, 
Sempe (1987). They were measured yearly between the ages 4 and 15 on the following eight variables:
</p>

<ol>
<li><p> 	weight = Weight
</p>
</li>
<li><p> 	length = Length
</p>
</li>
<li><p>	crump = Crown-rump length
</p>
</li>
<li><p>	head = Head circumference
</p>
</li>
<li><p>	chest = Chest circumference
</p>
</li>
<li><p>	arm = Arm
</p>
</li>
<li><p>	calf = Calf
</p>
</li>
<li><p>	pelvis = Pelvis
</p>
</li></ol>

<p>The data set is three way data array of size 30 (girls) x 8 (variables) x 12 (years). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("girls")</code></pre>


<h3>Format</h3>

<p>The format is a three way array with the following dimensions:
The first dimension refers to 30 girls. 
The second dimension refers to the eight variables measured on the girls. 
The third dimension refers to the years &ndash; 4 to 15.  
</p>


<h3>Details</h3>

<p>The data are generally preprocessed as standard multiway profile data. 
For details see Kroonenberg (2008), Chapters 6 and 15.
</p>


<h3>Source</h3>

<p>The data sets are available from Pieter Kroonenberg's web site at:
&quot;three-mode.leidenuniv.nl/data/girlsgrowthcurvesinfo.htm&quot;
</p>


<h3>References</h3>

<p>Sempe, M. (1987). Multivariate and longitudinal data on growing children: 
Presentation of the French auxiological survey. In J.Janssen et al. Data analysis. 
The Ins and Outs of solving real problems (pp. 3-6). New York: Plenum Press.
</p>
<p>Kroonenberg (2008). Applied multiway data analysis. Wiley series 
in probability and statistics. Hoboken NJ, Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(girls)
str(girls)
## Center the data in mode A and find the "average girl"
center.girls &lt;- do3Scale(girls, center=TRUE, only.data=FALSE)
X &lt;- center.girls$x
center &lt;- center.girls$center
average.girl &lt;- as.data.frame(matrix(center, ncol=8, byrow=TRUE))
dimnames(average.girl) &lt;- list(dimnames(X)[[3]], dimnames(X)[[2]])

## Divide these variables by 10 to reduce their range
average.girl$weight &lt;- average.girl$weight/10
average.girl$length &lt;- average.girl$length/10
average.girl$crrump &lt;- average.girl$crrump/10

average.girl 
p &lt;- ncol(average.girl)
plot(rownames(average.girl), average.girl[,1], ylim=c(min(average.girl), 
    max(average.girl)), type="n", xlab="Age", ylab="")
for(i in 1: p)
{
    lines(rownames(average.girl), average.girl[,i], lty=i, col=i) 
    points(rownames(average.girl), average.girl[,i], pch=i, col=i) 
}    
legend &lt;- colnames(average.girl)
legend[1] &lt;- paste0(legend[1], "*")
legend[2] &lt;- paste0(legend[3], "*")
legend[3] &lt;- paste0(legend[4], "*")
legend("topleft", legend=legend, col=1:p, lty=1:p, pch=1:p)
</code></pre>

<hr>
<h2 id='Kojima'>
Parental behaviour in Japan
</h2><span id='topic+Kojima'></span><span id='topic+Kojima.boys'></span><span id='topic+Kojima.girls'></span>

<h3>Description</h3>

<p>The data are drawn from a study (Kojima, 1975) of the perception of 
parental behaviour by parents and their children. Two data sets, boys and girls are available
as Kojima.boys and Kojima.girls. 
</p>

<ul>
<li><p> Boys data were analysed in Kroonenberg (2008)
</p>
</li>
<li><p> Girls data were analysed in Kroonenberg, Harshman, &amp; Murakami (2009).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(Kojima)

</code></pre>


<h3>Format</h3>

<p>Both data sets are three dimensional arrays:
</p>

<ul>
<li><p> boys: 150 x 18 x 4
</p>
</li>
<li><p> girls: 153 x 18 x 4
</p>
</li></ul>

<p>The rows (1st mode) are 150 Japanese sons/153 Japanese daughters.
The columns (2nd mode) are 18 scales (Acceptance, Child centerness, Possesiveness, etc.).
The slices (3rd mode) are the 4 judgements (See Details for explanation).
</p>


<h3>Details</h3>

<p>The <code>boys</code> data are ratings expressing the judgments of parents with respect to their 
own behaviour toward their sons, and the judgments of their sons with respect to their 
parents. Thus, there are four conditions: 
</p>

<ul>
<li><p> Father-Own behaviour (F-F), 
</p>
</li>
<li><p> Mother-Own behaviour (M-M), 
</p>
</li>
<li><p> Son-Father (B-F), 
</p>
</li>
<li><p> Son-Mother (B-M). 
</p>
</li></ul>

<p>The judgments involved 150 middle-class Japanese eighth-grade boys on the 18 subscales of the inventory. 
Thus, the data set consists of a 150 (Sons) x 18 (scales) x 4 (judgment combinations) 
data array.
</p>
<p>Similarly, the girls data are ratings expressing the judgments of parents with respect to 
their own behaviour toward their daughters, and the judgments of their daughters with 
respect to their parents. Thus, there are four conditions: 
</p>

<ul>
<li><p> Father-Own behaviour (F-F), 
</p>
</li>
<li><p> Mother-Own behaviour (M-M),
</p>
</li>
<li><p> Daughter-Father (G-F), 
</p>
</li>
<li><p> Daughter-Mother (G-M).
</p>
</li></ul>
 
<p>The judgments involved 153 middle-class Japanese eighth-grade girls on the 18 subscales of 
the inventory. Thus, the data set consists of a 153 (Daughters) x 18 (scales) x 4 (judgment combinations) 
data array.
</p>
<p><em>Preprocessing</em>
Given that the data are three-way profile data they are treated in the standard manner:
centering per occasion-variable combination and by normalising the data after centring 
per lateral slice i.e. per scale over all sons/daughters x judges combinations. 
For details see Kroonenberg (2008), Chapter 13.
</p>


<h3>Source</h3>

<p>The data sets are available from the Pieter Kroonenberg's web site at <a href="https://three-mode.leidenuniv.nl/">https://three-mode.leidenuniv.nl/</a>.
</p>


<h3>References</h3>

<p>Kojima, H. (1975). Inter-battery factor analysis of parents' and children's reports of 
parental behavior. Japanese Psychological Bulletin, 17, 33-48 (in Japanese).
</p>
<p>Kroonenberg, P. M. (2008). Applied multiway data analysis. Wiley series in probability and statistics. Wiley, Hoboken NJ.
</p>
<p>Kroonenberg, P. M., Harshman, R. A, &amp; Murakami, T. (2009). Analysing three-way profile data using 
the Parafac and Tucker3 models illustrated with views on parenting. Applied Multivariate 
Research, 13:5-41. PDF available at: http://www.phaenex.uwindsor.ca/ojs/leddy/index.php/AMR/article/viewFile/2833/2271
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Kojima)
    dim(Kojima.boys)
    dim(Kojima.girls)
</code></pre>

<hr>
<h2 id='krp'>The Khatri-Rao product of two matrices</h2><span id='topic+krp'></span>

<h3>Description</h3>

<p>The function <code>krp(A,B)</code> returns the Khatri-Rao product of two matrices <code>A</code> and <code>B</code>, of
dimensions I x K and J x K respectively. The result is an IJ x K matrix formed by the matching
column-wise Kronecker products, i.e. the k-th column of the Khatri-Rao product is
defined as <code>kronecker(A[, k], B[, k])</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krp(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krp_+3A_a">A</code></td>
<td>
<p>Matrix of order I x K.</p>
</td></tr>
<tr><td><code id="krp_+3A_b">B</code></td>
<td>
<p>Matrix of order J x K.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The IJ x K matrix of columnwise Kronecker products.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>Khatri, C. G., and Rao, C. Radhakrishna (1968).
Solutions to Some Functional Equations and Their Applications to Characterization of Probability Distributions.
Sankhya: Indian J. Statistics, Series A 30, 167-180.
</p>
<p>Smilde, A., Bro R. and Gelardi, P. (2004). Multi-way Analysis: Applications in Chemical Sciences, Chichester:Wiley
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:12, 3, 4)
b &lt;- diag(1:4)
krp(a, b)
krp(b, a)
</code></pre>

<hr>
<h2 id='mtrace'>The trace of a square numeric matrix</h2><span id='topic+mtrace'></span>

<h3>Description</h3>

<p>Computes the trace of a square numeric matrix. If <code>A</code> is not numeric and square matrix,
the function terminates with an error message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtrace(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtrace_+3A_a">A</code></td>
<td>
<p>A square numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sum of the values on the diagonal of the matrix <code>A</code>, i.e. <code>sum(diag(A))</code>.
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov, <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- matrix(c(5,2,3, 4,-3,7, 4,1,2), ncol=3))
(b &lt;- matrix(c(1,0,1, 0,1,2, 1,0,3), ncol=3))

mtrace(a)
mtrace(b)

## tr(A+B)=tr(A)+tr(B)
all.equal(mtrace(a) + mtrace(b), mtrace(a+b))

## tr(A)=tr(A')
all.equal(mtrace(a), mtrace(t(a)))

## tr(alphA)=alphatr(A)
alpha &lt;- 0.5
all.equal(mtrace(alpha*a), alpha*mtrace(a))

##  tr(AB)=tr(BA)
all.equal(mtrace(a %*% b), mtrace(b %*% a))


##  tr(A)=tr(BAB-1)
all.equal(mtrace(a), mtrace(b %*% a %*% solve(b)))
</code></pre>

<hr>
<h2 id='Parafac'>
Robust Parafac estimator for compositional data
</h2><span id='topic+Parafac'></span><span id='topic+print.parafac'></span>

<h3>Description</h3>

<p>Compute a robust Parafac model for compositional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Parafac(X, ncomp = 2, center = FALSE, 
    center.mode = c("A", "B", "C", "AB", "AC", "BC", "ABC"),
    scale=FALSE, scale.mode=c("B", "A", "C"), 
    const="none", conv = 1e-06, start="svd", maxit=10000, 
    optim=c("als", "atld", "int2"),
    robust = FALSE, coda.transform=c("none", "ilr", "clr"), 
    ncomp.rpca = 0, alpha = 0.75, robiter = 100, crit=0.975, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Parafac_+3A_x">X</code></td>
<td>
<p>3-way array of data</p>
</td></tr>
<tr><td><code id="Parafac_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of components</p>
</td></tr>
<tr><td><code id="Parafac_+3A_center">center</code></td>
<td>
<p>Whether to center the data</p>
</td></tr>
<tr><td><code id="Parafac_+3A_center.mode">center.mode</code></td>
<td>
<p>If centering the data, on which mode to do this</p>
</td></tr>
<tr><td><code id="Parafac_+3A_scale">scale</code></td>
<td>
<p>Whether to scale the data</p>
</td></tr>
<tr><td><code id="Parafac_+3A_scale.mode">scale.mode</code></td>
<td>
<p>If scaling the data, on which mode to do this</p>
</td></tr>
<tr><td><code id="Parafac_+3A_const">const</code></td>
<td>
<p>Optional constraints for each mode. Can be a three element character
vector or a single character, one of <code>"none"</code> for no constraints (default),
<code>"orth"</code> for orthogonality constraints, <code>"nonneg"</code> for nonnegativity constraints or
<code>"zerocor"</code> for zero correlation between the extracted factors. For example,
<code>const="orth"</code> means orthogonality constraints for all modes,
while <code>const=c("orth", "none", "none")</code> sets the orthogonality constraint
only for mode A.</p>
</td></tr>
<tr><td><code id="Parafac_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion, defaults to <code>1e-6</code></p>
</td></tr>
<tr><td><code id="Parafac_+3A_start">start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be <code>"svd"</code> 
for starting point of the algorithm from SVD's, <code>"random"</code> for random
starting point (orthonormalized component matrices or nonnegative matrices in
case of nonnegativity constraint), or a list containing user specified components.</p>
</td></tr>
<tr><td><code id="Parafac_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations, default is <code>maxit=10000</code>.</p>
</td></tr>
<tr><td><code id="Parafac_+3A_optim">optim</code></td>
<td>
<p>How to optimize the CP loss function, default is to use ALS, i.e. 
<code>optim="als"</code>. Other optins are ATLD (<code>optim="atld"</code>) and INT2 (<code>optim="INT2"</code>).
Please note that ATLD cannot be used with the robust option.</p>
</td></tr>
<tr><td><code id="Parafac_+3A_robust">robust</code></td>
<td>
<p>Whether to apply a robust estimation</p>
</td></tr>
<tr><td><code id="Parafac_+3A_coda.transform">coda.transform</code></td>
<td>
<p>If the data are a composition, use an <em>ilr</em> or <em>clr</em> transformation. 
Default is non-compositional data, i.e. <code>coda.transform="none"</code></p>
</td></tr>
<tr><td><code id="Parafac_+3A_ncomp.rpca">ncomp.rpca</code></td>
<td>
<p>Number of components for robust PCA</p>
</td></tr>
<tr><td><code id="Parafac_+3A_alpha">alpha</code></td>
<td>
<p>Measures the fraction of outliers the algorithm should
resist. Allowed values are between 0.5 and 1 and the default is 0.75</p>
</td></tr>
<tr><td><code id="Parafac_+3A_robiter">robiter</code></td>
<td>
<p>Maximal number of iterations for robust estimation</p>
</td></tr>
<tr><td><code id="Parafac_+3A_crit">crit</code></td>
<td>
<p>Cut-off for identifying outliers, default <code>crit=0.975</code></p>
</td></tr>
<tr><td><code id="Parafac_+3A_trace">trace</code></td>
<td>
<p>Logical, provide trace output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can compute four 
versions of the Parafac model: 
</p>

<ol>
<li><p> Classical Parafac,
</p>
</li>
<li><p> Parafac for compositional data,
</p>
</li>
<li><p> Robust Parafac and
</p>
</li>
<li><p> Robust Parafac for compositional data.
</p>
</li></ol>

<p>This is controlled though the paramters <code>robust=TRUE</code> and coda.transform=c(&quot;none&quot;, &quot;ilr&quot;).
</p>


<h3>Value</h3>

<p>An object of class &quot;parafac&quot; which is basically a list with components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Fit value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>Sum of squares</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Orthogonal loading matrix for the A-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Orthogonal loading matrix for the A-mode</p>
</td></tr>
<tr><td><code>Bclr</code></td>
<td>
<p>Orthogonal loading matrix for the B-mode, clr transformed. 
Available only if coda.transform=&quot;ilr&quot;, otherwise NULL</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Orthogonal loading matrix for the C-mode</p>
</td></tr>
<tr><td><code>Xhat</code></td>
<td>
<p>(Robustly) reconstructed array</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>Optional constraints (same as the input parameter)</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>rd</code></td>
<td>
<p>Residual distances</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Score distances</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>The observations whose residual distance <code>rd</code> is larger than <code>cutoff.rd</code> or 
score distance <code>sd</code> is larger than <code>cutoff.sd</code>, can be 
considered outliers and receive a flag equal to zero. 
The regular observations receive a flag 1</p>
</td></tr>
<tr><td><code>robust</code></td>
<td>
<p>The paramater <code>robust</code>, whether robust method is used or not</p>
</td></tr>    
<tr><td><code>coda.transform</code></td>
<td>
<p>Which coda transformation is used, can be <code>coda.transform=c("none", "ilr", "clr")</code>.</p>
</td></tr>    
</table>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and 
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>Harshman, R.A. (1970). Foundations of Parafac procedure: 
models and conditions for an &quot;explanatory&quot; multi-mode factor 
analysis. <em>UCLA Working Papers in Phonetics</em>, 16: 1&ndash;84.
</p>
<p>Engelen, S., Frosch, S. and Jorgensen, B.M. (2009). A fully 
robust PARAFAC method analyzing fluorescence data. 
<em>Journal of Chemometrics</em>, 23(3): 124&ndash;131.
</p>
<p>Kroonenberg, P.M. (1983).Three-mode principal component analysis: 
Theory and applications (Vol. 2), DSWO press.
</p>
<p>Rousseeuw, P.J. and Driessen, K.V. (1999). A fast algorithm for 
the minimum covariance determinant estimator. 
<em>Technometrics</em>, 41(3): 212&ndash;223.
</p>
<p>Egozcue J.J., Pawlowsky-Glahn V., Mateu-Figueras G. and 
Barcel'o-Vidal, C. (2003). Isometric logratio transformations 
for compositional data analysis. <em>Mathematical Geology</em>, 35(3): 279-300
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
##
## Example with the UNIDO Manufacturing value added data

data(va3way)
dim(va3way)

## Treat quickly and dirty the zeros in the data set (if any) 
va3way[va3way==0] &lt;- 0.001

## 
res &lt;- Parafac(va3way)
res
print(res$fit)
print(res$A)

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

data(ulabor)
res &lt;- Parafac(ulabor, robust=TRUE, coda.transform="ilr")
res

## Plot Orthonormalized A-mode component plot
plot(res, which="comp", mode="A", main="Component plot, A-mode")

## Plot Orthonormalized B-mode component plot
plot(res, which="comp", mode="B", main="Component plot, B-mode")

## Plot Orthonormalized C-mode component plot
plot(res, which="comp", mode="C", main="Component plot, C-mode")


</code></pre>

<hr>
<h2 id='permute'>Permutation of a matricized array</h2><span id='topic+permute'></span>

<h3>Description</h3>

<p>Permutes the matricized (<code>n</code> <code>x</code> <code>m</code> <code>x</code> <code>p</code>) array <code>X</code> to the 
matricized array <code>Y</code> of order (<code>m</code> <code>x</code> <code>p</code> <code>x</code> <code>n</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> permute(X,n,m,p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_x">X</code></td>
<td>
<p>Matrix (or data.frame coerced to a matrix) containing the matricized array</p>
</td></tr>
<tr><td><code id="permute_+3A_n">n</code></td>
<td>
<p>Number of <code>A</code>-mode entities of the array <code>X</code></p>
</td></tr>
<tr><td><code id="permute_+3A_m">m</code></td>
<td>
<p>Number of <code>B</code>-mode entities of the array <code>X</code></p>
</td></tr>
<tr><td><code id="permute_+3A_p">p</code></td>
<td>
<p>Number of <code>C</code>-mode entities of the array <code>X</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Y</code></td>
<td>
<p>Matrix containing the permuted matricized array</p>
</td></tr>
</table>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- array(1:24, c(4,3,2))
dim(X)

##  matricize the array
Xa &lt;- unfold(X)     # matricized X with the A-mode entities in its rows
dim(Xa)
Xa

## matricized X with the B-mode entities in its rows
Xb &lt;- permute(Xa, 4, 3, 2)
dim(Xb)
Xb

## matricized X with the C-mode entities in its rows
Xc &lt;- permute(Xb, 3, 2, 4)
dim(Xc)
Xc
</code></pre>

<hr>
<h2 id='plot.tucker3'> Plot a parafac or a tucker3 object
</h2><span id='topic+plot.tucker3'></span><span id='topic+plot.parafac'></span>

<h3>Description</h3>

<p>Different plots for the results of Parafac or Tucker3 analysis, stored in a 
<code>Parafac</code> or a <code>tucker3</code> object, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## S3 method for class 'tucker3'
plot(x, which = c("dd", "comp", "allcomp", "jbplot", 
    "tjplot", "all"), ask = (which == "all" &amp;&amp; dev.interactive(TRUE)), id.n, ...)
    ## S3 method for class 'parafac'
plot(x, which = c("dd", "comp", "percomp", "allcomp", 
    "all"), ask = (which == "all" &amp;&amp; dev.interactive(TRUE)), id.n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tucker3_+3A_x">x</code></td>
<td>
<p>A <code>tucker3</code> object</p>
</td></tr>
<tr><td><code id="plot.tucker3_+3A_which">which</code></td>
<td>
<p>Which plot to select (see Details). Default is <code>dd</code>, distance-distance plot.</p>
</td></tr>
<tr><td><code id="plot.tucker3_+3A_ask">ask</code></td>
<td>
<p>Generates all plots in interactive mode</p>
</td></tr>
<tr><td><code id="plot.tucker3_+3A_id.n">id.n</code></td>
<td>
<p>Number of items to highlight</p>
</td></tr>
<tr><td><code id="plot.tucker3_+3A_...">...</code></td>
<td>
<p>Other parameters to be passed to the lower level functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different plots for a <code>tucker3</code> or <code>parafac</code> object will be produced. Use the parameter 
<code>which</code> to select which plot to produce:
</p>

<dl>
<dt><code>dd</code></dt><dd><p>Distance-distance plot</p>
</dd>
<dt><code>comp</code></dt><dd><p>Paired components plot</p>
</dd>
<dt><code>percomp</code></dt><dd><p>Per-component plot - only for Parafac</p>
</dd>
<dt><code>allcomp</code></dt><dd><p>All components plot</p>
</dd>
<dt><code>jbplot</code></dt><dd><p>Joint biplot - only for Tucker3</p>
</dd>
<dt><code>tjplot</code></dt><dd><p>Trajectory plot - only for Tucker3</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and 
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>Kiers, H.A. (2000).Some procedures for displaying results from three-way methods. 
<em>Journal of Chemometrics</em>. 14(3): 151-170.
</p>
<p>Kroonenberg, P.M. (1983).Three-mode principal component analysis: 
Theory and applications (Vol. 2), DSWO press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
##
## Example with the UNIDO Manufacturing value added data

data(va3way)
dim(va3way)

## Treat quickly and dirty the zeros in the data set (if any)
va3way[va3way==0] &lt;- 0.001

##
res &lt;- Tucker3(va3way)
res
print(res$fit)
print(res$A)

## Print the core matrix
print(res$GA)

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)")

## Joint biplot
plot(res, which="jbplot", main="Joint biplot")

## Trajectory
plot(res, which="tjplot", choices=c(1:4), arrows=FALSE, main="Trajectory biplot")

</code></pre>

<hr>
<h2 id='toArray'>
Matrix to array conversion
</h2><span id='topic+toArray'></span>

<h3>Description</h3>

<p>Restore an array from its matricization with all the frontal slices of the array next to each other (mode=&quot;A&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toArray(x, n, m, r, mode = c("A", "B", "C"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toArray_+3A_x">x</code></td>
<td>
<p> Matrix (or data.frame coerced to a matrix) containing the elements of the frontal slices of an array</p>
</td></tr>
<tr><td><code id="toArray_+3A_n">n</code></td>
<td>
<p>number of A-mode elements</p>
</td></tr>
<tr><td><code id="toArray_+3A_m">m</code></td>
<td>
<p>number of B-mode elements</p>
</td></tr>
<tr><td><code id="toArray_+3A_r">r</code></td>
<td>
<p>number of C-mode elements</p>
</td></tr>
<tr><td><code id="toArray_+3A_mode">mode</code></td>
<td>
<p>in which mode is the matricized array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three way array
</p>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis.  <em>Journal of Chemometrics</em>, 14: 105&ndash;122.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(elind)
    di &lt;- dim(elind)
    toArray(unfold(elind), di[1], di[2], di[3])
</code></pre>

<hr>
<h2 id='Tucker3'>
Robust Tucker3 estimator for compositional data
</h2><span id='topic+Tucker3'></span><span id='topic+print.tucker3'></span>

<h3>Description</h3>

<p>Compute a robust Tucker3 model for compositional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tucker3(X, P = 2, Q = 2, R = 2, 
    center = FALSE, center.mode = c("A", "B", "C", "AB", "AC", "BC", "ABC"), 
    scale = FALSE, scale.mode = c("B", "A", "C"), 
    conv = 1e-06, start="svd",
    robust = FALSE, coda.transform=c("none", "ilr", "clr"), 
    ncomp.rpca = 0, alpha = 0.75, robiter=100, crit=0.975, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tucker3_+3A_x">X</code></td>
<td>
<p>3-way array of data</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_p">P</code></td>
<td>
<p>Number of A-mode components</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_q">Q</code></td>
<td>
<p>Number of B-mode components</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_r">R</code></td>
<td>
<p>Number of C-mode components</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_center">center</code></td>
<td>
<p>Whether to center the data</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_center.mode">center.mode</code></td>
<td>
<p>If scaling the data, on which mode to do this</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_scale">scale</code></td>
<td>
<p>Whether to scale the data</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_scale.mode">scale.mode</code></td>
<td>
<p>If centering the data, on which mode to do this</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion, defaults to <code>1e-6</code></p>
</td></tr>
<tr><td><code id="Tucker3_+3A_start">start</code></td>
<td>
<p>Initial values for the A, B and C components. Can be <code>"svd"</code> 
for starting point of the algorithm from SVD's, <code>"random"</code> for random
starting point (orthonormalized component matrices), or a list containing user specified components.</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_robust">robust</code></td>
<td>
<p>Whether to apply a robust estimation</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_coda.transform">coda.transform</code></td>
<td>
<p>If the data are a composition, use an <em>ilr</em> or <em>clr</em> transformation. 
Default is non-compositional data, i.e. <code>coda.transform="none"</code></p>
</td></tr>
<tr><td><code id="Tucker3_+3A_ncomp.rpca">ncomp.rpca</code></td>
<td>
<p>Number of components for robust PCA</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_alpha">alpha</code></td>
<td>
<p>Measures the fraction of outliers the algorithm should
resist. Allowed values are between 0.5 and 1 and the default is 0.75</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_robiter">robiter</code></td>
<td>
<p>Maximal number of iterations for robust estimation</p>
</td></tr>
<tr><td><code id="Tucker3_+3A_crit">crit</code></td>
<td>
<p>Cut-off for identifying outliers, default <code>crit=0.975</code></p>
</td></tr>
<tr><td><code id="Tucker3_+3A_trace">trace</code></td>
<td>
<p>Logical, provide trace output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can compute four
versions of the Tucker3 model:
</p>

<ol>
<li><p> Classical Tucker3,
</p>
</li>
<li><p> Tucker3 for compositional data,
</p>
</li>
<li><p> Robust Tucker3 and
</p>
</li>
<li><p> Robust Tucker3 for compositional data.
</p>
</li></ol>

<p>This is controlled through the parameters <code>robust=TRUE</code> and <code>coda.transform="ilr"</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;tucker3&quot; which is basically a list with components:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>Fit value</p>
</td></tr>
<tr><td><code>fp</code></td>
<td>
<p>Fit percentage</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Orthogonal loading matrix for the A-mode</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Orthogonal loading matrix for the B-mode</p>
</td></tr>
<tr><td><code>Bclr</code></td>
<td>
<p>Orthogonal loading matrix for the B-mode, clr transformed.
Available only if <code>coda.transform="ilr"</code>, otherwise NULL</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Orthogonal loading matrix for the C-mode</p>
</td></tr>
<tr><td><code>GA</code></td>
<td>
<p>Core matrix, which describes the relation between <code>A</code>, <code>B</code> and <code>C</code>,
unfolded in A-form. The largest squared elements of the core matrix indicate the
most important factors in the model of <code>X</code>.</p>
</td></tr>    
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>rd</code></td>
<td>
<p>Residual distances</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Score distances</p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>The observations whose residual distance <code>RD</code> is larger than cutoff.RD can be
considered as outliers and receive a flag equal to zero.
The regular observations receive a flag 1</p>
</td></tr>
<tr><td><code>robust</code></td>
<td>
<p>The paramater <code>robust</code>, whether robust method is used or not</p>
</td></tr>    
<tr><td><code>coda.transform</code></td>
<td>
<p>The input paramater <code>coda.transform</code>, what trnasofrmation for compositional data was used</p>
</td></tr>    
<tr><td><code>La</code></td>
<td>
<p>Diagonal matrix containing the <em>intrinsic eigenvalues</em> for A-mode</p>
</td></tr>
<tr><td><code>Lb</code></td>
<td>
<p>Diagonal matrix containing the <em>intrinsic eigenvalues</em> for B-mode</p>
</td></tr>
<tr><td><code>Lc</code></td>
<td>
<p>Diagonal matrix containing the <em>intrinsic eigenvalues</em> for C-mode</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a> and
Maria Anna Di Palma <a href="mailto:madipalma@unior.it">madipalma@unior.it</a> and
Michele Gallo <a href="mailto:mgallo@unior.it">mgallo@unior.it</a>
</p>


<h3>References</h3>

<p>Tucker, L.R. (1966). Some mathematical notes on three-mode 
factor analysis. <em>Psychometrika</em>, 31: 279&ndash;311.
</p>
<p>Egozcue J.J., Pawlowsky-Glahn, V.,  Mateu-Figueras G. and 
Barcel'o-Vidal, C. (2003). Isometric logratio transformations 
for compositional data analysis. <em>Mathematical Geology</em>, 35(3): 279&ndash;300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
##
## Example with the UNIDO Manufacturing value added data

data(va3way)
dim(va3way)

## Treat quickly and dirty the zeros in the data set (if any)
va3way[va3way==0] &lt;- 0.001

##
res &lt;- Tucker3(va3way)
res
print(res$fit)
print(res$A)

## Print the core matrix
print(res$GA)

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)")

## Joint biplot
plot(res, which="jbplot", main="Joint biplot")

## Trajectory
plot(res, which="tjplot", choices=c(1:4), arrows=FALSE, main="Trajectory biplot")

</code></pre>

<hr>
<h2 id='ulabor'>
Undeclared labor by region in Italy
</h2><span id='topic+ulabor'></span>

<h3>Description</h3>

<p>The dataset contains the undeclared labor in thousands work units. The data
originate from Italy and are recorded at a regional level over a certain 
time horizon for five macroeconomic activities defined according to 
NACE Rev. 1.1 classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ulabor")</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension 22x5x5. The first dimension 
refers to 22 regions in Italy. The second dimension refers to 
the 5 economic activities. The third dimension refers to 
the years in the period 2001-2009.
</p>


<h3>Source</h3>

<p>ISTAT (2011). Note metodologiche, la misura dell'occupazione non 
regolare nelle stime di contabilita nazionale [online]. Roma. 

</p>


<h3>References</h3>

<p>ISTAT (2011). Note metodologiche, la misura dell'occupazione non 
regolare nelle stime di contabilita nazionale [online]. Roma. 

</p>
<p>Di Palma M.A., Filzmoser P., Gallo M. and Hron, K. (2016). 
A robust CP model for compositional data, submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ulabor)
dim(ulabor)
str(ulabor)

## Plot robust and non-robust DD-plots of the ilr-transformed data
usr &lt;- par(mfrow=c(1,2))
res1 &lt;- Parafac(ulabor, robust=TRUE, coda.transform="ilr")
res2 &lt;- Parafac(ulabor, coda.transform="ilr")
plot(res1)
plot(res2)
par(usr)

## Not run: 

## Plot Orthonormalized A-mode component plot
res &lt;- Parafac(ulabor, robust=TRUE, coda.transform="ilr")
plot(res, which="comp", mode="A", main="Component plot, A-mode")

## Plot Orthonormalized B-mode component plot
plot(res, which="comp", mode="B", main="Component plot, B-mode")

## Plot Orthonormalized B-mode component plot
plot(res, which="comp", mode="C", main="Component plot, C-mode")


## Per component plot
## adapted for the example and only for robust, ilr transformed model
##
##
res &lt;- Parafac(ulabor, robust=TRUE, coda.transform="ilr")

plot(res, which="percomp")              # component 1
plot(res, which="percomp", comp=2)      # component 2

## End(Not run)
</code></pre>

<hr>
<h2 id='unfold'>Matrix unfolding</h2><span id='topic+unfold'></span>

<h3>Description</h3>

<p>Conducts matricizations of a three-way array into matrices according to the selected mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    unfold(x, mode=c("A", "B", "C"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold_+3A_x">x</code></td>
<td>
<p>Array to be unfolded</p>
</td></tr>
<tr><td><code id="unfold_+3A_mode">mode</code></td>
<td>
<p>the selected mode for unfolding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix represnting the input array, according to the selected mode:
</p>

<ul>
<li><p> Mode=A: <code>B</code>-mode entities are nested within <code>C</code>-mode entities (all the frontal slices of the array next to each other)
item Mode=B: <code>C</code>-mode entities nested within <code>A</code>-mode entities (all the horizontal slices of the array next to each other)
item Mode C: <code>A</code>-mode entities nested within <code>B</code>-mode entities (all the lateral slices of the array next to each other)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Valentin Todorov <a href="mailto:valentin.todorov@chello.at">valentin.todorov@chello.at</a>
</p>


<h3>References</h3>

<p>H.A.L. Kiers (2000). Towards a standardized notation and terminology in multiway analysis. <em>Journal of Chemometrics 14:105&ndash;122</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(X &lt;- array(1:24, c(4,3,2)))
dim(X)

## matricize the array

##  matricized X with the A-mode entities in its rows
##  all the frontal slices of the array next to each other
##
(Xa &lt;- unfold(X))
dim(Xa)

## matricized X with the B-mode entities in its rows
##  all the horizontal slices of the array next to each other
##
(Xb &lt;- unfold(X, mode="B"))
dim(Xb)

## matricized X with the C-mode entities in its rows
##  all the lateral slices of the array next to each other
##
(Xc &lt;- unfold(X, mode="C"))
dim(Xc)
</code></pre>

<hr>
<h2 id='va3way'>
Manufacturing value added by technology intensity for several years
</h2><span id='topic+va3way'></span>

<h3>Description</h3>

<p>A three-way array containing manufacturing value added by 
technology intensity for 55 countries in the period 2000&ndash;2010.
UNIDO maintains a unique database containing key industrial 
statistics indicators for more than 160 countries in the 
world in the period 1963-2011: INDSTAT 2, available at 
<a href="https://stat.unido.org">https://stat.unido.org</a>. The data are organized according 
to the International Standard Industrial Classification of all 
economic activities (ISIC) Revision 3 at 2-digit level. The present data 
set was created by aggregating the 23 2-digit divisions into five groups 
according to technology intensity, 
using the UNIDO derived classification (Upadhyaya, 2011). Then 55 countries were
selected which have relatively complete data in the period 2000&ndash;2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(va3way)</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension 55x5x11. 
The first dimension refers to 55 countries. 
The second dimension refers to the five categories of technology intensity 
described above. 
The third dimension refers to the years in the period 2000&ndash;2010.
</p>


<h3>Details</h3>

<p>Note that the values in the second mode (sectors) sum up to 
a constant - the total manufacturing value added of a country 
in a given year and thus the data set has a compositional character.
</p>


<h3>Source</h3>

<p><a href="https://stat.unido.org">https://stat.unido.org</a>
</p>


<h3>References</h3>

<p>Upahdyaya S (2011). Derived classifications for industrial performance indicators.
In <em>Int. Statistical Inst.: Proc. 58th World Statistical Congress, 
2011, Dublin (Session STS022)</em>.
</p>
<p>Upadhyaya S, Todorov V (2008). UNIDO Data Quality. UNIDO Staff Working Paper, Vienna.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(va3way)
ct &lt;- 2
x &lt;- va3way[ct,,]/1000000
plot(colnames(x), x[1,], ylim=c(min(x), max(x)), type="n", ylab="Manufacturing Value 
    Added in million USD", xlab="Years")
for(i in 1:nrow(x))
    lines(colnames(x), x[i,], col=i)
legend("topleft", legend=rownames(x), col=1:nrow(x), lwd=1)
title(paste("Coutnry: ", rownames(va3way[,,1])[ct]))


## Treat quickly and dirty the zeros in the data set (if any) 
## in order to be able to perform ilr transformation:

va3way[va3way==0] &lt;- 0.001

res &lt;- Tucker3(va3way)

##
## Not yet a print function
##
print(res$fit)
print(res$A)

## Print the core matrix
print(res$GA)

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")

## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)") 

## Joint biplot
plot(res, which="jbplot", main="Joint biplot") 

## Trajectory
plot(res, which="tjplot", main="Trajectory biplot") 

</code></pre>

<hr>
<h2 id='waterquality'>
Water quality data in Wyoming, USA
</h2><span id='topic+waterquality'></span>

<h3>Description</h3>

<p>Water quality data for three years of seasonal compositional groundwater 
chemistry data for 14 wells at a study site in Wyoming, USA. 
Routine water quality monitoring typically involves measurement of J parameters and 
constituents measured at I number of static locations at K sets of seasonal occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("waterquality")</code></pre>


<h3>Format</h3>

<p>A three-way array with dimension 14x12x10. 
The first dimension refers to 14 wells at a study site in Wyoming, USA. 
The second dimension refers to the ten most reactive and indicative dissolved
constituents at the site: B, Ba, Ca, Cl, K, Mg, Na, Si, Sr, and SO4. In addition,
the concentration of water in each sample was calculated. 
The third dimension refers to the time of collection - ten occasions.
</p>


<h3>References</h3>

<p>Engle, M.A., Gallo, M., Schroeder, K.T., Geboy, N.J., Zupancic, J.W., (2014). 
Three-way compositional analysis of water quality monitoring data. 
<em>Environmental and Ecological Statistics</em>, 21(3):565-581.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterquality)
dim(waterquality)               # [1] 14 12 10
dim(waterquality[,,1])          # [1] 14 12
rownames(waterquality[,,1])     # the 14 wells
colnames(waterquality[,,1])     # the 12 chemical compositions
dim(waterquality[,1,])          # [1] 14 10
colnames(waterquality[,1,])     # the ten occasions

(res &lt;- Tucker3(waterquality, robust=FALSE, coda.transform="ilr"))

## Distance-distance plot
plot(res, which="dd", main="Distance-distance plot")
## Paired component plot, mode A
plot(res, which="comp", main="Paired component plot (mode A)")

## Paired component plot, mode B
plot(res, which="comp", mode="B", main="Paired component plot (mode B)") 

## Joint biplot
plot(res, which="jbplot", main="Joint biplot") 

## Trajectory
plot(res, which="tjplot", main="Trajectory biplot") 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
