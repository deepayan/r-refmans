<!DOCTYPE html><html><head><title>Help for package sure</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sure}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoplot.resid'><p>Residual Plots for Cumulative Link and General Regression Models</p></a></li>
<li><a href='#df1'><p>Simulated Quadratic Data</p></a></li>
<li><a href='#df2'><p>Simulated Heteroscedastic Data</p></a></li>
<li><a href='#df3'><p>Simulated Gumbel Data</p></a></li>
<li><a href='#df4'><p>Simulated Proportionality Data</p></a></li>
<li><a href='#df5'><p>Simulated Interaction Data</p></a></li>
<li><a href='#getFittedProbs'><p>#' @keywords internal</p>
getFittedValues &lt;- function(object)
UseMethod(&quot;getFittedValues&quot;)</a></li>
<li><a href='#gof'><p>Goodness-of-Fit Simulation</p></a></li>
<li><a href='#grid.arrange'><p>Arrange multiple grobs on a page</p></a></li>
<li><a href='#resids'><p>Surrogate Residuals</p></a></li>
<li><a href='#sure'><p>sure: An R package for constructing surrogate-based residuals and diagnostics</p>
for ordinal and general regression models.</a></li>
<li><a href='#surrogate'><p>Surrogate Response</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Surrogate Residuals for Ordinal and General Regression Models</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the surrogate approach to residuals and 
  diagnostics for ordinal and general regression models; for details, see Liu 
  and Zhang (2017) &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1292915">doi:10.1080/01621459.2017.1292915</a>&gt;. These residuals can be 
  used to construct standard residual plots for model diagnostics (e.g., 
  residual-vs-fitted value plots, residual-vs-covariate plots, Q-Q plots, etc.). 
  The package also provides an 'autoplot' function for producing standard 
  diagnostic plots using 'ggplot2' graphics. The package currently supports 
  cumulative link models from packages 'MASS', 'ordinal', 'rms', and 'VGAM'. 
  Support for binary regression models using the standard 'glm' function is also 
  available.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 2.2.1), goftest, gridExtra, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, ordinal, rms, testthat, VGAM</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AFIT-R/sure">https://github.com/AFIT-R/sure</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AFIT-R/sure/issues">https://github.com/AFIT-R/sure/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-09-19 15:41:08 UTC; greenweb</td>
</tr>
<tr>
<td>Author:</td>
<td>Brandon Greenwell [aut, cre],
  Andrew McCarthy [aut],
  Brad Boehmke [aut],
  Dungang Liu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brandon Greenwell &lt;greenwell.brandon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-09-19 18:04:46 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoplot.resid'>Residual Plots for Cumulative Link and General Regression Models</h2><span id='topic+autoplot.resid'></span><span id='topic+autoplot.clm'></span><span id='topic+autoplot.glm'></span><span id='topic+autoplot.lrm'></span><span id='topic+autoplot.orm'></span><span id='topic+autoplot.polr'></span><span id='topic+autoplot.vgam'></span><span id='topic+autoplot.vglm'></span>

<h3>Description</h3>

<p>Residual-based diagnostic plots for cumulative link and general regression
models using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.resid(object, what = c("qq", "fitted", "covariate"), x = NULL,
  fit = NULL, distribution = qnorm, alpha = 1, xlab = NULL,
  color = "#444444", shape = 19, size = 2, qqpoint.color = "#444444",
  qqpoint.shape = 19, qqpoint.size = 2, qqline.color = "#888888",
  qqline.linetype = "dashed", qqline.size = 1, smooth = TRUE,
  smooth.color = "red", smooth.linetype = 1, smooth.size = 1,
  fill = NULL, ...)

autoplot.clm(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)

autoplot.glm(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)

autoplot.lrm(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)

autoplot.orm(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)

autoplot.polr(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)

autoplot.vgam(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)

autoplot.vglm(object, what = c("qq", "fitted", "covariate"), x = NULL,
  alpha = 1, xlab = NULL, color = "#444444", shape = 19, size = 2,
  qqpoint.color = "#444444", qqpoint.shape = 19, qqpoint.size = 2,
  qqline.color = "#888888", qqline.linetype = "dashed", qqline.size = 1,
  smooth = TRUE, smooth.color = "red", smooth.linetype = 1,
  smooth.size = 1, fill = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.resid_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>, or <code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_what">what</code></td>
<td>
<p>Character string specifying what to plot. Default is <code>"qq"</code>
which produces a quantile-quantile plots of the residuals.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_x">x</code></td>
<td>
<p>A vector giving the covariate values to use for residual-by-
covariate plots (i.e., when <code>what = "covariate"</code>).</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_fit">fit</code></td>
<td>
<p>The fitted model from which the residuals were extracted. (Only
required if <code>what = "fitted"</code> and <code>object</code> inherits from class
<code>"resid"</code>.)</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_distribution">distribution</code></td>
<td>
<p>Function that computes the quantiles for the reference
distribution to use in the quantile-quantile plot. Default is <code>qnorm</code>
which is only appropriate for models using a probit link function. When
<code>jitter.scale = "probability"</code>, the reference distribution is always
U(-0.5, 0.5). (Only
required if <code>object</code> inherits from class <code>"resid"</code>.)</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_alpha">alpha</code></td>
<td>
<p>A single values in the interval [0, 1] controlling the opacity
alpha of the plotted points. Only used when <code>nsim</code> &gt; 1.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_xlab">xlab</code></td>
<td>
<p>Character string giving the text to use for the x-axis label in
residual-by-covariate plots. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_color">color</code></td>
<td>
<p>Character string or integer specifying what color to use for the
points in the residual vs fitted value/covariate plot.
Default is <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_shape">shape</code></td>
<td>
<p>Integer or single character specifying a symbol to be used for
plotting the points in the residual vs fitted value/covariate plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_size">size</code></td>
<td>
<p>Numeric value specifying the size to use for the points in the
residual vs fitted value/covariate plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_qqpoint.color">qqpoint.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_qqpoint.shape">qqpoint.shape</code></td>
<td>
<p>Integer or single character specifying a symbol to be
used for plotting the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_qqpoint.size">qqpoint.size</code></td>
<td>
<p>Numeric value specifying the size to use for the points
in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_qqline.color">qqline.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the points in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_qqline.linetype">qqline.linetype</code></td>
<td>
<p>Integer or character string (e.g., <code>"dashed"</code>)
specifying the type of line to use in the quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_qqline.size">qqline.size</code></td>
<td>
<p>Numeric value specifying the thickness of the line in the
quantile-quantile plot.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_smooth">smooth</code></td>
<td>
<p>Logical indicating whether or not too add a nonparametric
smooth to certain plots. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_smooth.color">smooth.color</code></td>
<td>
<p>Character string or integer specifying what color to use
for the nonparametric smooth.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_smooth.linetype">smooth.linetype</code></td>
<td>
<p>Integer or character string (e.g., <code>"dashed"</code>)
specifying the type of line to use for the nonparametric smooth.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_smooth.size">smooth.size</code></td>
<td>
<p>Numeric value specifying the thickness of the line for the
nonparametric smooth.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_fill">fill</code></td>
<td>
<p>Character string or integer specifying the color to use to fill
the boxplots for residual-by-covariate plots when <code>x</code> is of class
<code>"factor"</code>. Default is <code>NULL</code> which colors the boxplots according
to the factor levels.</p>
</td></tr>
<tr><td><code id="autoplot.resid_+3A_...">...</code></td>
<td>
<p>Additional optional arguments to be passed onto
<code><a href="#topic+resids">resids</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"ggplot"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?resids for an example
?resids
</code></pre>

<hr>
<h2 id='df1'>Simulated Quadratic Data</h2><span id='topic+df1'></span>

<h3>Description</h3>

<p>Data simulated from a probit model with a quadratic trend. The data are
described in Example 2 of Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(df1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 2 variables.
</p>

<ul>
<li> <p><code>y</code> The response variable; an ordered factor.
</p>
</li>
<li> <p><code>x</code> The predictor variable.
</p>
</li></ul>


<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(df1)
</code></pre>

<hr>
<h2 id='df2'>Simulated Heteroscedastic Data</h2><span id='topic+df2'></span>

<h3>Description</h3>

<p>Data simulated from a probit model with heteroscedasticity. The data are
described in Example 4 of Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(df2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 2 variables.
</p>

<ul>
<li> <p><code>y</code> The response variable; an ordered factor.
</p>
</li>
<li> <p><code>x</code> The predictor variable.
</p>
</li></ul>


<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(df2)
</code></pre>

<hr>
<h2 id='df3'>Simulated Gumbel Data</h2><span id='topic+df3'></span>

<h3>Description</h3>

<p>Data simulated from a log-log model with a quadratic trend. The data are
described in Example 3 of Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(df3)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 2 variables.
</p>

<ul>
<li> <p><code>y</code> The response variable; an ordered factor.
</p>
</li>
<li> <p><code>x</code> The predictor variable.
</p>
</li></ul>


<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(df3)
</code></pre>

<hr>
<h2 id='df4'>Simulated Proportionality Data</h2><span id='topic+df4'></span>

<h3>Description</h3>

<p>Data simulated from two separate ordered probit models with different
coefficients. The data are described in Example 5 of Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(df4)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 2 variables.
</p>

<ul>
<li> <p><code>y</code> The response variable; an ordered factor.
</p>
</li>
<li> <p><code>x</code> The predictor variable.
</p>
</li></ul>


<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(df4)
</code></pre>

<hr>
<h2 id='df5'>Simulated Interaction Data</h2><span id='topic+df5'></span>

<h3>Description</h3>

<p>Data simulated from an ordered probit model with an interaction term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(df5)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 3 variables.
</p>

<ul>
<li> <p><code>y</code> The response variable; an ordered factor.
</p>
</li>
<li> <p><code>x1</code> A continuous predictor.
</p>
</li>
<li> <p><code>x2</code> A factor with two levels: <code>Control</code> and
<code>Treatment</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>head(df5)
</code></pre>

<hr>
<h2 id='getFittedProbs'>#' @keywords internal
getFittedValues &lt;- function(object) 
UseMethod(&quot;getFittedValues&quot;)
</h2><span id='topic+getFittedProbs'></span>

<h3>Description</h3>

<p>#' @keywords internal
getFittedValues &lt;- function(object) 
UseMethod(&quot;getFittedValues&quot;)

</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFittedProbs(object)
</code></pre>

<hr>
<h2 id='gof'>Goodness-of-Fit Simulation</h2><span id='topic+gof'></span><span id='topic+gof.default'></span><span id='topic+plot.gof'></span>

<h3>Description</h3>

<p>Simulate p-values from a goodness-of-fit test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, nsim = 10, test = c("ks", "ad", "cvm"), ...)

## Default S3 method:
gof(object, nsim = 10, test = c("ks", "ad", "cvm"), ...)

## S3 method for class 'gof'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>, or <code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_nsim">nsim</code></td>
<td>
<p>Integer specifying the number of bootstrap replicates to use.</p>
</td></tr>
<tr><td><code id="gof_+3A_test">test</code></td>
<td>
<p>Character string specifying which goodness-of-fit test to use.
Current options include: <code>"ks"</code> for the Kolmogorov-Smirnov test,
<code>"ad"</code> for the Anderson-Darling test, and <code>"cvm"</code> for the
Cramer-Von Mises test. Default is <code>"ks"</code>.</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. (Currently ignored.)</p>
</td></tr>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>An object of class <code>"gof"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the null hypothesis, the distribution of the p-values should appear
uniformly distributed on the interval [0, 1]. This can be visually
investigated using the <code>plot</code> method. A 45 degree line is indicative of
a &quot;good&quot; fit.
</p>


<h3>Value</h3>

<p>A numeric vector of class <code>"gof", "numeric"</code> containing the
simulated p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?resids for an example
?resids
</code></pre>

<hr>
<h2 id='grid.arrange'>Arrange multiple grobs on a page</h2><span id='topic+grid.arrange'></span>

<h3>Description</h3>

<p>See <code><a href="gridExtra.html#topic+grid.arrange">grid.arrange</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.arrange(..., newpage = TRUE)
</code></pre>

<hr>
<h2 id='resids'>Surrogate Residuals</h2><span id='topic+resids'></span><span id='topic+resids.default'></span>

<h3>Description</h3>

<p>Surrogate-based residuals for cumulative link and general regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resids(object, ...)

## Default S3 method:
resids(object, method = c("latent", "jitter"),
  jitter.scale = c("probability", "response"), nsim = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resids_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>,
<code><a href="MASS.html#topic+polr">polr</a></code>, <code><a href="VGAM.html#topic+vgam">vgam</a></code> (jittering only), or
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="resids_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. (Currently ignored.)</p>
</td></tr>
<tr><td><code id="resids_+3A_method">method</code></td>
<td>
<p>Character string specifying the type of surrogate to use; for
details, see Liu and Zhang (2017). Can be one of <code>"latent"</code> or
<code>"jitter"</code>.</p>
</td></tr>
<tr><td><code id="resids_+3A_jitter.scale">jitter.scale</code></td>
<td>
<p>Character string specifying the scale on which to perform
the jittering. Should be one of <code>"probability"</code> or <code>"response"</code>.
(Currently ignored for cumulative link models.)</p>
</td></tr>
<tr><td><code id="resids_+3A_nsim">nsim</code></td>
<td>
<p>Integer specifying the number of bootstrap replicates to use.
Default is <code>1L</code> meaning no bootstrap samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of class <code>c("numeric", "resid")</code> containing the
residuals. Additionally, if <code>nsim</code> &gt; 1, then the result will contain the
attributes:
</p>

<dl>
<dt><code>boot.reps</code></dt><dd><p>A matrix  with <code>nsim</code> columns, one for each
bootstrap replicate of the residuals. Note, these are random and do not
correspond to the original ordering of the data;</p>
</dd>
<dt><code>boot.id</code></dt><dd><p>A matrix  with <code>nsim</code> columns. Each column
contains the observation number each residual corresponds to in
<code>boot.reps</code>. (This is used for plotting purposes.)</p>
</dd>
</dl>



<h3>Note</h3>

<p>Surrogate residuals require sampling from a continuous distribution;
consequently, the result will be different with every call to <code>resids</code>.
The internal functions used for sampling from truncated distributions when
<code>method = "latent"</code> are based on modified versions of
<code><a href="truncdist.html#topic+rtrunc">rtrunc</a></code> and <code><a href="truncdist.html#topic+qtrunc">qtrunc</a></code>.
</p>


<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted). URL
http://www.tandfonline.com/doi/abs/10.1080/01621459.2017.1292915?journalCode=uasa20
</p>
<p>Nadarajah, Saralees and Kotz, Samuel. R Programs for Truncated Distributions.
<em>Journal of Statistical Software, Code Snippet</em>, 16(2), 1-8, 2006. URL
https://www.jstatsoft.org/v016/c02.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Residuals for binary GLMs using the jittering method
#

# Load the MASS package (for the polr function)
library(MASS)

# Simulated probit data with quadratic trend
data(df1)

# Fit logistic regression models (with and without quadratic trend)
fit1 &lt;- polr(y ~ x + I(x ^ 2), data = df1, method = "probit")
fit2 &lt;- polr(y ~ x, data = df1, method = "probit")

# Construct residuals
set.seed(102)  # for reproducibility
res1 &lt;- resids(fit1)
res2 &lt;- resids(fit2)

# Residual-vs-covariate plots
par(mfrow = c(1, 2))
scatter.smooth(df1$x, res1, lpars = list(lwd = 2, col = "red"),
               xlab = expression(x), ylab = "Surrogate residual",
               main = "Correct model")
scatter.smooth(df1$x, res2, lpars = list(lwd = 2, col = "red"),
               xlab = expression(x), ylab = "Surrogate residual",
               main = "Incorrect model")

## Not run: 
#
# Residuals for cumulative link models using the latent method
#

# Load required packages
library(ggplot2)  # for autoplot function
library(MASS)     # for polr function
library(ordinal)  # for clm function

#
# Detecting a misspecified mean structure
#

# Data simulated from a probit model with a quadratic trend
data(df1)
?df1

# Fit a probit model with/without a quadratic trend
fit.bad &lt;- polr(y ~ x, data = df1, method = "probit")
fit.good &lt;- polr(y ~ x + I(x ^ 2), data = df1, method = "probit")

# Some residual plots
p1 &lt;- autoplot(fit.bad, what = "covariate", x = df1$x)
p2 &lt;- autoplot(fit.bad, what = "qq")
p3 &lt;- autoplot(fit.good, what = "covariate", x = df1$x)
p4 &lt;- autoplot(fit.good, what = "qq")

# Display all four plots together (top row corresponds to bad model)
grid.arrange(p1, p2, p3, p4, ncol = 2)

#
# Detecting heteroscedasticity
#

# Data simulated from a probit model with heteroscedasticity.
data(df2)
?df2

# Fit a probit model with/without a quadratic trend
fit &lt;- polr(y ~ x, data = df2, method = "probit")

# Some residual plots
p1 &lt;- autoplot(fit, what = "covariate", x = df1$x)
p2 &lt;- autoplot(fit, what = "qq")
p3 &lt;- autoplot(fit, what = "fitted")

# Display all three plots together
grid.arrange(p1, p2, p3, ncol = 3)

#
# Detecting a misspecified link function
#

# Data simulated from a log-log model with a quadratic trend.
data(df3)
?df3

# Fit models with correctly specified link function
clm.loglog &lt;- clm(y ~ x + I(x ^ 2), data = df3, link = "loglog")
polr.loglog &lt;- polr(y ~ x + I(x ^ 2), data = df3, method = "loglog")

# Fit models with misspecified link function
clm.probit &lt;- clm(y ~ x + I(x ^ 2), data = df3, link = "probit")
polr.probit &lt;- polr(y ~ x + I(x ^ 2), data = df3, method = "probit")

# Q-Q plots of the residuals (with bootstrapping)
p1 &lt;- autoplot(clm.probit, nsim = 50, what = "qq") +
  ggtitle("clm: probit link")
p2 &lt;- autoplot(clm.loglog, nsim = 50, what = "qq") +
  ggtitle("clm: log-log link (correct link function)")
p3 &lt;- autoplot(polr.probit, nsim = 50, what = "qq") +
  ggtitle("polr: probit link")
p4 &lt;- autoplot(polr.loglog, nsim = 50, what = "qq") +
  ggtitle("polr: log-log link (correct link function)")
grid.arrange(p1, p2, p3, p4, ncol = 2)

# We can also try various goodness-of-fit tests
par(mfrow = c(1, 2))
plot(gof(clm.probit, nsim = 50))
plot(gof(clm.loglog, nsim = 50))

## End(Not run)
</code></pre>

<hr>
<h2 id='sure'>sure: An R package for constructing surrogate-based residuals and diagnostics
for ordinal and general regression models.</h2><span id='topic+sure'></span><span id='topic+sure-package'></span>

<h3>Description</h3>

<p>The <code>sure</code> package provides surrogate-based residuals for fitted ordinal
and general (e.g., binary) regression models of class
<code><a href="ordinal.html#topic+clm">clm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="rms.html#topic+lrm">lrm</a></code>,
<code><a href="rms.html#topic+orm">orm</a></code>, <code><a href="MASS.html#topic+polr">polr</a></code>, or
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.
</p>


<h3>Details</h3>

<p>The development version can be found on GitHub:
<a href="https://github.com/AFIT-R/sure">https://github.com/AFIT-R/sure</a>. As of right now, <code>sure</code> exports the
following functions:
</p>

<ul>
<li><p><code>resids</code> - construct (surrogate-based) residuals;
</p>
</li>
<li><p><code>autoplot</code> - plot diagnostics using
<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>-based graphics;
</p>
</li>
<li><p><code>gof</code> - simulate p-values from a goodness-of-fit test.
</p>
</li></ul>



<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted).
</p>

<hr>
<h2 id='surrogate'>Surrogate Response</h2><span id='topic+surrogate'></span>

<h3>Description</h3>

<p>Simulate surrogate response values for cumulative link regression models
using the latent method described in Liu and Zhang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate(object, method = c("latent", "jitter"),
  jitter.scale = c("probability", "response"), nsim = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="ordinal.html#topic+clm">clm</a></code>,
<code><a href="rms.html#topic+lrm">lrm</a></code>, <code><a href="rms.html#topic+orm">orm</a></code>, <code><a href="MASS.html#topic+polr">polr</a></code>, or
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_method">method</code></td>
<td>
<p>Character string specifying the type of surrogate to use; for
details, see Liu and Zhang (2017). For cumulative link models, the latent
variable method is used. For binary GLMs, the jittering approach is employed.
(Currently ignored.)</p>
</td></tr>
<tr><td><code id="surrogate_+3A_jitter.scale">jitter.scale</code></td>
<td>
<p>Character string specifying the scale on which to perform
the jittering. Should be one of <code>"probability"</code> or <code>"response"</code>.
(Currently ignored for cumulative link models.)</p>
</td></tr>
<tr><td><code id="surrogate_+3A_nsim">nsim</code></td>
<td>
<p>Integer specifying the number of bootstrap replicates to use.
Default is <code>1L</code> meaning no bootstrap samples.</p>
</td></tr>
<tr><td><code id="surrogate_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. (Currently ignored.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of class <code>c("numeric", "surrogate")</code> containing
the simulated surrogate response values. Additionally, if <code>nsim</code> &gt; 1,
then the result will contain the attributes:
</p>

<dl>
<dt><code>boot.reps</code></dt><dd><p>A matrix  with <code>nsim</code> columns, one for each
bootstrap replicate of the surrogate values. Note, these are random and do
not correspond to the original ordering of the data;</p>
</dd>
<dt><code>boot.id</code></dt><dd><p>A matrix  with <code>nsim</code> columns. Each column
contains the observation number each surrogate value corresponds to in
<code>boot.reps</code>. (This is used for plotting purposes.)</p>
</dd>
</dl>



<h3>Note</h3>

<p>Surrogate response values require sampling from a continuous distribution;
consequently, the result will be different with every call to
<code>surrogate</code>. The internal functions used for sampling from truncated
distributions are based on modified versions of
<code><a href="truncdist.html#topic+rtrunc">rtrunc</a></code> and <code><a href="truncdist.html#topic+qtrunc">qtrunc</a></code>.
</p>


<h3>References</h3>

<p>Liu, Dungang and Zhang, Heping. Residuals and Diagnostics for Ordinal
Regression Models: A Surrogate Approach.
<em>Journal of the American Statistical Association</em> (accepted). URL
http://www.tandfonline.com/doi/abs/10.1080/01621459.2017.1292915?journalCode=uasa20
</p>
<p>Nadarajah, Saralees and Kotz, Samuel. R Programs for Truncated Distributions.
<em>Journal of Statistical Software, Code Snippet</em>, 16(2), 1-8, 2006. URL
https://www.jstatsoft.org/v016/c02.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
