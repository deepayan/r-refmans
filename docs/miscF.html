<!DOCTYPE html><html><head><title>Help for package miscF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miscF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#curve.polynomial.rjmcmc'><p>Curve Fitting Using Piecewise Polynomials with Unknown Number and</p>
Location of Knots</a></li>
<li><a href='#mvn.bayes'><p>Estimate the Parameters of a Multivariate Normal Model by the</p>
Bayesian Methods</a></li>
<li><a href='#mvn.ub'><p>Unbiased Estimate of Parameters of a Multivariate Normal Distribution</p></a></li>
<li><a href='#mvsn.mcmc'><p>Estimate Parameters of a Multivariate Skew Normal Distribution Using the MCMC</p></a></li>
<li><a href='#mvst.mcmc'><p>Estimate Parameters of a Multivariate Skew t Distribution Using the MCMC</p></a></li>
<li><a href='#mvt.ecme'><p>Estimate Parameters of a Multivariate t Distribution Using the</p>
ECME Algorithm</a></li>
<li><a href='#mvt.mcmc'><p>Estimate Parameters of a Multivariate t Distribution Using the MCMC</p></a></li>
<li><a href='#rMultinom'><p>Generate Random Samples from Different Multinomial</p>
Distributions with the Same Number of Classes</a></li>
<li><a href='#rmvsn'><p>Generate Random Samples from a Multivariate Skew Normal Distribution</p></a></li>
<li><a href='#rmvst'><p>Generate Random Samples from a Multivariate Skew t Distribution</p></a></li>
<li><a href='#spatail.lme.mcmc'><p>Spatial Modeling by a Bayesian Hierarchical</p>
Linear Mixed-effects Model</a></li>
<li><a href='#uvnm.rjmcmc'><p>Univariate Normal Mixture (UVNM) Model with Unknown Number of Components</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Miscellaneous Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-5</td>
</tr>
<tr>
<td>Author:</td>
<td>Dai Feng</td>
</tr>
<tr>
<td>Description:</td>
<td>Various functions for random number generation, density 
             estimation, classification, curve fitting, and spatial 
             data analysis.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dai Feng &lt;daifeng.stat@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), MASS (&ge; 7.3-45), R2jags (&ge; 0.5-7)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MCMCpack (&ge; 1.2-4), mvtnorm (&ge; 0.9-9992)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mixAK (&ge; 2.6), BRugs (&ge; 0.8-6)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-03 15:33:14 UTC; jingru</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-03 16:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='curve.polynomial.rjmcmc'>Curve Fitting Using Piecewise Polynomials with Unknown Number and
Location of Knots
</h2><span id='topic+curve.polynomial.rjmcmc'></span>

<h3>Description</h3>

<p>Fit a variety of curves by a sequence of piecewise polynomials.
The number and location of knots are determined by the Reversible
Jump MCMC method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  curve.polynomial.rjmcmc(y, x, lambda, l, l0, c=0.4,
                          gamma.shape=1e-3, gamma.rate=1e-3,
                          maxit=10000, err=1e-8, verbose=TRUE)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_y">y</code></td>
<td>
<p>a vector of values of a response variable.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_x">x</code></td>
<td>
<p>a vector of values of the corresponding explanatory variable.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_lambda">lambda</code></td>
<td>
<p>the parameter of the Poisson prior for the number of knots.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_l">l</code></td>
<td>
<p>the order of polynomials.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_l0">l0</code></td>
<td>
<p>the degree of continuity at the knots.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_c">c</code></td>
<td>
<p>the parameter controlling the rate of changing dimension. The
default value is 0.4.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_gamma.shape">gamma.shape</code></td>
<td>
<p>the parameter shape of the gamma prior for the error
precision. The default value is 1e-3.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_gamma.rate">gamma.rate</code></td>
<td>
<p>the parameter rate of the gamma prior for the error
precision. The default value is 1e-3.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations. The default value is
10000.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_err">err</code></td>
<td>
<p>the iteration stops when consecutive difference in
percentage of mean-squared error reaches this bound.
The default value is 1e-8.</p>
</td></tr>
<tr><td><code id="curve.polynomial.rjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then indicate
the level of output after every 1000 iterations.
The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is based on Denison et al. (1998).  It can be used to fit
both smooth and unsmooth curves.  When both <code>l0</code> and <code>l</code>
are set to 3, it fits curves using cubic spline.
</p>


<h3>Value</h3>

<table>
<tr><td><code>knots.save</code></td>
<td>
<p>a list of location of knots. One component per iteration.</p>
</td></tr>
<tr><td><code>betas.save</code></td>
<td>
<p>a list of estimates of regression parameters
<code class="reqn">\beta</code>s. One component per iteration.</p>
</td></tr>
<tr><td><code>fitted.save</code></td>
<td>
<p>a matrix of fitted values. One column per iteration.</p>
</td></tr>
<tr><td><code>sigma2.save</code></td>
<td>
<p>a vector of estimate of error variance.
One component per iteration.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The factor <code class="reqn">\frac{1}{\sqrt{n}}</code> was added in the likelihood ratio
to penalize the ratio for dimensionality as suggested in Dimatteo et
al. (2001).
</p>


<h3>References</h3>

<p>Denison, D. G. T., Mallick, B. K., Smith, A. F. M.(1998) 
Automatic Bayesian Curve Fitting
<em>JRSSB</em> <b>vol. 60, no. 2</b> 333-350
</p>
<p>Dimatteo, I., Genovese, C. R., Kass, R. E.(2001) 
Bayesian Curve-fitting with Free-knot Splines
<em>Biometrika</em> <b>vol. 88, no. 4</b> 1055-1071
</p>


<h3>See Also</h3>

<p><code><a href="pspline.html#topic+sm.spline">sm.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   #Example 1: smooth curve
   #example 3.1. (b) in Denison et al.(1998)

   x &lt;- runif(200)
   xx &lt;- -2 + 4*x
   y.truth &lt;- sin(2*xx) + 2*exp(-16*xx^2)
   y &lt;- y.truth + rnorm(200, mean=0, sd=0.3)

   results &lt;- curve.polynomial.rjmcmc(y, x, lambda=1, l=2, l0=1)

   plot(sort(x), y.truth[order(x)], type="l")
   lines(sort(x), rowMeans(results$fitted.save), col="red")

   #Example 2: unsmooth curve
   #blocks in Denison et al.(1998)
   tj &lt;- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.4, 0.44, 0.65, 0.76, 0.78, 0.81)
   hj &lt;- c(4, -5, 3, -4, 5, -4.2, 2.1, 4.3, -3.1, 2.1, -4.2)

   t &lt;- seq(0, 1, len=2048)
   Ktmtj &lt;- outer(t, tj, function(a,b) ifelse(a-b &gt; 0, 1, -1))
   ft &lt;- rowSums(Ktmtj %*% diag(hj))
   x &lt;- t
   y &lt;- ft + rnorm(2048, 0, 1)

   results &lt;- curve.polynomial.rjmcmc(y, x, lambda=5, l=2, l0=1)

   plot(x, ft, type="s")
   lines(x, rowMeans(results$fitted.save), col="red")

   #Example 3: unsmooth curve
   #bumps in Denison et al.(1998)
   tj &lt;- c(0.1, 0.13, 0.15, 0.23, 0.25, 0.4, 0.44, 0.65, 0.76, 0.78, 0.81)
   hj &lt;- c(4, 5, 3, 4, 5, 4.2, 2.1, 4.3, 3.1, 5.1, 4.2)*10
   wj &lt;- c(0.005, 0.005, 0.006, 0.01, 0.01, 0.03, 0.01, 0.01, 0.005, 0.008, 0.005)

   t &lt;- seq(0, 1, len=2048)
   ft &lt;- rowSums((1 + abs(outer(t, tj ,"-") %*% diag(1/wj)))^(-4) %*% diag(hj))
   y &lt;- ft + rnorm(2048, 0, 1)

   results &lt;- curve.polynomial.rjmcmc(y, t, lambda=5, l=2, l0=1)

   plot(t, ft, type="s")
   lines(t, rowMeans(results$fitted.save), col="red")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='mvn.bayes'>Estimate the Parameters of a Multivariate Normal Model by the
Bayesian Methods</h2><span id='topic+mvn.bayes'></span>

<h3>Description</h3>

<p>Estimate the parameters of a multivariate normal model under different
priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvn.bayes(X, nsim, prior=c("Jeffreys", "Conjugate"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn.bayes_+3A_x">X</code></td>
<td>
<p>a matrix of observations with one subject per row.</p>
</td></tr>
<tr><td><code id="mvn.bayes_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="mvn.bayes_+3A_prior">prior</code></td>
<td>
<p>a character string specifying the prior distribution.
It must be either &quot;Jeffreys&quot; or &quot;Conjugate&quot; and may be abbreviated.
The default is &quot;Jeffreys&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both the Jeffreys prior and normal-inverse-Wishart conjugate prior
are available. The conjugate prior of variance covariance matrix is
inverse-Wishart. To use a noninformative proper prior, the degree of
freedom of Wishart prior was set as the number of dimensions and the
scale matrix was chosen based on the unbiased estimate.
The number of prior measurements was
taken as one and the prior mean was set as its unbiased estimate.</p>


<h3>Value</h3>

<table>
<tr><td><code>Mu.save</code></td>
<td>
<p>a matrix of mean vector of the model, one row per iteration.</p>
</td></tr>
<tr><td><code>Sigma.save</code></td>
<td>
<p>a three dimensional array of variance of the model.
Sigma.save[,,i] is the result from the ith iteration.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the number of dimensions is two, under Jeffreys prior,
it is straightforward to obtain independent
samples from the posteriors.
</p>


<h3>References</h3>

<p>Berger, J. O., Sun, D. (2008)
Objective Priors for the Bivariate Normal Model. 
<em>The Annals of Statistics</em> <b>36</b> 963-982.
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Rubin, D. B. (2003)
Bayesian Data Analysis. 2nd ed. London: Chapman and Hall
</p>
<p>Sun, D., Berger, J. O. (2009)
Objective Priors for the Multivariate Normal Model.
In Bayesian Statistics 8, Ed. J. Bernardo, M. Bayarri, J. Berger,
A. Dawid, D. Heckerman, A. Smith and M. West.
Oxford: Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Sigma &lt;- matrix(c(100, 0.99*sqrt(100*100),
                      0.99*sqrt(100*100), 100),
                      nrow=2)
  X &lt;- mvrnorm(1000, c(100, 100), Sigma)
  result &lt;- mvn.bayes(X, 10000)
  Mu &lt;- colMeans(result$Mu.save)
  Sigma &lt;- apply(result$Sigma.save, c(1,2), mean)
</code></pre>

<hr>
<h2 id='mvn.ub'>Unbiased Estimate of Parameters of a Multivariate Normal Distribution</h2><span id='topic+mvn.ub'></span>

<h3>Description</h3>

<p>Obtain the Unbiased Estimate of Parameters of a Multivariate Normal Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvn.ub(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn.ub_+3A_x">X</code></td>
<td>
<p>a matrix of observations with one subject per row.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>hat.Mu</code></td>
<td>
<p>unbiased estimate of mean.</p>
</td></tr>
<tr><td><code>hat.Sigma</code></td>
<td>
<p>unbiased estimate of variance.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  Sigma &lt;- matrix(c(100, 0.99*sqrt(100*100),
                      0.99*sqrt(100*100), 100),
                      nrow=2)
  X &lt;- mvrnorm(1000, c(100, 100), Sigma)
  result &lt;- mvn.ub(X)
</code></pre>

<hr>
<h2 id='mvsn.mcmc'>Estimate Parameters of a Multivariate Skew Normal Distribution Using the MCMC 
</h2><span id='topic+mvsn.mcmc'></span>

<h3>Description</h3>

<p>Use the MCMC to obtain estimate of parameters of a multivariate skew normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvsn.mcmc(Y, prior.Mu0=NULL, prior.Sigma0=NULL, 
            prior.muDelta0=NULL, prior.sigmaDelta0=NULL, 
            prior.H0=NULL, prior.P0=NULL,
            nmcmc=10000, nburn=nmcmc/10, nthin=1, seed=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvsn.mcmc_+3A_y">Y</code></td>
<td>
<p>a matrix of observations with one subject per row.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_prior.mu0">prior.Mu0</code></td>
<td>
<p>mean vector of multivariate normal prior of the
parameter <code class="reqn">\mu</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_prior.sigma0">prior.Sigma0</code></td>
<td>
<p>variance matrix of multivariate normal prior of
the parameter <code class="reqn">\mu</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_prior.mudelta0">prior.muDelta0</code></td>
<td>
<p>mean vector of normal prior of the diagonal elements of parameter <code class="reqn">D</code>. 
The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_prior.sigmadelta0">prior.sigmaDelta0</code></td>
<td>
<p>standard deviation vector of normal prior of the diagonal 
elements of parameter <code class="reqn">D</code>. 
The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_prior.h0">prior.H0</code></td>
<td>
<p>the inverse of scale matrix of Wishart prior of the inverse of 
parameter <code class="reqn">\Sigma</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_prior.p0">prior.P0</code></td>
<td>
<p>the degrees of freedom of Wishart prior of the inverse of 
parameter <code class="reqn">\Sigma</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_nmcmc">nmcmc</code></td>
<td>
<p>number of iterations. The default value is 10000.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in. The default value is <code>nmcmc</code>/10.</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_nthin">nthin</code></td>
<td>
<p>output every <code>nthin</code>-th sample. The default value is 1 (no thinning).</p>
</td></tr>
<tr><td><code id="mvsn.mcmc_+3A_seed">seed</code></td>
<td>
<p>random seed. The default value is 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the parameters of a multivariate skew normal distribution as in Sahu et al. 2003 using the MCMC.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Mu</code></td>
<td>
<p>a matrix of parameter <code class="reqn">\mu</code> of the distribution, one row per iteration.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>a three dimensional array of parameter <code class="reqn">\Sigma</code> of the
distribution. Sigma[i,,] is the result from the i-th iteration.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a matrix of diagonal elements of parameter <code class="reqn">D</code> of the distribution, one row per iteration.</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>DIC value.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sahu, Sujit K., Dipak K. Dey, and Marcia D. Branco. (2003) 
A new class of multivariate skew distributions with applications to Bayesian regression models.
<em>Canadian Journal of Statistics</em> <b>vol. 31, no. 2</b> 129-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  Mu &lt;- rep(400, 2)
  Sigma &lt;- diag(c(40, 40))
  D &lt;- diag(c(-30, -30))
  Y &lt;- rmvsn(n=1000, D, Mu, Sigma)
  mcmc &lt;- mvsn.mcmc(Y)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvst.mcmc'>Estimate Parameters of a Multivariate Skew t Distribution Using the MCMC 
</h2><span id='topic+mvst.mcmc'></span>

<h3>Description</h3>

<p>Use the MCMC to obtain estimate of parameters of a multivariate skew t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvst.mcmc(Y, prior.Mu0=NULL, prior.Sigma0=NULL, 
            prior.muDelta0=NULL, prior.sigmaDelta0=NULL, 
            prior.H0=NULL, prior.P0=NULL,
            nmcmc=10000, nburn=nmcmc/10, nthin=1, seed=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvst.mcmc_+3A_y">Y</code></td>
<td>
<p>a matrix of observations with one subject per row.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_prior.mu0">prior.Mu0</code></td>
<td>
<p>mean vector of multivariate normal prior of the
parameter <code class="reqn">\mu</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_prior.sigma0">prior.Sigma0</code></td>
<td>
<p>variance matrix of multivariate normal prior of
the parameter <code class="reqn">\mu</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_prior.mudelta0">prior.muDelta0</code></td>
<td>
<p>mean vector of normal prior of the diagonal elements of parameter <code class="reqn">D</code>. 
The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_prior.sigmadelta0">prior.sigmaDelta0</code></td>
<td>
<p>standard deviation vector of normal prior of the diagonal 
elements of parameter <code class="reqn">D</code>. 
The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_prior.h0">prior.H0</code></td>
<td>
<p>the inverse of scale matrix of Wishart prior of the inverse of 
parameter <code class="reqn">\Sigma</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_prior.p0">prior.P0</code></td>
<td>
<p>the degrees of freedom of Wishart prior of the inverse of 
parameter <code class="reqn">\Sigma</code>. The default value is <code>NULL</code>. For the default,
the value will be generated automatically.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_nmcmc">nmcmc</code></td>
<td>
<p>number of iterations. The default value is 10000.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in. The default value is <code>nmcmc</code>/10.</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_nthin">nthin</code></td>
<td>
<p>output every <code>nthin</code>-th sample. The default value is 1 (no thinning).</p>
</td></tr>
<tr><td><code id="mvst.mcmc_+3A_seed">seed</code></td>
<td>
<p>random seed. The default value is 1. Note that <code>seed</code> can be an integer from 1 to 14. 
The internal state of the OpenBUGS random number generator can be set to one of 14 predefined 
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the parameters of a multivariate skew t distribution as in Sahu et al. 2003 using the MCMC.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Mu</code></td>
<td>
<p>a matrix of parameter <code class="reqn">\mu</code> of the distribution, one row per iteration.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>a three dimensional array of parameter <code class="reqn">\Sigma</code> of the
distribution. Sigma[i,,] is the result from the i-th iteration.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p>a matrix of diagonal elements of parameter <code class="reqn">D</code> of the distribution, one row per iteration.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>a vector of parameter <code class="reqn">\nu</code> of the distribution.</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>DIC value.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sahu, Sujit K., Dipak K. Dey, and Marcia D. Branco. (2003) 
A new class of multivariate skew distributions with applications to Bayesian regression models.
<em>Canadian Journal of Statistics</em> <b>vol. 31, no. 2</b> 129-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  Mu &lt;- rep(0, 2)
  Sigma &lt;- diag(c(1,1))
  D &lt;- diag(c(1,1))
  nu &lt;- 5
  Y &lt;- rmvst(n=1000, D, Mu, Sigma, nu)
  mcmc &lt;- mvst.mcmc(Y)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvt.ecme'>Estimate Parameters of a Multivariate t Distribution Using the
ECME Algorithm</h2><span id='topic+mvt.ecme'></span>

<h3>Description</h3>

<p>Use the Expectation/Conditional Maximization Either (ECME) algorithm
to obtain estimate of parameters of a multivariate t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvt.ecme(X, lower.v, upper.v, err=1e-4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvt.ecme_+3A_x">X</code></td>
<td>
<p>a matrix of observations with one subject per row.</p>
</td></tr>
<tr><td><code id="mvt.ecme_+3A_lower.v">lower.v</code></td>
<td>
<p>lower bound of degrees of freedom (df).</p>
</td></tr>
<tr><td><code id="mvt.ecme_+3A_upper.v">upper.v</code></td>
<td>
<p>upper bound of df.</p>
</td></tr>
<tr><td><code id="mvt.ecme_+3A_err">err</code></td>
<td>
<p>the iteration stops when consecutive difference in
percentage of df reaches this bound. The default value is 1e-4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They are number of forms of the generalization of the univariate student-t
distribution to multivariate cases. This function adopts the widely
used representation as a scale mixture of normal distributions.
</p>
<p>To obtain the estimate, the algorithm adopted is the
Expectation/Conditional Maximization Either (ECME), which extends the
Expectation/Conditional Maximization (ECM) algorithm by allowing
CM-steps to maximize either the constrained expected complete-data
log-likelihood, as with ECM, or the correspondingly constrained
actual log-likelihood function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Mu</code></td>
<td>
<p>estimate of location.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>estimate of scale matrix.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>estimate of df.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chuanhai Liu (1994)
Statistical Analysis Using the Multivariate t Distribution
<em>Ph. D. Dissertation, Harvard University</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mu1 &lt;- mu2 &lt;- sigma12 &lt;- sigma22 &lt;- 100
  rho12 &lt;- 0.7
  Sigma &lt;- matrix(c(sigma12, rho12*sqrt(sigma12*sigma22),
                    rho12*sqrt(sigma12*sigma22), sigma22),
                  nrow=2)
  k &lt;- 5
  N &lt;- 100
  require(mvtnorm)
  X &lt;- rmvt(N, sigma=Sigma, df=k, delta=c(mu1, mu2))

  result &lt;- mvt.ecme(X, 3, 300)
  result$Mu
  result$Sigma
  result$v
</code></pre>

<hr>
<h2 id='mvt.mcmc'>Estimate Parameters of a Multivariate t Distribution Using the MCMC 
</h2><span id='topic+mvt.mcmc'></span>

<h3>Description</h3>

<p>Use the MCMC to obtain estimate of parameters of a multivariate t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mvt.mcmc(X, prior.lower.v, prior.upper.v,
           prior.Mu0=rep(0, ncol(X)), prior.Sigma0=diag(10000, ncol(X)),
           prior.p=ncol(X), prior.V=diag(1, ncol(X)),
           initial.v=NULL, initial.Sigma=NULL,
           nmcmc=10000, nburn=nmcmc/10, nthin=1, seed=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvt.mcmc_+3A_x">X</code></td>
<td>
<p>a matrix of observations with one subject per row.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_prior.lower.v">prior.lower.v</code></td>
<td>
<p>lower bound of degrees of freedom (df).</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_prior.upper.v">prior.upper.v</code></td>
<td>
<p>upper bound of df.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_prior.mu0">prior.Mu0</code></td>
<td>
<p>mean vector of multivariate normal prior of the
location. The default value is 0.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_prior.sigma0">prior.Sigma0</code></td>
<td>
<p>variance matrix of multivariate normal prior of
the location. The default value is a diagonal matrix with diagonal
entries equal to 10000.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_prior.p">prior.p</code></td>
<td>
<p>the df of wishart prior of inverse of the scale matrix. The
default value is dimensions of observation.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_prior.v">prior.V</code></td>
<td>
<p>the scale matrix of wishart prior of inverse of the scale
matrix.	The	default value is identity matrix.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_initial.v">initial.v</code></td>
<td>
<p>the initial value of the df. The default is
<code>NULL</code>. For the default, the value will be generated by using
the ECME Algorithm.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_initial.sigma">initial.Sigma</code></td>
<td>
<p>the initial value of the scale matrix. The default is
<code>NULL</code>. For the default, the value will be generated by using
the ECME Algorithm.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_nmcmc">nmcmc</code></td>
<td>
<p>number of iterations. The default value is 10000.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_nburn">nburn</code></td>
<td>
<p>number of burn-in. The default value is <code>nmcmc</code>/10.</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_nthin">nthin</code></td>
<td>
<p>output every <code>nthin</code>-th sample. The default value is 1 (no thinning).</p>
</td></tr>
<tr><td><code id="mvt.mcmc_+3A_seed">seed</code></td>
<td>
<p>random seed. The default value is 1. Note that <code>seed</code> can be an integer from 1 to 14. 
The internal state of the OpenBUGS random number generator can be set to one of 14 predefined 
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate samples from the full conditional distribution of
df, the slice sampling was used and the code was adapted from
<a href="http://www.cs.toronto.edu/~radford/ftp/slice-R-prog">http://www.cs.toronto.edu/~radford/ftp/slice-R-prog</a>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Mu.save</code></td>
<td>
<p>a matrix of locations of the distribution, one row per iteration.</p>
</td></tr>
<tr><td><code>Sigma.save</code></td>
<td>
<p>a three dimensional array of scale matrix of the
distribution. Sigma.save[,,i] is the result from the ith iteration.</p>
</td></tr>
<tr><td><code>v.save</code></td>
<td>
<p>a vector of df of the distribution, one component per iteration.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mvt.ecme">mvt.ecme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  mu1 &lt;- mu2 &lt;- sigma12 &lt;- sigma22 &lt;- 100
  rho12 &lt;- 0.9
  Sigma &lt;- matrix(c(sigma12, rho12*sqrt(sigma12*sigma22),
                    rho12*sqrt(sigma12*sigma22), sigma22),
                  nrow=2)
  k &lt;- 8
  N &lt;- 100
  X &lt;- rmvt(N, sigma=Sigma, df=k, delta=c(mu1, mu2))

  result &lt;- mvt.mcmc(X, 4, 25)
  colMeans(result$Mu.save)
  apply(result$Sigma.save, c(1,2), mean)
  mean(result$v.save)

## End(Not run)
</code></pre>

<hr>
<h2 id='rMultinom'>Generate Random Samples from Different Multinomial
Distributions with the Same Number of Classes
</h2><span id='topic+rMultinom'></span>

<h3>Description</h3>

<p>Generate random samples from multinomial distributions with the same
number of classes but different event probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rMultinom(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rMultinom_+3A_p">p</code></td>
<td>
<p>matrix with each row specifying the probabilities for
different classes of each sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function vectorizes the generation of random samples from
different multinomial distributions by the inversion of CDF method.
</p>


<h3>Value</h3>

<p>Random samples from multinomial distributions.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rmultinom">rmultinom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example 1: Generate 100 random samples from multinomial distributions
  #           with 3 classes and different event probabilities.
  p1 &lt;- runif(100)
  p2  &lt;- runif(100, 0, 1-p1)
  p3 &lt;- 1-p1-p2 
  x &lt;- rMultinom(p=cbind(p1, p2, p3))
  
</code></pre>

<hr>
<h2 id='rmvsn'>Generate Random Samples from a Multivariate Skew Normal Distribution
</h2><span id='topic+rmvsn'></span>

<h3>Description</h3>

<p>Generate random samples from a multivariate skew normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rmvsn(n, D, Mu, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvsn_+3A_n">n</code></td>
<td>
<p>number of samples.</p>
</td></tr>
<tr><td><code id="rmvsn_+3A_d">D</code></td>
<td>
<p>parameter <code class="reqn">D</code> of the distribution.</p>
</td></tr>
<tr><td><code id="rmvsn_+3A_mu">Mu</code></td>
<td>
<p>parameter <code class="reqn">\mu</code> of the distribution.</p>
</td></tr>
<tr><td><code id="rmvsn_+3A_sigma">Sigma</code></td>
<td>
<p>parameter <code class="reqn">\Sigma</code> of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates random samples using the methods in Sahu et al. 2003.
</p>


<h3>Value</h3>

<p>Random samples from the multivariate skew normal distribution.
</p>


<h3>References</h3>

<p>Sahu, Sujit K., Dipak K. Dey, and Marcia D. Branco. (2003) 
A new class of multivariate skew distributions with applications to Bayesian regression models.
<em>Canadian Journal of Statistics</em> <b>vol. 31, no. 2</b> 129-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Mu &lt;- rep(400, 2)
  Sigma &lt;- diag(c(40, 40))
  D &lt;- diag(c(-30, -30))
  Y &lt;- rmvsn(n=1000, D, Mu, Sigma)
</code></pre>

<hr>
<h2 id='rmvst'>Generate Random Samples from a Multivariate Skew t Distribution
</h2><span id='topic+rmvst'></span>

<h3>Description</h3>

<p>Generate random samples from a multivariate skew t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rmvst(n, D, Mu, Sigma, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvst_+3A_n">n</code></td>
<td>
<p>number of samples.</p>
</td></tr>
<tr><td><code id="rmvst_+3A_d">D</code></td>
<td>
<p>parameter <code class="reqn">D</code> of the distribution.</p>
</td></tr>
<tr><td><code id="rmvst_+3A_mu">Mu</code></td>
<td>
<p>parameter <code class="reqn">\mu</code> of the distribution.</p>
</td></tr>
<tr><td><code id="rmvst_+3A_sigma">Sigma</code></td>
<td>
<p>parameter <code class="reqn">\Sigma</code> of the distribution.</p>
</td></tr>
<tr><td><code id="rmvst_+3A_nu">nu</code></td>
<td>
<p>parameter <code class="reqn">\nu</code> of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates random samples using the methods in Sahu et al. 2003.
</p>


<h3>Value</h3>

<p>Random samples from the multivariate skew t distribution.
</p>


<h3>References</h3>

<p>Sahu, Sujit K., Dipak K. Dey, and Marcia D. Branco. (2003) 
A new class of multivariate skew distributions with applications to Bayesian regression models.
<em>Canadian Journal of Statistics</em> <b>vol. 31, no. 2</b> 129-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Mu &lt;- rep(0, 2)
  Sigma &lt;- diag(c(1,1))
  D &lt;- diag(c(1,1))
  nu &lt;- 5
  Y &lt;- rmvst(n=100, D, Mu, Sigma, nu)
</code></pre>

<hr>
<h2 id='spatail.lme.mcmc'>Spatial Modeling by a Bayesian Hierarchical
Linear Mixed-effects Model 
</h2><span id='topic+spatial.lme.mcmc'></span>

<h3>Description</h3>

<p>A linear mixed-effects model that combines unstructured
variance/covariance matrix for
inter-regional (long-range) correlations and 
an exchangeable correlation structure for intra-regional (short-range)
correlations. Estimation is performed using the Gibbs sampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  spatial.lme.mcmc(spatialMat, nlr, nsweep, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatail.lme.mcmc_+3A_spatialmat">spatialMat</code></td>
<td>
<p>a matrix of observations with one subject per column
and one location per row. For each subject, the observations
are arranged one location after another.</p>
</td></tr>
<tr><td><code id="spatail.lme.mcmc_+3A_nlr">nlr</code></td>
<td>
<p>a vector of number of locations within each region. One
component per region.</p>
</td></tr>
<tr><td><code id="spatail.lme.mcmc_+3A_nsweep">nsweep</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code id="spatail.lme.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then indicate
the level of output after every 1000 iterations.
The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function was proposed to study the fMRI data.
The original MATLAB code written by DuBois Bowman and Brian Caffo can
be found at: <a href="http://www.biostat.jhsph.edu/~bcaffo/downloads/clusterBayes.m">http://www.biostat.jhsph.edu/~bcaffo/downloads/clusterBayes.m</a>. 
Instead of stacking the data from
two conditions, the R version fits the model for one condition and
the user needs to use the function multiple times for separate conditions.
</p>
<p>The initial values are obtained based on sample moments. The
hyper-parameters for the prior distributions of the intra-regional
variances and variances of locations' means are set up in the way that
the mean is equal to the sample mean and the variance is large.
</p>


<h3>Value</h3>

<table>
<tr><td><code>mu.save</code></td>
<td>
<p>a matrix of means at every location. One column per iteration.</p>
</td></tr>
<tr><td><code>sigma2.save</code></td>
<td>
<p>a matrix of intra-regional variances. One column
per iteration.</p>
</td></tr>
<tr><td><code>lambda2.save</code></td>
<td>
<p>a matrix of variances of locations' means within regions. One column per iteration.</p>
</td></tr>
<tr><td><code>Gamma.save</code></td>
<td>
<p>a matrix of inter-regional variance/covariance
matrix. One column per iteration and within each column the
elements of the variance/covariance matrix are arranged column-wise.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There seemed to be no easy way to use <code><a href="lme4.html#topic+lmer">lmer</a></code> or
<code><a href="nlme.html#topic+lme">lme</a></code> to fit
the variance/covariance structure in this model and <em>SAS proc
mixed</em> failed for certain cases.
</p>


<h3>References</h3>

<p>Brian Caffo, DuBois Bowman, Lynn Eberly and Susan Spear Bassett (2009)
A Markov Chain Monte Carlo Based Analysis of a
Multilevel Model for Functional MRI Data
<em>Handbook of Markov Chain Monte Carlo</em>
</p>
<p>F. DuBois Bowman, Brian Caffo, Susan Spear Bassett, and Clinton Kilts (2008)
A Bayesian Hierarchical Framework for Spatial Modeling of fMRI
Data
<em>Neuroimage</em> <b>vol. 39, no. 1</b> 146-156
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    #simulate the data
    ns=100; nr=2; nlr &lt;- c(20, 20)
    mu0 &lt;- c(0, 0)
    sigma2 &lt;- c(1., 1.)
    Gamma &lt;- matrix(c(3, 0, 0, 3), nrow=2)

    sample &lt;- matrix(0, nrow=sum(nlr), ncol=ns)
    for(i in 1:ns){
        alpha &lt;- mvrnorm(1, rep(0, nr), Gamma)
        sampleR &lt;- NULL
        for(g in 1:nr){
            beta &lt;- rnorm(nlr[g], mean=alpha[g] + mu0[g], sd=sqrt(sigma2[g]))
            sampleR &lt;- c(sampleR, beta)
        }
        sample[,i] &lt;- sampleR
    }

    #run mcmc
    mcmc.result &lt;- spatial.lme.mcmc(sample, nlr, 10000)

    #check the results
    Gamma &lt;- mcmc.result$Gamma.save
    sigma2 &lt;- mcmc.result$sigma2.save
    mu &lt;- mcmc.result$mu.save
    matrix(rowMeans(Gamma), nr, nr)
    apply(sigma2, 1, function(x) quantile(x, prob=c(0.025, 0.5, 0.975)))
    summary(rowMeans(mu[1:nlr[1],]))
    summary(rowMeans(mu[(nlr[1]+1):sum(nlr),]))
    

## End(Not run)
</code></pre>

<hr>
<h2 id='uvnm.rjmcmc'>Univariate Normal Mixture (UVNM) Model with Unknown Number of Components 
</h2><span id='topic+uvnm.rjmcmc'></span>

<h3>Description</h3>

<p>Estimate the parameters of an univariate normal mixture model including
the number of components using the Reversible Jump MCMC method. It can
be used for density estimation and/or classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  uvnm.rjmcmc(y, nsweep, kmax, k, w, mu, sigma2, Z,
              delta=1, xi=NULL, kappa=NULL, alpha=2,
              beta=NULL, g=0.2, h=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uvnm.rjmcmc_+3A_y">y</code></td>
<td>
<p>a vector of observations.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_nsweep">nsweep</code></td>
<td>
<p>number of sweeps. One sweep has six moves to update
parameters including the number of components.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_kmax">kmax</code></td>
<td>
<p>the maximum number of components.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_k">k</code></td>
<td>
<p>initial value of number of components.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_w">w</code></td>
<td>
<p>initial values of weights of different components.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_mu">mu</code></td>
<td>
<p>initial values of means of different components.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_sigma2">sigma2</code></td>
<td>
<p>initial values of variances of different components.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_z">Z</code></td>
<td>
<p>initial values of allocations of all observations.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_delta">delta</code></td>
<td>
<p>the parameter of the prior distribution of <code>w</code>,
the symmetric Dirichlet distribution. The default value is one.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_xi">xi</code></td>
<td>
<p>the mean of the prior distribution of means of
components. By taking the default value <code>NULL</code>, it is
set as the median of the data <code>y</code> internally.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_kappa">kappa</code></td>
<td>
<p>the precision of the prior distribution of means of
components. By taking the default value <code>NULL</code>, 
it is set as 1/R^2 internally, where R is the range of <code>y</code>.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_alpha">alpha</code></td>
<td>
<p>the parameter shape of the prior distribution of
precision of components. The default values is 2.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_beta">beta</code></td>
<td>
<p>the parameter rate of the prior distribution of
precision of components. By taking the default value 
<code>NULL</code>, it is set as
a number generated randomly from a gamma distribution with shape
<code>g</code> and rate <code>h</code>.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_g">g</code></td>
<td>
<p>the parameter shape of the gamma distribution for
<code>beta</code>. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_h">h</code></td>
<td>
<p>the parameter rate of the gamma distribution for
<code>beta</code>. By taking the default value <code>NULL</code>, it is
set as 10/R^2 internally, where R is the range of <code>y</code>.</p>
</td></tr>
<tr><td><code id="uvnm.rjmcmc_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code>, then indicate
the level of output after every 1000 sweeps.
The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate the parameters of a univariate normal mixture model with flexible
number of components using the Reversible Jump MCMC method in
Richardson and Green (1997).
</p>


<h3>Value</h3>

<table>
<tr><td><code>k.save</code></td>
<td>
<p>a vector of number of components.</p>
</td></tr>
<tr><td><code>w.save</code></td>
<td>
<p>weights of the UVNM, one component of the list per sweep.</p>
</td></tr>
<tr><td><code>mu.save</code></td>
<td>
<p>means of the UVNM, one component of the list per sweep.</p>
</td></tr>
<tr><td><code>sigma2.save</code></td>
<td>
<p>variances of the UVNM, one component of the list per sweep.</p>
</td></tr>
<tr><td><code>Z.save</code></td>
<td>
<p>a matrix of allocation, one column per sweep.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The error in equation (12) of Richardson and Green (1997)
was corrected based on Richardson and Green (1998).
</p>


<h3>References</h3>

<p>Sylvia Richardson and Peter J. Green (1997) 
On Bayesian Analysis of Mixtures with an Unknown Number of Components
<em>JRSSB</em> <b>vol. 59, no. 4</b> 731-792
</p>
<p>Sylvia Richardson and Peter J. Green (1998) 
Corrigendum: On Bayesian Analysis of Mixtures with an Unknown Number of Components
<em>JRSSB</em> <b>vol. 60, no. 3</b> 661
</p>


<h3>See Also</h3>

<p><code><a href="mixAK.html#topic+NMixMCMC">NMixMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
    require(mixAK)
    data(Acidity)
    y &lt;- Acidity
    w &lt;- c(0.50, 0.17, 0.33)
    mu &lt;- c(4, 5, 6)
    sigma2 &lt;- c(0.08, 0.10, 0.14)
    Z &lt;- do.call(cbind, lapply(1:3, function(i)
                                    w[i]*dnorm(y, mu[i], sqrt(sigma2[i]))))
    Z &lt;- apply(Z, 1, function(x) which(x==max(x))[1])
     
    result &lt;- uvnm.rjmcmc(y, nsweep=200000, kmax=30, k=3,
                          w, mu, sigma2, Z)

    ksave &lt;- result$k.save
    round(table(ksave[-(1:100000)])/100000,4)

    #conditional density estimation
    focus.k &lt;- 3
    pick.k &lt;- which(ksave==focus.k)
    w &lt;- unlist(result$w.save[pick.k])
    mu &lt;- unlist(result$mu.save[pick.k])
    sigma2 &lt;- unlist(result$sigma2.save[pick.k])
    den.estimate &lt;- rep(w, each=length(y)) *
                    dnorm(rep(y, length(w)), mean=rep(mu, each=length(y)),
                          sd=rep(sqrt(sigma2), each=length(y)))
    den.estimate &lt;- rowMeans(matrix(den.estimate, nrow=length(y)))*focus.k

    #within-sample classification
    class &lt;- apply(result$Z.save[,pick.k], 1,
                                function(x) c(sum(x==1), sum(x==2), sum(x==3)))
    class &lt;- max.col(t(class))

    #visualize the results
    hist(y, freq=FALSE, breaks=20, axes=FALSE, ylim=c(-0.3, 1),
         main="Density Estimation and Classification", ylab="")
    axis(2, at=c(-(3:1)/10, seq(0,10,2)/10), labels=c(3:1, seq(0,10,2)/10),
         font=2)
    lines(sort(y), den.estimate[order(y)], col="red")
    for(i in 1:3){
        points(y[class==i], rep(-i/10, length(y[class==i])), col=i, pch=i)
    }
    mtext("Density", 2, at=0.5, line=2)
    mtext("Classification", 2, at=-0.15, line=2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
