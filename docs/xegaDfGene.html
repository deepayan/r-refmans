<!DOCTYPE html><html><head><title>Help for package xegaDfGene</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaDfGene}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ConstScaleFactor'><p>Constant scale factor for differential evolution.</p></a></li>
<li><a href='#lFxegaDfGene'><p>Generate local functions and objects</p></a></li>
<li><a href='#UniformRandomScaleFactor'><p>Uniform random scale factor for differential evolution.</p></a></li>
<li><a href='#xegaDfCrossGene'><p>One point crossover of 2 genes.</p></a></li>
<li><a href='#xegaDfCrossoverFactory'><p>Configure the crossover function of a genetic algorithm.</p></a></li>
<li><a href='#xegaDfDecodeGene'><p>Decode a gene</p></a></li>
<li><a href='#xegaDfGene'><p>Package xegaDfGene.</p></a></li>
<li><a href='#xegaDfGeneMapFactory'><p>Configure the gene map function of a genetic algorithm.</p></a></li>
<li><a href='#xegaDfGeneMapIdentity'><p>Map the parameter vector of a real-coded gene to an identical vector.</p></a></li>
<li><a href='#xegaDfInitGene'><p>Initialize a real-coded gene.</p></a></li>
<li><a href='#xegaDfMutateGeneDE'><p>Mutate a gene (differential mutation).</p></a></li>
<li><a href='#xegaDfMutationFactory'><p>Configure the mutation function of a genetic algorithm.</p></a></li>
<li><a href='#xegaDfReplicateGeneDE'><p>Replicates a gene (differential evolution).</p></a></li>
<li><a href='#xegaDfReplicationFactory'><p>Configure the replication function of a genetic algorithm.</p></a></li>
<li><a href='#xegaDfScaleFactorFactory'><p>Configure the scale factor function for differential mutation.</p></a></li>
<li><a href='#xegaDfUCrossGene'><p>Uniform crossover of 2 genes.</p></a></li>
<li><a href='#xegaDfUPCrossGene'><p>Parameterized uniform crossover of 2 genes.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Gene Operations for Real-Coded Genes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Representation-dependent gene level operations  
        for genetic and evolutionary algorithms with real-coded genes
        are collected in this package. The common feature of the gene
        operations is that all of them are useful for derivation-free
        optimization algorithms. At the moment the package  
        implements initialization, mutation, crossover, and replication 
        operations for differential evolution as described in
        Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
        &lt;<a href="https://doi.org/10.1007%2F3-540-31306-0">doi:10.1007/3-540-31306-0</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaDfGene&amp;gt;">https://github.com/ageyerschulz/xegaDfGene&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>xegaSelectGene</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 14:50:55 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 20:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ConstScaleFactor'>Constant scale factor for differential evolution.</h2><span id='topic+ConstScaleFactor'></span>

<h3>Description</h3>

<p>Constant scale factor for differential evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstScaleFactor(lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstScaleFactor_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A constant scale factor.
</p>


<h3>See Also</h3>

<p>Other ScaleFactor: 
<code><a href="#topic+UniformRandomScaleFactor">UniformRandomScaleFactor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list()
lF$ScaleFactor1&lt;-parm(0.90)
ConstScaleFactor(lF)
ConstScaleFactor(lF)
</code></pre>

<hr>
<h2 id='lFxegaDfGene'>Generate local functions and objects</h2><span id='topic+lFxegaDfGene'></span>

<h3>Description</h3>

<p><code>lFxegaDfGene</code> is 
the list of functions containing
a definition of all local objects required for the use
of evaluation functions. We reference this object 
as local configuration. When adding additional 
functions, this list must be extended
by the constant (functions) needed to configure them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lFxegaDfGene
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 30.
</p>


<h3>Details</h3>

<p>We use the local configuration for: 
</p>

<ol>
<li>
<p>Replacing all constants with constant functions.
</p>
<p>Rationale: We need one formal argument (the local function list lF)
and we can dispatch multiple functions. E.g.  <code>lF$verbose()</code>
</p>
</li>
<li>    
<p>We can dynamically bind a local function with a definition from a
proper function factory. E.g., the selection methods 
<code>lf$SelectGene</code> and <code>lF$SelectMate</code>.
</p>
</li>
<li><p> Gene representations require special functions to handle them:
<code>lf$InitGene</code>, <code>lF$DecodeGene</code>, <code>lf$EvalGene</code>
<code>lf$ReplicateGene</code>, ...
</p>
</li></ol>



<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+xegaDfCrossoverFactory">xegaDfCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaDfGeneMapFactory">xegaDfGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaDfMutationFactory">xegaDfMutationFactory</a>()</code>,
<code><a href="#topic+xegaDfReplicationFactory">xegaDfReplicationFactory</a>()</code>,
<code><a href="#topic+xegaDfScaleFactorFactory">xegaDfScaleFactorFactory</a>()</code>
</p>

<hr>
<h2 id='UniformRandomScaleFactor'>Uniform random scale factor for differential evolution.</h2><span id='topic+UniformRandomScaleFactor'></span>

<h3>Description</h3>

<p>The scale factor is drawn from 
<code>0.000001</code> to <code>1.0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UniformRandomScaleFactor(lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UniformRandomScaleFactor_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A constant scale factor.
</p>


<h3>See Also</h3>

<p>Other ScaleFactor: 
<code><a href="#topic+ConstScaleFactor">ConstScaleFactor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parm&lt;-function(x){function() {return(x)}}
lF&lt;-list()
lF$ScaleFactor1&lt;-parm(0.90)
UniformRandomScaleFactor(lF)
UniformRandomScaleFactor(lF)
</code></pre>

<hr>
<h2 id='xegaDfCrossGene'>One point crossover of 2 genes.</h2><span id='topic+xegaDfCrossGene'></span>

<h3>Description</h3>

<p><code>CrossGene</code> randomly determines a cut point.
It combines the parameters before the cut point of the first gene
with the parameters after the cut point from the second gene (kid 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfCrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfCrossGene_+3A_gg1">gg1</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfCrossGene_+3A_gg2">gg2</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfCrossGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real-coded gene.
</p>


<h3>See Also</h3>

<p>Other Crossover (1): 
<code><a href="#topic+xegaDfUCrossGene">xegaDfUCrossGene</a>()</code>,
<code><a href="#topic+xegaDfUPCrossGene">xegaDfUPCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaDfInitGene(lFxegaDfGene)
gene2&lt;-xegaDfInitGene(lFxegaDfGene)
gene3&lt;-xegaDfCrossGene(gene1, gene2, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfCrossoverFactory'>Configure the crossover function of a genetic algorithm.</h2><span id='topic+xegaDfCrossoverFactory'></span>

<h3>Description</h3>

<p><code>xegaDfCrossoverFactory</code> implements the selection
of one of the crossover functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>
<p>Crossover functions with one kid:
</p>

<ol>
<li><p> &quot;CrossGene&quot; returns <code>CrossGene</code>.
</p>
</li>
<li><p> &quot;UCrossGene&quot; returns <code>UCrossGene</code>. Default.
</p>
</li>
<li><p> &quot;PUCrossGene&quot; returns <code>PUCrossGene</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaDfCrossoverFactory(method = "UCrossGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfCrossoverFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the crossover function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Crossover function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaDfGene">lFxegaDfGene</a></code>,
<code><a href="#topic+xegaDfGeneMapFactory">xegaDfGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaDfMutationFactory">xegaDfMutationFactory</a>()</code>,
<code><a href="#topic+xegaDfReplicationFactory">xegaDfReplicationFactory</a>()</code>,
<code><a href="#topic+xegaDfScaleFactorFactory">xegaDfScaleFactorFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XGene&lt;-xegaDfCrossoverFactory("UCrossGene")
gene1&lt;-xegaDfInitGene(lFxegaDfGene)
gene2&lt;-xegaDfInitGene(lFxegaDfGene)
XGene(gene1, gene2, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfDecodeGene'>Decode a gene</h2><span id='topic+xegaDfDecodeGene'></span>

<h3>Description</h3>

<p><code>xegaDfDecodeGene</code> decodes a real gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfDecodeGene(gene, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfDecodeGene_+3A_gene">gene</code></td>
<td>
<p>Real gene</p>
</td></tr>
<tr><td><code id="xegaDfDecodeGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>xegaDfDecodeGene</code> is the identy function.
</p>


<h3>Value</h3>

<p>Decoded gene.
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaDfGeneMapIdentity">xegaDfGeneMapIdentity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaDfInitGene(lFxegaDfGene)
xegaDfDecodeGene(gene, lFxegaDfGene)

</code></pre>

<hr>
<h2 id='xegaDfGene'>Package xegaDfGene.</h2><span id='topic+xegaDfGene'></span>

<h3>Description</h3>

<p>Genetic operations for real-coded genetic and evolutionary algorithms.
</p>


<h3>Details</h3>

<p>For real-coded genes, the <code>xegaDfGene</code> package provides
</p>

<ul>
<li><p> Gene initialization.
</p>
</li>
<li><p> Decoding of parameters.
</p>
</li>
<li><p> Scaling functions as a function factory for configuration.
</p>
</li>
<li><p> Mutation functions as well as a function factory for configuration.
</p>
</li>
<li><p> Crossover functions as well as a function factory for configuration.
</p>
</li>
<li><p> Replication functions as well as a function factory for configuration. 
</p>
</li></ul>

<p>Current support: 
Functions for differential evolution (de). See Price et al. (2005).
</p>


<h3>Real-Coded Gene Representation</h3>

<p>A real-coded gene is a named list:
</p>

<ul>
<li><p> $gene1      the gene must be a vector of reals.
</p>
</li>
<li><p> $fit        the fitness value of the gene
(for EvalGeneDet and EvalGeneU) or
the mean fitness (for stochastic functions
evaluated with EvalGeneStoch).
</p>
</li>
<li><p> $evaluated  has the gene been evaluated?
</p>
</li>
<li><p> $evalFail   has the evaluation of the gene failed?
</p>
</li>
<li><p> $var        the cumulative variance of the fitness 
of all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $sigma      the standard deviation of the fitness of 
all evaluations of a gene.
(For stochastic functions)
</p>
</li>
<li><p> $obs        the number evaluations of a gene.
(For stochastic functions)
</p>
</li></ul>



<h3>Abstract Interface of Problem Environment</h3>

<p>We reuse the abstract interface of a problem environment 
for binary-coded genes. The number of parameters 
is given by <code>length(penv$bitlength())</code>.
</p>
<p>A problem environment <code>penv</code> must provide:
</p>

<ul>
<li> <p><code>$f(parameters, gene, lF)</code>: 
Function with a real parameter vector as first argument 
which returns a gene 
with evaluated fitness.
</p>
</li>
<li><p> $genelength(): The number of bits of the binary coded
real parameter vector. Used in <code>InitGene</code>.
</p>
</li>
<li><p> $bitlength(): A vector specifying the number of bits 
used for coding each real parameter.
If <code>penv$bitlength()[1]</code> is <code>20</code>, 
then <code>parameters[1]</code> is coded by 20 bits.
Used in <code>GeneMap</code>.
</p>
</li>
<li><p> $lb(): The lower bound vector of each parameter.
Used in <code>GeneMap</code>.
</p>
</li>
<li><p> $ub(): The upper bound vector of each paremeter.
Used in <code>GeneMap</code>.
</p>
</li></ul>



<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation-free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population-related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split in a representation-independent and 
a representation-dependent part:
</p>

<ol>
<li> 
<p>The representation-independent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation-dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation-free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler, and 
<code>xegaDerivationTrees</code> is an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>&lt;URL</h3>

<p>https://github.com/ageyerschulz/xegaDfGene&gt;
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaDfGene')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>


<h3>References</h3>

<p>Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
The Differential Evolution Algorithm (Chapter 2), pp. 37-134. 
In: Differential Evolution. A Practical Approach to Global Optimization.
Springer, Berlin.
&lt;doi:10.1007/3-540-31306-0&gt;
</p>

<hr>
<h2 id='xegaDfGeneMapFactory'>Configure the gene map function of a genetic algorithm.</h2><span id='topic+xegaDfGeneMapFactory'></span>

<h3>Description</h3>

<p><code>xegaDfGeneMapFactory</code> implements the selection
of one of the GeneMap functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error) if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Identity&quot; returns <code>GeneMapIdentity</code>. (Default)
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaDfGeneMapFactory(method = "Identity")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfGeneMapFactory_+3A_method">method</code></td>
<td>
<p>String specifying the GeneMap function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gene map function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaDfGene">lFxegaDfGene</a></code>,
<code><a href="#topic+xegaDfCrossoverFactory">xegaDfCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaDfMutationFactory">xegaDfMutationFactory</a>()</code>,
<code><a href="#topic+xegaDfReplicationFactory">xegaDfReplicationFactory</a>()</code>,
<code><a href="#topic+xegaDfScaleFactorFactory">xegaDfScaleFactorFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XGene&lt;-xegaDfGeneMapFactory("Identity")
gene1&lt;-xegaDfInitGene(lFxegaDfGene)
XGene(gene1, lFxegaDfGene$penv)
</code></pre>

<hr>
<h2 id='xegaDfGeneMapIdentity'>Map the parameter vector of a real-coded gene to an identical vector.</h2><span id='topic+xegaDfGeneMapIdentity'></span>

<h3>Description</h3>

<p><code>GenemapIdentity</code> maps the real parameter vector
to an identical vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfGeneMapIdentity(gene, penv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfGeneMapIdentity_+3A_gene">gene</code></td>
<td>
<p>Real-coded gene (the genotype).</p>
</td></tr>
<tr><td><code id="xegaDfGeneMapIdentity_+3A_penv">penv</code></td>
<td>
<p>Problem environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>gene</em> is a list with 
</p>

<ol>
<li> <p><code>$evaluated</code> Boolean: TRUE if the fitness is known.
</p>
</li>
<li> <p><code>$fit</code>       The fitness of the genotype of 
<code>$gene1</code>         
</p>
</li>
<li> <p><code>$gene1</code>     a real parameter vector (the genetopye).
</p>
</li></ol>

<p>This representation simplifies the implementation 
af various optimizations
and generalizations.
</p>


<h3>Value</h3>

<p>Decoded gene (the phenotype).
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+xegaDfDecodeGene">xegaDfDecodeGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene&lt;-xegaDfInitGene(lFxegaDfGene)
xegaDfGeneMapIdentity(gene$gene1, lFxegaDfGene$penv)

</code></pre>

<hr>
<h2 id='xegaDfInitGene'>Initialize a real-coded gene.</h2><span id='topic+xegaDfInitGene'></span>

<h3>Description</h3>

<p><code>xegaDfInitGene</code> generates a random real-coded gene 
with a given length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfInitGene(lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfInitGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the real-coded representation of 
package <code>xegaDf</code>, <em>gene</em> is a list with 
</p>

<ol>
<li> <p><code>$evaluated</code> Boolean: TRUE if the fitness is known.
</p>
</li>
<li> <p><code>$fit</code>       The fitness of the genotype of 
<code>$gene1</code>         
</p>
</li>
<li> <p><code>$gene1</code>     a real vector (the genetopye).
</p>
</li></ol>

<p>This representation simplifies the implementation 
af various optimizations
and generalizations.
</p>


<h3>Value</h3>

<p>A real-coded gene (a named list):
</p>

<ul>
<li> <p><code>$evaluated</code>: FALSE. See package <code>xegaEvalGene</code>.
</p>
</li>
<li> <p><code>$evalFail</code>:  FALSE. Set by the error handler(s)
in package <code>xegaEvalGene</code> 
in the case of failure.
</p>
</li>
<li> <p><code>$fit</code>:       Fitness.
</p>
</li>
<li> <p><code>$gene1</code>:     A vector of reals.
</p>
</li></ul>



<h3>References</h3>

<p>Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
The Differential Evolution Algorithm (Chapter 2), pp. 37-134. 
In: Differential Evolution. A Practical Approach to Global Optimization.
Springer, Berlin.
&lt;doi:10.1007/3-540-31306-0&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xegaDfInitGene(lFxegaDfGene)

</code></pre>

<hr>
<h2 id='xegaDfMutateGeneDE'>Mutate a gene (differential mutation).</h2><span id='topic+xegaDfMutateGeneDE'></span>

<h3>Description</h3>

<p><code>xegaDfMutateGeneDE</code> mutates a real-coded gene.
The scale factor is given by Scalefactor().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfMutateGeneDE(gene0, gene1, gene2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfMutateGeneDE_+3A_gene0">gene0</code></td>
<td>
<p>Real-coded gene (the base vector).</p>
</td></tr>
<tr><td><code id="xegaDfMutateGeneDE_+3A_gene1">gene1</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfMutateGeneDE_+3A_gene2">gene2</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfMutateGeneDE_+3A_lf">lF</code></td>
<td>
<p>Local configuration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference of gene1 and gene2 is scaled by 
ScaleFactor() and added to gene0.
</p>


<h3>Value</h3>

<p>Real-coded gene.
</p>


<h3>References</h3>

<p>Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
The Differential Evolution Algorithm (Chapter 2), pp. 37-134.
In: Differential Evolution. A Practical Approach to Global Optimization.
Springer, Berlin.
&lt;doi:10.1007/3-540-31306-0&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene0&lt;-xegaDfInitGene(lFxegaDfGene)
gene1&lt;-xegaDfInitGene(lFxegaDfGene)
gene2&lt;-xegaDfInitGene(lFxegaDfGene)
gene&lt;-xegaDfMutateGeneDE(gene0, gene1, gene2, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfMutationFactory'>Configure the mutation function of a genetic algorithm.</h2><span id='topic+xegaDfMutationFactory'></span>

<h3>Description</h3>

<p><code>xegaDfMutationFactory</code> implements the selection
of one of the mutation functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error), if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;MutateGene&quot; returns <code>xegaDfMutateGeneDE</code>.
To provide a working default for more than 
one gene representation.
</p>
</li>
<li><p> &quot;MutateGeneDE&quot; returns <code>xegaDfMutateGeneDE</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaDfMutationFactory(method = "MutateGene")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfMutationFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the mutation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mutation function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaDfGene">lFxegaDfGene</a></code>,
<code><a href="#topic+xegaDfCrossoverFactory">xegaDfCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaDfGeneMapFactory">xegaDfGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaDfReplicationFactory">xegaDfReplicationFactory</a>()</code>,
<code><a href="#topic+xegaDfScaleFactorFactory">xegaDfScaleFactorFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mutate&lt;-xegaDfMutationFactory("MutateGene")
gene1&lt;-xegaDfInitGene(lFxegaDfGene)
gene2&lt;-xegaDfInitGene(lFxegaDfGene)
gene3&lt;-xegaDfInitGene(lFxegaDfGene)
Mutate(gene1, gene2, gene3, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfReplicateGeneDE'>Replicates a gene (differential evolution).</h2><span id='topic+xegaDfReplicateGeneDE'></span>

<h3>Description</h3>

<p><code>ReplicateGeneDE</code> replicates a gene. Replication
is the reproduction function which uses crossover and
mutation. The control flow of differential evolution 
is as follows:
</p>

<ul>
<li><p> A target gene is selected from the population.
</p>
</li>
<li><p> A mutant gene is generated by differential mutation.
</p>
</li>
<li><p> The gene and the mutant gene are crossed to get a 
new gene.
</p>
</li>
<li><p> The gene is accepted if it is at least as good 
as the target gene.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>xegaDfReplicateGeneDE(pop, fit, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfReplicateGeneDE_+3A_pop">pop</code></td>
<td>
<p>Population of binary genes.</p>
</td></tr>
<tr><td><code id="xegaDfReplicateGeneDE_+3A_fit">fit</code></td>
<td>
<p>Fitness vector.</p>
</td></tr>
<tr><td><code id="xegaDfReplicateGeneDE_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>selection="UniformP"</code>,
for <code>crossover="UPCrossGene"</code> and
for <code>accept="Best"</code>
this is 
the algorithm of Price, Storn and Lampinen (2005), page 41.
</p>


<h3>Value</h3>

<p>A list of one gene.
</p>


<h3>References</h3>

<p>Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
The Differential Evolution Algorithm (Chapter 2), pp. 37-134.
In: Differential Evolution. A Practical Approach to Global Optimization.
Springer, Berlin.
&lt;doi:10.1007/3-540-31306-0&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-lapply(rep(0,10), function(x) xegaDfGene::xegaDfInitGene(lFxegaDfGene))
epop10&lt;-lapply(pop10, lFxegaDfGene$EvalGene, lF=lFxegaDfGene)
fit10&lt;-unlist(lapply(epop10, function(x) {x$fit}))
newgenes&lt;-xegaDfReplicateGeneDE(pop10, fit10, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfReplicationFactory'>Configure the replication function of a genetic algorithm.</h2><span id='topic+xegaDfReplicationFactory'></span>

<h3>Description</h3>

<p><code>ReplicationFactory</code> implements the selection
of a replication method. 
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;DE&quot; returns <code>ReplicateGeneDE</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaDfReplicationFactory(method = "DE")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfReplicationFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the replication function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A replication function for genes.
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaDfGene">lFxegaDfGene</a></code>,
<code><a href="#topic+xegaDfCrossoverFactory">xegaDfCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaDfGeneMapFactory">xegaDfGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaDfMutationFactory">xegaDfMutationFactory</a>()</code>,
<code><a href="#topic+xegaDfScaleFactorFactory">xegaDfScaleFactorFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop10&lt;-lapply(rep(0,10), function(x) xegaDfInitGene(lFxegaDfGene))
epop10&lt;-lapply(pop10, lFxegaDfGene$EvalGene, lF=lFxegaDfGene)
fit10&lt;-unlist(lapply(epop10, function(x) {x$fit}))
Replicate&lt;-xegaDfReplicationFactory("DE")
newgenes2&lt;-Replicate(pop10, fit10, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfScaleFactorFactory'>Configure the scale factor function for differential mutation.</h2><span id='topic+xegaDfScaleFactorFactory'></span>

<h3>Description</h3>

<p><code>xegaDfScaleFactorFactory</code> implements the selection
of one of the scale factor functions in this
package by specifying a text string.
The selection fails ungracefully (produces
a runtime error) if the label does not match.
The functions are specified locally.
</p>
<p>Current support:
</p>

<ol>
<li><p> &quot;Const&quot; returns <code>ConstScaleFactor</code>.
</p>
</li>
<li><p> &quot;Uniform&quot; returns <code>UniformRandomScaleFactor</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>xegaDfScaleFactorFactory(method = "Const")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfScaleFactorFactory_+3A_method">method</code></td>
<td>
<p>A string specifying the scale factor function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the literature, several approaches have been suggested.
For a review see Sharma et al. (2019).
</p>


<h3>Value</h3>

<p>A scale factor function for genes.
</p>


<h3>References</h3>

<p>Sharma, Prashant; Sharma, Harish; Kumar, Sandeep; Bansal, Jagdish Chand
(2019):
A Review on Scale Factor Strategies in Differential Evolution Algorithm.
pp. 925-934. In:
Bansal, Jagdish Chand et al. (2019)
Soft Computing for Problem Solving.
Advances in Intelligent Systems and Computing, Vol. 817.
Springer, Singapore, 2019. (ISBN:978-981-13-1594-7)
</p>


<h3>See Also</h3>

<p>Other Configuration: 
<code><a href="#topic+lFxegaDfGene">lFxegaDfGene</a></code>,
<code><a href="#topic+xegaDfCrossoverFactory">xegaDfCrossoverFactory</a>()</code>,
<code><a href="#topic+xegaDfGeneMapFactory">xegaDfGeneMapFactory</a>()</code>,
<code><a href="#topic+xegaDfMutationFactory">xegaDfMutationFactory</a>()</code>,
<code><a href="#topic+xegaDfReplicationFactory">xegaDfReplicationFactory</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f&lt;-xegaDfScaleFactorFactory("Uniform")
f(lFxegaDfGene)
f(lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfUCrossGene'>Uniform crossover of 2 genes.</h2><span id='topic+xegaDfUCrossGene'></span>

<h3>Description</h3>

<p><code>UCrossGene</code> swaps alleles of both genes
with a probability of 0.5. It generates a random 
mask which is used to build the new gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfUCrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfUCrossGene_+3A_gg1">gg1</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfUCrossGene_+3A_gg2">gg2</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfUCrossGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real-coded gene.
</p>


<h3>References</h3>

<p>Syswerda, Gilbert (1989):
Uniform Crossover in Genetic Algorithms. 
In: Schaffer, J. David (Ed.)
Proceedings of the Third International Conference on Genetic Algorithms,
Morgan Kaufmann Publishers, Los Altos, California, pp. 2-9.
(ISBN:1-55860-066-3)
</p>


<h3>See Also</h3>

<p>Other Crossover (1): 
<code><a href="#topic+xegaDfCrossGene">xegaDfCrossGene</a>()</code>,
<code><a href="#topic+xegaDfUPCrossGene">xegaDfUPCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaDfInitGene(lFxegaDfGene)
gene2&lt;-xegaDfInitGene(lFxegaDfGene)
gene3&lt;-xegaDfUCrossGene(gene1, gene2, lFxegaDfGene)
</code></pre>

<hr>
<h2 id='xegaDfUPCrossGene'>Parameterized uniform crossover of 2 genes.</h2><span id='topic+xegaDfUPCrossGene'></span>

<h3>Description</h3>

<p><code>UPCrossGene</code> swaps alleles of both genes
with a probability of <code>lF$UCrossSwap</code>. 
It generate a random 
mask which is used to build the new gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xegaDfUPCrossGene(gg1, gg2, lF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xegaDfUPCrossGene_+3A_gg1">gg1</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfUPCrossGene_+3A_gg2">gg2</code></td>
<td>
<p>Real-coded gene.</p>
</td></tr>
<tr><td><code id="xegaDfUPCrossGene_+3A_lf">lF</code></td>
<td>
<p>Local configuration of the genetic algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real-coded gene.
</p>


<h3>References</h3>

<p>Spears William and De Jong, Kenneth (1991):
On the Virtues of Parametrized Uniform Crossover. 
In: Belew, Richard K. and Booker, Lashon B. (Ed.)
Proceedings of the Fourth International Conference on Genetic Algorithms,
Morgan Kaufmann Publishers, Los Altos, California, pp. 230-236.
(ISBN: 1-55860-208-9)
</p>
<p>Price, Kenneth V., Storn, Rainer M. and Lampinen, Jouni A. (2005)
The Differential Evolution Algorithm (Chapter 2), pp. 37-134.
In: Differential Evolution. A Practical Approach to Global Optimization.
Springer, Berlin.
&lt;doi:10.1007/3-540-31306-0&gt;
</p>


<h3>See Also</h3>

<p>Other Crossover (1): 
<code><a href="#topic+xegaDfCrossGene">xegaDfCrossGene</a>()</code>,
<code><a href="#topic+xegaDfUCrossGene">xegaDfUCrossGene</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1&lt;-xegaDfInitGene(lFxegaDfGene)
gene2&lt;-xegaDfInitGene(lFxegaDfGene)
gene3&lt;-xegaDfUPCrossGene(gene1, gene2, lFxegaDfGene)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
