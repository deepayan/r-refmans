<!DOCTYPE html><html><head><title>Help for package bayesRecon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesRecon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesRecon-package'><p>bayesRecon: Probabilistic Reconciliation via Conditioning</p></a></li>
<li><a href='#carparts_example'><p>Example of a time series from carparts</p></a></li>
<li><a href='#extr_mkt_events'><p>Extreme market events dataset</p></a></li>
<li><a href='#extr_mkt_events_basefc'><p>Base forecasts for the extreme market events dataset</p></a></li>
<li><a href='#get_reconc_matrices'><p>Build hierarchy matrices</p></a></li>
<li><a href='#infantMortality'><p>Infant Mortality grouped time series dataset</p></a></li>
<li><a href='#M3_example'><p>Example of a time series from the M3 forecasting competition</p></a></li>
<li><a href='#reconc_BUIS'><p>BUIS for Probabilistic Reconciliation of forecasts via conditioning</p></a></li>
<li><a href='#reconc_gaussian'><p>Analytical reconciliation of Gaussian base forecasts</p></a></li>
<li><a href='#reconc_MCMC'><p>MCMC for Probabilistic Reconciliation of forecasts via conditioning</p></a></li>
<li><a href='#schaferStrimmer_cov'><p>Schäfer Strimmer covariance shrinkage</p></a></li>
<li><a href='#temporal_aggregation'><p>Temporal aggregation of a time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Reconciliation via Conditioning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dario Azzimonti &lt;dario.azzimonti@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for probabilistic reconciliation of hierarchical forecasts of time series. The available methods include analytical Gaussian reconciliation (Corani et al., 2021) &lt;<a href="https://doi.org/10.1007%2F978-3-030-67664-3_13">doi:10.1007/978-3-030-67664-3_13</a>&gt;, MCMC reconciliation of count time series (Corani et al., 2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2207.09322">doi:10.48550/arXiv.2207.09322</a>&gt;, Bottom-Up Importance Sampling (Zambon et al., 2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2210.02286">doi:10.48550/arXiv.2210.02286</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, lpSolve (&ge; 5.6.18)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, forecast, glarma, scoringRules, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-19 13:37:08 UTC; dario.azzimonti</td>
</tr>
<tr>
<td>Author:</td>
<td>Dario Azzimonti <a href="https://orcid.org/0000-0001-5080-3061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nicolò Rubattu <a href="https://orcid.org/0000-0002-2703-1005"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lorenzo Zambon <a href="https://orcid.org/0000-0002-8939-993X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Giorgio Corani <a href="https://orcid.org/0000-0002-1541-8384"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-19 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesRecon-package'>bayesRecon: Probabilistic Reconciliation via Conditioning</h2><span id='topic+bayesRecon'></span><span id='topic+bayesRecon-package'></span>

<h3>Description</h3>

<p>Provides methods for probabilistic reconciliation of hierarchical forecasts of time series. The available methods include analytical Gaussian reconciliation (Corani et al., 2021) <a href="https://doi.org/10.1007/978-3-030-67664-3_13">doi:10.1007/978-3-030-67664-3_13</a>, MCMC reconciliation of count time series (Corani et al., 2022) <a href="https://doi.org/10.48550/arXiv.2207.09322">doi:10.48550/arXiv.2207.09322</a>, Bottom-Up Importance Sampling (Zambon et al., 2022) <a href="https://doi.org/10.48550/arXiv.2210.02286">doi:10.48550/arXiv.2210.02286</a>.
</p>


<h3>Learn more</h3>

<p>To learn more about <code>bayesRecon</code>, start with the vignettes: <code>browseVignettes(package = "bayesRecon")</code>
</p>


<h3>Main functions</h3>

<p>The package implements reconciliation via conditioning for probabilistic forecasts of hierarchical time series. The main functions are
</p>

<ul>
<li> <p><code><a href="#topic+reconc_gaussian">reconc_gaussian()</a></code>: analytical reconciliation of Gaussian base forecasts;
</p>
</li>
<li> <p><code><a href="#topic+reconc_BUIS">reconc_BUIS()</a></code>: reconciliation of any probabilistic base forecast via importance sampling;
this is the recommended option for non-Gaussian base forecasts;
</p>
</li>
<li> <p><code><a href="#topic+reconc_MCMC">reconc_MCMC()</a></code>: reconciliation of probabilistic discrete base forecasts via Markov Chain Monte Carlo.
</p>
</li></ul>



<h3>Utility functions</h3>


<ul>
<li> <p><code><a href="#topic+temporal_aggregation">temporal_aggregation()</a></code>: temporal aggregation of a given time series object of class <a href="stats.html#topic+ts">ts</a>;
</p>
</li>
<li> <p><code><a href="#topic+get_reconc_matrices">get_reconc_matrices()</a></code>: aggregation and summing matrices for a temporal hierarchy of time series from user-selected list of aggregation levels.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dario Azzimonti <a href="mailto:dario.azzimonti@gmail.com">dario.azzimonti@gmail.com</a> (<a href="https://orcid.org/0000-0001-5080-3061">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Nicolò Rubattu <a href="mailto:nicolo.rubattu@idsia.ch">nicolo.rubattu@idsia.ch</a> (<a href="https://orcid.org/0000-0002-2703-1005">ORCID</a>)
</p>
</li>
<li><p> Lorenzo Zambon <a href="mailto:lorenzo.zambon@idsia.ch">lorenzo.zambon@idsia.ch</a> (<a href="https://orcid.org/0000-0002-8939-993X">ORCID</a>)
</p>
</li>
<li><p> Giorgio Corani <a href="mailto:giorgio.corani@idsia.ch">giorgio.corani@idsia.ch</a> (<a href="https://orcid.org/0000-0002-1541-8384">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Corani, G., Azzimonti, D., Augusto, J.P.S.C., Zaffalon, M. (2021). <em>Probabilistic Reconciliation of Hierarchical Forecast via Bayes' Rule</em>. In: Hutter, F., Kersting, K., Lijffijt, J., Valera, I. (eds) Machine Learning and Knowledge Discovery in Databases. ECML PKDD 2020. Lecture Notes in Computer Science(), vol 12459. Springer, Cham. <a href="https://doi.org/10.1007/978-3-030-67664-3_13">doi:10.1007/978-3-030-67664-3_13</a>.
</p>
<p>Corani, G., Azzimonti, D., Rubattu, N. (2023). <em>Probabilistic reconciliation of count time series</em>. <a href="https://doi.org/10.1016/j.ijforecast.2023.04.003">doi:10.1016/j.ijforecast.2023.04.003</a>.
</p>
<p>Zambon, L., Azzimonti, D. &amp; Corani, G. (2024). <em>Efficient probabilistic reconciliation of forecasts for real-valued and count time series</em>. <a href="https://doi.org/10.1007/s11222-023-10343-y">doi:10.1007/s11222-023-10343-y</a>.
</p>
<p>Zambon, L., Agosto, A., Giudici, P., Corani, G. (2023). <em>Properties of the reconciled distributions for Gaussian and count forecasts</em>. <a href="https://doi.org/10.48550/arXiv.2303.15135">doi:10.48550/arXiv.2303.15135</a>.
</p>

<hr>
<h2 id='carparts_example'>Example of a time series from carparts</h2><span id='topic+carparts_example'></span>

<h3>Description</h3>

<p>A monthly time series from the <code>carparts</code> dataset, 51 observations, Jan 1998 - Mar 2002.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carparts_example
</code></pre>


<h3>Format</h3>

<p>Univariate time series of class <a href="stats.html#topic+ts">ts</a>.
</p>


<h3>Source</h3>

<p>Godahewa, Rakshitha, Bergmeir, Christoph, Webb, Geoff, Hyndman, Rob, &amp; Montero-Manso, Pablo. (2020). Car Parts Dataset (without Missing Values) (Version 2) <a href="https://doi.org/10.5281/zenodo.4656021">doi:10.5281/zenodo.4656021</a>
</p>


<h3>References</h3>

<p>Hyndman, R.J., Koehler, A.B., Ord, J.K., and Snyder, R.D., (2008) Forecasting with exponential
smoothing: the state space approach, Springer
</p>
<p>Godahewa, Rakshitha, Bergmeir, Christoph, Webb, Geoff, Hyndman, Rob, &amp; Montero-Manso, Pablo. (2020). Car Parts Dataset (without Missing Values) (Version 2) <a href="https://doi.org/10.5281/zenodo.4656021">doi:10.5281/zenodo.4656021</a>
</p>

<hr>
<h2 id='extr_mkt_events'>Extreme market events dataset</h2><span id='topic+extr_mkt_events'></span>

<h3>Description</h3>

<p>Count time series of extreme market events in five economic sectors.
The data refer to the trading days between 2004/12/31 and 2018/12/19 (3508 trading days in total).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extr_mkt_events
</code></pre>


<h3>Format</h3>

<p>A multivariate time series of class <a href="stats.html#topic+ts">ts</a>.
</p>


<h3>Details</h3>

<p>The counts are computed by considering 29 companies included in the Euro Stoxx
50 index and observing if the value of the CDS spread on a given day exceeds
the 90-th percentile of its distribution in the last trading year.
The companies are divided in the following  sectors: Financial (FIN), Information
and Communication Technology (ICT), Manufacturing (MFG), Energy (ENG), and Trade (TRD).
</p>
<p>There are 6 time series:
</p>

<ul>
<li><p> 5 bottom time series, corresponding to the daily counts for each sector
</p>
</li>
<li><p> 1 upper time series, which is the sum of all the bottom (ALL)
</p>
</li></ul>



<h3>Source</h3>

<p>Zambon, L., Agosto, A., Giudici, P., Corani, G. (2023). <em>Properties of the reconciled distributions for Gaussian and count forecasts</em>. <a href="https://doi.org/10.48550/arXiv.2303.15135">doi:10.48550/arXiv.2303.15135</a>.
</p>


<h3>References</h3>

<p>Zambon, L., Agosto, A., Giudici, P., Corani, G. (2023). <em>Properties of the reconciled distributions for Gaussian and count forecasts</em>. <a href="https://doi.org/10.48550/arXiv.2303.15135">doi:10.48550/arXiv.2303.15135</a>.
</p>
<p>Agosto, A. (2022). <em>Multivariate Score-Driven Models for Count Time Series to Assess Financial Contagion</em>. <a href="https://doi.org/10.2139/ssrn.4119895">doi:10.2139/ssrn.4119895</a>
</p>

<hr>
<h2 id='extr_mkt_events_basefc'>Base forecasts for the extreme market events dataset</h2><span id='topic+extr_mkt_events_basefc'></span>

<h3>Description</h3>

<p>Base forecasts for the <code>extr_mkt_events</code> dataset, computed using the model by
Agosto, A. (2022). <em>Multivariate Score-Driven Models for Count Time Series to Assess Financial Contagion</em>. <a href="https://doi.org/10.2139/ssrn.4119895">doi:10.2139/ssrn.4119895</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extr_mkt_events_basefc
</code></pre>


<h3>Format</h3>

<p>A list <code>extr_mkt_events_basefc</code> containing
</p>

<dl>
<dt><code>extr_mkt_events_basefc$mu</code></dt><dd><p>data frame of the base forecast means, for each day</p>
</dd>
<dt><code>extr_mkt_events_basefc$size</code></dt><dd><p>data frame of the static base forecast size parameters</p>
</dd>
</dl>



<h3>Details</h3>

<p>The predictive distribution for the bottom time series is a multivariate negative
binomial with a static vector of dispersion parameters and a time-varying vector
of location parameters following a score-driven dynamics.
The base forecasts for the upper time series are computed using a univariate version of this model.
They are in-sample forecasts: for each training instant, they are computed for
time t+1 by conditioning on the counts observed up to time t.
</p>


<h3>Source</h3>

<p>Agosto, A. (2022). <em>Multivariate Score-Driven Models for Count Time Series to Assess Financial Contagion</em>. <a href="https://doi.org/10.2139/ssrn.4119895">doi:10.2139/ssrn.4119895</a>
</p>


<h3>References</h3>

<p>Agosto, A. (2022). <em>Multivariate Score-Driven Models for Count Time Series to Assess Financial Contagion</em>. <a href="https://doi.org/10.2139/ssrn.4119895">doi:10.2139/ssrn.4119895</a>
</p>
<p>Zambon, L., Agosto, A., Giudici, P., Corani, G. (2023). <em>Properties of the reconciled distributions for Gaussian and count forecasts</em>. <a href="https://doi.org/10.48550/arXiv.2303.15135">doi:10.48550/arXiv.2303.15135</a>.
</p>

<hr>
<h2 id='get_reconc_matrices'>Build hierarchy matrices</h2><span id='topic+get_reconc_matrices'></span>

<h3>Description</h3>

<p>Creates the aggregation and summing matrices for a temporal hierarchy of time series
from a user-selected list of aggregation levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_reconc_matrices(agg_levels, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_reconc_matrices_+3A_agg_levels">agg_levels</code></td>
<td>
<p>user-selected list of aggregation levels.</p>
</td></tr>
<tr><td><code id="get_reconc_matrices_+3A_h">h</code></td>
<td>
<p>number of steps ahead for the bottom level forecasts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the named elements:
</p>

<ul>
<li> <p><code>A</code> the aggregation matrix;
</p>
</li>
<li> <p><code>S</code> the summing matrix.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+temporal_aggregation">temporal_aggregation()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayesRecon)

#Create monthly hierarchy
agg_levels &lt;- c(1,2,3,4,6,12)
h &lt;- 12
rec_mat &lt;- get_reconc_matrices(agg_levels, h)
S &lt;- rec_mat$S
A &lt;- rec_mat$A

</code></pre>

<hr>
<h2 id='infantMortality'>Infant Mortality grouped time series dataset</h2><span id='topic+infantMortality'></span>

<h3>Description</h3>

<p>A yearly grouped time series dataset, from 1901 to 2003, of infant mortality counts (deaths) in Australia;
disaggregated by state (see below), and sex (male and female).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infantMortality
</code></pre>


<h3>Format</h3>

<p>List of time series of class <a href="stats.html#topic+ts">ts</a>.
</p>


<h3>Details</h3>

<p>States: New South Wales (NSW), Victoria (VIC), Queensland (QLD), South Australia (SA), Western Australia
(WA), Northern Territory (NT), Australian Capital Territory (ACT), and Tasmania (TAS).
</p>


<h3>Source</h3>

<p>hts package <a href="https://cran.r-project.org/package=hts">CRAN</a>
</p>


<h3>References</h3>

<p>R. J. Hyndman, R. A. Ahmed, G. Athanasopoulos and H.L. Shang (2011) Optimal combination forecasts for hierarchical time series. Computational Statistics and Data Analysis, 55(9), 2579-2589.
</p>

<hr>
<h2 id='M3_example'>Example of a time series from the M3 forecasting competition</h2><span id='topic+M3_example'></span>

<h3>Description</h3>

<p>A monthly time series, from the M3 forecasting competition (&quot;N1485&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M3_example
</code></pre>


<h3>Format</h3>

<p>List of time series of class <a href="stats.html#topic+ts">ts</a>.
</p>


<h3>Source</h3>

<p><a href="https://forecasters.org/resources/time-series-data/m3-competition/">https://forecasters.org/resources/time-series-data/m3-competition/</a>
</p>

<hr>
<h2 id='reconc_BUIS'>BUIS for Probabilistic Reconciliation of forecasts via conditioning</h2><span id='topic+reconc_BUIS'></span>

<h3>Description</h3>

<p>Uses the Bottom-Up Importance Sampling algorithm to draw samples from the reconciled
forecast distribution, which is obtained via conditioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconc_BUIS(
  S,
  base_forecasts,
  in_type,
  distr,
  num_samples = 20000,
  suppress_warnings = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconc_BUIS_+3A_s">S</code></td>
<td>
<p>Summing matrix (n x n_bottom).</p>
</td></tr>
<tr><td><code id="reconc_BUIS_+3A_base_forecasts">base_forecasts</code></td>
<td>
<p>A list containing the base_forecasts, see details.</p>
</td></tr>
<tr><td><code id="reconc_BUIS_+3A_in_type">in_type</code></td>
<td>
<p>A string or a list of length n. If it is a list the i-th element is a string with two possible values:
</p>

<ul>
<li><p> 'samples' if the i-th base forecasts are in the form of samples;
</p>
</li>
<li><p> 'params'  if the i-th base forecasts are in the form of estimated parameters.
</p>
</li></ul>

<p>If it <code>in_type</code> is a string it is assumed that all base forecasts are of the same type.</p>
</td></tr>
<tr><td><code id="reconc_BUIS_+3A_distr">distr</code></td>
<td>
<p>A string or a list of length n describing the type of base forecasts. If it is a list the i-th element is a string with two possible values:
</p>

<ul>
<li><p> 'continuous' or 'discrete' if <code>in_type[[i]]</code>='samples';
</p>
</li>
<li><p> 'gaussian', 'poisson' or 'nbinom' if <code>in_type[[i]]</code>='params'.
</p>
</li></ul>

<p>If <code>distr</code> is a string it is assumed that all distributions are of the same type.</p>
</td></tr>
<tr><td><code id="reconc_BUIS_+3A_num_samples">num_samples</code></td>
<td>
<p>Number of samples drawn from the reconciled distribution.</p>
</td></tr>
<tr><td><code id="reconc_BUIS_+3A_suppress_warnings">suppress_warnings</code></td>
<td>
<p>Logical. If <code>TRUE</code>, no warnings about effective sample size
are triggered. If <code>FALSE</code>, warnings are generated. Default is <code>FALSE</code>. See Details.</p>
</td></tr>
<tr><td><code id="reconc_BUIS_+3A_seed">seed</code></td>
<td>
<p>Seed for reproducibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>base_forecast</code> is a list containing n elements where the i-th element depends on
the values of <code>in_type[[i]]</code> and <code>distr[[i]]</code>.
</p>
<p>If <code>in_type[[i]]</code>='samples', then <code>base_forecast[[i]]</code> is a vector containing samples from the base forecast distribution.
</p>
<p>If <code>in_type[[i]]</code>='params', then <code>base_forecast[[i]]</code> is a vector containing the estimated:
</p>

<ul>
<li><p> mean and sd for the Gaussian base forecast if <code>distr[[i]]</code>='gaussian', see <a href="stats.html#topic+Normal">Normal</a>;
</p>
</li>
<li><p> lambda for the Poisson base forecast if <code>distr[[i]]</code>='poisson', see <a href="stats.html#topic+Poisson">Poisson</a>;
</p>
</li>
<li><p> mu and size for the negative binomial base forecast if <code>distr[[i]]</code>='nbinom', see <a href="stats.html#topic+NegBinomial">NegBinomial</a>.
</p>
</li></ul>

<p>See the description of the parameters <code>in_type</code> and <code>distr</code> for more details.
</p>
<p>The order of the <code>base_forecast</code> list is given by the order of the time series in the summing matrix.
</p>
<p>Warnings are triggered from the Importance Sampling step if:
</p>

<ul>
<li><p> weights are all zeros, then the upper is ignored during reconciliation;
</p>
</li>
<li><p> the effective sample size is &lt; 200;
</p>
</li>
<li><p> the effective sample size is &lt; 1% of the sample size (<code>num_samples</code> if <code>in_type</code> is 'params' or the size of the base forecast if if <code>in_type</code> is 'samples').
</p>
</li></ul>

<p>Note that warnings are an indication that the base forecasts might have issues. Please check the base forecasts in case of warnings.
</p>


<h3>Value</h3>

<p>A list containing the reconciled forecasts. The list has the following named elements:
</p>

<ul>
<li> <p><code>bottom_reconciled_samples</code>: a matrix (n_bottom x <code>num_samples</code>) containing the reconciled samples for the bottom time series;
</p>
</li>
<li> <p><code>upper_reconciled_samples</code>: a matrix (n_upper x <code>num_samples</code>) containing the reconciled samples for the upper time series;
</p>
</li>
<li> <p><code>reconciled_samples</code>: a matrix (n x <code>num_samples</code>) containing the reconciled samples for all time series.
</p>
</li></ul>



<h3>References</h3>

<p>Zambon, L., Azzimonti, D. &amp; Corani, G. (2024). <em>Efficient probabilistic reconciliation of forecasts for real-valued and count time series</em>. <a href="https://doi.org/10.1007/s11222-023-10343-y">doi:10.1007/s11222-023-10343-y</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconc_gaussian">reconc_gaussian()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayesRecon)

# Create a minimal hierarchy with 2 bottom and 1 upper variable
rec_mat &lt;- get_reconc_matrices(agg_levels=c(1,2), h=2)
S &lt;- rec_mat$S


#1) Gaussian base forecasts

#Set the parameters of the Gaussian base forecast distributions
mu1 &lt;- 2
mu2 &lt;- 4
muY &lt;- 9
mus &lt;- c(muY,mu1,mu2)

sigma1 &lt;- 2
sigma2 &lt;- 2
sigmaY &lt;- 3
sigmas &lt;- c(sigmaY,sigma1,sigma2)

base_forecasts = list()
for (i in 1:nrow(S)) {
base_forecasts[[i]] = c(mus[[i]], sigmas[[i]])
}


#Sample from the reconciled forecast distribution using the BUIS algorithm
buis &lt;- reconc_BUIS(S, base_forecasts, in_type="params",
                 distr="gaussian", num_samples=100000, seed=42)

samples_buis &lt;- buis$reconciled_samples

#In the Gaussian case, the reconciled distribution is still Gaussian and can be
#computed in closed form
Sigma &lt;- diag(sigmas^2)  #transform into covariance matrix
analytic_rec &lt;- reconc_gaussian(S, base_forecasts.mu = mus,
                                base_forecasts.Sigma = Sigma)

#Compare the reconciled means obtained analytically and via BUIS
print(c(S %*% analytic_rec$bottom_reconciled_mean))
print(rowMeans(samples_buis))


#2) Poisson base forecasts

#Set the parameters of the Poisson base forecast distributions
lambda1 &lt;- 2
lambda2 &lt;- 4
lambdaY &lt;- 9
lambdas &lt;- c(lambdaY,lambda1,lambda2)

base_forecasts &lt;- list()
for (i in 1:nrow(S)) {
 base_forecasts[[i]] = lambdas[i]
}

#Sample from the reconciled forecast distribution using the BUIS algorithm
buis &lt;- reconc_BUIS(S, base_forecasts, in_type="params",
                          distr="poisson", num_samples=100000, seed=42)
samples_buis &lt;- buis$reconciled_samples

#Print the reconciled means
print(rowMeans(samples_buis))

</code></pre>

<hr>
<h2 id='reconc_gaussian'>Analytical reconciliation of Gaussian base forecasts</h2><span id='topic+reconc_gaussian'></span>

<h3>Description</h3>

<p>Closed form computation of the reconciled forecasts in case of Gaussian base forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconc_gaussian(S, base_forecasts.mu, base_forecasts.Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconc_gaussian_+3A_s">S</code></td>
<td>
<p>summing matrix (n x n_bottom).</p>
</td></tr>
<tr><td><code id="reconc_gaussian_+3A_base_forecasts.mu">base_forecasts.mu</code></td>
<td>
<p>a vector containing the means of the base forecasts.</p>
</td></tr>
<tr><td><code id="reconc_gaussian_+3A_base_forecasts.sigma">base_forecasts.Sigma</code></td>
<td>
<p>a matrix containing the covariance matrix of the base forecasts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the base forecast means and covariance is given by the order of the time series in the summing matrix.
</p>
<p>The function returns only the reconciled parameters of the bottom variables.
The reconciled upper parameters and the reconciled samples for the entire hierarchy can be obtained from the reconciled bottom parameters.
See the example section.
</p>


<h3>Value</h3>

<p>A list containing the bottom reconciled forecasts. The list has the following named elements:
</p>

<ul>
<li> <p><code>bottom_reconciled_mean</code>: reconciled mean for the bottom forecasts;
</p>
</li>
<li> <p><code>bottom_reconciled_covariance</code>: reconciled covariance for the bottom forecasts.
</p>
</li></ul>



<h3>References</h3>

<p>Corani, G., Azzimonti, D., Augusto, J.P.S.C., Zaffalon, M. (2021). <em>Probabilistic Reconciliation of Hierarchical Forecast via Bayes' Rule</em>. In: Hutter, F., Kersting, K., Lijffijt, J., Valera, I. (eds) Machine Learning and Knowledge Discovery in Databases. ECML PKDD 2020. Lecture Notes in Computer Science(), vol 12459. Springer, Cham. <a href="https://doi.org/10.1007/978-3-030-67664-3_13">doi:10.1007/978-3-030-67664-3_13</a>.
</p>
<p>Zambon, L., Agosto, A., Giudici, P., Corani, G. (2023). <em>Properties of the reconciled distributions for Gaussian and count forecasts</em>. <a href="https://doi.org/10.48550/arXiv.2303.15135">doi:10.48550/arXiv.2303.15135</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconc_BUIS">reconc_BUIS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayesRecon)

# Create a minimal hierarchy with 2 bottom and 1 upper variable
rec_mat &lt;- get_reconc_matrices(agg_levels=c(1,2), h=2)
S &lt;- rec_mat$S
A &lt;- rec_mat$A

#Set the parameters of the Gaussian base forecast distributions
mu1 &lt;- 2
mu2 &lt;- 4
muY &lt;- 9
mus &lt;- c(muY,mu1,mu2)

sigma1 &lt;- 2
sigma2 &lt;- 2
sigmaY &lt;- 3
sigmas &lt;- c(sigmaY,sigma1,sigma2)

Sigma &lt;- diag(sigmas^2)  #need to transform into covariance matrix
analytic_rec &lt;- reconc_gaussian(S, base_forecasts.mu = mus,
                               base_forecasts.Sigma = Sigma)

bottom_mu_reconc &lt;- analytic_rec$bottom_reconciled_mean
bottom_Sigma_reconc &lt;- analytic_rec$bottom_reconciled_covariance

# Obtain reconciled mu and Sigma for the upper variable
upper_mu_reconc &lt;- A %*% bottom_mu_reconc
upper_Sigma_reconc &lt;- A %*% bottom_Sigma_reconc %*% t(A)

# Obtain reconciled mu and Sigma for the entire hierarchy
Y_mu_reconc &lt;- S %*% bottom_mu_reconc
Y_Sigma_reconc &lt;- S %*% bottom_Sigma_reconc %*% t(S)  # note: singular matrix

# Obtain reconciled samples for the entire hierarchy:
# i.e., sample from the reconciled bottoms and multiply by S
chol_decomp = chol(bottom_Sigma_reconc) # Compute the Cholesky Decomposition
Z = matrix(rnorm(n = 2000), nrow = 2) # Sample from standard normal
B = chol_decomp %*% Z + matrix(rep(bottom_mu_reconc, 1000), nrow=2) # Apply the transformation

U = S %*% B
Y_reconc = rbind(U, B)

</code></pre>

<hr>
<h2 id='reconc_MCMC'>MCMC for Probabilistic Reconciliation of forecasts via conditioning</h2><span id='topic+reconc_MCMC'></span>

<h3>Description</h3>

<p>Uses Markov Chain Monte Carlo algorithm to draw samples from the reconciled
forecast distribution, which is obtained via conditioning.
</p>
<p>This is a bare-bones implementation of the Metropolis-Hastings algorithm, we suggest the usage of tools to check the convergence.
The function only works with Poisson or Negative Binomial base forecasts.
</p>
<p>The function <code><a href="#topic+reconc_BUIS">reconc_BUIS()</a></code> is generally faster on most hierarchies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconc_MCMC(
  S,
  base_forecasts,
  distr,
  num_samples = 10000,
  tuning_int = 100,
  init_scale = 1,
  burn_in = 1000,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconc_MCMC_+3A_s">S</code></td>
<td>
<p>summing matrix (n x n_bottom).</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_base_forecasts">base_forecasts</code></td>
<td>
<p>list of the parameters of the base forecast distributions, see details.</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_distr">distr</code></td>
<td>
<p>a string describing the type of predictive distribution.</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_num_samples">num_samples</code></td>
<td>
<p>number of samples to draw using MCMC.</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_tuning_int">tuning_int</code></td>
<td>
<p>number of iterations between scale updates of the proposal.</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_init_scale">init_scale</code></td>
<td>
<p>initial scale of the proposal.</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_burn_in">burn_in</code></td>
<td>
<p>number of initial samples to be discarded.</p>
</td></tr>
<tr><td><code id="reconc_MCMC_+3A_seed">seed</code></td>
<td>
<p>seed for reproducibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>base_forecast</code> is a list containing n elements.
Each element is a vector containing the estimated:
</p>

<ul>
<li><p> mean and sd for the Gaussian base forecast, see <a href="stats.html#topic+Normal">Normal</a>, if <code>distr</code>='gaussian';
</p>
</li>
<li><p> lambda for the Poisson base forecast, see <a href="stats.html#topic+Poisson">Poisson</a>, if <code>distr</code>='poisson';
</p>
</li>
<li><p> mu and size for the negative binomial base forecast, see <a href="stats.html#topic+NegBinomial">NegBinomial</a>, if <code>distr</code>='nbinom'.
</p>
</li></ul>

<p>The order of the <code>base_forecast</code> list is given by the order of the time series in the summing matrix.
</p>


<h3>Value</h3>

<p>A list containing the reconciled forecasts. The list has the following named elements:
</p>

<ul>
<li> <p><code>bottom_reconciled_samples</code>: a matrix (n_bottom x <code>num_samples</code>) containing reconciled samples for the bottom time series;
</p>
</li>
<li> <p><code>upper_reconciled_samples</code>: a matrix (n_upper x <code>num_samples</code>) containing reconciled samples for the upper time series;
</p>
</li>
<li> <p><code>reconciled_samples</code>: a matrix (n x <code>num_samples</code>) containing the reconciled samples for all time series.
</p>
</li></ul>



<h3>References</h3>

<p>Corani, G., Azzimonti, D., Rubattu, N. (2023). <em>Probabilistic reconciliation of count time series</em>. <a href="https://doi.org/10.1016/j.ijforecast.2023.04.003">doi:10.1016/j.ijforecast.2023.04.003</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconc_BUIS">reconc_BUIS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayesRecon)

# Create a minimal hierarchy with 2 bottom and 1 upper variable
rec_mat &lt;- get_reconc_matrices(agg_levels=c(1,2), h=2)
S &lt;- rec_mat$S

#Set the parameters of the Poisson base forecast distributions
lambda1 &lt;- 2
lambda2 &lt;- 4
lambdaY &lt;- 9
lambdas &lt;- c(lambdaY,lambda1,lambda2)

base_forecasts = list()
for (i in 1:nrow(S)) {
 base_forecasts[[i]] = lambdas[i]
}

#Sample from the reconciled forecast distribution using MCMC
mcmc = reconc_MCMC(S,base_forecasts=lambdas,distr="poisson",
                  num_samples=30000, seed=42)
samples_mcmc &lt;- mcmc$reconciled_samples

#Compare the reconciled means with those obtained via BUIS
buis = reconc_BUIS(S, base_forecasts, in_type="params",
                   distr="poisson", num_samples=100000, seed=42)
samples_buis &lt;- buis$reconciled_samples

print(rowMeans(samples_mcmc))
print(rowMeans(samples_buis))

</code></pre>

<hr>
<h2 id='schaferStrimmer_cov'>Schäfer Strimmer covariance shrinkage</h2><span id='topic+schaferStrimmer_cov'></span>

<h3>Description</h3>

<p>Computes the Schäfer Strimmer shrinkage estimator for a covariance matrix
from a matrix of samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schaferStrimmer_cov(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schaferStrimmer_cov_+3A_x">x</code></td>
<td>
<p>matrix of samples with dimensions nxp (n samples, p dimensions).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the shrinkage to a diagonal covariance with unequal variances.
Note that here we use the estimators <code class="reqn">S = X X^T/n</code> and <code class="reqn">T = diag(S)</code> and we internally
use the correlation matrix in place of the covariance to compute the optimal shrinkage factor.
</p>


<h3>Value</h3>

<p>A list containing the shrinkage estimator and the optimal lambda. The list has the following named elements:
</p>

<ul>
<li> <p><code>shrink_cov</code>: the shrinked covariance matrix (<code>p</code> x <code>p</code>);
</p>
</li>
<li> <p><code>lambda_star</code>: the optimal lambda for the shrinkage;
</p>
</li></ul>



<h3>References</h3>

<p>Schäfer, Juliane, and Korbinian Strimmer. (2005). <em>A Shrinkage Approach to Large-Scale Covariance Matrix Estimation and Implications for Functional Genomics.</em> Statistical Applications in Genetics and Molecular Biology 4: Article32. <a href="https://doi.org/10.2202/1544-6115.1175">doi:10.2202/1544-6115.1175</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some multivariate normal samples
# Parameters
nSamples &lt;- 200
pTrue &lt;- 2

# True moments
trueSigma &lt;- matrix(c(3,2,2,2), nrow=2)
chol_trueSigma &lt;- chol(trueSigma)
trueMean &lt;- c(0,0) 

# Generate samples
set.seed(42)
x &lt;- replicate(nSamples, trueMean) +  t(chol_trueSigma)%*%matrix(rnorm(pTrue*nSamples), 
                                                                 nrow=pTrue,ncol=nSamples)
x &lt;- t(x) 
res_shrinkage &lt;- schaferStrimmer_cov(x)
res_shrinkage$lambda_star # should be 0.01287923

</code></pre>

<hr>
<h2 id='temporal_aggregation'>Temporal aggregation of a time series</h2><span id='topic+temporal_aggregation'></span>

<h3>Description</h3>

<p>Creates a list of aggregated time series from a time series of class <a href="stats.html#topic+ts">ts</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporal_aggregation(y, agg_levels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporal_aggregation_+3A_y">y</code></td>
<td>
<p>univariate time series of class <a href="stats.html#topic+ts">ts</a>.</p>
</td></tr>
<tr><td><code id="temporal_aggregation_+3A_agg_levels">agg_levels</code></td>
<td>
<p>user-selected list of aggregation levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>agg_levels=NULL</code> then <code>agg_levels</code> is automatically generated by taking all the factors of the time series frequency.
</p>


<h3>Value</h3>

<p>A list of <a href="stats.html#topic+ts">ts</a> objects each containing the aggregates time series in the order defined by <code>agg_levels</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_reconc_matrices">get_reconc_matrices()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a monthly count time series with 100 observations
y &lt;- ts(data=stats::rpois(100,lambda = 2),frequency = 12)

# Create the aggregate time series according to agg_levels
y_agg &lt;- temporal_aggregation(y,agg_levels = c(2,3,4,6,12))

# Show annual aggregate time series
print(y_agg$`f=1`)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
