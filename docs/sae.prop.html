<!DOCTYPE html><html><head><title>Help for package sae.prop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sae.prop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#datasaem'><p>Data generated based on Multivariate Fay Herriot Model with Additive Logistic Transformation</p></a></li>
<li><a href='#datasaem.ns'><p>Data generated based on Multivariate Fay Herriot Model with Additive Logistic Transformation with Non-Sampled Cases</p></a></li>
<li><a href='#datasaeu'><p>Data generated based on Univariate Fay Herriot Model with Additive Logistic Transformation</p></a></li>
<li><a href='#datasaeu.ns'><p>Data generated based on Univariate Fay Herriot Model with Additive Logistic Transformation with Non-Sampled Cases</p></a></li>
<li><a href='#mseFH.mprop'><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation</p></a></li>
<li><a href='#mseFH.ns.mprop'><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p></a></li>
<li><a href='#mseFH.ns.uprop'><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p></a></li>
<li><a href='#mseFH.uprop'><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation</p></a></li>
<li><a href='#sae.prop'><p>sae.prop : Small Area Estimation for Proportion using Fay Herriot Models with Additive Logistic Transformation</p></a></li>
<li><a href='#saeFH.mprop'><p>EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation</p></a></li>
<li><a href='#saeFH.ns.mprop'><p>EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p></a></li>
<li><a href='#saeFH.ns.uprop'><p>EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p></a></li>
<li><a href='#saeFH.uprop'><p>EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Small Area Estimation using Fay-Herriot Models with Additive
Logistic Transformation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Additive Logistic Transformation (alr) for Small Area Estimation under Fay Herriot Model. Small Area Estimation is used to borrow strength from auxiliary variables to improve the effectiveness of a domain sample size. This package uses Empirical Best Linear Unbiased Prediction (EBLUP). The Additive Logistic Transformation (alr) are based on transformation by Aitchison J (1986). The covariance matrix for multivariate application is based on covariance matrix used by Esteban M, Lombardía M, López-Vizcaíno E, Morales D, and Pérez A &lt;<a href="https://doi.org/10.1007%2Fs11749-019-00688-w">doi:10.1007/s11749-019-00688-w</a>&gt;. The non-sampled models are modified area-level models based on models proposed by Anisa R, Kurnia A, and Indahwati I &lt;<a href="https://doi.org/10.9790%2F5728-10121519">doi:10.9790/5728-10121519</a>&gt;, with univariate model using model-3, and multivariate model using model-1. The MSE are estimated using Parametric Bootstrap approach. For non-sampled cases, MSE are estimated using modified approach proposed by Haris F and Ubaidillah A &lt;<a href="https://doi.org/10.4108%2Feai.2-8-2019.2290339">doi:10.4108/eai.2-8-2019.2290339</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mrijalussholihin/sae.prop">https://github.com/mrijalussholihin/sae.prop</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mrijalussholihin/sae.prop/issues">https://github.com/mrijalussholihin/sae.prop/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, magic, MASS, corpcor, progress, fpc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-15 11:29:23 UTC; M. Rijalus Sholihin</td>
</tr>
<tr>
<td>Author:</td>
<td>M. Rijalus Sholihin [aut, cre],
  Cucu Sumarni [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>M. Rijalus Sholihin &lt;m.rijalussholihin@bps.go.id&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-15 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='datasaem'>Data generated based on Multivariate Fay Herriot Model with Additive Logistic Transformation</h2><span id='topic+datasaem'></span>

<h3>Description</h3>

<p>This data is generated based on multivariate Fay-Herriot model and then transformed by using inverse Additive Logistic Transformation (alr). The steps are as follows:
</p>

<ol>
<li><p> Set these following variables:
</p>

<ul>
<li> <p><code class="reqn">q = 4</code>
</p>
</li>
<li> <p><code class="reqn">r_{1} = r_{2} = r_{3} = 2, r = 6</code>
</p>
</li>
<li> <p><code class="reqn">\beta_{1} = (\beta_{11}, \beta_{12})' = (1, 1)', \beta_{2} = (\beta_{21}, \beta_{22})' = (1, 1)', \beta_{3} = (\beta_{31}, \beta_{32})' = (1, 1)'</code>
</p>
</li>
<li> <p><code class="reqn">\mu_{x1} = \mu_{x2} = \mu_{x3}</code> and <code class="reqn">\sigma_{x11} = 1, \sigma_{x22} = 3/2, \sigma_{x33} = 2</code>
</p>
</li>
<li><p> for <code class="reqn">k = 1, 2, \dots, q -1</code> and <code class="reqn">d = 1, \dots, D</code>, generate <code class="reqn">X_{d} = diag(x_{d1}, x_{d2}, x_{d3})_{(q-1) \times r}</code>, where:
</p>

<ul>
<li> <p><code class="reqn">x_{d1} = (x_{d11}, x_{d11})</code>
</p>
</li>
<li> <p><code class="reqn">x_{d1} = (x_{d21}, x_{d22})</code>
</p>
</li>
<li> <p><code class="reqn">x_{d1} = (x_{d31}, x_{d31})</code>
</p>
</li>
<li> <p><code class="reqn">x_{d11} = x_{d21} = x_{d31} = 1</code>
</p>
</li>
<li> <p><code class="reqn">U_{dk} \sim U(0, 1)</code>
</p>
</li>
<li> <p><code class="reqn">x_{d12} = \mu_{x1} + \sigma_{x11}^{1/2}U_{d1}</code>
</p>
</li>
<li> <p><code class="reqn">x_{d22} = \mu_{x2} + \sigma_{x22}^{1/2}U_{d2}</code>
</p>
</li>
<li> <p><code class="reqn">x_{d32} = \mu_{x3} + \sigma_{x33}^{1/2}U_{d3}</code>
</p>
</li></ul>

</li></ul>

</li>
<li><p> For random effects <code class="reqn">u</code>, <code class="reqn">u_{d} \sim N_{q-1}(0, V_{ud})</code>, where <code class="reqn">\theta_{1} = 1, \theta_{2} = 3/2, \theta_{3} = 2, \theta_{4} = -1/2, \theta_{5} = -1/2, \theta_{6} = 0</code>
</p>
</li>
<li><p> For sampling errors <code class="reqn">e</code>, <code class="reqn">e_{d} \sim N_{q-1}(0, V_{ed})</code>, where <code class="reqn">c = -1/4</code>
</p>
</li>
<li><p> The generated data is transformed using inverse alr transformation, so the data will be within the range of proportion.
</p>
</li></ol>

<p>Auxiliary variables <code class="reqn">X_{1}, X_{2}, X_{3}</code>, direct estimation <code class="reqn">Y_{1}, Y_{2}, Y_{3}</code>, and sampling variance-covariance <code class="reqn">v_{1}, v_{2}, v_{3}, v_{12}, v_{13}, v_{23}</code> are combined into a data frame called datasaem. For more details about the structure of covariance matrix, it is available in supplementary materials of Reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasaem
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 12 columns:
</p>

<dl>
<dt>Y1</dt><dd><p>Direct Estimation of Y1</p>
</dd>
<dt>Y2</dt><dd><p>Direct Estimation of Y2</p>
</dd>
<dt>Y3</dt><dd><p>Direct Estimation of Y3</p>
</dd>
<dt>X1</dt><dd><p>Auxiliary variable of X1</p>
</dd>
<dt>X2</dt><dd><p>Auxiliary variable of X2</p>
</dd>
<dt>X3</dt><dd><p>Auxiliary variable of X3</p>
</dd>
<dt>v1</dt><dd><p>Sampling Variance of Y1</p>
</dd>
<dt>v2</dt><dd><p>Sampling Variance of Y2</p>
</dd>
<dt>v3</dt><dd><p>Sampling Variance of Y3</p>
</dd>
<dt>v12</dt><dd><p>Sampling Covariance of Y1 and Y2</p>
</dd>
<dt>v13</dt><dd><p>Sampling Covariance of Y1 and Y3</p>
</dd>
<dt>v23</dt><dd><p>Sampling Covariance of Y2 and Y3</p>
</dd>
</dl>



<h3>Reference</h3>

<p>Esteban, M. D., Lombardía, M. J., López-Vizcaíno, E., Morales, D., &amp; Pérez, A. (2020). Small area estimation of proportions under area-level compositional mixed models. Test, 29(3), 793–818. https://doi.org/10.1007/s11749-019-00688-w.
</p>

<hr>
<h2 id='datasaem.ns'>Data generated based on Multivariate Fay Herriot Model with Additive Logistic Transformation with Non-Sampled Cases</h2><span id='topic+datasaem.ns'></span>

<h3>Description</h3>

<p>This data is generated based on multivariate Fay-Herriot model and then transformed by using inverse Additive Logistic Transformation (alr). Then some domain would be edited to be non-sampled. The steps are as follows:
</p>

<ol>
<li><p> Set these following variables:
</p>

<ul>
<li> <p><code class="reqn">q = 4</code>
</p>
</li>
<li> <p><code class="reqn">r_{1} = r_{2} = r_{3} = 2, r = 6</code>
</p>
</li>
<li> <p><code class="reqn">\beta_{1} = (\beta_{11}, \beta_{12})' = (1, 1)', \beta_{2} = (\beta_{21}, \beta_{22})' = (1, 1)', \beta_{3} = (\beta_{31}, \beta_{32})' = (1, 1)'</code>
</p>
</li>
<li> <p><code class="reqn">\mu_{x1} = \mu_{x2} = \mu_{x3}</code> and <code class="reqn">\sigma_{x11} = 1, \sigma_{x22} = 3/2, \sigma_{x33} = 2</code>
</p>
</li>
<li><p> for <code class="reqn">k = 1, 2, \dots, q -1</code> and <code class="reqn">d = 1, \dots, D</code>, generate <code class="reqn">X_{d} = diag(x_{d1}, x_{d2}, x_{d3})_{(q-1) \times r}</code>, where:
</p>

<ul>
<li> <p><code class="reqn">x_{d1} = (x_{d11}, x_{d11})</code>
</p>
</li>
<li> <p><code class="reqn">x_{d1} = (x_{d21}, x_{d22})</code>
</p>
</li>
<li> <p><code class="reqn">x_{d1} = (x_{d31}, x_{d31})</code>
</p>
</li>
<li> <p><code class="reqn">x_{d11} = x_{d21} = x_{d31} = 1</code>
</p>
</li>
<li> <p><code class="reqn">U_{dk} \sim U(0, 1)</code>
</p>
</li>
<li> <p><code class="reqn">x_{d12} = \mu_{x1} + \sigma_{x11}^{1/2}U_{d1}</code>
</p>
</li>
<li> <p><code class="reqn">x_{d22} = \mu_{x2} + \sigma_{x22}^{1/2}U_{d2}</code>
</p>
</li>
<li> <p><code class="reqn">x_{d32} = \mu_{x3} + \sigma_{x33}^{1/2}U_{d3}</code>
</p>
</li></ul>

</li></ul>

</li>
<li><p> For random effects <code class="reqn">u</code>, <code class="reqn">u_{d} \sim N_{q-1}(0, V_{ud})</code>, where <code class="reqn">\theta_{1} = 1, \theta_{2} = 3/2, \theta_{3} = 2, \theta_{4} = -1/2, \theta_{5} = -1/2, \theta_{6} = 0</code>
</p>
</li>
<li><p> For sampling errors <code class="reqn">e</code>, <code class="reqn">e_{d} \sim N_{q-1}(0, V_{ed})</code>, where <code class="reqn">c = -1/4</code>
</p>
</li>
<li><p> The generated data is transformed using inverse alr transformation, so the data will be within the range of proportion.
</p>
</li>
<li><p> Domain 3, 15, and 25 are set to be examples of non-sampled cases (0, 1, or NA).
</p>
</li>
<li> <p><code class="reqn">c1</code>, <code class="reqn">c2</code>, and <code class="reqn">c3</code> are clusters performed using k-medoids algorithm with <code><a href="fpc.html#topic+pamk">pamk</a></code>.
</p>
</li></ol>

<p>Auxiliary variables <code class="reqn">X_{1}, X_{2}, X_{3}</code>, direct estimation <code class="reqn">Y_{1}, Y_{2}, Y_{3}</code>, sampling variance-covariance <code class="reqn">v_{1}, v_{2}, v_{3}, v_{12}, v_{13}, v_{23}</code>, and cluster <code class="reqn">c1, c2, c3</code> are combined into a data frame called datasaem.ns. For more details about the structure of covariance matrix, it is available in supplementary materials of Reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasaem.ns
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 15 columns:
</p>

<dl>
<dt>Y1</dt><dd><p>Direct Estimation of Y1</p>
</dd>
<dt>Y2</dt><dd><p>Direct Estimation of Y2</p>
</dd>
<dt>Y3</dt><dd><p>Direct Estimation of Y3</p>
</dd>
<dt>X1</dt><dd><p>Auxiliary variable of X1</p>
</dd>
<dt>X2</dt><dd><p>Auxiliary variable of X2</p>
</dd>
<dt>X3</dt><dd><p>Auxiliary variable of X3</p>
</dd>
<dt>v1</dt><dd><p>Sampling Variance of Y1</p>
</dd>
<dt>v2</dt><dd><p>Sampling Variance of Y2</p>
</dd>
<dt>v3</dt><dd><p>Sampling Variance of Y3</p>
</dd>
<dt>v12</dt><dd><p>Sampling Covariance of Y1 and Y2</p>
</dd>
<dt>v13</dt><dd><p>Sampling Covariance of Y1 and Y3</p>
</dd>
<dt>v23</dt><dd><p>Sampling Covariance of Y2 and Y3</p>
</dd>
<dt>c1</dt><dd><p>Cluster of Y1</p>
</dd>
<dt>c2</dt><dd><p>Cluster of Y2</p>
</dd>
<dt>c3</dt><dd><p>Cluster of Y3</p>
</dd>
</dl>



<h3>Reference</h3>

<p>Esteban, M. D., Lombardía, M. J., López-Vizcaíno, E., Morales, D., &amp; Pérez, A. (2020). Small area estimation of proportions under area-level compositional mixed models. Test, 29(3), 793–818. https://doi.org/10.1007/s11749-019-00688-w.
</p>

<hr>
<h2 id='datasaeu'>Data generated based on Univariate Fay Herriot Model with Additive Logistic Transformation</h2><span id='topic+datasaeu'></span>

<h3>Description</h3>

<p>This data is generated based on univariate Fay-Herriot model and then transformed by using inverse Additive Logistic Transformation (alr). The steps are as follows:
</p>

<ol>
<li> <p><code class="reqn">\beta</code> are set to be <code class="reqn">\beta_{0} = \beta_{1} = \beta_{2} = 1</code>
</p>
</li>
<li><p> Auxiliary variables are set as follows:
</p>

<ul>
<li> <p><code class="reqn">x_{1} \sim N(0, 1)</code>
</p>
</li>
<li> <p><code class="reqn">x_{2} \sim N(0.5, 1)</code>
</p>
</li></ul>

</li>
<li><p> For random effects, <code class="reqn">u \sim N(0, V_{u})</code>, where <code class="reqn">V_{u} = 1</code>.
</p>
</li>
<li><p> For sampling errors <code class="reqn">e \sim N(0, V_{ed})</code>, where <code class="reqn">V_{ed}</code> is generated <code class="reqn">V_{ed} \sim InvGamma(50, 0.5)</code>.
</p>
</li>
<li><p> The generated data is transformed using inverse alr transformation, so the data will be within the range of proportion.
</p>
</li></ol>

<p>Auxiliary variables <code class="reqn">x_{1}, x_{2}</code>, direct estimation <code class="reqn">y</code>, and sampling variance <code class="reqn">vardir</code> are combined into a data frame called datasaeu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasaeu
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 4 columns:
</p>

<dl>
<dt>y</dt><dd><p>Direct Estimation of y</p>
</dd>
<dt>x1</dt><dd><p>Auxiliary variable of x1</p>
</dd>
<dt>x2</dt><dd><p>Auxiliary variable of x2</p>
</dd>
<dt>vardir</dt><dd><p>Sampling Variance of y</p>
</dd>
</dl>


<hr>
<h2 id='datasaeu.ns'>Data generated based on Univariate Fay Herriot Model with Additive Logistic Transformation with Non-Sampled Cases</h2><span id='topic+datasaeu.ns'></span>

<h3>Description</h3>

<p>This data is generated based on univariate Fay-Herriot model and then transformed by using inverse Additive Logistic Transformation (alr). Then some domain would be edited to be non-sampled. The steps are as follows:
</p>

<ol>
<li> <p><code class="reqn">\beta</code> are set to be <code class="reqn">\beta_{0} = \beta_{1} = \beta_{2} = 1</code>
</p>
</li>
<li><p> Auxiliary variables are set as follows:
</p>

<ul>
<li> <p><code class="reqn">x_{1} \sim N(0, 1)</code>
</p>
</li>
<li> <p><code class="reqn">x_{2} \sim N(0.5, 1)</code>
</p>
</li></ul>

</li>
<li><p> For random effects, <code class="reqn">u \sim N(0, V_{u})</code>, where <code class="reqn">V_{u} = 1</code>.
</p>
</li>
<li><p> For sampling errors <code class="reqn">e \sim N(0, V_{ed})</code>, where <code class="reqn">V_{ed}</code> is generated <code class="reqn">V_{ed} \sim InvGamma(50, 0.5)</code>.
</p>
</li>
<li><p> The generated data is transformed using inverse alr transformation, so the data will be within the range of proportion.
</p>
</li>
<li><p> Domain 3, 15, and 25 are set to be examples of non-sampled cases (0, 1, or NA).
</p>
</li>
<li> <p><code class="reqn">cluster</code> is cluster performed using k-medoids algorithm with <code><a href="fpc.html#topic+pamk">pamk</a></code>.
</p>
</li></ol>

<p>Auxiliary variables <code class="reqn">x_{1}, x_{2}</code>, direct estimation <code class="reqn">y</code>, and sampling variance <code class="reqn">vardir</code> are combined into a data frame called datasaeu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasaeu.ns
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 rows and 5 columns:
</p>

<dl>
<dt>y</dt><dd><p>Direct Estimation of y</p>
</dd>
<dt>x1</dt><dd><p>Auxiliary variable of x1</p>
</dd>
<dt>x2</dt><dd><p>Auxiliary variable of x2</p>
</dd>
<dt>vardir</dt><dd><p>Sampling Variance of y</p>
</dd>
<dt>cluster</dt><dd><p>Cluster of y</p>
</dd>
</dl>


<hr>
<h2 id='mseFH.mprop'>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation</h2><span id='topic+mseFH.mprop'></span>

<h3>Description</h3>

<p>This function gives the MSE of transformed EBLUP and Empirical Best Predictor (EBP) based on a multivariate Fay-Herriot model with modified parametric bootstrap approach proposed by Gonzalez-Manteiga.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseFH.mprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  L = 1000,
  B = 400,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseFH.mprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="mseFH.mprop_+3A_vardir">vardir</code></td>
<td>
<p>sampling variances of direct estimations. If data is defined, it is a vector containing names of sampling variance columns. If data is not defined, it should be a data frame of sampling variances of direct estimators. The order is <code class="reqn">var1, var2, \dots, var(q-1), cov12, \dots, cov1(q-1), cov23, \dots, cov(q-2)(q-1)</code>.</p>
</td></tr>
<tr><td><code id="mseFH.mprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="mseFH.mprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="mseFH.mprop_+3A_l">L</code></td>
<td>
<p>number of Monte Carlo iterations in calculating Empirical Best Predictor (EBP), Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="mseFH.mprop_+3A_b">B</code></td>
<td>
<p>number of Bootstrap iterations in calculating MSE, Default: <code>400</code>.</p>
</td></tr>
<tr><td><code id="mseFH.mprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list containing the following objects:</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : data frame containing transformed EBLUP estimators using inverse alr for each category.
</p>
</li>
<li> <p><code>EBP</code> : data frame containing Empirical Best Predictor using Monte Carlo for each category.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated covariance matrix of random effects.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a list containing the following objects:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : data frame containing estimated random effect values of the fitted model for each category.
</p>
</li>
<li> <p><code>residuals</code> : data frame containing residuals of the fitted model for each category.
</p>
</li></ul>

<table>
<tr><td><code>mse</code></td>
<td>
<p>a list containing estimated MSE of the estimators.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : estimated MSE of plugin (PC) estimators for each category.
</p>
</li>
<li> <p><code>EBP</code> : estimated MSE of EBP estimators for each category.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaem)

## If data is defined
Fo = list(Y1 ~ X1,
          Y2 ~ X2,
          Y3 ~ X3)
vardir = c("v1", "v2", "v3", "v12", "v13", "v23")
MSE.data &lt;- mseFH.mprop(Fo, vardir, data = datasaem, B = 10)

## If data is undefined
Fo = list(datasaem$Y1 ~ datasaem$X1,
          datasaem$Y2 ~ datasaem$X2,
          datasaem$Y3 ~ datasaem$X3)
vardir = datasaem[, c("v1", "v2", "v3", "v12", "v13", "v23")]
MSE &lt;- mseFH.mprop(Fo, vardir, B = 10)

## See the estimators
MSE$mse

## NOTE:
## B = 10 is just for examples.
## Please choose a proper number for Bootstrap iterations in real calculation.

## End(Not run)

</code></pre>

<hr>
<h2 id='mseFH.ns.mprop'>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</h2><span id='topic+mseFH.ns.mprop'></span>

<h3>Description</h3>

<p>This function gives the MSE of transformed EBLUP based on a multivariate Fay-Herriot model. For sampled domains, MSE is estimated using modified parametric bootstrap approach proposed by Gonzalez-Manteiga. For non-sampled domains, MSE is estimated using modified approach by using average sampling variance of sampled domain in each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseFH.ns.mprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  cluster = "auto",
  B = 400,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseFH.ns.mprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="mseFH.ns.mprop_+3A_vardir">vardir</code></td>
<td>
<p>sampling variances of direct estimations. If data is defined, it is a vector containing names of sampling variance columns. If data is not defined, it should be a data frame of sampling variances of direct estimators. The order is <code class="reqn">var1, var2, \dots, var(q-1), cov12, \dots, cov1(q-1), cov23, \dots, cov(q-2)(q-1)</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.mprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.mprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.mprop_+3A_cluster">cluster</code></td>
<td>
<p>Default: <code>"auto"</code>. If <code>cluster = "auto"</code>, then the clustering will be performed by the function by finding optimal number of cluster. If cluster is a vector containing numbers of cluster for each category, then clustering will be performed based on the chosen number of cluster. If cluster is a data frame or matrix containing cluster information, then the vector will be used directly to find average of random effects. Clustering is performed with k-medoids algorithms using the function <code><a href="fpc.html#topic+pamk">pamk</a></code>. If <code>"auto"</code> is chosen, <code>krange</code> are set to <code>2:(nrow(data)-1)</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.mprop_+3A_b">B</code></td>
<td>
<p>number of Bootstrap iterations in calculating MSE, Default: <code>400</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.mprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr for each categoory.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated covariance matrix of random effects.
</p>
</li>
<li> <p><code>cluster</code> : cluster of each category.
</p>
</li>
<li> <p><code>cluster.information</code> : a list containing data frames with average random effects of sampled domain in each cluster.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a list containing the following objects:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : data frame containing estimated random effect values of the fitted model for each category and their status whether sampled or non-sampled.
</p>
</li>
<li> <p><code>residuals</code> : data frame containing residuals of the fitted model for each category and their status whether sampled or non-sampled.
</p>
</li></ul>

<table>
<tr><td><code>mse</code></td>
<td>
<p>data frame containing estimated MSE of the estimators.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : estimated MSE of plugin (PC) estimators for each category.
</p>
</li>
<li> <p><code>status</code> : status of domain, whether sampled or non-sampled.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaem.ns)

## If data is defined
Fo = list(Y1 ~ X1,
          Y2 ~ X2,
          Y3 ~ X3)
vardir = c("v1", "v2", "v3", "v12", "v13", "v23")
MSE.ns &lt;- mseFH.ns.mprop(Fo, vardir, data = datasaem.ns, B = 10)

## If data is undefined (and option for cluster arguments)
Fo = list(datasaem.ns$Y1 ~ datasaem.ns$X1,
          datasaem.ns$Y2 ~ datasaem.ns$X2,
          datasaem.ns$Y3 ~ datasaem.ns$X3)
vardir = datasaem.ns[, c("v1", "v2", "v3", "v12", "v13", "v23")]

### "auto"
MSE.ns1 &lt;- mseFH.ns.mprop(Fo, vardir, cluster = "auto", B = 10)

### number of clusters
MSE.ns2 &lt;- mseFH.ns.mprop(Fo, vardir, cluster = c(3, 2, 2), B = 10)

### data frame or matrix containing cluster for each domain
MSE.ns3 &lt;- mseFH.ns.mprop(Fo, vardir, cluster = datasaem.ns[, c("c1", "c2", "c3")], B = 10)

## See the estimators
MSE.ns$mse

## NOTE:
## B = 10 is just for examples.
## Please choose a proper number for Bootstrap iterations in real calculation.

## End(Not run)

</code></pre>

<hr>
<h2 id='mseFH.ns.uprop'>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</h2><span id='topic+mseFH.ns.uprop'></span>

<h3>Description</h3>

<p>This function gives the MSE of transformed EBLUP based on a univariate Fay-Herriot model. For sampled domains, MSE is estimated using modified parametric bootstrap approach proposed by Butar &amp; Lahiri. For non-sampled domains, MSE is estimated using modified approach proposed by Haris &amp; Ubaidillah.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseFH.ns.uprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  cluster = "auto",
  B = 1000,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseFH.ns.uprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="mseFH.ns.uprop_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the sampling variances of direct estimators for each domain. The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.uprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.uprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.uprop_+3A_cluster">cluster</code></td>
<td>
<p>Default: <code>"auto"</code>. If <code>cluster = "auto"</code>, then the clustering will be performed by the function by finding optimal number of cluster. If cluster is a number, then clustering will be performed based on the chosen number of cluster. If cluster is a vector containing cluster information, then the vector will be used directly to find average of random effects. Clustering is performed with k-medoids algorithms using the function <code><a href="fpc.html#topic+pamk">pamk</a></code>. If <code>"auto"</code> is chosen, <code>krange</code> are set to <code>2:(nrow(data)-1)</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.uprop_+3A_b">B</code></td>
<td>
<p>number of Bootstrap iterations in calculating MSE, Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="mseFH.ns.uprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li>
<li> <p><code>cluster</code> : cluster of corresponding domain.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated random effects variance.
</p>
</li>
<li> <p><code>cluster.information</code> : a data frame containing average random effects of sampled domain in each cluster.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a data frame containing the following columns:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : estimated random effect values of the fitted model.
</p>
</li>
<li> <p><code>residuals</code> : residuals of the fitted model.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li></ul>

<table>
<tr><td><code>mse</code></td>
<td>
<p>a data frame containing estimated MSE of the estimators.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : estimated MSE of plugin (PC) estimators.
</p>
</li>
<li> <p><code>status</code> : status of domain, whether sampled or non-sampled.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaeu.ns)

## If data is defined
Fo = y ~ x1 + x2
vardir = "vardir"
MSE.ns &lt;- mseFH.ns.uprop(Fo, vardir, data = datasaeu.ns)

## If data is undefined (and option for cluster arguments)
Fo = datasaeu.ns$y ~ datasaeu.ns$x1 + datasaeu.ns$x2
vardir = datasaeu.ns$vardir

### "auto"
MSE.ns1 &lt;- mseFH.ns.uprop(Fo, vardir, cluster = "auto")

### number of clusters
MSE.ns2 &lt;- mseFH.ns.uprop(Fo, vardir, cluster = 2)

### vector containing cluster for each domain
MSE.ns3 &lt;- mseFH.ns.uprop(Fo, vardir, cluster = datasaeu.ns$cluster)

## See the estimators
MSE.ns$mse

## End(Not run)

</code></pre>

<hr>
<h2 id='mseFH.uprop'>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation</h2><span id='topic+mseFH.uprop'></span>

<h3>Description</h3>

<p>This function gives the MSE of transformed EBLUP and Empirical Best Predictor (EBP) based on a univariate Fay-Herriot model with modified parametric bootstrap approach proposed by Butar &amp; Lahiri.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mseFH.uprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  L = 1000,
  B = 1000,
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mseFH.uprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="mseFH.uprop_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the sampling variances of direct estimators for each domain. The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="mseFH.uprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="mseFH.uprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="mseFH.uprop_+3A_l">L</code></td>
<td>
<p>number of Monte Carlo iterations in calculating Empirical Best Predictor (EBP), Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="mseFH.uprop_+3A_b">B</code></td>
<td>
<p>number of Bootstrap iterations in calculating MSE, Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="mseFH.uprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr.
</p>
</li>
<li> <p><code>EBP</code> : Empirical Best Predictor using Monte Carlo.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated random effects variance.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a data frame containing the following columns:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : estimated random effect values of the fitted model.
</p>
</li>
<li> <p><code>residuals</code> : residuals of the fitted model.
</p>
</li></ul>

<table>
<tr><td><code>mse</code></td>
<td>
<p>a data frame containing estimated MSE of the estimators.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : estimated MSE of plugin (PC) estimators.
</p>
</li>
<li> <p><code>EBP</code> : estimated MSE of EBP estimators.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaeu)

## If data is defined
Fo = y ~ x1 + x2
vardir = "vardir"
MSE.data &lt;- mseFH.uprop(Fo, vardir, data = datasaeu)

## If data is undefined
Fo = datasaeu$y ~ datasaeu$x1 + datasaeu$x2
vardir = datasaeu$vardir
MSE &lt;- mseFH.uprop(Fo, vardir)

## See the estimators
MSE$mse

## End(Not run)

</code></pre>

<hr>
<h2 id='sae.prop'>sae.prop : Small Area Estimation for Proportion using Fay Herriot Models with Additive Logistic Transformation</h2><span id='topic+sae.prop'></span>

<h3>Description</h3>

<p>Implements Additive Logistic Transformation (alr) for Small Area Estimation under Fay Herriot Model. Small Area Estimation is used to borrow strength from auxiliary variables to improve the effectiveness of a domain sample size. This package uses Empirical Best Linear Unbiased Prediction (EBLUP) estimator. The Additive Logistic Transformation (alr) are based on transformation by Aitchison J (1986). The covariance matrix for multivariate application is base on covariance matrix used by Esteban M, Lombardía M, López-Vizcaíno E, Morales D, and Pérez A &lt;doi:10.1007/s11749-019-00688-w&gt;. The non-sampled models are modified area-level models based on models proposed by Anisa R, Kurnia A, and Indahwati I &lt;doi:10.9790/5728-10121519&gt;, with univariate model using model-3, and multivariate model using model-1. The MSE are estimated using Parametric Bootstrap approach. For non-sampled cases, MSE are estimated using modified approach proposed by Haris F and Ubaidillah A &lt;doi:10.4108/eai.2-8-2019.2290339&gt;.
</p>


<h3>Author(s)</h3>

<p>M. Rijalus Sholihin, Cucu Sumarni
</p>
<p><strong>Maintainer</strong>: M. Rijalus Sholihin <a href="mailto:221810400@stis.ac.id">221810400@stis.ac.id</a>
</p>


<h3>Functions</h3>


<dl>
<dt><code><a href="#topic+saeFH.uprop">saeFH.uprop</a></code></dt><dd><p>EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation</p>
</dd>
<dt><code><a href="#topic+mseFH.uprop">mseFH.uprop</a></code></dt><dd><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation</p>
</dd>
<dt><code><a href="#topic+saeFH.ns.uprop">saeFH.ns.uprop</a></code></dt><dd><p>EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p>
</dd>
<dt><code><a href="#topic+mseFH.ns.uprop">mseFH.ns.uprop</a></code></dt><dd><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p>
</dd>
<dt><code><a href="#topic+saeFH.mprop">saeFH.mprop</a></code></dt><dd><p>EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation</p>
</dd>
<dt><code><a href="#topic+mseFH.mprop">mseFH.mprop</a></code></dt><dd><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation</p>
</dd>
<dt><code><a href="#topic+saeFH.ns.mprop">saeFH.ns.mprop</a></code></dt><dd><p>EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p>
</dd>
<dt><code><a href="#topic+mseFH.ns.mprop">mseFH.ns.mprop</a></code></dt><dd><p>Parametric Bootstrap Mean Squared Error of EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</p>
</dd>
</dl>



<h3>Reference</h3>


<ul>
<li><p>Rao, J.N.K &amp; Molina. (2015). Small Area Estimation 2nd Edition. New York: John Wiley and Sons, Inc.
</p>
</li>
<li><p>Aitchison, J. (1986). The Statistical Analysis of Compositional Data. Springer Netherlands.
</p>
</li>
<li><p>Esteban, M. D., Lombardía, M. J., López-Vizcaíno, E., Morales, D., &amp; Pérez, A. (2020). Small area estimation of proportions under area-level compositional mixed models. Test, 29(3), 793–818. https://doi.org/10.1007/s11749-019-00688-w.
</p>
</li>
<li><p>Anisa, R., Kurnia, A., &amp; Indahwati, I. (2014). Cluster Information of Non-Sampled Area In Small Area Estimation. IOSR Journal of Mathematics, 10(1), 15–19. https://doi.org/10.9790/5728-10121519.
</p>
</li>
<li><p>Haris, F., &amp; Ubaidillah, A. (2020, January 21). Mean Square Error of Non-Sampled Area in Small Area Estimation. https://doi.org/10.4108/eai.2-8-2019.2290339.
</p>
</li></ul>


<hr>
<h2 id='saeFH.mprop'>EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation</h2><span id='topic+saeFH.mprop'></span>

<h3>Description</h3>

<p>This function gives the transformed EBLUP and Empirical Best Predictor (EBP) based on a multivariate Fay-Herriot model. This function is used for multinomial compositional data. If data has <code class="reqn">P</code> as proportion and total of <code class="reqn">q</code> categories <code class="reqn">(P_{1} + P_{2} + \dots + P_{q} = 1)</code>, then function should be used to estimate <code class="reqn">{P_{1}, P_{2}, \dots, P_{q-1}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saeFH.mprop(formula, vardir, MAXITER = 100, PRECISION = 1e-04, L = 1000, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saeFH.mprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="saeFH.mprop_+3A_vardir">vardir</code></td>
<td>
<p>sampling variances of direct estimations. If data is defined, it is a vector containing names of sampling variance columns. If data is not defined, it should be a data frame of sampling variances of direct estimators. The order is <code class="reqn">var1, var2, \dots, var(q-1), cov12, \dots, cov1(q-1), cov23, \dots, cov(q-2)(q-1)</code>.</p>
</td></tr>
<tr><td><code id="saeFH.mprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="saeFH.mprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="saeFH.mprop_+3A_l">L</code></td>
<td>
<p>number of Monte Carlo iterations in calculating Empirical Best Predictor (EBP), Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="saeFH.mprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a list containing data frame of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr for each category.
</p>
</li>
<li> <p><code>EBP</code> : Empirical Best Predictor using Monte Carlo for each category.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated covariance matrix of random effects.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a list containing the following objects:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : data frame containing estimated random effect values of the fitted model for each category.
</p>
</li>
<li> <p><code>residuals</code> : data frame containing residuals of the fitted model for each category.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaem)

## If data is defined
Fo = list(Y1 ~ X1,
          Y2 ~ X2,
          Y3 ~ X3)
vardir = c("v1", "v2", "v3", "v12", "v13", "v23")
model.data &lt;- saeFH.mprop(Fo, vardir, data = datasaem)

Fo = list(datasaem$Y1 ~ datasaem$X1,
          datasaem$Y2 ~ datasaem$X2,
          datasaem$Y3 ~ datasaem$X3)
vardir = datasaem[, c("v1", "v2", "v3", "v12", "v13", "v23")]
model &lt;- saeFH.mprop(Fo, vardir)

## See the estimators
model$est

## End(Not run)

</code></pre>

<hr>
<h2 id='saeFH.ns.mprop'>EBLUPs based on a Multivariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</h2><span id='topic+saeFH.ns.mprop'></span>

<h3>Description</h3>

<p>This function gives the transformed EBLUP based on a multivariate Fay-Herriot model. Random effects for sampled domains are from the fitted model and random effects for non-sampled domains are from cluster information. This function is used for multinomial compositional data. If data has <code class="reqn">P</code> as proportion and total of <code class="reqn">q</code> categories <code class="reqn">(P_{1} + P_{2} + \dots + P_{q} = 1)</code>, then function should be used to estimate <code class="reqn">{P_{1}, P_{2}, \dots, P_{q-1}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saeFH.ns.mprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  cluster = "auto",
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saeFH.ns.mprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="saeFH.ns.mprop_+3A_vardir">vardir</code></td>
<td>
<p>sampling variances of direct estimations. If data is defined, it is a vector containing names of sampling variance columns. If data is not defined, it should be a data frame of sampling variances of direct estimators. The order is <code class="reqn">var1, var2, \dots, var(q-1), cov12, \dots, cov1(q-1), cov23, \dots, cov(q-2)(q-1)</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.mprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.mprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.mprop_+3A_cluster">cluster</code></td>
<td>
<p>Default: <code>"auto"</code>. If <code>cluster = "auto"</code>, then the clustering will be performed by the function by finding optimal number of cluster. If cluster is a vector containing numbers of cluster for each category, then clustering will be performed based on the chosen number of cluster. If cluster is a data frame or matrix containing cluster information, then the vector will be used directly to find average of random effects. Clustering is performed with k-medoids algorithms using the function <code><a href="fpc.html#topic+pamk">pamk</a></code>. If <code>"auto"</code> is chosen, <code>krange</code> are set to <code>2:(nrow(data)-1)</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.mprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr for each categoory.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated covariance matrix of random effects.
</p>
</li>
<li> <p><code>cluster</code> : cluster of each category.
</p>
</li>
<li> <p><code>cluster.information</code> : a list containing data frames with average random effects of sampled domain in each cluster.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a list containing the following objects:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : data frame containing estimated random effect values of the fitted model for each category and their status whether sampled or non-sampled.
</p>
</li>
<li> <p><code>residuals</code> : data frame containing residuals of the fitted model for each category and their status whether sampled or non-sampled.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaem.ns)

## If data is defined
Fo = list(Y1 ~ X1,
          Y2 ~ X2,
          Y3 ~ X3)
vardir = c("v1", "v2", "v3", "v12", "v13", "v23")
model.ns &lt;- saeFH.ns.mprop(Fo, vardir, data = datasaem.ns)

## If data is undefined (and option for cluster arguments)
Fo = list(datasaem.ns$Y1 ~ datasaem.ns$X1,
          datasaem.ns$Y2 ~ datasaem.ns$X2,
          datasaem.ns$Y3 ~ datasaem.ns$X3)
vardir = datasaem.ns[, c("v1", "v2", "v3", "v12", "v13", "v23")]

### "auto"
model.ns1 &lt;- saeFH.ns.mprop(Fo, vardir, cluster = "auto")

### number of clusters
model.ns2 &lt;- saeFH.ns.mprop(Fo, vardir, cluster = c(3, 2, 2))

### data frame or matrix containing cluster for each domain
model.ns3 &lt;- saeFH.ns.mprop(Fo, vardir, cluster = datasaem.ns[, c("c1", "c2", "c3")])

## See the estimators
model.ns$est

## End(Not run)

</code></pre>

<hr>
<h2 id='saeFH.ns.uprop'>EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation for Non-Sampled Data</h2><span id='topic+saeFH.ns.uprop'></span>

<h3>Description</h3>

<p>This function gives the transformed EBLUP based on a univariate Fay-Herriot model. Random effects for sampled domains are from the fitted model and random effects for non-sampled domains are from cluster information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saeFH.ns.uprop(
  formula,
  vardir,
  MAXITER = 100,
  PRECISION = 1e-04,
  cluster = "auto",
  data
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saeFH.ns.uprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="saeFH.ns.uprop_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the sampling variances of direct estimators for each domain. The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.uprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.uprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.uprop_+3A_cluster">cluster</code></td>
<td>
<p>Default: <code>"auto"</code>. If <code>cluster = "auto"</code>, then the clustering will be performed by the function by finding optimal number of cluster. If cluster is a number, then clustering will be performed based on the chosen number of cluster. If cluster is a vector containing cluster information, then the vector will be used directly to find average of random effects. Clustering is performed with k-medoids algorithms using the function <code><a href="fpc.html#topic+pamk">pamk</a></code>. If <code>"auto"</code> is chosen, <code>krange</code> are set to <code>2:(nrow(data)-1)</code>.</p>
</td></tr>
<tr><td><code id="saeFH.ns.uprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li>
<li> <p><code>cluster</code> : cluster of corresponding domain.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated random effects variance.
</p>
</li>
<li> <p><code>cluster.information</code> : a data frame containing average random effects of sampled domain in each cluster.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a data frame containing the following columns:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : estimated random effect values of the fitted model.
</p>
</li>
<li> <p><code>residuals</code> : residuals of the fitted model.
</p>
</li>
<li> <p><code>status</code> : status of corresponding domain, whether sampled or non-sampled.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaeu.ns)

## If data is defined
Fo = y ~ x1 + x2
vardir = "vardir"
model.ns &lt;- saeFH.ns.uprop(Fo, vardir, data = datasaeu.ns)

## If data is undefined (and option for cluster arguments)
Fo = datasaeu.ns$y ~ datasaeu.ns$x1 + datasaeu.ns$x2
vardir = datasaeu.ns$vardir

### "auto"
model.ns1 &lt;- saeFH.ns.uprop(Fo, vardir, cluster = "auto")

### number of clusters
model.ns2 &lt;- saeFH.ns.uprop(Fo, vardir, cluster = 2)

### vector containing cluster for each domain
model.ns3 &lt;- saeFH.ns.uprop(Fo, vardir, cluster = datasaeu.ns$cluster)

## See the estimators
model.ns$est

## End(Not run)

</code></pre>

<hr>
<h2 id='saeFH.uprop'>EBLUPs based on a Univariate Fay Herriot model with Additive Logistic Transformation</h2><span id='topic+saeFH.uprop'></span>

<h3>Description</h3>

<p>This function gives the transformed EBLUP and Empirical Best Predictor (EBP) based on a univariate Fay-Herriot model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saeFH.uprop(formula, vardir, MAXITER = 100, PRECISION = 1e-04, L = 1000, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saeFH.uprop_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> that describe the fitted model.</p>
</td></tr>
<tr><td><code id="saeFH.uprop_+3A_vardir">vardir</code></td>
<td>
<p>vector containing the sampling variances of direct estimators for each domain. The values must be sorted as the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="saeFH.uprop_+3A_maxiter">MAXITER</code></td>
<td>
<p>maximum number of iterations allowed in the Fisher-scoring algorithm, Default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="saeFH.uprop_+3A_precision">PRECISION</code></td>
<td>
<p>convergence tolerance limit for the Fisher-scoring algorithm, Default: <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="saeFH.uprop_+3A_l">L</code></td>
<td>
<p>number of Monte Carlo iterations in calculating Empirical Best Predictor (EBP), Default: <code>1000</code>.</p>
</td></tr>
<tr><td><code id="saeFH.uprop_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in <code>formula</code> and <code>vardir</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following objects:
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a data frame containing values of the estimators for each domains.</p>
</td></tr>
</table>

<ul>
<li> <p><code>PC</code> : transformed EBLUP estimators using inverse alr.
</p>
</li>
<li> <p><code>EBP</code> : Empirical Best Predictor using Monte Carlo.
</p>
</li></ul>

<table>
<tr><td><code>fit</code></td>
<td>
<p>a list containing the following objects (model is fitted using REML):</p>
</td></tr>
</table>

<ul>
<li> <p><code>convergence</code> : a logical value equal to <code>TRUE</code> if Fisher-scoring algorithm converges in less than <code>MAXITER</code> iterations.
</p>
</li>
<li> <p><code>iterations</code> : number of iterations performed by the Fisher-scoring algorithm.
</p>
</li>
<li> <p><code>estcoef</code> : a data frame that contains the estimated model coefficients, standard errors, t-statistics, and p-values of each coefficient.
</p>
</li>
<li> <p><code>refvar</code> : estimated random effects variance.
</p>
</li></ul>

<table>
<tr><td><code>components</code></td>
<td>
<p>a data frame containing the following columns:</p>
</td></tr>
</table>

<ul>
<li> <p><code>random.effects</code> : estimated random effect values of the fitted model.
</p>
</li>
<li> <p><code>residuals</code> : residuals of the fitted model.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Load dataset
data(datasaeu)

## If data is defined
Fo = y ~ x1 + x2
vardir = "vardir"
model.data &lt;- saeFH.uprop(Fo, vardir, data = datasaeu)

## If data is undefined
Fo = datasaeu$y ~ datasaeu$x1 + datasaeu$x2
vardir = datasaeu$vardir
model &lt;- saeFH.uprop(Fo, vardir)

## See the estimators
model$est

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
