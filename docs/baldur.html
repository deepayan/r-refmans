<!DOCTYPE html><html><head><title>Help for package baldur</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baldur}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baldur-package'><p>The 'baldur' package.</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#calculate_mean_sd_trends'><p>Calculate the Mean-Variance trend</p></a></li>
<li><a href='#empirical_bayes'><p>Baldur's empirical Bayes Prior For The Mean In Conditions</p></a></li>
<li><a href='#estimate_gamma_hyperparameters'><p>Estimate Gamma hyperparameters for sigma</p></a></li>
<li><a href='#estimate_uncertainty'><p>Estimate measurement uncertainty</p></a></li>
<li><a href='#fit_gamma_regression'><p>Function for Fitting the Mean-Variance Gamma Regression Models</p></a></li>
<li><a href='#fit_lgmr'><p>Fit Latent Gamma Mixture Regression</p></a></li>
<li><a href='#infer_data_and_decision_model'><p>Sample the Posterior of the data and decision model and generate point</p>
estimates</a></li>
<li><a href='#lgmr_model'><p>Latent Gamma Regression Model</p></a></li>
<li><a href='#lgmr_plotting'><p>Visualization of LGMR models</p></a></li>
<li><a href='#plot_gamma'><p>Function for plotting the gamma regression for the mean-variance trend</p></a></li>
<li><a href='#plot_gamma_regression'><p>Function for plotting the mean-variance gamma regressions</p></a></li>
<li><a href='#plot_sa'><p>Plot the trend between the log fold-change and sigma, coloring significant hits</p></a></li>
<li><a href='#plot_volcano'><p>Plot the -log10(err) against the log fold-change</p></a></li>
<li><a href='#psrn'><p>Normalize data to a pseudo-reference</p></a></li>
<li><a href='#ups'><p>Spiked-in data set of peptides</p></a></li>
<li><a href='#weakly_informative'><p>Baldur's weakly informative prior for the mean in conditions</p></a></li>
<li><a href='#yeast'><p>Spiked-in data set of reversibly oxidized cysteines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Hierarchical Modeling for Label-Free Proteomics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical decision in proteomics data using a hierarchical
    Bayesian model. There are two regression models for describing the 
    mean-variance trend, a gamma regression or a latent gamma mixture
    regression. The regression model is then used as an Empirical Bayes
    estimator for the prior on the variance in a peptide. Further, it assumes
    that each measurement has an uncertainty (increased variance) associated
    with it that is also inferred. Finally, it tries to estimate the posterior
    distribution (by Hamiltonian Monte Carlo) for the differences in means for
    each peptide in the data. Once the posterior is inferred, it integrates the
    tails to estimate the probability of error from which a statistical decision
    can be made.
    See Berg and Popescu for details (&lt;<a href="https://doi.org/10.1101%2F2023.05.11.540411">doi:10.1101/2023.05.11.540411</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PhilipBerg/baldur">https://github.com/PhilipBerg/baldur</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.9), magrittr (&ge; 2.0.3), methods, purrr (&ge;
0.3.4), Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rstan (&ge;
2.26.0), rstantools (&ge; 2.2.0), stats, stringr (&ge; 1.0.4),
tidyr (&ge; 1.2.0), rlang (&ge; 1.0.2), Rdpack (&ge; 2.4), multidplyr
(&ge; 0.1.1), ggplot2 (&ge; 3.3.6), tibble (&ge; 3.1.7), viridisLite
(&ge; 0.4.1), lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PhilipBerg/baldur/issues">https://github.com/PhilipBerg/baldur/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-12 15:21:02 UTC; Pberg</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Berg <a href="https://orcid.org/0000-0002-3772-6185"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Berg &lt;pb1015@msstate.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-18 08:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='baldur-package'>The 'baldur' package.</h2><span id='topic+baldur-package'></span><span id='topic+baldur'></span>

<h3>Description</h3>

<p><code>baldur</code> is a Bayesian hierarchical model for statistical decision
in proteomics data. It models the mean-variance trend with the option of
two different regression models, a gamma regression or a latent gamma
mixture regression. It then the regression model as en Empirical Bayes
estimator for the prior on the variance. Further, it assumes that
each measurement has an uncertainty (increased variance) associated with it
that it also infers. Finally, it tries to estimate the posterior
distribution (by Hamiltonian Monte Carlo) for the differences in means for
each peptide in the data. Once the posterior is inferred, it integrates the
tails to estimate the probability of error from which a statistical
decision can be made.
</p>


<h3>References</h3>

<p>Berg and Popescu (2023). Baldur: Bayesian Hierarchical Modeling
For Label-Free Proteomics Exploiting Gamma Dependent Mean-Variance Trends.
Under review.
Stan Development Team (2022). RStan: the R interface to Stan. R package version
2.21.5. https://mc-stan.org
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='calculate_mean_sd_trends'>Calculate the Mean-Variance trend</h2><span id='topic+calculate_mean_sd_trends'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Calculates the mean and standard deviation of each row (peptide)
and adds them as new columns. Assumes that the condition names are the
names in the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_mean_sd_trends(data, design_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_mean_sd_trends_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> to annotate with mean and sd</p>
</td></tr>
<tr><td><code id="calculate_mean_sd_trends_+3A_design_matrix">design_matrix</code></td>
<td>
<p>A design matrix for the data (see example).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with the mean and sd vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setup model matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

yeast %&gt;%
    # Normalize data
    psrn("identifier") %&gt;%
    # Get mean-variance trends
    calculate_mean_sd_trends(design)
</code></pre>

<hr>
<h2 id='empirical_bayes'>Baldur's empirical Bayes Prior For The Mean In Conditions</h2><span id='topic+empirical_bayes'></span>

<h3>Description</h3>

<p>Here we assume that the sample mean of each condition is an estimator for the center of the mean prior.
In addition, it assumes that the confidence in the prior is proportional to the variance of the peptide.
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\mu}_0\sim\mathcal{N}(\boldsymbol{\bar{y}},\sigma\boldsymbol{n}_R)</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{n}_R=[\frac{1}{\sqrt{n_1}},\frac{1}{\sqrt{n_2}},\dots,\frac{1}{\sqrt{n_C}}]</code>
</p>



<h3>Value</h3>

<p>A <code>stanmodel</code> that can be used in <a href="#topic+infer_data_and_decision_model">infer_data_and_decision_model</a>.
</p>


<h3>Code</h3>

<p>The <code>Stan</code> code for this model is given by:
</p>
<div class="sourceCode r"><pre>empirical_bayes
S4 class stanmodel 'empirical_bayes' coded as follows:
data {
  int&lt;lower=0&gt; N;     // number of data items
  int&lt;lower=0&gt; K;     // number of conditions
  int C;              // number of comparisons to perform
  matrix[N, K] x;     // design matrix
  vector[N] y;        // data
  matrix[K, C] c;     // contrast matrix
  real alpha;         // alpha prior for gamma
  real beta;          // beta prior for gamma
  vector[N] u;        // uncertainty
  vector[K] mu_not;   // prior mu
}
transformed data{
  vector[K] n_k;      // per condition reciprocal measurements
  row_vector[C] n_c;  // per comparison measurements
  matrix[K, C] abs_c; // abs of C for n_c calculation
  for (i in 1:K) {
    for (j in 1:C) {
      abs_c[i, j] = abs(c[i, j]);
    }
  }
  for (i in 1:K) {
    n_k[i] = 1/sum(x[,i]);
  }
  n_c = n_k' * abs_c;
  n_c = sqrt(n_c);
  n_k = sqrt(2*n_k);
}
parameters {
  vector[K] mu;           // mean vector
  real&lt;lower=0&gt; sigma;    // error scale
  array[C] real y_diff;   // difference in coefficients
  vector[K] eta;          // Error in mean
  vector[K] prior_mu_not; // Estimation error
}
transformed parameters{
  row_vector[C] mu_diff = mu' * c;      // differences in means
  vector[K] sigma_mu_not = sigma * n_k; // variance of ybars
  vector[C] sigma_lfc = sigma * n_c';   // variance of y_diff
}
model {
  sigma        ~ gamma(alpha, beta);                        // variance
  eta          ~ normal(0, 1);                              // NCP auxilary variable
  prior_mu_not ~ normal(mu_not, sigma_mu_not);              // Prior mean
  mu           ~ normal(prior_mu_not + sigma * eta, sigma); // mean
  y            ~ normal(x * mu, sigma * u);                 // data model
  y_diff       ~ normal(mu_diff, sigma_lfc);                // difference statistic
} 
</pre></div>

<hr>
<h2 id='estimate_gamma_hyperparameters'>Estimate Gamma hyperparameters for sigma</h2><span id='topic+estimate_gamma_hyperparameters'></span><span id='topic+estimate_gamma_hyperparameters.glm'></span><span id='topic+estimate_gamma_hyperparameters.lgmr'></span><span id='topic+estimate_beta'></span><span id='topic+estimate_beta.glm'></span><span id='topic+estimate_beta.lgmr'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Estimates the hyperparameters for the Bayesian data and decision
model. <code>estimate_gamma_hyperparameters</code> is a wrapper that adds new columns
to the data (one for alpha and one for betas). Note that for <code>lgmr</code>
objects, the <code>estimate_beta</code> function assumes that the data is ordered as
when the model was fitted. If this is not the case, theta's will be
incorrectly matched with peptides&mdash;resulting in wrong estimates of beta
parameters. On the other hand, <code>estimate_gamma_hyperparameters</code> will
temporarily sort the data as when fitted and the sort it back as it
was input to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_gamma_hyperparameters(reg, data, ...)

## S3 method for class 'glm'
estimate_gamma_hyperparameters(reg, data, ...)

## S3 method for class 'lgmr'
estimate_gamma_hyperparameters(reg, data, id_col, ...)

estimate_beta(reg, mean, ...)

## S3 method for class 'glm'
estimate_beta(reg, mean, alpha, ...)

## S3 method for class 'lgmr'
estimate_beta(reg, mean, m, s, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_reg">reg</code></td>
<td>
<p>A <code>glm</code> Gamma regression or a <code>lgmr</code> object</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> to add gamma priors to</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_...">...</code></td>
<td>
<p>Currently not in use</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_id_col">id_col</code></td>
<td>
<p>A character for the name of the column containing the
name of the features in data (e.g., peptides, proteins, etc.)</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_mean">mean</code></td>
<td>
<p>The mean value of the peptide</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter of the peptide</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_m">m</code></td>
<td>
<p>The mean of the means</p>
</td></tr>
<tr><td><code id="estimate_gamma_hyperparameters_+3A_s">s</code></td>
<td>
<p>The sd of the means</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>estimate_gamma_hyperparameters</code> returns a <code>tibble</code> or <code>data.frame</code>
with the alpha,beta hyperparameters estimates as new columns.
</p>
<p><code>estimate_beta</code> returns estimates of the beta parameter(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup model matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

# Normalize data
yeast_norm &lt;- yeast %&gt;%
    psrn("identifier") %&gt;%
    # Get mean-variance trends
    calculate_mean_sd_trends(design)

# Fit gamma regression (could also have been a lgmr model)
gam_reg &lt;- fit_gamma_regression(yeast_norm, sd ~ mean)

# Estimate priors
gam_reg %&gt;%
    estimate_gamma_hyperparameters(yeast_norm)

# Can also explicitly estimate the beta parameters
# Note this is order sensitive.
estimate_beta(gam_reg, yeast_norm$mean, 1/summary(gam_reg)$dispersion)
</code></pre>

<hr>
<h2 id='estimate_uncertainty'>Estimate measurement uncertainty</h2><span id='topic+estimate_uncertainty'></span><span id='topic+estimate_uncertainty.glm'></span><span id='topic+estimate_uncertainty.lgmr'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Estimates the measurement uncertainty for each data point using
a Gamma regression.
Calculated as the expected standard deviation for each measurement:
</p>
<p style="text-align: center;"><code class="reqn">
     \text{E}[s_i|\omega,y_{ij}]=\exp({f(y_{ij},\omega)})
  </code>
</p>

<p>where <code class="reqn">\omega</code> are the regression parameters and <code class="reqn">f</code> is a function
describing the mean relationship between <code class="reqn">s_i</code> and <code class="reqn">y_{ij}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_uncertainty(reg, data, id_col, design_matrix)

## S3 method for class 'glm'
estimate_uncertainty(reg, data, id_col, design_matrix)

## S3 method for class 'lgmr'
estimate_uncertainty(reg, data, id_col, design_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_uncertainty_+3A_reg">reg</code></td>
<td>
<p>A <code>glm</code> gamma regression or <code>lgmr</code> object</p>
</td></tr>
<tr><td><code id="estimate_uncertainty_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="estimate_uncertainty_+3A_id_col">id_col</code></td>
<td>
<p>A character for the name of the column containing the
name of the features in data (e.g., peptides, proteins, etc.)</p>
</td></tr>
<tr><td><code id="estimate_uncertainty_+3A_design_matrix">design_matrix</code></td>
<td>
<p>Cell mean design matrix for the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the uncertainty
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup model matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

yeast_norm &lt;- yeast %&gt;%
  # Remove missing data
  tidyr::drop_na() %&gt;%
  # Normalize data
  psrn("identifier") %&gt;%
  # Add mean-variance trends
  calculate_mean_sd_trends(design)
# Fit the gamma regression
gam &lt;- fit_gamma_regression(yeast_norm, sd ~ mean)
# Estimate each data point's uncertainty
estimate_uncertainty(gam, yeast_norm, 'identifier', design)
</code></pre>

<hr>
<h2 id='fit_gamma_regression'>Function for Fitting the Mean-Variance Gamma Regression Models</h2><span id='topic+fit_gamma_regression'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>fit_gamma_regression</code> returns a <code>glm</code> object containing the
gamma regression for the mean-variance trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_gamma_regression(data, formula = sd ~ mean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_gamma_regression_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> to generate the mean-variance trends for. It
should contain columns with conditions named as the column names in
<code>design</code> (presumably with some suffix).</p>
</td></tr>
<tr><td><code id="fit_gamma_regression_+3A_formula">formula</code></td>
<td>
<p>a formula describing the model</p>
</td></tr>
<tr><td><code id="fit_gamma_regression_+3A_...">...</code></td>
<td>
<p>only for compatibility with other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fit_gamma_regression</code> returns a glm object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a design matrix for the data
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))

# Set correct colnames, this is important for calculate_mean_sd_trends
colnames(design) &lt;- paste0("ng", c(50, 100))

# Normalize and log-transform the data
yeast_norm &lt;- psrn(yeast, "identifier") %&gt;%
  # Add row means and variances
  calculate_mean_sd_trends(design)

# Fit gamma regression model for the mean-variance trends
gamma_model &lt;- fit_gamma_regression(yeast_norm, sd ~ mean)
</code></pre>

<hr>
<h2 id='fit_lgmr'>Fit Latent Gamma Mixture Regression</h2><span id='topic+fit_lgmr'></span><span id='topic+print.lgmr'></span><span id='topic+coef.lgmr'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>See <a href="#topic+lgmr_model">lgmr_model</a> for model details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lgmr(
  data,
  id_col,
  model = lgmr_model,
  iter = 6000,
  warmup = 1500,
  chains = 5,
  cores = 1,
  return_stanfit = FALSE,
  simplify = FALSE,
  ...
)

## S3 method for class 'lgmr'
print(
  x,
  simplify = x$simplify,
  pars = c("auxiliary", "coefficients"),
  digits = 3,
  ...
)

## S3 method for class 'lgmr'
coef(object, simplify = FALSE, pars = c("coefficients", "auxiliary"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_lgmr_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> with mean-variance trends to use in the fitting.
The columns need to have the following hard-coded names: <code>mean</code> and <code>sd</code>.</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_id_col">id_col</code></td>
<td>
<p>A character for the name of the column containing the name of
the features in data (e.g., peptides, proteins, etc.). Has to be a unique
identifier for each feature.</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_model">model</code></td>
<td>
<p>Defaults to <a href="#topic+lgmr_model">lgmr_model</a> (see it for details on the model), can
also be an user supplied <code><a href="rstan.html#topic+stan_model">stan_model()</a></code></p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_iter">iter</code></td>
<td>
<p>Total number of samples to draw</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_warmup">warmup</code></td>
<td>
<p>Number of warm-up samples to draw</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_chains">chains</code></td>
<td>
<p>Number of chains to run</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use per chain</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_return_stanfit">return_stanfit</code></td>
<td>
<p>Should the <code>stanfit</code> object be returned with the model?</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_simplify">simplify</code></td>
<td>
<p>Should only the mean estimates of the posterior be returned?</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>rstan</code>'s <a href="rstan.html#topic+stanmodel-method-sampling">sampling</a>.
Does nothing for <code>print</code> or <code>coef</code> only for <code>fit_lgmr</code>.</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_x">x</code>, <code id="fit_lgmr_+3A_object">object</code></td>
<td>
<p>An <code>lgmr</code> model.</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_pars">pars</code></td>
<td>
<p>If you want to print/extract the regression coefficients, theta, auxiliary (alpha and NRMSE), or all</p>
</td></tr>
<tr><td><code id="fit_lgmr_+3A_digits">digits</code></td>
<td>
<p>Number of digits to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fitted <code>lgmr</code> model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define design matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))


# Normalize data, calculate M-V trend, and fit LGMR model
yeast_lgmr &lt;- yeast %&gt;%
    # Remove missing values
    tidyr::drop_na() %&gt;%
    # Normalize
    psrn("identifier") %&gt;%
    # Add the mean-variance trends
    calculate_mean_sd_trends(design) %&gt;%
    # Fit the model
    fit_lgmr("identifier")
# Print everything except thetas
print(yeast_lgmr, pars = c("coefficients", "auxiliary"))
# Extract the mean of the model parameters posterior
yeast_lgmr_pars &lt;- coef(yeast_lgmr, pars = 'all', simplify = TRUE)


</code></pre>

<hr>
<h2 id='infer_data_and_decision_model'>Sample the Posterior of the data and decision model and generate point
estimates</h2><span id='topic+infer_data_and_decision_model'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Function to sample the posterior of the Bayesian data and
decision model. It first produces the needed inputs for Stan's <code><a href="rstan.html#topic+sampling">sampling()</a></code>
for each peptide (or protein, PTM, etc.). It then runs the sampling for the
data and decision model. From the posterior, it then collects estimates and
sampling statistics from the posterior of data model and integrates the
decision distribution D. It then returns a <code><a href="dplyr.html#topic+tibble">tibble()</a></code> with all the
information for each peptide's posterior (see <strong>Value</strong> below). There are
major time gains to be made by running this procedure in parallel.
<code>infer_data_and_decision_model</code> has an efficient wrapper around
<code>multidplyr</code>. This will let you to evenly distribute all peptides evenly to
each worker. E.g., two workers will each run half of the peptides in
parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_data_and_decision_model(
  data,
  id_col,
  design_matrix,
  contrast_matrix,
  uncertainty_matrix,
  stan_model = empirical_bayes,
  clusters = 1,
  h_not = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_data_and_decision_model_+3A_data">data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with alpha,beta priors annotated</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_id_col">id_col</code></td>
<td>
<p>A character for the name of the column containing the name of
the features in data (e.g., peptides, proteins, etc.)</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_design_matrix">design_matrix</code></td>
<td>
<p>A design matrix for the data. For the <a href="#topic+empirical_bayes">empirical_bayes</a>
prior only mean models are allowed (see example). For the
<a href="#topic+weakly_informative">weakly_informative</a> prior more complicated design can be used.</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_contrast_matrix">contrast_matrix</code></td>
<td>
<p>A contrast matrix of the decisions to test. Columns
should sum to <code>0</code> and only mean comparisons are allowed. That is, the
absolute value of the positive and negative values in each column has to
sum to <code>2</code>. E.g., a column can be <code>[</code>0.5, 0.5, -1<code style="white-space: pre;">&#8288;]&#8288;</code><code class="reqn">^T</code> but not <code>[</code>1,
1, -1<code style="white-space: pre;">&#8288;]&#8288;</code><code class="reqn">^T</code> or <code>[</code>0.5, 0.5, -2<code style="white-space: pre;">&#8288;]&#8288;</code><code class="reqn">^T</code>. That is, <code>sum(abs(x))=2</code>
where <code>x</code> is a column in the contrast matrix.</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_uncertainty_matrix">uncertainty_matrix</code></td>
<td>
<p>A matrix of observation specific uncertainties</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_stan_model">stan_model</code></td>
<td>
<p>Which Bayesian model to use. Defaults to <a href="#topic+empirical_bayes">empirical_bayes</a>
but also allows <a href="#topic+weakly_informative">weakly_informative</a>, or an user supplied function see [].</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_clusters">clusters</code></td>
<td>
<p>The number of parallel threads/workers to run on.</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_h_not">h_not</code></td>
<td>
<p>The value of the null hypothesis for the difference in means</p>
</td></tr>
<tr><td><code id="infer_data_and_decision_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="rstan.html#topic+sampling">rstan::sampling</a></code>. Note that verbose will
always be forced to <code>FALSE</code> to avoid console flooding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data model of Baldur assumes that the observations of a peptide,
<code class="reqn">\boldsymbol{Y}</code>, is a normally distributed with a standard deviation,
<code class="reqn">\sigma</code>, common to all measurements. In addition, it assumes that each
measurement has a unique uncertainty <code class="reqn">u</code>. It then models all
measurements in the same condition with a common mean <code class="reqn">\mu</code>. It then
assumes that the common variation of the peptide is caused by the variation
in the <code class="reqn">\mu</code> As such, it models <code class="reqn">\mu</code> with the common variance
<code class="reqn">\sigma</code> and a non-centered parametrization for condition level
effects.
</p>
<p style="text-align: center;"><code class="reqn">
 \boldsymbol{Y}\sim\mathcal{N}(\boldsymbol{X}\boldsymbol{\mu},\sigma\boldsymbol{u})\quad
 \boldsymbol{\mu}\sim\mathcal{N}(\mu_0+\boldsymbol{\eta}\sigma,\sigma)
</code>
</p>

<p>It then assumes <code class="reqn">\sigma</code> to be gamma distributed with hyperparameters
infered from either a gamma regression <a href="#topic+fit_gamma_regression">fit_gamma_regression</a> or a latent
gamma mixture regression <a href="#topic+fit_lgmr">fit_lgmr</a>. </p>
<p style="text-align: center;"><code class="reqn">\sigma\sim\Gamma(\alpha,\beta)</code>
</p>

<p>For details on the two priors for <code class="reqn">\mu_0</code> see <a href="#topic+empirical_bayes">empirical_bayes</a> or
<a href="#topic+weakly_informative">weakly_informative</a>. Baldur then builds a posterior distribution of the
difference(s) in means for contrasts of interest. In addition, Baldur
increases the precision of the decision as the number of measurements
increase. This is done by weighting the sample size with the contrast
matrix. To this end, Baldur limits the possible contrast of interest such
that each column must sum to zero, and the absolute value of each column
must sum to two. That is, only mean comparisons are allowed.
</p>
<p style="text-align: center;"><code class="reqn">
    \boldsymbol{D}\sim\mathcal{N}(\boldsymbol{\mu}^\text{T}\boldsymbol{K},\sigma\boldsymbol{\xi}),\quad \xi_{i}=\sqrt{\sum_{c=1}^{C}|k_{cm}|n_c^{-1}}
  </code>
</p>

<p>where <code class="reqn">\boldsymbol{K}</code> is a contrast matrix of interest and
<code class="reqn">k_{cm}</code> is the contrast of the c:th condition in the m:th contrast of
interest, and <code class="reqn">n_c</code> is the number of measurements in the c:th
condition. Baldur then integrates the tails of <code class="reqn">\boldsymbol{D}</code> to
determine the probability of error.
</p>
<p style="text-align: center;"><code class="reqn">P(\text{\textbf{error}})=2\Phi(-\left|\boldsymbol{\mu}_{\boldsymbol{D}}-H_0\right|\odot\boldsymbol{\tau}_{\boldsymbol{D}})</code>
</p>

<p>where <code class="reqn">H_0</code> is the null hypothesis for the difference in means,
<code class="reqn">\Phi</code> is the CDF of the standard normal,
<code class="reqn">\boldsymbol{\mu}_{\boldsymbol{D}}</code> is the posterior mean of
<code class="reqn">\boldsymbol{D}</code>, <code class="reqn">\boldsymbol{\tau}_{\boldsymbol{D}}</code> is the
posterior precision of <code class="reqn">\boldsymbol{D}</code>, and <code class="reqn">\odot</code> is the
Hadamard product.
</p>


<h3>Value</h3>

<p>A <code><a href="dplyr.html#topic+tibble">tibble()</a></code> or <code><a href="base.html#topic+data.frame">data.frame()</a></code> annotated  with statistics of the
posterior and p(error). <code>err</code> is the probability of error, i.e., the two
tail-density supporting the null-hypothesis, <code>lfc</code> is the estimated
<code class="reqn">\log_2</code>-fold change, <code>sigma</code> is the common variance, and <code>lp</code> is the
log-posterior. Columns without suffix shows the mean estimate from the
posterior, while the suffixes <code style="white-space: pre;">&#8288;_025&#8288;</code>, <code style="white-space: pre;">&#8288;_50&#8288;</code>, and <code style="white-space: pre;">&#8288;_975&#8288;</code>, are the 2.5, 50.0,
and 97.5, percentiles, respectively. The suffixes <code style="white-space: pre;">&#8288;_eff&#8288;</code> and <code style="white-space: pre;">&#8288;_rhat&#8288;</code> are
the diagnostic variables returned by <code>Stan</code>. In general, a larger <code style="white-space: pre;">&#8288;_eff&#8288;</code>
indicates effective sample size and <code style="white-space: pre;">&#8288;_rhat&#8288;</code> indicates the mixing within
chains and between the chains and should be smaller than 1.05 (please see
the Stan manual for more details). In addition it returns a column
<code>warnings</code> with potential warnings given by the sampler.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (Please see the vignette for a tutorial)
# Setup model matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

yeast_norm &lt;- yeast %&gt;%
# Remove missing data
  tidyr::drop_na() %&gt;%
  # Normalize data
  psrn('identifier') %&gt;%
  # Add mean-variance trends
  calculate_mean_sd_trends(design)

# Fit the gamma regression
gam &lt;- fit_gamma_regression(yeast_norm, sd ~ mean)

# Estimate each data point's uncertainty
unc &lt;- estimate_uncertainty(gam, yeast_norm, 'identifier', design)

yeast_norm &lt;- gam %&gt;%
   # Add hyper-priors for sigma
   estimate_gamma_hyperparameters(yeast_norm)
# Setup contrast matrix
contrast &lt;- matrix(c(-1, 1), 2)

yeast_norm %&gt;%
  head() %&gt;% # Just running a few for the example
  infer_data_and_decision_model(
    'identifier',
    design,
    contrast,
    unc,
    clusters = 1 # I highly recommend increasing the number of parallel workers/clusters
                 # this will greatly reduce the speed of running baldur
  )

</code></pre>

<hr>
<h2 id='lgmr_model'>Latent Gamma Regression Model</h2><span id='topic+lgmr_model'></span>

<h3>Description</h3>

<p>Baldur has the option to use the Latent Gamma Regression Model
(LGMR). This model attempts to estimate local Mean-Variance (M-V) trend for
each peptide (or protein, PTM, etc.). To this end is describes the M-V
trend as a regression with a common link function and a latent one. While
there may not be a latent trend in real data, it allows for a mathematical
description that can estimate the local trends of each peptide. The model
describes the standard deviation (S) as a gamma random variable with mean
dependency described by the sample mean (<code class="reqn">\bar{y}</code>):
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{S}\sim\Gamma(\alpha,\beta),\quad\boldsymbol{\beta}=\frac{\alpha}{\boldsymbol{\mu}}</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\mu}=\exp(\gamma_0-\gamma_{\bar{y}}\,f(\boldsymbol{\bar{y}}))
  + \kappa
  \exp(\boldsymbol{\theta}(\gamma_{0L}-\gamma_{\bar{y}L}\,f(\boldsymbol{\bar{y}})),\quad
  f(\boldsymbol{x})=\frac{\boldsymbol{x}-\mu_{\bar{y}}}{\sigma_{\bar{y}}}</code>
</p>

<p>Here, <code class="reqn">\exp(\gamma_0-\gamma_{\bar{y}}f(\boldsymbol{\bar{y}}))</code> is the common trend of the
regression. Then, the mixing variable, <code class="reqn">\boldsymbol{\theta}</code>, describes
the proportion of the mixture that each peptide has, and <code class="reqn">\kappa</code> is
just some small constant such that when <code class="reqn">\theta</code> is zero the latent
term is small.
</p>


<h3>Details</h3>

<p>Next we will describe the hierarchical prior setup for the
regression variables.
For <code class="reqn">\alpha</code> <code>baldur</code> uses a half-Cauchy as a weakly informative prior:
</p>
<p style="text-align: center;"><code class="reqn">\alpha\sim\text{Half-Cauchy}(25)</code>
</p>

<p>For the latent contribution to the i:th peptide, <code class="reqn">\theta_i</code>, has an uniform distribution:
</p>
<p style="text-align: center;"><code class="reqn">\theta_i\sim\mathcal{U}(0, 1)</code>
</p>
<p> Further, it can be seen that Baldur assumes
that S always decreases (on average) with the sample mean. To this end, both
slopes (<code class="reqn">\gamma_{\bar{y}},\gamma_{\bar{y}L}</code>) are defined on the real
positive line. Hence, we used Half-Normal (HN)
distributions to describe the slope parameters: </p>
<p style="text-align: center;"><code class="reqn">\gamma_{\bar{y}}\sim
HN(1)</code>
</p>
 <p style="text-align: center;"><code class="reqn">\gamma_{\bar{y}L}\sim HN(1)</code>
</p>
<p> For the intercepts, we assume a
standard normal prior for the common intercept. Then, we use a skew-normal to
model the latent intercept. The reason for this is two-fold, one,
<code class="reqn">\kappa</code> will decrease the value of the latent term and, two, to push the
latent trend upwards. The latter reason is so that the latent intercept is
larger than the common and so that the priors prioritize a shift in intercept
over a increase in slope.
For the intercepts, Baldur uses a standard normal prior for the common intercept.
</p>
<p style="text-align: center;"><code class="reqn">\gamma_0\sim\mathcal{N}(0,1)</code>
</p>

<p>While for the latent trend, it uses a skew-normal (SN) to push up the second
trend and to counteract the shrinkage of <code class="reqn">\kappa</code>.
</p>
<p style="text-align: center;"><code class="reqn">\gamma_{0L}\sim\mathcal{SN}(2,15,35)</code>
</p>



<h3>Value</h3>

<p>A <code>stanmodel</code> that can be used in <a href="#topic+fit_lgmr">fit_lgmr</a>.
</p>


<h3>Code</h3>

<p>The <code>Stan</code> code for this model is given by:
</p>
<div class="sourceCode r"><pre>lgmr_model
S4 class stanmodel 'lgmr_model' coded as follows:
functions {
  // mu
  vector reg_function(
    vector x,
    vector theta,
    real I,
    real I_L,
    real S,
    real S_L,
    int N
    ) {
    vector[N] exp_beta  = .001*exp(theta .* (I_L - S_L*x));
              exp_beta +=      exp(I - S*x);
    return exp_beta;
  }
}
data {
  int&lt;lower=0&gt; N;       // Number of observations
  vector&lt;lower=0&gt;[N] y; // sd
  vector[N] x;          // mean
}
transformed data {
  real v_y = variance(y);                      // for NRMSE
  vector[N] x_star = (x - mean(x))/sd(x);      // f(y_bar)
  vector[3] lb = [0, 0, negative_infinity()]'; // Boundaries normal coefs.
}
parameters {
  real&lt;lower = 0&gt; alpha;                 // Shape
  vector&lt;lower = lb&gt;[3] eta;             // For S, S_L, I
  vector&lt;lower = 0, upper = 1&gt;[N] theta; // Mixture parameter
  real I_L;                              // Intercept Latent
}
transformed parameters {
  real&lt;lower = 0&gt; S   = eta[1]; // Slope common
  real&lt;lower = 0&gt; S_L = eta[2]; // Slope Latent
  real I              = eta[3]; // Intercep common
}
model {
  //Priors
  alpha         ~ cauchy(0, 25);
  eta           ~ std_normal();
  I_L           ~ skew_normal(2, 15,  35);
  theta         ~ beta(1, 1);
  {
    vector[N] exp_beta = reg_function(x_star, theta, I, I_L, S, S_L, N);
    // Likelihood
    y ~ gamma(alpha, alpha ./ exp_beta);
  }
}
generated quantities {
  // NRMSE calculations
  real nrmse;
  {
    vector[N] se = reg_function(x_star, theta, I, I_L, S, S_L, N);
    se -= y;
    se  = square(se);
    nrmse = mean(se) / v_y;
  }
  nrmse = sqrt(nrmse);
} 
</pre></div>

<hr>
<h2 id='lgmr_plotting'>Visualization of LGMR models</h2><span id='topic+lgmr_plotting'></span><span id='topic+plot_lgmr_regression'></span><span id='topic+plot_regression_field'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Options to plot the LGMR model. <code>plot_lgmr_regression</code> will plot the data
colored by the amount of latent trend they have as well as the two extreme
regression cases when <code class="reqn">\theta</code> is zero or one. <code>plot_regression_field</code>
will plot the local regression trend for each data point as a vector field and
color the vector based on the derivative at the mean of the peptide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lgmr_regression(model)

plot_regression_field(model, n = 10, rng = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgmr_plotting_+3A_model">model</code></td>
<td>
<p>An LGMR model object</p>
</td></tr>
<tr><td><code id="lgmr_plotting_+3A_n">n</code></td>
<td>
<p>Number of interpolation points for each peptides regression</p>
</td></tr>
<tr><td><code id="lgmr_plotting_+3A_rng">rng</code></td>
<td>
<p>The proportional range of each peptides regression.
E.g., a value of 10 will make each line span 1 % of the x-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Define design matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))


# Normalize data, calculate M-V trend, and fit LGMR model
yeast_lgmr &lt;- yeast %&gt;%
    # Remove missing values
    tidyr::drop_na() %&gt;%
    # Normalize
    psrn("identifier") %&gt;%
    # Add the mean-variance trends
    calculate_mean_sd_trends(design) %&gt;%
    # Fit the model
    fit_lgmr("identifier")
# Print everything except thetas
print(yeast_lgmr, pars = c("coefficients", "auxiliary"))
# Extract the mean of the model parameters posterior
yeast_lgmr_pars &lt;- coef(yeast_lgmr, pars = 'all', simplify = TRUE)
plot_lgmr_regression(yeast_lgmr)
plot_regression_field(yeast_lgmr)

</code></pre>

<hr>
<h2 id='plot_gamma'>Function for plotting the gamma regression for the mean-variance trend</h2><span id='topic+plot_gamma'></span>

<h3>Description</h3>

<p>Generates a scatter plot with the gamma regressions of the mean-variance
trends without partitioning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gamma(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gamma_+3A_data">data</code></td>
<td>
<p>The data to use for producing the plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot with the estimated mean-variance trend
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Produce a design matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

# Normalize and log transform the data
yeast_norm &lt;- psrn(yeast, "identifier")

# Generate the plot
yeast_norm %&gt;%
  calculate_mean_sd_trends(design) %&gt;%
  plot_gamma()
</code></pre>

<hr>
<h2 id='plot_gamma_regression'>Function for plotting the mean-variance gamma regressions</h2><span id='topic+plot_gamma_regression'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Generates a scatter plot with the gamma regressions of the mean-variance
trend. Can either be ran directly with <code>plot_gamma_regression</code> and inputing
a design matrix, or with <code>plot_gamma</code> if the M-V trend has been added to the
data with <code><a href="#topic+calculate_mean_sd_trends">calculate_mean_sd_trends()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gamma_regression(data, design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gamma_regression_+3A_data">data</code></td>
<td>
<p>The data to use for producing the plots.</p>
</td></tr>
<tr><td><code id="plot_gamma_regression_+3A_design">design</code></td>
<td>
<p>A design matrix as produced by
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot with the mean-variance trend before partitioning on the left
side, and the right side after.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Produce a design matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

# Normalize and log transform the data
yeast %&gt;%
    # Remove missing data
    # Note that this could be replaced with imputation
    tidyr::drop_na() %&gt;%
    # Normalize
    psrn("identifier") %&gt;%
    plot_gamma_regression(design)
</code></pre>

<hr>
<h2 id='plot_sa'>Plot the trend between the log fold-change and sigma, coloring significant hits</h2><span id='topic+plot_sa'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>plot_sa</code> returns a <code>ggplot</code> with a graphical representation between the log
fold-change and sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sa(results, alpha = 0.05, lfc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sa_+3A_results">results</code></td>
<td>
<p>Output generated by
<code>baldur::<a href="#topic+infer_data_and_decision_model">infer_data_and_decision_model</a></code></p>
</td></tr>
<tr><td><code id="plot_sa_+3A_alpha">alpha</code></td>
<td>
<p>Significance cut-off; used to draw a line indicating where
significance starts</p>
</td></tr>
<tr><td><code id="plot_sa_+3A_lfc">lfc</code></td>
<td>
<p>LFC cut-off; used to draw lines for <code>abs(lfc)</code>, if <code>NULL</code> no lines
are drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_sa</code> returns a <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup model matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

yeast_norm &lt;- yeast %&gt;%
# Remove missing data
  tidyr::drop_na() %&gt;%
  # Normalize data
  psrn('identifier') %&gt;%
  # Add mean-variance trends
  calculate_mean_sd_trends(design)
# Fit the gamma regression
gam &lt;- fit_gamma_regression(yeast_norm, sd ~ mean)
# Estimate each data point's uncertainty
unc &lt;- estimate_uncertainty(gam, yeast_norm, "identifier", design)
yeast_norm &lt;- gam %&gt;%
   # Add hyper-priors for sigma
   estimate_gamma_hyperparameters(yeast_norm)
# Setup contrast matrix
contrast &lt;- matrix(c(-1, 1), 2)

results &lt;- yeast_norm %&gt;%
  head() %&gt;% # Just run a few for the example
  infer_data_and_decision_model(
    'identifier',
    design,
    contrast,
    unc,
    clusters = 1 # I highly recommend increasing the number of parallel workers/clusters
                 # this will greatly reduce the speed of running baldur
  )
  # Plot with alpha = 0.05
  plot_sa(results, alpha = 0.05)
  # Plot with alpha = 0.01 and show LFC = 1
  plot_sa(results, alpha = 0.01, 1)

</code></pre>

<hr>
<h2 id='plot_volcano'>Plot the -log10(err) against the log fold-change</h2><span id='topic+plot_volcano'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>plot_volcano</code> returns a <code>ggplot</code> with a graphical representation between the
-log10(err) and LFC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_volcano(results, alpha = 0.05, lfc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_volcano_+3A_results">results</code></td>
<td>
<p>Output generated by
<code>baldur::<a href="#topic+infer_data_and_decision_model">infer_data_and_decision_model</a></code></p>
</td></tr>
<tr><td><code id="plot_volcano_+3A_alpha">alpha</code></td>
<td>
<p>Significance cut-off; used to draw a line indicating where
significance starts</p>
</td></tr>
<tr><td><code id="plot_volcano_+3A_lfc">lfc</code></td>
<td>
<p>LFC cut-off; used to draw lines for <code>abs(lfc)</code>, if <code>NULL</code> no lines
are drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_volcano</code> returns a <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup model matrix
design &lt;- model.matrix(~ 0 + factor(rep(1:2, each = 3)))
colnames(design) &lt;- paste0("ng", c(50, 100))

yeast_norm &lt;- yeast %&gt;%
# Remove missing data
  tidyr::drop_na() %&gt;%
  # Normalize data
  psrn('identifier') %&gt;%
  # Add mean-variance trends
  calculate_mean_sd_trends(design)
# Fit the gamma regression
gam &lt;- fit_gamma_regression(yeast_norm, sd ~ mean)
# Estimate each data point's uncertainty
unc &lt;- estimate_uncertainty(gam, yeast_norm, 'identifier', design)
yeast_norm &lt;- gam %&gt;%
   # Add hyper-priors for sigma
   estimate_gamma_hyperparameters(yeast_norm)
# Setup contrast matrix
contrast &lt;- matrix(c(-1, 1), 2)

results &lt;- yeast_norm %&gt;%
  head() %&gt;% # Just run a few for the example
  infer_data_and_decision_model(
    'identifier',
    design,
    contrast,
    unc,
    clusters = 1 # I highly recommend increasing the number of parallel workers/clusters
                 # this will greatly reduce the speed of running baldur
  )
  # Plot indicating where alpha = 0.05
  plot_volcano(results, alpha = 0.05)
  # Plot indicating where alpha = 0.01 and where LFC = 1
  plot_volcano(results, alpha = 0.01, 1)

</code></pre>

<hr>
<h2 id='psrn'>Normalize data to a pseudo-reference</h2><span id='topic+psrn'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function generates a pseudo-reference by taking the geometric mean of
each peptide across all samples. Each peptide in each sample is then divided
by the pseudo-reference. Then, the median ratio of all ratios is used as an
estimate to use for normalizing differences in loading concentration. All
features in each sample is then divided by their corresponding estimate.
All estimates are based on features without missing values.
For details see Anders and Huber (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psrn(data, id_col, log = TRUE, load_info = FALSE, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psrn_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="psrn_+3A_id_col">id_col</code></td>
<td>
<p>a character for the name of the column containing the
name of the features in data (e.g., peptides, proteins, etc.)</p>
</td></tr>
<tr><td><code id="psrn_+3A_log">log</code></td>
<td>
<p>boolean variable indicating if the data should be log transformed
after normalization</p>
</td></tr>
<tr><td><code id="psrn_+3A_load_info">load_info</code></td>
<td>
<p>logical; should the load information be output?</p>
</td></tr>
<tr><td><code id="psrn_+3A_target">target</code></td>
<td>
<p>target columns to normalize, supports
<code><a href="tidyselect.html#topic+tidyselect-package">tidyselect-package</a></code> syntax. By default, all numerical
columns will be used in the normalization if not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with normalized values if <code>load_info=FALSE</code>, if it is <code>TRUE</code>
then it returns a list with two tibbles. One tibble containing the
normalized data and one containing the loading info as well as the
estimated normalization factors.
</p>


<h3>Source</h3>

<p><a href="https://www.nature.com/articles/npre.2010.4282.1">https://www.nature.com/articles/npre.2010.4282.1</a>
</p>


<h3>References</h3>

<p>Simon Anders, Wolfgang Huber (2010).
&ldquo;Differential expression analysis for sequence count data.&rdquo;
<em>Nature Precedings</em>, 1&ndash;1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yeast_psrn &lt;- psrn(yeast, "identifier")
yeast_psrn_with_load &lt;- psrn(yeast, "identifier", load_info = TRUE)
yeast_ng50_only &lt;- psrn(yeast, "identifier", target = matches('ng50'))
</code></pre>

<hr>
<h2 id='ups'>Spiked-in data set of peptides</h2><span id='topic+ups'></span>

<h3>Description</h3>

<p>A dataset containing quantification of peptides using Progenesis. True
positives peptides spiked-in from the Universal Proteomics Standard Set 1
(UPS1) at three different concentrations and true negatives from
<em>Chlamydomonas reinhardtii</em> with the same concentration in all samples.
You can find true positives with <code>stringr::str_detect(ups$identifier, 'UPS')</code>. For details see Berg et al. (2019) and
if you use this dataset please cite the same paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ups
</code></pre>


<h3>Format</h3>

<p>A data frame with 10599 rows and 13 variables:
</p>

<dl>
<dt>identifier</dt><dd><p>id column for features, true positives contains UPS and
true negatives contains Cre</p>
</dd>
<dt>fmol25_1,fmol25_2,fmol25_3,fmol25_4</dt><dd><p>Technical replicates
with true positives spiked-in from 25 fmol UPS1 peptides</p>
</dd>
<dt>fmol50_1,fmol50_2,fmol50_3,fmol50_4</dt><dd><p>Technical replicate with true positives
spiked-in from 50 fmol UPS1 peptides</p>
</dd>
<dt>fmol100_1,fmol100_2,fmol100_3,fmol100_4</dt><dd><p>Technical replicate with true positives
spiked-in from 100 fmol
UPS1 peptides</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-2619-6">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-2619-6</a>
</p>


<h3>References</h3>

<p>Philip Berg, Evan
W McConnell, Leslie
M Hicks, Sorina
C Popescu, George
V Popescu (2019).
&ldquo;Evaluation of linear models and missing value imputation for the analysis of peptide-centric proteomics.&rdquo;
<em>BMC bioinformatics</em>, <b>20</b>(2), 7&ndash;16.
</p>

<hr>
<h2 id='weakly_informative'>Baldur's weakly informative prior for the mean in conditions</h2><span id='topic+weakly_informative'></span>

<h3>Description</h3>

<p>Here we will model the mean of the prior with a weakly
informative (WI) prior. We will assume that, in essence, nothing is know
about the mean. As such, for the WI prior, we use a normal prior on
<code class="reqn">\boldsymbol{\mu}_0</code> centered at zero and with a very large variance.
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{\mu}_0\sim\mathcal{N}(0,100)</code>
</p>



<h3>Value</h3>

<p>A <code>stanmodel</code> that can be used in <a href="#topic+infer_data_and_decision_model">infer_data_and_decision_model</a>.
</p>


<h3>Code</h3>

<p>The <code>Stan</code> code for this model is given by:
</p>
<div class="sourceCode r"><pre>weakly_informative
S4 class stanmodel 'weakly_informative' coded as follows:
data {
  int&lt;lower=0&gt; N;     // number of data items
  int&lt;lower=0&gt; K;     // number of conditions
  int C;              // number of comparisons to perform
  matrix[N, K] x;     // design matrix
  vector[N] y;        // data
  matrix[K, C] c;     // contrast matrix
  real alpha;         // alpha prior for gamma
  real beta;          // beta prior for gamma
  vector[N] u;        // uncertainty
}
transformed data{
  vector[K] n_k;      // per condition measurements
  row_vector[C] n_c;  // per comparison measurements
  matrix[K, C] abs_c; // abs of C for n_c calculation
  for (i in 1:K) {
    for (j in 1:C) {
      abs_c[i, j] = abs(c[i, j]);
    }
  }
  for (i in 1:K) {
    n_k[i] = 1/sum(x[,i]);
  }
  n_c = n_k' * abs_c;
  n_c = sqrt(n_c);
}
parameters {
  vector[K] mu;           // coefficients for predictors
  real&lt;lower=0&gt; sigma;    // error scale
  array[C] real y_diff;   // difference in coefficients
  vector[K] eta;          // Error in mean
  vector[K] prior_mu_not; // Estimation error
}
transformed parameters{
  row_vector[C] mu_diff = mu' * c;        // differences in means
  vector[C] sigma_lfc = sigma * n_c';     // variance of y_diff
}
model {
  sigma        ~ gamma(alpha, beta);                      // variance
  eta          ~ normal(0, 1);                            // NCP auxilary variable
  prior_mu_not ~ normal(0, 10);                           // prior mean
  mu           ~ normal(prior_mu_not + sigma*eta, sigma); // mean
  y            ~ normal(x * mu, sigma*u);                 // data model
  y_diff       ~ normal(mu_diff, sigma_lfc);              // difference statistic
} 
</pre></div>

<hr>
<h2 id='yeast'>Spiked-in data set of reversibly oxidized cysteines</h2><span id='topic+yeast'></span>

<h3>Description</h3>

<p>A dataset containing quantification of reversibly oxidized cysteines using
Progenesis. True positives cysteines spiked-in from yeast at two different
concentrations and true negatives from <em>Chlamydomonas reinhardtii</em> with
the same concentration in all samples. To identify true positives one can use
<code>stringr::str_detect(yeast$identifier, 'YEAST')</code>. For details see
Berg et al. (2019) and if you use this dataset
please cite the same paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yeast
</code></pre>


<h3>Format</h3>

<p>A data frame with 2235 rows and 7 variables: </p>

<dl>
<dt>identifier</dt><dd><p>id column for features, true positives contains YEAST and
true negatives contains Cre</p>
</dd>
<dt>ng50_1,ng50_2,ng50_3</dt><dd><p>Biological replicates with
true positives spiked-in from 50 ng yeast cells</p>
</dd>
<dt>ng100_1,ng100_2,ng100_3</dt><dd><p>Biological replicates with
true positives spiked-in from 100 ng yeast cells</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-2619-6">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-2619-6</a>
</p>


<h3>References</h3>

<p>Philip Berg, Evan
W McConnell, Leslie
M Hicks, Sorina
C Popescu, George
V Popescu (2019).
&ldquo;Evaluation of linear models and missing value imputation for the analysis of peptide-centric proteomics.&rdquo;
<em>BMC bioinformatics</em>, <b>20</b>(2), 7&ndash;16.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
