<!DOCTYPE html><html><head><title>Help for package bioregion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bioregion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compare_partitions'><p>Compare cluster memberships among multiple partitions</p></a></li>
<li><a href='#cut_tree'><p>Cut a hierarchical tree</p></a></li>
<li><a href='#dissimilarity'><p>Compute dissimilarity metrics (beta-diversity) between sites based on</p>
species composition</a></li>
<li><a href='#dissimilarity_to_similarity'><p>Convert dissimilarity metrics to similarity metrics</p></a></li>
<li><a href='#find_optimal_n'><p>Search for an optimal number of clusters in a list of partitions</p></a></li>
<li><a href='#fishdf'><p>Spatial distribution of fish in Europe (data.frame)</p></a></li>
<li><a href='#fishmat'><p>Spatial distribution of fish in Europe (co-occurrence matrix)</p></a></li>
<li><a href='#fishsf'><p>Spatial distribution of fish in Europe</p></a></li>
<li><a href='#hclu_diana'><p>Divisive hierarchical clustering based on dissimilarity or beta-diversity</p></a></li>
<li><a href='#hclu_hierarclust'><p>Hierarchical clustering based on dissimilarity or beta-diversity</p></a></li>
<li><a href='#hclu_optics'><p>OPTICS hierarchical clustering algorithm</p></a></li>
<li><a href='#install_binaries'><p>Download, unzip, check permission and test the bioregion's binary files</p></a></li>
<li><a href='#map_clusters'><p>Create a map of bioregions</p></a></li>
<li><a href='#mat_to_net'><p>Create a data.frame from a contingency table</p></a></li>
<li><a href='#net_to_mat'><p>Create a contingency table from a data.frame</p></a></li>
<li><a href='#netclu_beckett'><p>Community structure detection in weighted bipartite network via modularity</p>
optimization</a></li>
<li><a href='#netclu_greedy'><p>Community structure detection via greedy optimization of modularity</p></a></li>
<li><a href='#netclu_infomap'><p>Infomap community finding</p></a></li>
<li><a href='#netclu_labelprop'><p>Finding communities based on propagating labels</p></a></li>
<li><a href='#netclu_leadingeigen'><p>Finding communities based on leading eigen vector of the community matrix</p></a></li>
<li><a href='#netclu_leiden'><p>Finding communities using the Leiden algorithm</p></a></li>
<li><a href='#netclu_louvain'><p>Louvain community finding</p></a></li>
<li><a href='#netclu_oslom'><p>OSLOM community finding</p></a></li>
<li><a href='#netclu_walktrap'><p>Community structure detection via short random walks</p></a></li>
<li><a href='#nhclu_clara'><p>Non hierarchical clustering: CLARA</p></a></li>
<li><a href='#nhclu_clarans'><p>Non hierarchical clustering: CLARANS</p></a></li>
<li><a href='#nhclu_dbscan'><p>dbscan clustering</p></a></li>
<li><a href='#nhclu_kmeans'><p>Non hierarchical clustering: k-means analysis</p></a></li>
<li><a href='#nhclu_pam'><p>Non hierarchical clustering: partitioning around medoids</p></a></li>
<li><a href='#partition_metrics'><p>Calculate metrics for one or several partitions</p></a></li>
<li><a href='#similarity'><p>Compute similarity metrics between sites based on species composition</p></a></li>
<li><a href='#similarity_to_dissimilarity'><p>Convert similarity metrics to dissimilarity metrics</p></a></li>
<li><a href='#subset_node'><p>Extract a subset of node from a bioregion.clusters object</p></a></li>
<li><a href='#vegedf'><p>Spatial distribution of Mediterranean vegetation (data.frame)</p></a></li>
<li><a href='#vegemat'><p>Spatial distribution of Mediterranean vegetation (co-occurrence matrix)</p></a></li>
<li><a href='#vegesf'><p>Spatial distribution of Mediterranean vegetation (spatial grid)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Comparison of Bioregionalisation Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The main purpose of this package is to propose a transparent methodological framework to compare bioregionalisation methods based on hierarchical and non-hierarchical clustering algorithms (Kreft &amp; Jetz (2010) &lt;<a href="https://doi.org/10.1111%2Fj.1365-2699.2010.02375.x">doi:10.1111/j.1365-2699.2010.02375.x</a>&gt;) and network algorithms (Lenormand et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fece3.4718">doi:10.1002/ece3.4718</a>&gt; and Leroy et al. (2019) &lt;<a href="https://doi.org/10.1111%2Fjbi.13674">doi:10.1111/jbi.13674</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, bipartite, cluster, data.table, dbscan, dynamicTreeCut,
fastcluster, fastkmedoids, ggplot2, grDevices, igraph,
mathjaxr, Matrix, Rdpack, rlang, rmarkdown, segmented, sf,
stats, tidyr, utils</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr, Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ade4, dplyr, knitr, microbenchmark, rnaturalearth,
rnaturalearthdata, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bioRgeo/bioregion">https://github.com/bioRgeo/bioregion</a>,
<a href="https://bioRgeo.github.io/bioregion/">https://bioRgeo.github.io/bioregion/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bioRgeo/bioregion/issues">https://github.com/bioRgeo/bioregion/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-19 16:11:14 UTC; maxime</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Lenormand <a href="https://orcid.org/0000-0001-6362-3473"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Boris Leroy <a href="https://orcid.org/0000-0002-7686-4302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Pierre Denelle <a href="https://orcid.org/0000-0001-5037-2281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxime Lenormand &lt;maxime.lenormand@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-19 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compare_partitions'>Compare cluster memberships among multiple partitions</h2><span id='topic+compare_partitions'></span>

<h3>Description</h3>

<p>This function aims at computing pairwise comparisons for several
partitions, usually on outputs from <code>netclu_</code>, <code>hclu_</code> or <code>nhclu_</code> functions.
It also provides the confusion matrix from pairwise comparisons, so that
the user can compute additional comparison metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_partitions(
  cluster_object,
  sample_comparisons = NULL,
  indices = c("rand", "jaccard"),
  cor_frequency = FALSE,
  store_pairwise_membership = TRUE,
  store_confusion_matrix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_partitions_+3A_cluster_object">cluster_object</code></td>
<td>
<p>a <code>bioregion.clusters</code> object or a <code>data.frame</code> or a
list of <code>data.frame</code> containing multiple partitions. At least two partitions
are required. If a list of <code>data.frame</code> is provided, they should all have
the same number of rows (i.e., same items in the clustering for all
partitions).</p>
</td></tr>
<tr><td><code id="compare_partitions_+3A_sample_comparisons">sample_comparisons</code></td>
<td>
<p><code>NULL</code> or a positive integer. Reduce computation
time by sampling a number of pairwise comparisons in cluster membership
of items. Useful if the number of items clustered is high. Suggested
values 5000 or 10000.</p>
</td></tr>
<tr><td><code id="compare_partitions_+3A_indices">indices</code></td>
<td>
<p><code>NULL</code> or <code>character</code>. Indices to compute for the pairwise
comparison of partitions. Current available metrics are <code>"rand"</code> and
<code>"jaccard"</code></p>
</td></tr>
<tr><td><code id="compare_partitions_+3A_cor_frequency">cor_frequency</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, then computes the correlation
between each partition and the total frequency of co-membership of items
across all partitions. Useful to identify which partition(s) is(are) most
representative of all the computed partitions.</p>
</td></tr>
<tr><td><code id="compare_partitions_+3A_store_pairwise_membership">store_pairwise_membership</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, the pairwise
membership of items is stored in the output object.</p>
</td></tr>
<tr><td><code id="compare_partitions_+3A_store_confusion_matrix">store_confusion_matrix</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, the confusion matrices
of pairwise partition comparisons are stored in the output object.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function proceeds in two main steps:
</p>

<ol>
<li><p> The first step is done within each partition. It will compare all pairs of
items and document if they are clustered together (<code>TRUE</code>) or separately
(<code>FALSE</code>) in each partition. For example, if site 1 and site 2 are clustered
in the same cluster in partition 1, then the pairwise membership site1_site2
will be <code>TRUE</code>. The output of this first step is stored in the slot
<code>pairwise_membership</code> if <code>store_pairwise_membership = TRUE</code>.
</p>
</li>
<li><p> The second step compares all pairs of partitions by analysing if their
pairwise memberships are similar or not. To do so, for each pair of
partitions, the function computes a confusion matrix with four elements:
</p>
</li></ol>


<ul>
<li> <p><em>a</em>: number of pairs of items grouped in partition 1 and in partition 2
</p>
</li>
<li> <p><em>b</em>: number of pairs of items grouped in partition 1 but not in partition
2
</p>
</li>
<li> <p><em>c</em>: number of pairs of items not grouped in partition 1 but grouped in
partition 2
</p>
</li>
<li> <p><em>d</em>: number of pairs of items not grouped in both partition 1 &amp; 2
</p>
</li></ul>

<p>The confusion matrix is stored in <code>confusion_matrix</code> if
<code>store_confusion_matrix = TRUE</code>.
</p>
<p>Based on the confusion matrices, we can compute a range of indices to
indicate the agreement among partitions. As of now, we have implemented:
</p>

<ul>
<li> <p><em>Rand index</em>
\((a + d)/(a + b + c + d)\)
The Rand index measures agreement among partitions by accounting for both
the pairs of sites that are grouped, but also the pairs of sites that are
not grouped.
</p>
</li>
<li> <p><em>Jaccard index</em>
\((a)/(a + b + c)\)
The Jaccard index measures agreement among partitions by only accounting
for pairs of sites that are grouped - it is
</p>
</li></ul>

<p>These two metrics are complementary, because the Jaccard index will tell
if partitions are similar in their clustering structure, whereas the
Rand index will tell if partitions are similar not only in the pairs of
items clustered together, but also in terms of the pairs of sites that are
not clustered together. For example, take two partitions which
never group together the same pairs of sites. Their Jaccard index will be 0,
whereas the Rand index can be &gt; 0 due to the sites that are not grouped
together.
</p>
<p>Additional indices can be manually computed by the users on the basis of the
list of confusion matrices.
</p>
<p>In some cases, users may be interested in finding which of the partitions
is most representative of all partitions. To find it out, we can
compare the pairwise membership of each partition with the total frequency
of pairwise membership across all partitions. This correlation can be
requested with <code>cor_frequency = TRUE</code>
</p>


<h3>Value</h3>

<p>A <code>list</code> with 4 to 7 elements:
</p>

<ul>
<li> <p><code>args</code>: arguments provided by the user
</p>
</li>
<li> <p><code>inputs</code>: information on the input partitions, such as the number of items
being clustered
</p>
</li>
<li><p> (facultative) <code>pairwise_membership</code>: only if
<code>store_pairwise_membership = TRUE</code>. This
element contains the pairwise memberships of all items for each
partition, in the form of a <code style="white-space: pre;">&#8288;boolean matrix&#8288;</code> where <code>TRUE</code> means that
two items are in the same cluster, and <code>FALSE</code> means that two items
are not in the same cluster
</p>
</li>
<li> <p><code>freq_item_pw_membership</code>: A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code>
containing the number of times each pair of items are clustered
together. It corresponds to the sum of rows of the table in
<code>pairwise_membership</code>
</p>
</li>
<li><p> (facultative) <code>partition_freq_cor</code>:  only if <code>cor_frequency = TRUE</code>.
A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code>
indicating the correlation between individual partitions and the total
frequency of pairwise membership across all partitions. It corresponds to
the correlation between individual columns in <code>pairwise_membership</code> and
<code>freq_item_pw_membership</code>
</p>
</li>
<li><p> (facultative) <code>confusion_matrix</code>: only if <code>store_confusion_matrix = TRUE</code>.
A <code>list</code>
containing all confusion matrices between each pair of partitions.
</p>
</li>
<li> <p><code>partition_comparison</code>: a <code>data.frame</code> containing the results of the
comparison of partitions, where the first column indicates which partitions
are compared, and the next columns correspond to the requested <code>indices</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><a href="#topic+partition_metrics">partition_metrics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple case with four partitions of four items
partitions &lt;- data.frame(matrix(nr = 4, nc = 4, 
                                c(1,2,1,1,1,2,2,1,2,1,3,1,2,1,4,2),
                                byrow = TRUE))
partitions
compare_partitions(partitions)

# Find out which partitions are most representative
compare_partitions(partitions,
                   cor_frequency = TRUE)
                                

</code></pre>

<hr>
<h2 id='cut_tree'>Cut a hierarchical tree</h2><span id='topic+cut_tree'></span>

<h3>Description</h3>

<p>This functions is designed to work on a hierarchical tree and cut it
at user-selected heights. It works on either outputs from
<code>hclu_hierarclust</code> or <code>hclust</code> objects. It cuts the tree for the chosen
number(s) of clusters or selected height(s). It also includes a procedure to
automatically return the height of cut for the chosen number(s) of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_tree(
  tree,
  n_clust = NULL,
  cut_height = NULL,
  find_h = TRUE,
  h_max = 1,
  h_min = 0,
  dynamic_tree_cut = FALSE,
  dynamic_method = "tree",
  dynamic_minClusterSize = 5,
  dissimilarity = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_tree_+3A_tree">tree</code></td>
<td>
<p>a <code>bioregion.hierar.tree</code> or a <code>hclust</code> object</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_n_clust">n_clust</code></td>
<td>
<p>an integer or a vector of integers indicating the number of
clusters to be obtained from the hierarchical tree, or the output from
<code><a href="#topic+partition_metrics">partition_metrics()</a></code>. Should not be used at the same time as <code>cut_height</code></p>
</td></tr>
<tr><td><code id="cut_tree_+3A_cut_height">cut_height</code></td>
<td>
<p>a numeric vector indicating the height(s) at which the
tree should be cut. Should not be used at the same time as <code>n_clust</code> or
<code>optim_method</code></p>
</td></tr>
<tr><td><code id="cut_tree_+3A_find_h">find_h</code></td>
<td>
<p>a boolean indicating if the height of cut should be found for
the requested <code>n_clust</code></p>
</td></tr>
<tr><td><code id="cut_tree_+3A_h_max">h_max</code></td>
<td>
<p>a numeric indicating the maximum possible tree height for
finding the height of cut when <code>find_h = TRUE</code></p>
</td></tr>
<tr><td><code id="cut_tree_+3A_h_min">h_min</code></td>
<td>
<p>a numeric indicating the minimum possible height in the tree
for finding the height of cut when <code>find_h = TRUE</code></p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dynamic_tree_cut">dynamic_tree_cut</code></td>
<td>
<p>a boolean indicating if the dynamic tree cut method
should be used, in which case <code>n_clust</code> &amp; <code>cut_height</code> are ignored</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dynamic_method">dynamic_method</code></td>
<td>
<p>a character vector indicating the method to be used
to dynamically cut the tree: either <code>"tree"</code> (clusters searched only
in the tree) or <code>"hybrid"</code> (clusters searched on both tree and dissimilarity
matrix)</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dynamic_minclustersize">dynamic_minClusterSize</code></td>
<td>
<p>an integer indicating the minimum cluster size
to use in the dynamic tree cut method (see
<a href="dynamicTreeCut.html#topic+cutreeDynamic">dynamicTreeCut::cutreeDynamic()</a>)</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>only useful if <code>dynamic_method = "hybrid"</code>.
Provide here the dissimilarity <code>data.frame</code> used to build the <code>tree</code></p>
</td></tr>
<tr><td><code id="cut_tree_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to
<a href="dynamicTreeCut.html#topic+cutreeDynamic">dynamicTreeCut::cutreeDynamic()</a> to
customize the dynamic tree cut method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can cut the tree with two main methods. First, it can cut
the entire tree at the same height (either specified by <code>cut_height</code> or
automatically defined for the chosen <code>n_clust</code>). Second, it can use
the dynamic tree cut method (Langfelder et al. 2008), in which
case clusters are detected with an adaptive method based on the shape of
branches in the tree (thus cuts happen at multiple heights depending on
cluster positions in the tree).
</p>
<p>The dynamic tree cut method has two variants.
</p>

<ul>
<li><p>The tree-based only variant
(<code>dynamic_method = "tree"</code>) is a top-down approach which relies only
on the tree and follows the order of clustered objects on it
</p>
</li>
<li><p>The hybrid variant
(<code>dynamic_method = "hybrid"</code>) is a bottom-up approach which relies on
both the tree and the dissimilarity matrix to build clusters on the basis of
dissimilarity information among sites. This method is useful to detect
outlying members in each cluster.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>tree</code> is an output from <code><a href="#topic+hclu_hierarclust">hclu_hierarclust()</a></code>, then the same
object is returned with content updated (i.e., <code>args</code> and <code>clusters</code>). If
<code>tree</code> is a <code>hclust</code> object, then a <code>data.frame</code> containing the clusters is
returned.
</p>


<h3>Note</h3>

<p>The argument <code>find_h</code> is ignored if <code>dynamic_tree_cut = TRUE</code>,
because heights of cut cannot be estimated in this case.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>),
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Langfelder P, Zhang B, Horvath S (2008).
&ldquo;Defining clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for R.&rdquo;
<em>BIOINFORMATICS</em>, <b>24</b>(5), 719&ndash;720.
</p>


<h3>See Also</h3>

<p><a href="#topic+hclu_hierarclust">hclu_hierarclust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site", 1:20)
colnames(comat) &lt;- paste0("Species", 1:25)

simil &lt;- similarity(comat, metric = "all")
dissimilarity &lt;- similarity_to_dissimilarity(simil)

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissimilarity, n_clust = 5)
tree2 &lt;- cut_tree(tree1, cut_height = .05)
tree3 &lt;- cut_tree(tree1, n_clust = c(3, 5, 10))
tree4 &lt;- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25))
tree5 &lt;- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE)

hclust_tree &lt;- tree2$algorithm$final.tree
clusters_2 &lt;- cut_tree(hclust_tree, n_clust = 10)

cluster_dynamic &lt;- cut_tree(tree1, dynamic_tree_cut = TRUE,
                            dissimilarity = dissimilarity)

</code></pre>

<hr>
<h2 id='dissimilarity'>Compute dissimilarity metrics (beta-diversity) between sites based on
species composition</h2><span id='topic+dissimilarity'></span>

<h3>Description</h3>

<p>This function creates a <code>data.frame</code> where each row provides one or
several dissimilarity metric(s) between each pair of sites from a
co-occurrence <code>matrix</code> with sites as rows and species as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity(comat, metric = "Simpson", formula = NULL, method = "prodmat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_+3A_comat">comat</code></td>
<td>
<p>a co-occurrence <code>matrix</code> with sites as rows and species
as columns.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_metric">metric</code></td>
<td>
<p>a vector of string(s) indicating which metrics to chose
(see Details). Available options are <em>abc</em>, <em>ABC</em>, <em>Jaccard</em>,
<em>Jaccardturn</em>, <em>Sorensen</em>, <em>Simpson</em>,  <em>Bray</em>,
<em>Brayturn</em> or <em>Euclidean</em>.<br />
If <code>"all"</code> is specified, then all metrics will be
calculated. Can be set to <code>NULL</code> if <code>formula</code> is used.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_formula">formula</code></td>
<td>
<p>a vector of string(s) with your own formula based on the
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code> quantities
(see Details). <code>formula</code> is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_method">method</code></td>
<td>
<p>a string indicating what method should be used to compute
<code>abc</code> (see Details).
<code>method = "prodmat"</code> by default is more efficient but can be greedy
in memory and <code>method="loops"</code> is less efficient but less greedy in
memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>With <code>a</code> the number of species shared by a pair of sites, <code>b</code> species only
present in the first site  and <code>c</code> species only present in the second site.
</p>
<p>\(Jaccard = (b + c) / (a + b + c)\)
</p>
<p>\(Jaccardturn = 2min(b, c) / (a + 2min(b, c))\)(Baselga 2012)
</p>
<p>\(Sorensen = (b + c) / (2a + b + c)\)
</p>
<p>\(Simpson = min(b, c) / (a + min(b, c))\)
</p>
<p>If abundances data are available, Bray-Curtis and its turnover component
can also be computed with the following equation:
</p>
<p>\(Bray = (B + C) / (2A + B + C)\)
</p>
<p>\(Brayturn = min(B, C)/(A + min(B, C))\) (Baselga 2013)
</p>
<p>with A the sum of the lesser values for common species shared by a pair of
sites. B and C are the total number of specimens counted at both sites minus
A.
</p>
<p><code>formula</code> can be used to compute customized metrics with the terms
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code>.
For example
<code>formula = c("(b + c) / (a + b + c)", "(B + C) / (2*A + B + C)")</code> will
compute the Jaccard and Bray-Curtis dissimilarity metrics, respectively.
</p>
<p>Euclidean computes the Euclidean distance between each pair of sites.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with additional class <code>bioregion.pairwise.metric</code>,
providing one or several dissimilarity
metric(s) between each pair of sites. The two first columns represent each
pair of sites.
One column per dissimilarity metric provided in <code>metric</code> and
<code>formula</code> except for the metric <em>abc</em> and <em>ABC</em> that
are stored in three columns (one for each letter).
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Baselga A (2012).
&ldquo;The Relationship between Species Replacement, Dissimilarity Derived from Nestedness, and Nestedness.&rdquo;
<em>Global Ecology and Biogeography</em>, <b>21</b>(12), 1223&ndash;1232.
</p>
<p>Baselga A (2013).
&ldquo;Separating the two components of abundance-based dissimilarity: balanced changes in abundance vs. abundance gradients.&rdquo;
<em>Methods in Ecology and Evolution</em>, <b>4</b>(6), 552&ndash;557.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+similarity">similarity()</a></code> <a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity</a>
<a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

dissim &lt;- dissimilarity(comat,
metric = c("abc", "ABC", "Simpson", "Brayturn"))

dissim &lt;- dissimilarity(comat, metric = "all",
formula = "1 - (b + c) / (a + b + c)")

</code></pre>

<hr>
<h2 id='dissimilarity_to_similarity'>Convert dissimilarity metrics to similarity metrics</h2><span id='topic+dissimilarity_to_similarity'></span>

<h3>Description</h3>

<p>This function converts a data.frame of dissimilarity metrics (beta diversity)
between sites to similarity metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity_to_similarity(dissimilarity, include_formula = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_to_similarity_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>.</p>
</td></tr>
<tr><td><code id="dissimilarity_to_similarity_+3A_include_formula">include_formula</code></td>
<td>
<p>a boolean indicating if the metrics based on your own
formula should be converted (see Details). This argument is set to <code>TRUE</code>
by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with additional class
<code>bioregion.pairwise.metric</code>, providing similarity
metric(s) between each pair of sites based on a dissimilarity object.
</p>


<h3>Note</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The behavior of this function changes depending on column names. Columns
<code>Site1</code> and <code>Site2</code> are copied identically. If there are columns called
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, <code>C</code> they will also be copied identically. If there
are columns based on your own formula (argument <code>formula</code> in
<code><a href="#topic+dissimilarity">dissimilarity()</a></code>) or not in the original list of dissimilarity metrics
(argument <code>metrics</code> in <code><a href="#topic+dissimilarity">dissimilarity()</a></code>) and if the argument
<code>include_formula</code> is set to <code>FALSE</code>, they will also be copied identically.
Otherwise there are going to be converted like they other columns (default
behavior).
</p>
<p>If a column is called <code>Euclidean</code>, the similarity will be calculated based
on the following formula:
</p>
<p>\(Euclidean similarity = 1 / (1 - Euclidean distance)\)
</p>
<p>Otherwise, all other columns will be transformed into dissimilarity with the
following formula:
</p>
<p>\(similarity = 1 - dissimilarity\)
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code> <code><a href="#topic+similarity">similarity()</a></code> <code><a href="#topic+dissimilarity">dissimilarity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

dissimil &lt;- dissimilarity(comat, metric = "all")
dissimil

similarity &lt;- dissimilarity_to_similarity(dissimil)
similarity

</code></pre>

<hr>
<h2 id='find_optimal_n'>Search for an optimal number of clusters in a list of partitions</h2><span id='topic+find_optimal_n'></span>

<h3>Description</h3>

<p>This function aims at optimizing one or several criteria on a set of
ordered partitions. It is usually applied to find one (or several) optimal
number(s) of clusters on, for example, a hierarchical tree to cut, or a
range of partitions obtained from k-means or PAM. Users are advised to be
careful if applied in other cases (e.g., partitions which are not ordered in
an increasing or decreasing sequence, or partitions which are not related
to each other).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimal_n(
  partitions,
  metrics_to_use = "all",
  criterion = "elbow",
  step_quantile = 0.99,
  step_levels = NULL,
  step_round_above = TRUE,
  metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),
  n_breakpoints = 1,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_optimal_n_+3A_partitions">partitions</code></td>
<td>
<p>a <code>bioregion.partition.metrics</code> object (output from
<code><a href="#topic+partition_metrics">partition_metrics()</a></code> or a <code>data.frame</code> with the first two
columns named &quot;K&quot; (partition name) and &quot;n_clusters&quot; (number of clusters) and
the following columns containing evaluation metrics (numeric values)</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_metrics_to_use">metrics_to_use</code></td>
<td>
<p>character string or vector of character strings
indicating upon which metric(s) in <code>partitions</code> the optimal number of
clusters should be calculated. Defaults to <code>"all"</code> which means all
metrics available in <code>partitions</code> will be used</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_criterion">criterion</code></td>
<td>
<p>character string indicating the criterion to be used to
identify optimal number(s) of clusters. Available methods currently include
<code>"elbow"</code>,
<code>"increasing_step"</code>, <code>"decreasing_step"</code>, <code>"cutoff"</code>,
<code>"breakpoints"</code>, <code>"min"</code> or
<code>"max"</code>. Default is <code>"elbow"</code>. See details.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_step_quantile">step_quantile</code></td>
<td>
<p>if <code>"increasing_step"</code> or <code>"decreasing_step"</code>,
specify here the quantile
of differences between two consecutive k to be used as the cutoff to
identify the most important steps in <code>eval_metric</code></p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_step_levels">step_levels</code></td>
<td>
<p>if <code>"increasing_step"</code> or <code>"decreasing_step"</code>, specify
here the number of largest steps to keep as cutoffs.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_step_round_above">step_round_above</code></td>
<td>
<p>a <code>boolean</code> indicating if the optimal number of
clusters should be picked above or below the identified steps. Indeed, each
step will correspond to a sudden increase or decrease between partition X &amp;
partition X+1: should the optimal partition be X+1
(<code>step_round_above = TRUE</code>) or X (<code>step_round_above = FALSE</code>?
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_metric_cutoffs">metric_cutoffs</code></td>
<td>
<p>if <code>criterion = "cutoff"</code>, specify here the cutoffs
of <code>eval_metric</code> at which the number of clusters should be extracted</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_n_breakpoints">n_breakpoints</code></td>
<td>
<p>specify here the number of breakpoints to look for in
the curve. Defaults to 1</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_plot">plot</code></td>
<td>
<p>a boolean indicating if a plot of the first <code>eval_metric</code>
should be drawn with the identified optimal numbers of cutoffs</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function explores the relationship evaluation metric ~ number of
clusters, and a criterion is applied to search an optimal number of
clusters.
</p>
<p><strong>Please read the note section about the following criteria.</strong>
</p>
<p>Foreword:
</p>
<p>Here we implemented a set of criteria commonly found in the literature or
recommended in the bioregionalisation literature. Nevertheless, we also
advocate to move
beyond the &quot;Search one optimal number of clusters&quot; paradigm, and consider
investigating &quot;multiple optimal numbers of clusters&quot;. Indeed, using only one
optimal number of clusters may simplify the natural complexity of biological
datasets, and, for example, ignore the often hierarchical / nested nature of
bioregionalisations. Using multiple partitions likely avoids this
oversimplification bias and may convey more information.
See, for example, the reanalysis of Holt et al. (2013)
by (Ficetola et al. 2017), where they used deep, intermediate
and shallow cuts.
</p>
<p>Following this rationale, several of the criteria implemented here can/will
return multiple &quot;optimal&quot; numbers of clusters, depending on user choices.
</p>
<p><strong>Criteria to find optimal number(s) of clusters</strong>
</p>

<ul>
<li><p><code>elbow</code>:
This method consists in finding one elbow in the evaluation metric curve, as
is commonly done in clustering analyses. The idea is to approximate the
number of clusters at which the evaluation metric no longer increments.It is
based on a fast method finding the maximum distance between the curve and a
straight line linking the minimum and maximum number of points. The code we
use here is based on code written by Esben Eickhardt available here
<a href="https://stackoverflow.com/questions/2018178/finding-the-best-trade-off-point-on-a-curve/42810075#42810075">https://stackoverflow.com/questions/2018178/finding-the-best-trade-off-point-on-a-curve/42810075#42810075</a>.
The code has been modified to work on both increasing and decreasing
evaluation metrics.
</p>
</li>
<li><p><code>increasing_step</code> or <code>decreasing_step</code>:
This method consists in identifying clusters at the most important changes,
or steps, in the evaluation metric. The objective can be to either look for
largest increases (<code>increasing_step</code>) or largest decreases
<code>decreasing_step</code>. Steps are calculated based on the pairwise differences
between partitions. Therefore, this is relative to the distribution of
differences in the evaluation metric over the tested partitions. Specify
<code>step_quantile</code> as the quantile cutoff above which steps will be selected as
most important (by default, 0.99, i.e. the largest 1\
selected).Alternatively, you can also choose to specify the number of top
steps to keep, e.g. to keep the largest three steps, specify
<code>step_level = 3</code>. Basically this method will emphasize the most important
changes in the evaluation metric as a first approximation of where important
cuts can be chosen.
</p>
<p>**Please note that you should choose between <code>increasing_step</code> and
<code>decreasing_step</code> depending on the nature of your evaluation metrics. For
example, for metrics that are monotonously decreasing (e.g., endemism
metrics <code>"avg_endemism" &amp; "tot_endemism"</code>) with the number of clusters
should n_clusters, you should choose <code>decreasing_step</code>. On the contrary, for
metrics that are monotonously increasing with the number of clusters (e.g.,
<code>"pc_distance"</code>), you should choose <code>increasing_step</code>. **

</p>
</li>
<li><p><code>cutoffs</code>:
This method consists in specifying the cutoff value(s) in the evaluation
metric from which the number(s) of clusters should be derived. This is the
method used by (Holt et al. 2013). Note, however, that the
cut-offs suggested by Holt et al. (0.9, 0.95, 0.99, 0.999) may be only
relevant at very large spatial scales, and lower cut-offs should be
considered at finer spatial scales.

</p>
</li>
<li><p><code>breakpoints</code>:
This method consists in finding break points in the curve using a segmented
regression. Users have to specify the number of expected break points in
<code>n_breakpoints</code> (defaults to 1). Note that since this method relies on a
regression model, it should probably not be applied with a low number of
partitions.
</p>
</li>
<li><p><code>min</code> &amp; <code>max</code>:
Picks the optimal partition(s) respectively at the minimum or maximum value
of the evaluation metric.
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>list</code> of class <code>bioregion.optimal.n</code> with three elements:
</p>

<ul>
<li><p><code>args</code>: input arguments

</p>
</li>
<li><p><code>evaluation_df</code>: the input evaluation data.frame appended with
<code>boolean</code> columns identifying the optimal numbers of clusters

</p>
</li>
<li><p><code>optimal_nb_clusters</code>: a list containing the optimal number(s)
of cluster(s) for each metric specified in <code>"metrics_to_use"</code>, based on
the chosen <code>criterion</code>

</p>
</li>
<li><p><code>plot</code>: if requested, the plot will be stored in this slot</p>
</li></ul>



<h3>Note</h3>

<p>Please note that finding the optimal number of clusters is a procedure
which normally requires decisions from the users, and as such can hardly be
fully automatized. Users are strongly advised to read the references
indicated below to look for guidance on how to choose their optimal
number(s) of clusters. Consider the &quot;optimal&quot; numbers of clusters returned
by this function as first approximation of the best numbers for your
bioregionalisation.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>References</h3>

<p>Castro-Insua A, Gómez-Rodríguez C, Baselga A (2018).
&ldquo;Dissimilarity measures affected by richness differences yield biased delimitations of biogeographic realms.&rdquo;
<em>Nature Communications</em>, <b>9</b>(1), 9&ndash;11.
</p>
<p>Ficetola GF, Mazel F, Thuiller W (2017).
&ldquo;Global determinants of zoogeographical boundaries.&rdquo;
<em>Nature Ecology &amp; Evolution</em>, <b>1</b>, 0089.
</p>
<p>Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J, Rahbek C (2013).
&ldquo;An update of Wallace's zoogeographic regions of the world.&rdquo;
<em>Science</em>, <b>339</b>(6115), 74&ndash;78.
</p>
<p>Kreft H, Jetz W (2010).
&ldquo;A framework for delineating biogeographical regions based on species distributions.&rdquo;
<em>Journal of Biogeography</em>, <b>37</b>, 2029&ndash;2053.
</p>
<p>Langfelder P, Zhang B, Horvath S (2008).
&ldquo;Defining clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for R.&rdquo;
<em>BIOINFORMATICS</em>, <b>24</b>(5), 719&ndash;720.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)

dissim &lt;- dissimilarity(comat, metric = "all")

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissim,
                          n_clust = 2:15,
                          index = "Simpson")
tree1

a &lt;- partition_metrics(tree1,
                   dissimilarity = dissim,
                   net = comnet,
                   species_col = "Node2",
                   site_col = "Node1",
                   eval_metric = c("tot_endemism",
                                   "avg_endemism",
                                   "pc_distance",
                                   "anosim"))
                                   
find_optimal_n(a)
find_optimal_n(a, criterion = "increasing_step")
find_optimal_n(a, criterion = "decreasing_step")
find_optimal_n(a, criterion = "decreasing_step",
               step_levels = 3) 
find_optimal_n(a, criterion = "decreasing_step",
               step_quantile = .9) 
find_optimal_n(a, criterion = "decreasing_step",
               step_levels = 3) 
find_optimal_n(a, criterion = "decreasing_step",
               step_levels = 3)                 
find_optimal_n(a, criterion = "breakpoints")             

</code></pre>

<hr>
<h2 id='fishdf'>Spatial distribution of fish in Europe (data.frame)</h2><span id='topic+fishdf'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 195 species in 338 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishdf
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2,703 rows and 3 columns:
</p>

<dl>
<dt>Site</dt><dd><p>Unique site identifier (corresponding to the field ID of fishsf).</p>
</dd>
<dt>Species</dt><dd><p>Unique species identifier.</p>
</dd>
<dt>Abundance</dt><dd><p>Species abundance</p>
</dd>
</dl>


<hr>
<h2 id='fishmat'>Spatial distribution of fish in Europe (co-occurrence matrix)</h2><span id='topic+fishmat'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of each of the 195 species in each of
the 338 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishmat
</code></pre>


<h3>Format</h3>

<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns. Each element of the matrix
represents the abundance of the species in the site.
</p>

<hr>
<h2 id='fishsf'>Spatial distribution of fish in Europe</h2><span id='topic+fishsf'></span>

<h3>Description</h3>

<p>A dataset containing the geometry of the 338 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishsf
</code></pre>


<h3>Format</h3>

<p>A
</p>

<dl>
<dt>ID</dt><dd><p>Unique site identifier.</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of the site.</p>
</dd>
</dl>


<hr>
<h2 id='hclu_diana'>Divisive hierarchical clustering based on dissimilarity or beta-diversity</h2><span id='topic+hclu_diana'></span>

<h3>Description</h3>

<p>This function computes a divisive hierarchical clustering from a
dissimilarity (beta-diversity) <code>data.frame</code>, calculates the cophenetic correlation
coefficient, and can get clusters from the tree if requested by the user.
The function implements randomization of the dissimilarity matrix to
generate the tree, with a selection method based on the optimal cophenetic
correlation coefficient. Typically, the dissimilarity <code>data.frame</code> is a
<code>bioregion.pairwise.metric</code> object obtained by running <code>similarity</code>
or <code>similarity</code> and then <code>similarity_to_dissimilarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclu_diana(
  dissimilarity,
  index = names(dissimilarity)[3],
  n_clust = NULL,
  cut_height = NULL,
  find_h = TRUE,
  h_max = 1,
  h_min = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclu_diana_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object.
If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_n_clust">n_clust</code></td>
<td>
<p>an integer or a vector of integers indicating the number of
clusters to be obtained from the hierarchical tree, or the output from
<a href="#topic+partition_metrics">partition_metrics</a>. Should not be used at the same time as
<code>cut_height</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_cut_height">cut_height</code></td>
<td>
<p>a numeric vector indicating the height(s) at which the
tree should be cut. Should not be used at the same time as <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_find_h">find_h</code></td>
<td>
<p>a boolean indicating if the height of cut should be found for
the requested <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_h_max">h_max</code></td>
<td>
<p>a numeric indicating the maximum possible tree height for
the chosen <code>index</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_h_min">h_min</code></td>
<td>
<p>a numeric indicating the minimum possible height in the tree
for the chosen <code>index</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chapter 6 of Kaufman and Rousseeuw (1990) fully details the functioning of
the diana algorithm.
</p>
<p>To find an optimal number of clusters, see <code><a href="#topic+partition_metrics">partition_metrics()</a></code>
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>
<p>#'
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kaufman L, Rousseeuw PJ (2009).
&ldquo;Finding groups in data: An introduction to cluster analysis.&rdquo;
In &amp; Sons. JW (ed.), <em>Finding groups in data: An introduction to cluster analysis.</em>.
</p>


<h3>See Also</h3>

<p><a href="#topic+cut_tree">cut_tree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

data("fishmat")
fishdissim &lt;- dissimilarity(fishmat)
fish_diana &lt;- hclu_diana(fishdissim, index = "Simpson")


</code></pre>

<hr>
<h2 id='hclu_hierarclust'>Hierarchical clustering based on dissimilarity or beta-diversity</h2><span id='topic+hclu_hierarclust'></span>

<h3>Description</h3>

<p>This function generates a hierarchical tree from a dissimilarity
(beta-diversity) <code>data.frame</code>, calculates the cophenetic correlation
coefficient, and can get clusters from the tree if requested by the user.
The function implements randomization of the dissimilarity matrix to
generate the tree, with a selection method based on the optimal cophenetic
correlation coefficient. Typically, the dissimilarity <code>data.frame</code> is a
<code>bioregion.pairwise.metric</code> object obtained by running <code>similarity</code>
or <code>similarity</code> and then <code>similarity_to_dissimilarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclu_hierarclust(
  dissimilarity,
  index = names(dissimilarity)[3],
  method = "average",
  randomize = TRUE,
  n_runs = 30,
  keep_trials = FALSE,
  optimal_tree_method = "best",
  n_clust = NULL,
  cut_height = NULL,
  find_h = TRUE,
  h_max = 1,
  h_min = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclu_hierarclust_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object.
If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_method">method</code></td>
<td>
<p>name of the hierarchical classification method, as in
<a href="fastcluster.html#topic+hclust">fastcluster::hclust()</a>. Should be one of <code>"ward.D"</code>,
<code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>
(= UPGMA), <code>"mcquitty"</code> (= WPGMA), <code>"median"</code> (= WPGMC) or
<code>"centroid"</code> (= UPGMC).</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_randomize">randomize</code></td>
<td>
<p>a boolean indicating if the dissimilarity matrix should be
randomized, to account for the order of sites in the dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_n_runs">n_runs</code></td>
<td>
<p>number of trials to randomize the dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_keep_trials">keep_trials</code></td>
<td>
<p>a boolean indicating if all random trial results.
should be stored in the output object (set to FALSE to save space if your
<code>dissimilarity</code> object is large).</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_optimal_tree_method">optimal_tree_method</code></td>
<td>
<p>a character vector indicating how the final tree
should be obtained from all trials. The only option currently is
<code>"best"</code>, which means the tree with the best cophenetic correlation
coefficient will be chosen.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_n_clust">n_clust</code></td>
<td>
<p>an integer or a vector of integers indicating the number of
clusters to be obtained from the hierarchical tree, or the output from
<a href="#topic+partition_metrics">partition_metrics</a>. Should not be used at the same time as
<code>cut_height</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_cut_height">cut_height</code></td>
<td>
<p>a numeric vector indicating the height(s) at which the
tree should be cut. Should not be used at the same time as <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_find_h">find_h</code></td>
<td>
<p>a boolean indicating if the height of cut should be found for
the requested <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_h_max">h_max</code></td>
<td>
<p>a numeric indicating the maximum possible tree height for
the chosen <code>index</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_h_min">h_min</code></td>
<td>
<p>a numeric indicating the minimum possible height in the tree
for the chosen <code>index</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method for the hierarchical tree is <code>"average"</code>, i.e.
UPGMA as it has been recommended as the best method to generate a tree
from beta diversity dissimilarity (Kreft and Jetz 2010)
</p>
<p>Clusters can be obtained by two methods:
</p>

<ul>
<li><p>Specifying a desired number of clusters in <code>n_clust</code>
</p>
</li>
<li><p>Specifying one or several heights of cut in <code>cut_height</code></p>
</li></ul>

<p>To find an optimal number of clusters, see <code><a href="#topic+partition_metrics">partition_metrics()</a></code>
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, users can find the following elements:
</p>

<ul>
<li><p><code>trials</code>: a list containing all randomization trials. Each trial
contains the dissimilarity matrix, with site order randomized, the
associated tree and the cophenetic correlation coefficient (Spearman) for
that tree
</p>
</li>
<li><p><code>final.tree</code>: a <code>hclust</code> object containing the final
hierarchical tree to be used
</p>
</li>
<li><p><code>final.tree.coph.cor</code>: the cophenetic correlation coefficient
between the initial dissimilarity matrix and <code>final.tree</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kreft H, Jetz W (2010).
&ldquo;A framework for delineating biogeographical regions based on species distributions.&rdquo;
<em>Journal of Biogeography</em>, <b>37</b>, 2029&ndash;2053.
</p>


<h3>See Also</h3>

<p><a href="#topic+cut_tree">cut_tree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissim, n_clust = 5)
tree1
plot(tree1)
str(tree1)
tree1$clusters

# User-defined height cut
# Only one height
tree2 &lt;- hclu_hierarclust(dissim, cut_height = .05)
tree2
tree2$clusters

# Multiple heights
tree3 &lt;- hclu_hierarclust(dissim, cut_height = c(.05, .15, .25))

tree3$clusters # Mind the order of height cuts: from deep to shallow cuts
# Info on each partition can be found in table cluster_info
tree3$cluster_info
plot(tree3)

# Recut the tree afterwards
tree3.1 &lt;- cut_tree(tree3, n = 5)

tree4 &lt;- hclu_hierarclust(dissim, n_clust = 1:19)

</code></pre>

<hr>
<h2 id='hclu_optics'>OPTICS hierarchical clustering algorithm</h2><span id='topic+hclu_optics'></span>

<h3>Description</h3>

<p>This function performs semi-hierarchical
clustering on the basis of dissimilarity with the OPTICS algorithm (Ordering
Points To Identify the Clustering Structure)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclu_optics(
  dissimilarity,
  index = names(dissimilarity)[3],
  minPts = NULL,
  eps = NULL,
  xi = 0.05,
  minimum = FALSE,
  show_hierarchy = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hclu_optics_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the dissimilarity
indices.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_minpts">minPts</code></td>
<td>
<p>a <code>numeric</code> value specifying the minPts argument of
<a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a>). minPts is the minimum number of
points to form a dense region. By default, it is set to the natural
logarithm of the number of sites in <code>dissimilarity</code>.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_eps">eps</code></td>
<td>
<p>a <code>numeric</code> value specifying the eps argument of
<a href="dbscan.html#topic+optics">dbscan::optics()</a>). It is the upper limit of the size
of the epsilon neighborhood. Limiting the neighborhood size improves
performance and has no or very little impact on the ordering as long as it
is not set too low. If not specified (default behavior), the largest
minPts-distance in the data set is used which gives the same result as
infinity.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_xi">xi</code></td>
<td>
<p>a <code>numeric</code> value specifying the steepness threshold to
identify clusters hierarchically using the Xi method
(see <a href="dbscan.html#topic+optics">dbscan::optics()</a>)</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_minimum">minimum</code></td>
<td>
<p>a <code>boolean</code> specifying if the hierarchy should be pruned
out from the output to only keep clusters at the &quot;minimal&quot; level, i.e.
only leaf / non-overlapping clusters.
If <code>TRUE</code>, then argument <code>show_hierarchy</code> should be <code>FALSE</code></p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_show_hierarchy">show_hierarchy</code></td>
<td>
<p>a <code>boolean</code> specifying if the hierarchy of
clusters should be included in the output. By default, the hierarchy is not
visible in the clusters obtained from OPTICS - it can only be visualized by
visualising the plot of the OPTICS object. If <code>show_hierarchy = TRUE</code>,
then the output cluster <code>data.frame</code> will contain additional columns
showing the hierarchy of clusters.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_...">...</code></td>
<td>
<p>you can add here further arguments to be passed to <code>optics()</code>
(see <a href="dbscan.html#topic+optics">dbscan::optics()</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optics (Ordering points to identify the clustering structure) is a
semi-hierarchical clustering algorithm which orders the points in the
dataset such that points which are closest become neighbors, and calculates
a reachability distance for each point. Then, clusters can be extracted in a
hierarchical manner from this reachability distance, by identifying clusters
depending on changes in the relative cluster density. The reachability plot
should be explored to understand the clusters and their hierarchical nature,
by running plot on the output of the function:
<code>plot(object$algorithm$optics)</code>.
We recommend reading (Hahsler et al. 2019) to grasp the
algorithm, how it works, and what the clusters mean.
</p>
<p>To extract the clusters, we use the
<a href="dbscan.html#topic+optics">dbscan::extractXi()</a> function which is based on the
steepness of the reachability plot (see
<a href="dbscan.html#topic+optics">dbscan::optics()</a>)
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Hahsler M, Piekenbrock M, Doran D (2019).
&ldquo;Dbscan: Fast density-based clustering with R.&rdquo;
<em>Journal of Statistical Software</em>, <b>91</b>(1).
ISSN 15487660.
</p>


<h3>See Also</h3>

<p><a href="#topic+nhclu_dbscan">nhclu_dbscan</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dissim &lt;- dissimilarity(fishmat, metric = "all")
  
clust1 &lt;- hclu_optics(dissim, index = "Simpson")
clust1

# Visualize the optics plot (the hierarchy of clusters is illustrated at the
# bottom)
plot(clust1$algorithm$optics)

# Extract the hierarchy of clusters
clust1 &lt;- hclu_optics(dissim, index = "Simpson", show_hierarchy = TRUE)
clust1

</code></pre>

<hr>
<h2 id='install_binaries'>Download, unzip, check permission and test the bioregion's binary files</h2><span id='topic+install_binaries'></span>

<h3>Description</h3>

<p>This function downloads and unzips the 'bin' folder needed to run some
functions of bioregion. It also checks if the files have the permissions to
be executed as programs. It finally tests if the binary files
are running properly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_binaries(
  binpath = "tempdir",
  infomap_version = c("2.1.0", "2.6.0", "2.7.1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_binaries_+3A_binpath">binpath</code></td>
<td>
<p>a <code>character</code> indicating the path to the folder that will
host the 'bin' folder containing the binary files (see Details).</p>
</td></tr>
<tr><td><code id="install_binaries_+3A_infomap_version">infomap_version</code></td>
<td>
<p>a <code>character</code> vector indicating the Infomap
version(s) to install.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the binary files are installed in R's temporary
directory (<code>binpath = "tempdir"</code>). In this case the <code>bin</code> folder will be
automatically removed at the end of the R session. Alternatively, the binary
files can be installed in the bioregion's package folder
(<code>binpath = "pkgfolder"</code>).
Finally, a path to a folder of your choice can be chosen.
</p>
<p><strong>In any case, PLEASE MAKE SURE to update the binpath accordingly in
<a href="#topic+netclu_infomap">netclu_infomap</a>, <a href="#topic+netclu_louvain">netclu_louvain</a> and <a href="#topic+netclu_oslom">netclu_oslom</a>).</strong>
</p>


<h3>Value</h3>

<p>No return value
</p>


<h3>Note</h3>

<p>Only the Infomap version 2.1.0, 2.6.0 and 2.7.1 are available for now.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>

<hr>
<h2 id='map_clusters'>Create a map of bioregions</h2><span id='topic+map_clusters'></span>

<h3>Description</h3>

<p>This plot function can be used to visualise bioregions based on a
bioregion.clusters object combined with a geometry (sf objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_clusters(clusters, geometry, write_clusters = FALSE, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_clusters_+3A_clusters">clusters</code></td>
<td>
<p>an object of class <code>bioregion.clusters</code> or a <code>data.frame</code>. If
a <code>data.frame</code> is used, the first column should represent the sites' ID, and
the next column(s) the clusters.</p>
</td></tr>
<tr><td><code id="map_clusters_+3A_geometry">geometry</code></td>
<td>
<p>a spatial object that can be handled by the <code>sf</code> package.
The first attribute should correspond to the sites' ID (see Details).</p>
</td></tr>
<tr><td><code id="map_clusters_+3A_write_clusters">write_clusters</code></td>
<td>
<p>a <code>boolean</code> indicating if the <code>clusters</code>
should be added in <code>geometry</code>.</p>
</td></tr>
<tr><td><code id="map_clusters_+3A_plot">plot</code></td>
<td>
<p>a <code>boolean</code> indicating if the plot should be drawn.</p>
</td></tr>
<tr><td><code id="map_clusters_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>sf::plot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>clusters</code> and <code>geometry</code> site IDs should correspond. They should
have the same type (i.e. <code>character</code> is cluster is a
<code>bioregion.clusters</code> object) and the site of <code>clusters</code> should be
included in the sites of <code>geometry</code>.
</p>


<h3>Value</h3>

<p>One or several maps of bioregions if <code>plot = TRUE</code> and the
geometry with additional clusters' attributes if <code>write_clusters = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fishmat)
data(fishsf)

net &lt;- similarity(fishmat, metric = "Simpson")
clu &lt;- netclu_greedy(net)
map &lt;- map_clusters(clu, fishsf, write_clusters = TRUE, plot = FALSE)

</code></pre>

<hr>
<h2 id='mat_to_net'>Create a data.frame from a contingency table</h2><span id='topic+mat_to_net'></span>

<h3>Description</h3>

<p>This function creates a two- or three-columns <code>data.frame</code> where
each row represents the interaction between two nodes (site and species for
example) and an optional third column indicating the weight of the
interaction (if <code>weight = TRUE</code>) from a contingency table (sites as
rows and species as columns for example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_to_net(
  mat,
  weight = FALSE,
  remove_zeroes = TRUE,
  include_diag = TRUE,
  include_lower = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_to_net_+3A_mat">mat</code></td>
<td>
<p>a contingency table (i.e. <code>matrix</code>).</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the value are weights.</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_remove_zeroes">remove_zeroes</code></td>
<td>
<p>a <code>boolean</code> determining whether interactions with
weight equal to 0 should be removed from the output.</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_include_diag">include_diag</code></td>
<td>
<p>a <code>boolean</code> indicating whether the diagonal
should be included in the output. Only for squared matrix.</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_include_lower">include_lower</code></td>
<td>
<p>a <code>boolean</code> indicating whether the lower triangular
matrix should be included in the output. Only for squared matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> where each row represents the interaction
between two nodes and an optional third column indicating the weight of the
interaction.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><a href="#topic+net_to_mat">net_to_mat</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(mat) &lt;- paste0("Site", 1:5)
colnames(mat) &lt;- paste0("Species", 1:10)

net &lt;- mat_to_net(mat, weight = TRUE)

</code></pre>

<hr>
<h2 id='net_to_mat'>Create a contingency table from a data.frame</h2><span id='topic+net_to_mat'></span>

<h3>Description</h3>

<p>This function creates a contingency table from a two- or three-columns
<code>data.frame</code> where each row represents the interaction between two
nodes (site and species for example) and an optional third column indicating
the weight of the interaction (if <code>weight = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_to_mat(
  net,
  weight = FALSE,
  squared = FALSE,
  symmetrical = FALSE,
  missing_value = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_to_mat_+3A_net">net</code></td>
<td>
<p>a two- or three-columns <code>data.frame</code> where each row
represents the interaction between two nodes (site and species for example)
and an optional third column indicating the weight of the interaction.</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weight should be considered</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_squared">squared</code></td>
<td>
<p>a <code>boolean</code> indicating if the output matrix should but
squared (same nodes in rows and columns).</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_symmetrical">symmetrical</code></td>
<td>
<p>a <code>boolean</code> indicating if the resulting matrix
should be symmetrical (only if <code>squared = TRUE</code>).
Note that different weights associated with two opposite pairs already
present in net will be preserved.</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_missing_value">missing_value</code></td>
<td>
<p>the value to assign to the pairs of nodes not present
in net (0 by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first nodes (first column of <code>net</code>) as
rows and the second nodes (second column of <code>net</code>) as columns. Note
that if <code>squared = TRUE</code> the rows and columns have the same number of
elements corresponding to the concatenation of unique objects in
<code>net</code>'s first and second columns. If <code>squared = TRUE</code> the matrix
can be forced to be symmetrical based on the upper triangular part of the
matrix.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><a href="#topic+mat_to_net">mat_to_net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- data.frame(
  Site = c(rep("A", 2), rep("B", 3), rep("C", 2)),
  Species = c("a", "b", "a", "c", "d", "b", "d"),
  Weight = c(10, 100, 1, 20, 50, 10, 20)
)

mat &lt;- net_to_mat(net, weight = TRUE)

</code></pre>

<hr>
<h2 id='netclu_beckett'>Community structure detection in weighted bipartite network via modularity
optimization</h2><span id='topic+netclu_beckett'></span>

<h3>Description</h3>

<p>This function takes a bipartite weighted graph and computes modules by
applying Newman’s modularity measure in a bipartite weighted version to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_beckett(
  net,
  weight = TRUE,
  index = names(net)[3],
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  forceLPA = FALSE,
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_beckett_+3A_net">net</code></td>
<td>
<p>a <code>data.frame</code> representing a bipartite network with the two
first columns as undirected links between pair of nodes and and the next
column(s) are the weight of the links.</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns (see Note).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes (i.e. primary
nodes).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes (i.e.
feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_forcelpa">forceLPA</code></td>
<td>
<p>a <code>boolean</code> indicating if the even faster pure
LPA-algorithm of Beckett should be used? DIRT-LPA, the default, is less
likely to get trapped in a local minimum, but is slightly slower. Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>computeModules</code> should be returned in the output (see Value).
Default to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the modularity optimization algorithm provided by
Stephen Beckett (Beckett 2016) as implemented in the
<a href="https://cran.r-project.org/package=bipartite">bipartite</a>
package (<a href="bipartite.html#topic+computeModules">computeModules</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can find an
object of class &quot;moduleWeb&quot;, output of
<a href="bipartite.html#topic+computeModules">computeModules</a>.
</p>


<h3>Note</h3>

<p>Beckett has been designed to deal with weighted bipartite networks. Note
that if <code>weight = FALSE</code>, a weight of 1 will be assigned to each pair of
nodes. Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>. The type of
nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,<code>"sites"</code>
to preserve only the sites nodes and <code>"species"</code> to preserve only the
species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Beckett SJ (2016).
&ldquo;Improved community detection in weighted bipartite networks.&rdquo;
<em>Royal Society Open Science</em>, <b>3</b>(1), 140536.
</p>


<h3>See Also</h3>

<p><a href="#topic+netclu_infomap">netclu_infomap</a>, <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- data.frame(
  Site = c(rep("A", 2), rep("B", 3), rep("C", 2)),
  Species = c("a", "b", "a", "c", "d", "b", "d"),
  Weight = c(10, 100, 1, 20, 50, 10, 20))

com &lt;- netclu_beckett(net)

</code></pre>

<hr>
<h2 id='netclu_greedy'>Community structure detection via greedy optimization of modularity</h2><span id='topic+netclu_greedy'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network via
greedy optimization of modularity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_greedy(
  net,
  weight = TRUE,
  index = names(net)[3],
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_greedy_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the similarity
indices.</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>communities</code> should be returned in the output (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the fast greedy modularity optimization algorithm
(Clauset et al. 2004) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find an &quot;communities&quot; object, output of
<a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"sites"</code> to preserve only the sites nodes and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Clauset A, Newman MEJ, Moore C (2004).
&ldquo;Finding community structure in very large networks.&rdquo;
<em>Phys. Rev. E</em>, <b>70</b>, 066111.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_greedy(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_greedy(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_infomap'>Infomap community finding</h2><span id='topic+netclu_infomap'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted (un)directed network based
on the Infomap algorithm (<a href="https://github.com/mapequation/infomap">https://github.com/mapequation/infomap</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_infomap(
  net,
  weight = TRUE,
  index = names(net)[3],
  nbmod = 0,
  markovtime = 1,
  seed = 0,
  numtrials = 1,
  twolevel = FALSE,
  show_hierarchy = FALSE,
  directed = FALSE,
  bipartite_version = FALSE,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  version = "2.7.1",
  binpath = "tempdir",
  path_temp = "infomap_temp",
  delete_temp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_infomap_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the similarity
indices.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_nbmod">nbmod</code></td>
<td>
<p>penalize solutions the more they differ from this number (0 by
default for no preferred number of modules).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_markovtime">markovtime</code></td>
<td>
<p>scales link flow to change the cost of moving between
modules, higher values results in fewer modules (default is 1).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_seed">seed</code></td>
<td>
<p>for the random number generator (0 for random by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_numtrials">numtrials</code></td>
<td>
<p>for the number of trials before picking up the best
solution.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_twolevel">twolevel</code></td>
<td>
<p>a <code>boolean</code> indicating if the algorithm should optimize a
two-level partition of the network (default is multi-level).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_show_hierarchy">show_hierarchy</code></td>
<td>
<p>a <code>boolean</code> specifying if the hierarchy of community
should be identifiable in the outputs (FALSE by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_directed">directed</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is directed (from
column 1 to column 2).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_bipartite_version">bipartite_version</code></td>
<td>
<p>a <code>boolean</code> indicating if the bipartite version of
Infomap should be used (see Note).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Note).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_version">version</code></td>
<td>
<p>a <code>character</code> indicating the Infomap version to use.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_binpath">binpath</code></td>
<td>
<p>a <code>character</code> indicating the path to the bin folder
(see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_path_temp">path_temp</code></td>
<td>
<p>a <code>character</code> indicating the path to the temporary folder
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_delete_temp">delete_temp</code></td>
<td>
<p>a <code>boolean</code> indicating if the temporary folder should
be removed (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Infomap is a network clustering algorithm based on the Map equation proposed
in (Rosvall and Bergstrom 2008) that finds communities in (un)weighted
and (un)directed networks.
</p>
<p>This function is based on the C++ version of Infomap
(<a href="https://github.com/mapequation/infomap/releases">https://github.com/mapequation/infomap/releases</a>).
This function needs binary files to run. They can be installed
with <a href="#topic+install_binaries">install_binaries</a>.
</p>
<p><strong>If you changed the default path to the <code>bin</code> folder
while running <a href="#topic+install_binaries">install_binaries</a> PLEASE MAKE SURE to set <code>binpath</code>
accordingly.</strong>
</p>
<p>The C++ version of Infomap generates temporary folders and/or files that are
stored in the <code>path_temp</code> folder (&quot;infomap_temp&quot; with an unique timestamp
located in the bin folder in <code>binpath</code> by default). This temporary folder is
removed by default (<code>delete_temp = TRUE</code>).
</p>
<p>Several version of Infomap are available in the package. See
<a href="#topic+install_binaries">install_binaries</a> for more details.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, users can find the following elements:
</p>

<ul>
<li><p><code>cmd</code>: the command line use to run Infomap
</p>
</li>
<li><p><code>version</code>: the Infomap version
</p>
</li>
<li><p><code>web</code>: Infomap's GitHub repository
</p>
</li></ul>



<h3>Note</h3>

<p>Infomap has been designed to deal with bipartite networks. To use this
functionality set the <code>bipartite_version</code> argument to TRUE in order to
approximate a two-step random walker (see
<a href="https://www.mapequation.org/infomap/">https://www.mapequation.org/infomap/</a> for more information). Note that
a bipartite network can also be considered as unipartite network
(<code>bipartite = TRUE</code>).
</p>
<p>In both cases do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes, <code>"sites"</code>
to preserve only the sites nodes and <code>"species"</code> to preserve only the
species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Rosvall M, Bergstrom CT (2008).
&ldquo;Maps of random walks on complex networks reveal community structure.&rdquo;
<em>Proceedings of the National Academy of Sciences</em>, <b>105</b>(4), 1118&ndash;1123.
</p>


<h3>See Also</h3>

<p><a href="#topic+install_binaries">install_binaries</a>, <a href="#topic+netclu_louvain">netclu_louvain</a>, <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_infomap(net)

</code></pre>

<hr>
<h2 id='netclu_labelprop'>Finding communities based on propagating labels</h2><span id='topic+netclu_labelprop'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on propagating labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_labelprop(
  net,
  weight = TRUE,
  index = names(net)[3],
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_labelprop_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>communities</code> should be returned in the output (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on propagating labels
(Raghavan et al. 2007) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_label_prop">cluster_label_prop</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find an &quot;communities&quot; object, output of
<a href="igraph.html#topic+cluster_label_prop">cluster_label_prop</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"sites"</code> to preserve only the sites nodes and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Raghavan UN, Albert R, Kumara S (2007).
&ldquo;Near linear time algorithm to detect community structures in large-scale networks.&rdquo;
<em>Physical Review E</em>, <b>76</b>(3), 036106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_labelprop(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_labelprop(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_leadingeigen'>Finding communities based on leading eigen vector of the community matrix</h2><span id='topic+netclu_leadingeigen'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on leading eigen vector of the community matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_leadingeigen(
  net,
  weight = TRUE,
  index = names(net)[3],
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_leadingeigen_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>communities</code> should be returned in the output (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on leading eigenvector of the community matrix
(Newman 2006) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find an &quot;communities&quot; object, output of
<a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"sites"</code> to preserve only the sites nodes and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Newman MEJ (2006).
&ldquo;Finding community structure in networks using the eigenvectors of matrices.&rdquo;
<em>Physical Review E</em>, <b>74</b>(3), 036104.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_leadingeigen(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_leadingeigen(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_leiden'>Finding communities using the Leiden algorithm</h2><span id='topic+netclu_leiden'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on the Leiden algorithm of Traag, van Eck &amp; Waltman.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_leiden(
  net,
  weight = TRUE,
  index = names(net)[3],
  objective_function = c("CPM", "modularity"),
  resolution_parameter = 1,
  beta = 0.01,
  initial_membership = NULL,
  n_iterations = 2,
  vertex_weights = NULL,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_leiden_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_objective_function">objective_function</code></td>
<td>
<p>Whether to use the Constant Potts Model (CPM) or
modularity. Must be either &quot;CPM&quot; or &quot;modularity&quot;.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_resolution_parameter">resolution_parameter</code></td>
<td>
<p>The resolution parameter to use. Higher
resolutions lead to more smaller communities, while lower resolutions lead
to fewer larger communities.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_beta">beta</code></td>
<td>
<p>Parameter affecting the randomness in the Leiden algorithm. This
affects only the refinement step of the algorithm.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_initial_membership">initial_membership</code></td>
<td>
<p>If provided, the Leiden algorithm will try to
improve this provided membership. If no argument is provided, the aglorithm
simply starts from the singleton partition.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_n_iterations">n_iterations</code></td>
<td>
<p>the number of iterations to iterate the Leiden
algorithm. Each iteration may improve the partition further.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_vertex_weights">vertex_weights</code></td>
<td>
<p>the vertex weights used in the Leiden algorithm. If
this is not provided, it will be automatically determined on the basis of
the objective_function. Please see the details of this function how to
interpret the vertex weights.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>communities</code> should be returned in the output (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the Leiden algorithm
(Traag et al. 2019) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_leiden">cluster_leiden</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find an &quot;communities&quot; object, output of
<a href="igraph.html#topic+cluster_leiden">cluster_leiden</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"sites"</code> to preserve only the sites nodes and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Traag VA, Waltman L, Van Eck NJ (2019).
&ldquo;From Louvain to Leiden: guaranteeing well-connected communities.&rdquo;
<em>Scientific reports</em>, <b>9</b>(1), 5233.
Publisher: Nature Publishing Group UK London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_leiden(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_leiden(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_louvain'>Louvain community finding</h2><span id='topic+netclu_louvain'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on the Louvain algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_louvain(
  net,
  weight = TRUE,
  index = names(net)[3],
  lang = "Cpp",
  resolution = 1,
  q = 0,
  c = 0.5,
  k = 1,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  binpath = "tempdir",
  path_temp = "louvain_temp",
  delete_temp = TRUE,
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_louvain_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of sites
(or any pair of nodes), and the next column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_lang">lang</code></td>
<td>
<p>a string indicating what version of Louvain should be used
(igraph or Cpp, see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_resolution">resolution</code></td>
<td>
<p>a resolution parameter to adjust the modularity
(1 is chosen by default, see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_q">q</code></td>
<td>
<p>the quality function used to compute partition of the graph
(modularity is chosen by default, see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_c">c</code></td>
<td>
<p>the parameter for the Owsinski-Zadrozny quality function
(between 0 and 1, 0.5 is chosen by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_k">k</code></td>
<td>
<p>the kappa_min value for the Shi-Malik quality function
(it must be &gt; 0, 1 is chosen by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_bipartite">bipartite</code></td>
<td>
<p>a boolean indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_binpath">binpath</code></td>
<td>
<p>a <code>character</code> indicating the path to the bin folder
(see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_path_temp">path_temp</code></td>
<td>
<p>a <code>character</code> indicating the path to the temporary folder
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_delete_temp">delete_temp</code></td>
<td>
<p>a <code>boolean</code> indicating if the temporary folder should
be removed (see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>communities</code> should be returned in the output (see Value).
Default to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Louvain is a network community detection algorithm proposed in
(Blondel et al. 2008). This function proposed two
implementations of the function (parameter <code>lang</code>): the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
implementation (<a href="igraph.html#topic+cluster_louvain">cluster_louvain</a>) and the C++
implementation (<a href="https://sourceforge.net/projects/louvain/">https://sourceforge.net/projects/louvain/</a>, version 0.3).
</p>
<p>The <a href="https://cran.r-project.org/package=igraph">igraph</a>
implementation offers the possibility to adjust the resolution parameter of
the modularity function (<code>resolution</code> argument) that the algorithm uses
internally. Lower values typically yield fewer, larger clusters. The original
definition of modularity is recovered when the resolution parameter
is set to 1 (by default).
</p>
<p>The C++ implementation offers the possibility to choose among several
quality functions,
<code>q = 0</code> for the classical Newman-Girvan criterion (also called
&quot;Modularity&quot;), 1 for the Zahn-Condorcet criterion, 2 for the
Owsinski-Zadrozny criterion (you should specify the value of the parameter
with the <code>c</code> argument), 3 for the Goldberg Density criterion, 4 for the
A-weighted Condorcet criterion,5 for the Deviation to Indetermination
criterion, 6 for the Deviation to Uniformity criterion, 7 for the Profile
Difference criterion, 8	for the Shi-Malik criterion (you should specify the
value of kappa_min with <code>k</code> argument) and 9 for the Balanced Modularity
criterion.
</p>
<p>The C++ version of Louvain is based on the version 0.3
(<a href="https://sourceforge.net/projects/louvain/">https://sourceforge.net/projects/louvain/</a>). This function needs
binary files to run. They can be installed with
<a href="#topic+install_binaries">install_binaries</a>.
</p>
<p><strong>If you changed the default path to the <code>bin</code> folder
while running <a href="#topic+install_binaries">install_binaries</a> PLEASE MAKE SURE to set <code>binpath</code>
accordingly.</strong>
</p>
<p>The C++ version of Louvain generates temporary folders and/or files that are
stored in the <code>path_temp</code> folder (&quot;louvain_temp&quot; with an unique timestamp
located in the bin folder in <code>binpath</code> by default). This temporary folder
is removed by default (<code>delete_temp = TRUE</code>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can find an
&quot;communities&quot; object, output of <a href="igraph.html#topic+cluster_louvain">cluster_louvain</a>
if <code>lang = "igraph"</code> and the following element if <code>lang = "Cpp"</code>:
</p>

<ul>
<li><p><code>cmd</code>: the command line use to run Louvain
</p>
</li>
<li><p><code>version</code>: the Louvain version
</p>
</li>
<li><p><code>web</code>: Louvain's website
</p>
</li></ul>
<p>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is dedicated to the
site nodes (i.e. primary nodes) and species nodes (i.e. feature nodes) using
the arguments <code>site_col</code> and <code>species_col</code>. The type of nodes returned in
the output can be chosen with the argument <code>return_node_type</code> equal to
<code>"both"</code> to keep both types of nodes, <code>"sites"</code> to preserve only the sites
nodes and <code>"species"</code> to preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Blondel VD, Guillaume JL, Lambiotte R, Mech ELJS (2008).
&ldquo;Fast unfolding of communities in large networks.&rdquo;
<em>J. Stat. Mech</em>, P10008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+install_binaries">install_binaries()</a></code>, <code><a href="#topic+netclu_infomap">netclu_infomap()</a></code>, <code><a href="#topic+netclu_oslom">netclu_oslom()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_louvain(net, lang = "igraph")

</code></pre>

<hr>
<h2 id='netclu_oslom'>OSLOM community finding</h2><span id='topic+netclu_oslom'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted (un)directed network based
on the OSLOM algorithm (<a href="http://oslom.org/">http://oslom.org/</a>, version 2.4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_oslom(
  net,
  weight = TRUE,
  index = names(net)[3],
  reassign = "no",
  r = 10,
  hr = 50,
  seed = 0,
  t = 0.1,
  cp = 0.5,
  directed = FALSE,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  binpath = "tempdir",
  path_temp = "oslom_temp",
  delete_temp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_oslom_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the similarity
indices.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_reassign">reassign</code></td>
<td>
<p>a string indicating if the nodes belonging to several
community should be reassign and what method should be used (see Note).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_r">r</code></td>
<td>
<p>the number of runs for the first hierarchical level
(10 by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_hr">hr</code></td>
<td>
<p>the number of runs for the higher hierarchical level (50 by
default, 0 if you are not interested in hierarchies).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_seed">seed</code></td>
<td>
<p>for the random number generator (0 for random by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_t">t</code></td>
<td>
<p>the p-value, the default value is 0.10, increase this value you to
get more modules.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_cp">cp</code></td>
<td>
<p>kind of resolution parameter used to decide between taking some
modules or their union (default value is 0.5, bigger value leads to bigger
clusters).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_directed">directed</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is directed (from
column 1 to column 2).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_binpath">binpath</code></td>
<td>
<p>a <code>character</code> indicating the path to the bin folder
(see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_path_temp">path_temp</code></td>
<td>
<p>a <code>character</code> indicating the path to the temporary folder
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_delete_temp">delete_temp</code></td>
<td>
<p>a <code>boolean</code> indicating if the temporary folder should
be removed (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OSLOM is a network community detection algorithm proposed in
(Lancichinetti et al. 2011) that finds statistically significant
(overlapping) communities in (un)weighted and (un)directed networks.
</p>
<p>This function is based on the 2.4 C++ version of OSLOM
(<a href="http://www.oslom.org/software.htm">http://www.oslom.org/software.htm</a>). This function needs files
to run. They can be installed with <a href="#topic+install_binaries">install_binaries</a>.
</p>
<p><strong>If you changed the default path to the <code>bin</code> folder
while running <a href="#topic+install_binaries">install_binaries</a> PLEASE MAKE SURE to set <code>binpath</code>
accordingly.</strong>
</p>
<p>The C++ version of OSLOM generates temporary folders and/or files that are
stored in the <code>path_temp</code> folder (folder &quot;oslom_temp&quot; with an unique timestamp
located in the bin folder in <code>binpath</code> by default). This temporary folder is
removed by default (<code>delete_temp = TRUE</code>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, users can find the following elements:
</p>

<ul>
<li><p><code>cmd</code>: the command line use to run OSLOM
</p>
</li>
<li><p><code>version</code>: the OSLOM version
</p>
</li>
<li><p><code>web</code>: the OSLOM's web site
</p>
</li></ul>



<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>). Do not forget to indicate which of the
first two columns is dedicated to the site nodes (i.e. primary nodes) and
species nodes (i.e.feature nodes) using the arguments <code>site_col</code> and
<code>species_col</code>. The type of nodes returned in the output can be chosen
with the argument <code>return_node_type</code> equal to <code>"both"</code> to keep both
types of nodes, <code>"sites"</code> to preserve only the sites nodes and
<code>"species"</code> to preserve only the species nodes.
</p>
<p>Since OSLOM potentially returns overlapping communities we propose two
methods to reassign the 'overlapping' nodes randomly <code>reassign = 'random'</code>
or based on the closest candidate community <code>reassign = 'simil'</code> (only for
weighted networks, in this case the closest candidate community is
determined with the average similarity). By default <code>reassign = 'no'</code> and
all the information will be provided. The number of partitions will depend
on the number of overlapping modules (up to three). The suffix '_semel',
'_bis' and '_ter' are added to the column names. The first partition
('_semel') assigns a module for each node. A value of 0 in the second
('_bis') and third ('_ter') columns indicates that no overlapping module
were found for this node (i.e. non-overlapping nodes).
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Lancichinetti A, Radicchi F, Ramasco JJ, Fortunato S (2011).
&ldquo;Finding statistically significant communities in networks.&rdquo;
<em>PloS one</em>, <b>6</b>(4).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+install_binaries">install_binaries()</a></code>, <code><a href="#topic+netclu_infomap">netclu_infomap()</a></code>, <code><a href="#topic+netclu_louvain">netclu_louvain()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_oslom(net)

</code></pre>

<hr>
<h2 id='netclu_walktrap'>Community structure detection via short random walks</h2><span id='topic+netclu_walktrap'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network via
short random walks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_walktrap(
  net,
  weight = TRUE,
  index = names(net)[3],
  steps = 4,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netclu_walktrap_+3A_net">net</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_weight">weight</code></td>
<td>
<p>a <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_index">index</code></td>
<td>
<p>name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_steps">steps</code></td>
<td>
<p>the length of the random walks to perform.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_bipartite">bipartite</code></td>
<td>
<p>a <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_return_node_type">return_node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot;, &quot;species&quot; or &quot;both&quot;) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>a <code>boolean</code> indicating if the original output
of <code>communities</code> should be returned in the output (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on random walks (Pons and Latapy 2005)
as implemented in the <a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find an &quot;communities&quot; object, output of
<a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"sites"</code> to preserve only the sites nodes and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pons P, Latapy M (2005).
&ldquo;Computing Communities in Large Networks Using Random Walks.&rdquo;
In Yolum I, Güngör T, Gürgen F, Özturan C (eds.), <em>Computer and Information Sciences - ISCIS 2005</em>,  Lecture Notes in Computer Science, 284&ndash;293.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_walktrap(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_walktrap(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='nhclu_clara'>Non hierarchical clustering: CLARA</h2><span id='topic+nhclu_clara'></span>

<h3>Description</h3>

<p>This function performs non hierarchical clustering on the basis of
dissimilarity with partitioning around medoids, using the Clustering Large
Applications (CLARA) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_clara(
  dissimilarity,
  index = names(dissimilarity)[3],
  n_clust = NULL,
  maxiter = 0L,
  initializer = "LAB",
  fasttol = 1,
  numsamples = 5L,
  sampling = 0.25,
  independent = FALSE,
  seed = 123456789L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhclu_clara_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_n_clust">n_clust</code></td>
<td>
<p>an <code>integer</code> or a <code>vector</code> of <code>integers</code> specifying the
requested number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_maxiter">maxiter</code></td>
<td>
<p>an <code>integer</code> defining the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_initializer">initializer</code></td>
<td>
<p>character string, either 'BUILD' (used in classic PAM
algorithm) or 'LAB' (linear approximative BUILD).</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_fasttol">fasttol</code></td>
<td>
<p>Positive numeric defining the tolerance for fast swapping
behavior, set to 1 by default.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_numsamples">numsamples</code></td>
<td>
<p>Positive integer defining the number of samples to draw.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_sampling">sampling</code></td>
<td>
<p>Positive numeric defining the sampling rate.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_independent">independent</code></td>
<td>
<p>Logical, FALSE by default meaning that the previous
medoids are not kept in the next sample.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_seed">seed</code></td>
<td>
<p>an <code>integer</code> to define a generator of random numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on fastkmedoids R package.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>



<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>), and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Schubert E, Rousseeuw PJ (2019).
&ldquo;Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms.&rdquo;
<em>Similarity Search and Applications</em>, <b>11807</b>, 171&ndash;187.
</p>


<h3>See Also</h3>

<p><a href="#topic+nhclu_pam">nhclu_pam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_clara(dissim, index = "Simpson", n_clust = 5)

partition_metrics(clust1, dissimilarity = dissim,
eval_metric = "pc_distance")

   
</code></pre>

<hr>
<h2 id='nhclu_clarans'>Non hierarchical clustering: CLARANS</h2><span id='topic+nhclu_clarans'></span>

<h3>Description</h3>

<p>This function performs non hierarchical clustering on the basis of
dissimilarity with partitioning around medoids, using the Clustering Large
Applications based on RANdomized Search (CLARANS) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_clarans(
  dissimilarity,
  index = names(dissimilarity)[3],
  n_clust = NULL,
  numlocal = 2L,
  maxneighbor = 0.025,
  seed = 123456789L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhclu_clarans_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_n_clust">n_clust</code></td>
<td>
<p>an <code>integer</code> or a <code>vector</code> of <code>integers</code> specifying the
requested number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_numlocal">numlocal</code></td>
<td>
<p>an <code>integer</code> defining the number of samples to draw.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_maxneighbor">maxneighbor</code></td>
<td>
<p>A positive numeric defining the sampling rate.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_seed">seed</code></td>
<td>
<p>an <code>integer</code> to define a generator of random numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on fastkmedoids R package.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>



<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>), and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Schubert E, Rousseeuw PJ (2019).
&ldquo;Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms.&rdquo;
<em>Similarity Search and Applications</em>, <b>11807</b>, 171&ndash;187.
</p>


<h3>See Also</h3>

<p><a href="#topic+nhclu_pam">nhclu_pam</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_clarans(dissim, index = "Simpson", n_clust = 5)

partition_metrics(clust1, dissimilarity = dissim,
eval_metric = "pc_distance")

   
</code></pre>

<hr>
<h2 id='nhclu_dbscan'>dbscan clustering</h2><span id='topic+nhclu_dbscan'></span>

<h3>Description</h3>

<p>This function performs non hierarchical clustering on the basis of
dissimilarity with Density-based Spatial Clustering of Applications with
Noise (DBSCAN)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_dbscan(
  dissimilarity,
  index = names(dissimilarity)[3],
  minPts = NULL,
  eps = NULL,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhclu_dbscan_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_minpts">minPts</code></td>
<td>
<p>a <code>numeric</code> value or a vector of <code>numeric</code> values
specifying the minPts argument of <a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a>).
minPts is the minimum number of points to form a dense region. By default,
it is set to the natural logarithm of the number of sites in
<code>dissimilarity</code>. See details for guidance on choosing this parameter.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_eps">eps</code></td>
<td>
<p>a <code>numeric</code> value or a vector of <code>numeric</code> values specifying the
eps argument of <a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a>). eps specifies how
similar points should be to each other to be considered a part of a cluster.
See details for guidance on choosing this parameter.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_plot">plot</code></td>
<td>
<p>a <code>boolean</code> indicating if the  k-nearest neighbor distance plot
should be plotted.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_...">...</code></td>
<td>
<p>you can add here further arguments to be passed to <code>dbscan()</code>
(see <a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dbscan (Density-based spatial clustering of
applications with noise) clustering algorithm clusters points on the basis
of the density of neighbours around each data points. It necessitates two
main arguments, <code>minPts</code>, which stands for the minimum number of points to
identify a core, and <code>eps</code>, which is the radius to find neighbors.
<code>minPts</code> and <code>eps</code> should be defined by the user, which is not
straightforward.
We recommend reading the help in <a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a>)
to learn how to set these arguments, as well as the paper
(Hahsler et al. 2019). Note that clusters with a value of 0
are points which were deemed as noise by the algorithm.
</p>
<p>By default the function will select values for <code>minPts</code> and <code>eps</code>. However,
these values can be inadequate and the users is advised to tune these values
by running the function multiple times.
</p>
<p><strong>Choosing minPts:</strong> how many points should be necessary to make a cluster?
i.e., what is the minimum number of sites you expect in a bioregion? Set a
value sufficiently large for your dataset and your expectations.
</p>
<p><strong>Choosing eps:</strong> how similar should sites be in a cluster?  If <code>eps</code> is
too small, then a majority of points will be considered too distinct and
will not be clustered at all (i.e., considered as noise)? If the value is
too high, then clusters will merge together.
The value of <code>eps</code> depends on the <code>minPts</code> argument, and the literature
recommends to choose <code>eps</code> by identifying a knee in the k-nearest neighbor
distance plot. By default
the function will try to automatically find a knee in that curve, but the
result is uncertain, and so the user should inspect the graph and modify
<code>dbscan_eps</code> accordingly.To explore eps values, follow the
recommendation by the function when you launch it a first time without
defining <code>eps</code>. Then, adjust depending on your clustering results.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p><a href="#topic+hclu_optics">hclu_optics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_dbscan(dissim, index = "Simpson")
clust2 &lt;- nhclu_dbscan(dissim, index = "Simpson", eps = 0.2)
clust3 &lt;- nhclu_dbscan(dissim, index = "Simpson", minPts = c(5, 10, 15, 20),
     eps = c(.1, .15, .2, .25, .3))

</code></pre>

<hr>
<h2 id='nhclu_kmeans'>Non hierarchical clustering: k-means analysis</h2><span id='topic+nhclu_kmeans'></span>

<h3>Description</h3>

<p>This function performs non hierarchical
clustering on the basis of dissimilarity with a k-means analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_kmeans(
  dissimilarity,
  index = names(dissimilarity)[3],
  n_clust = NULL,
  iter_max = 10,
  nstart = 10,
  algorithm = "Hartigan-Wong"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhclu_kmeans_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_n_clust">n_clust</code></td>
<td>
<p>an <code>integer</code> or a <code>vector</code> of <code>integers</code> specifying the
requested number(s) of clusters</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_iter_max">iter_max</code></td>
<td>
<p>an <code>integer</code> specifying the maximum number of
iterations for the kmeans method (see <a href="stats.html#topic+kmeans">stats::kmeans()</a>)</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_nstart">nstart</code></td>
<td>
<p>an <code>integer</code> specifying how many random sets of
<code>n_clust</code> should be selected as starting points for the kmeans analysis
(see <a href="stats.html#topic+kmeans">stats::kmeans()</a>)</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>a <code style="white-space: pre;">&#8288;character string&#8288;</code> specifying the algorithm to use for
kmean (see <a href="stats.html#topic+kmeans">stats::kmeans()</a>). Available options are
Hartigan-Wong, Lloyd, Forgy and MacQueen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method partitions the data into k groups
such that that the sum of squares of euclidean distances from points to the
assigned cluster centers is minimized. k-means cannot be applied directly
on dissimilarity/beta-diversity metrics, because these distances are not
euclidean. Therefore, it requires first to transform the dissimilarity
matrix with a Principal Coordinate Analysis (using the function
<a href="ape.html#topic+pcoa">ape::pcoa()</a>), and then applying k-means on the coordinates
of points in the PCoA. Because this makes an additional transformation of
the initial matrix of dissimilarity, the partitioning around medoids method
should be preferred (<code><a href="#topic+nhclu_pam">nhclu_pam()</a></code>)
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p><a href="#topic+nhclu_pam">nhclu_pam</a>
</p>
<p><a href="#topic+cut_tree">cut_tree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)

dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_kmeans(dissim, n_clust = 2:10, index = "Simpson")
clust2 &lt;- nhclu_kmeans(dissim, n_clust = 2:15, index = "Simpson")
partition_metrics(clust2, dissimilarity = dissim,
                  eval_metric = "pc_distance")

partition_metrics(clust2, net = comnet, species_col = "Node2",
                  site_col = "Node1", eval_metric = "avg_endemism")

</code></pre>

<hr>
<h2 id='nhclu_pam'>Non hierarchical clustering: partitioning around medoids</h2><span id='topic+nhclu_pam'></span>

<h3>Description</h3>

<p>This function performs non hierarchical clustering on the basis of
dissimilarity with partitioning around medoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_pam(
  dissimilarity,
  index = names(dissimilarity)[3],
  n_clust = NULL,
  nstart = if (variant == "faster") 1 else NA,
  variant = "faster",
  cluster_only = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhclu_pam_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns represent pairs of sites (or any pair of nodes),
and the next column(s) are the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_index">index</code></td>
<td>
<p>name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_n_clust">n_clust</code></td>
<td>
<p>an <code>integer</code> or a <code>vector</code> of <code>integers</code> specifying the
requested number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_nstart">nstart</code></td>
<td>
<p>an <code>integer</code> specifying the number of random “starts” for the
pam algorithm. By default, 1 (for the <code>"faster"</code> variant).</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_variant">variant</code></td>
<td>
<p>a <code>character</code> string specifying the variant of pam to use,
by default &quot;faster&quot;. Available options are original, o_1, o_2, f_3, f_4,
f_5 or fasterSee <a href="cluster.html#topic+pam">cluster::pam()</a> for more details.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_cluster_only">cluster_only</code></td>
<td>
<p>a <code>boolean</code> specifying if only the clustering should be
returned from the <a href="cluster.html#topic+pam">cluster::pam()</a> function (more efficient).</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_...">...</code></td>
<td>
<p>you can add here further arguments to be passed to <code>pam()</code>
(see <a href="cluster.html#topic+pam">cluster::pam()</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method partitions data into the chosen number of cluster on the basis
of the input dissimilarity matrix. It is more robust than k-means because it
minimizes the sum of dissimilarity between cluster centres and points
assigned to the cluster - whereas the k-means approach minimizes the sum of
squared euclidean distances (thus k-means cannot be applied directly on the
input dissimilarity matrix if the distances are not euclidean).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code style="white-space: pre;">&#8288;character string&#8288;</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kaufman L, Rousseeuw PJ (2009).
&ldquo;Finding groups in data: An introduction to cluster analysis.&rdquo;
In &amp; Sons. JW (ed.), <em>Finding groups in data: An introduction to cluster analysis.</em>.
</p>


<h3>See Also</h3>

<p><a href="#topic+nhclu_kmeans">nhclu_kmeans</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)
dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_pam(dissim, n_clust = 2:10, index = "Simpson")
clust2 &lt;- nhclu_pam(dissim, n_clust = 2:15, index = "Simpson")
partition_metrics(clust2, dissimilarity = dissim,
eval_metric = "pc_distance")
partition_metrics(clust2, net = comnet, species_col = "Node2",
                   site_col = "Node1", eval_metric = "avg_endemism")
   
</code></pre>

<hr>
<h2 id='partition_metrics'>Calculate metrics for one or several partitions</h2><span id='topic+partition_metrics'></span>

<h3>Description</h3>

<p>This function aims at calculating metrics for one or several partitions,
usually on outputs from <code>netclu_</code>, <code>hclu_</code> or <code>nhclu_</code> functions. Metrics
may require the users to provide either a similarity or dissimilarity
matrix, or to provide the initial species-site table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_metrics(
  cluster_object,
  dissimilarity = NULL,
  dissimilarity_index = NULL,
  net = NULL,
  site_col = 1,
  species_col = 2,
  eval_metric = c("pc_distance", "anosim", "avg_endemism", "tot_endemism")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_metrics_+3A_cluster_object">cluster_object</code></td>
<td>
<p>a <code>bioregion.clusters</code> object</p>
</td></tr>
<tr><td><code id="partition_metrics_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>a <code>dist</code> object or a <code>bioregion.pairwise.metric</code> object (output
from <code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>). Necessary if <code>eval_metric</code>
includes <code>pc_distance</code> and <code>tree</code> is not a
<code>bioregion.hierar.tree</code> object</p>
</td></tr>
<tr><td><code id="partition_metrics_+3A_dissimilarity_index">dissimilarity_index</code></td>
<td>
<p>a character string indicating the dissimilarity
(beta-diversity) index to be used in case <code>dist</code> is a <code>data.frame</code> with
multiple dissimilarity indices</p>
</td></tr>
<tr><td><code id="partition_metrics_+3A_net">net</code></td>
<td>
<p>the species-site network (i.e., bipartite network). Should be
provided if <code>eval_metric</code> includes <code>"avg_endemism"</code> or <code>"tot_endemism"</code></p>
</td></tr>
<tr><td><code id="partition_metrics_+3A_site_col">site_col</code></td>
<td>
<p>name or number for the column of site nodes (i.e. primary
nodes). Should be provided if <code>eval_metric</code> includes <code>"avg_endemism"</code> or
<code>"tot_endemism"</code></p>
</td></tr>
<tr><td><code id="partition_metrics_+3A_species_col">species_col</code></td>
<td>
<p>name or number for the column of species nodes (i.e.
feature nodes). Should be provided if <code>eval_metric</code> includes
<code>"avg_endemism"</code> or <code>"tot_endemism"</code></p>
</td></tr>
<tr><td><code id="partition_metrics_+3A_eval_metric">eval_metric</code></td>
<td>
<p>character string or vector of character strings indicating
metric(s) to be calculated to investigate the effect of different number
of clusters. Available options: <code>"pc_distance"</code>, <code>"anosim"</code>,
<code>"avg_endemism"</code> and <code>"tot_endemism"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p><strong>Evaluation metrics:</strong>
</p>

<ul>
<li><p><code>pc_distance</code>: this metric is the method used by
(Holt et al. 2013). It is a ratio of the between-cluster sum of
dissimilarity (beta-diversity) versus the total sum of dissimilarity
(beta-diversity) for the full dissimilarity matrix. In other words, it is
calculated on the basis of two elements. First, the total sum of
dissimilarity is calculated by summing the entire dissimilarity matrix
(<code>dist</code>). Second, the between-cluster sum of dissimilarity is calculated as
follows: for a given number of cluster, the dissimilarity is only summed
between clusters, not within clusters. To do that efficiently, all pairs of
sites within the same clusters have their dissimilarity set to zero in
the dissimilarity matrix, and then the dissimilarity matrix is summed. The
<code>pc_distance</code> ratio is obtained by dividing the between-cluster sum of
dissimilarity by the total sum of dissimilarity.
</p>
</li>
<li><p><code>anosim</code>: This metric is the statistic used in Analysis of
Similarities, as suggested in (Castro-Insua et al. 2018) (see
<a href="vegan.html#topic+anosim">vegan::anosim()</a>). It compares the between-cluster
dissimilarities to the within-cluster dissimilarities. It is based based on
the difference of mean ranks between groups and within groups with the
following formula:
\(R = (r_B - r_W)/(N (N-1) / 4)\),
where \(r_B\) and \(r_W\) are the average ranks
between and within clusters respectively, and \(N\) is the total
number of sites.
Note that the function does not estimate the significance here, it only
computes the statistic - for significance testing see
<a href="vegan.html#topic+anosim">vegan::anosim()</a>.
</p>
</li>
<li><p><code>avg_endemism</code>: this metric is the average percentage of
endemism in clusters as
recommended by (Kreft and Jetz 2010). Calculated as follows:
\(End_{mean} = \frac{\sum_{i=1}^K E_i / S_i}{K}\)
where \(E_i\) is the number of endemic species in cluster i,
\(S_i\) is the number of
species in cluster i, and K the maximum number of clusters.

</p>
</li>
<li><p><code>tot_endemism</code>: this metric is the total endemism across all clusters,
as recommended by (Kreft and Jetz 2010). Calculated as follows:
\(End_{tot} = \frac{E}{C}\)
</p>
<p>where \(E\) is total the number of endemics (i.e., species found in
only one cluster) and \(C\) is the number of non-endemic species.

</p>
</li></ul>



<h3>Value</h3>

<p>a <code>list</code> of class <code>bioregion.partition.metrics</code> with two to three elements:
</p>

<ul>
<li><p><code>args</code>: input arguments

</p>
</li>
<li><p><code>evaluation_df</code>: the data.frame containing <code>eval_metric</code>
for all explored numbers of clusters

</p>
</li>
<li><p><code>endemism_results</code>: if endemism calculations were requested, a list
with the endemism results for each partition

</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>),
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>References</h3>

<p>Castro-Insua A, Gómez-Rodríguez C, Baselga A (2018).
&ldquo;Dissimilarity measures affected by richness differences yield biased delimitations of biogeographic realms.&rdquo;
<em>Nature Communications</em>, <b>9</b>(1), 9&ndash;11.
</p>
<p>Ficetola GF, Mazel F, Thuiller W (2017).
&ldquo;Global determinants of zoogeographical boundaries.&rdquo;
<em>Nature Ecology &amp; Evolution</em>, <b>1</b>, 0089.
</p>
<p>Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P, Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ, Fjeldså J, Rahbek C (2013).
&ldquo;An update of Wallace's zoogeographic regions of the world.&rdquo;
<em>Science</em>, <b>339</b>(6115), 74&ndash;78.
</p>
<p>Kreft H, Jetz W (2010).
&ldquo;A framework for delineating biogeographical regions based on species distributions.&rdquo;
<em>Journal of Biogeography</em>, <b>37</b>, 2029&ndash;2053.
</p>
<p>Langfelder P, Zhang B, Horvath S (2008).
&ldquo;Defining clusters from a hierarchical cluster tree: the Dynamic Tree Cut package for R.&rdquo;
<em>BIOINFORMATICS</em>, <b>24</b>(5), 719&ndash;720.
</p>


<h3>See Also</h3>

<p><a href="#topic+compare_partitions">compare_partitions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)

dissim &lt;- dissimilarity(comat, metric = "all")

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissim, n_clust = 2:20, index = "Simpson")
tree1

a &lt;- partition_metrics(tree1, dissimilarity = dissim, net = comnet,
                       site_col = "Node1", species_col = "Node2",
                       eval_metric = c("tot_endemism", "avg_endemism",
                                      "pc_distance", "anosim"))
a

</code></pre>

<hr>
<h2 id='similarity'>Compute similarity metrics between sites based on species composition</h2><span id='topic+similarity'></span>

<h3>Description</h3>

<p>This function creates a <code>data.frame</code> where each row provides one or
several similarity metric(s) between each pair of sites from a co-occurrence
<code>matrix</code> with sites as rows and species as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(comat, metric = "Simpson", formula = NULL, method = "prodmat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_+3A_comat">comat</code></td>
<td>
<p>a co-occurrence <code>matrix</code> with sites as rows and species as
columns.</p>
</td></tr>
<tr><td><code id="similarity_+3A_metric">metric</code></td>
<td>
<p>a vector of string(s) indicating which metrics to chose
(see Details). Available options are <em>abc</em>, <em>ABC</em>, <em>Jaccard</em>,
<em>Jaccardturn</em>, <em>Sorensen</em>, <em>Simpson</em>,  <em>Bray</em>,
<em>Brayturn</em> or <em>Euclidean</em>.<br />
If <code>"all"</code> is specified, then all metrics will be
calculated. Can be set to <code>NULL</code> if <code>formula</code> is used.</p>
</td></tr>
<tr><td><code id="similarity_+3A_formula">formula</code></td>
<td>
<p>a vector of string(s) with your own formula based on the
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code> quantities
(see Details). <code>formula</code> is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="similarity_+3A_method">method</code></td>
<td>
<p>a string indicating what method should be used to compute
<code>abc</code> (see Details).
<code>method = "prodmat"</code> by default is more efficient but can be greedy in
memory and <code>method = "loops"</code> is less efficient but less greedy in
memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>With <code>a</code> the number of species shared by a pair of sites, <code>b</code>
species only present in the first site and <code>c</code> species only present in
the second site.
</p>
<p>\(Jaccard = 1 - (b + c) / (a + b + c)\)
</p>
<p>\(Jaccardturn = 1 - 2min(b, c) / (a + 2min(b, c))\) (Baselga 2012)
</p>
<p>\(Sorensen = 1 - (b + c) / (2a + b + c)\)
</p>
<p>\(Simpson = 1 - min(b, c) / (a + min(b, c))\)
</p>
<p>If abundances data are available, Bray-Curtis and its turnover component can
also be computed with the following equation:
</p>
<p>\(Bray = 1 - (B + C) / (2A + B + C)\)
</p>
<p>\(Brayturn = 1 - min(B, C)/(A + min(B, C))\) (Baselga 2013)
</p>
<p>with A the sum of the lesser values for common species shared by a pair of
sites.
B and C are the total number of specimens counted at both sites minus A.
</p>
<p><code>formula</code> can be used to compute customized metrics with the terms
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code>. For example
<code>formula = c("1 - (b + c) / (a + b + c)", "1 - (B + C) / (2*A + B + C)")</code>
will compute the Jaccard and Bray-Curtis similarity metrics, respectively.
</p>
<p>Euclidean computes the Euclidean similarity between each pair of site
following this equation:
</p>
<p>\(Euclidean = 1 / (1 + d_{ij})\)
</p>
<p>Where \(d_{ij}\) is the Euclidean distance between site i and
site j in terms of species composition.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with additional class
<code>bioregion.pairwise.metric</code>, providing one or several similarity
metric(s) between each pair of sites. The two first columns represent each
pair of sites.
One column per similarity metric provided in <code>metric</code> and
<code>formula</code> except for the metric <em>abc</em> and <em>ABC</em> that are
stored in three columns (one for each letter).
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Baselga A (2012).
&ldquo;The Relationship between Species Replacement, Dissimilarity Derived from Nestedness, and Nestedness.&rdquo;
<em>Global Ecology and Biogeography</em>, <b>21</b>(12), 1223&ndash;1232.
</p>
<p>Baselga A (2013).
&ldquo;Separating the two components of abundance-based dissimilarity: balanced changes in abundance vs. abundance gradients.&rdquo;
<em>Methods in Ecology and Evolution</em>, <b>4</b>(6), 552&ndash;557.
</p>


<h3>See Also</h3>

<p><a href="#topic+dissimilarity">dissimilarity</a> <a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity</a>
<a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

sim &lt;- similarity(comat, metric = c("abc", "ABC", "Simpson", "Brayturn"))

sim &lt;- similarity(comat, metric = "all",
formula = "1 - (b + c) / (a + b + c)")

</code></pre>

<hr>
<h2 id='similarity_to_dissimilarity'>Convert similarity metrics to dissimilarity metrics</h2><span id='topic+similarity_to_dissimilarity'></span>

<h3>Description</h3>

<p>This function converts a data.frame of similarity metrics between sites to
dissimilarity metrics (beta diversity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity_to_dissimilarity(similarity, include_formula = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_to_dissimilarity_+3A_similarity">similarity</code></td>
<td>
<p>the output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.</p>
</td></tr>
<tr><td><code id="similarity_to_dissimilarity_+3A_include_formula">include_formula</code></td>
<td>
<p>a boolean indicating if the metrics based on your own
formula should be converted (see Details). This argument is set to <code>TRUE</code>
by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with additional class
<code>bioregion.pairwise.metric</code>, providing dissimilarity
metric(s) between each pair of sites based on a similarity object.
</p>


<h3>Note</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The behavior of this function changes depending on column names. Columns
<code>Site1</code> and <code>Site2</code> are copied identically. If there are columns called
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, <code>C</code> they will also be copied identically. If there
are columns based on your own formula (argument <code>formula</code> in <code><a href="#topic+similarity">similarity()</a></code>)
or not in the original list of similarity metrics (argument <code>metrics</code> in
<code><a href="#topic+similarity">similarity()</a></code>) and if the argument <code>include_formula</code> is set to <code>FALSE</code>,
they will also be copied identically. Otherwise there are going to be
converted like they other columns (default behavior).
</p>
<p>If a column is called <code>Euclidean</code>, its distance will be calculated based
on the following formula:
</p>
<p>\(Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity\)
</p>
<p>Otherwise, all other columns will be transformed into dissimilarity with the
following formula:
</p>
<p>\(dissimilarity = 1 - similarity\)
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) and
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code> <code><a href="#topic+similarity">similarity()</a></code> <code><a href="#topic+dissimilarity">dissimilarity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

simil &lt;- similarity(comat, metric = "all")
simil

dissimilarity &lt;- similarity_to_dissimilarity(simil)
dissimilarity

</code></pre>

<hr>
<h2 id='subset_node'>Extract a subset of node from a bioregion.clusters object</h2><span id='topic+subset_node'></span>

<h3>Description</h3>

<p>This function extracts a subset of node according to its type (sites or
species) from a bioregion.clusters object containing both types of
nodes (sites and species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_node(clusters, node_type = "sites")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_node_+3A_clusters">clusters</code></td>
<td>
<p>an object of class <code>bioregion.clusters</code>.</p>
</td></tr>
<tr><td><code id="subset_node_+3A_node_type">node_type</code></td>
<td>
<p>a <code>character</code> indicating what types of nodes
(&quot;sites&quot; or &quot;species&quot;) should be extracted
(<code>node_type = "sites"</code> by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bioregion.clusters</code> with a given node type (sites
or species).
</p>


<h3>Note</h3>

<p>The network clustering functions (prefix <code>netclu_</code>) may return both types of
nodes (sites and species) when applied on bipartite networks
(argument <code>bipartite</code>). In this case, the type of nodes returned in the
output can be chosen with the argument <code>return_node_type</code>. This function
allows to retrieve a particular type of nodes (sites or species) from the
output and modify the return_node_type accordingly.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>),
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) and
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- data.frame(
  Site = c(rep("A", 2), rep("B", 3), rep("C", 2)),
  Species = c("a", "b", "a", "c", "d", "b", "d"),
  Weight = c(10, 100, 1, 20, 50, 10, 20)
)

clusters &lt;- netclu_louvain(net, lang = "igraph", bipartite = TRUE)

clusters_sites &lt;- subset_node(clusters, node_type = "sites")

</code></pre>

<hr>
<h2 id='vegedf'>Spatial distribution of Mediterranean vegetation (data.frame)</h2><span id='topic+vegedf'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 3,697 species in 715 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegedf
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 460,878 rows and 3 columns:
</p>

<dl>
<dt>Site</dt><dd><p>Unique site identifier (corresponding to the field ID of vegesp).</p>
</dd>
<dt>Species</dt><dd><p>Unique species identifier.</p>
</dd>
<dt>Abundance</dt><dd><p>Species abundance</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.4718">doi:10.1002/ece3.4718</a>
</p>

<hr>
<h2 id='vegemat'>Spatial distribution of Mediterranean vegetation (co-occurrence matrix)</h2><span id='topic+vegemat'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of each of the 3,697 species in each of
the 715 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegemat
</code></pre>


<h3>Format</h3>

<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns. Each element of the matrix
represents the abundance of the species in the site.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.4718">doi:10.1002/ece3.4718</a>
</p>

<hr>
<h2 id='vegesf'>Spatial distribution of Mediterranean vegetation (spatial grid)</h2><span id='topic+vegesf'></span>

<h3>Description</h3>

<p>A dataset containing the geometry of the 715 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegesf
</code></pre>


<h3>Format</h3>

<p>A
</p>

<dl>
<dt>ID</dt><dd><p>Unique site identifier.</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of the site.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.4718">doi:10.1002/ece3.4718</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
