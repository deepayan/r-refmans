<!DOCTYPE html><html lang="en"><head><title>Help for package bioregion</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bioregion}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betapart_to_bioregion'><p>Convert betapart dissimilarity to bioregion dissimilarity</p></a></li>
<li><a href='#bioregion_metrics'><p>Calculate contribution metrics for bioregions</p></a></li>
<li><a href='#bioregionalization_metrics'><p>Calculate metrics for one or several bioregionalizations</p></a></li>
<li><a href='#compare_bioregionalizations'><p>Compare cluster memberships among multiple bioregionalizations</p></a></li>
<li><a href='#cut_tree'><p>Cut a hierarchical tree</p></a></li>
<li><a href='#dissimilarity'><p>Compute dissimilarity metrics (beta-diversity) between sites based on</p>
species composition</a></li>
<li><a href='#dissimilarity_to_similarity'><p>Convert dissimilarity metrics to similarity metrics</p></a></li>
<li><a href='#find_optimal_n'><p>Search for an optimal number of clusters in a list of bioregionalizations</p></a></li>
<li><a href='#fishdf'><p>Spatial distribution of fish in Europe (data.frame)</p></a></li>
<li><a href='#fishmat'><p>Spatial distribution of fish in Europe (co-occurrence matrix)</p></a></li>
<li><a href='#fishsf'><p>Spatial distribution of fish in Europe</p></a></li>
<li><a href='#hclu_diana'><p>Divisive hierarchical clustering based on dissimilarity or beta-diversity</p></a></li>
<li><a href='#hclu_hierarclust'><p>Hierarchical clustering based on dissimilarity or beta-diversity</p></a></li>
<li><a href='#hclu_optics'><p>OPTICS hierarchical clustering algorithm</p></a></li>
<li><a href='#install_binaries'><p>Download, unzip, check permissions, and test the bioregion's binary files</p></a></li>
<li><a href='#map_bioregions'><p>Create a map of bioregions</p></a></li>
<li><a href='#mat_to_net'><p>Create a data.frame from a contingency table</p></a></li>
<li><a href='#net_to_mat'><p>Create a contingency table from a data.frame</p></a></li>
<li><a href='#netclu_beckett'><p>Community structure detection in weighted bipartite networks via modularity</p>
optimization</a></li>
<li><a href='#netclu_greedy'><p>Community structure detection via greedy optimization of modularity</p></a></li>
<li><a href='#netclu_infomap'><p>Infomap community finding</p></a></li>
<li><a href='#netclu_labelprop'><p>Finding communities based on propagating labels</p></a></li>
<li><a href='#netclu_leadingeigen'><p>Finding communities based on the leading eigenvector of the community matrix</p></a></li>
<li><a href='#netclu_leiden'><p>Finding communities using the Leiden algorithm</p></a></li>
<li><a href='#netclu_louvain'><p>Louvain community finding</p></a></li>
<li><a href='#netclu_oslom'><p>OSLOM community finding</p></a></li>
<li><a href='#netclu_walktrap'><p>Community structure detection via short random walks</p></a></li>
<li><a href='#nhclu_affprop'><p>Non-hierarchical clustering: Affinity Propagation</p></a></li>
<li><a href='#nhclu_clara'><p>Non-hierarchical clustering: CLARA</p></a></li>
<li><a href='#nhclu_clarans'><p>Non-hierarchical clustering: CLARANS</p></a></li>
<li><a href='#nhclu_dbscan'><p>Non-hierarchical clustering: DBSCAN</p></a></li>
<li><a href='#nhclu_kmeans'><p>Non-hierarchical clustering: K-means analysis</p></a></li>
<li><a href='#nhclu_pam'><p>Non-hierarchical clustering: Partitioning Around Medoids</p></a></li>
<li><a href='#similarity'><p>Compute similarity metrics between sites based on species composition</p></a></li>
<li><a href='#similarity_to_dissimilarity'><p>Convert similarity metrics to dissimilarity metrics</p></a></li>
<li><a href='#site_species_metrics'><p>Calculate contribution metrics of sites and species</p></a></li>
<li><a href='#site_species_subset'><p>Extract a subset of sites or species from a <code>bioregion.clusters</code> object</p></a></li>
<li><a href='#vegedf'><p>Spatial distribution of Mediterranean vegetation (data.frame)</p></a></li>
<li><a href='#vegemat'><p>Spatial distribution of Mediterranean vegetation (co-occurrence matrix)</p></a></li>
<li><a href='#vegesf'><p>Spatial distribution of Mediterranean vegetation (spatial grid)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Comparison of Bioregionalisation Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The main purpose of this package is to propose a transparent methodological framework to compare bioregionalisation methods based on hierarchical and non-hierarchical clustering algorithms (Kreft &amp; Jetz (2010) &lt;<a href="https://doi.org/10.1111%2Fj.1365-2699.2010.02375.x">doi:10.1111/j.1365-2699.2010.02375.x</a>&gt;) and network algorithms (Lenormand et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fece3.4718">doi:10.1002/ece3.4718</a>&gt; and Leroy et al. (2019) &lt;<a href="https://doi.org/10.1111%2Fjbi.13674">doi:10.1111/jbi.13674</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, apcluster, bipartite, cluster, data.table, dbscan,
dynamicTreeCut, fastcluster, fastkmedoids, ggplot2, grDevices,
httr, igraph, mathjaxr, Matrix, phangorn, Rdpack, rlang,
rmarkdown, segmented, sf, stats, tidyr, utils</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr, Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ade4, dplyr, knitr, microbenchmark, rnaturalearth,
rnaturalearthdata, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bioRgeo/bioregion">https://github.com/bioRgeo/bioregion</a>,
<a href="https://bioRgeo.github.io/bioregion/">https://bioRgeo.github.io/bioregion/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bioRgeo/bioregion/issues">https://github.com/bioRgeo/bioregion/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-31 15:50:27 UTC; maxime</td>
</tr>
<tr>
<td>Author:</td>
<td>Maxime Lenormand <a href="https://orcid.org/0000-0001-6362-3473"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Boris Leroy <a href="https://orcid.org/0000-0002-7686-4302"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Pierre Denelle <a href="https://orcid.org/0000-0001-5037-2281"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maxime Lenormand &lt;maxime.lenormand@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-31 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='betapart_to_bioregion'>Convert betapart dissimilarity to bioregion dissimilarity</h2><span id='topic+betapart_to_bioregion'></span>

<h3>Description</h3>

<p>This function converts dissimilarity results produced by the betapart package
(and packages using betapart, such as phyloregion) into a dissimilarity
object compatible with the bioregion package. This function only converts
object types to make them compatible with bioregion; it does not modify the
beta-diversity values. This function allows the inclusion of phylogenetic
beta diversity to compute bioregions with bioregion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betapart_to_bioregion(betapart_result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="betapart_to_bioregion_+3A_betapart_result">betapart_result</code></td>
<td>
<p>An object produced by the betapart package (e.g.,
using the <code>beta.pair</code> function).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dissimilarity object of class <code>bioregion.pairwise.metric</code>,
compatible with the bioregion package.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

## Not run: 
beta_div &lt;- betapart::beta.pair.abund(comat)
betapart_to_bioregion(beta_div)

## End(Not run)
</code></pre>

<hr>
<h2 id='bioregion_metrics'>Calculate contribution metrics for bioregions</h2><span id='topic+bioregion_metrics'></span>

<h3>Description</h3>

<p>This function calculates the number of sites per bioregion, as well as the
number of species these sites have, the number of endemic species, and the
proportion of endemism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bioregion_metrics(bioregionalization, comat, map = NULL, col_bioregion = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bioregion_metrics_+3A_bioregionalization">bioregionalization</code></td>
<td>
<p>A <code>bioregion.clusters</code> object.</p>
</td></tr>
<tr><td><code id="bioregion_metrics_+3A_comat">comat</code></td>
<td>
<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns.</p>
</td></tr>
<tr><td><code id="bioregion_metrics_+3A_map">map</code></td>
<td>
<p>A spatial <code style="white-space: pre;">&#8288;sf data.frame&#8288;</code> with sites and bioregions. It is the
output of the function <code>map_bioregions</code>. <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="bioregion_metrics_+3A_col_bioregion">col_bioregion</code></td>
<td>
<p>An <code>integer</code> specifying the column position of the
bioregion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Endemic species are species found only in the sites belonging to one
bioregion.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with 5 columns, or 6 if spatial coherence is computed.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a5_3_summary_metrics.html">https://biorgeo.github.io/bioregion/articles/a5_3_summary_metrics.html</a>.
</p>
<p>Associated functions:
<a href="#topic+site_species_metrics">site_species_metrics</a> <a href="#topic+bioregionalization_metrics">bioregionalization_metrics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
clust &lt;- netclu_louvain(net)

bioregion_metrics(bioregionalization = clust, 
                  comat = comat) 

</code></pre>

<hr>
<h2 id='bioregionalization_metrics'>Calculate metrics for one or several bioregionalizations</h2><span id='topic+bioregionalization_metrics'></span>

<h3>Description</h3>

<p>This function calculates metrics for one or several bioregionalizations,
typically based on outputs from <code>netclu_</code>, <code>hclu_</code>, or <code>nhclu_</code> functions.
Some metrics may require users to provide either a similarity or dissimilarity
matrix, or the initial species-site table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bioregionalization_metrics(
  bioregionalization,
  dissimilarity = NULL,
  dissimilarity_index = NULL,
  net = NULL,
  site_col = 1,
  species_col = 2,
  eval_metric = "all"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bioregionalization_metrics_+3A_bioregionalization">bioregionalization</code></td>
<td>
<p>A <code>bioregion.clusters</code> object.</p>
</td></tr>
<tr><td><code id="bioregionalization_metrics_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>A <code>dist</code> object or a <code>bioregion.pairwise.metric</code>
object (output from <code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>). Required if
<code>eval_metric</code> includes <code>"pc_distance"</code> and <code>tree</code> is not a
<code>bioregion.hierar.tree</code> object.</p>
</td></tr>
<tr><td><code id="bioregionalization_metrics_+3A_dissimilarity_index">dissimilarity_index</code></td>
<td>
<p>A <code>character</code> string indicating the dissimilarity
(beta-diversity) index to use if dissimilarity is a <code>data.frame</code> with
multiple dissimilarity indices.</p>
</td></tr>
<tr><td><code id="bioregionalization_metrics_+3A_net">net</code></td>
<td>
<p>The site-species network (i.e., bipartite network). Should be
provided as a <code>data.frame</code> if <code>eval_metric</code> includes <code>"avg_endemism"</code> or
<code>"tot_endemism"</code>.</p>
</td></tr>
<tr><td><code id="bioregionalization_metrics_+3A_site_col">site_col</code></td>
<td>
<p>The name or index of the column representing site nodes
(i.e., primary nodes). Should be provided if <code>eval_metric</code> includes
<code>"avg_endemism"</code> or <code>"tot_endemism"</code>.</p>
</td></tr>
<tr><td><code id="bioregionalization_metrics_+3A_species_col">species_col</code></td>
<td>
<p>The name or index of the column representing species nodes
(i.e., feature nodes). Should be provided if <code>eval_metric</code> includes
<code>"avg_endemism"</code> or <code>"tot_endemism"</code>.</p>
</td></tr>
<tr><td><code id="bioregionalization_metrics_+3A_eval_metric">eval_metric</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string
indicating the metric(s) to be calculated to assess the effect of different
numbers of clusters. Available options are <code>"pc_distance"</code>, <code>"anosim"</code>,
<code>"avg_endemism"</code>, or <code>"tot_endemism"</code>. If <code>"all"</code> is specified, all metrics
will be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Evaluation metrics:</strong>
</p>

<ul>
<li><p><code>pc_distance</code>: This metric, as used by Holt et al. (2013), is the
ratio of the between-cluster sum of dissimilarities (beta-diversity) to the
total sum of dissimilarities for the full dissimilarity matrix. It is calculated
in two steps:
</p>

<ul>
<li><p> Compute the total sum of dissimilarities by summing all elements of the
dissimilarity matrix.
</p>
</li>
<li><p> Compute the between-cluster sum of dissimilarities by setting within-cluster
dissimilarities to zero and summing the matrix.
The <code>pc_distance</code> ratio is obtained by dividing the between-cluster sum of
dissimilarities by the total sum of dissimilarities.</p>
</li></ul>


</li>
<li><p><code>anosim</code>: This metric is the statistic used in the Analysis of
Similarities, as described in Castro-Insua et al. (2018). It compares
between-cluster and within-cluster dissimilarities. The statistic is computed as:
R = (r_B - r_W) / (N (N-1) / 4),
where r_B and r_W are the average ranks of between-cluster and within-cluster
dissimilarities, respectively, and N is the total number of sites.
Note: This function does not estimate significance; for significance testing,
use <a href="vegan.html#topic+anosim">vegan::anosim()</a>.
</p>
</li>
<li><p><code>avg_endemism</code>: This metric is the average percentage of
endemism in clusters, as recommended by Kreft &amp; Jetz (2010). It is calculated as:
End_mean = sum_i (E_i / S_i) / K,
where E_i is the number of endemic species in cluster i, S_i is the number of
species in cluster i, and K is the total number of clusters.
</p>
</li>
<li><p><code>tot_endemism</code>: This metric is the total endemism across all clusters,
as recommended by Kreft &amp; Jetz (2010). It is calculated as:
End_tot = E / C,
where E is the total number of endemic species (i.e., species found in only one
cluster) and C is the number of non-endemic species.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.bioregionalization.metrics</code> with two to three elements:
</p>

<ul>
<li><p><code>args</code>: Input arguments.
</p>
</li>
<li><p><code>evaluation_df</code>: A <code>data.frame</code> containing the <code>eval_metric</code>
values for all explored numbers of clusters.
</p>
</li>
<li><p><code>endemism_results</code>: If endemism calculations are requested, a list
with the endemism results for each bioregionalization.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>References</h3>

<p>Castro-Insua A, Gómez-Rodríguez C &amp; Baselga A (2018) Dissimilarity measures
affected by richness differences yield biased delimitations of biogeographic
realms. <em>Nature Communications</em> 9, 9-11.
</p>
<p>Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P,
Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ,
Fjeldså J &amp; Rahbek C (2013) An update of Wallace's zoogeographic regions of
the world. <em>Science</em> 339, 74-78.
</p>
<p>Kreft H &amp; Jetz W (2010) A framework for delineating biogeographical regions
based on species distributions. <em>Journal of Biogeography</em> 37, 2029-2053.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html#optimaln">https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html#optimaln</a>.
</p>
<p>Associated functions:
<a href="#topic+compare_bioregionalizations">compare_bioregionalizations</a> <a href="#topic+find_optimal_n">find_optimal_n</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)

dissim &lt;- dissimilarity(comat, metric = "all")

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissim, 
                          n_clust = 10:15, 
                          index = "Simpson")
tree1

a &lt;- bioregionalization_metrics(tree1, 
                                dissimilarity = dissim, 
                                net = comnet,
                                site_col = "Node1", 
                                species_col = "Node2",
                                eval_metric = c("tot_endemism", 
                                                "avg_endemism",
                                                "pc_distance", 
                                                "anosim"))
a

</code></pre>

<hr>
<h2 id='compare_bioregionalizations'>Compare cluster memberships among multiple bioregionalizations</h2><span id='topic+compare_bioregionalizations'></span>

<h3>Description</h3>

<p>This function computes pairwise comparisons for several
bioregionalizations, usually outputs from <code>netclu_</code>, <code>hclu_</code>, or <code>nhclu_</code>
functions. It also provides the confusion matrix from pairwise comparisons,
enabling the user to compute additional comparison metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_bioregionalizations(
  bioregionalizations,
  indices = c("rand", "jaccard"),
  cor_frequency = FALSE,
  store_pairwise_membership = TRUE,
  store_confusion_matrix = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_bioregionalizations_+3A_bioregionalizations">bioregionalizations</code></td>
<td>
<p>A <code>data.frame</code> object where each row corresponds to
a site, and each column to a bioregionalization.</p>
</td></tr>
<tr><td><code id="compare_bioregionalizations_+3A_indices">indices</code></td>
<td>
<p><code>NULL</code> or <code>character</code>. Indices to compute for the pairwise
comparison of bioregionalizations. Currently available metrics are <code>"rand"</code>
and <code>"jaccard"</code>.</p>
</td></tr>
<tr><td><code id="compare_bioregionalizations_+3A_cor_frequency">cor_frequency</code></td>
<td>
<p>A <code>boolean</code>. If <code>TRUE</code>, computes the correlation
between each bioregionalization and the total frequency of co-membership of
items across all bioregionalizations. This is useful for identifying which
bioregionalization(s) is(are) most representative of all computed
bioregionalizations.</p>
</td></tr>
<tr><td><code id="compare_bioregionalizations_+3A_store_pairwise_membership">store_pairwise_membership</code></td>
<td>
<p>A <code>boolean</code>. If <code>TRUE</code>, stores the pairwise
membership of items in the output object.</p>
</td></tr>
<tr><td><code id="compare_bioregionalizations_+3A_store_confusion_matrix">store_confusion_matrix</code></td>
<td>
<p>A <code>boolean</code>. If <code>TRUE</code>, stores the confusion
matrices of pairwise bioregionalization comparisons in the output object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function operates in two main steps:
</p>

<ol>
<li><p> Within each bioregionalization, the function compares all pairs of items
and documents whether they are clustered together (<code>TRUE</code>) or separately
(<code>FALSE</code>). For example, if site 1 and site 2 are clustered in the same
cluster in bioregionalization 1, their pairwise membership <code>site1_site2</code>
will be <code>TRUE</code>. This output is stored in the <code>pairwise_membership</code> slot if
<code>store_pairwise_membership = TRUE</code>.
</p>
</li>
<li><p> Across all bioregionalizations, the function compares their pairwise
memberships to determine similarity. For each pair of bioregionalizations,
it computes a confusion matrix with the following elements:
</p>
</li></ol>


<ul>
<li> <p><code>a</code>: Number of item pairs grouped in both bioregionalizations.
</p>
</li>
<li> <p><code>b</code>: Number of item pairs grouped in the first but not in the second
bioregionalization.
</p>
</li>
<li> <p><code>c</code>: Number of item pairs grouped in the second but not in the first
bioregionalization.
</p>
</li>
<li> <p><code>d</code>: Number of item pairs not grouped in either bioregionalization.
</p>
</li></ul>

<p>The confusion matrix is stored in <code>confusion_matrix</code> if
<code>store_confusion_matrix = TRUE</code>.
</p>
<p>Based on these confusion matrices, various indices can be computed to
measure agreement among bioregionalizations. The currently implemented
indices are:
</p>

<ul>
<li> <p><strong>Rand index</strong>: <code>(a + d) / (a + b + c + d)</code>
Measures agreement by considering both grouped and ungrouped item pairs.
</p>
</li>
<li> <p><strong>Jaccard index</strong>: <code>a / (a + b + c)</code>
Measures agreement based only on grouped item pairs.
</p>
</li></ul>

<p>These indices are complementary: the Jaccard index evaluates clustering
similarity, while the Rand index considers both clustering and separation.
For example, if two bioregionalizations never group the same pairs, their
Jaccard index will be 0, but their Rand index may be &gt; 0 due to ungrouped
pairs.
</p>
<p>Users can compute additional indices manually using the list of confusion
matrices.
</p>
<p>To identify which bioregionalization is most representative of the others,
the function can compute the correlation between the pairwise membership of
each bioregionalization and the total frequency of pairwise membership across
all bioregionalizations. This is enabled by setting <code>cor_frequency = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing 4 to 7 elements:
</p>

<ol>
<li><p><strong>args</strong>: A <code>list</code> of user-provided arguments.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> containing information on the input
bioregionalizations, such as the number of items clustered.
</p>
</li>
<li><p><strong>pairwise_membership</strong> (optional): If <code>store_pairwise_membership = TRUE</code>,
a <code style="white-space: pre;">&#8288;boolean matrix&#8288;</code> where <code>TRUE</code> indicates two items are in the same cluster,
and <code>FALSE</code> indicates they are not.
</p>
</li>
<li><p><strong>freq_item_pw_membership</strong>: A <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> containing the number of
times each item pair is clustered together, corresponding to the sum of rows
in <code>pairwise_membership</code>.
</p>
</li>
<li><p><strong>bioregionalization_freq_cor</strong> (optional): If <code>cor_frequency = TRUE</code>,
a <code style="white-space: pre;">&#8288;numeric vector&#8288;</code> of correlations between individual bioregionalizations
and the total frequency of pairwise membership.
</p>
</li>
<li><p><strong>confusion_matrix</strong> (optional): If <code>store_confusion_matrix = TRUE</code>,
a <code>list</code> of confusion matrices for each pair of bioregionalizations.
</p>
</li>
<li><p><strong>bioregionalization_comparison</strong>: A <code>data.frame</code> containing comparison
results, where the first column indicates the bioregionalizations compared,
and the remaining columns contain the requested <code>indices</code>.</p>
</li></ol>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html">https://biorgeo.github.io/bioregion/articles/a5_2_compare_bioregionalizations.html</a>.
</p>
<p>Associated functions:
<a href="#topic+bioregionalization_metrics">bioregionalization_metrics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We here compare three different bioregionalizations
comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "Simpson")
bioregion1 &lt;- nhclu_kmeans(dissim, n_clust = 3, index = "Simpson")

net &lt;- similarity(comat, metric = "Simpson")
bioregion2 &lt;- netclu_greedy(net)
bioregion3 &lt;- netclu_walktrap(net)

# Make one single data.frame with the bioregionalizations to compare
compare_df &lt;- merge(bioregion1$clusters, bioregion2$clusters, by = "ID")
compare_df &lt;- merge(compare_df, bioregion3$clusters, by = "ID")
colnames(compare_df) &lt;- c("Site", "Hclu", "Greedy", "Walktrap")
rownames(compare_df) &lt;- compare_df$Site
compare_df &lt;- compare_df[, c("Hclu", "Greedy", "Walktrap")]

# Running the function
compare_bioregionalizations(compare_df)

# Find out which bioregionalizations are most representative
compare_bioregionalizations(compare_df,
                            cor_frequency = TRUE)
                                
</code></pre>

<hr>
<h2 id='cut_tree'>Cut a hierarchical tree</h2><span id='topic+cut_tree'></span>

<h3>Description</h3>

<p>This function is designed to work on a hierarchical tree and cut it
at user-selected heights. It works with outputs from either
<code>hclu_hierarclust</code> or <code>hclust</code> objects. The function allows for cutting
the tree based on the chosen number(s) of clusters or specified height(s).
Additionally, it includes a procedure to automatically determine the cutting
height for the requested number(s) of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_tree(
  tree,
  n_clust = NULL,
  cut_height = NULL,
  find_h = TRUE,
  h_max = 1,
  h_min = 0,
  dynamic_tree_cut = FALSE,
  dynamic_method = "tree",
  dynamic_minClusterSize = 5,
  dissimilarity = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_tree_+3A_tree">tree</code></td>
<td>
<p>A <code>bioregion.hierar.tree</code> or an <code>hclust</code> object.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> indicating the
number of clusters to be obtained from the hierarchical tree, or the output
from <code><a href="#topic+bioregionalization_metrics">bioregionalization_metrics()</a></code>. This should not be used concurrently
with <code>cut_height</code>.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_cut_height">cut_height</code></td>
<td>
<p>A <code>numeric</code> vector specifying the height(s) at which the
tree should be cut. This should not be used concurrently with <code>n_clust</code> or
<code>optim_method</code>.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_find_h">find_h</code></td>
<td>
<p>A <code>boolean</code> indicating whether the cutting height should be
determined for the requested <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_h_max">h_max</code></td>
<td>
<p>A <code>numeric</code> value indicating the maximum possible tree height
for determining the cutting height when <code>find_h = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_h_min">h_min</code></td>
<td>
<p>A <code>numeric</code> value specifying the minimum possible height in the
tree for determining the cutting height when <code>find_h = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dynamic_tree_cut">dynamic_tree_cut</code></td>
<td>
<p>A <code>boolean</code> indicating whether the dynamic tree cut
method should be used. If <code>TRUE</code>, <code>n_clust</code> and <code>cut_height</code> are ignored.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dynamic_method">dynamic_method</code></td>
<td>
<p>A <code>character</code> string specifying the method to be used
for dynamically cutting the tree: either <code>"tree"</code> (clusters searched only
within the tree) or <code>"hybrid"</code> (clusters searched in both the tree and the
dissimilarity matrix).</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dynamic_minclustersize">dynamic_minClusterSize</code></td>
<td>
<p>An <code>integer</code> indicating the minimum cluster
size for the dynamic tree cut method (see
<a href="dynamicTreeCut.html#topic+cutreeDynamic">dynamicTreeCut::cutreeDynamic()</a>).</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>Relevant only if <code>dynamic_method = "hybrid"</code>. Provide
the dissimilarity <code>data.frame</code> used to build the <code>tree</code>.</p>
</td></tr>
<tr><td><code id="cut_tree_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<a href="dynamicTreeCut.html#topic+cutreeDynamic">dynamicTreeCut::cutreeDynamic()</a> to
customize the dynamic tree cut method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function supports two main methods for cutting the tree. First, the tree
can be cut at a uniform height (specified by <code>cut_height</code> or determined
automatically for the requested <code>n_clust</code>). Second, the dynamic tree cut
method (Langfelder et al., 2008) can be applied, which adapts to the shape
of branches in the tree, cutting at varying heights based on cluster
positions.
</p>
<p>The dynamic tree cut method has two variants:
</p>

<ul>
<li><p>The tree-based variant (<code>dynamic_method = "tree"</code>) uses a top-down
approach, relying solely on the tree and the order of clustered objects.
</p>
</li>
<li><p>The hybrid variant (<code>dynamic_method = "hybrid"</code>) employs a bottom-up
approach, leveraging both the tree and the dissimilarity matrix to identify
clusters based on dissimilarity among sites. This approach is useful for
detecting outliers within clusters.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>tree</code> is an output from <code><a href="#topic+hclu_hierarclust">hclu_hierarclust()</a></code>, the same
object is returned with updated content (i.e., <code>args</code> and <code>clusters</code>). If
<code>tree</code> is an <code>hclust</code> object, a <code>data.frame</code> containing the clusters is
returned.
</p>


<h3>Note</h3>

<p>The <code>find_h</code> argument is ignored if <code>dynamic_tree_cut = TRUE</code>,
as cutting heights cannot be determined in this case.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Langfelder P, Zhang B &amp; Horvath S (2008) Defining clusters from a
hierarchical cluster tree: the Dynamic Tree Cut package for R.
<em>BIOINFORMATICS</em> 24, 719-720.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+hclu_hierarclust">hclu_hierarclust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site", 1:20)
colnames(comat) &lt;- paste0("Species", 1:25)

simil &lt;- similarity(comat, metric = "all")
dissimilarity &lt;- similarity_to_dissimilarity(simil)

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissimilarity,
                          n_clust = 5)
tree2 &lt;- cut_tree(tree1, cut_height = .05)
tree3 &lt;- cut_tree(tree1, n_clust = c(3, 5, 10))
tree4 &lt;- cut_tree(tree1, cut_height = c(.05, .1, .15, .2, .25))
tree5 &lt;- cut_tree(tree1, n_clust = c(3, 5, 10), find_h = FALSE)

hclust_tree &lt;- tree2$algorithm$final.tree
clusters_2 &lt;- cut_tree(hclust_tree, n_clust = 10)

cluster_dynamic &lt;- cut_tree(tree1, dynamic_tree_cut = TRUE,
                            dissimilarity = dissimilarity)

</code></pre>

<hr>
<h2 id='dissimilarity'>Compute dissimilarity metrics (beta-diversity) between sites based on
species composition</h2><span id='topic+dissimilarity'></span>

<h3>Description</h3>

<p>This function generates a <code>data.frame</code> where each row provides one or
several dissimilarity metrics between pairs of sites, based on a
co-occurrence <code>matrix</code> with sites as rows and species as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity(comat, metric = "Simpson", formula = NULL, method = "prodmat")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissimilarity_+3A_comat">comat</code></td>
<td>
<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_metric">metric</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string specifying
the metrics to compute (see Details). Available options are <code>"abc"</code>, <code>"ABC"</code>,
<code>"Jaccard"</code>, <code>"Jaccardturn"</code>, <code>"Sorensen"</code>, <code>"Simpson"</code>, <code>"Bray"</code>,
<code>"Brayturn"</code>, and <code>"Euclidean"</code>. If <code>"all"</code> is specified, all metrics will
be calculated. Can be set to <code>NULL</code> if <code>formula</code> is used.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_formula">formula</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string specifying
custom formula(s) based on the <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code> quantities
(see Details). The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_method">method</code></td>
<td>
<p>A <code>character</code> string specifying the method to compute <code>abc</code>
(see Details). The default is <code>"prodmat"</code>, which is more efficient but
memory-intensive. Alternatively, <code>"loops"</code> is less memory-intensive but
slower.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>a</code> the number of species shared by a pair of sites, <code>b</code> species only
present in the first site  and <code>c</code> species only present in the second site.
</p>
<p>Jaccard = (b + c) / (a + b + c)
</p>
<p>Jaccardturn = 2min(b, c) / (a + 2min(b, c)) (Baselga, 2012)
</p>
<p>Sorensen = (b + c) / (2a + b + c)
</p>
<p>Simpson = min(b, c) / (a + min(b, c))
</p>
<p>If abundances data are available, Bray-Curtis and its turnover component
can also be computed with the following equation:
</p>
<p>Bray = (B + C) / (2A + B + C)
</p>
<p>Brayturn = min(B, C)/(A + min(B, C)) (Baselga, 2013)
</p>
<p>with <code>A</code> the sum of the lesser values for common species shared by a pair of
sites. <code>B</code> and <code>C</code> are the total number of specimens counted at both sites
minus <code>A</code>.
</p>
<p><code>formula</code> can be used to compute customized metrics with the terms
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code>. For example
<code>formula = c("pmin(b,c) / (a + pmin(b,c))", "(B + C) / (2*A + B + C)")</code>
will compute the Simpson and Bray-Curtis dissimilarity metrics, respectively.
Note that <code>pmin</code> is used in the Simpson formula because <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>,
<code>B</code> and <code>C</code> are <code>numeric</code> vectors.
</p>
<p>Euclidean computes the Euclidean distance between each pair of sites.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the additional class
<code>bioregion.pairwise.metric</code>, containing one or several dissimilarity
metrics between pairs of sites. The first two columns represent the pairs of
sites. There is one column per similarity metric provided in <code>metric</code> and
<code>formula</code>, except for the <code>abc</code> and <code>ABC</code> metrics, which are stored in three
separate columns (one for each letter).
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Baselga, A. (2012) The Relationship between Species Replacement,
Dissimilarity Derived from Nestedness, and Nestedness.
<em>Global Ecology and Biogeography</em>, 21(12), 1223&ndash;1232.
</p>
<p>Baselga, A. (2013) Separating the two components of abundance-based
dissimilarity: balanced changes in abundance vs. abundance gradients.
<em>Methods in Ecology and Evolution</em>, 4(6), 552&ndash;557.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html">https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html</a>.
</p>
<p>Associated functions:
<a href="#topic+similarity">similarity</a> <a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

dissim &lt;- dissimilarity(comat,
metric = c("abc", "ABC", "Simpson", "Brayturn"))

dissim &lt;- dissimilarity(comat, metric = "all",
formula = "1 - (b + c) / (a + b + c)")

</code></pre>

<hr>
<h2 id='dissimilarity_to_similarity'>Convert dissimilarity metrics to similarity metrics</h2><span id='topic+dissimilarity_to_similarity'></span>

<h3>Description</h3>

<p>This function converts a <code>data.frame</code> of dissimilarity metrics
(beta diversity) between sites into similarity metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity_to_similarity(dissimilarity, include_formula = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissimilarity_to_similarity_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>the output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>.</p>
</td></tr>
<tr><td><code id="dissimilarity_to_similarity_+3A_include_formula">include_formula</code></td>
<td>
<p>a <code>boolean</code> indicating whether metrics based on custom
formula(s) should also be converted (see Details). The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the additional class
<code>bioregion.pairwise.metric</code>, providing similarity metrics for each pair of
sites based on a dissimilarity object.
</p>


<h3>Note</h3>

<p>The behavior of this function changes depending on column names. Columns
<code>Site1</code> and <code>Site2</code> are copied identically. If there are columns called
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, <code>C</code> they will also be copied identically. If there
are columns based on your own formula (argument <code>formula</code> in
<code><a href="#topic+dissimilarity">dissimilarity()</a></code>) or not in the original list of dissimilarity metrics
(argument <code>metrics</code> in <code><a href="#topic+dissimilarity">dissimilarity()</a></code>) and if the argument
<code>include_formula</code> is set to <code>FALSE</code>, they will also be copied identically.
Otherwise there are going to be converted like they other columns (default
behavior).
</p>
<p>If a column is called <code>Euclidean</code>, the similarity will be calculated based
on the following formula:
</p>
<p>Euclidean similarity = 1 / (1 - Euclidean distance)
</p>
<p>Otherwise, all other columns will be transformed into dissimilarity with the
following formula:
</p>
<p>similarity = 1 - dissimilarity
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html">https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html</a>.
</p>
<p>Associated functions:
<a href="#topic+similarity">similarity</a> <a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

dissimil &lt;- dissimilarity(comat, metric = "all")
dissimil

similarity &lt;- dissimilarity_to_similarity(dissimil)
similarity

</code></pre>

<hr>
<h2 id='find_optimal_n'>Search for an optimal number of clusters in a list of bioregionalizations</h2><span id='topic+find_optimal_n'></span>

<h3>Description</h3>

<p>This function aims to optimize one or several criteria on a set of
ordered bioregionalizations. It is typically used to find one or more optimal
cluster counts on hierarchical trees to cut or ranges of bioregionalizations
from k-means or PAM. Users should exercise caution in other cases
(e.g., unordered bioregionalizations or unrelated bioregionalizations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_optimal_n(
  bioregionalizations,
  metrics_to_use = "all",
  criterion = "elbow",
  step_quantile = 0.99,
  step_levels = NULL,
  step_round_above = TRUE,
  metric_cutoffs = c(0.5, 0.75, 0.9, 0.95, 0.99, 0.999),
  n_breakpoints = 1,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_optimal_n_+3A_bioregionalizations">bioregionalizations</code></td>
<td>
<p>A <code>bioregion.bioregionalization.metrics</code> object
(output from
<code><a href="#topic+bioregionalization_metrics">bioregionalization_metrics()</a></code>) or a <code>data.frame</code> with the first two
columns named <code>K</code> (bioregionalization name) and <code>n_clusters</code> (number of clusters),
followed by columns with numeric evaluation metrics.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_metrics_to_use">metrics_to_use</code></td>
<td>
<p>A <code>character</code> vector or single string specifying
metrics in <code>bioregionalizations</code> for calculating optimal clusters. Defaults
to <code>"all"</code> (uses all metrics).</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_criterion">criterion</code></td>
<td>
<p>A <code>character</code> string specifying the criterion to identify
optimal clusters. Options include <code>"elbow"</code>, <code>"increasing_step"</code>,
<code>"decreasing_step"</code>, <code>"cutoff"</code>, <code>"breakpoints"</code>, <code>"min"</code>, or <code>"max"</code>.
Defaults to <code>"elbow"</code>. See Details.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_step_quantile">step_quantile</code></td>
<td>
<p>For <code>"increasing_step"</code> or <code>"decreasing_step"</code>,
specifies the quantile of differences between consecutive bioregionalizations as
the cutoff to identify significant steps in <code>eval_metric</code>.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_step_levels">step_levels</code></td>
<td>
<p>For <code>"increasing_step"</code> or <code>"decreasing_step"</code>, specifies
the number of largest steps to retain as cutoffs.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_step_round_above">step_round_above</code></td>
<td>
<p>A <code>boolean</code> indicating whether the optimal clusters
are above (<code>TRUE</code>) or below (<code>FALSE</code>) identified steps. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_metric_cutoffs">metric_cutoffs</code></td>
<td>
<p>For <code>criterion = "cutoff"</code>, specifies the cutoffs
of <code>eval_metric</code> to extract cluster counts.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_n_breakpoints">n_breakpoints</code></td>
<td>
<p>Specifies the number of breakpoints to find in the
curve. Defaults to 1.</p>
</td></tr>
<tr><td><code id="find_optimal_n_+3A_plot">plot</code></td>
<td>
<p>A <code>boolean</code> indicating if a plot of the first <code>eval_metric</code>
with identified optimal clusters should be drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function explores evaluation metric ~ cluster relationships, applying
criteria to find optimal cluster counts.
</p>
<p><strong>Note on criteria:</strong> Several criteria can return multiple optimal cluster
counts, emphasizing hierarchical or nested bioregionalizations. This
approach aligns with modern recommendations for biological datasets, as seen
in Ficetola et al. (2017)'s reanalysis of Holt et al. (2013).
</p>
<p><strong>Criteria for optimal clusters:</strong>
</p>

<ul>
<li><p><code>elbow</code>: Identifies the &quot;elbow&quot; point in the evaluation metric curve,
where incremental improvements diminish. Based on a method to find the
maximum distance from a straight line linking curve endpoints.
</p>
</li>
<li><p><code>increasing_step</code> or <code>decreasing_step</code>: Highlights significant
increases or decreases in metrics by analyzing pairwise differences between
bioregionalizations. Users specify <code>step_quantile</code> or <code>step_levels</code>.
</p>
</li>
<li><p><code>cutoffs</code>: Derives clusters from specified metric cutoffs, e.g., as in
Holt et al. (2013). Adjust cutoffs based on spatial scale.
</p>
</li>
<li><p><code>breakpoints</code>: Uses segmented regression to find breakpoints. Requires
specifying <code>n_breakpoints</code>.
</p>
</li>
<li><p><code>min</code> &amp; <code>max</code>: Selects clusters at minimum or maximum metric values.</p>
</li></ul>



<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.optimal.n</code> with these elements:
</p>

<ul>
<li><p><code>args</code>: Input arguments.
</p>
</li>
<li><p><code>evaluation_df</code>: The input evaluation <code>data.frame</code>, appended with
<code>boolean</code> columns for optimal cluster counts.
</p>
</li>
<li><p><code>optimal_nb_clusters</code>: A <code>list</code> with optimal cluster counts for each
metric in <code>"metrics_to_use"</code>, based on the chosen <code>criterion</code>.
</p>
</li>
<li><p><code>plot</code>: The plot (if requested).</p>
</li></ul>



<h3>Note</h3>

<p>Please note that finding the optimal number of clusters is a procedure
which normally requires decisions from the users, and as such can hardly be
fully automatized. Users are strongly advised to read the references
indicated below to look for guidance on how to choose their optimal
number(s) of clusters. Consider the &quot;optimal&quot; numbers of clusters returned
by this function as first approximation of the best numbers for your
bioregionalization.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>References</h3>

<p>Holt BG, Lessard J, Borregaard MK, Fritz SA, Araújo MB, Dimitrov D, Fabre P,
Graham CH, Graves GR, Jønsson Ka, Nogués-Bravo D, Wang Z, Whittaker RJ,
Fjeldså J &amp; Rahbek C (2013) An update of Wallace's zoogeographic regions of
the world. <em>Science</em> 339, 74-78.
</p>
<p>Ficetola GF, Mazel F &amp; Thuiller W (2017) Global determinants of
zoogeographical boundaries. <em>Nature Ecology &amp; Evolution</em> 1, 0089.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html#optimaln">https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html#optimaln</a>.
</p>
<p>Associated functions:
<a href="#topic+hclu_hierarclust">hclu_hierarclust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

# User-defined number of clusters
tree &lt;- hclu_hierarclust(dissim,
                          optimal_tree_method = "best",
                          n_clust = 5:10)
tree

a &lt;- bioregionalization_metrics(tree,
                                dissimilarity = dissim,
                                species_col = "Node2",
                                site_col = "Node1",
                                eval_metric = "anosim")
                                   
find_optimal_n(a, criterion = 'increasing_step', plot = FALSE)

</code></pre>

<hr>
<h2 id='fishdf'>Spatial distribution of fish in Europe (data.frame)</h2><span id='topic+fishdf'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 195 species in 338 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishdf
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2,703 rows and 3 columns:
</p>

<dl>
<dt>Site</dt><dd><p>Unique site identifier (corresponding to the field ID of fishsf)</p>
</dd>
<dt>Species</dt><dd><p>Unique species identifier</p>
</dd>
<dt>Abundance</dt><dd><p>Species abundance</p>
</dd>
</dl>


<hr>
<h2 id='fishmat'>Spatial distribution of fish in Europe (co-occurrence matrix)</h2><span id='topic+fishmat'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of each of the 195 species in each of
the 338 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishmat
</code></pre>


<h3>Format</h3>

<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns. Each element of the matrix
represents the abundance of the species in the site.
</p>

<hr>
<h2 id='fishsf'>Spatial distribution of fish in Europe</h2><span id='topic+fishsf'></span>

<h3>Description</h3>

<p>A dataset containing the geometry of the 338 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishsf
</code></pre>


<h3>Format</h3>

<p>A
</p>

<dl>
<dt>ID</dt><dd><p>Unique site identifier</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of the site</p>
</dd>
</dl>


<hr>
<h2 id='hclu_diana'>Divisive hierarchical clustering based on dissimilarity or beta-diversity</h2><span id='topic+hclu_diana'></span>

<h3>Description</h3>

<p>This function computes a divisive hierarchical clustering from a
dissimilarity (beta-diversity) <code>data.frame</code>, calculates the cophenetic
correlation coefficient, and can generate clusters from the tree if requested
by the user. The function implements randomization of the dissimilarity matrix
to generate the tree, with a selection method based on the optimal cophenetic
correlation coefficient. Typically, the dissimilarity <code>data.frame</code> is a
<code>bioregion.pairwise.metric</code> object obtained by running <code>similarity</code>
or <code>similarity</code> followed by <code>similarity_to_dissimilarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclu_diana(
  dissimilarity,
  index = names(dissimilarity)[3],
  n_clust = NULL,
  cut_height = NULL,
  find_h = TRUE,
  h_max = 1,
  h_min = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclu_diana_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object.
If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the remaining
column(s) contain the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By default,
the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> indicating the
number of clusters to be obtained from the hierarchical tree, or the output
from <a href="#topic+bioregionalization_metrics">bioregionalization_metrics</a>. Should not be used concurrently with
<code>cut_height</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_cut_height">cut_height</code></td>
<td>
<p>A <code>numeric</code> vector indicating the height(s) at which the
tree should be cut. Should not be used concurrently with <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_find_h">find_h</code></td>
<td>
<p>A <code>boolean</code> indicating whether the cutting height should be
determined for the requested <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_h_max">h_max</code></td>
<td>
<p>A <code>numeric</code> value indicating the maximum possible tree height
for the chosen <code>index</code>.</p>
</td></tr>
<tr><td><code id="hclu_diana_+3A_h_min">h_min</code></td>
<td>
<p>A <code>numeric</code> value indicating the minimum possible height in the
tree for the chosen <code>index</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on <a href="cluster.html#topic+diana">diana</a>.
Chapter 6 of Kaufman &amp; Rousseeuw (1990) fully details the functioning of
the diana algorithm.
</p>
<p>To find an optimal number of clusters, see <code><a href="#topic+bioregionalization_metrics">bioregionalization_metrics()</a></code>
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> describing the characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> containing all objects associated with the
clustering procedure, such as the original cluster objects.
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>



<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kaufman L &amp; Rousseeuw PJ (2009) Finding groups in data: An introduction to
cluster analysis. In &amp; Sons. JW (ed.), <em>Finding groups in data: An
introduction to cluster analysis</em>.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+cut_tree">cut_tree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

data("fishmat")
fishdissim &lt;- dissimilarity(fishmat)
fish_diana &lt;- hclu_diana(fishdissim, index = "Simpson")


</code></pre>

<hr>
<h2 id='hclu_hierarclust'>Hierarchical clustering based on dissimilarity or beta-diversity</h2><span id='topic+hclu_hierarclust'></span>

<h3>Description</h3>

<p>This function generates a hierarchical tree from a dissimilarity
(beta-diversity) <code>data.frame</code>, calculates the cophenetic correlation
coefficient, and optionally retrieves clusters from the tree upon user
request. The function includes a randomization process for the dissimilarity
matrix to generate the tree, with two methods available for constructing the
final tree. Typically, the dissimilarity <code>data.frame</code> is a
<code>bioregion.pairwise.metric</code> object obtained by running <code>similarity</code>,
or by running <code>similarity</code> followed by <code>similarity_to_dissimilarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclu_hierarclust(
  dissimilarity,
  index = names(dissimilarity)[3],
  method = "average",
  randomize = TRUE,
  n_runs = 100,
  keep_trials = FALSE,
  optimal_tree_method = "iterative_consensus_tree",
  n_clust = NULL,
  cut_height = NULL,
  find_h = TRUE,
  h_max = 1,
  h_min = 0,
  consensus_p = 0.5,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclu_hierarclust_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object.
If a <code>data.frame</code> is used, the first two columns represent pairs of sites
(or any pair of nodes), and the subsequent column(s) contain the
dissimilarity indices.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_method">method</code></td>
<td>
<p>The name of the hierarchical classification method, as in
<a href="fastcluster.html#topic+hclust">hclust</a>. Should be one of <code>"ward.D"</code>,
<code>"ward.D2"</code>, <code>"single"</code>, <code>"complete"</code>, <code>"average"</code>
(= UPGMA), <code>"mcquitty"</code> (= WPGMA), <code>"median"</code> (= WPGMC), or
<code>"centroid"</code> (= UPGMC).</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_randomize">randomize</code></td>
<td>
<p>A <code>boolean</code> indicating whether the dissimilarity matrix
should be randomized to account for the order of sites in the dissimilarity
matrix.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_n_runs">n_runs</code></td>
<td>
<p>The number of trials for randomizing the dissimilarity matrix.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_keep_trials">keep_trials</code></td>
<td>
<p>A <code>boolean</code> indicating whether all random trial results
should be stored in the output object. Set to <code>FALSE</code> to save space if your
<code>dissimilarity</code> object is large. Note that this cannot be set to <code>TRUE</code> if
<code>optimal_tree_method = "iterative_consensus_tree"</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_optimal_tree_method">optimal_tree_method</code></td>
<td>
<p>A <code>character</code> string indicating how the final tree
should be obtained from all trials. Possible values are
<code>"iterative_consensus_tree"</code> (default), <code>"best"</code>, and <code>"consensus"</code>.
<strong>We recommend <code>"iterative_consensus_tree"</code>. See Details.</strong></p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> indicating the
number of clusters to be obtained from the hierarchical tree, or the output
from <a href="#topic+bioregionalization_metrics">bioregionalization_metrics</a>. This parameter should not be used
simultaneously with <code>cut_height</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_cut_height">cut_height</code></td>
<td>
<p>A <code>numeric</code> vector indicating the height(s) at which the
tree should be cut. This parameter should not be used simultaneously with
<code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_find_h">find_h</code></td>
<td>
<p>A <code>boolean</code> indicating whether the height of the cut should be
found for the requested <code>n_clust</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_h_max">h_max</code></td>
<td>
<p>A <code>numeric</code> value indicating the maximum possible tree height
for the chosen <code>index</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_h_min">h_min</code></td>
<td>
<p>A <code>numeric</code> value indicating the minimum possible height in the
tree for the chosen <code>index</code>.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_consensus_p">consensus_p</code></td>
<td>
<p>A <code>numeric</code> value (applicable only if
<code>optimal_tree_method = "consensus"</code>) indicating the threshold proportion of
trees that must support a region/cluster for it to be included in the final
consensus tree.</p>
</td></tr>
<tr><td><code id="hclu_hierarclust_+3A_verbose">verbose</code></td>
<td>
<p>A <code>boolean</code> (applicable only if
<code>optimal_tree_method = "iterative_consensus_tree"</code>) indicating whether to
display progress messages. Set to <code>FALSE</code> to suppress these messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on <a href="fastcluster.html#topic+hclust">hclust</a>.
The default method for the hierarchical tree is <code>average</code>, i.e.
UPGMA as it has been recommended as the best method to generate a tree
from beta diversity dissimilarity (Kreft &amp; Jetz, 2010).
</p>
<p>Clusters can be obtained by two methods:
</p>

<ul>
<li><p>Specifying a desired number of clusters in <code>n_clust</code>
</p>
</li>
<li><p>Specifying one or several heights of cut in <code>cut_height</code></p>
</li></ul>

<p>To find an optimal number of clusters, see <code><a href="#topic+bioregionalization_metrics">bioregionalization_metrics()</a></code>
</p>
<p>It is important to pay attention to the fact that the order of rows
in the input distance matrix influences the tree topology as explained in
Dapporto (2013). To address this, the function generates multiple trees by
randomizing the distance matrix.
</p>
<p>Two methods are available to obtain the final tree:
</p>

<ul>
<li><p><code>optimal_tree_method = "iterative_consensus_tree"</code>: The Iterative
Hierarchical Consensus Tree (IHCT) method reconstructs a consensus tree by
iteratively splitting the dataset into two subclusters based on the pairwise
dissimilarity of sites across <code>n_runs</code> trees based on <code>n_runs</code> randomizations
of the distance matrix. At each iteration, it
identifies the majority membership of sites into two stable groups across
all trees,
calculates the height based on the selected linkage method (<code>method</code>),
and enforces monotonic constraints on
node heights to produce a coherent tree structure.
This approach provides a robust, hierarchical representation of site
relationships, balancing
cluster stability and hierarchical constraints.
</p>
</li>
<li><p><code>optimal_tree_method = "best"</code>: This method selects one tree among with
the highest cophenetic correlation coefficient, representing the best fit
between the hierarchical structure and the original distance matrix. 
</p>
</li>
<li><p><code>optimal_tree_method = "consensus"</code>: This method constructs a consensus
tree using phylogenetic methods with the function
<a href="ape.html#topic+consensus">consensus</a>.
When using this option, you must set the <code>consensus_p</code> parameter, which
indicates
the proportion of trees that must contain a region/cluster for it to be
included
in the final consensus tree.
Consensus trees lack an inherent height because they represent a majority
structure rather than an actual hierarchical clustering. To assign heights,
we use a non-negative least squares method (<a href="phangorn.html#topic+designTree">nnls.tree</a>)
based on the initial distance matrix, ensuring that the consensus
tree preserves
approximate distances among clusters.
</p>
</li></ul>

<p>We recommend using the <code>"iterative_consensus_tree"</code> as all the branches of
this tree will always reflect the majority decision among many randomized
versions of the distance matrix. This method is inspired by
Dapporto et al. (2015), which also used the majority decision
among many randomized versions of the distance matrix, but it expands it
to reconstruct the entire topology of the tree iteratively.
</p>
<p>We do not recommend using the basic <code>consensus</code> method because in many
contexts it provides inconsistent results, with a meaningless tree topology
and a very low cophenetic correlation coefficient.
</p>
<p>For a fast exploration of the tree, we recommend using the <code>best</code> method
which will only select the tree with the highest cophenetic correlation
coefficient among all randomized versions of the distance matrix.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> describing the characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> containing all objects associated with the
clustering procedure, such as the original cluster objects.
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, users can find the following elements:
</p>

<ul>
<li><p><code>trials</code>: A list containing all randomization trials. Each trial
includes the dissimilarity matrix with randomized site order, the
associated tree, and the cophenetic correlation coefficient (Spearman) for
that tree.
</p>
</li>
<li><p><code>final.tree</code>: An <code>hclust</code> object representing the final
hierarchical tree to be used.
</p>
</li>
<li><p><code>final.tree.coph.cor</code>: The cophenetic correlation coefficient
between the initial dissimilarity matrix and the <code>final.tree</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kreft H &amp; Jetz W (2010) A framework for delineating biogeographical regions
based on species distributions. <em>Journal of Biogeography</em> 37, 2029-2053.
</p>
<p>Dapporto L, Ramazzotti M, Fattorini S, Talavera G, Vila R &amp; Dennis, RLH
(2013) Recluster: an unbiased clustering procedure for beta-diversity
turnover. <em>Ecography</em> 36, 1070&ndash;1075.
</p>
<p>Dapporto L, Ciolli G, Dennis RLH, Fox R &amp; Shreeve TG (2015) A new procedure
for extrapolating turnover regionalization at mid-small spatial scales,
tested on British butterflies. <em>Methods in Ecology and Evolution</em> 6
, 1287&ndash;1297.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+cut_tree">cut_tree</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "Simpson")

# User-defined number of clusters
tree1 &lt;- hclu_hierarclust(dissim, 
                          n_clust = 5)
tree1
plot(tree1)
str(tree1)
tree1$clusters

# User-defined height cut
# Only one height
tree2 &lt;- hclu_hierarclust(dissim, 
                          cut_height = .05)
tree2
tree2$clusters

# Multiple heights
tree3 &lt;- hclu_hierarclust(dissim, 
                          cut_height = c(.05, .15, .25))

tree3$clusters # Mind the order of height cuts: from deep to shallow cuts
# Info on each partition can be found in table cluster_info
tree3$cluster_info
plot(tree3)

</code></pre>

<hr>
<h2 id='hclu_optics'>OPTICS hierarchical clustering algorithm</h2><span id='topic+hclu_optics'></span>

<h3>Description</h3>

<p>This function performs semi-hierarchical clustering based on dissimilarity
using the OPTICS algorithm (Ordering Points To Identify the
Clustering Structure).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclu_optics(
  dissimilarity,
  index = names(dissimilarity)[3],
  minPts = NULL,
  eps = NULL,
  xi = 0.05,
  minimum = FALSE,
  show_hierarchy = FALSE,
  algorithm_in_output = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclu_optics_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the subsequent column(s) contain the
dissimilarity indices.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_minpts">minPts</code></td>
<td>
<p>A <code>numeric</code> value specifying the minPts argument of
<a href="dbscan.html#topic+dbscan">dbscan</a>. minPts is the minimum number of points required
to form a dense region. By default, it is set to the natural logarithm
of the number of sites in <code>dissimilarity</code>.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_eps">eps</code></td>
<td>
<p>A <code>numeric</code> value specifying the eps argument of
<a href="dbscan.html#topic+optics">optics</a>. It defines the upper limit of the size
of the epsilon neighborhood. Limiting the neighborhood size improves
performance and has no or very little impact on the ordering as long as it
is not set too low. If not specified (default behavior), the largest
minPts-distance in the dataset is used, which gives the same result as
infinity.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_xi">xi</code></td>
<td>
<p>A <code>numeric</code> value specifying the steepness threshold to
identify clusters hierarchically using the Xi method
(see <a href="dbscan.html#topic+optics">optics</a>).</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_minimum">minimum</code></td>
<td>
<p>A <code>boolean</code> specifying whether the hierarchy should be pruned
from the output to only retain clusters at the &quot;minimal&quot; level, i.e.,
only leaf / non-overlapping clusters.
If <code>TRUE</code>, then the argument <code>show_hierarchy</code> should be set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_show_hierarchy">show_hierarchy</code></td>
<td>
<p>A <code>boolean</code> specifying whether the hierarchy of
clusters should be included in the output. By default, the hierarchy is not
visible in the clusters obtained from OPTICS; it can only be visualized by
plotting the OPTICS object. If <code>show_hierarchy = TRUE</code>,
the output cluster <code>data.frame</code> will contain additional columns
showing the hierarchy of clusters.</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original output
of <a href="dbscan.html#topic+dbscan">dbscan</a> should be returned in the output (<code>TRUE</code> by
default, see Value).</p>
</td></tr>
<tr><td><code id="hclu_optics_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>optics()</code>
(see <a href="dbscan.html#topic+optics">optics</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The OPTICS (Ordering points to identify the clustering structure) is a
semi-hierarchical clustering algorithm which orders the points in the
dataset such that points which are closest become neighbors, and calculates
a reachability distance for each point. Then, clusters can be extracted in a
hierarchical manner from this reachability distance, by identifying clusters
depending on changes in the relative cluster density. The reachability plot
should be explored to understand the clusters and their hierarchical nature,
by running plot on the output of the function
if <code>algorithm_in_output = TRUE</code>: <code>plot(object$algorithm)</code>.
We recommend reading (Hahsler et al., 2019) to grasp the
algorithm, how it works, and what the clusters mean.
</p>
<p>To extract the clusters, we use the
<a href="dbscan.html#topic+optics">extractXi</a> function which is based on the
steepness of the reachability plot (see
<a href="dbscan.html#topic+optics">optics</a>)
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> describing the characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> containing all objects associated with the
clustering procedure, such as the original cluster objects.
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of <a href="dbscan.html#topic+optics">optics</a>.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Hahsler M, Piekenbrock M &amp; Doran D (2019) Dbscan: Fast density-based
clustering with R. <em>Journal of Statistical Software</em> 91, 1&ndash;30.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_1_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_dbscan">nhclu_dbscan</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dissim &lt;- dissimilarity(fishmat, metric = "all")
  
clust1 &lt;- hclu_optics(dissim, index = "Simpson")
clust1

# Visualize the optics plot (the hierarchy of clusters is illustrated at the
# bottom)
plot(clust1$algorithm)

# Extract the hierarchy of clusters
clust1 &lt;- hclu_optics(dissim, index = "Simpson", show_hierarchy = TRUE)
clust1

</code></pre>

<hr>
<h2 id='install_binaries'>Download, unzip, check permissions, and test the bioregion's binary files</h2><span id='topic+install_binaries'></span>

<h3>Description</h3>

<p>This function downloads and unzips the 'bin' folder required to run certain
functions of the <code>bioregion</code> package. It also verifies if the files have the
necessary permissions to be executed as programs. Finally, it tests whether
the binary files are running correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_binaries(
  binpath = "tempdir",
  download_only = FALSE,
  infomap_version = c("2.1.0", "2.6.0", "2.7.1", "2.8.0")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="install_binaries_+3A_binpath">binpath</code></td>
<td>
<p>A <code>character</code> string specifying the path to the folder that
will host the <code>bin</code> folder containing the binary files (see Details).</p>
</td></tr>
<tr><td><code id="install_binaries_+3A_download_only">download_only</code></td>
<td>
<p>A <code>logical</code> value indicating whether the function should
only download the <code>bin.zip</code> file or perform the entire process (see Details).</p>
</td></tr>
<tr><td><code id="install_binaries_+3A_infomap_version">infomap_version</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string
specifying the Infomap version(s) to install.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the binary files are installed in R's temporary
directory (<code>binpath = "tempdir"</code>). In this case, the <code>bin</code> folder will be
automatically removed at the end of the R session. Alternatively, the binary
files can be installed in the <code>bioregion</code> package folder
(<code>binpath = "pkgfolder"</code>).
</p>
<p>A custom folder path can also be specified. In this case, and only in this
case, <code>download_only</code> can be set to <code>TRUE</code>, but you must ensure that the
files have the required permissions to be executed as programs.
</p>
<p><strong>In all cases, PLEASE MAKE SURE to update the <code>binpath</code> and <code>check_install</code>
parameters accordingly in <a href="#topic+netclu_infomap">netclu_infomap</a>, <a href="#topic+netclu_louvain">netclu_louvain</a>, and
<a href="#topic+netclu_oslom">netclu_oslom</a>.</strong>
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Note</h3>

<p>Currently, only Infomap versions 2.1.0, 2.6.0, 2.7.1, and 2.8.0 are available.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a1_install_binary_files.html">https://biorgeo.github.io/bioregion/articles/a1_install_binary_files.html</a>.
</p>

<hr>
<h2 id='map_bioregions'>Create a map of bioregions</h2><span id='topic+map_bioregions'></span>

<h3>Description</h3>

<p>This plot function can be used to visualize bioregions based on a
<code>bioregion.clusters</code> object combined with a geometry (<code>sf</code> objects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_bioregions(clusters, geometry, write_clusters = FALSE, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_bioregions_+3A_clusters">clusters</code></td>
<td>
<p>An object of class <code>bioregion.clusters</code> or a <code>data.frame</code>.
If a <code>data.frame</code> is used, the first column should represent the sites'
ID, and the subsequent column(s) should represent the clusters.</p>
</td></tr>
<tr><td><code id="map_bioregions_+3A_geometry">geometry</code></td>
<td>
<p>A spatial object that can be handled by the <code>sf</code> package.
The first attribute should correspond to the sites' ID (see Details).</p>
</td></tr>
<tr><td><code id="map_bioregions_+3A_write_clusters">write_clusters</code></td>
<td>
<p>A <code>boolean</code> indicating if the <code>clusters</code> should be
added to the <code>geometry</code>.</p>
</td></tr>
<tr><td><code id="map_bioregions_+3A_plot">plot</code></td>
<td>
<p>A <code>boolean</code> indicating if the plot should be drawn.</p>
</td></tr>
<tr><td><code id="map_bioregions_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>sf::plot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>clusters</code> and <code>geometry</code> site IDs should correspond. They should
have the same type (i.e., <code>character</code> if <code>clusters</code> is a
<code>bioregion.clusters</code> object) and the sites of <code>clusters</code> should be
included in the sites of <code>geometry</code>.
</p>


<h3>Value</h3>

<p>One or several maps of bioregions if <code>plot = TRUE</code> and the
geometry with additional clusters' attributes if <code>write_clusters = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fishmat)
data(fishsf)

net &lt;- similarity(fishmat, metric = "Simpson")
clu &lt;- netclu_greedy(net)
map &lt;- map_bioregions(clu, fishsf, write_clusters = TRUE, plot = FALSE)

</code></pre>

<hr>
<h2 id='mat_to_net'>Create a data.frame from a contingency table</h2><span id='topic+mat_to_net'></span>

<h3>Description</h3>

<p>This function generates a two- or three-column <code>data.frame</code>, where
each row represents the interaction between two nodes (e.g., site and species)
and an optional third column indicates the weight of the interaction
(if <code>weight = TRUE</code>). The input is a contingency table, with rows
representing one set of entities (e.g., site) and columns representing
another set (e.g., species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_to_net(
  mat,
  weight = FALSE,
  remove_zeroes = TRUE,
  include_diag = TRUE,
  include_lower = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_to_net_+3A_mat">mat</code></td>
<td>
<p>A contingency table (i.e., a <code>matrix</code>).</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_weight">weight</code></td>
<td>
<p>A <code>logical</code> value indicating whether the values in the matrix
should be interpreted as interaction weights.</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_remove_zeroes">remove_zeroes</code></td>
<td>
<p>A <code>logical</code> value determining whether interactions with
a weight equal to 0 should be excluded from the output.</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_include_diag">include_diag</code></td>
<td>
<p>A <code>logical</code> value indicating whether the diagonal
(self-interactions) should be included in the output. This applies only to
square matrices.</p>
</td></tr>
<tr><td><code id="mat_to_net_+3A_include_lower">include_lower</code></td>
<td>
<p>A <code>logical</code> value indicating whether the lower
triangular part of the <code>matrix</code> should be included in the output. This
applies only to square matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> where each row represents the interaction
between two nodes. If <code>weight = TRUE</code>, the <code>data.frame</code> includes a third
column representing the weight of each interaction.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html">https://biorgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html</a>.
</p>
<p>Associated functions:
<a href="#topic+net_to_mat">net_to_mat</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(mat) &lt;- paste0("Site", 1:5)
colnames(mat) &lt;- paste0("Species", 1:10)

net &lt;- mat_to_net(mat, weight = TRUE)

</code></pre>

<hr>
<h2 id='net_to_mat'>Create a contingency table from a data.frame</h2><span id='topic+net_to_mat'></span>

<h3>Description</h3>

<p>This function generates a contingency table from a two- or three-column
<code>data.frame</code>, where each row represents the interaction between two
nodes (e.g., site and species) and an optional third column indicates
the weight of the interaction (if <code>weight = TRUE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_to_mat(
  net,
  weight = FALSE,
  squared = FALSE,
  symmetrical = FALSE,
  missing_value = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="net_to_mat_+3A_net">net</code></td>
<td>
<p>A two- or three-column <code>data.frame</code> where each row
represents the interaction between two nodes (e.g., site and species),
with an optional third column indicating the weight of the interaction.</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_weight">weight</code></td>
<td>
<p>A <code>logical</code> value indicating whether the weight column
should be considered.</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_squared">squared</code></td>
<td>
<p>A <code>logical</code> value indicating whether the output matrix
should be square (i.e., containing the same nodes in rows and columns).</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_symmetrical">symmetrical</code></td>
<td>
<p>A <code>logical</code> value indicating whether the resulting
matrix should be symmetrical. This applies only if <code>squared = TRUE</code>.
Note that different weights associated with opposite pairs already present
in <code>net</code> will be preserved.</p>
</td></tr>
<tr><td><code id="net_to_mat_+3A_missing_value">missing_value</code></td>
<td>
<p>The value to assign to pairs of nodes not present
in <code>net</code>. Defaults to <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the first nodes (from the first column of <code>net</code>)
as rows and the second nodes (from the second column of <code>net</code>) as columns.
If <code>squared = TRUE</code>, the rows and columns will have the same number of
elements, corresponding to the unique union of objects in the first and
second columns of <code>net</code>. If <code>squared = TRUE</code> and <code>symmetrical = TRUE</code>,
the matrix will be forced to be symmetrical based on the upper triangular
part of the matrix.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html">https://biorgeo.github.io/bioregion/articles/a2_matrix_and_network_formats.html</a>.
</p>
<p>Associated functions:
<a href="#topic+mat_to_net">mat_to_net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- data.frame(
  Site = c(rep("A", 2), rep("B", 3), rep("C", 2)),
  Species = c("a", "b", "a", "c", "d", "b", "d"),
  Weight = c(10, 100, 1, 20, 50, 10, 20)
)

mat &lt;- net_to_mat(net, weight = TRUE)

</code></pre>

<hr>
<h2 id='netclu_beckett'>Community structure detection in weighted bipartite networks via modularity
optimization</h2><span id='topic+netclu_beckett'></span>

<h3>Description</h3>

<p>This function takes a bipartite weighted graph and computes modules by
applying Newman’s modularity measure in a bipartite weighted version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_beckett(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  seed = NULL,
  forceLPA = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_beckett_+3A_net">net</code></td>
<td>
<p>A <code>data.frame</code> representing a bipartite network with the first
two columns representing undirected links between pairs of nodes, and the
next column(s) representing the weights of the links.</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating whether weights should be considered
if there are more than two columns (see Note).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, links
with weights strictly lower than this value will not be considered
(<code>0</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator (<code>NULL</code> for random
by default).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_forcelpa">forceLPA</code></td>
<td>
<p>A <code>boolean</code> indicating whether the even faster pure
LPA-algorithm of Beckett should be used. DIRT-LPA (the default) is less
likely to get trapped in a local minimum but is slightly slower. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_site_col">site_col</code></td>
<td>
<p>The name or number of the column for site nodes
(i.e., primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_species_col">species_col</code></td>
<td>
<p>The name or number of the column for species nodes
(i.e., feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating which types of nodes
(<code>"site"</code>, <code>"species"</code>, or <code>"both"</code>) should be returned in the output
(<code>"both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_beckett_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original
output of <a href="bipartite.html#topic+computeModules">computeModules</a> should be returned
in the output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the modularity optimization algorithm provided by
Stephen Beckett (Beckett, 2016) as implemented in the
<a href="https://cran.r-project.org/package=bipartite">bipartite</a>
package (<a href="bipartite.html#topic+computeModules">computeModules</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, users can find the output of
<a href="bipartite.html#topic+computeModules">computeModules</a> in the <code>algorithm</code> slot.
</p>


<h3>Note</h3>

<p>Beckett's algorithm is designed to handle weighted bipartite networks. If
<code>weight = FALSE</code>, a weight of 1 will be assigned to each pair of nodes.
Ensure that the <code>site_col</code> and <code>species_col</code> arguments correctly identify
the respective columns for site nodes (primary nodes) and species nodes
(feature nodes). The type of nodes returned in the output can be selected
using the <code>return_node_type</code> argument: <code>"both"</code> to include both node types,
<code>"site"</code> to return only site nodes, or <code>"species"</code> to return only species
nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Beckett SJ (2016) Improved community detection in weighted bipartite
networks. <em>Royal Society Open Science</em> 3, 140536.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- data.frame(
  Site = c(rep("A", 2), rep("B", 3), rep("C", 2)),
  Species = c("a", "b", "a", "c", "d", "b", "d"),
  Weight = c(10, 100, 1, 20, 50, 10, 20))

com &lt;- netclu_beckett(net)

</code></pre>

<hr>
<h2 id='netclu_greedy'>Community structure detection via greedy optimization of modularity</h2><span id='topic+netclu_greedy'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network via
greedy optimization of modularity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_greedy(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_greedy_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the similarity
indices.</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (0 by default).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_site_col">site_col</code></td>
<td>
<p>The name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_species_col">species_col</code></td>
<td>
<p>The name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>site</code>, <code>species</code> or <code>both</code>) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_greedy_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating if the original output
of <a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a> should be returned in
the output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the fast greedy modularity optimization algorithm
(Clauset et al., 2004) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: <code>character</code> containing the name of the algorithm
</p>
</li>
<li><p><strong>args</strong>: <code>list</code> of input arguments as provided by the user
</p>
</li>
<li><p><strong>inputs</strong>: <code>list</code> of characteristics of the clustering process
</p>
</li>
<li><p><strong>algorithm</strong>: <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>)
</p>
</li>
<li><p><strong>clusters</strong>: <code>data.frame</code> containing the clustering results</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of
<a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
network, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>both</code> to keep both types of nodes,
<code>sites</code> to preserve only the sites nodes and <code>species</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Clauset A, Newman MEJ &amp; Moore C (2004) Finding community structure in very
large networks. <em>Phys. Rev. E</em> 70, 066111.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_greedy(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_greedy(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_infomap'>Infomap community finding</h2><span id='topic+netclu_infomap'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted (un)directed network based
on the Infomap algorithm (<a href="https://github.com/mapequation/infomap">https://github.com/mapequation/infomap</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_infomap(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  seed = NULL,
  nbmod = 0,
  markovtime = 1,
  numtrials = 1,
  twolevel = FALSE,
  show_hierarchy = FALSE,
  directed = FALSE,
  bipartite_version = FALSE,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  version = "2.8.0",
  binpath = "tempdir",
  check_install = TRUE,
  path_temp = "infomap_temp",
  delete_temp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_infomap_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the similarity
indices.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (<code>0</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator (<code>NULL</code> for random by
default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_nbmod">nbmod</code></td>
<td>
<p>Penalize solutions the more they differ from this number (<code>0</code> by
default for no preferred number of modules).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_markovtime">markovtime</code></td>
<td>
<p>Scales link flow to change the cost of moving between
modules, higher values result in fewer modules (<code>1</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_numtrials">numtrials</code></td>
<td>
<p>For the number of trials before picking up the best
solution.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_twolevel">twolevel</code></td>
<td>
<p>A <code>boolean</code> indicating if the algorithm should optimize a
two-level partition of the network (<code>FALSE</code> by default for multi-level).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_show_hierarchy">show_hierarchy</code></td>
<td>
<p>A <code>boolean</code> specifying if the hierarchy of community
should be identifiable in the outputs (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_directed">directed</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is directed (from
column 1 to column 2).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_bipartite_version">bipartite_version</code></td>
<td>
<p>A <code>boolean</code> indicating if the bipartite version of
Infomap should be used (see Note).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Note).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_site_col">site_col</code></td>
<td>
<p>The name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_species_col">species_col</code></td>
<td>
<p>The name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>"site"</code>, <code>"species"</code>, or <code>"both"</code>) should be returned in the output
(<code>"both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_version">version</code></td>
<td>
<p>A <code>character</code> indicating the Infomap version to use.</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_binpath">binpath</code></td>
<td>
<p>A <code>character</code> indicating the path to the bin folder
(see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_check_install">check_install</code></td>
<td>
<p>A <code>boolean</code> indicating if the function should check that
the Infomap has been properly installed (see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_path_temp">path_temp</code></td>
<td>
<p>A <code>character</code> indicating the path to the temporary folder
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_infomap_+3A_delete_temp">delete_temp</code></td>
<td>
<p>A <code>boolean</code> indicating if the temporary folder should
be removed (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Infomap is a network clustering algorithm based on the Map equation proposed
in Rosvall &amp; Bergstrom (2008) that finds communities in (un)weighted
and (un)directed networks.
</p>
<p>This function is based on the C++ version of Infomap
(<a href="https://github.com/mapequation/infomap/releases">https://github.com/mapequation/infomap/releases</a>).
This function needs binary files to run. They can be installed
with <a href="#topic+install_binaries">install_binaries</a>.
</p>
<p><strong>If you changed the default path to the <code>bin</code> folder
while running <a href="#topic+install_binaries">install_binaries</a> PLEASE MAKE SURE to set <code>binpath</code>
accordingly.</strong>
</p>
<p><strong>If you did not use <a href="#topic+install_binaries">install_binaries</a> to change the permissions and test
the binary files PLEASE MAKE SURE to set <code>check_install</code> accordingly.</strong>
</p>
<p>The C++ version of Infomap generates temporary folders and/or files that are
stored in the <code>path_temp</code> folder (&quot;infomap_temp&quot; with a unique timestamp
located in the bin folder in <code>binpath</code> by default). This temporary folder is
removed by default (<code>delete_temp = TRUE</code>).
</p>
<p>Several versions of Infomap are available in the package. See
<a href="#topic+install_binaries">install_binaries</a> for more details.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects.
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, users can find the following elements:
</p>

<ul>
<li><p><code>cmd</code>: The command line used to run Infomap.
</p>
</li>
<li><p><code>version</code>: The Infomap version.
</p>
</li>
<li><p><code>web</code>: Infomap's GitHub repository.
</p>
</li></ul>



<h3>Note</h3>

<p>Infomap has been designed to deal with bipartite networks. To use this
functionality, set the <code>bipartite_version</code> argument to TRUE in order to
approximate a two-step random walker (see
<a href="https://www.mapequation.org/infomap/">https://www.mapequation.org/infomap/</a> for more information). Note that
a bipartite network can also be considered as a unipartite network
(<code>bipartite = TRUE</code>).
</p>
<p>In both cases, do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e., primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes, <code>"site"</code>
to preserve only the site nodes, and <code>"species"</code> to preserve only the
species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Rosvall M &amp; Bergstrom CT (2008) Maps of random walks on complex networks
reveal community structure. <em>Proceedings of the National Academy of
Sciences</em> 105, 1118-1123.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_greedy">netclu_greedy</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_infomap(net)

</code></pre>

<hr>
<h2 id='netclu_labelprop'>Finding communities based on propagating labels</h2><span id='topic+netclu_labelprop'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on propagating labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_labelprop(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  seed = NULL,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_labelprop_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (<code>0</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator (<code>NULL</code> for random
by default).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_site_col">site_col</code></td>
<td>
<p>The name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_species_col">species_col</code></td>
<td>
<p>The name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>"site"</code>, <code>"species"</code>, or <code>"both"</code>) should be returned in the output
(<code>"both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_labelprop_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating if the original output
of <a href="igraph.html#topic+cluster_label_prop">cluster_label_prop</a> should be returned in the
output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on propagating labels
(Raghavan et al., 2007) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_label_prop">cluster_label_prop</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find a &quot;communities&quot; object, output of
<a href="igraph.html#topic+cluster_label_prop">cluster_label_prop</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
networks, it is possible to consider the bipartite network as a unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e., primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"site"</code> to preserve only the site nodes, and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Raghavan UN, Albert R &amp; Kumara S (2007) Near linear time algorithm to detect
community structures in large-scale networks. <em>Physical Review E</em> 76,
036106.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_labelprop(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_labelprop(net_bip, bipartite = TRUE)
</code></pre>

<hr>
<h2 id='netclu_leadingeigen'>Finding communities based on the leading eigenvector of the community matrix</h2><span id='topic+netclu_leadingeigen'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on the leading eigenvector of the community matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_leadingeigen(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_leadingeigen_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (<code>0</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_site_col">site_col</code></td>
<td>
<p>The name or number for the column of site nodes
(i.e., primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_species_col">species_col</code></td>
<td>
<p>The name or number for the column of species nodes
(i.e., feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>"site"</code>, <code>"species"</code>, or <code>"both"</code>) should be returned in the output
(<code>"both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_leadingeigen_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating if the original output
of <a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a> should be returned
in the output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the leading eigenvector of the community matrix
(Newman, 2006) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of <a href="igraph.html#topic+cluster_leading_eigen">cluster_leading_eigen</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
networks, it is possible to consider the bipartite network as a unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e., primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"site"</code> to preserve only the site nodes, and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Newman MEJ (2006) Finding community structure in networks using the
eigenvectors of matrices. <em>Physical Review E</em> 74, 036104.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_leadingeigen(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_leadingeigen(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_leiden'>Finding communities using the Leiden algorithm</h2><span id='topic+netclu_leiden'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on the Leiden algorithm of Traag, van Eck &amp; Waltman.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_leiden(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  seed = NULL,
  objective_function = "CPM",
  resolution_parameter = 1,
  beta = 0.01,
  n_iterations = 2,
  vertex_weights = NULL,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_leiden_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (<code>0</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_seed">seed</code></td>
<td>
<p>The random number generator seed (NULL for random by default).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_objective_function">objective_function</code></td>
<td>
<p>A string indicating the objective function to use,
either the Constant Potts Model (&quot;CPM&quot;) or &quot;modularity&quot; (&quot;CPM&quot; by default).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_resolution_parameter">resolution_parameter</code></td>
<td>
<p>The resolution parameter to use. Higher
resolutions lead to smaller communities, while lower resolutions lead
to larger communities.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_beta">beta</code></td>
<td>
<p>A parameter affecting the randomness in the Leiden algorithm. This
affects only the refinement step of the algorithm.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_n_iterations">n_iterations</code></td>
<td>
<p>The number of iterations for the Leiden
algorithm. Each iteration may further improve the partition.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_vertex_weights">vertex_weights</code></td>
<td>
<p>The vertex weights used in the Leiden algorithm. If
not provided, they will be automatically determined based on the
objective_function. Please see the details of this function to understand how
to interpret the vertex weights.</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_site_col">site_col</code></td>
<td>
<p>The name or number for the column of site nodes
(i.e., primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_species_col">species_col</code></td>
<td>
<p>The name or number for the column of species nodes
(i.e., feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(&quot;site&quot;, &quot;species&quot;, or &quot;both&quot;) should be returned in the output
(<code>"both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_leiden_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating if the original output
of <a href="igraph.html#topic+cluster_leiden">cluster_leiden</a> should be returned in the
output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the Leiden algorithm
(Traag et al., 2019) as implemented in the
<a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_leiden">cluster_leiden</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of <a href="igraph.html#topic+cluster_leiden">cluster_leiden</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
networks, it is possible to consider the bipartite network as a unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e., primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>"both"</code> to keep both types of nodes,
<code>"site"</code> to preserve only the site nodes, and <code>"species"</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Traag VA, Waltman L &amp; Van Eck NJ (2019) From Louvain to Leiden: guaranteeing
well-connected communities. <em>Scientific reports</em> 9, 5233.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_leiden(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_leiden(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='netclu_louvain'>Louvain community finding</h2><span id='topic+netclu_louvain'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network based
on the Louvain algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_louvain(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  lang = "igraph",
  resolution = 1,
  seed = NULL,
  q = 0,
  c = 0.5,
  k = 1,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  binpath = "tempdir",
  check_install = TRUE,
  path_temp = "louvain_temp",
  delete_temp = TRUE,
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_louvain_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of sites
(or any pair of nodes), and the next column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (<code>0</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_index">index</code></td>
<td>
<p>The name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_lang">lang</code></td>
<td>
<p>A string indicating which version of Louvain should be used
(<code>"igraph"</code> or <code>"cpp"</code>, see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_resolution">resolution</code></td>
<td>
<p>A resolution parameter to adjust the modularity
(1 is chosen by default, see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_seed">seed</code></td>
<td>
<p>The random number generator seed (only when <code>lang = "igraph"</code>,
NULL for random by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_q">q</code></td>
<td>
<p>The quality function used to compute the partition of the graph
(modularity is chosen by default, see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_c">c</code></td>
<td>
<p>The parameter for the Owsinski-Zadrozny quality function
(between 0 and 1, 0.5 is chosen by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_k">k</code></td>
<td>
<p>The kappa_min value for the Shi-Malik quality function
(it must be &gt; 0, 1 is chosen by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_site_col">site_col</code></td>
<td>
<p>The name or number for the column of site nodes
(i.e., primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_species_col">species_col</code></td>
<td>
<p>The name or number for the column of species nodes
(i.e., feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>"site"</code>, <code>"species"</code>, or <code>"both"</code>) should be returned in the output
(<code>"both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_binpath">binpath</code></td>
<td>
<p>A <code>character</code> indicating the path to the bin folder
(see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_check_install">check_install</code></td>
<td>
<p>A <code>boolean</code> indicating if the function should check that
Louvain has been properly installed (see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_path_temp">path_temp</code></td>
<td>
<p>A <code>character</code> indicating the path to the temporary folder
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_delete_temp">delete_temp</code></td>
<td>
<p>A <code>boolean</code> indicating if the temporary folder should
be removed (see Details).</p>
</td></tr>
<tr><td><code id="netclu_louvain_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating if the original output
of <a href="igraph.html#topic+cluster_louvain">cluster_louvain</a> should be returned in the
output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Louvain is a network community detection algorithm proposed in
(Blondel et al., 2008). This function offers two
implementations of the Louvain algorithm (controlled by the <code>lang</code> parameter):
the <a href="https://cran.r-project.org/package=igraph">igraph</a>
implementation (<a href="igraph.html#topic+cluster_louvain">cluster_louvain</a>) and the C++
implementation (<a href="https://sourceforge.net/projects/louvain/">https://sourceforge.net/projects/louvain/</a>, version 0.3).
</p>
<p>The <a href="https://cran.r-project.org/package=igraph">igraph</a>
implementation allows adjustment of the resolution parameter of
the modularity function (<code>resolution</code> argument) used internally by the
algorithm. Lower values typically yield fewer, larger clusters. The original
definition of modularity is recovered when the resolution parameter
is set to 1 (by default).
</p>
<p>The C++ implementation provides several quality functions:
<code>q = 0</code> for the classical Newman-Girvan criterion (Modularity),
<code>q = 1</code> for the Zahn-Condorcet criterion, <code>q = 2</code> for the Owsinski-Zadrozny
criterion (parameterized by <code>c</code>), <code>q = 3</code> for the Goldberg Density criterion,
<code>q = 4</code> for the A-weighted Condorcet criterion, <code>q = 5</code> for the Deviation to
Indetermination criterion, <code>q = 6</code> for the Deviation to Uniformity criterion,
<code>q = 7</code> for the Profile Difference criterion, <code>q = 8</code> for the Shi-Malik
criterion (parameterized by <code>k</code>), and <code>q = 9</code> for the Balanced Modularity
criterion.
</p>
<p>The C++ version is based on version 0.3
(<a href="https://sourceforge.net/projects/louvain/">https://sourceforge.net/projects/louvain/</a>). Binary files are required to run it,
and can be installed with <a href="#topic+install_binaries">install_binaries</a>.
</p>
<p><strong>If you changed the default path to the <code>bin</code> folder
while running <a href="#topic+install_binaries">install_binaries</a>, PLEASE MAKE SURE to set <code>binpath</code>
accordingly.</strong>
</p>
<p><strong>If you did not use <a href="#topic+install_binaries">install_binaries</a> to change the permissions or test
the binary files, PLEASE MAKE SURE to set <code>check_install</code> accordingly.</strong>
</p>
<p>The C++ version generates temporary folders and/or files in the <code>path_temp</code>
folder (&quot;louvain_temp&quot; with a unique timestamp located in the bin folder in
<code>binpath</code> by default). This temporary folder is removed by default
(<code>delete_temp = TRUE</code>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of <a href="igraph.html#topic+cluster_louvain">cluster_louvain</a> if
<code>lang = "igraph"</code> and the following element if <code>lang = "cpp"</code>:
</p>

<ul>
<li><p><code>cmd</code>: The command line used to run Louvain.
</p>
</li>
<li><p><code>version</code>: The Louvain version.
</p>
</li>
<li><p><code>web</code>: The Louvain's website.
</p>
</li></ul>



<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
networks, it is possible to consider the bipartite network as a unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is dedicated to the
site nodes (i.e., primary nodes) and species nodes (i.e., feature nodes) using
the arguments <code>site_col</code> and <code>species_col</code>. The type of nodes returned in
the output can be chosen with the argument <code>return_node_type</code> equal to
<code>"both"</code> to keep both types of nodes, <code>"site"</code> to preserve only the site
nodes, and <code>"species"</code> to preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Blondel VD, Guillaume JL, Lambiotte R &amp; Mech ELJS (2008) Fast unfolding of
communities in large networks. <em>J. Stat. Mech.</em> 10, P10008.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_greedy">netclu_greedy</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_louvain(net, lang = "igraph")

</code></pre>

<hr>
<h2 id='netclu_oslom'>OSLOM community finding</h2><span id='topic+netclu_oslom'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted (un)directed network based
on the OSLOM algorithm (<a href="http://oslom.org/">http://oslom.org/</a>, version 2.4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_oslom(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  seed = NULL,
  reassign = "no",
  r = 10,
  hr = 50,
  t = 0.1,
  cp = 0.5,
  directed = FALSE,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  binpath = "tempdir",
  check_install = TRUE,
  path_temp = "oslom_temp",
  delete_temp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_oslom_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.
If a <code>data.frame</code> is used, the first two columns represent pairs of
sites (or any pair of nodes), and the next column(s) are the similarity
indices.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (0 by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_index">index</code></td>
<td>
<p>Name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_seed">seed</code></td>
<td>
<p>For the random number generator (NULL for random by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_reassign">reassign</code></td>
<td>
<p>A <code>character</code> indicating if the nodes belonging to several
community should be reassigned and what method should be used (see Note).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_r">r</code></td>
<td>
<p>The number of runs for the first hierarchical level
(10 by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_hr">hr</code></td>
<td>
<p>The number of runs for the higher hierarchical level (50 by
default, 0 if you are not interested in hierarchies).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_t">t</code></td>
<td>
<p>The p-value, the default value is 0.10. Increase this value if you want
more modules.</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_cp">cp</code></td>
<td>
<p>Kind of resolution parameter used to decide between taking some
modules or their union (default value is 0.5; a bigger value leads to bigger
clusters).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_directed">directed</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is directed (from
column 1 to column 2).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_site_col">site_col</code></td>
<td>
<p>Name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_species_col">species_col</code></td>
<td>
<p>Name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>site</code>, <code>species</code>, or <code>both</code>) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_binpath">binpath</code></td>
<td>
<p>A <code>character</code> indicating the path to the bin folder
(see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_check_install">check_install</code></td>
<td>
<p>A <code>boolean</code> indicating if the function should check that
the OSLOM has been properly installed (see <a href="#topic+install_binaries">install_binaries</a> and Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_path_temp">path_temp</code></td>
<td>
<p>A <code>character</code> indicating the path to the temporary folder
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_oslom_+3A_delete_temp">delete_temp</code></td>
<td>
<p>A <code>boolean</code> indicating if the temporary folder should
be removed (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OSLOM is a network community detection algorithm proposed in
Lancichinetti et al. (2011) that finds statistically significant
(overlapping) communities in (un)weighted and (un)directed networks.
</p>
<p>This function is based on the 2.4 C++ version of OSLOM
(<a href="http://www.oslom.org/software.htm">http://www.oslom.org/software.htm</a>). This function needs files
to run. They can be installed with <a href="#topic+install_binaries">install_binaries</a>.
</p>
<p><strong>If you changed the default path to the <code>bin</code> folder
while running <a href="#topic+install_binaries">install_binaries</a>, PLEASE MAKE SURE to set <code>binpath</code>
accordingly.</strong>
</p>
<p><strong>If you did not use <a href="#topic+install_binaries">install_binaries</a> to change the permissions and test
the binary files, PLEASE MAKE SURE to set <code>check_install</code> accordingly.</strong>
</p>
<p>The C++ version of OSLOM generates temporary folders and/or files that are
stored in the <code>path_temp</code> folder (folder &quot;oslom_temp&quot; with a unique timestamp
located in the bin folder in <code>binpath</code> by default). This temporary folder is
removed by default (<code>delete_temp = TRUE</code>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, users can find the following elements:
</p>

<ul>
<li><p><code>cmd</code>: The command line used to run OSLOM.
</p>
</li>
<li><p><code>version</code>: The OSLOM version.
</p>
</li>
<li><p><code>web</code>: The OSLOM's web site.
</p>
</li></ul>



<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
networks, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>). Do not forget to indicate which of the
first two columns is dedicated to the site nodes (i.e. primary nodes) and
species nodes (i.e. feature nodes) using the arguments <code>site_col</code> and
<code>species_col</code>. The type of nodes returned in the output can be chosen
with the argument <code>return_node_type</code> equal to <code>both</code> to keep both
types of nodes, <code>sites</code> to preserve only the sites nodes, and
<code>species</code> to preserve only the species nodes.
</p>
<p>Since OSLOM potentially returns overlapping communities, we propose two
methods to reassign the 'overlapping' nodes: randomly (<code>reassign = "random"</code>)
or based on the closest candidate community (<code>reassign = "simil"</code>) (only for
weighted networks, in this case the closest candidate community is
determined with the average similarity). By default, <code>reassign = "no"</code> and
all the information will be provided. The number of partitions will depend
on the number of overlapping modules (up to three). The suffix <code style="white-space: pre;">&#8288;_semel&#8288;</code>,
<code style="white-space: pre;">&#8288;_bis&#8288;</code>, and <code style="white-space: pre;">&#8288;_ter&#8288;</code> are added to the column names. The first partition
(<code style="white-space: pre;">&#8288;_semel&#8288;</code>) assigns a module to each node. A value of <code>NA</code> in the second
(<code style="white-space: pre;">&#8288;_bis&#8288;</code>) and third (<code style="white-space: pre;">&#8288;_ter&#8288;</code>) columns indicates that no overlapping module
was found for this node (i.e. non-overlapping nodes).
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Lancichinetti A, Radicchi F, Ramasco JJ &amp; Fortunato S (2011) Finding
statistically significant communities in networks. <em>PLOS ONE</em> 6,
e18961.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_greedy">netclu_greedy</a> <a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_oslom(net)

</code></pre>

<hr>
<h2 id='netclu_walktrap'>Community structure detection via short random walks</h2><span id='topic+netclu_walktrap'></span>

<h3>Description</h3>

<p>This function finds communities in a (un)weighted undirected network via
short random walks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netclu_walktrap(
  net,
  weight = TRUE,
  cut_weight = 0,
  index = names(net)[3],
  steps = 4,
  bipartite = FALSE,
  site_col = 1,
  species_col = 2,
  return_node_type = "both",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netclu_walktrap_+3A_net">net</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>. If a <code>data.frame</code> is used, the first two
columns represent pairs of sites (or any pair of nodes), and the next
column(s) are the similarity indices.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_weight">weight</code></td>
<td>
<p>A <code>boolean</code> indicating if the weights should be considered
if there are more than two columns.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_cut_weight">cut_weight</code></td>
<td>
<p>A minimal weight value. If <code>weight</code> is TRUE, the links
between sites with a weight strictly lower than this value will not be
considered (0 by default).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_index">index</code></td>
<td>
<p>Name or number of the column to use as weight. By default,
the third column name of <code>net</code> is used.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_steps">steps</code></td>
<td>
<p>The length of the random walks to perform.</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_bipartite">bipartite</code></td>
<td>
<p>A <code>boolean</code> indicating if the network is bipartite
(see Details).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_site_col">site_col</code></td>
<td>
<p>Name or number for the column of site nodes
(i.e. primary nodes).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_species_col">species_col</code></td>
<td>
<p>Name or number for the column of species nodes
(i.e. feature nodes).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_return_node_type">return_node_type</code></td>
<td>
<p>A <code>character</code> indicating what types of nodes
(<code>site</code>, <code>species</code>, or <code>both</code>) should be returned in the output
(<code>return_node_type = "both"</code> by default).</p>
</td></tr>
<tr><td><code id="netclu_walktrap_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating if the original output
of <a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a> should be returned in the
output (<code>TRUE</code> by default, see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on random walks (Pons &amp; Latapy, 2005)
as implemented in the <a href="https://cran.r-project.org/package=igraph">igraph</a>
package (<a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>In the <code>algorithm</code> slot, if <code>algorithm_in_output = TRUE</code>, users can
find the output of
<a href="igraph.html#topic+cluster_walktrap">cluster_walktrap</a>.
</p>


<h3>Note</h3>

<p>Although this algorithm was not primarily designed to deal with bipartite
networks, it is possible to consider the bipartite network as unipartite
network (<code>bipartite = TRUE</code>).
</p>
<p>Do not forget to indicate which of the first two columns is
dedicated to the site nodes (i.e. primary nodes) and species nodes (i.e.
feature nodes) using the arguments <code>site_col</code> and <code>species_col</code>.
The type of nodes returned in the output can be chosen with the argument
<code>return_node_type</code> equal to <code>both</code> to keep both types of nodes,
<code>sites</code> to preserve only the site nodes, and <code>species</code> to
preserve only the species nodes.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Pons P &amp; Latapy M (2005) Computing Communities in Large Networks
Using Random Walks. In Yolum I, Güngör T, Gürgen F, Özturan C (eds.),
<em>Computer and Information Sciences - ISCIS 2005</em>, Lecture Notes in
Computer Science, 284-293.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_3_network_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+netclu_infomap">netclu_infomap</a> <a href="#topic+netclu_louvain">netclu_louvain</a> <a href="#topic+netclu_oslom">netclu_oslom</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(1000, 50), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_walktrap(net)

net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust2 &lt;- netclu_walktrap(net_bip, bipartite = TRUE)

</code></pre>

<hr>
<h2 id='nhclu_affprop'>Non-hierarchical clustering: Affinity Propagation</h2><span id='topic+nhclu_affprop'></span>

<h3>Description</h3>

<p>This function performs non-hierarchical clustering using the Affinity
Propagation algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_affprop(
  similarity,
  index = names(similarity)[3],
  seed = NULL,
  p = NA,
  q = NA,
  maxits = 1000,
  convits = 100,
  lam = 0.9,
  details = FALSE,
  nonoise = FALSE,
  K = NULL,
  prc = NULL,
  bimaxit = NULL,
  exact = NULL,
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhclu_affprop_+3A_similarity">similarity</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns should represent pairs of sites (or any pair of
nodes), and the subsequent column(s) should contain the similarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_index">index</code></td>
<td>
<p>The name or number of the similarity column to use. By default,
the third column name of <code>similarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_seed">seed</code></td>
<td>
<p>The seed for the random number generator used when
<code>nonoise = FALSE</code>.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_p">p</code></td>
<td>
<p>Input preference, which can be a vector specifying individual
preferences for each data point. If scalar, the same value is used for all
data points. If <code>NA</code>, exemplar preferences are initialized based on the
distribution of non-Inf values in the similarity matrix, controlled by <code>q</code>.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_q">q</code></td>
<td>
<p>If <code>p = NA</code>, exemplar preferences are initialized according to the
distribution of non-Inf values in the similarity matrix. By default, the
median is used. A value between 0 and 1 specifies the sample quantile,
where <code>q = 0.5</code> results in the median.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_maxits">maxits</code></td>
<td>
<p>The maximum number of iterations to execute.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_convits">convits</code></td>
<td>
<p>The algorithm terminates if the exemplars do not change for
<code>convits</code> iterations.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_lam">lam</code></td>
<td>
<p>The damping factor, a value in the range [0.5, 1). Higher values
correspond to heavier damping, which may help prevent oscillations.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_details">details</code></td>
<td>
<p>If <code>TRUE</code>, detailed information about the algorithm's progress
is stored in the output object.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_nonoise">nonoise</code></td>
<td>
<p>If <code>TRUE</code>, disables the addition of a small amount of noise to
the similarity object, which prevents degenerate cases.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_k">K</code></td>
<td>
<p>The desired number of clusters. If not <code>NULL</code>, the function
<a href="apcluster.html#topic+apclusterK-methods">apclusterK</a> is called.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_prc">prc</code></td>
<td>
<p>A parameter needed when <code>K</code> is not <code>NULL</code>. The algorithm stops if
the number of clusters deviates by less than <code>prc</code> percent from the desired
value <code>K</code>. Set to 0 to enforce exactly <code>K</code> clusters.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_bimaxit">bimaxit</code></td>
<td>
<p>A parameter needed when <code>K</code> is not <code>NULL</code>. Specifies the
maximum number of bisection steps to perform. No warning is issued if the
number of clusters remains outside the desired range.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_exact">exact</code></td>
<td>
<p>A flag indicating whether to compute the initial preference
range exactly.</p>
</td></tr>
<tr><td><code id="nhclu_affprop_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether to include the
original output of <a href="apcluster.html#topic+apcluster-methods">apcluster</a> in the result. Defaults
to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on the
<a href="https://cran.r-project.org/package=apcluster">apcluster</a>
package (<a href="apcluster.html#topic+apcluster-methods">apcluster</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five slots:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> describing the characteristics of the clustering
process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of objects associated with the clustering
procedure, such as original cluster objects
(if <code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, the <code>algorithm</code> slot includes the output of
<a href="apcluster.html#topic+apcluster-methods">apcluster</a>.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Frey B &amp; Dueck D (2007) Clustering by Passing Messages Between Data Points.
<em>Science</em> 315, 972-976.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_clara">nhclu_clara</a> <a href="#topic+nhclu_clarans">nhclu_clarans</a> <a href="#topic+nhclu_dbscan">nhclu_dbscan</a> <a href="#topic+nhclu_kmeans">nhclu_kmeans</a> <a href="#topic+nhclu_affprop">nhclu_affprop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat_1 &lt;- matrix(sample(0:1000, size = 10*12, replace = TRUE,
prob = 1/1:1001), 10, 12)
rownames(comat_1) &lt;- paste0("Site", 1:10)
colnames(comat_1) &lt;- paste0("Species", 1:12)
comat_1 &lt;- cbind(comat_1,
                 matrix(0, 10, 8,
                        dimnames = list(paste0("Site", 1:10),
                                        paste0("Species", 13:20))))
                                        
comat_2 &lt;- matrix(sample(0:1000, 
                         size = 10*12, 
                         replace = TRUE, 
                         prob = 1/1:1001), 
                  10, 12)
rownames(comat_2) &lt;- paste0("Site", 11:20)
colnames(comat_2) &lt;- paste0("Species", 9:20)
comat_2 &lt;- cbind(matrix(0, 10, 8, 
                        dimnames = list(paste0("Site", 11:20),
                                        paste0("Species", 1:8))),
                 comat_2)
                 
comat &lt;- rbind(comat_1, comat_2)

dissim &lt;- dissimilarity(comat, metric = "Simpson")
sim &lt;- dissimilarity_to_similarity(dissim)

clust1 &lt;- nhclu_affprop(sim)

clust2 &lt;- nhclu_affprop(sim, q = 1)

# Fixed number of clusters 
clust3 &lt;- nhclu_affprop(sim, K = 2, prc = 10, bimaxit = 20, exact = FALSE)

</code></pre>

<hr>
<h2 id='nhclu_clara'>Non-hierarchical clustering: CLARA</h2><span id='topic+nhclu_clara'></span>

<h3>Description</h3>

<p>This function performs non-hierarchical clustering based on
dissimilarity using partitioning around medoids, implemented via
the Clustering Large Applications (CLARA) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_clara(
  dissimilarity,
  index = names(dissimilarity)[3],
  seed = NULL,
  n_clust = c(1, 2, 3),
  maxiter = 0,
  initializer = "LAB",
  fasttol = 1,
  numsamples = 5,
  sampling = 0.25,
  independent = FALSE,
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhclu_clara_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns should represent pairs of sites (or any pair of
nodes), and the subsequent column(s) should contain the dissimilarity
indices.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_seed">seed</code></td>
<td>
<p>A value for the random number generator (set to <code>NULL</code> for random
initialization by default).</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> specifying the
desired number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_maxiter">maxiter</code></td>
<td>
<p>An <code>integer</code> defining the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_initializer">initializer</code></td>
<td>
<p>A <code>character</code> string, either <code>"BUILD"</code> (used in the
classic PAM algorithm) or <code>"LAB"</code> (Linear Approximate BUILD).</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_fasttol">fasttol</code></td>
<td>
<p>A positive <code>numeric</code> value defining the tolerance for fast
swapping behavior. Defaults to 1.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_numsamples">numsamples</code></td>
<td>
<p>A positive <code>integer</code> specifying the number of samples to
draw.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_sampling">sampling</code></td>
<td>
<p>A positive <code>numeric</code> value defining the sampling rate.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_independent">independent</code></td>
<td>
<p>A <code>boolean</code> indicating whether the previous
medoids are excluded in the next sample. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="nhclu_clara_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original output
of <a href="fastkmedoids.html#topic+fastclara">fastclara</a> should be included in the output.
Defaults to <code>TRUE</code> (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on <a href="https://cran.r-project.org/package=fastkmedoids">fastkmedoids</a>
package (<a href="fastkmedoids.html#topic+fastclara">fastclara</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five components:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the
clustering procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, the <code>algorithm</code> slot includes the output of
<a href="fastkmedoids.html#topic+fastclara">fastclara</a>.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Schubert E &amp; Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving the
PAM, CLARA, and CLARANS Algorithms. <em>Similarity Search and Applications</em>
11807, 171-187.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_clarans">nhclu_clarans</a> <a href="#topic+nhclu_dbscan">nhclu_dbscan</a> <a href="#topic+nhclu_kmeans">nhclu_kmeans</a> <a href="#topic+nhclu_pam">nhclu_pam</a> <a href="#topic+nhclu_affprop">nhclu_affprop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

#clust &lt;- nhclu_clara(dissim, index = "Simpson", n_clust = 5)
   
</code></pre>

<hr>
<h2 id='nhclu_clarans'>Non-hierarchical clustering: CLARANS</h2><span id='topic+nhclu_clarans'></span>

<h3>Description</h3>

<p>This function performs non-hierarchical clustering based on dissimilarity
using partitioning around medoids, implemented via the Clustering Large
Applications based on RANdomized Search (CLARANS) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_clarans(
  dissimilarity,
  index = names(dissimilarity)[3],
  seed = NULL,
  n_clust = c(1, 2, 3),
  numlocal = 2,
  maxneighbor = 0.025,
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhclu_clarans_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns should represent pairs of sites (or any pair of
nodes), and the subsequent column(s) should contain the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_seed">seed</code></td>
<td>
<p>A value for the random number generator (<code>NULL</code> for random
initialization by default).</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> specifying the
desired number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_numlocal">numlocal</code></td>
<td>
<p>An <code>integer</code> defining the number of local searches to perform.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_maxneighbor">maxneighbor</code></td>
<td>
<p>A positive <code>numeric</code> value defining the maximum number of
neighbors to consider for each local search.</p>
</td></tr>
<tr><td><code id="nhclu_clarans_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original output
of <a href="fastkmedoids.html#topic+fastclarans">fastclarans</a> should be included in the output.
Defaults to <code>TRUE</code> (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on <a href="https://cran.r-project.org/package=fastkmedoids">fastkmedoids</a>
package (<a href="fastkmedoids.html#topic+fastclarans">fastclarans</a>).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five components:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the clustering
procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, the <code>algorithm</code> slot includes the output of
<a href="fastkmedoids.html#topic+fastclarans">fastclarans</a>.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Schubert E &amp; Rousseeuw PJ (2019) Faster k-Medoids Clustering: Improving the
PAM, CLARA, and CLARANS Algorithms. <em>Similarity Search and Applications</em>
11807, 171-187.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_clara">nhclu_clara</a> <a href="#topic+nhclu_dbscan">nhclu_dbscan</a> <a href="#topic+nhclu_kmeans">nhclu_kmeans</a> <a href="#topic+nhclu_pam">nhclu_pam</a> <a href="#topic+nhclu_affprop">nhclu_affprop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

#clust &lt;- nhclu_clarans(dissim, index = "Simpson", n_clust = 5)
   
</code></pre>

<hr>
<h2 id='nhclu_dbscan'>Non-hierarchical clustering: DBSCAN</h2><span id='topic+nhclu_dbscan'></span>

<h3>Description</h3>

<p>This function performs non-hierarchical clustering based on dissimilarity
using the Density-Based Spatial Clustering of Applications with Noise
(DBSCAN) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_dbscan(
  dissimilarity,
  index = names(dissimilarity)[3],
  minPts = NULL,
  eps = NULL,
  plot = TRUE,
  algorithm_in_output = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhclu_dbscan_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns should represent pairs of sites (or any pair of
nodes), and the subsequent column(s) should contain the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_minpts">minPts</code></td>
<td>
<p>A <code>numeric</code> vector or a single <code>numeric</code> value specifying the
<code>minPts</code> argument of <code><a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a></code>. <code>minPts</code> is the minimum number of
points to form a dense region. By default, it is set to the natural logarithm
of the number of sites in <code>dissimilarity</code>. See Details for guidance on
choosing this parameter.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_eps">eps</code></td>
<td>
<p>A <code>numeric</code> vector or a single <code>numeric</code> value specifying the <code>eps</code>
argument of <code><a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a></code>. <code>eps</code> specifies how similar points should be
to each other to be considered part of a cluster. See Details for guidance on
choosing this parameter.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_plot">plot</code></td>
<td>
<p>A <code>boolean</code> indicating whether the k-nearest neighbor distance
plot should be displayed.</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original output
of <a href="dbscan.html#topic+dbscan">dbscan::dbscan</a> should be included in the output. Defaults to <code>TRUE</code> (see
Value).</p>
</td></tr>
<tr><td><code id="nhclu_dbscan_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>dbscan()</code> (see
<a href="dbscan.html#topic+dbscan">dbscan::dbscan</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DBSCAN (Density-Based Spatial Clustering of Applications with Noise)
algorithm clusters points based on the density of neighbors around each
data point. It requires two main arguments: <code>minPts</code>, the minimum number of
points to identify a core, and <code>eps</code>, the radius used to find neighbors.
</p>
<p><strong>Choosing minPts:</strong> This determines how many points are necessary to form a
cluster. For example, what is the minimum number of sites expected in a
bioregion? Choose a value sufficiently large for your dataset and expectations.
</p>
<p><strong>Choosing eps:</strong> This determines how similar sites should be to form a
cluster. If <code>eps</code> is too small, most points will be considered too distinct
and marked as noise. If <code>eps</code> is too large, clusters may merge. The value of
<code>eps</code> depends on <code>minPts</code>. It is recommended to choose <code>eps</code> by identifying
a knee in the k-nearest neighbor distance plot.
</p>
<p>By default, the function attempts to find a knee in this curve
automatically, but the result is uncertain. Users should inspect the graph
and modify <code>eps</code> accordingly. To explore <code>eps</code> values, run the function
initially without defining <code>eps</code>, review the recommendations, and adjust
as needed based on clustering results.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five components:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the clustering
procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, the <code>algorithm</code> slot includes the output of
<a href="dbscan.html#topic+dbscan">dbscan::dbscan</a>.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Hahsler M, Piekenbrock M &amp; Doran D (2019) Dbscan: Fast density-based
clustering with R. <em>Journal of Statistical Software</em>, 91(1), 1&ndash;30.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_clara">nhclu_clara</a> <a href="#topic+nhclu_clarans">nhclu_clarans</a> <a href="#topic+nhclu_kmeans">nhclu_kmeans</a> <a href="#topic+nhclu_pam">nhclu_pam</a> <a href="#topic+nhclu_affprop">nhclu_affprop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "all")

clust1 &lt;- nhclu_dbscan(dissim, index = "Simpson")
clust2 &lt;- nhclu_dbscan(dissim, index = "Simpson", eps = 0.2)
clust3 &lt;- nhclu_dbscan(dissim, index = "Simpson", minPts = c(5, 10, 15, 20),
     eps = c(.1, .15, .2, .25, .3))
     
</code></pre>

<hr>
<h2 id='nhclu_kmeans'>Non-hierarchical clustering: K-means analysis</h2><span id='topic+nhclu_kmeans'></span>

<h3>Description</h3>

<p>This function performs non-hierarchical clustering based on dissimilarity
using a k-means analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_kmeans(
  dissimilarity,
  index = names(dissimilarity)[3],
  seed = NULL,
  n_clust = c(1, 2, 3),
  iter_max = 10,
  nstart = 10,
  algorithm = "Hartigan-Wong",
  algorithm_in_output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhclu_kmeans_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns should represent pairs of sites (or any pair of
nodes), and the subsequent column(s) should contain the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_seed">seed</code></td>
<td>
<p>A value for the random number generator (<code>NULL</code> for random by
default).</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> value specifying
the requested number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_iter_max">iter_max</code></td>
<td>
<p>An <code>integer</code> specifying the maximum number of iterations for
the k-means method (see <a href="stats.html#topic+kmeans">kmeans</a>).</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_nstart">nstart</code></td>
<td>
<p>An <code>integer</code> specifying how many random sets of <code>n_clust</code>
should be selected as starting points for the k-means analysis
(see <a href="stats.html#topic+kmeans">kmeans</a>).</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>A <code>character</code> specifying the algorithm to use for k-means
(see <a href="stats.html#topic+kmeans">kmeans</a>). Available options are Hartigan-Wong, Lloyd,
Forgy, and MacQueen.</p>
</td></tr>
<tr><td><code id="nhclu_kmeans_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original
output of <a href="stats.html#topic+kmeans">kmeans</a> should be included in the output. Defaults
to <code>TRUE</code> (see Value).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method partitions data into k groups such that the sum of squares of
Euclidean distances from points to the assigned cluster centers is minimized.
K-means cannot be applied directly to dissimilarity or beta-diversity metrics
because these distances are not Euclidean. Therefore, it first requires
transforming the dissimilarity matrix using Principal Coordinate Analysis
(PCoA) with <a href="ape.html#topic+pcoa">pcoa</a>, and then applying k-means to the coordinates
of points in the PCoA.
</p>
<p>Because this additional transformation alters the initial dissimilarity
matrix, the partitioning around medoids method (<a href="#topic+nhclu_pam">nhclu_pam</a>) is preferred.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five components:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the clustering
procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, the <code>algorithm</code> slot includes the output of
<a href="stats.html#topic+kmeans">kmeans</a>.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_clara">nhclu_clara</a> <a href="#topic+nhclu_clarans">nhclu_clarans</a> <a href="#topic+nhclu_dbscan">nhclu_dbscan</a> <a href="#topic+nhclu_pam">nhclu_pam</a> <a href="#topic+nhclu_affprop">nhclu_affprop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)

dissim &lt;- dissimilarity(comat, metric = "all")

clust &lt;- nhclu_kmeans(dissim, n_clust = 2:10, index = "Simpson")

</code></pre>

<hr>
<h2 id='nhclu_pam'>Non-hierarchical clustering: Partitioning Around Medoids</h2><span id='topic+nhclu_pam'></span>

<h3>Description</h3>

<p>This function performs non-hierarchical clustering based on dissimilarity
using partitioning around medoids (PAM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclu_pam(
  dissimilarity,
  index = names(dissimilarity)[3],
  seed = NULL,
  n_clust = c(1, 2, 3),
  variant = "faster",
  nstart = 1,
  cluster_only = FALSE,
  algorithm_in_output = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nhclu_pam_+3A_dissimilarity">dissimilarity</code></td>
<td>
<p>The output object from <code><a href="#topic+dissimilarity">dissimilarity()</a></code> or
<code><a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity()</a></code>, or a <code>dist</code> object. If a <code>data.frame</code> is
used, the first two columns should represent pairs of sites (or any pair of
nodes), and the subsequent column(s) should contain the dissimilarity indices.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_index">index</code></td>
<td>
<p>The name or number of the dissimilarity column to use. By
default, the third column name of <code>dissimilarity</code> is used.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_seed">seed</code></td>
<td>
<p>A value for the random number generator (<code>NULL</code> for random by
default).</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_n_clust">n_clust</code></td>
<td>
<p>An <code>integer</code> vector or a single <code>integer</code> value specifying
the requested number(s) of clusters.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_variant">variant</code></td>
<td>
<p>A <code>character</code> string specifying the PAM variant to use.
Defaults to <code>faster</code>. Available options are <code>original</code>, <code>o_1</code>, <code>o_2</code>, <code>f_3</code>,
<code>f_4</code>, <code>f_5</code>, or <code>faster</code>. See <a href="cluster.html#topic+pam">pam</a> for more details.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_nstart">nstart</code></td>
<td>
<p>An <code>integer</code> specifying the number of random starts for the PAM
algorithm. Defaults to 1 (for the <code>faster</code> variant).</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_cluster_only">cluster_only</code></td>
<td>
<p>A <code>boolean</code> specifying whether only the clustering
results should be returned from the <a href="cluster.html#topic+pam">pam</a> function. Setting
this to <code>TRUE</code> makes the function more efficient.</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_algorithm_in_output">algorithm_in_output</code></td>
<td>
<p>A <code>boolean</code> indicating whether the original output
of <a href="cluster.html#topic+pam">pam</a> should be included in the result. Defaults to <code>TRUE</code>
(see Value).</p>
</td></tr>
<tr><td><code id="nhclu_pam_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>pam()</code> (see <a href="cluster.html#topic+pam">pam</a>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method partitions the data into the chosen number of clusters based on
the input dissimilarity matrix. It is more robust than k-means because it
minimizes the sum of dissimilarities between cluster centers (medoids) and
points assigned to the cluster. In contrast, k-means minimizes the sum of
squared Euclidean distances, which makes it unsuitable for dissimilarity
matrices that are not based on Euclidean distances.
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>bioregion.clusters</code> with five components:
</p>

<ol>
<li><p><strong>name</strong>: A <code>character</code> string containing the name of the algorithm.
</p>
</li>
<li><p><strong>args</strong>: A <code>list</code> of input arguments as provided by the user.
</p>
</li>
<li><p><strong>inputs</strong>: A <code>list</code> of characteristics of the clustering process.
</p>
</li>
<li><p><strong>algorithm</strong>: A <code>list</code> of all objects associated with the clustering
procedure, such as original cluster objects (only if
<code>algorithm_in_output = TRUE</code>).
</p>
</li>
<li><p><strong>clusters</strong>: A <code>data.frame</code> containing the clustering results.</p>
</li></ol>

<p>If <code>algorithm_in_output = TRUE</code>, the <code>algorithm</code> slot includes the output of
<a href="cluster.html#topic+pam">pam</a>.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Kaufman L &amp; Rousseeuw PJ (2009) Finding groups in data: An introduction to
cluster analysis. In &amp; Sons. JW (ed.), Finding groups in data: An
introduction to cluster analysis.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html">https://biorgeo.github.io/bioregion/articles/a4_2_non_hierarchical_clustering.html</a>.
</p>
<p>Associated functions:
<a href="#topic+nhclu_clara">nhclu_clara</a> <a href="#topic+nhclu_clarans">nhclu_clarans</a> <a href="#topic+nhclu_dbscan">nhclu_dbscan</a> <a href="#topic+nhclu_kmeans">nhclu_kmeans</a> <a href="#topic+nhclu_affprop">nhclu_affprop</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

comnet &lt;- mat_to_net(comat)
dissim &lt;- dissimilarity(comat, metric = "all")

clust &lt;- nhclu_pam(dissim, n_clust = 2:15, index = "Simpson")
   
</code></pre>

<hr>
<h2 id='similarity'>Compute similarity metrics between sites based on species composition</h2><span id='topic+similarity'></span>

<h3>Description</h3>

<p>This function generates a <code>data.frame</code> where each row provides one or
several similarity metrics between pairs of sites, based on a co-occurrence
<code>matrix</code> with sites as rows and species as columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(comat, metric = "Simpson", formula = NULL, method = "prodmat")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarity_+3A_comat">comat</code></td>
<td>
<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns.</p>
</td></tr>
<tr><td><code id="similarity_+3A_metric">metric</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string specifying
the metrics to compute (see Details). Available options are <code>"abc"</code>, <code>"ABC"</code>,
<code>"Jaccard"</code>, <code>"Jaccardturn"</code>, <code>"Sorensen"</code>, <code>"Simpson"</code>, <code>"Bray"</code>,
<code>"Brayturn"</code>, and <code>"Euclidean"</code>. If <code>"all"</code> is specified, all metrics will
be calculated. Can be set to <code>NULL</code> if <code>formula</code> is used.</p>
</td></tr>
<tr><td><code id="similarity_+3A_formula">formula</code></td>
<td>
<p>A <code>character</code> vector or a single <code>character</code> string specifying
custom formula(s) based on the <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code> quantities
(see Details). The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="similarity_+3A_method">method</code></td>
<td>
<p>A <code>character</code> string specifying the method to compute <code>abc</code>
(see Details). The default is <code>"prodmat"</code>, which is more efficient but
memory-intensive. Alternatively, <code>"loops"</code> is less memory-intensive but
slower.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>a</code> the number of species shared by a pair of sites, <code>b</code>
species only present in the first site and <code>c</code> species only present in
the second site.
</p>
<p>Jaccard = 1 - (b + c) / (a + b + c)
</p>
<p>Jaccardturn = 1 - 2min(b, c) / (a + 2min(b, c)) (Baselga, 2012)
</p>
<p>Sorensen = 1 - (b + c) / (2a + b + c)
</p>
<p>Simpson = 1 - min(b, c) / (a + min(b, c))
</p>
<p>If abundances data are available, Bray-Curtis and its turnover component can
also be computed with the following equation:
</p>
<p>Bray = 1 - (B + C) / (2A + B + C)
</p>
<p>Brayturn = 1 - min(B, C) / (A + min(B, C)) (Baselga, 2013)
</p>
<p>with <code>A</code> the sum of the lesser values for common species shared by a pair of
sites. <code>B</code> and <code>C</code> are the total number of specimens counted at both sites
minus <code>A</code>.
</p>
<p><code>formula</code> can be used to compute customized metrics with the terms
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, and <code>C</code>. For example
<code>formula = c("1 - pmin(b,c) / (a + pmin(b,c))", "1 - (B + C) / (2*A + B + C)")</code>
will compute the Simpson and Bray-Curtis similarity metrics, respectively.
Note that <code>pmin</code> is used in the Simpson formula because <code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>,
<code>B</code> and <code>C</code> are <code>numeric</code> vectors.
</p>
<p>Euclidean computes the Euclidean similarity between each pair of site
following this equation:
</p>
<p>Euclidean = 1 / (1 + d_ij)
</p>
<p>Where d_ij is the Euclidean distance between site i and
site j in terms of species composition.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with the additional class
<code>bioregion.pairwise.metric</code>, containing one or several similarity
metrics between pairs of sites. The first two columns represent the pairs of
sites. There is one column per similarity metric provided in <code>metric</code> and
<code>formula</code>, except for the <code>abc</code> and <code>ABC</code> metrics, which are stored in three
separate columns (one for each letter).
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>References</h3>

<p>Baselga A (2012) The Relationship between Species Replacement,
Dissimilarity Derived from Nestedness, and Nestedness.
<em>Global Ecology and Biogeography</em> 21, 1223&ndash;1232.
</p>
<p>Baselga A (2013) Separating the two components of abundance-based
dissimilarity: balanced changes in abundance vs. abundance gradients.
<em>Methods in Ecology and Evolution</em> 4, 552&ndash;557.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html">https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html</a>.
</p>
<p>Associated functions:
<a href="#topic+dissimilarity">dissimilarity</a> <a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

sim &lt;- similarity(comat, metric = c("abc", "ABC", "Simpson", "Brayturn"))

sim &lt;- similarity(comat, metric = "all",
formula = "1 - (b + c) / (a + b + c)")

</code></pre>

<hr>
<h2 id='similarity_to_dissimilarity'>Convert similarity metrics to dissimilarity metrics</h2><span id='topic+similarity_to_dissimilarity'></span>

<h3>Description</h3>

<p>This function converts a <code>data.frame</code> of similarity metrics between sites
into dissimilarity metrics (beta diversity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity_to_dissimilarity(similarity, include_formula = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="similarity_to_dissimilarity_+3A_similarity">similarity</code></td>
<td>
<p>The output object from <code><a href="#topic+similarity">similarity()</a></code> or
<code><a href="#topic+dissimilarity_to_similarity">dissimilarity_to_similarity()</a></code>.</p>
</td></tr>
<tr><td><code id="similarity_to_dissimilarity_+3A_include_formula">include_formula</code></td>
<td>
<p>A <code>boolean</code> indicating whether metrics based on custom
formula(s) should also be converted (see Details). The default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with additional class
<code>bioregion.pairwise.metric</code>, providing dissimilarity
metric(s) between each pair of sites based on a similarity object.
</p>


<h3>Note</h3>

<p>The behavior of this function changes depending on column names. Columns
<code>Site1</code> and <code>Site2</code> are copied identically. If there are columns called
<code>a</code>, <code>b</code>, <code>c</code>, <code>A</code>, <code>B</code>, <code>C</code> they will also be copied identically. If there
are columns based on your own formula (argument <code>formula</code> in <code><a href="#topic+similarity">similarity()</a></code>)
or not in the original list of similarity metrics (argument <code>metrics</code> in
<code><a href="#topic+similarity">similarity()</a></code>) and if the argument <code>include_formula</code> is set to <code>FALSE</code>,
they will also be copied identically. Otherwise there are going to be
converted like they other columns (default behavior).
</p>
<p>If a column is called <code>Euclidean</code>, its distance will be calculated based
on the following formula:
</p>
<p>Euclidean distance = (1 - Euclidean similarity) / Euclidean similarity
</p>
<p>Otherwise, all other columns will be transformed into dissimilarity with the
following formula:
</p>
<p>dissimilarity = 1 - similarity
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>)
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html">https://biorgeo.github.io/bioregion/articles/a3_pairwise_metrics.html</a>.
</p>
<p>Associated functions:
<a href="#topic+dissimilarity">dissimilarity</a> <a href="#topic+similarity_to_dissimilarity">similarity_to_dissimilarity</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 50, replace = TRUE,
prob = 1 / 1:1001), 5, 10)
rownames(comat) &lt;- paste0("Site", 1:5)
colnames(comat) &lt;- paste0("Species", 1:10)

simil &lt;- similarity(comat, metric = "all")
simil

dissimilarity &lt;- similarity_to_dissimilarity(simil)
dissimilarity

</code></pre>

<hr>
<h2 id='site_species_metrics'>Calculate contribution metrics of sites and species</h2><span id='topic+site_species_metrics'></span>

<h3>Description</h3>

<p>This function calculates metrics to assess the contribution of a given
species or site to its bioregion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_species_metrics(
  bioregionalization,
  comat,
  indices = c("rho"),
  net = NULL,
  site_col = 1,
  species_col = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="site_species_metrics_+3A_bioregionalization">bioregionalization</code></td>
<td>
<p>A <code>bioregion.clusters</code> object.</p>
</td></tr>
<tr><td><code id="site_species_metrics_+3A_comat">comat</code></td>
<td>
<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns.</p>
</td></tr>
<tr><td><code id="site_species_metrics_+3A_indices">indices</code></td>
<td>
<p>A <code>character</code> specifying the contribution metric to compute.
Available options are <code>rho</code>, <code>affinity</code>, <code>fidelity</code>, <code>indicator_value</code> and
<code>Cz</code>.</p>
</td></tr>
<tr><td><code id="site_species_metrics_+3A_net">net</code></td>
<td>
<p><code>NULL</code> by default. Required for <code>Cz</code> indices. A
<code>data.frame</code> where each row represents an interaction between two nodes
and an optional third column indicating the interaction's weight.</p>
</td></tr>
<tr><td><code id="site_species_metrics_+3A_site_col">site_col</code></td>
<td>
<p>A number indicating the position of the column containing
the sites in <code>net</code>. 1 by default.</p>
</td></tr>
<tr><td><code id="site_species_metrics_+3A_species_col">species_col</code></td>
<td>
<p>A number indicating the position of the column
containing the species in <code>net</code>. 2 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">\rho</code> metric is derived from Lenormand et al. (2019) with the
following formula:
</p>
<p><code class="reqn">\rho_{ij} = \frac{n_{ij} - \frac{n_i n_j}{n}}{\sqrt{\left(\frac{n - n_j}{
n-1}\right) \left(1-\frac{n_j}{n}\right) \frac{n_i n_j}{n}}}</code>
</p>
<p>where <code class="reqn">n</code> is the number of sites, <code class="reqn">n_i</code> is the number of sites in
which species <code class="reqn">i</code> is present, <code class="reqn">n_j</code> is the number of sites in
bioregion <code class="reqn">j</code>, and <code class="reqn">n_{ij}</code> is the number of occurrences of species
<code class="reqn">i</code> in sites of bioregion <code class="reqn">j</code>.
</p>
<p>Affinity <code class="reqn">A</code>, fidelity <code class="reqn">F</code>, and individual contributions
<code class="reqn">IndVal</code> describe how species are linked to their bioregions. These
metrics are described in Bernardo-Madrid et al. (2019):
</p>

<ul>
<li><p> Affinity of species to their region:
<code class="reqn">A_i = \frac{R_i}{Z}</code>, where <code class="reqn">R_i</code> is the occurrence/range size
of species <code class="reqn">i</code> in its associated bioregion, and <code class="reqn">Z</code> is the total
size (number of sites) of the bioregion. High affinity indicates that the
species occupies most sites in its bioregion.
</p>
</li>
<li><p> Fidelity of species to their region:
<code class="reqn">F_i = \frac{R_i}{D_i}</code>, where <code class="reqn">R_i</code> is the occurrence/range size
of species <code class="reqn">i</code> in its bioregion, and <code class="reqn">D_i</code> is its total range size.
High fidelity indicates that the species is not present in other regions.
</p>
</li>
<li><p> Indicator Value of species:
<code class="reqn">IndVal = F_i \cdot A_i</code>.
</p>
</li></ul>

<p><code>Cz</code> metrics are derived from Guimerà &amp; Amaral (2005):
</p>

<ul>
<li><p> Participation coefficient:
<code class="reqn">C_i = 1 - \sum_{s=1}^{N_M}{\left(\frac{k_{is}}{k_i}\right)^2}</code>, where
<code class="reqn">k_{is}</code> is the number of links of node <code class="reqn">i</code> to nodes in bioregion
<code class="reqn">s</code>, and <code class="reqn">k_i</code> is the total degree of node <code class="reqn">i</code>. A high value
means links are uniformly distributed; a low value means links are within
the node's bioregion.
</p>
</li>
<li><p> Within-bioregion degree z-score:
<code class="reqn">z_i = \frac{k_i - \overline{k_{si}}}{\sigma_{k_{si}}}</code>, where
<code class="reqn">k_i</code> is the number of links of node <code class="reqn">i</code> to nodes in its bioregion
<code class="reqn">s_i</code>, <code class="reqn">\overline{k_{si}}</code> is the average degree of nodes in
<code class="reqn">s_i</code>, and <code class="reqn">\sigma_{k_{si}}</code> is the standard deviation of degrees
in <code class="reqn">s_i</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>Bioregion</code>, <code>Species</code>, and the desired summary
statistics, or a list of <code>data.frame</code>s if <code>Cz</code> and other indices are
selected.
</p>


<h3>Author(s)</h3>

<p>Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>) <br />
Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>)
</p>


<h3>References</h3>

<p>Bernardo-Madrid R, Calatayud J, González‐Suárez M, Rosvall M, Lucas P,
Antonelli A &amp; Revilla E (2019) Human activity is altering the world’s
zoogeographical regions. <em>Ecology Letters</em> 22, 1297&ndash;1305.
</p>
<p>Guimerà R &amp; Amaral LAN (2005) Functional cartography of complex metabolic
networks. <em>Nature</em> 433, 895&ndash;900.
</p>
<p>Lenormand M, Papuga G, Argagnon O, Soubeyrand M, Alleaume S &amp; Luque S (2019)
Biogeographical network analysis of plant species distribution in the
Mediterranean region. <em>Ecology and Evolution</em> 9, 237&ndash;250.
</p>


<h3>See Also</h3>

<p>For more details illustrated with a practical example,
see the vignette:
<a href="https://biorgeo.github.io/bioregion/articles/a5_3_summary_metrics.html">https://biorgeo.github.io/bioregion/articles/a5_3_summary_metrics.html</a>.
</p>
<p>Associated functions:
<a href="#topic+bioregion_metrics">bioregion_metrics</a> <a href="#topic+bioregionalization_metrics">bioregionalization_metrics</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comat &lt;- matrix(sample(0:1000, size = 500, replace = TRUE, prob = 1/1:1001),
                20, 25)
rownames(comat) &lt;- paste0("Site",1:20)
colnames(comat) &lt;- paste0("Species",1:25)

dissim &lt;- dissimilarity(comat, metric = "Simpson")
clust1 &lt;- nhclu_kmeans(dissim, n_clust = 3, index = "Simpson")

net &lt;- similarity(comat, metric = "Simpson")
com &lt;- netclu_greedy(net)

site_species_metrics(bioregionalization = clust1, comat = comat,
indices = "rho")

# Contribution metrics
site_species_metrics(bioregionalization = com, comat = comat,
indices = c("rho", "affinity", "fidelity", "indicator_value"))

# Cz indices
net_bip &lt;- mat_to_net(comat, weight = TRUE)
clust_bip &lt;- netclu_greedy(net_bip, bipartite = TRUE)
site_species_metrics(bioregionalization = clust_bip, comat = comat, 
net = net_bip, indices = "Cz")

</code></pre>

<hr>
<h2 id='site_species_subset'>Extract a subset of sites or species from a <code>bioregion.clusters</code> object</h2><span id='topic+site_species_subset'></span>

<h3>Description</h3>

<p>This function extracts a subset of nodes based on their type (<code>"site"</code> or
<code>"species"</code>) from a <code>bioregion.clusters</code> object, which contains both types of
nodes (sites and species).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_species_subset(clusters, node_type = "site")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="site_species_subset_+3A_clusters">clusters</code></td>
<td>
<p>An object of class <code>bioregion.clusters</code>.</p>
</td></tr>
<tr><td><code id="site_species_subset_+3A_node_type">node_type</code></td>
<td>
<p>A <code>character</code> string indicating the type of nodes to
extract. Possible values are <code>"site"</code> or <code>"species"</code>. The default is
<code>"site"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bioregion.clusters</code> containing only the specified
node type (sites or species).
</p>


<h3>Note</h3>

<p>Network clustering functions (prefixed with <code>netclu_</code>) may return both types
of nodes (sites and species) when applied to bipartite networks (using the
<code>bipartite</code> argument). In such cases, the type of nodes included in the
output can be specified with the <code>return_node_type</code> argument. This function
allows you to extract a particular type of nodes (sites or species) from the
output and adjust the <code>return_node_type</code> attribute accordingly.
</p>


<h3>Author(s)</h3>

<p>Maxime Lenormand (<a href="mailto:maxime.lenormand@inrae.fr">maxime.lenormand@inrae.fr</a>) <br />
Pierre Denelle (<a href="mailto:pierre.denelle@gmail.com">pierre.denelle@gmail.com</a>) <br />
Boris Leroy (<a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net &lt;- data.frame(
  Site = c(rep("A", 2), rep("B", 3), rep("C", 2)),
  Species = c("a", "b", "a", "c", "d", "b", "d"),
  Weight = c(10, 100, 1, 20, 50, 10, 20)
)

clusters &lt;- netclu_louvain(net, lang = "igraph", bipartite = TRUE)

clusters_sites &lt;- site_species_subset(clusters, node_type = "site")

</code></pre>

<hr>
<h2 id='vegedf'>Spatial distribution of Mediterranean vegetation (data.frame)</h2><span id='topic+vegedf'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of 3,697 species in 715 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegedf
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 460,878 rows and 3 columns:
</p>

<dl>
<dt>Site</dt><dd><p>Unique site identifier (corresponding to the field ID of vegesp)</p>
</dd>
<dt>Species</dt><dd><p>Unique species identifier</p>
</dd>
<dt>Abundance</dt><dd><p>Species abundance</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.4718">doi:10.1002/ece3.4718</a>
</p>

<hr>
<h2 id='vegemat'>Spatial distribution of Mediterranean vegetation (co-occurrence matrix)</h2><span id='topic+vegemat'></span>

<h3>Description</h3>

<p>A dataset containing the abundance of each of the 3,697 species in each of
the 715 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegemat
</code></pre>


<h3>Format</h3>

<p>A co-occurrence <code>matrix</code> with sites as rows and species as
columns. Each element of the matrix
represents the abundance of the species in the site.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.4718">doi:10.1002/ece3.4718</a>
</p>

<hr>
<h2 id='vegesf'>Spatial distribution of Mediterranean vegetation (spatial grid)</h2><span id='topic+vegesf'></span>

<h3>Description</h3>

<p>A dataset containing the geometry of the 715 sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegesf
</code></pre>


<h3>Format</h3>

<p>A
</p>

<dl>
<dt>ID</dt><dd><p>Unique site identifier</p>
</dd>
<dt>geometry</dt><dd><p>Geometry of the site</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1002/ece3.4718">doi:10.1002/ece3.4718</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
