<!DOCTYPE html><html><head><title>Help for package LSVAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LSVAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#f.func'><p>Main loss function for quardratic loss</p></a></li>
<li><a href='#fista.LpS'><p>A function to solve low rank plus sparse model estimation using FISTA algorithm</p></a></li>
<li><a href='#gradf.func'><p>Gradient function of quardratic loss</p></a></li>
<li><a href='#nuclear.pen'><p>Nuclear norm penalty for low-rank component</p></a></li>
<li><a href='#obj.func'><p>Objective function</p></a></li>
<li><a href='#plot_network'><p>plot sparse component for use igraph and network layout</p></a></li>
<li><a href='#prox.nuclear.func'><p>Proximal function with nuclear norm penalty updating</p></a></li>
<li><a href='#prox.sparse.func'><p>Proximal function with l1-norm penalty updating</p></a></li>
<li><a href='#Q.func'><p>An auxiliary function in FISTA algorithm</p></a></li>
<li><a href='#shrinkage'><p>Shrinkage function for sparse soft-thresholding</p></a></li>
<li><a href='#shrinkage.lr'><p>Shrinkage function for low-rank soft-thresholding</p></a></li>
<li><a href='#sparse.pen'><p>L1-norm penalty for sparse component</p></a></li>
<li><a href='#summary.LSVAR'><p>Summary of LSVAR S3 class</p></a></li>
<li><a href='#testVAR'><p>Function to generate a VAR process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Low Rank Plus Sparse Structured Vector
Auto-Regressive (VAR) Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Peiliang Bai [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peiliang Bai &lt;baipl92@ufl.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of estimation algorithm of low rank plus sparse structured VAR model by using Fast Iterative Shrinkage-Thresholding Algorithm (FISTA). It relates to the algorithm in Sumanta, Li, and Michailidis (2019) &lt;<a href="https://doi.org/10.1109%2FTSP.2018.2887401">doi:10.1109/TSP.2018.2887401</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, mvtnorm, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-25 15:55:28 UTC; baipl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-26 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='f.func'>Main loss function for quardratic loss</h2><span id='topic+f.func'></span>

<h3>Description</h3>

<p>Main loss function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.func(x, A, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f.func_+3A_x">x</code></td>
<td>
<p>Model parameters</p>
</td></tr>
<tr><td><code id="f.func_+3A_a">A</code></td>
<td>
<p>Design matrix with size of n by p</p>
</td></tr>
<tr><td><code id="f.func_+3A_b">b</code></td>
<td>
<p>Correspond vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of objective function
</p>

<hr>
<h2 id='fista.LpS'>A function to solve low rank plus sparse model estimation using FISTA algorithm</h2><span id='topic+fista.LpS'></span>

<h3>Description</h3>

<p>A function to solve low rank plus sparse model estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fista.LpS(
  data,
  lambda,
  mu,
  alpha_L = 0.25,
  niter = 100,
  backtracking = TRUE,
  x.true = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fista.LpS_+3A_data">data</code></td>
<td>
<p>A numeric dataset with size of n by p</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_lambda">lambda</code></td>
<td>
<p>A positive numeric value, indicating the tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_mu">mu</code></td>
<td>
<p>A positive numeric value, indicating the tuning parameter for low rank component</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_alpha_l">alpha_L</code></td>
<td>
<p>The constraint coefficient of low rank component, default is 0.25</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations required for FISTA</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_backtracking">backtracking</code></td>
<td>
<p>A boolean argument, indicating that use backtracking in the FISTA</p>
</td></tr>
<tr><td><code id="fista.LpS_+3A_x.true">x.true</code></td>
<td>
<p>A p by p matrix, the true model parameter. Only available for simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A S3 object of class <code>LSVAR</code>, including
</p>

<dl>
<dt>est_phi</dt><dd><p>estimated model parameter</p>
</dd>
<dt>sparse.comp</dt><dd><p>Estimated sparse component</p>
</dd>
<dt>lr.comp</dt><dd><p>Estimated low-rank component</p>
</dd>
<dt>obj.val</dt><dd><p>Values of objective function</p>
</dd>
<dt>rel.err</dt><dd><p>Relative errors compared with the true model parameters if available</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 300
p &lt;- 20
try &lt;- testVAR(n, p, struct = "LS", signal = 0.75, rank = 2,
               singular_vals = c(1, 0.8))
data &lt;- as.matrix(try$series)
lambda &lt;- 0.1; mu &lt;- 1
fit &lt;- fista.LpS(data, lambda = lambda, mu = mu, x.true = try$model_param)
summary(fit, threshold = 0.2)
</code></pre>

<hr>
<h2 id='gradf.func'>Gradient function of quardratic loss</h2><span id='topic+gradf.func'></span>

<h3>Description</h3>

<p>Gradient function of quardratic loss
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradf.func(x, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradf.func_+3A_x">x</code></td>
<td>
<p>A vector, or matrix, indicating the model parameter</p>
</td></tr>
<tr><td><code id="gradf.func_+3A_ata">AtA</code></td>
<td>
<p>A p by p Gram matrix for corresponding design matrix A</p>
</td></tr>
<tr><td><code id="gradf.func_+3A_atb">Atb</code></td>
<td>
<p>An inner product for design matrix A and corresponding matrix (vector) b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of gradients
</p>

<hr>
<h2 id='nuclear.pen'>Nuclear norm penalty for low-rank component</h2><span id='topic+nuclear.pen'></span>

<h3>Description</h3>

<p>Nuclear norm penalty for low-rank component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuclear.pen(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nuclear.pen_+3A_x">x</code></td>
<td>
<p>Model parameter</p>
</td></tr>
<tr><td><code id="nuclear.pen_+3A_lambda">lambda</code></td>
<td>
<p>Tuning parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of nuclear norm penalty term
</p>

<hr>
<h2 id='obj.func'>Objective function</h2><span id='topic+obj.func'></span>

<h3>Description</h3>

<p>objective function, main loss function and penalties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.func(x.lr, x.sparse, A, b, lambda, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.func_+3A_x.lr">x.lr</code></td>
<td>
<p>low-rank component</p>
</td></tr>
<tr><td><code id="obj.func_+3A_x.sparse">x.sparse</code></td>
<td>
<p>sparse component</p>
</td></tr>
<tr><td><code id="obj.func_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="obj.func_+3A_b">b</code></td>
<td>
<p>correspond vector</p>
</td></tr>
<tr><td><code id="obj.func_+3A_lambda">lambda</code></td>
<td>
<p>a tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="obj.func_+3A_mu">mu</code></td>
<td>
<p>a tuning parameter for low-rank component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of objective function
</p>

<hr>
<h2 id='plot_network'>plot sparse component for use igraph and network layout</h2><span id='topic+plot_network'></span>

<h3>Description</h3>

<p>Plot a network to illustrate the estimated sparse component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_network(mat, threshold = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_network_+3A_mat">mat</code></td>
<td>
<p>a p by p matrix, indicating the sparse component</p>
</td></tr>
<tr><td><code id="plot_network_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for presenting the edges in the network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network plot for the sparse component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
est_mats &lt;- matrix(rnorm(400, 0, 1), 20, 20)
plot_network(est_mats, threshold = 0.1)
</code></pre>

<hr>
<h2 id='prox.nuclear.func'>Proximal function with nuclear norm penalty updating</h2><span id='topic+prox.nuclear.func'></span>

<h3>Description</h3>

<p>Proximal function with nuclear norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prox.nuclear.func(w1, y, A, b, L, lambda, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prox.nuclear.func_+3A_w1">w1</code></td>
<td>
<p>previously updated model parameter</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_y">y</code></td>
<td>
<p>updated model parameter</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_b">b</code></td>
<td>
<p>correspond vector, or matrix</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_l">L</code></td>
<td>
<p>learning rate</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for low-rank component</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix of design matrix A</p>
</td></tr>
<tr><td><code id="prox.nuclear.func_+3A_atb">Atb</code></td>
<td>
<p>inner product of design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of proximal function with nuclear norm penalty
</p>

<hr>
<h2 id='prox.sparse.func'>Proximal function with l1-norm penalty updating</h2><span id='topic+prox.sparse.func'></span>

<h3>Description</h3>

<p>Proximal function with l1-norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prox.sparse.func(w1, y, A, b, L, lambda, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prox.sparse.func_+3A_w1">w1</code></td>
<td>
<p>previously updated model parameter</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_y">y</code></td>
<td>
<p>updated model parameter</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_a">A</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_b">b</code></td>
<td>
<p>correspond vector, or matrix</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_l">L</code></td>
<td>
<p>learning rate</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter for sparse component</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix of design matrix A</p>
</td></tr>
<tr><td><code id="prox.sparse.func_+3A_atb">Atb</code></td>
<td>
<p>inner product of design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of proximal function with l1-norm penalty
</p>

<hr>
<h2 id='Q.func'>An auxiliary function in FISTA algorithm</h2><span id='topic+Q.func'></span>

<h3>Description</h3>

<p>Auxiliary function for FISTA implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q.func(x, y, A, b, L, AtA, Atb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q.func_+3A_x">x</code></td>
<td>
<p>Model parameter for previous update</p>
</td></tr>
<tr><td><code id="Q.func_+3A_y">y</code></td>
<td>
<p>Model parameter for updating</p>
</td></tr>
<tr><td><code id="Q.func_+3A_a">A</code></td>
<td>
<p>An n by p design matrix</p>
</td></tr>
<tr><td><code id="Q.func_+3A_b">b</code></td>
<td>
<p>A correspond vector, or matrix with size of n by 1 or n by p</p>
</td></tr>
<tr><td><code id="Q.func_+3A_l">L</code></td>
<td>
<p>Learning rate</p>
</td></tr>
<tr><td><code id="Q.func_+3A_ata">AtA</code></td>
<td>
<p>Gram matrix for design matrix A</p>
</td></tr>
<tr><td><code id="Q.func_+3A_atb">Atb</code></td>
<td>
<p>Inner product for design matrix A and correspond vector b</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of function Q
</p>

<hr>
<h2 id='shrinkage'>Shrinkage function for sparse soft-thresholding</h2><span id='topic+shrinkage'></span>

<h3>Description</h3>

<p>Shrinkage function for sparse soft-thresholding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkage(y, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrinkage_+3A_y">y</code></td>
<td>
<p>A matrix, or a vector for thresholding</p>
</td></tr>
<tr><td><code id="shrinkage_+3A_tau">tau</code></td>
<td>
<p>A positive number, threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thresholded matrix, or vector
</p>

<hr>
<h2 id='shrinkage.lr'>Shrinkage function for low-rank soft-thresholding</h2><span id='topic+shrinkage.lr'></span>

<h3>Description</h3>

<p>Shrinkage function for low-rank soft-thresholding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkage.lr(y, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shrinkage.lr_+3A_y">y</code></td>
<td>
<p>A matrix, or a vector for thresholding</p>
</td></tr>
<tr><td><code id="shrinkage.lr_+3A_tau">tau</code></td>
<td>
<p>A positive number, threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A thresholded matrix, or vector
</p>

<hr>
<h2 id='sparse.pen'>L1-norm penalty for sparse component</h2><span id='topic+sparse.pen'></span>

<h3>Description</h3>

<p>L1-norm penalty for sparse component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse.pen(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse.pen_+3A_x">x</code></td>
<td>
<p>Model parameter</p>
</td></tr>
<tr><td><code id="sparse.pen_+3A_lambda">lambda</code></td>
<td>
<p>Tuning parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of l1-norm penalty term
</p>

<hr>
<h2 id='summary.LSVAR'>Summary of LSVAR S3 class</h2><span id='topic+summary.LSVAR'></span>

<h3>Description</h3>

<p>summary function for S3 class for the fitting result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LSVAR'
summary(object, threshold = 0.2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.LSVAR_+3A_object">object</code></td>
<td>
<p>the S3 class object of <code>LSVAR</code></p>
</td></tr>
<tr><td><code id="summary.LSVAR_+3A_threshold">threshold</code></td>
<td>
<p>the threshold for sparse component visualization</p>
</td></tr>
<tr><td><code id="summary.LSVAR_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of summary for the S3 result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 300
p &lt;- 20
try &lt;- testVAR(n, p, struct = "LS", signal = 0.75, rank = 2,
               singular_vals = c(1, 0.8))
data &lt;- as.matrix(try$series)
lambda &lt;- 0.1; mu &lt;- 1
fit &lt;- fista.LpS(data, lambda = lambda, mu = mu, x.true = try$model_param)
summary(fit, threshold = 0.2)
</code></pre>

<hr>
<h2 id='testVAR'>Function to generate a VAR process</h2><span id='topic+testVAR'></span>

<h3>Description</h3>

<p>A function to generate synthetic time series process based on the given structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testVAR(
  n,
  p,
  struct = c("sparse", "low rank", "LS")[1],
  sp_density = 0.1,
  signal = NULL,
  rank = NULL,
  singular_vals,
  spectral_radius = 0.9,
  sigma = NULL,
  skip = 50,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testVAR_+3A_n">n</code></td>
<td>
<p>the length of time series</p>
</td></tr>
<tr><td><code id="testVAR_+3A_p">p</code></td>
<td>
<p>the number of multivariate time series</p>
</td></tr>
<tr><td><code id="testVAR_+3A_struct">struct</code></td>
<td>
<p>a character string indicating the structure of the transition matrix, here are three options:
sparse, low rank and LS (low rank plus sparse)</p>
</td></tr>
<tr><td><code id="testVAR_+3A_sp_density">sp_density</code></td>
<td>
<p>a numeric value, indicating the sparsity density of sparse components, default is 0.1</p>
</td></tr>
<tr><td><code id="testVAR_+3A_signal">signal</code></td>
<td>
<p>a numeric value, indicating the magnitude of transition matrix</p>
</td></tr>
<tr><td><code id="testVAR_+3A_rank">rank</code></td>
<td>
<p>a positive integer, the rank for low rank component</p>
</td></tr>
<tr><td><code id="testVAR_+3A_singular_vals">singular_vals</code></td>
<td>
<p>a numeric vector, indicating the singular values for the low rank component, the length of
singular value must equal to the rank</p>
</td></tr>
<tr><td><code id="testVAR_+3A_spectral_radius">spectral_radius</code></td>
<td>
<p>a numeric value, controlling the stability of the process, default is 0.9</p>
</td></tr>
<tr><td><code id="testVAR_+3A_sigma">sigma</code></td>
<td>
<p>a numeric matrix, indicating the covariance matrix of noise term</p>
</td></tr>
<tr><td><code id="testVAR_+3A_skip">skip</code></td>
<td>
<p>a numeric value, indicating the number of skipped time points in the beginning of the process</p>
</td></tr>
<tr><td><code id="testVAR_+3A_seed">seed</code></td>
<td>
<p>an integer, indicating the seed for random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, including
</p>

<dl>
<dt>series</dt><dd><p>the generated time series</p>
</dd>
<dt>noise</dt><dd><p>the noise term</p>
</dd>
<dt>model_param</dt><dd><p>true transition matrix</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 300; p &lt;- 15
signal &lt;- 0.75
rank &lt;- 3
singular_vals &lt;- c(1, 0.75, 0.5)
try &lt;- testVAR(n, p, struct = "LS", signal = signal, rank = rank,
               singular_vals = singular_vals)
data &lt;- as.matrix(try$series)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
