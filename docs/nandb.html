<!DOCTYPE html><html><head><title>Help for package nandb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nandb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brightness'><p>Calculate brightness from image series.</p></a></li>
<li><a href='#brightness_folder'><p>Brightness calculations for every image in a folder.</p></a></li>
<li><a href='#brightness_timeseries'><p>Create a brightness time-series.</p></a></li>
<li><a href='#brightness_timeseries_folder'><p>Brightness time-series calculations for every image in a folder.</p></a></li>
<li><a href='#cc_brightness'><p>Cross-correlated brightness.</p></a></li>
<li><a href='#cc_brightness_folder'><p>Cross-correlated brightness calculations for every image in a folder.</p></a></li>
<li><a href='#cc_brightness_timeseries'><p>Create a cross-correlated brightness time-series.</p></a></li>
<li><a href='#cc_brightness_timeseries_folder'><p>Cross-correlated brightness time-series calculations for every image in a</p>
folder.</a></li>
<li><a href='#cc_number'><p>Cross-correlated number.</p></a></li>
<li><a href='#cc_number_folder'><p>Cross-correlated number calculations for every image in a folder.</p></a></li>
<li><a href='#cc_number_timeseries'><p>Create a cross-correlated number time-series.</p></a></li>
<li><a href='#cc_number_timeseries_folder'><p>Cross-correlated number time-series calculations for every image in a</p>
folder.</a></li>
<li><a href='#cc-nb-img-classes'><p>Cross-correlated number and brightness image classes.</p></a></li>
<li><a href='#cc-nb-ts-img-classes'><p>Cross-correlated number and brightness time series image classes.</p></a></li>
<li><a href='#cross_var'><p>Calculate the <em>cross-variance</em> of two vectors.</p></a></li>
<li><a href='#cross_var_pillars'><p>Calculate the <em>cross-variance</em> of corresponding pillars of 3d arrays.</p></a></li>
<li><a href='#matrix_raster_plot'><p>Make a raster plot of a matrix.</p></a></li>
<li><a href='#median_filter'><p>Smooth and median filters with options for handling NAs.</p></a></li>
<li><a href='#nandb'><p>nandb: Number and brightness in R.</p></a></li>
<li><a href='#nb-img-classes'><p>Number and brightness image classes.</p></a></li>
<li><a href='#nb-ts-img-classes'><p>Number and brightness time series image classes.</p></a></li>
<li><a href='#number'><p>Calculate number from image series.</p></a></li>
<li><a href='#number_folder'><p>Number calculations for every image in a folder.</p></a></li>
<li><a href='#number_timeseries'><p>Create a number time-series.</p></a></li>
<li><a href='#number_timeseries_folder'><p>Number time-series calculations for every image in a folder.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Number and Brightness Image Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rory Nolan &lt;rorynoolan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculation of molecular number and brightness from
    fluorescence microscopy image series. The software was published in a
    2016 paper &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtx434">doi:10.1093/bioinformatics/btx434</a>&gt;. The seminal paper for
    the technique is Digman et al. 2008 &lt;<a href="https://doi.org/10.1529%2Fbiophysj.107.114645">doi:10.1529/biophysj.107.114645</a>&gt;.
    A review of the technique was published in 2017
    &lt;<a href="https://doi.org/10.1016%2Fj.ymeth.2017.12.001">doi:10.1016/j.ymeth.2017.12.001</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rorynolan.github.io/nandb/">https://rorynolan.github.io/nandb/</a>,
<a href="https://github.com/rorynolan/nandb">https://github.com/rorynolan/nandb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rorynolan/nandb/issues">https://github.com/rorynolan/nandb/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, autothresholdr (&ge; 1.3.11), BBmisc, checkmate (&ge;
1.9.3), detrendr (&ge; 0.6.12), dplyr, filesstrings (&ge; 3.2),
ggplot2, glue (&ge; 1.3), ijtiff (&ge; 2.2), magrittr (&ge; 1.5),
purrr, Rcpp (&ge; 1.0.1), reshape2, rlang (&ge; 0.3.3), stringr (&ge;
1.4), utils, viridis, withr (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>abind, covr, gridExtra, knitr, matrixStats (&ge; 0.50), pacman,
rmarkdown, spelling, testthat (&ge; 2.1), tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-16 01:12:41 UTC; rnolan</td>
</tr>
<tr>
<td>Author:</td>
<td>Rory Nolan <a href="https://orcid.org/0000-0002-5239-4043"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Luis Alvarez <a href="https://orcid.org/0000-0003-1316-1906"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph],
  Sergi Padilla-Parra
    <a href="https://orcid.org/0000-0002-8010-9481"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, ths,
    cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-16 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='brightness'>Calculate brightness from image series.</h2><span id='topic+brightness'></span>

<h3>Description</h3>

<p>Given a time stack of images, <code>brightness()</code> performs a calculation of the
brightness for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brightness(
  img,
  def,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brightness_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="brightness_+3A_def">def</code></td>
<td>
<p>A character. Which definition of brightness do you want to use,
<code>"B"</code> or <code>"epsilon"</code>?</p>
</td></tr>
<tr><td><code id="brightness_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and brightness calculations.</p>
</td></tr>
<tr><td><code id="brightness_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="brightness_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
<tr><td><code id="brightness_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="brightness_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="brightness_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, the brightness image.
</p>


<h3>References</h3>

<p>Digman MA, Dalal R, Horwitz AF, Gratton E. Mapping the Number of
Molecules and Brightness in the Laser Scanning Microscope. Biophysical
Journal. 2008;94(6):2320-2332. doi: <a href="https://doi.org/10.1529/biophysj.107.114645">10.1529/biophysj.107.114645</a>.
</p>
<p>Dalal, RB, Digman, MA, Horwitz, AF, Vetri, V, Gratton, E (2008).
Determination of particle number and brightness using a laser scanning
confocal microscope operating in the analog mode. Microsc. Res. Tech., 71,
1:69-81. doi: <a href="https://doi.org/10.1002/jemt.20526">10.1002/jemt.20526</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::display(img[, , 1, 1])
b &lt;- brightness(img, "e", thresh = "Huang")
b &lt;- brightness(img, "B", thresh = "tri")

</code></pre>

<hr>
<h2 id='brightness_folder'>Brightness calculations for every image in a folder.</h2><span id='topic+brightness_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+brightness">brightness()</a></code> calculations on all tif images in a folder and save the
resulting brightness images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brightness_folder(
  folder_path = ".",
  def,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brightness_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_def">def</code></td>
<td>
<p>A character. Which definition of brightness do you want to use,
<code>"B"</code> or <code>"epsilon"</code>?</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and brightness calculations.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+number">number()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::write_tif(img, "img1.tif")
ijtiff::write_tif(img, "img2.tif")
brightness_folder(def = "B", thresh = "Huang")

## End(Not run)
</code></pre>

<hr>
<h2 id='brightness_timeseries'>Create a brightness time-series.</h2><span id='topic+brightness_timeseries'></span>

<h3>Description</h3>

<p>Given a stack of images <code>img</code>, use the first <code>frames_per_set</code> of them to
create one brightness image, the next <code>frames_per_set</code> of them to create the
next brightness image and so on to get a time-series of brightness images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brightness_timeseries(
  img,
  def,
  frames_per_set,
  overlap = FALSE,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brightness_timeseries_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_def">def</code></td>
<td>
<p>A character. Which definition of brightness do you want to use,
<code>"B"</code> or <code>"epsilon"</code>?</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive brightnesses.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate number are
overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and brightness calculations.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may discard some images, for example if 175 frames are in the input and
<code>frames_per_set = 50</code>, then the last 25 are discarded. If detrending is
selected, it is performed on the whole image stack before the sectioning is
done for calculation of numbers.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+brightness_ts_img">brightness_ts_img</a>.
</p>
<ul>
<li><p> If <code>img</code> is 3-dimensional (i.e. 1-channel), a 3-dimensional
array <code>arr</code> is returned with <code>arr[y, x, t]</code> being pixel <code class="reqn">(x, y)</code> of the
<code class="reqn">t</code>th brightness image in the brightness time series. </p>
</li>
<li><p> If  <code>img</code>
is 4-dimensional (i.e. 2-channel), a 4-dimensional array <code>arr</code> is returned
with <code>arr[y, x, c, t]</code> being pixel <code class="reqn">(x, y)</code> of the <code class="reqn">c</code>th channel of
the <code class="reqn">t</code>th brightness image in the brightness time series.</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+brightness">brightness()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
bts &lt;- brightness_timeseries(img, "e", frames_per_set = 20, thresh = "Huang")

</code></pre>

<hr>
<h2 id='brightness_timeseries_folder'>Brightness time-series calculations for every image in a folder.</h2><span id='topic+brightness_timeseries_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+brightness_timeseries">brightness_timeseries()</a></code> calculations on all tif images in a folder
and save the resulting number images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brightness_timeseries_folder(
  folder_path = ".",
  def,
  frames_per_set,
  overlap = FALSE,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brightness_timeseries_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_def">def</code></td>
<td>
<p>A character. Which definition of brightness do you want to use,
<code>"B"</code> or <code>"epsilon"</code>?</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive brightnesses.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate number are
overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and brightness calculations.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="brightness_timeseries_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brightness_timeseries">brightness_timeseries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::write_tif(img, "img1.tif")
ijtiff::write_tif(img, "img2.tif")
brightness_timeseries_folder(def = "e", thresh = "tri", frames_per_set = 20)

## End(Not run)
</code></pre>

<hr>
<h2 id='cc_brightness'>Cross-correlated brightness.</h2><span id='topic+cc_brightness'></span>

<h3>Description</h3>

<p>Given a time stack of images  and two channels, calculate the
cross-correlated brightness of those two channels for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_brightness(
  img,
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_brightness_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array of images indexed by <code>img[y, x, channel, frame]</code> (an object of class <a href="ijtiff.html#topic+ijtiff_img">ijtiff::ijtiff_img</a>). The image to perform the
calculation on. To perform this on a file that has not yet been read in,
set this argument to the path to that file (a string).</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated brightness (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated brightness image using
<code><a href="#topic+smooth_filter">smooth_filter()</a></code> or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are
invoked here with a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code> for either channel gives no thresholding for that
channel. If you want to smooth/median filter the cross-correlated
brightness image in a different way, first calculate the cross-correlated
brightnesses without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result.</p>
</td></tr>
<tr><td><code id="cc_brightness_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix, the cross-correlated brightness image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "two_ch.tif",
  package = "nandb"
))
ijtiff::display(detrendr::mean_pillars(img[, , 1, ]))
ijtiff::display(detrendr::mean_pillars(img[, , 2, ]))
b &lt;- brightness(img, def = "e", thresh = "Huang", filt = "median")
ijtiff::display(b[, , 1, 1])
ijtiff::display(b[, , 2, 1])
cc_b &lt;- cc_brightness(img, thresh = "Huang")
ijtiff::display(cc_b[, , 1, 1])

</code></pre>

<hr>
<h2 id='cc_brightness_folder'>Cross-correlated brightness calculations for every image in a folder.</h2><span id='topic+cc_brightness_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+cc_brightness">cc_brightness()</a></code> calculations on all TIFF images in a folder and
save the resulting images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_brightness_folder(
  folder_path = ".",
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = detrend,
  quick = quick,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_brightness_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated brightness (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated brightness image using
<code><a href="#topic+smooth_filter">smooth_filter()</a></code> or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are
invoked here with a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code> for either channel gives no thresholding for that
channel. If you want to smooth/median filter the cross-correlated
brightness image in a different way, first calculate the cross-correlated
brightnesses without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result.</p>
</td></tr>
<tr><td><code id="cc_brightness_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
ijtiff::write_tif(img, "a.tif")
ijtiff::write_tif(img, "ab.tif")
cc_brightness_folder()
list.files()

## End(Not run)
</code></pre>

<hr>
<h2 id='cc_brightness_timeseries'>Create a cross-correlated brightness time-series.</h2><span id='topic+cc_brightness_timeseries'></span>

<h3>Description</h3>

<p>Given a stack of images <code>img</code>, use the first <code>frames_per_set</code> of them to
create one cross-correlated brightness image, the next <code>frames_per_set</code> of
them to create the next and so on to get a time-series of cross-correlated
brightness images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_brightness_timeseries(
  img,
  frames_per_set,
  overlap = FALSE,
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_brightness_timeseries_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array of images indexed by <code>img[y, x, channel, frame]</code> (an object of class <a href="ijtiff.html#topic+ijtiff_img">ijtiff::ijtiff_img</a>). The image to perform the
calculation on. To perform this on a file that has not yet been read in,
set this argument to the path to that file (a string).</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive cross-correlated brightnesses.
</p>
<p>This may discard some images, for example if 175 frames are in the input and
<code>frames_per_set = 50</code>, then the last 25 are discarded. If bleaching or/and
thresholding are selected, they are performed on the whole image stack before
the sectioning is done for calculation of cross-correlated brightnesses.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate brightness
are overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated brightness (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated brightness image using
<code><a href="#topic+smooth_filter">smooth_filter()</a></code> or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are
invoked here with a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code> for either channel gives no thresholding for that
channel. If you want to smooth/median filter the cross-correlated
brightness image in a different way, first calculate the cross-correlated
brightnesses without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array where the <code class="reqn">i</code>th slice is the <code class="reqn">i</code>th cross-correlated
brightness image.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brightness">brightness()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "two_ch.tif",
  package = "nandb"
))
cc_bts &lt;- cc_brightness_timeseries(img, 10,
  thresh = "Huang",
  filt = "median", parallel = 2
)
ijtiff::display(cc_bts[, , 1, 1])

</code></pre>

<hr>
<h2 id='cc_brightness_timeseries_folder'>Cross-correlated brightness time-series calculations for every image in a
folder.</h2><span id='topic+cc_brightness_timeseries_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+cc_brightness_timeseries">cc_brightness_timeseries()</a></code> calculations on all tif images in a
folder and save the resulting images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_brightness_timeseries_folder(
  folder_path = ".",
  frames_per_set,
  overlap = FALSE,
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = detrend,
  quick = quick,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive cross-correlated brightnesses.
</p>
<p>This may discard some images, for example if 175 frames are in the input and
<code>frames_per_set = 50</code>, then the last 25 are discarded. If bleaching or/and
thresholding are selected, they are performed on the whole image stack before
the sectioning is done for calculation of cross-correlated brightnesses.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate brightness
are overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated brightness (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated brightness image using
<code><a href="#topic+smooth_filter">smooth_filter()</a></code> or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are
invoked here with a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code> for either channel gives no thresholding for that
channel. If you want to smooth/median filter the cross-correlated
brightness image in a different way, first calculate the cross-correlated
brightnesses without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result.</p>
</td></tr>
<tr><td><code id="cc_brightness_timeseries_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cc_brightness_timeseries">cc_brightness_timeseries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
ijtiff::write_tif(img, "a.tif")
ijtiff::write_tif(img, "ab.tif")
cc_brightness_timeseries_folder(frames_per_set = 25)
list.files()

## End(Not run)

</code></pre>

<hr>
<h2 id='cc_number'>Cross-correlated number.</h2><span id='topic+cc_number'></span>

<h3>Description</h3>

<p>Given a time stack of images  and two channels, calculate the
cross-correlated number of those two channels for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_number(
  img,
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_number_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array of images indexed by <code>img[y, x, channel, frame]</code> (an object of class <a href="ijtiff.html#topic+ijtiff_img">ijtiff::ijtiff_img</a>). The image to perform the
calculation on. To perform this on a file that has not yet been read in,
set this argument to the path to that file (a string).</p>
</td></tr>
<tr><td><code id="cc_number_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated number (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_number_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_number_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_number_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code>
or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with
a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code>
for either channel gives no thresholding for that channel. If you want to
smooth/median filter the cross-correlated number image in a different way,
first calculate the cross-correlated numbers without filtering (<code>filt = NULL</code>) using this function and then perform your desired filtering routine
on the result.</p>
</td></tr>
<tr><td><code id="cc_number_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix, the cross-correlated number image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "two_ch.tif",
  package = "nandb"
))
ijtiff::display(detrendr::mean_pillars(img[, , 1, ]))
ijtiff::display(detrendr::mean_pillars(img[, , 2, ]))
n &lt;- number(img, def = "n", thresh = "Huang", filt = "median")
ijtiff::display(n[, , 1, 1])
ijtiff::display(n[, , 2, 1])
cc_n &lt;- cc_number(img, thresh = "Huang")
ijtiff::display(cc_n[, , 1, 1])

</code></pre>

<hr>
<h2 id='cc_number_folder'>Cross-correlated number calculations for every image in a folder.</h2><span id='topic+cc_number_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+cc_number">cc_number()</a></code> calculations on all TIFF images in a folder and
save the resulting images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_number_folder(
  folder_path = ".",
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_number_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated number (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code>
or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with
a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code>
for either channel gives no thresholding for that channel. If you want to
smooth/median filter the cross-correlated number image in a different way,
first calculate the cross-correlated numbers without filtering (<code>filt = NULL</code>) using this function and then perform your desired filtering routine
on the result.</p>
</td></tr>
<tr><td><code id="cc_number_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
ijtiff::write_tif(img, "a.tif")
ijtiff::write_tif(img, "ab.tif")
cc_number_folder()
list.files()

## End(Not run)
</code></pre>

<hr>
<h2 id='cc_number_timeseries'>Create a cross-correlated number time-series.</h2><span id='topic+cc_number_timeseries'></span>

<h3>Description</h3>

<p>Given a stack of images <code>img</code>, use the first <code>frames_per_set</code> of them to
create one cross-correlated number image, the next <code>frames_per_set</code> of
them to create the next and so on to get a time-series of cross-correlated
number images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_number_timeseries(
  img,
  frames_per_set,
  overlap = FALSE,
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_number_timeseries_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array of images indexed by <code>img[y, x, channel, frame]</code> (an object of class <a href="ijtiff.html#topic+ijtiff_img">ijtiff::ijtiff_img</a>). The image to perform the
calculation on. To perform this on a file that has not yet been read in,
set this argument to the path to that file (a string).</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive cross-correlated numbers.
</p>
<p>This may discard some images, for example if 175 frames are in the input and
<code>frames_per_set = 50</code>, then the last 25 are discarded. If bleaching or/and
thresholding are selected, they are performed on the whole image stack before
the sectioning is done for calculation of cross-correlated numbers.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate brightness
are overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated number (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code>
or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with
a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code>
for either channel gives no thresholding for that channel. If you want to
smooth/median filter the cross-correlated number image in a different way,
first calculate the cross-correlated numbers without filtering (<code>filt = NULL</code>) using this function and then perform your desired filtering routine
on the result.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array where the <code class="reqn">i</code>th slice is the <code class="reqn">i</code>th cross-correlated
number image.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number">number()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "two_ch.tif",
  package = "nandb"
))
cc_nts &lt;- cc_number_timeseries(img, 10,
  thresh = "Huang",
  filt = "median", parallel = 2
)
ijtiff::display(cc_nts[, , 1, 1])

</code></pre>

<hr>
<h2 id='cc_number_timeseries_folder'>Cross-correlated number time-series calculations for every image in a
folder.</h2><span id='topic+cc_number_timeseries_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+cc_number_timeseries">cc_number_timeseries()</a></code> calculations on all tif images in a
folder and save the resulting images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_number_timeseries_folder(
  folder_path = ".",
  frames_per_set,
  overlap = FALSE,
  ch1 = 1,
  ch2 = 2,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_number_timeseries_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive cross-correlated numbers.
</p>
<p>This may discard some images, for example if 175 frames are in the input and
<code>frames_per_set = 50</code>, then the last 25 are discarded. If bleaching or/and
thresholding are selected, they are performed on the whole image stack before
the sectioning is done for calculation of cross-correlated numbers.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate brightness
are overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_ch1">ch1</code></td>
<td>
<p>A natural number. The index of the first channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_ch2">ch2</code></td>
<td>
<p>A natural number. The index of the second channel to use.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_thresh">thresh</code></td>
<td>
<p>Do you want to apply an intensity threshold prior to
calculating cross-correlated number (via
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>)? If so, set your thresholding method
here. If this is a single value, that same threshold will be applied to
both channels. If this is a length-2 vector or list, then these two
thresholds will be applied to channels 1 and 2 respectively. A value of
<code>NA</code> for either channel gives no thresholding for that channel.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. To
detrend one channel and not the other, specify this as a length 2 vector.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'smooth'</code>) or median (<code>filt = 'median'</code>) filter the cross-correlated number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code>
or <code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with
a filter radius of 1 and with the option <code>na_count = TRUE</code>. A value of <code>NA</code>
for either channel gives no thresholding for that channel. If you want to
smooth/median filter the cross-correlated number image in a different way,
first calculate the cross-correlated numbers without filtering (<code>filt = NULL</code>) using this function and then perform your desired filtering routine
on the result.</p>
</td></tr>
<tr><td><code id="cc_number_timeseries_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cc_number_timeseries">cc_number_timeseries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
ijtiff::write_tif(img, "a.tif")
ijtiff::write_tif(img, "ab.tif")
cc_number_timeseries_folder(frames_per_set = 25)
list.files()

## End(Not run)

</code></pre>

<hr>
<h2 id='cc-nb-img-classes'>Cross-correlated number and brightness image classes.</h2><span id='topic+cc-nb-img-classes'></span><span id='topic+cc_number_img'></span><span id='topic+cc_brightness_img'></span>

<h3>Description</h3>

<p>The <code>cc_number_img</code> and <code>cc_brightness_img</code> classes are designed to hold
objects which are images calculated from the <em>cross-correlated number and
brightness</em> technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_number_img(img, thresh, swaps, filt)

cc_brightness_img(img, thresh, swaps, filt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc-nb-img-classes_+3A_img">img</code></td>
<td>
<p>The calculated cross-correlated number or brightness image.</p>
</td></tr>
<tr><td><code id="cc-nb-img-classes_+3A_thresh">thresh</code></td>
<td>
<p>A positive integer, possibly an object of class
<a href="autothresholdr.html#topic+th">autothresholdr::th</a>. If the different channels of the image had different
thresholds, this argument may be specified as a vector or list (of positive
integers, possibly objects of class <a href="autothresholdr.html#topic+th">autothresholdr::th</a>), one element for
each channel.</p>
</td></tr>
<tr><td><code id="cc-nb-img-classes_+3A_swaps">swaps</code></td>
<td>
<p>A non-negative integer with an attribute <code>auto</code>. If the
different channels of the image had different <code>swaps</code>, this argument may be
specified as a list (of non-negative integers with attributes <code>auto</code>), one
element for each channel. For undetrended images, set <code>swaps = NA</code>.</p>
</td></tr>
<tr><td><code id="cc-nb-img-classes_+3A_filt">filt</code></td>
<td>
<p>A string, the filtering method used. Must be either <code>"mean"</code> or
<code>"median"</code>, or <code>NA</code> for no filtering. If the different channels of the
image had different filters, this may be specified as a character vector,
one element for each channel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>cc_number_img</code> or <code>cc_brightness_img</code> is a 4-dimensional
array of real numbers in the mould of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>
(indexed as <code>img[y, x, channel, frame]</code>) with 3 attributes:
</p>
<dl>
<dt><code>thresh</code></dt><dd><p>A positive integer, possibly an object of class
<a href="autothresholdr.html#topic+th">autothresholdr::th</a> detailing which threshold and thresholding method was
used in preprocessing (in the multi-channel case, one threshold per channel
is given).</p>
</dd> <dt><code>swaps</code></dt><dd><p>A non-negative integer indicating the number of
swaps used for Robin Hood detrending, with an attribute <code>auto</code> which is a
logical indicating whether or not the parameter was chosen automatically (in
the multi-channel case, one <code>swaps</code> per channel is given).</p>
</dd><dt><code>filt</code></dt><dd><p>Was
mean or median filtering used in postprocessing?</p>
</dd></dl>



<h3>Value</h3>

<p>An object of class <code>cc_number_img</code> or <code>cc_brightness_img</code>.
</p>

<hr>
<h2 id='cc-nb-ts-img-classes'>Cross-correlated number and brightness time series image classes.</h2><span id='topic+cc-nb-ts-img-classes'></span><span id='topic+cc_number_ts_img'></span><span id='topic+cc_brightness_ts_img'></span>

<h3>Description</h3>

<p>The <code>cc_number_ts_img</code> and <code>cc_brightness_ts_img</code> classes are designed to
hold objects which are images calculated from the <em>cross-correlated number
and brightness</em> technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_number_ts_img(img, frames_per_set, overlapped, thresh, swaps, filt)

cc_brightness_ts_img(img, frames_per_set, overlapped, thresh, swaps, filt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc-nb-ts-img-classes_+3A_img">img</code></td>
<td>
<p>The calculated cross-correlated number or brightness time series
image series.</p>
</td></tr>
<tr><td><code id="cc-nb-ts-img-classes_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames used in the calculation of each
point in the cross-correlated number or brightness time series.</p>
</td></tr>
<tr><td><code id="cc-nb-ts-img-classes_+3A_overlapped">overlapped</code></td>
<td>
<p>A boolean. <code>TRUE</code> indicates that the windows used to
calculate consecutive brightnesses over time were overlapped, <code>FALSE</code>
indicates that they were not.</p>
</td></tr>
<tr><td><code id="cc-nb-ts-img-classes_+3A_thresh">thresh</code></td>
<td>
<p>A positive integer, possibly an object of class
<a href="autothresholdr.html#topic+th">autothresholdr::th</a>. If the different channels of the image had different
thresholds, this argument may be specified as a vector or list (of positive
integers, possibly objects of class <a href="autothresholdr.html#topic+th">autothresholdr::th</a>), one element for
each channel.</p>
</td></tr>
<tr><td><code id="cc-nb-ts-img-classes_+3A_swaps">swaps</code></td>
<td>
<p>A non-negative integer with an attribute <code>auto</code>. If the
different channels of the image had different <code>swaps</code>, this argument may be
specified as a list (of non-negative integers with attributes <code>auto</code>), one
element for each channel. For undetrended images, set <code>swaps = NA</code>.</p>
</td></tr>
<tr><td><code id="cc-nb-ts-img-classes_+3A_filt">filt</code></td>
<td>
<p>A string, the filtering method used. Must be either <code>"mean"</code> or
<code>"median"</code>, or <code>NA</code> for no filtering. If the different channels of the
image had different filters, this may be specified as a character vector,
one element for each channel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>cc_number_ts_img</code> or <code>cc_brightness_ts_img</code> is a
4-dimensional array of real numbers in the mould of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> with 3 attributes:
</p>
<dl>
<dt><code>thresh</code></dt><dd><p>A positive integer, possibly an object of class
<a href="autothresholdr.html#topic+th">autothresholdr::th</a> detailing which threshold and thresholding method was
used in preprocessing (in the multi-channel case, one threshold per channel
is given).</p>
</dd> <dt><code>swaps</code></dt><dd><p>A non-negative integer indicating the parameter
used for Robin Hood detrending with an attribute <code>auto</code> which is a logical
indicating whether or not the parameter was chosen automatically (in the
multi-channel case, one <code>swaps</code> per channel is given).</p>
</dd>
<dt><code>frames_per_set</code></dt><dd><p>A positive integer detailing how many frames were
used in the calculation of each point in the number or brightness time
series.</p>
</dd> <dt><code>overlapped</code></dt><dd><p>A boolean. <code>TRUE</code> indicates that the windows
used to calculate consecutive brightnesses over time were overlapped, <code>FALSE</code>
indicates that they were not.</p>
</dd></dl>



<h3>Value</h3>

<p>An object of class <code>cc_number_ts_img</code> or <code>cc_brightness_ts_img</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc_number_timeseries">cc_number_timeseries()</a></code>, <code><a href="#topic+cc_brightness_timeseries">cc_brightness_timeseries()</a></code>.
</p>

<hr>
<h2 id='cross_var'>Calculate the <em>cross-variance</em> of two vectors.</h2><span id='topic+cross_var'></span>

<h3>Description</h3>

<p>The cross-variance function is defined in the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_var(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_var_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="cross_var_+3A_y">y</code></td>
<td>
<p>A numeric vector with the same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number
</p>


<h3>References</h3>

<p>Digman, MA, Wiseman, PW, Choi, C, Horwitz, AR, Gratton, E (2009).
Stoichiometry of molecular complexes at adhesions in living cells. Proc.
Natl. Acad. Sci. U.S.A., 106, 7:2170-5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross_var(0:3, 2:5)
</code></pre>

<hr>
<h2 id='cross_var_pillars'>Calculate the <em>cross-variance</em> of corresponding pillars of 3d arrays.</h2><span id='topic+cross_var_pillars'></span>

<h3>Description</h3>

<p>The cross-variance function is defined in the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_var_pillars(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_var_pillars_+3A_x">x</code></td>
<td>
<p>A 3-dimensional array.</p>
</td></tr>
<tr><td><code id="cross_var_pillars_+3A_y">y</code></td>
<td>
<p>A 3-dimensional array with the same dimensions as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pillar <code style="white-space: pre;">&#8288;i, j&#8288;</code> of the 3-dimensional array <code>arr</code> is <code>arr[i, j, ]</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:27, dim = rep(3, 3))
y &lt;- array(0:26, dim = rep(3, 3))
cross_var_pillars(x, y)
</code></pre>

<hr>
<h2 id='matrix_raster_plot'>Make a raster plot of a matrix.</h2><span id='topic+matrix_raster_plot'></span>

<h3>Description</h3>

<p>Given a matrix <code>mat</code>, make a raster plot of the matrix whereby in the
plot, the pixel at <code class="reqn">x = </code><code>i</code>, <code class="reqn">y = </code><code>j</code> has colour based on
the value of <code>mat[i, j]</code> and the <code class="reqn">x</code> axis points right and the
<code class="reqn">y</code> axis points down (see 'Details').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_raster_plot(
  mat,
  scale_name = "scale",
  limits = NULL,
  ranges = NULL,
  range_names = NULL,
  colours = NULL,
  na_colour = "black",
  clip = FALSE,
  clip_low = FALSE,
  clip_high = FALSE,
  log_trans = FALSE,
  breaks = NULL,
  include_breaks = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_raster_plot_+3A_mat">mat</code></td>
<td>
<p>The matrix you wish to plot.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_scale_name">scale_name</code></td>
<td>
<p>A string. The title of the color scale on the right of the
plot.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_limits">limits</code></td>
<td>
<p>This gives the user the option to set all values outside a
certain range to their nearest value within that range (if <code>clip = TRUE</code>) or to <code>NA</code> (if <code>clip = FALSE</code>. For example, to set all
values outside the range [1.5, 2.6) to <code>NA</code>, use <code style="white-space: pre;">&#8288;limits = c(1.5, 2.6), clip = FALSE&#8288;</code>. The colour range will cover all values within these
specified limits.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_ranges">ranges</code></td>
<td>
<p>A numeric vector. If you want specific ranges of values to have
the same color, specify these ranges via an increasing numeric vector. For
example, if you want the ranges 0.5-1.2 and 1.2-3, use <code>ranges = c(0.5, 1.2, 3)</code>. If <code>ranges</code> is specified as a number (a numeric
vector of length 1) <code>n</code>, this is equivalent to setting ranges to be
<code>n</code> equal-length intervals within the range of the matrix, i.e. it is
equivalent to setting 'ranges = seq(min(mat), max(mat), length.out = n
</p>

<ul>
<li><p> 1)<code style="white-space: pre;">&#8288;. At most one of &#8288;</code>ranges<code>and</code>limits<code style="white-space: pre;">&#8288;should be set. If   ranges is set, the behaviour for values which are not in any of the ranges   are set by the&#8288;</code>clip<code style="white-space: pre;">&#8288;arguments as in the&#8288;</code>limits' argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_range_names">range_names</code></td>
<td>
<p>A character vector. If your colour scale is discrete, here
you can set the names which will label each range in the legend.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_colours">colours</code></td>
<td>
<p>If you have set <code>ranges</code>, here you may specify which
colors you wish to colour each range. It must have the same length as the
number of intervals you have specified in <code>ranges</code>.  If you have not
specified <code>ranges</code>, here you may specify the colours (to be passed to
<code><a href="ggplot2.html#topic+scale_gradient">ggplot2::scale_fill_gradientn()</a></code>) to create the continuous
colour band. It is specified as a character vector, with the colors
specified either as the values in <code><a href="grDevices.html#topic+colors">colors()</a></code> or as in the value
of the <code><a href="grDevices.html#topic+rgb">rgb()</a></code> function. Note that this allows the use of
<code><a href="grDevices.html#topic+palettes">grDevices::rainbow()</a></code> and friends. The default uses
<code><a href="viridis.html#topic+reexports">viridis::viridis()</a></code>.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_na_colour">na_colour</code></td>
<td>
<p>Which colour should the <code>NA</code> pixels be? Default is
black.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_clip">clip</code></td>
<td>
<p>If either <code>limits</code> or <code>ranges</code> are set (one should
never set both), there may be values that fall outside the specified
limits/ranges. If <code>clip = TRUE</code>, values outside these limits/ranges
are set to their nearest values within them, but if <code>clip = FALSE</code>,
these values are set to NA. Note that setting <code>clip = TRUE</code> is
equivalent to setting both <code>clip_low</code> and <code>clip_high</code> to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_clip_low">clip_low</code></td>
<td>
<p>Setting this to <code>TRUE</code> (and leaving <code>clip = FALSE</code>,
<code>clip_high = FALSE</code>) will set all values falling below the specified
limits/ranges to their nearest value within them, but all values falling
above those limits/ranges will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_clip_high">clip_high</code></td>
<td>
<p>Setting this to <code>TRUE</code> (and leaving <code>clip = FALSE</code>, <code>clip_low = FALSE</code>) will set all values falling above the
specified limits/ranges to their nearest value within them, but all values
falling below those limits/ranges will be set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_log_trans">log_trans</code></td>
<td>
<p>Do you want to log-transform the colour scaling?</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_breaks">breaks</code></td>
<td>
<p>Where do you want tick marks to appear on the legend colour
scale?</p>
</td></tr>
<tr><td><code id="matrix_raster_plot_+3A_include_breaks">include_breaks</code></td>
<td>
<p>If you don't want to specify all the breaks, but you
want some specific ones to be included on the legend colour scale, specify
those specific ones here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the graphics console, a raster plot (via
<code><a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster()</a></code>) will appear with the matrix values
represented as pixel colours, with a named scale bar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::display(img[, , 1, 1])
matrix_raster_plot(img[, , 1, 1])
b &lt;- brightness(img, def = "B", detrend = FALSE, thresh = "Huang")
matrix_raster_plot(b, scale_name = "brightness")
matrix_raster_plot(b, scale_name = "brightness", log_trans = TRUE)
matrix_raster_plot(b,
  scale_name = "brightness", log_trans = TRUE,
  include_breaks = 1.35
)
matrix_raster_plot(b,
  scale_name = "brightness", log_trans = TRUE,
  breaks = 1:3
)
matrix_raster_plot(b,
  scale_name = "brightness",
  ranges = seq(0.5, 3, length.out = 6),
  range_names = paste0(1:5, "mer")
)
matrix_raster_plot(b,
  scale_name = "brightness",
  ranges = seq(0.5, 3, length.out = 6),
  range_names = paste0(1:5, "mer"), log_trans = TRUE
)
matrix_raster_plot(b,
  scale_name = "brightness",
  include_breaks = 1.25, range_names = NULL,
  log_trans = FALSE
)
matrix_raster_plot(b,
  scale_name = "brightness",
  include_breaks = 1.25, log_trans = TRUE
)
matrix_raster_plot(b,
  scale_name = "brightness",
  limits = c(1, 1.25), clip = TRUE
)
matrix_raster_plot(b,
  scale_name = "brightness",
  include_breaks = 1.25
)

</code></pre>

<hr>
<h2 id='median_filter'>Smooth and median filters with options for handling NAs.</h2><span id='topic+median_filter'></span><span id='topic+smooth_filter'></span>

<h3>Description</h3>

<p>These are alternatives to
<code>EBImage::filter2()</code> and <code>EBImage::medianFilter()</code> for
smooth and median filtering respectively. These functions have many options
for dealing with <code>NA</code> values which <code>EBImage</code>'s functions lack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_filter(mat, size = 1L, na_rm = FALSE, na_count = FALSE)

smooth_filter(mat, size = 1L, na_rm = FALSE, na_count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_filter_+3A_mat">mat</code></td>
<td>
<p>A matrix (representing an image).</p>
</td></tr>
<tr><td><code id="median_filter_+3A_size">size</code></td>
<td>
<p>An integer; the median filter radius.</p>
</td></tr>
<tr><td><code id="median_filter_+3A_na_rm">na_rm</code></td>
<td>
<p>Should <code>NA</code>s be ignored?</p>
</td></tr>
<tr><td><code id="median_filter_+3A_na_count">na_count</code></td>
<td>
<p>If this is TRUE, in each median calculation, if the majority
of arguments are <code>NA</code>s, <code>NA</code> is returned but if the <code>NA</code>s are
in the minority, they are ignored as in <code>median(x, na.rm = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behavior at image boundaries is such as the source image has been padded
with pixels whose values equal the nearest border pixel value.
</p>


<h3>Value</h3>

<p>A matrix (the median filtered image).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:9, nrow = 3)
m[2:3, 2:3] &lt;- NA
print(m)
median_filter(m)
median_filter(m, na_rm = TRUE)
median_filter(m, na_count = TRUE)

smooth_filter(m)
smooth_filter(m, na_rm = TRUE)
smooth_filter(m, na_count = TRUE)

</code></pre>

<hr>
<h2 id='nandb'>nandb: Number and brightness in R.</h2><span id='topic+nandb'></span><span id='topic+nandb-package'></span>

<h3>Description</h3>

<p>The <code>nandb</code> package gives functions for calculation of molecular number and
brightness from images, as detailed in Digman et al. 2008. It comes with an
implementation of the novel 'automatic detrending' technique.
</p>


<h3>References</h3>

<p>Digman MA, Dalal R, Horwitz AF, Gratton E. Mapping the Number of
Molecules and Brightness in the Laser Scanning Microscope. Biophysical
Journal. 2008;94(6):2320-2332. doi: <a href="https://doi.org/10.1529/biophysj.107.114645">10.1529/biophysj.107.114645</a>.
</p>

<hr>
<h2 id='nb-img-classes'>Number and brightness image classes.</h2><span id='topic+nb-img-classes'></span><span id='topic+number_img'></span><span id='topic+brightness_img'></span>

<h3>Description</h3>

<p>The <code>number_img</code> and <code>brightness_img</code> classes are designed to hold objects
which are images calculated from the <em>number and brightness</em> technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_img(img, def, thresh, swaps, filt)

brightness_img(img, def, thresh, swaps, filt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb-img-classes_+3A_img">img</code></td>
<td>
<p>The calculated number or brightness image.</p>
</td></tr>
<tr><td><code id="nb-img-classes_+3A_def">def</code></td>
<td>
<p>The number or brightness definition used.</p>
</td></tr>
<tr><td><code id="nb-img-classes_+3A_thresh">thresh</code></td>
<td>
<p>A positive integer, possibly an object of class
<a href="autothresholdr.html#topic+th">autothresholdr::th</a>. If the different channels of the image had different
thresholds, this argument may be specified as a vector or list (of positive
integers, possibly objects of class <a href="autothresholdr.html#topic+th">autothresholdr::th</a>), one element for
each channel.</p>
</td></tr>
<tr><td><code id="nb-img-classes_+3A_swaps">swaps</code></td>
<td>
<p>A non-negative integer with an attribute <code>auto</code>. If the
different channels of the image had different <code>swaps</code>, this argument may be
specified as a list (of non-negative integers with attributes <code>auto</code>), one
element for each channel. For undetrended images, set <code>swaps = NA</code>.</p>
</td></tr>
<tr><td><code id="nb-img-classes_+3A_filt">filt</code></td>
<td>
<p>A string, the filtering method used. Must be either <code>"mean"</code> or
<code>"median"</code>, or <code>NA</code> for no filtering. If the different channels of the
image had different filters, this may be specified as a character vector,
one element for each channel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>number_img</code> or <code>brightness_img</code> is a 4-dimensional array
of real numbers in the mould of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed
as <code>img[y, x, channel, frame]</code>) with 4 attributes: </p>
<dl>
<dt><code>def</code></dt><dd><p>Are
we using the <code>"N"</code> or <code>"n"</code> definition of number, or the <code>"B"</code> or <code>"epsilon"</code>
definition of brightness?</p>
</dd> <dt><code>thresh</code></dt><dd><p>A positive integer, possibly an
object of class <a href="autothresholdr.html#topic+th">autothresholdr::th</a> detailing which threshold and
thresholding method was used in preprocessing (in the multi-channel case, one
threshold per channel is given).</p>
</dd> <dt><code>swaps</code></dt><dd><p>A non-negative integer
indicating the number of swaps Robin Hood detrending, with an attribute
<code>auto</code> which is a logical indicating whether or not the parameter was chosen
automatically (in the multi-channel case, one threshold per channel is
given).</p>
</dd><dt><code>filt</code></dt><dd><p>Was mean or median filtering used in postprocessing?</p>
</dd></dl>



<h3>Value</h3>

<p>An object of class <code>number_img</code> or <code>brightness_img</code>.
</p>

<hr>
<h2 id='nb-ts-img-classes'>Number and brightness time series image classes.</h2><span id='topic+nb-ts-img-classes'></span><span id='topic+number_ts_img'></span><span id='topic+brightness_ts_img'></span>

<h3>Description</h3>

<p>The <code>number_ts_img</code> and <code>brightness_ts_img</code> classes are designed to hold
objects which are images calculated from the <em>number and brightness</em>
technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_ts_img(img, def, frames_per_set, overlapped, thresh, swaps, filt)

brightness_ts_img(img, def, frames_per_set, overlapped, thresh, swaps, filt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nb-ts-img-classes_+3A_img">img</code></td>
<td>
<p>The calculated number or brightness time series image series.</p>
</td></tr>
<tr><td><code id="nb-ts-img-classes_+3A_def">def</code></td>
<td>
<p>The number or brightness definition used.</p>
</td></tr>
<tr><td><code id="nb-ts-img-classes_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames used in the calculation of each
point in the number or brightness time series.</p>
</td></tr>
<tr><td><code id="nb-ts-img-classes_+3A_overlapped">overlapped</code></td>
<td>
<p>A boolean. <code>TRUE</code> indicates that the windows used to
calculate consecutive brightnesses over time were overlapped, <code>FALSE</code>
indicates that they were not.</p>
</td></tr>
<tr><td><code id="nb-ts-img-classes_+3A_thresh">thresh</code></td>
<td>
<p>A positive integer, possibly an object of class
<a href="autothresholdr.html#topic+th">autothresholdr::th</a>. If the different channels of the image had different
thresholds, this argument may be specified as a vector or list (of positive
integers, possibly objects of class <a href="autothresholdr.html#topic+th">autothresholdr::th</a>), one element for
each channel.</p>
</td></tr>
<tr><td><code id="nb-ts-img-classes_+3A_swaps">swaps</code></td>
<td>
<p>A non-negative integer with an attribute <code>auto</code>. If the
different channels of the image had different <code>swaps</code>, this argument may be
specified as a list (of non-negative integers with attributes <code>auto</code>), one
element for each channel. For undetrended images, set <code>swaps = NA</code>.</p>
</td></tr>
<tr><td><code id="nb-ts-img-classes_+3A_filt">filt</code></td>
<td>
<p>A string, the filtering method used. Must be either <code>"mean"</code> or
<code>"median"</code>, or <code>NA</code> for no filtering. If the different channels of the
image had different filters, this may be specified as a character vector,
one element for each channel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>number_ts_img</code> or <code>brightness_ts_img</code> is a 3- or
4-dimensional array of real numbers with 4 attributes:
</p>
<dl>
<dt><code>def</code></dt><dd><p>Are we using the <code>"N"</code> or <code>"n"</code> definition of number,
or the <code>"B"</code> or <code>"epsilon"</code> definition of brightness?</p>
</dd> <dt><code>thresh</code></dt><dd><p>A
positive integer, possibly an object of class <a href="autothresholdr.html#topic+th">autothresholdr::th</a> detailing
which threshold and thresholding method was used in preprocessing (in the
multi-channel case, one threshold per channel is given).</p>
</dd> <dt><code>swaps</code></dt><dd><p>A
non-negative integer indicating the number of swaps used for Robin Hood
detrending, with an attribute <code>auto</code> which is a logical indicating whether or
not the parameter was chosen automatically (in the multi-channel case, one
<code>swaps</code> per channel is given).</p>
</dd> <dt><code>frames_per_set</code></dt><dd><p>A positive integer
detailing how many frames were used in the calculation of each point in the
number or brightness time series.</p>
</dd> <dt><code>overlapped</code></dt><dd><p>A boolean. <code>TRUE</code>
indicates that the windows used to calculate consecutive brightnesses over
time were overlapped, <code>FALSE</code> indicates that they were not.</p>
</dd></dl>



<h3>Value</h3>

<p>An object of class <code>number_ts_img</code> or <code>brightness_ts_img</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number_timeseries">number_timeseries()</a></code>, <code><a href="#topic+brightness_timeseries">brightness_timeseries()</a></code>.
</p>

<hr>
<h2 id='number'>Calculate number from image series.</h2><span id='topic+number'></span>

<h3>Description</h3>

<p>Given a time stack of images, <code>number()</code> performs a calculation of the number
for each pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number(
  img,
  def,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  gamma = 1,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array of images indexed by <code>img[y, x, channel, frame]</code> (an object of class <a href="ijtiff.html#topic+ijtiff_img">ijtiff::ijtiff_img</a>). The image to perform the
calculation on. To perform this on a file that has not yet been read in,
set this argument to the path to that file (a string).</p>
</td></tr>
<tr><td><code id="number_+3A_def">def</code></td>
<td>
<p>A character. Which definition of number do you want to use, <code>"n"</code>
or <code>"N"</code>?</p>
</td></tr>
<tr><td><code id="number_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and number calculations. If there are many channels, this may be
specified as a vector or list, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="number_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="number_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="number_+3A_offset">offset</code>, <code id="number_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_+3A_gamma">gamma</code></td>
<td>
<p>Factor for correction of number <code class="reqn">n</code> due to the illumination
profile. The default (<code>gamma = 1</code>) has no effect. Changing gamma will have
the effect of dividing the result by <code>gamma</code>, so the result with <code>gamma = 0.5</code> is two times the result with <code>gamma = 1</code>. For a Gaussian illumination
profile, use <code>gamma = 0.3536</code>; for a Gaussian-Lorentzian illumination
profile, use <code>gamma = 0.0760</code>.</p>
</td></tr>
<tr><td><code id="number_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, the number image.
</p>


<h3>References</h3>

<p>Digman MA, Dalal R, Horwitz AF, Gratton E. Mapping the Number of
Molecules and Brightness in the Laser Scanning Microscope. Biophysical
Journal. 2008;94(6):2320-2332. doi: <a href="https://doi.org/10.1529/biophysj.107.114645">10.1529/biophysj.107.114645</a>.
</p>
<p>Dalal, RB, Digman, MA, Horwitz, AF, Vetri, V, Gratton, E (2008).
Determination of particle number and brightness using a laser scanning
confocal microscope operating in the analog mode. Microsc. Res. Tech., 71,
1:69-81. doi: <a href="https://doi.org/10.1002/jemt.20526">10.1002/jemt.20526</a>.
</p>
<p>Hur K-H, Macdonald PJ, Berk S, Angert CI, Chen Y, Mueller JD (2014)
Quantitative Measurement of Brightness from Living Cells in the Presence of
Photodepletion. PLoS ONE 9(5): e97440. doi: <a href="https://doi.org/10.1371/journal.pone.0097440">10.1371/journal.pone.0097440</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::display(img[, , 1, 1])
num &lt;- number(img, "N", thresh = "Huang")
num &lt;- number(img, "n", thresh = "tri")

</code></pre>

<hr>
<h2 id='number_folder'>Number calculations for every image in a folder.</h2><span id='topic+number_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+number">number()</a></code> calculations on all tif images in a folder and save the
resulting number images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_folder(
  folder_path = ".",
  def,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  gamma = 1,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_def">def</code></td>
<td>
<p>A character. Which definition of number do you want to use, <code>"n"</code>
or <code>"N"</code>?</p>
</td></tr>
<tr><td><code id="number_folder_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and number calculations. If there are many channels, this may be
specified as a vector or list, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_gamma">gamma</code></td>
<td>
<p>Factor for correction of number <code class="reqn">n</code> due to the illumination
profile. The default (<code>gamma = 1</code>) has no effect. Changing gamma will have
the effect of dividing the result by <code>gamma</code>, so the result with <code>gamma = 0.5</code> is two times the result with <code>gamma = 1</code>. For a Gaussian illumination
profile, use <code>gamma = 0.3536</code>; for a Gaussian-Lorentzian illumination
profile, use <code>gamma = 0.0760</code>.</p>
</td></tr>
<tr><td><code id="number_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Extreme number values (of magnitude greater than 3.40282e+38) will be
written to the TIFF file as <code>NA</code>, since TIFF files cannot handle such huge
numbers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number">number()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::write_tif(img, "img2.tif")
number_folder(def = "n", thresh = "Huang", parallel = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='number_timeseries'>Create a number time-series.</h2><span id='topic+number_timeseries'></span>

<h3>Description</h3>

<p>Given a stack of images <code>img</code>, use the first <code>frames_per_set</code> of them to
create one number image, the next <code>frames_per_set</code> of them to create the next
number image and so on to get a time-series of number images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_timeseries(
  img,
  def,
  frames_per_set,
  overlap = FALSE,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  gamma = 1,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_timeseries_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array of images indexed by <code>img[y, x, channel, frame]</code> (an object of class <a href="ijtiff.html#topic+ijtiff_img">ijtiff::ijtiff_img</a>). The image to perform the
calculation on. To perform this on a file that has not yet been read in,
set this argument to the path to that file (a string).</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_def">def</code></td>
<td>
<p>A character. Which definition of number do you want to use, <code>"n"</code>
or <code>"N"</code>?</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive numbers.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate brightness
are overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and number calculations. If there are many channels, this may be
specified as a vector or list, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_gamma">gamma</code></td>
<td>
<p>Factor for correction of number <code class="reqn">n</code> due to the illumination
profile. The default (<code>gamma = 1</code>) has no effect. Changing gamma will have
the effect of dividing the result by <code>gamma</code>, so the result with <code>gamma = 0.5</code> is two times the result with <code>gamma = 1</code>. For a Gaussian illumination
profile, use <code>gamma = 0.3536</code>; for a Gaussian-Lorentzian illumination
profile, use <code>gamma = 0.0760</code>.</p>
</td></tr>
<tr><td><code id="number_timeseries_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may discard some images, for example if 175 frames are in the input and
<code>frames_per_set = 50</code>, then the last 25 are discarded. If detrending is
selected, it is performed on the whole image stack before the sectioning is
done for calculation of numbers.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+number_ts_img">number_ts_img</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number">number()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
nts &lt;- number_timeseries(img, "n", frames_per_set = 20, thresh = "Huang")

</code></pre>

<hr>
<h2 id='number_timeseries_folder'>Number time-series calculations for every image in a folder.</h2><span id='topic+number_timeseries_folder'></span>

<h3>Description</h3>

<p>Perform <code><a href="#topic+number_timeseries">number_timeseries()</a></code> calculations on all tif images in a folder and
save the resulting number images to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number_timeseries_folder(
  folder_path = ".",
  def,
  frames_per_set,
  overlap = FALSE,
  thresh = NULL,
  detrend = FALSE,
  quick = FALSE,
  filt = NULL,
  s = 1,
  offset = 0,
  readout_noise = 0,
  gamma = 1,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number_timeseries_folder_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_def">def</code></td>
<td>
<p>A character. Which definition of number do you want to use, <code>"n"</code>
or <code>"N"</code>?</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_frames_per_set">frames_per_set</code></td>
<td>
<p>The number of frames with which to calculate the
successive numbers.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_overlap">overlap</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, the windows used to calculate brightness
are overlapped, if <code>FALSE</code>, they are not. For example, for a 20-frame image
series with 5 frames per set, if the windows are not overlapped, then the
frame sets used are 1-5, 6-10, 11-15 and 16-20; whereas if they are
overlapped, the frame sets are 1-5, 2-6, 3-7, 4-8 and so on up to 16-20.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending and number calculations. If there are many channels, this may be
specified as a vector or list, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_detrend">detrend</code></td>
<td>
<p>Detrend your data with <code><a href="detrendr.html#topic+detrending">detrendr::img_detrend_rh()</a></code>. This is
the best known detrending method for brightness analysis. For more
fine-grained control over your detrending, use the <code>detrendr</code> package. If
there are many channels, this may be specified as a vector, one element for
each channel.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_quick">quick</code></td>
<td>
<p><code>FALSE</code> repeats the detrending procedure (which has some inherent
randomness) a few times to hone in on the best detrend. <code>TRUE</code> is quicker,
performing the routine only once. <code>FALSE</code> is better.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_filt">filt</code></td>
<td>
<p>Do you want to smooth (<code>filt = 'mean'</code>) or median (<code>filt = 'median'</code>) filter the number image using <code><a href="#topic+smooth_filter">smooth_filter()</a></code> or
<code><a href="#topic+median_filter">median_filter()</a></code> respectively? If selected, these are invoked here with a
filter radius of 1 (with corners included, so each median is the median of
9 elements) and with the option <code>na_count = TRUE</code>. If you want to
smooth/median filter the number image in a different way, first calculate
the numbers without filtering (<code>filt = NULL</code>) using this function and then
perform your desired filtering routine on the result. If there are many
channels, this may be specified as a vector, one element for each channel.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_s">s</code></td>
<td>
<p>A positive number. The <code class="reqn">S</code>-factor of microscope acquisition.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_offset">offset</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_readout_noise">readout_noise</code></td>
<td>
<p>Microscope acquisition parameters. See reference
Dalal et al.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_gamma">gamma</code></td>
<td>
<p>Factor for correction of number <code class="reqn">n</code> due to the illumination
profile. The default (<code>gamma = 1</code>) has no effect. Changing gamma will have
the effect of dividing the result by <code>gamma</code>, so the result with <code>gamma = 0.5</code> is two times the result with <code>gamma = 1</code>. For a Gaussian illumination
profile, use <code>gamma = 0.3536</code>; for a Gaussian-Lorentzian illumination
profile, use <code>gamma = 0.0760</code>.</p>
</td></tr>
<tr><td><code id="number_timeseries_folder_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Extreme number values (of magnitude greater than 3.40282e+38) will be
written to the TIFF file as <code>NA</code>, since TIFF files cannot handle such huge
numbers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+number_timeseries">number_timeseries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
img &lt;- ijtiff::read_tif(system.file("extdata", "50.tif", package = "nandb"))
ijtiff::write_tif(img, "img1.tif")
ijtiff::write_tif(img, "img2.tif")
number_timeseries_folder(def = "n", thresh = "Huang", frames_per_set = 20)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
