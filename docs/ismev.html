<!DOCTYPE html><html><head><title>Help for package ismev</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ismev}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dowjones'><p>Daily Closing Prices of The Dow Jones Index</p></a></li>
<li><a href='#engine'><p>Engine Failure Time Data</p></a></li>
<li><a href='#euroex'><p>UK/Euro Exchange Rates</p></a></li>
<li><a href='#exchange'><p>UK/US and UK/Canada Exchange Rates</p></a></li>
<li><a href='#fremantle'><p>Annual Maximum Sea Levels at Fremantle, Western Australia</p></a></li>
<li><a href='#gamGPDfitboot'><p>Smooth Parameter Estimation and Bootstrapping of Generalized Pareto Distributions</p>
with Penalized Maximum Likelihood Estimation</a></li>
<li><a href='#gev.diag'><p>Diagnostic Plots for GEV Models</p></a></li>
<li><a href='#gev.fit'><p>Maximum-likelihood Fitting of the GEV Distribution</p></a></li>
<li><a href='#gev.prof'><p>Profile Log-likelihoods for Stationary GEV Models</p></a></li>
<li><a href='#glass'><p>Breaking Strengths of Glass Fibres</p></a></li>
<li><a href='#gpd.diag'><p>Diagnostic Plots for GPD Models</p></a></li>
<li><a href='#gpd.fit'><p>Maximum-likelihood Fitting for the GPD Model</p></a></li>
<li><a href='#gpd.fitrange'><p>Fitting the GPD Model Over a Range of Thresholds</p></a></li>
<li><a href='#gpd.prof'><p>Profile Log-likelihoods for Stationary GPD Models</p></a></li>
<li><a href='#gum.diag'><p>Diagnostic Plots for Gumbel Models</p></a></li>
<li><a href='#gum.fit'><p>Maximum-likelihood Fitting of the Gumbel Distribution</p></a></li>
<li><a href='#ismev'><p>ismev &ndash; an Introduction to Statistical Modeling of Extreme Values</p></a></li>
<li><a href='#ismev-internal'><p>Internal Functions</p></a></li>
<li><a href='#mrl.plot'><p>Mean Residual Life Plot</p></a></li>
<li><a href='#portpirie'><p>Annual Maximum Sea Levels at Port Pirie, South Australia</p></a></li>
<li><a href='#pp.diag'><p>Diagnostic Plots for Point Process Models</p></a></li>
<li><a href='#pp.fit'><p>Maximum-likelihood Fitting for the Point Process Model</p></a></li>
<li><a href='#pp.fitrange'><p>Fitting the Point Process Model Over a Range of Thresholds</p></a></li>
<li><a href='#rain'><p>Daily Rainfall Accumulations in South-West England</p></a></li>
<li><a href='#rlarg.diag'><p>Diagnostic Plots for Order Statistics Models</p></a></li>
<li><a href='#rlarg.fit'><p>Maximum-likelihood Fitting of Order Statistics Model</p></a></li>
<li><a href='#venice'><p>Venice Sea Levels</p></a></li>
<li><a href='#wavesurge'><p>Wave and Surge Heights in South-West England</p></a></li>
<li><a href='#wind'><p>Annual Maximum Wind Speeds at Albany and Hartford</p></a></li>
<li><a href='#wooster'><p>Minimum Temperatures at Wooster, Ohio</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.42</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-08</td>
</tr>
<tr>
<td>Title:</td>
<td>An Introduction to Statistical Modeling of Extreme Values</td>
</tr>
<tr>
<td>Author:</td>
<td>Original S functions written by Janet E. Heffernan with R port and R 
  documentation provided by Alec G. Stephenson.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Gilleland &lt;ericg@ucar.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0), mgcv</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to support the computations carried out in
  &lsquo;An Introduction to Statistical Modeling of Extreme Values&rsquo; by
  Stuart Coles. The functions may be divided into the following 
  groups; maxima/minima, order statistics, peaks over thresholds
  and point processes.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.ral.ucar.edu/~ericg/softextreme.php">http://www.ral.ucar.edu/~ericg/softextreme.php</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-08 20:56:39 UTC; ericg</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-10 22:08:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='dowjones'>Daily Closing Prices of The Dow Jones Index</h2><span id='topic+dowjones'></span>

<h3>Description</h3>

<p>The <code>dowjones</code> data frame has 1304 rows and 2 columns.
The second column contains daily closing prices of the Dow
Jones Index over the period 1996 to 2000. The first column
contains a <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object giving the dates of
each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dowjones)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Date</dt><dd><p>A <code><a href="base.html#topic+POSIXct">POSIXct</a></code> object containing dates.</p>
</dd>
<dt>Index</dt><dd><p>A numeric vector containing daily closing
prices of the Dow Jones Index.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='engine'>Engine Failure Time Data</h2><span id='topic+engine'></span>

<h3>Description</h3>

<p>The <code>engine</code> data frame has 32 rows and 2 columns.
The first column contains the corrosion level, the second
column gives the engine failure time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(engine)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Time</dt><dd><p>A numeric vector of corrosion levels.</p>
</dd>
<dt>Corrosion</dt><dd><p>A numeric vector of failure times.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Unknown.
</p>

<hr>
<h2 id='euroex'>UK/Euro Exchange Rates</h2><span id='topic+euroex'></span>

<h3>Description</h3>

<p>A numeric vector of daily exchange rates between
the Euro and UK sterling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(euroex)</code></pre>


<h3>Format</h3>

<p>A vector containing 975 observations.</p>


<h3>Source</h3>

<p>Unknown.
</p>

<hr>
<h2 id='exchange'>UK/US and UK/Canada Exchange Rates</h2><span id='topic+exchange'></span>

<h3>Description</h3>

<p>The <code>exchange</code> data frame has 975 rows and 2 columns.
The columns contain daily exchange rates; UK sterling
against the US dollar (first column) and UK sterling
against the Canadian dollar (second column).
The rownames contain the corresponding dates in a character
string with the format <code>"2000/05/26"</code>. This can be
converted into a <code>POSIXct</code> or <code>POSIXlt</code> object
using <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code> or <code><a href="base.html#topic+as.POSIXlt">as.POSIXlt</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exchange)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>USD.GBP</dt><dd><p>US against UK exchange rate.</p>
</dd>
<dt>CAD.GBP</dt><dd><p>Canada against UK exchange rate.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='fremantle'>Annual Maximum Sea Levels at Fremantle, Western Australia</h2><span id='topic+fremantle'></span>

<h3>Description</h3>

<p>The <code>fremantle</code> data frame has 86 rows and 3 columns.
The second column gives 86 annual maximimum sea levels
recorded at Fremantle, Western Australia, within the period
1897 to 1989.
The first column gives the corresponding years.
The third column gives annual mean values of the Southern
Oscillation Index (SOI), which is a proxy for meteorological
volitility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fremantle)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Year</dt><dd><p>A numeric vector of years.</p>
</dd>
<dt>SeaLevel</dt><dd><p>A numeric vector of annual sea level
maxima.</p>
</dd>
<dt>SOI</dt><dd><p>A numeric vector of annual mean values of
the Southern Oscillation Index.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='gamGPDfitboot'>Smooth Parameter Estimation and Bootstrapping of Generalized Pareto Distributions
with Penalized Maximum Likelihood Estimation</h2><span id='topic+gamGPDfit'></span><span id='topic+gamGPDboot'></span>

<h3>Description</h3>

<p><code>gamGPDfit()</code> fits the parameters of a generalized Pareto
distribution (GPD) depending on covariates in a non- or semiparametric
way.
</p>
<p><code>gamGPDboot()</code> fits and bootstraps the parameters of a GPD
distribution depending on covariates in a non- or semiparametric
way. Applies the post-blackend bootstrap of Chavez-Demoulin and
Davison (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamGPDfit(x, threshold, nexc=NULL, datvar, xiFrhs, nuFrhs,
          init=gpd.fit(x[, datvar], threshold=threshold, show=FALSE)$mle[2:1],
          niter=32, include.updates=FALSE, epsxi=1e-05, epsnu=1e-05,
          progress=TRUE, verbose=FALSE, ...)
gamGPDboot(x, B, threshold, nexc=NULL, datvar, xiFrhs, nuFrhs,
           init=gpd.fit(x[, datvar], threshold=threshold, show=FALSE)$mle[2:1],
           niter=32, include.updates=FALSE, epsxi=1e-5, epsnu=1e-5,
           boot.progress=TRUE, progress=FALSE, verbose=FALSE, debug=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamGPDfitboot_+3A_x">x</code></td>
<td>
<p>data.frame containing the losses (in some component; can be
specified with the argument <code>datvar</code>; the other components
contain the covariates).</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_b">B</code></td>
<td>
<p>number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_threshold">threshold</code></td>
<td>
<p>threshold of the peaks-over-threshold (POT)
method.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_nexc">nexc</code></td>
<td>
<p>number of excesses. This can be used to determine</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_datvar">datvar</code></td>
<td>
<p>name of the data column in <code>x</code> which contains the
the data to be modeled.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_xifrhs">xiFrhs</code></td>
<td>
<p>right-hand side of the formula for <code class="reqn">\xi</code> in
the <code>gam()</code> call for fitting <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_nufrhs">nuFrhs</code></td>
<td>
<p>right-hand side of the formula for <code class="reqn">\nu</code> in
the <code>gam()</code> call for fitting <code class="reqn">\nu</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_init">init</code></td>
<td>
<p>bivariate vector containing initial values
for <code class="reqn">(\xi, \beta)</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_niter">niter</code></td>
<td>
<p>maximal number of iterations in the backfitting
algorithm.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_include.updates">include.updates</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether
updates for xi and nu are returned as well (note: this might lead to
objects of large size).</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_epsxi">epsxi</code></td>
<td>
<p>epsilon for stop criterion for <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_epsnu">epsnu</code></td>
<td>
<p>epsilon for stop criterion for <code class="reqn">\nu</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_boot.progress">boot.progress</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating
whether progress information about <code>gamGPDboot()</code> is displayed.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_progress">progress</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether progress information about
<code>gamGPDfit()</code> is displayed. For <code>gamGPDboot()</code>,
<code>progress</code> is only passed to <code>gamGPDfit()</code> in the case that
<code>boot.progress==TRUE</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether additional
information (in case of undesired behavior) is printed. For <code>gamGPDboot()</code>,
<code>progress</code> is only passed to <code>gamGPDfit()</code> if
<code>boot.progress==TRUE</code>.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_debug">debug</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether initial fit
(before the bootstrap is initiated) is saved.</p>
</td></tr>
<tr><td><code id="gamGPDfitboot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>gam()</code> (which is
called internally; see the source code of <code>gamGPDfitUp()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gamGPDfit()</code> fits the parameters <code class="reqn">\xi</code> and
<code class="reqn">\beta</code> of the generalized Pareto distribution
<code class="reqn">\mathrm{GPD}(\xi,\beta)</code> depending on covariates in
a non- or semiparametric way. The distribution function is given by
</p>
<p style="text-align: center;"><code class="reqn">G_{\xi,\beta}(x)=1-(1+\xi x/\beta)^{-1/\xi},\quad
    x\ge0,</code>
</p>

<p>for <code class="reqn">\xi&gt;0</code> (which is what we assume) and
<code class="reqn">\beta&gt;0</code>. Note that <code class="reqn">\beta</code> is also denoted by
<code class="reqn">\sigma</code> in this package. Estimation of <code class="reqn">\xi</code>
and <code class="reqn">\beta</code> by <code>gamGPDfit()</code> is done via penalized maximum
likelihood estimation, where the estimators are computed with a
backfitting algorithm. In order to guarantee convergence of this
algorithm, a reparameterization of <code class="reqn">\beta</code> in terms of the parameter
<code class="reqn">\nu</code> is done via
</p>
<p style="text-align: center;"><code class="reqn">\beta=\exp(\nu)/(1+\xi).</code>
</p>

<p>The parameters <code class="reqn">\xi</code> and <code class="reqn">\nu</code> (and thus
<code class="reqn">\beta</code>) are allowed to depend on covariates (including
time) in a non- or semiparametric way, for example:
</p>
<p style="text-align: center;"><code class="reqn">\xi=\xi(\bm{x},t)=\bm{x}^{\top}\bm{\alpha}_{\xi}+h_{\xi}(t),</code>
</p>

<p style="text-align: center;"><code class="reqn">\nu=\nu(\bm{x},t)=\bm{x}^{\top}\bm{\alpha}_{\nu}+h_{\nu}(t),</code>
</p>

<p>where <code class="reqn">\bm{x}</code> denotes the vector of covariates,
<code class="reqn">\bm{\alpha}_{\xi}</code>, <code class="reqn">\bm{\alpha}_{\nu}</code>
are parameter vectors and <code class="reqn">h_{\xi}</code>, <code class="reqn">h_{\nu}</code> are
regression splines. For more details, see the references and the source
code.
</p>
<p><code>gamGPDboot()</code> first fits the GPD parameters via
<code>gamGPDfit()</code>. It then conducts the post-blackend bootstrap of
Chavez-Demoulin and Davison (2005). To this end, it computes the
residuals, resamples them (<code>B</code> times), reconstructs the
corresponding excesses, and refits the GPD parameters via
<code>gamGPDfit()</code> again.
</p>


<h3>Value</h3>

<p><code>gamGPDfit()</code> returns a list with the components
</p>

<dl>
<dt><code>xi</code>:</dt><dd><p>estimated parameters <code class="reqn">\xi</code>;</p>
</dd>
<dt><code>beta</code>:</dt><dd><p>estimated parameters <code class="reqn">\beta</code>;</p>
</dd>
<dt><code>nu</code>:</dt><dd><p>estimated parameters <code class="reqn">\nu</code>;</p>
</dd>
<dt><code>se.xi</code>:</dt><dd><p>standard error for <code class="reqn">\xi</code> ((possibly
adjusted) second-order derivative of the reparameterized
log-likelihood with respect to <code class="reqn">\xi</code>) multiplied by -1;</p>
</dd>
<dt><code>se.nu</code>:</dt><dd><p>standard error for <code class="reqn">\nu</code> ((possibly
adjusted) second-order derivative of the reparameterized
log-likelihood with respect to <code class="reqn">\nu</code>) multiplied by -1;</p>
</dd>
<dt><code>xi.covar</code>:</dt><dd><p>(unique) covariates for <code class="reqn">\xi</code>;</p>
</dd>
<dt><code>nu.covar</code>:</dt><dd><p>(unique) covariates for <code class="reqn">\nu</code>;</p>
</dd>
<dt><code>covar</code>:</dt><dd><p>available covariate combinations used for
fitting <code class="reqn">\beta</code>(<code class="reqn">\xi</code>, <code class="reqn">\nu</code>);</p>
</dd>
<dt><code>y</code>:</dt><dd><p>vector of excesses (exceedances minus threshold);</p>
</dd>
<dt><code>res</code>:</dt><dd><p>residuals;</p>
</dd>
<dt><code>MRD</code>:</dt><dd><p>mean relative distances between for all
iterations, calculated between old parameters <code class="reqn">(\xi, \nu)</code> (from the last iteration) and new parameters (currently
estimated ones);</p>
</dd>
<dt><code>logL</code>:</dt><dd><p>log-likelihood at the estimated parameters;</p>
</dd>
<dt><code>xiObj</code>:</dt><dd><p><span class="rlang"><b>R</b></span> object of type <code>gamObject</code> for estimated
<code class="reqn">\xi</code> (returned by <code>mgcv::gam()</code>);</p>
</dd>
<dt><code>nuObj</code>:</dt><dd><p><span class="rlang"><b>R</b></span> object of type <code>gamObject</code> for estimated
<code class="reqn">\nu</code> (returned by <code>mgcv::gam()</code>);</p>
</dd>
<dt><code>xiUpdates</code>:</dt><dd><p>if <code>include.updates</code> is
<code><a href="base.html#topic+TRUE">TRUE</a></code>, updates for <code class="reqn">\xi</code> for each
iteration. This is a list of <span class="rlang"><b>R</b></span> objects of type <code>gamObject</code>
which contains <code>xiObj</code> as last element;</p>
</dd>
<dt><code>nuUpdates</code>:</dt><dd><p>if <code>include.updates</code> is
<code><a href="base.html#topic+TRUE">TRUE</a></code>, updates for <code class="reqn">\nu</code> for each
iteration. This is a list of <span class="rlang"><b>R</b></span> objects of type <code>gamObject</code>
which contains <code>nuObj</code> as last element;</p>
</dd>
</dl>

<p><code>gamGPDboot()</code> returns a list of length <code>B+1</code> where the
first component contains the results of
the initial fit via <code>gamGPDfit()</code> and the other <code>B</code>
components contain the results for each replication of the
post-blackend bootstrap.
</p>


<h3>Author(s)</h3>

<p>Marius Hofert, Valerie Chavez-Demoulin.</p>


<h3>References</h3>

<p>Chavez-Demoulin, V., and Davison, A. C. (2005),
Generalized additive models for sample extremes,
<em>Applied Statistics</em> <b>54</b>(1), 207&ndash;222.
</p>
<p>Chavez-Demoulin, V., and Hofert, M. (to be submitted),
Smooth extremal models fitted by penalized maximum likelihood
estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example 1: fitting capability ##############################################

## generate an example data set
years &lt;- 2003:2012 # years
nyears &lt;- length(years)
n &lt;- 250 # sample size for each (different) xi
u &lt;- 200 # threshold
rGPD &lt;- function(n, xi, beta) ((1-runif(n))^(-xi)-1)*beta/xi # sampling GPD

set.seed(17) # setting seed
xi.true.A &lt;- seq(0.4, 0.8, length=nyears) # true xi for group "A"
## generate losses for group "A"
lossA &lt;- unlist(lapply(1:nyears,
                       function(y) u + rGPD(n, xi=xi.true.A[y], beta=1)))
xi.true.B &lt;- xi.true.A^2 # true xi for group "B"
## generate losses for group "B"
lossB &lt;- unlist(lapply(1:nyears,
                       function(y) u + rGPD(n, xi=xi.true.B[y], beta=1)))
## build data frame
time &lt;- rep(rep(years, each=n), 2) # "2" stands for the two groups
covar &lt;- rep(c("A","B"), each=n*nyears)
value &lt;- c(lossA, lossB)
x &lt;- data.frame(covar=covar, time=time, value=value)

## fit
eps &lt;- 1e-3 # to decrease the run time for this example
fit &lt;- gamGPDfit(x, threshold=u, datvar="value", xiFrhs=~covar+s(time)-1,
                 nuFrhs=~covar+s(time)-1, epsxi=eps, epsnu=eps)
## note: choosing s(..., bs="cr") will fit cubic splines

## grab the fitted values per group and year
xi.fit &lt;- fitted(fit$xiObj)
xi.fit. &lt;- xi.fit[1+(0:(2*nyears-1))*n] # pick fit for each group and year
xi.fit.A &lt;- xi.fit.[1:nyears] # fit for "A" and each year
xi.fit.B &lt;- xi.fit.[(nyears+1):(2*nyears)] # fit for "B" and each year

## plot the fitted values of xi and the true ones we simulated from
par(mfrow=c(1,2))
plot(years, xi.true.A, type="l", ylim=range(xi.true.A, xi.fit.A),
     main="Group A", xlab="Year", ylab=expression(xi))
points(years, xi.fit.A, type="l", col="red")
legend("topleft", inset=0.04, lty=1, col=c("black", "red"),
       legend=c("true", "fitted"), bty="n")
plot(years, xi.true.B, type="l", ylim=range(xi.true.B, xi.fit.B),
     main="Group B", xlab="Year", ylab=expression(xi))
points(years, xi.fit.B, type="l", col="blue")
legend("topleft", inset=0.04, lty=1, col=c("black", "blue"),
       legend=c("true", "fitted"), bty="n")

## Not run: 
### Example 2: Comparison of (the more general) gamGPDfit() with gpd.fit() ########

set.seed(17) # setting seed
xi.true.A &lt;- rep(0.4, length=nyears)
xi.true.B &lt;- rep(0.8, length=nyears)
## generate losses for group "A"
lossA &lt;- unlist(lapply(1:nyears,
                       function(y) u + rGPD(n, xi=xi.true.A[y], beta=1)))
## generate losses for group "B"
lossB &lt;- unlist(lapply(1:nyears,
                       function(y) u + rGPD(n, xi=xi.true.B[y], beta=1)))
## build data frame
x &lt;- data.frame(covar=covar, time=time, value=c(lossA, lossB))

## fit with gpd.fit
fit.coles &lt;- gpd.fit(x$value, threshold=u, shl=1, sigl=1, ydat=x)
xi.fit.coles.A &lt;- fit.coles$mle[3]+1*fit.coles$mle[4]
xi.fit.coles.B &lt;- fit.coles$mle[3]+2*fit.coles$mle[4]

## fit with gamGPDfit()
fit &lt;- gamGPDfit(x, threshold=u, datvar="value", xiFrhs=~covar, nuFrhs=~covar,
                 epsxi=eps, epsnu=eps)
xi.fit &lt;- fitted(fit$xiObj)
xi.fit.A &lt;- as.numeric(xi.fit[1]) # fit for group "A"
xi.fit.B &lt;- as.numeric(xi.fit[nyears*n+1]) # fit for group "B"

## comparison
xi.fit.A-xi.fit.coles.A
xi.fit.B-xi.fit.coles.B

## End(Not run) # dontrun
</code></pre>

<hr>
<h2 id='gev.diag'>Diagnostic Plots for GEV Models</h2><span id='topic+gev.diag'></span>

<h3>Description</h3>

<p>Produces diagnostic plots for GEV models using the output
of the function <code>gev.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev.diag(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev.diag_+3A_z">z</code></td>
<td>
<p>An object returned by <code>gev.fit</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>For stationary models four plots are produced; a probability
plot, a quantile plot, a return level plot and a histogram
of data with fitted density.
</p>
<p>For non-stationary models two plots are produced; a residual
probability plot and a residual quantile plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gev.fit">gev.fit</a></code>, <code><a href="#topic+gev.prof">gev.prof</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(portpirie)
ppfit &lt;- gev.fit(portpirie[,2])
gev.diag(ppfit)
</code></pre>

<hr>
<h2 id='gev.fit'>Maximum-likelihood Fitting of the GEV Distribution</h2><span id='topic+gev.fit'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the generalized extreme value distribution,
including generalized linear modelling of each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev.fit(xdat, ydat = NULL, mul = NULL, sigl = NULL, shl = NULL, 
    mulink = identity, siglink = identity, shlink = identity, 
    muinit = NULL, siginit = NULL, shinit = NULL,
    show = TRUE, method = "Nelder-Mead", maxit = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev.fit_+3A_xdat">xdat</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_ydat">ydat</code></td>
<td>
<p>A matrix of covariates for generalized linear modelling
of the parameters (or <code>NULL</code> (the default) for stationary
fitting). The number of rows should be the same as the length
of <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_mul">mul</code>, <code id="gev.fit_+3A_sigl">sigl</code>, <code id="gev.fit_+3A_shl">shl</code></td>
<td>
<p>Numeric vectors of integers, giving the columns
of <code>ydat</code> that contain covariates for generalized linear
modelling of the location, scale and shape parameters repectively
(or <code>NULL</code> (the default) if the corresponding parameter is
stationary).</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_mulink">mulink</code>, <code id="gev.fit_+3A_siglink">siglink</code>, <code id="gev.fit_+3A_shlink">shlink</code></td>
<td>
<p>Inverse link functions for generalized
linear modelling of the location, scale and shape parameters
repectively.</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_muinit">muinit</code>, <code id="gev.fit_+3A_siginit">siginit</code>, <code id="gev.fit_+3A_shinit">shinit</code></td>
<td>
<p>numeric of length equal to total number
of parameters used to model the location, scale or shape parameter(s),
resp.  See Details section for default (NULL) initial values.</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), print details of
the fit.</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="gev.fit_+3A_...">...</code></td>
<td>
<p>Other control parameters for the optimization. These
are passed to components of the <code>control</code> argument of
<code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The form of the GEV used is that of Coles (2001) Eq (3.2).  Specifically,
positive values of the shape parameter imply a heavy tail, and negative values
imply a bounded upper tail.
</p>
<p>For non-stationary fitting it is recommended that the covariates
within the generalized linear models are (at least approximately)
centered and scaled (i.e.\ the columns of <code>ydat</code> should be
approximately centered and scaled).
</p>
<p>Let m=mean(xdat) and s=sqrt(6*var(xdat))/pi.  Then, initial values
assigend when 'muinit' is NULL are m - 0.57722 * s (stationary case).
When 'siginit' is NULL, the initial value is taken to be s, and when
'shinit' is NULL, the initial value is taken to be 0.1.  When
covariates are introduced (non-stationary case), these same initial
values are used by default for the constant term, and zeros for all
other terms.  For example, if a GEV( mu(t)=mu0+mu1*t, sigma, xi) is
being fitted, then the initial value for mu0 is m - 0.57722 * s, and
0 for mu1.
</p>


<h3>Value</h3>

<p>A list containing the following components. A subset of these
components are printed after the fit. If <code>show</code> is
<code>TRUE</code>, then assuming that successful convergence is
indicated, the components <code>nllh</code>, <code>mle</code> and <code>se</code>
are always printed.
</p>
<table>
<tr><td><code>nllh</code></td>
<td>
<p>single numeric giving the negative log-likelihood value.</p>
</td></tr>  
<tr><td><code>mle</code></td>
<td>
<p>numeric vector giving the MLE's for the location, scale and shape parameters, resp.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>numeric vector giving the standard errors for the MLE's for the location, scale and shape parameters, resp.</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>An logical indicator for a non-stationary fit.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list with components <code>mul</code>, <code>sigl</code>
and <code>shl</code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A character vector giving inverse link functions.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>The convergence code, taken from the list returned by
<code><a href="stats.html#topic+optim">optim</a></code>. A zero indicates successful convergence.</p>
</td></tr>
<tr><td><code>nllh</code></td>
<td>
<p>The negative logarithm of the likelihood evaluated at
the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data that has been fitted. For non-stationary
models, the data is standardized.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The covariance matrix.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A matrix with three columns containing the maximum
likelihood estimates of the location, scale and shape parameters
at each data point.</p>
</td></tr>  
</table>


<h3>References</h3>

<p>Coles, S., 2001.  An Introduction to Statistical Modeling of Extreme Values.  Springer-Verlag, London, U.K., 208pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gev.diag">gev.diag</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+gev.prof">gev.prof</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(portpirie)
gev.fit(portpirie[,2])
</code></pre>

<hr>
<h2 id='gev.prof'>Profile Log-likelihoods for Stationary GEV Models</h2><span id='topic+gev.prof'></span><span id='topic+gev.profxi'></span>

<h3>Description</h3>

<p>Produce profile log-likelihoods for shape parameters and
m year/block return levels for stationary GEV models using
the output of the function <code>gev.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev.prof(z, m, xlow, xup, conf = 0.95, nint = 100)
gev.profxi(z, xlow, xup, conf = 0.95, nint = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev.prof_+3A_z">z</code></td>
<td>
<p>An object returned by <code>gev.fit</code>. The object
should represent a stationary model.</p>
</td></tr>
<tr><td><code id="gev.prof_+3A_m">m</code></td>
<td>
<p>The return level (i.e.\ the profile likelihood is for
the value that is exceeded with probability 1/<code>m</code>).</p>
</td></tr>
<tr><td><code id="gev.prof_+3A_xlow">xlow</code>, <code id="gev.prof_+3A_xup">xup</code></td>
<td>
<p>The least and greatest value at which to
evaluate the profile likelihood.</p>
</td></tr>
<tr><td><code id="gev.prof_+3A_conf">conf</code></td>
<td>
<p>The confidence coefficient of the plotted profile
confidence interval.</p>
</td></tr>
<tr><td><code id="gev.prof_+3A_nint">nint</code></td>
<td>
<p>The number of points at which the profile
likelihood is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the profile likelihood is produced, with a horizontal
line representing a profile confidence interval with confidence
coefficient <code>conf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gev.fit">gev.fit</a></code>, <code><a href="#topic+gev.diag">gev.diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(portpirie)
ppfit &lt;- gev.fit(portpirie[,2])
## Not run: gev.prof(ppfit, m = 10, 4.1, 5)
## Not run: gev.profxi(ppfit, -0.3, 0.3)
</code></pre>

<hr>
<h2 id='glass'>Breaking Strengths of Glass Fibres</h2><span id='topic+glass'></span>

<h3>Description</h3>

<p>A numeric vector containing breaking strengths of 63 glass
fibres of length 1.5 centimetres, recorded under experimental
conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(glass)</code></pre>


<h3>Format</h3>

<p>A vector containing 63 observations.</p>


<h3>Source</h3>

<p>Smith, R. L. and Naylor, J. C. (1987)
A comparison of maximum likelihood and Bayesian estimators
for the three-parameter Weibull distribution.
<em>Applied Statistics</em> <b>36</b>, 358&ndash;396.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='gpd.diag'>Diagnostic Plots for GPD Models</h2><span id='topic+gpd.diag'></span>

<h3>Description</h3>

<p>Produces diagnostic plots for GPD models using the output
of the function <code>gpd.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.diag(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd.diag_+3A_z">z</code></td>
<td>
<p>An object returned by <code>gpd.fit</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>For stationary models four plots are produced; a probability
plot, a quantile plot, a return level plot and a histogram
of data with fitted density.
</p>
<p>For non-stationary models two plots are produced; a residual
probability plot and a residual quantile plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd.fit">gpd.fit</a></code>, <code><a href="#topic+gpd.prof">gpd.prof</a></code>,
<code><a href="#topic+pp.fit">pp.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
rnfit &lt;- gpd.fit(rain, 10)
gpd.diag(rnfit)
</code></pre>

<hr>
<h2 id='gpd.fit'>Maximum-likelihood Fitting for the GPD Model</h2><span id='topic+gpd.fit'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the GPD model,
including generalized linear modelling of each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.fit(xdat, threshold, npy = 365, ydat = NULL, sigl = NULL,
    shl = NULL, siglink = identity, shlink = identity, siginit = NULL,
    shinit = NULL, show = TRUE,
    method = "Nelder-Mead", maxit = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd.fit_+3A_xdat">xdat</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_threshold">threshold</code></td>
<td>
<p>The threshold; a single number or a numeric
vector of the same length as <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_npy">npy</code></td>
<td>
<p>The number of observations per year/block.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_ydat">ydat</code></td>
<td>
<p>A matrix of covariates for generalized linear modelling
of the parameters (or <code>NULL</code> (the default) for stationary
fitting). The number of rows should be the same as the length
of <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_sigl">sigl</code>, <code id="gpd.fit_+3A_shl">shl</code></td>
<td>
<p>Numeric vectors of integers, giving the columns
of <code>ydat</code> that contain covariates for generalized linear
modelling of the scale and shape parameters repectively
(or <code>NULL</code> (the default) if the corresponding parameter is
stationary).</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_siglink">siglink</code>, <code id="gpd.fit_+3A_shlink">shlink</code></td>
<td>
<p>Inverse link functions for generalized
linear modelling of the scale and shape parameters repectively.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_siginit">siginit</code>, <code id="gpd.fit_+3A_shinit">shinit</code></td>
<td>
<p>numeric giving initial value(s) for parameter
estimates.  If NULL, default is sqrt(6 * var(xdat))/pi and 0.1
for the scale and shape parameters, resp.  If using parameter
covariates, then these values are used for the constant term,
and zeros for all other terms.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), print details of
the fit.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="gpd.fit_+3A_...">...</code></td>
<td>
<p>Other control parameters for the optimization. These
are passed to components of the <code>control</code> argument of
<code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-stationary fitting it is recommended that the covariates
within the generalized linear models are (at least approximately)
centered and scaled (i.e.\ the columns of <code>ydat</code> should be
approximately centered and scaled).
</p>
<p>The form of the GP model used follows Coles (2001) Eq (4.7).  In particular,
the shape parameter is defined so that positive values imply a heavy tail
and negative values imply a bounded upper value.
</p>


<h3>Value</h3>

<p>A list containing the following components. A subset of these
components are printed after the fit. If <code>show</code> is
<code>TRUE</code>, then assuming that successful convergence is
indicated, the components <code>nexc</code>, <code>nllh</code>,
<code>mle</code>, <code>rate</code> and <code>se</code> are always printed.
</p>
<table>
<tr><td><code>nexc</code></td>
<td>
<p>single numeric giving the number of threshold exceedances.</p>
</td></tr>
<tr><td><code>nllh</code></td>
<td>
<p>nsingle umeric giving the negative log-likelihood value.</p>
</td></tr> 
<tr><td><code>mle</code></td>
<td>
<p>numeric vector giving the MLE's for the scale and shape parameters, resp.</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>
<p>single numeric giving the estimated probability of exceeding the threshold.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>numeric vector giving the standard error estiamtes for the scale and shape parameter estimates, resp.</p>
</td></tr>
<tr><td><code>trans</code></td>
<td>
<p>An logical indicator for a non-stationary fit.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list with components <code>sigl</code> and <code>shl</code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A character vector giving inverse link functions.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold, or vector of thresholds.</p>
</td></tr>
<tr><td><code>nexc</code></td>
<td>
<p>The number of data points above the threshold.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data that lie above the threshold. For
non-stationary models, the data is standardized.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>The convergence code, taken from the list returned by
<code><a href="stats.html#topic+optim">optim</a></code>. A zero indicates successful convergence.</p>
</td></tr>
<tr><td><code>nllh</code></td>
<td>
<p>The negative logarithm of the likelihood evaluated at
the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A matrix with three columns containing the maximum
likelihood estimates of the scale and shape parameters, and
the threshold, at each data point.</p>
</td></tr> 
<tr><td><code>mle</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>rate</code></td>
<td>
<p>The proportion of data points that lie above the
threshold.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The covariance matrix.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of data points (i.e.\ the length of
<code>xdat</code>).</p>
</td></tr>
<tr><td><code>npy</code></td>
<td>
<p>The number of observations per year/block.</p>
</td></tr>
<tr><td><code>xdata</code></td>
<td>
<p>The data that has been fitted.</p>
</td></tr> 
</table>


<h3>References</h3>

<p>Coles, S., 2001.  An Introduction to Statistical Modeling of Extreme Values.  Springer-Verlag, London, U.K., 208pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd.diag">gpd.diag</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+gpd.prof">gpd.prof</a></code>, <code><a href="#topic+gpd.fitrange">gpd.fitrange</a></code>,
<code><a href="#topic+mrl.plot">mrl.plot</a></code>, <code><a href="#topic+pp.fit">pp.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
gpd.fit(rain, 10)
</code></pre>

<hr>
<h2 id='gpd.fitrange'>Fitting the GPD Model Over a Range of Thresholds</h2><span id='topic+gpd.fitrange'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for a stationary GPD model,
over a range of thresholds. Graphs of parameter estimates
which aid the selection of a threshold are produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.fitrange(data, umin, umax, nint = 10, show = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd.fitrange_+3A_data">data</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="gpd.fitrange_+3A_umin">umin</code>, <code id="gpd.fitrange_+3A_umax">umax</code></td>
<td>
<p>The minimum and maximum thresholds at which
the model is fitted.</p>
</td></tr>
<tr><td><code id="gpd.fitrange_+3A_nint">nint</code></td>
<td>
<p>The number of fitted models.</p>
</td></tr>
<tr><td><code id="gpd.fitrange_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code>, print details of each
fit.</p>
</td></tr>
<tr><td><code id="gpd.fitrange_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>gpd.fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two graphs showing maximum likelihood estimates and confidence
intervals of the shape and modified scale parameters over a
range of thresholds are produced.  A list object is returned invisibly
with components:
'threshold' numeric vector of length 'nint' giving the thresholds used,
'mle' an 'nint X 3' matrix giving the maximum likelihood parameter estimates
(columns are location, scale and shape respectively),
'se' an 'nint X 3' matrix giving the estimated standard errors for the
parameter estimates (columns are location, scale and shape, resp.),
'ci.low', 'ci.up' 'nint X 3' matrices giving the lower and upper 95
intervals, resp. (columns same as for 'mle' and 'se').
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd.fit">gpd.fit</a></code>, <code><a href="#topic+mrl.plot">mrl.plot</a></code>,
<code><a href="#topic+pp.fit">pp.fit</a></code>, <code><a href="#topic+pp.fitrange">pp.fitrange</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(rain)
## Not run: gpd.fitrange(rain, 10, 40)
</code></pre>

<hr>
<h2 id='gpd.prof'>Profile Log-likelihoods for Stationary GPD Models</h2><span id='topic+gpd.prof'></span><span id='topic+gpd.profxi'></span>

<h3>Description</h3>

<p>Produce profile log-likelihoods for shape parameters and
m year/block return levels for stationary GPD models using
the output of the function <code>gpd.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd.prof(z, m, xlow, xup, npy = 365, conf = 0.95, nint = 100)
gpd.profxi(z, xlow, xup, conf = 0.95, nint = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd.prof_+3A_z">z</code></td>
<td>
<p>An object returned by <code>gpd.fit</code>. The object
should represent a stationary model.</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_m">m</code></td>
<td>
<p>The return level (i.e.\ the profile likelihood is for
the value that is exceeded with probability 1/<code>m</code>).</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_xlow">xlow</code>, <code id="gpd.prof_+3A_xup">xup</code></td>
<td>
<p>The least and greatest value at which to
evaluate the profile likelihood.</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_npy">npy</code></td>
<td>
<p>The number of observations per year.</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_conf">conf</code></td>
<td>
<p>The confidence coefficient of the plotted profile
confidence interval.</p>
</td></tr>
<tr><td><code id="gpd.prof_+3A_nint">nint</code></td>
<td>
<p>The number of points at which the profile
likelihood is evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the profile likelihood is produced, with a horizontal
line representing a profile confidence interval with confidence
coefficient <code>conf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd.fit">gpd.fit</a></code>, <code><a href="#topic+gpd.diag">gpd.diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
rnfit &lt;- gpd.fit(rain, 10)
## Not run: gpd.prof(rnfit, m = 10, 55, 75)
## Not run: gpd.profxi(rnfit, -0.02, 0.15)
</code></pre>

<hr>
<h2 id='gum.diag'>Diagnostic Plots for Gumbel Models</h2><span id='topic+gum.diag'></span>

<h3>Description</h3>

<p>Produces diagnostic plots for Gumbel models using the output
of the function <code>gum.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gum.diag(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gum.diag_+3A_z">z</code></td>
<td>
<p>An object returned by <code>gum.fit</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>For stationary models four plots are produced; a probability
plot, a quantile plot, a return level plot and a histogram
of data with fitted density.
</p>
<p>For non-stationary models two plots are produced; a residual
probability plot and a residual quantile plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gev.fit">gev.fit</a></code>, <code><a href="#topic+gum.fit">gum.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(portpirie)
ppfit &lt;- gum.fit(portpirie[,2])
gum.diag(ppfit)
</code></pre>

<hr>
<h2 id='gum.fit'>Maximum-likelihood Fitting of the Gumbel Distribution</h2><span id='topic+gum.fit'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the gumbel distribution,
including generalized linear modelling of each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gum.fit(xdat, ydat = NULL, mul = NULL, sigl = NULL, mulink = identity,
    siglink = identity, muinit = NULL, siginit = NULL, show = TRUE,
    method = "Nelder-Mead", maxit = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gum.fit_+3A_xdat">xdat</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_ydat">ydat</code></td>
<td>
<p>A matrix of covariates for generalized linear modelling
of the parameters (or <code>NULL</code> (the default) for stationary
fitting). The number of rows should be the same as the length
of <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_mul">mul</code>, <code id="gum.fit_+3A_sigl">sigl</code></td>
<td>
<p>Numeric vectors of integers, giving the columns
of <code>ydat</code> that contain covariates for generalized linear
modelling of the location and scale parameters repectively
(or <code>NULL</code> (the default) if the corresponding parameter is
stationary).</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_mulink">mulink</code>, <code id="gum.fit_+3A_siglink">siglink</code></td>
<td>
<p>Inverse link functions for generalized
linear modelling of the location and scale parameters
repectively.</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_muinit">muinit</code>, <code id="gum.fit_+3A_siginit">siginit</code></td>
<td>
<p>numeric giving initial parameter estimates.  See
Details section for information about default values (NULL).</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), print details of
the fit.</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="gum.fit_+3A_...">...</code></td>
<td>
<p>Other control parameters for the optimization. These
are passed to components of the <code>control</code> argument of
<code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-stationary fitting it is recommended that the covariates
within the generalized linear models are (at least approximately)
centered and scaled (i.e.\ the columns of <code>ydat</code> should be
approximately centered and scaled).
</p>
<p>Let m=mean(xdat) and s=sqrt(6*var(xdat))/pi.  Then, initial values
assigend when 'muinit' is NULL are m - 0.57722 * s (stationary case).
When 'siginit' is NULL, the initial value is taken to be s, and when
'shinit' is NULL.  When covariates are introduced (non-stationary case),
these same initial values are used by default for the constant term,
and zeros for all other terms.  For example, if a
Gumbel( mu(t)=mu0+mu1*t, sigma) is being fitted, then the initial value
for mu0 is m - 0.57722 * s, and 0 for mu1.
</p>


<h3>Value</h3>

<p>A list containing the following components. A subset of these
components are printed after the fit. If <code>show</code> is
<code>TRUE</code>, then assuming that successful convergence is
indicated, the components <code>nllh</code>, <code>mle</code> and <code>se</code>
are always printed.
</p>
<table>
<tr><td><code>trans</code></td>
<td>
<p>An logical indicator for a non-stationary fit.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list with components <code>mul</code> and <code>sigl</code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A character vector giving inverse link functions.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>The convergence code, taken from the list returned by
<code><a href="stats.html#topic+optim">optim</a></code>. A zero indicates successful convergence.</p>
</td></tr>
<tr><td><code>nllh</code></td>
<td>
<p>The negative logarithm of the likelihood evaluated at
the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data that has been fitted. For non-stationary
models, the data is standardized.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The covariance matrix.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A matrix with two columns containing the maximum
likelihood estimates of the location and scale parameters
at each data point.</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gum.diag">gum.diag</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+gev.fit">gev.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(portpirie)
gum.fit(portpirie[,2])
</code></pre>

<hr>
<h2 id='ismev'>ismev &ndash; an Introduction to Statistical Modeling of Extreme Values</h2><span id='topic+ismev'></span>

<h3>Description</h3>

<p><span class="pkg">ismev</span> includes functions to support the computations carried out in Coles (2001). The functions may be divided into the following groups; maxima/minima, order statistics, peaks over thresholds and point processes.  <span class="pkg">ismev</span> is an R port of the S-Plus extreme value statistical routines believed to be originally written by Janet E. Heffernan.
</p>
<p>Primary functions include:
</p>
<p><code>gev.fit</code>, <code>gev.diag</code>, <code>gpd.fit</code>, <code>gpd.diag</code>, <code>pp.fit</code> and <code>pp.diag</code>.
</p>
<p>Original R port was carried out by Alec G. Stephenson, and the package is
currently being maintained by Eric Gilleland.
</p>
<p>Datasets from Coles (2001) included are:
</p>
<p>dowjones
euroex
fremantle
portpirie
venice
wind
engine
exchange
glass
rain
wavesurge
wooster
</p>


<h3>References</h3>

<p>Coles, Stuart (2001) <em>An Introduction to Statistical Modeling of Extreme Values</em>, London, UK: Springer, ISBN: 1852334592, 208 pp.
</p>

<hr>
<h2 id='ismev-internal'>Internal Functions</h2><span id='topic+GPD.fit'></span><span id='topic+GPD.predict'></span><span id='topic+lambda.fit'></span><span id='topic+lambda.predict'></span><span id='topic+gev.pp'></span><span id='topic+gpd.pp'></span><span id='topic+pp.pp'></span><span id='topic+rlarg.pp'></span><span id='topic+gev.qq'></span><span id='topic+gpd.qq'></span><span id='topic+pp.qq'></span><span id='topic+rlarg.qq'></span><span id='topic+gev.rl'></span><span id='topic+gum.rl'></span><span id='topic+gpd.rl'></span><span id='topic+gev.rl.gradient'></span><span id='topic+gpd.rl.gradient'></span><span id='topic+gev.his'></span><span id='topic+gpd.his'></span><span id='topic+gevf'></span><span id='topic+gpdf'></span><span id='topic+ppf'></span><span id='topic+rlargf'></span><span id='topic+gum.df'></span><span id='topic+gevq'></span><span id='topic+gpdq'></span><span id='topic+gpdq2'></span><span id='topic+ppq'></span><span id='topic+rlargq'></span><span id='topic+rlargq2'></span><span id='topic+gum.q'></span><span id='topic+gev.dens'></span><span id='topic+gpd.dens'></span><span id='topic+gum.dens'></span><span id='topic+ppp'></span><span id='topic+q.form'></span><span id='topic+DrLogL'></span><span id='topic+LambdaPredict'></span><span id='topic+adjustD2'></span><span id='topic+gamGPDfitUp'></span><span id='topic+rLogL'></span><span id='topic+sample.real'></span><span id='topic+xibetaFitCI'></span><span id='topic+xibetaPredict'></span>

<h3>Description</h3>

<p>Not to be called by the user.
</p>

<hr>
<h2 id='mrl.plot'>Mean Residual Life Plot</h2><span id='topic+mrl.plot'></span>

<h3>Description</h3>

<p>An empirical mean residual life plot, including confidence
intervals, is produced. The mean residual life plot aids
the selection of a threshold for the GPD or point process
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrl.plot(data, umin = min(data), umax = max(data) - 0.1,
    conf = 0.95, nint = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrl.plot_+3A_data">data</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="mrl.plot_+3A_umin">umin</code>, <code id="mrl.plot_+3A_umax">umax</code></td>
<td>
<p>The minimum and maximum thresholds at which
the mean residual life function is calculated.</p>
</td></tr>
<tr><td><code id="mrl.plot_+3A_conf">conf</code></td>
<td>
<p>The confidence coefficient for the confidence
intervals depicted in the plot.</p>
</td></tr>
<tr><td><code id="mrl.plot_+3A_nint">nint</code></td>
<td>
<p>The number of points at which the mean residual
life function is calculated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gpd.fit">gpd.fit</a></code>, <code><a href="#topic+gpd.fitrange">gpd.fitrange</a></code>,
<code><a href="#topic+pp.fit">pp.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
mrl.plot(rain)
</code></pre>

<hr>
<h2 id='portpirie'>Annual Maximum Sea Levels at Port Pirie, South Australia</h2><span id='topic+portpirie'></span>

<h3>Description</h3>

<p>The <code>portpirie</code> data frame has 65 rows and 2 columns.
The second column gives annual maximimum sea levels recorded
at Port Pirie, South Australia, from 1923 to 1987.
The first column gives the corresponding years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(portpirie)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Year</dt><dd><p>A numeric vector of years.</p>
</dd>
<dt>SeaLevel</dt><dd><p>A numeric vector of annual sea level
maxima.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='pp.diag'>Diagnostic Plots for Point Process Models</h2><span id='topic+pp.diag'></span>

<h3>Description</h3>

<p>Produces diagnostic plots for point process models using the
output of the function <code>pp.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.diag(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.diag_+3A_z">z</code></td>
<td>
<p>An object returned by <code>pp.fit</code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>For stationary models two plots are produced; a probability
plot and a quantile plot.
</p>
<p>For non-stationary models two plots are produced; a residual
probability plot and a residual quantile plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp.fit">pp.fit</a></code>, <code><a href="#topic+gpd.fit">gpd.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
rnfit &lt;- pp.fit(rain, 10)
pp.diag(rnfit)
</code></pre>

<hr>
<h2 id='pp.fit'>Maximum-likelihood Fitting for the Point Process Model</h2><span id='topic+pp.fit'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the point process model,
including generalized linear modelling of each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.fit(xdat, threshold, npy = 365, ydat = NULL, mul = NULL, sigl =
    NULL, shl = NULL, mulink = identity, siglink = identity, shlink =
    identity, muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
    method = "Nelder-Mead", maxit = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.fit_+3A_xdat">xdat</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_threshold">threshold</code></td>
<td>
<p>The threshold; a single number or a numeric
vector of the same length as <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_npy">npy</code></td>
<td>
<p>The number of observations per year/block.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_ydat">ydat</code></td>
<td>
<p>A matrix of covariates for generalized linear modelling
of the parameters (or <code>NULL</code> (the default) for stationary
fitting). The number of rows should be the same as the length
of <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_mul">mul</code>, <code id="pp.fit_+3A_sigl">sigl</code>, <code id="pp.fit_+3A_shl">shl</code></td>
<td>
<p>Numeric vectors of integers, giving the columns
of <code>ydat</code> that contain covariates for generalized linear
modelling of the location, scale and shape parameters repectively
(or <code>NULL</code> (the default) if the corresponding parameter is
stationary).</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_mulink">mulink</code>, <code id="pp.fit_+3A_siglink">siglink</code>, <code id="pp.fit_+3A_shlink">shlink</code></td>
<td>
<p>Inverse link functions for generalized
linear modelling of the location, scale and shape parameters
repectively.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_muinit">muinit</code>, <code id="pp.fit_+3A_siginit">siginit</code>, <code id="pp.fit_+3A_shinit">shinit</code></td>
<td>
<p>numeric giving initial parameter estimates.
See Details section for information on default (NULL) initial values.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), print details of
the fit.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="pp.fit_+3A_...">...</code></td>
<td>
<p>Other control parameters for the optimization. These
are passed to components of the <code>control</code> argument of
<code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-stationary fitting it is recommended that the covariates
within the generalized linear models are (at least approximately)
centered and scaled (i.e.\ the columns of <code>ydat</code> should be
approximately centered and scaled).  Otherwise, the numerics may
become unstable.
</p>
<p>As of version 1.32, a more accurate estimate of the exceedance
rate, in the face of covariates, is used (at the expense of
computational efficiency).  In particular, when including covariates,
parameter estimates may differ from those in Coles (2001).
</p>
<p>Let m=mean(xdat) and s=sqrt(6*var(xdat))/pi.  Then, initial values
assigend when 'muinit' is NULL are m - 0.57722 * s (stationary case).
When 'siginit' is NULL, the initial value is taken to be s, and when
'shinit' is NULL, the initial value is taken to be 0.1.  When
covariates are introduced (non-stationary case), these same initial
values are used by default for the constant term, and zeros for all
other terms.  For example, if a GEV( mu(t)=mu0+mu1*t, sigma, xi) is
being fitted, then the initial value for mu0 is m - 0.57722 * s, and
0 for mu1.
</p>


<h3>Value</h3>

<p>A list containing the following components. A subset of these
components are printed after the fit. If <code>show</code> is
<code>TRUE</code>, then assuming that successful convergence is
indicated, the components <code>nexc</code>, <code>nllh</code>, <code>mle</code>
and <code>se</code> are always printed.
</p>
<table>
<tr><td><code>trans</code></td>
<td>
<p>An logical indicator for a non-stationary fit.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list with components <code>mul</code>, <code>sigl</code>
and <code>shl</code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A character vector giving inverse link functions.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>The threshold, or vector of thresholds.</p>
</td></tr>
<tr><td><code>npy</code></td>
<td>
<p>The number of observations per year/block.</p>
</td></tr>
<tr><td><code>nexc</code></td>
<td>
<p>The number of data points above the threshold.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data that lie above the threshold. For
non-stationary models, the data is standardized.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>The convergence code, taken from the list returned by
<code><a href="stats.html#topic+optim">optim</a></code>. A zero indicates successful convergence.</p>
</td></tr>
<tr><td><code>nllh</code></td>
<td>
<p>The negative logarithm of the likelihood evaluated at
the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A matrix with four columns containing the maximum
likelihood estimates of the location, scale and shape
parameters, and the threshold, at each data point.</p>
</td></tr>
<tr><td><code>gpd</code></td>
<td>
<p>A matrix with three rows containing the maximum
likelihood estimates of corresponding GPD location, scale
and shape parameters at each data point.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The covariance matrix.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Different optimization methods may result in wildly different parameter estimates.</p>


<h3>Note</h3>

<p> This code is adapted by Eric Gilleland from code originally written for S-Plus by Stuart Coles, and ported to R by Alec Stephenson. See
details section above.</p>


<h3>References</h3>

  
<p>Beirlant J, Goegebeur Y, Segers J and Teugels J. (2004). Statistics of Extremes, Wiley,
Chichester, England.
</p>
<p>Coles, Stuart (2001).  An Introduction to Statistical Modeling of
Extreme Values.  Springer-Verlag, London. </p>


<h3>See Also</h3>

<p><code><a href="#topic+pp.diag">pp.diag</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+pp.fitrange">pp.fitrange</a></code>, <code><a href="#topic+mrl.plot">mrl.plot</a></code>,
<code><a href="#topic+gpd.fit">gpd.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
pp.fit(rain, 10)
</code></pre>

<hr>
<h2 id='pp.fitrange'>Fitting the Point Process Model Over a Range of Thresholds</h2><span id='topic+pp.fitrange'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for a stationary point process model,
over a range of thresholds. Graphs of parameter estimates
which aid the selection of a threshold are produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp.fitrange(data, umin, umax, npy = 365, nint = 10, show = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp.fitrange_+3A_data">data</code></td>
<td>
<p>A numeric vector of data to be fitted.</p>
</td></tr>
<tr><td><code id="pp.fitrange_+3A_umin">umin</code>, <code id="pp.fitrange_+3A_umax">umax</code></td>
<td>
<p>The minimum and maximum thresholds at which
the model is fitted.</p>
</td></tr>
<tr><td><code id="pp.fitrange_+3A_npy">npy</code></td>
<td>
<p>The number of observations per year/block.</p>
</td></tr>
<tr><td><code id="pp.fitrange_+3A_nint">nint</code></td>
<td>
<p>The number of fitted models.</p>
</td></tr>
<tr><td><code id="pp.fitrange_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code>, print details of each
fit.</p>
</td></tr>
<tr><td><code id="pp.fitrange_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>pp.fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three graphs showing maximum likelihood estimates and confidence
intervals of the location, scale and shape parameters over a
range of thresholds are produced.  A list object is returned invisibly
with components:
'threshold' numeric vector of length 'nint' giving the thresholds used,
'mle' an 'nint X 3' matrix giving the maximum likelihood parameter estimates
(columns are location, scale and shape respectively),
'se' an 'nint X 3' matrix giving the estimated standard errors for the 
parameter estimates (columns are location, scale and shape, resp.),
'ci.low', 'ci.up' 'nint X 3' matrices giving the lower and upper 95
intervals, resp. (columns same as for 'mle' and 'se').
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp.fit">pp.fit</a></code>, <code><a href="#topic+mrl.plot">mrl.plot</a></code>,
<code><a href="#topic+gpd.fit">gpd.fit</a></code>, <code><a href="#topic+gpd.fitrange">gpd.fitrange</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(rain)
## Not run: pp.fitrange(rain, 10, 40)
</code></pre>

<hr>
<h2 id='rain'>Daily Rainfall Accumulations in South-West England</h2><span id='topic+rain'></span>

<h3>Description</h3>

<p>A numeric vector containing daily rainfall accumulations
at a location in south-west England over the period 1914
to 1962.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rain)</code></pre>


<h3>Format</h3>

<p>A vector containing 17531 observations.</p>


<h3>Source</h3>

<p>Coles, S. G. and Tawn, J. A. (1996)
Modelling extremes of the areal rainfall process.
<em>Journal of the Royal Statistical Society, B</em>
<b>53</b>, 329&ndash;347.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='rlarg.diag'>Diagnostic Plots for Order Statistics Models</h2><span id='topic+rlarg.diag'></span>

<h3>Description</h3>

<p>Produces diagnostic plots for order statistics models using
the output of the function <code>rlarg.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlarg.diag(z, n = z$r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlarg.diag_+3A_z">z</code></td>
<td>
<p>An object returned by <code>rlarg.fit</code>.</p>
</td></tr>
<tr><td><code id="rlarg.diag_+3A_n">n</code></td>
<td>
<p>Probability and quantile plots are produced for the
largest <code>n</code> order statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For stationary models four plots are initially produced;
a probability plot, a quantile plot, a return level plot
and a histogram of data with fitted density.
Then probability and quantile plots are produced for the
largest <code>n</code> order statistics.
</p>
<p>For non-stationary models residual probability plots and
residual quantile plots are produced for the largest
<code>n</code> order statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlarg.fit">rlarg.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(venice)
## Not run: venfit &lt;- rlarg.fit(venice[,-1])
## Not run: rlarg.diag(venfit)
</code></pre>

<hr>
<h2 id='rlarg.fit'>Maximum-likelihood Fitting of Order Statistics Model</h2><span id='topic+rlarg.fit'></span>

<h3>Description</h3>

<p>Maximum-likelihood fitting for the order statistic model,
including generalized linear modelling of each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlarg.fit(xdat, r = dim(xdat)[2], ydat = NULL, mul = NULL, sigl = NULL,
  shl = NULL, mulink = identity, siglink = identity, shlink = identity,
  muinit = NULL, siginit = NULL, shinit = NULL, show = TRUE,
  method = "Nelder-Mead", maxit = 10000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlarg.fit_+3A_xdat">xdat</code></td>
<td>
<p>A numeric matrix of data to be fitted. Each row
should be a vector of decreasing order, containing the
largest order statistics for each year (or time period).
The first column therefore contains annual (or period)
maxima.
Only the first <code>r</code> columns are used for the fitted
model. By default, all columns are used.
If one year (or time period) contains fewer order statistics
than another, missing values can be appended to the end
of the corresponding row.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_r">r</code></td>
<td>
<p>The largest <code>r</code> order statistics are used for
the fitted model.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_ydat">ydat</code></td>
<td>
<p>A matrix of covariates for generalized linear modelling
of the parameters (or <code>NULL</code> (the default) for stationary
fitting). The number of rows should be the same as the number
of rows of <code>xdat</code>.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_mul">mul</code>, <code id="rlarg.fit_+3A_sigl">sigl</code>, <code id="rlarg.fit_+3A_shl">shl</code></td>
<td>
<p>Numeric vectors of integers, giving the columns
of <code>ydat</code> that contain covariates for generalized linear
modelling of the location, scale and shape parameters repectively
(or <code>NULL</code> (the default) if the corresponding parameter is
stationary).</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_mulink">mulink</code>, <code id="rlarg.fit_+3A_siglink">siglink</code>, <code id="rlarg.fit_+3A_shlink">shlink</code></td>
<td>
<p>Inverse link functions for generalized
linear modelling of the location, scale and shape parameters
repectively.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_muinit">muinit</code>, <code id="rlarg.fit_+3A_siginit">siginit</code>, <code id="rlarg.fit_+3A_shinit">shinit</code></td>
<td>
<p>numeric of length equal to total number
of parameters used to model the location, scale or shape parameter(s),
resp.  See Details section for default (NULL) initial values.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_show">show</code></td>
<td>
<p>Logical; if <code>TRUE</code> (the default), print details of
the fit.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_method">method</code></td>
<td>
<p>The optimization method (see <code><a href="stats.html#topic+optim">optim</a></code> for
details).</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="rlarg.fit_+3A_...">...</code></td>
<td>
<p>Other control parameters for the optimization. These
are passed to components of the <code>control</code> argument of
<code>optim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For non-stationary fitting it is recommended that the covariates
within the generalized linear models are (at least approximately)
centered and scaled (i.e.\ the columns of <code>ydat</code> should be
approximately centered and scaled).
</p>
<p>Let m=mean(xdat) and s=sqrt(6*var(xdat))/pi.  Then, initial values
assigend when 'muinit' is NULL are m - 0.57722 * s (stationary case).
When 'siginit' is NULL, the initial value is taken to be s, and when
'shinit' is NULL, the initial value is taken to be 0.1.  When
covariates are introduced (non-stationary case), these same initial
values are used by default for the constant term, and zeros for all
other terms.  For example, if a GEV( mu(t)=mu0+mu1*t, sigma, xi) is
being fitted, then the initial value for mu0 is m - 0.57722 * s, and
0 for mu1.
</p>


<h3>Value</h3>

<p>A list containing the following components. A subset of these
components are printed after the fit. If <code>show</code> is
<code>TRUE</code>, then assuming that successful convergence is
indicated, the components <code>nllh</code>, <code>mle</code> and <code>se</code>
are always printed.
</p>
<table>
<tr><td><code>trans</code></td>
<td>
<p>An logical indicator for a non-stationary fit.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list with components <code>mul</code>, <code>sigl</code>
and <code>shl</code>.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>A character vector giving inverse link functions.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>The convergence code, taken from the list returned by
<code><a href="stats.html#topic+optim">optim</a></code>. A zero indicates successful convergence.</p>
</td></tr>
<tr><td><code>nllh</code></td>
<td>
<p>The negative logarithm of the likelihood evaluated at
the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data that has been fitted. For non-stationary
models, the data is standardized.</p>
</td></tr>
<tr><td><code>mle</code></td>
<td>
<p>A vector containing the maximum likelihood estimates.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>The covariance matrix.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A matrix with three columns containing the maximum
likelihood estimates of the location, scale and shape parameters
at each data point.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The number of order statistics used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rlarg.diag">rlarg.diag</a></code>, <code><a href="stats.html#topic+optim">optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(venice)
## Not run: rlarg.fit(venice[,-1])
</code></pre>

<hr>
<h2 id='venice'>Venice Sea Levels</h2><span id='topic+venice'></span>

<h3>Description</h3>

<p>The <code>venice</code> data frame has 51 rows and 11 columns.
The final ten columns contain the 10 largest sea levels
observed within the year given by the first column.
The ten largest sea levels are given for every year in
the period 1931 to 1981, excluding 1935 in which only
the six largest measurements are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(venice)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Year</dt><dd><p>A numeric vector of years.</p>
</dd>
<dt>r1</dt><dd><p>Annual sea level maxima.</p>
</dd>
<dt>r2</dt><dd><p>The second largest sea level.</p>
</dd>
<dt>r3</dt><dd><p>The third largest sea level.</p>
</dd>
<dt>r4</dt><dd><p>The forth largest sea level.</p>
</dd>
<dt>r5</dt><dd><p>The fifth largest sea level.</p>
</dd>
<dt>r6</dt><dd><p>The sixth largest sea level.</p>
</dd>
<dt>r7</dt><dd><p>The seventh largest sea level.</p>
</dd>
<dt>r8</dt><dd><p>The eigth largest sea level.</p>
</dd>
<dt>r9</dt><dd><p>The ninth largest sea level.</p>
</dd>
<dt>r10</dt><dd><p>The tenth largest sea level.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Smith, R. L. (1986)
Extreme value theory based on the <em>r</em> largest annual
events.
<em>Journal of Hydrology</em> <b>86</b>, 27&ndash;43.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='wavesurge'>Wave and Surge Heights in South-West England</h2><span id='topic+wavesurge'></span>

<h3>Description</h3>

<p>The <code>wavesurge</code> data frame has 2894 rows and 2 columns.
The columns contain wave and surge heights (in metres) at a
single location off south-west England.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wavesurge)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>wave</dt><dd><p>A numeric vector of wave heights.</p>
</dd>
<dt>surge</dt><dd><p>A numeric vector of surge heights.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='wind'>Annual Maximum Wind Speeds at Albany and Hartford</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>The <code>wind</code> data frame has 40 rows and 3 columns.
The second and third columns contain annual maximum wind
speeds at Albany, New York and Hartford, Connecticut
respectively, over the period 1944 to 1983.
The first column gives the corresponding years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wind)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Year</dt><dd><p>A numeric vector of years.</p>
</dd>
<dt>Hartford</dt><dd><p>Annual maximum wind speeds at Hartford.</p>
</dd>
<dt>Albany</dt><dd><p>Annual maximum wind speeds at Albany.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>

<hr>
<h2 id='wooster'>Minimum Temperatures at Wooster, Ohio</h2><span id='topic+wooster'></span>

<h3>Description</h3>

<p>A numeric vector containing daily minimum temperatures,
in degrees Fahrenheit, at Wooster, Ohio, over the period
1983 to 1988.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wooster)</code></pre>


<h3>Format</h3>

<p>A vector containing 1826 observations.</p>


<h3>Source</h3>

<p>Coles, S. G., Tawn, J. A. and Smith, R. L. (1994)
A seasonal Markov model for extremely low temperatures.
<em>Environmetrics</em> <b>5</b>, 221&ndash;239.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001)
<em>An Introduction to Statistical Modelling of
Extreme Values.</em> London: Springer.
</p>
<p>Smith, R. L., Tawn, J. A. and Coles, S. G. (1997)
Markov chain models for threshold exceedences.
<em>Biometrica</em> <b>84</b>, 249&ndash;268.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
