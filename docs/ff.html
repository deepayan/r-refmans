<!DOCTYPE html><html><head><title>Help for package ff</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ff}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add'><p> Incrementing an ff or ram object</p></a></li>
<li><a href='#array2vector'><p> Array: make vector from array</p></a></li>
<li><a href='#arrayIndex2vectorIndex'><p> Array: make vector positions from array index</p></a></li>
<li><a href='#as.ff'><p> Coercing ram to ff and ff to ram objects</p></a></li>
<li><a href='#as.ff.bit'>
<p>Conversion between bit and ff boolean</p></a></li>
<li><a href='#as.ffdf'>
<p>Coercing to ffdf and data.frame</p></a></li>
<li><a href='#as.hi'><p> Hybrid Index, coercion to</p></a></li>
<li><a href='#as.integer.hi'><p> Hybrid Index, coercing from</p></a></li>
<li><a href='#as.vmode'><p> Coercing to virtual mode</p></a></li>
<li><a href='#bigsample'><p> Sampling from large pools</p></a></li>
<li><a href='#CFUN'><p> Collapsing functions for batch processing</p></a></li>
<li><a href='#chunk.ffdf'>
<p>Chunk ff_vector and ffdf</p></a></li>
<li><a href='#clone.ff'><p> Cloning ff and ram objects</p></a></li>
<li><a href='#clone.ffdf'>
<p>Cloning ffdf objects</p></a></li>
<li><a href='#close.ff'><p> Closing ff files</p></a></li>
<li><a href='#delete'><p> Deleting the file behind an ff object</p></a></li>
<li><a href='#dim.ff'><p> Getting and setting dim and dimorder</p></a></li>
<li><a href='#dimnames.ff'><p> Getting and setting dimnames</p></a></li>
<li><a href='#dimnames.ffdf'>
<p>Getting and setting dimnames of ffdf</p></a></li>
<li><a href='#dimorderCompatible'><p> Test for dimorder compatibility</p></a></li>
<li><a href='#dummy.dimnames'><p> Array: make dimnames</p></a></li>
<li><a href='#Extract.ff'><p> Reading and writing vectors and arrays (high-level)</p></a></li>
<li><a href='#Extract.ffdf'><p> Reading and writing data.frames (ffdf)</p></a></li>
<li><a href='#ff'><p> ff classes for representing (large) atomic data</p></a></li>
<li><a href='#ffapply'><p> Apply for ff objects</p></a></li>
<li><a href='#ffconform'><p> Get most conforming argument</p></a></li>
<li><a href='#ffdf'>
<p>ff class for data.frames</p></a></li>
<li><a href='#ffdfindexget'>
<p>Reading and writing ffdf data.frame using ff subscripts</p></a></li>
<li><a href='#ffdfsort'>
<p>Sorting: convenience wrappers for data.frames</p></a></li>
<li><a href='#ffdrop'>
<p>Delete an ffarchive</p></a></li>
<li><a href='#ffindexget'>
<p>Reading and writing ff vectors using ff subscripts</p></a></li>
<li><a href='#ffindexorder'>
<p>Sorting: chunked ordering of integer suscript positions</p></a></li>
<li><a href='#ffinfo'>
<p>Inspect content of ff saves</p></a></li>
<li><a href='#ffload'>
<p>Reload ffSaved Datasets</p></a></li>
<li><a href='#fforder'>
<p>Sorting: order from ff vectors</p></a></li>
<li><a href='#ffreturn'><p> Return suitable ff object</p></a></li>
<li><a href='#ffsave'>
<p>Save R and ff objects</p></a></li>
<li><a href='#ffsort'>
<p>Sorting of ff vectors</p></a></li>
<li><a href='#ffsuitable'><p> Test ff object for suitability</p></a></li>
<li><a href='#ffxtensions'><p> Test for availability of ff extensions</p></a></li>
<li><a href='#file.resize'><p> Change size of move an existing file</p></a></li>
<li><a href='#filename'><p> Get or set filename</p></a></li>
<li><a href='#finalize'>
<p>Call finalizer</p></a></li>
<li><a href='#finalizer'>
<p>Get and set finalizer (name)</p></a></li>
<li><a href='#fixdiag'><p> Test for fixed diagonal</p></a></li>
<li><a href='#Forbidden_ffdf'>
<p>Forbidden ffdf functions</p></a></li>
<li><a href='#geterror.ff'><p> Get error and error string</p></a></li>
<li><a href='#getpagesize'>
<p>Get page size information</p></a></li>
<li><a href='#getset.ff'><p> Reading and writing vectors of values (low-level)</p></a></li>
<li><a href='#hi'><p> Hybrid index class</p></a></li>
<li><a href='#hiparse'><p> Hybrid Index, parsing</p></a></li>
<li><a href='#Internal_ffdf'>
<p>Internal ffdf functions</p></a></li>
<li><a href='#is.ff'><p> Test for class ff</p></a></li>
<li><a href='#is.ffdf'><p> Test for class ff</p></a></li>
<li><a href='#is.open'><p> Test if object is opened</p></a></li>
<li><a href='#is.readonly'><p> Get readonly status</p></a></li>
<li><a href='#is.sorted'><p> Getting and setting 'is.sorted' physical attribute</p></a></li>
<li><a href='#length.ff'><p> Getting and setting length</p></a></li>
<li><a href='#length.ffdf'>
<p>Getting length of a ffdf dataframe</p></a></li>
<li><a href='#length.hi'><p> Hybrid Index, querying</p></a></li>
<li><a href='#levels.ff'><p> Getting and setting factor levels</p></a></li>
<li><a href='#LimWarn'><p> ff Limitations and Warnings</p></a></li>
<li><a href='#matcomb'><p> Array: make matrix indices from row and columns positions</p></a></li>
<li><a href='#matprint'><p> Print beginning and end of big matrix</p></a></li>
<li><a href='#maxffmode'><p> Lossless vmode coercability</p></a></li>
<li><a href='#maxlength'><p> Get physical length of an ff or ram object</p></a></li>
<li><a href='#mismatch'><p> Test for recycle mismatch</p></a></li>
<li><a href='#na.count'><p> Getting and setting 'na.count' physical attribute</p></a></li>
<li><a href='#names.ff'><p> Getting and setting names</p></a></li>
<li><a href='#nrowAssign'>
<p>Assigning the number of rows or columns</p></a></li>
<li><a href='#open.ff'><p> Opening an ff file</p></a></li>
<li><a href='#pagesize'><p> Pagesize of ff object</p></a></li>
<li><a href='#physical.ff'><p> Getting and setting physical and virtual attributes of ff objects</p></a></li>
<li><a href='#physical.ffdf'>
<p>Getting physical and virtual attributes of ffdf objects</p></a></li>
<li><a href='#print.ff'><p> Print and str methods</p></a></li>
<li><a href='#ram2ffcode'><p> Factor codings</p></a></li>
<li><a href='#ramattribs'><p> Get ramclass and ramattribs</p></a></li>
<li><a href='#ramorder.default'>
<p>Sorting: order R vector in-RAM and in-place</p></a></li>
<li><a href='#ramsort.default'>
<p>Sorting: Sort R vector in-RAM and in-place</p></a></li>
<li><a href='#read.table.ffdf'>
<p>Importing csv files into ff data.frames</p></a></li>
<li><a href='#readwrite.ff'><p> Reading and writing vectors (low-level)</p></a></li>
<li><a href='#regtest.fforder'>
<p>Sorting: regression tests</p></a></li>
<li><a href='#repnam'>
<p>Replicate with names</p></a></li>
<li><a href='#sortLevels'>
<p>Factor level manipulation</p></a></li>
<li><a href='#splitPathFile'>
<p>Analyze pathfile-strings</p></a></li>
<li><a href='#swap'><p> Reading and writing in one operation (high-level)</p></a></li>
<li><a href='#symmetric'><p> Test for symmetric structure</p></a></li>
<li><a href='#symmIndex2vectorIndex'><p> Array: make vector positions from symmetric array index</p></a></li>
<li><a href='#unclass_-'><p> Unclassed assignement</p></a></li>
<li><a href='#undim'><p> Undim</p></a></li>
<li><a href='#unsort'><p> Hybrid Index, internal utilities</p></a></li>
<li><a href='#update.ff'><p> Update ff content from another object</p></a></li>
<li><a href='#vecprint'><p> Print beginning and end of big vector</p></a></li>
<li><a href='#vector.vmode'><p> Create vector of virtual mode</p></a></li>
<li><a href='#vector2array'><p> Array: make array from vector</p></a></li>
<li><a href='#vectorIndex2arrayIndex'><p> Array: make array from index vector positions</p></a></li>
<li><a href='#vmode'><p> Virtual storage mode</p></a></li>
<li><a href='#vmode.ffdf'>
<p>Virtual storage mode of ffdf</p></a></li>
<li><a href='#vt'><p> Virtual transpose</p></a></li>
<li><a href='#vw'><p> Getting and setting virtual windows</p></a></li>
<li><a href='#write.table.ffdf'>
<p>Exporting csv files from ff data.frames</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.0.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Memory-Efficient Storage of Large Data on Disk and Fast Access
Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Adler [aut],
	Christian Gläser [aut],
	Oleg Nenadic  [aut], 
	Jens Oehlschlägel [aut, cre],
	Martijn Schuemie [aut],
	Walter Zucchini  [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.1), bit (&ge; 4.0.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>biglm, testthat (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>The ff package provides data structures that are stored on
	disk but behave (almost) as if they were in RAM by transparently 
	mapping only a section (pagesize) in main memory - the effective 
	virtual memory consumption per ff object. ff supports R's standard 
	atomic data types 'double', 'logical', 'raw' and 'integer' and 
	non-standard atomic types boolean (1 bit), quad (2 bit unsigned), 
	nibble (4 bit unsigned), byte (1 byte signed with NAs), ubyte (1 byte 
	unsigned), short (2 byte signed with NAs), ushort (2 byte unsigned), 
	single (4 byte float with NAs). For example 'quad' allows efficient 
	storage of genomic data as an 'A','T','G','C' factor. The unsigned 
	types support 'circular' arithmetic. There is also support for 
	close-to-atomic types 'factor', 'ordered', 'POSIXct', 'Date' and 
	custom close-to-atomic types. 
	ff not only has native C-support for vectors, matrices and arrays 
	with flexible dimorder (major column-order, major row-order and 
	generalizations for arrays). There is also a ffdf class not unlike 
	data.frames and import/export filters for csv files.
	ff objects store raw data in binary flat files in native encoding,
	and complement this with metadata stored in R as physical and virtual
	attributes. ff objects have well-defined hybrid copying semantics, 
	which gives rise to certain performance improvements through 
	virtualization. ff objects can be stored and reopened across R 
	sessions. ff files can be shared by multiple ff R objects 
	(using different data en/de-coding schemes) in the same process 
	or from multiple R processes to exploit parallelism. A wide choice of 
	finalizer options allows to work with 'permanent' files as well as 
	creating/removing 'temporary' ff files completely transparent to the 
	user. On certain OS/Filesystem combinations, creating the ff files
	works without notable delay thanks to using sparse file allocation.
	Several access optimization techniques such as Hybrid Index 
	Preprocessing and Virtualization are implemented to achieve good 
	performance even with large datasets, for example virtual matrix 
	transpose without touching a single byte on disk. Further, to reduce 
	disk I/O, 'logicals' and non-standard data types get stored native and 
	compact on binary flat files i.e. logicals take up exactly 2 bits to 
	represent TRUE, FALSE and NA. 
	Beyond basic access functions, the ff package also provides 
	compatibility functions that facilitate writing code for ff and ram 
	objects and support for batch processing on ff objects (e.g. as.ram, 
	as.ff, ffapply). ff interfaces closely with functionality from package 
	'bit': chunked looping, fast bit operations and coercions between 
	different objects that can store subscript information ('bit', 
	'bitwhich', ff 'boolean', ri range index, hi hybrid index). This allows
	to work interactively with selections of large datasets and quickly 
	modify selection criteria. 
	Further high-performance enhancements can be made available upon request. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/truecluster/ff">https://github.com/truecluster/ff</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-10 19:06:47 UTC; jo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-12 15:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add'> Incrementing an ff or ram object </h2><span id='topic+add'></span><span id='topic+add.ff'></span><span id='topic+add.default'></span>

<h3>Description</h3>

<p>Yet another assignment interface in order to allow to formulate <code>x[index,...,add=TRUE]&lt;-value</code>
in a way which works transparently, not only for ff, but also for ram objects: <code>add(x, value, index, ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(x, ...)
## S3 method for class 'ff'
add(x, value, ...)
## Default S3 method:
add(x, value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="add_+3A_value">value</code></td>
<td>
<p> the amount to increment, possibly recylcled </p>
</td></tr>
<tr><td><code id="add_+3A_...">...</code></td>
<td>
<p> further arguments &ndash; especially index information &ndash; passed to <code><a href="base.html#topic++5B+3C-">[&lt;-</a></code> or <code><a href="#topic+Extract.ff">[&lt;-.ff</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible()
</p>


<h3>Note</h3>

<p>Note that <code>add.default</code> changes the object in its parent frame and thus violates R's usual functional programming logic.
Duplicated index positions should be avoided, because ff and ram objects behave differently:
</p>
<pre>
  add.ff(x, 1, c(3,3))
  # will increment x at position 3 TWICE by 1, while
  add.default(x, 1, c(3,3))
  # will increment x at position 3 just ONCE by 1
  </pre>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+swap">swap</a></code>, <code><a href="#topic++5B.ff">[.ff</a></code>, <code><a href="#topic+LimWarn">LimWarn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   message("incrementing parts of a vector")
   x &lt;- ff(0, length=12)
   y &lt;- rep(0, 12)
   add(x, 1, 1:6)
   add(y, 1, 1:6)
   x
   y

   message("incrementing parts of a matrix")
   x &lt;- ff(0, dim=3:4)
   y &lt;- array(0, dim=3:4)
   add(x, 1, 1:2, 1:2)
   add(y, 1, 1:2, 1:2)
   x
   y

   message("BEWARE that ff and ram methods differ in treatment of duplicated index positions")
   add(x, 1, c(3,3))
   add(y, 1, c(3,3))
   x
   y

   rm(x); gc()
</code></pre>

<hr>
<h2 id='array2vector'> Array: make vector from array </h2><span id='topic+array2vector'></span>

<h3>Description</h3>

<p>Makes a vector from an array respecting <span class="option">dim</span> and <span class="option">dimorder</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array2vector(x, dim = NULL, dimorder = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array2vector_+3A_x">x</code></td>
<td>
<p> an <code><a href="base.html#topic+array">array</a></code> </p>
</td></tr>
<tr><td><code id="array2vector_+3A_dim">dim</code></td>
<td>
 <p><code><a href="base.html#topic+dim">dim</a></code> </p>
</td></tr>
<tr><td><code id="array2vector_+3A_dimorder">dimorder</code></td>
<td>
 <p><code><a href="#topic+dimorder">dimorder</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the inverse function of <code><a href="#topic+vector2array">vector2array</a></code>.
It extracts the vector from the array by first moving through the fastest rotating dimension dim[dimorder[1]], then dim[dimorder[2]], and so forth
</p>


<h3>Value</h3>

<p>a vector
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+vector2array">vector2array</a></code>, <code><a href="#topic+arrayIndex2vectorIndex">arrayIndex2vectorIndex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  array2vector(matrix(1:12, 3, 4))
  array2vector(matrix(1:12, 3, 4, byrow=TRUE), dimorder=2:1)
</code></pre>

<hr>
<h2 id='arrayIndex2vectorIndex'> Array: make vector positions from array index </h2><span id='topic+arrayIndex2vectorIndex'></span>

<h3>Description</h3>

<p>Make vector positions from a (non-symmetric) array index respecting <span class="option">dim</span> and <span class="option">dimorder</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrayIndex2vectorIndex(x, dim = NULL, dimorder = NULL, vw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrayIndex2vectorIndex_+3A_x">x</code></td>
<td>
<p> an n by m matrix with n m-dimensional array indices </p>
</td></tr>
<tr><td><code id="arrayIndex2vectorIndex_+3A_dim">dim</code></td>
<td>
<p> NULL or <code><a href="base.html#topic+dim">dim</a></code> </p>
</td></tr>
<tr><td><code id="arrayIndex2vectorIndex_+3A_dimorder">dimorder</code></td>
<td>
<p> NULL or <code><a href="#topic+dimorder">dimorder</a></code> </p>
</td></tr>
<tr><td><code id="arrayIndex2vectorIndex_+3A_vw">vw</code></td>
<td>
<p> NULL or integer vector[3] or integer matrix[3,m], see details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fastest rotating dimension is dim[dimorder[1]], then dim[dimorder[2]], and so forth. <br />
The parameters 'x' and 'dim' may refer to a subarray of a larger array, in this case, the array indices 'x' are interpreted as 'vw[1,] + x' within the larger array 'as.integer(colSums(vw))'.
</p>


<h3>Value</h3>

<p>a vector of indices in <code>seq_len(prod(dim))</code> (or  <code>seq_len(prod(colSums(vw)))</code>)
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+vectorIndex2arrayIndex">vectorIndex2arrayIndex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(1:12, 3, 4)
  x
  arrayIndex2vectorIndex(cbind(as.vector(row(x)), as.vector(col(x)))
  , dim=dim(x))
  arrayIndex2vectorIndex(cbind(as.vector(row(x)), as.vector(col(x)))
  , dim=dim(x), dimorder=2:1)
  matrix(1:30, 5, 6)
  arrayIndex2vectorIndex(cbind(as.vector(row(x)), as.vector(col(x)))
  , vw=rbind(c(0,1), c(3,4), c(2,1)))
  arrayIndex2vectorIndex(cbind(as.vector(row(x)), as.vector(col(x)))
  , vw=rbind(c(0,1), c(3,4), c(2,1)), dimorder=2:1)
</code></pre>

<hr>
<h2 id='as.ff'> Coercing ram to ff and ff to ram objects </h2><span id='topic+as.ff'></span><span id='topic+as.ff.default'></span><span id='topic+as.ff.ff'></span><span id='topic+as.ram'></span><span id='topic+as.ram.default'></span><span id='topic+as.ram.ff'></span>

<h3>Description</h3>

<p>Coercing ram to ff and ff to ram objects while optionally modifying object features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  as.ff(x, ...)
  as.ram(x, ...)
  ## Default S3 method:
as.ff(x, filename = NULL, overwrite = FALSE, ...)
  ## S3 method for class 'ff'
as.ff(x, filename = NULL, overwrite = FALSE, ...)
  ## Default S3 method:
as.ram(x, ...)
  ## S3 method for class 'ff'
as.ram(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ff_+3A_x">x</code></td>
<td>
<p> any object to be coerced </p>
</td></tr>
<tr><td><code id="as.ff_+3A_filename">filename</code></td>
<td>
<p> path and filename </p>
</td></tr>
<tr><td><code id="as.ff_+3A_overwrite">overwrite</code></td>
<td>
<p> TRUE to overwrite the old filename </p>
</td></tr>
<tr><td><code id="as.ff_+3A_...">...</code></td>
<td>
 <p><code>...</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>as.ff.ff</code> is called on an 'ff' object or <code>as.ram.default</code> is called on a non-ff object AND no changes are required, the input object 'x' is returned unchanged.
Otherwise the workhorse <code><a href="#topic+clone.ff">clone.ff</a></code> is called.
If no change of features are requested, the filename attached to the object remains unchanged, otherwise a new filename is requested (or can be set by the user).
</p>


<h3>Value</h3>

<p>A ram or ff object.
</p>


<h3>Note</h3>

<p>If you use <code>ram &lt;- as.ram(ff)</code> for caching, please note that you must <code><a href="#topic+close.ff">close.ff</a></code> before you can write back <code>as.ff(ram, overwrite=TRUE)</code> (see examples).
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+as.ff.bit">as.ff.bit</a></code>, <code><a href="#topic+ff">ff</a></code>, <code><a href="bit.html#topic+clone">clone</a></code> 
, <code><a href="#topic+as.vmode">as.vmode</a></code>, <code><a href="#topic+vmode">vmode</a></code>, <code><a href="#topic+as.hi">as.hi</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   message("create ff")
   myintff &lt;- ff(1:12)
   message("coerce (=clone) integer ff to double ff")
   mydoubleff &lt;- as.ff(myintff, vmode="double")
   message("cache (=clone) integer ff to integer ram AND close original ff")
   myintram &lt;- as.ram(myintff) # filename is retained
   close(myintff)
   message("modify ram cache and write back (=clone) to ff")
   myintram[1] &lt;- -1L
   myintff &lt;- as.ff(myintram, overwrite=TRUE)
   message("coerce (=clone) integer ram to double ram")
   mydoubleram &lt;- as.ram(myintram, vmode="double")
   message("coerce (inplace) integer ram to double ram")
   myintram &lt;- as.ram(myintram, vmode="double")
   message("more classic: coerce (inplace) double ram to integer ram")
   vmode(myintram) &lt;- "integer"
   rm(myintff, myintram, mydoubleff, mydoubleram); gc()
</code></pre>

<hr>
<h2 id='as.ff.bit'>
Conversion between bit and ff boolean
</h2><span id='topic+as.ff.bit'></span><span id='topic+as.bit.ff'></span>

<h3>Description</h3>

<p>Function <code>as.ff.bit</code> converts a <code><a href="bit.html#topic+bit">bit</a></code> vector to a boolean <code><a href="#topic+ff">ff</a></code> vector.
Function <code>as.bit.ff</code> converts a boolean <code><a href="#topic+ff">ff</a></code> vector to a <code><a href="#topic+ff">ff</a></code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bit'
as.ff(x, filename = NULL, overwrite = FALSE, ...)
## S3 method for class 'ff'
as.bit(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ff.bit_+3A_x">x</code></td>
<td>
<p> the source of conversion </p>
</td></tr>
<tr><td><code id="as.ff.bit_+3A_filename">filename</code></td>
<td>
<p> optionally a desired filename </p>
</td></tr>
<tr><td><code id="as.ff.bit_+3A_overwrite">overwrite</code></td>
<td>
<p> logical indicating whether we allow overwriting the target file </p>
</td></tr>
<tr><td><code id="as.ff.bit_+3A_...">...</code></td>
<td>
<p> further arguments passed to ff in case <code>as.ff.bit</code>, ignored in case of <code>as.bit.ff</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data are copied bot bit-wise but integerwise, therefore these conversions are very fast.
<code>as.bit.ff</code>  will attach the ff filename to the bit vector, and <code>as.ff.bit</code> will - if attached - use THIS filename and SILENTLY overwrite this file.
</p>


<h3>Value</h3>

<p>A vector of the converted type
</p>


<h3>Note</h3>

<p>NAs are mapped to TRUE in 'bit' and to FALSE in 'ff' booleans. Might be aligned in a future release. Don't use bit if you have NAs - or map NAs explicitely.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+bit">bit</a></code>, <code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+as.ff">as.ff</a></code>, <code><a href="#topic+as.hi.bit">as.hi.bit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  l &lt;- as.boolean(sample(c(FALSE,TRUE), 1000, TRUE))

  b &lt;- as.bit(l)
  stopifnot(identical(l,b[]))
  b
  f &lt;- as.ff(b)
  stopifnot(identical(l,f[]))
  f
  b2 &lt;- as.bit(f)
  stopifnot(identical(l,b2[]))
  b2
  f2 &lt;- as.ff(b2)
  stopifnot(identical(filename(f),filename(f2)))
  stopifnot(identical(l,f2[]))
  f
  rm(f,f2); gc()
</code></pre>

<hr>
<h2 id='as.ffdf'>
Coercing to ffdf and data.frame
</h2><span id='topic+as.ffdf'></span><span id='topic+as.ffdf.ff_vector'></span><span id='topic+as.ffdf.ff_matrix'></span><span id='topic+as.ffdf.data.frame'></span><span id='topic+as.data.frame.ffdf'></span>

<h3>Description</h3>

<p>Functions for coercing to ffdf and data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ffdf(x, ...)
## S3 method for class 'ff_vector'
as.ffdf(x, ...)
## S3 method for class 'ff_matrix'
as.ffdf(x, ...)
## S3 method for class 'data.frame'
as.ffdf(x, vmode=NULL, col_args = list(), ...)
## S3 method for class 'ffdf'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ffdf_+3A_x">x</code></td>
<td>
<p> the object to be coerced </p>
</td></tr>
<tr><td><code id="as.ffdf_+3A_vmode">vmode</code></td>
<td>
<p> optional specification of the <code><a href="#topic+vmode">vmode</a>s</code> of columns of the <code><a href="base.html#topic+data.frame">data.frame</a></code>. Either a character vector of vmodes (named with column names of the data.frame or recycled if not named)
or a list named with vmodes where each element identifies those columns of the data.frame that should get the vmode encoded in the name of the element </p>
</td></tr>
<tr><td><code id="as.ffdf_+3A_col_args">col_args</code></td>
<td>
<p> further arguments; passed to <code><a href="#topic+ff">ff</a></code>  </p>
</td></tr>
<tr><td><code id="as.ffdf_+3A_...">...</code></td>
<td>
<p> further arguments; passed to <code><a href="#topic+ffdf">ffdf</a></code> for .ff_vector, .ff_matrix and .data.frame methods, ignored for .ffdf identity method </p>
</td></tr>
</table>


<h3>Value</h3>

<p>'as.ffdf' returns an object of class <code><a href="#topic+ffdf">ffdf</a></code>, 'as.data.frame' returns an object of class <code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.ffdf">is.ffdf</a></code>, <code><a href="#topic+ffdf">ffdf</a></code>, <code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- data.frame(x=1:26, y=letters, z=Sys.time()+1:26, stringsAsFactors = TRUE)
  ffd &lt;- as.ffdf(d)
  stopifnot(identical(d, as.data.frame(ffd)))
  rm(ffd); gc()
</code></pre>

<hr>
<h2 id='as.hi'> Hybrid Index, coercion to </h2><span id='topic+as.hi'></span><span id='topic+as.hi.NULL'></span><span id='topic+as.hi.hi'></span><span id='topic+as.hi.ri'></span><span id='topic+as.hi.bit'></span><span id='topic+as.hi.bitwhich'></span><span id='topic+as.hi.call'></span><span id='topic+as.hi.name'></span><span id='topic+as.hi.+28'></span><span id='topic+as.hi.integer'></span><span id='topic+as.hi.which'></span><span id='topic+as.hi.double'></span><span id='topic+as.hi.logical'></span><span id='topic+as.hi.character'></span><span id='topic+as.hi.matrix'></span>

<h3>Description</h3>

<p>The generic <code>as.hi</code> and its methods are the main (internal) means for preprocessing index information into the hybrid index class <code><a href="#topic+hi">hi</a></code>.
Usually <code>as.hi</code> is called transparently from <code><a href="#topic++5B.ff">[.ff</a></code>. However, you can explicitely do the index-preprocessing,
store the Hybrid Index <code><a href="#topic+hi">hi</a></code>, and use the <code>hi</code> for subscripting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.hi(x, ...)
## S3 method for class 'NULL'
as.hi(x, ...)
## S3 method for class 'hi'
as.hi(x, ...)
## S3 method for class 'ri'
as.hi(x, maxindex = length(x), ...)
## S3 method for class 'bit'
as.hi(x, range = NULL, maxindex = length(x), vw = NULL
, dim = NULL, dimorder = NULL, pack = TRUE, ...)
## S3 method for class 'bitwhich'
as.hi(x, maxindex = length(x), pack = FALSE, ...)
## S3 method for class 'call'
as.hi(x, maxindex = NA, dim = NULL, dimorder = NULL, vw = NULL
, vw.convert = TRUE, pack = TRUE, envir = parent.frame(), ...)
## S3 method for class 'name'
as.hi(x, envir = parent.frame(), ...)
## S3 method for class 'integer'
as.hi(x, maxindex = NA, dim = NULL, dimorder = NULL
, symmetric = FALSE, fixdiag = NULL, vw = NULL, vw.convert = TRUE
, dimorder.convert  = TRUE, pack = TRUE, NAs = NULL, ...)
## S3 method for class 'which'
as.hi(x, ...)
## S3 method for class 'double'
as.hi(x, ...)
## S3 method for class 'logical'
as.hi(x, maxindex = NA, dim = NULL, vw = NULL, pack = TRUE, ...)
## S3 method for class 'character'
as.hi(x, names, vw = NULL, vw.convert = TRUE, ...)
## S3 method for class 'matrix'
as.hi(x, dim, dimorder = NULL, symmetric = FALSE, fixdiag = NULL
, vw = NULL, pack = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.hi_+3A_x">x</code></td>
<td>
<p> an appropriate object of the class for which we dispatched </p>
</td></tr>
<tr><td><code id="as.hi_+3A_envir">envir</code></td>
<td>
<p> the environment in which to evaluate components of the index expression </p>
</td></tr>
<tr><td><code id="as.hi_+3A_maxindex">maxindex</code></td>
<td>
<p> maximum positive indexposition <code>maxindex</code>, is needed with negative indices, if vw or dim is given, maxindex is calculated automatically </p>
</td></tr>
<tr><td><code id="as.hi_+3A_names">names</code></td>
<td>
<p> the <code><a href="#topic+names.ff">names</a></code> of the indexed vector for character indexing </p>
</td></tr>
<tr><td><code id="as.hi_+3A_dim">dim</code></td>
<td>
<p> the <code><a href="#topic+dim.ff">dim</a></code> of the indexed matrix to be stored within the <code><a href="#topic+hi">hi</a></code> object </p>
</td></tr>
<tr><td><code id="as.hi_+3A_dimorder">dimorder</code></td>
<td>
<p> the <code><a href="#topic+dimorder">dimorder</a></code> of the indexed matrix to be stored within the <code><a href="#topic+hi">hi</a></code> object, may convert interpretation of <code>x</code> </p>
</td></tr>
<tr><td><code id="as.hi_+3A_symmetric">symmetric</code></td>
<td>
<p> the <code><a href="#topic+symmetric">symmetric</a></code> of the indexed matrix to be stored within the <code><a href="#topic+hi">hi</a></code> object </p>
</td></tr>
<tr><td><code id="as.hi_+3A_fixdiag">fixdiag</code></td>
<td>
<p> the <code><a href="#topic+fixdiag">fixdiag</a></code> of the indexed matrix to be stored within the <code><a href="#topic+hi">hi</a></code> object </p>
</td></tr>
<tr><td><code id="as.hi_+3A_vw">vw</code></td>
<td>
<p> the virtual window <code><a href="#topic+vw">vw</a></code> of the indexed vector or matrix to be stored within the <code><a href="#topic+hi">hi</a></code> object, see details </p>
</td></tr>
<tr><td><code id="as.hi_+3A_vw.convert">vw.convert</code></td>
<td>
<p> FALSE to prevent doubly virtual window conversion, this is needed for some internal calls that have done the virtual window conversion already, see details </p>
</td></tr>
<tr><td><code id="as.hi_+3A_dimorder.convert">dimorder.convert</code></td>
<td>
<p> FALSE to prevent doubly dimorder conversion, this is needed for some internal calls that have done the dimorder conversion already, see details </p>
</td></tr>
<tr><td><code id="as.hi_+3A_nas">NAs</code></td>
<td>
<p> a vector of NA positions to be stored <code><a href="bit.html#topic+rlepack">rlepack</a>ed</code>, not fully supported yet </p>
</td></tr>
<tr><td><code id="as.hi_+3A_pack">pack</code></td>
<td>
<p> FALSE to prevent <code><a href="bit.html#topic+rlepack">rlepack</a>ing</code>, note that this is a hint rather than a guarantee, <code>as.hi.bit</code> might ignore this </p>
</td></tr>
<tr><td><code id="as.hi_+3A_range">range</code></td>
<td>
<p> NULL or a vector with two elements indicating first and last position to be converted from 'bit' to 'hi' </p>
</td></tr>
<tr><td><code id="as.hi_+3A_...">...</code></td>
<td>
<p> further argument passed from generic to method or from wrapper method to <code>as.hi.integer</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic dispatches appropriately, <code>as.hi.hi</code> returns an <code><a href="#topic+hi">hi</a></code> object unchanged,
<code>as.hi.call</code> tries to <code><a href="#topic+hiparse">hiparse</a></code> instead of evaluate its input in order to save RAM.
If parsing is successfull <code>as.hi.call</code> will ignore its argument <code>pack</code> and always pack unless the subscript is too small to do so.
If parsing fails it evaluates the index expression and dispatches again to one of the other methods.
<code>as.hi.name</code> and <code>as.hi.(</code> are wrappers to <code>as.hi.call</code>.
<code>as.hi.integer</code> is the workhorse for coercing evaluated expressions
and <code>as.hi.which</code> is a wrapper removing the <code>which</code> class attribute.
<code>as.hi.double</code>, <code>as.hi.logical</code> and <code>as.hi.character</code> are also wrappers to <code>as.hi.integer</code>,
but note that <code>as.hi.logical</code> is not memory efficient because it expands <em>all</em> positions and then applies logical subscripting.
<br />
<code>as.hi.matrix</code> calls <code><a href="#topic+arrayIndex2vectorIndex">arrayIndex2vectorIndex</a></code> and then <code>as.hi.integer</code> to interpret and preprocess matrix indices.
<br />
If the <code>dim</code> and <code>dimorder</code> parameter indicate a non-standard dimorder (<code><a href="#topic+dimorderStandard">dimorderStandard</a></code>), the index information in <code>x</code> is converted from a standard dimorder interpretation to the requested <code><a href="#topic+dimorder">dimorder</a></code>.
<br />
If the <code>vw</code> parameter is used, the index information in <code>x</code> is interpreted relative to the virtual window but stored relative to the abolute origin.
Back-coercion via <code><a href="#topic+as.integer.hi">as.integer.hi</a></code> and friends will again return the index information relative to the virtual window, thus retaining symmetry and transparency of the viurtual window to the user.
<br />
You can use <code><a href="#topic+length.hi">length</a></code> to query the index length (possibly length of negative subscripts),
<code><a href="#topic+length.hi">poslength</a></code> to query the number of selected elements (even with negative subscripts),
and <code><a href="#topic+length.hi">maxindex</a></code> to query the largest possible index position (within virtual window, if present)
<br />
Duplicated negative indices are removed and will not be recovered by <code><a href="#topic+as.integer.hi">as.integer.hi</a></code>.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+hi">hi</a></code>
</p>


<h3>Note</h3>

<p> Avoid changing the Hybrid Index representation, this might crash the <code><a href="#topic++5B.ff">[.ff</a></code> subscripting. </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hi">hi</a></code> for the Hybrid Index class, <code><a href="#topic+hiparse">hiparse</a></code> for parsing details, <code><a href="#topic+as.integer.hi">as.integer.hi</a></code> for back-coercion, <code><a href="#topic++5B.ff">[.ff</a></code> for ff subscripting </p>


<h3>Examples</h3>

<pre><code class='language-R'>  message("integer indexing with and without rel-packing")
  as.hi(1:12)
  as.hi(1:12, pack=FALSE)
  message("if index is double, the wrapper method just converts to integer")
  as.hi(as.double(1:12))
  message("if index is character, the wrapper method just converts to integer")
  as.hi(c("a","b","c"), names=letters)
  message("negative index must use maxindex (or vw)")
  as.hi(-(1:3), maxindex=12)
  message("logical index can use maxindex")
  as.hi(c(FALSE, FALSE, TRUE, TRUE))
  as.hi(c(FALSE, FALSE, TRUE, TRUE), maxindex=12)

  message("matrix index")
  x &lt;- matrix(1:12, 6)
  as.hi(rbind(c(1,1), c(1,2), c(2,1)), dim=dim(x))

  message("first ten positions within virtual window")
  i &lt;- as.hi(1:10, vw=c(10, 80, 10))
  i
  message("back-coerce relativ to virtual window")
  as.integer(i)
  message("back-coerce relativ to absolute origin")
  as.integer(i, vw.convert=FALSE)

  message("parsed index expressions save index RAM")
    as.hi(quote(1:1000000000))
## Not run: 
  message("compare to RAM requirement when the index experssion is evaluated")
    as.hi(1:1000000000)

## End(Not run)

message("example of parsable index expression")
  a &lt;- seq(100, 200, 20)
  as.hi(substitute(c(1:5, 4:9, a)))
  hi(c(1,4, 100),c(5,9, 200), by=c(1,1,20))

message("two examples of index expression temporarily expanded to full length due to 
non-supported use of brackets '(' and mathematical operators '+' accepting token")
message("example1: accepted token but aborted parsing because length&gt;16")
  as.hi(quote(1+(1:16)))
message("example1: rejected token and aborted parsing because length&gt;16")
  as.hi(quote(1+(1:17)))
</code></pre>

<hr>
<h2 id='as.integer.hi'> Hybrid Index, coercing from </h2><span id='topic+as.which.hi'></span><span id='topic+as.bitwhich.hi'></span><span id='topic+as.bit.hi'></span><span id='topic+as.integer.hi'></span><span id='topic+as.logical.hi'></span><span id='topic+as.character.hi'></span><span id='topic+as.matrix.hi'></span>

<h3>Description</h3>

<p>Functions that (back-)convert an <code><a href="#topic+hi">hi</a></code> object to the respective subscripting information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hi'
as.which(x, ...)
## S3 method for class 'hi'
as.bitwhich(x, ...)
## S3 method for class 'hi'
as.bit(x, ...)
## S3 method for class 'hi'
as.integer(x, vw.convert = TRUE, ...)
## S3 method for class 'hi'
as.logical(x, maxindex = NULL, ...)
## S3 method for class 'hi'
as.character(x, names, vw.convert = TRUE, ...)
## S3 method for class 'hi'
as.matrix(x, dim = x$dim, dimorder = x$dimorder
, vw = x$vw, symmetric = x$symmetric, fixdiag = x$fixdiag, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.integer.hi_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="#topic+hi">hi</a></code> </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_maxindex">maxindex</code></td>
<td>
<p> the <code><a href="base.html#topic+length">length</a></code> of the subscripted object (needed for logical output) </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_names">names</code></td>
<td>
<p> the <code><a href="base.html#topic+names">names</a></code> vector of the subscripted object </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_dim">dim</code></td>
<td>
<p> the <code><a href="base.html#topic+dim">dim</a></code> of the subscripted object </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_dimorder">dimorder</code></td>
<td>
<p> the <code><a href="#topic+dimorder">dimorder</a></code> of the subscripted object </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_vw">vw</code></td>
<td>
<p> the virtual window <code><a href="#topic+vw">vw</a></code> of the subscripted object </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_vw.convert">vw.convert</code></td>
<td>
 <p><code>vw.convert</code> </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_symmetric">symmetric</code></td>
<td>
<p> TRUE if the subscripted matrix is <code><a href="#topic+symmetric">symmetric</a></code> </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_fixdiag">fixdiag</code></td>
<td>
<p> TRUE if the subscripted matrix has <code><a href="#topic+fixdiag">fixdiag</a></code> </p>
</td></tr>
<tr><td><code id="as.integer.hi_+3A_...">...</code></td>
<td>
<p> further arguments passed </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.integer.hi</code> returns an integer vector, see <code><a href="#topic+as.hi.integer">as.hi.integer</a></code>.
<code>as.logical.hi</code> returns an logical vector, see <code><a href="#topic+as.hi.logical">as.hi.logical</a></code>.
<code>as.character.hi</code> returns a character vector, see <code><a href="#topic+as.hi.character">as.hi.character</a></code>.
<code>as.matrix.hi</code> returns a matrix index, see <code><a href="#topic+as.hi.matrix">as.hi.matrix</a></code>.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hi">hi</a></code>, <code><a href="#topic+as.hi">as.hi</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:6
  names(x) &lt;- letters[1:6]
  as.integer(as.hi(c(1:3)))
  as.logical(as.hi(c(TRUE,TRUE,TRUE,FALSE,FALSE,FALSE)))
  as.character(as.hi(letters[1:3], names=names(x)), names=names(x))
  x &lt;- matrix(1:12, 6)
  as.matrix(as.hi(rbind(c(1,1), c(1,2), c(2,1)), dim=dim(x)), dim=dim(x))
</code></pre>

<hr>
<h2 id='as.vmode'> Coercing to virtual mode </h2><span id='topic+as.vmode'></span><span id='topic+as.vmode.default'></span><span id='topic+as.vmode.ff'></span><span id='topic+as.boolean'></span><span id='topic+as.boolean.default'></span><span id='topic+as.quad'></span><span id='topic+as.quad.default'></span><span id='topic+as.nibble'></span><span id='topic+as.nibble.default'></span><span id='topic+as.byte'></span><span id='topic+as.byte.default'></span><span id='topic+as.ubyte'></span><span id='topic+as.ubyte.default'></span><span id='topic+as.short'></span><span id='topic+as.short.default'></span><span id='topic+as.ushort'></span><span id='topic+as.ushort.default'></span>

<h3>Description</h3>

<p><code>as.vmode</code> is a generic that converts some R ram object to the desired <code><a href="#topic+vmode">vmode</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vmode(x, ...)
as.boolean(x, ...)
as.quad(x, ...)
as.nibble(x, ...)
as.byte(x, ...)
as.ubyte(x, ...)
as.short(x, ...)
as.ushort(x, ...)
## Default S3 method:
as.vmode(x, vmode, ...)
## S3 method for class 'ff'
as.vmode(x, ...)
## Default S3 method:
as.boolean(x, ...)
## Default S3 method:
as.quad(x, ...)
## Default S3 method:
as.nibble(x, ...)
## Default S3 method:
as.byte(x, ...)
## Default S3 method:
as.ubyte(x, ...)
## Default S3 method:
as.short(x, ...)
## Default S3 method:
as.ushort(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vmode_+3A_x">x</code></td>
<td>
<p> any object </p>
</td></tr>
<tr><td><code id="as.vmode_+3A_vmode">vmode</code></td>
<td>
<p> virtual mode </p>
</td></tr>
<tr><td><code id="as.vmode_+3A_...">...</code></td>
<td>
<p> The <code>...</code> don't have a function yet, they are only defined to keep the generic flexible. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>as.vmode</code> actually coerces to one of the usual <code><a href="base.html#topic+storage.mode">storage.mode</a>s</code> (see <code><a href="#topic+.rammode">.rammode</a></code>) but flags them with an additional attribute 'vmode' if necessary.
The coercion generics can also be called directly:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>as.boolean</code>    </td><td style="text-align: left;">  1 bit logical without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.logical</code>    </td><td style="text-align: left;">  2 bit logical with NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.quad</code>       </td><td style="text-align: left;">  2 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.nibble</code>     </td><td style="text-align: left;">  4 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.byte</code>       </td><td style="text-align: left;">  8 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.ubyte</code>      </td><td style="text-align: left;">  8 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.short</code>      </td><td style="text-align: left;"> 16 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.ushort</code>     </td><td style="text-align: left;"> 16 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.integer</code>    </td><td style="text-align: left;"> 32 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.single</code>     </td><td style="text-align: left;"> 32 bit float </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.double</code>     </td><td style="text-align: left;"> 64 bit float </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.complex</code>    </td><td style="text-align: left;"> 2x64 bit float </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.raw</code>        </td><td style="text-align: left;"> 8 bit unsigned char </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>as.character</code>  </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p>a vector of the desired vmode containing the input data
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+vmode">vmode</a></code>, <code><a href="#topic+vector.vmode">vector.vmode</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.vmode(1:3,"double")
  as.vmode(1:3,"byte")
  as.double(1:3)
  as.byte(1:3)
</code></pre>

<hr>
<h2 id='bigsample'> Sampling from large pools </h2><span id='topic+bigsample'></span><span id='topic+bigsample.default'></span><span id='topic+bigsample.ff'></span>

<h3>Description</h3>

<p><code>bigsample</code> samples quicker from large pools than <code><a href="base.html#topic+sample">sample</a></code> does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bigsample(x, ...)
## Default S3 method:
bigsample(x, size, replace = FALSE, prob = NULL, negative = FALSE, ...)
## S3 method for class 'ff'
bigsample(x, size, replace = FALSE, prob = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bigsample_+3A_x">x</code></td>
<td>
<p> the pool to sample from </p>
</td></tr>
<tr><td><code id="bigsample_+3A_size">size</code></td>
<td>
<p> the number of elements to sample </p>
</td></tr>
<tr><td><code id="bigsample_+3A_replace">replace</code></td>
<td>
<p> TRUE to use sampling with replacement </p>
</td></tr>
<tr><td><code id="bigsample_+3A_prob">prob</code></td>
<td>
<p> optional vector of sampling probabilities (recyled to pool length) </p>
</td></tr>
<tr><td><code id="bigsample_+3A_negative">negative</code></td>
<td>
 <p><code>negative</code> </p>
</td></tr>
<tr><td><code id="bigsample_+3A_...">...</code></td>
<td>
 <p><code>...</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For small pools <code><a href="base.html#topic+sample">sample</a></code> is called.
</p>


<h3>Value</h3>

<p>a vector of elements sampled from the pool (argument 'x')
</p>


<h3>Note</h3>

<p>Note that <code>bigsample</code> and <code>sample</code> do not necessarily return the same sequence of elements when <code>set.seed</code> is set before.
</p>


<h3>Author(s)</h3>

<p> Daniel Adler, Jens Oehlschlägel, Walter Zucchini</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+sample">sample</a></code>, <code><a href="#topic+ff">ff</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>message("Specify pool size")
bigsample(1e8, 10)
message("Sample ff elements (same as x[bigsample(length(ff(1:100 / 10)), 10)])")
bigsample(ff(1:100 / 10), 10)
 ## Not run: 
   message("Speed factor")
     (system.time(for(i in 1:10)sample(1e8, 10))[3]/10) 
   / (system.time(for(i in 1:1000)bigsample(1e8, 10))[3]/1000)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='CFUN'> Collapsing functions for batch processing </h2><span id='topic+CFUN'></span><span id='topic+ccbind'></span><span id='topic+crbind'></span><span id='topic+cfun'></span><span id='topic+cquantile'></span><span id='topic+csummary'></span><span id='topic+cmedian'></span><span id='topic+clength'></span><span id='topic+csum'></span><span id='topic+cmean'></span>

<h3>Description</h3>

<p>These are used in aggregating the chunks resulting from batch processing. They are usually called via <code><a href="base.html#topic+do.call">do.call</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccbind(...)
crbind(...)
cfun(..., FUN, FUNARGS = list())
cquantile(..., probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7)
csummary(..., na.rm = "ignored")
cmedian(..., na.rm = FALSE)
clength(..., na.rm = FALSE)
csum(..., na.rm = FALSE)
cmean(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CFUN_+3A_...">...</code></td>
<td>
 <p><code>...</code> </p>
</td></tr>
<tr><td><code id="CFUN_+3A_fun">FUN</code></td>
<td>
<p> a aggregating function </p>
</td></tr>
<tr><td><code id="CFUN_+3A_funargs">FUNARGS</code></td>
<td>
<p> further arguments to the aggregating function </p>
</td></tr>
<tr><td><code id="CFUN_+3A_na.rm">na.rm</code></td>
<td>
<p> TRUE to remove NAs </p>
</td></tr>
<tr><td><code id="CFUN_+3A_probs">probs</code></td>
<td>
<p> see <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="CFUN_+3A_names">names</code></td>
<td>
<p> see <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
<tr><td><code id="CFUN_+3A_type">type</code></td>
<td>
<p> see <code><a href="stats.html#topic+quantile">quantile</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
  <strong>CFUN</strong>        </td><td style="text-align: left;"> <strong>FUN</strong>              </td><td style="text-align: left;"> <strong>comment</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>ccbind</code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+cbind">cbind</a></code>    </td><td style="text-align: left;"> like <code>cbind</code> but respecting names </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>crbind</code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+rbind">rbind</a></code>    </td><td style="text-align: left;"> like <code>rbind</code> but respecting names </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cfun</code>       </td><td style="text-align: left;">                           </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then apply 'FUN' to each column </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cquantile</code>  </td><td style="text-align: left;"> <code><a href="stats.html#topic+quantile">quantile</a></code> </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then apply 'quantile' to each column </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>csummary</code>   </td><td style="text-align: left;"> <code><a href="base.html#topic+summary">summary</a></code>  </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then apply 'summary' to each column </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cmedian</code>    </td><td style="text-align: left;"> <code><a href="stats.html#topic+median">median</a></code>   </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then apply 'median' to each column </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>clength</code>    </td><td style="text-align: left;"> <code><a href="base.html#topic+length">length</a></code>   </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then determine the number of values in each column</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>csum</code>       </td><td style="text-align: left;"> <code><a href="base.html#topic+sum">sum</a></code>      </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then determine the sum values in each column</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>cmean</code>      </td><td style="text-align: left;"> <code><a href="base.html#topic+mean">mean</a></code>     </td><td style="text-align: left;"> <code>crbind</code> the input chunks and then determine the (unweighted) mean in each column</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>In order to use CFUNs on the result of <code><a href="base.html#topic+lapply">lapply</a></code> or <code><a href="#topic+ffapply">ffapply</a></code> use <code><a href="base.html#topic+do.call">do.call</a></code>.
</p>


<h3>Value</h3>

<p>depends on the CFUN used
</p>


<h3>ff options</h3>

<p>xx TODO: extend this for weighted means, weighted median etc., <br />
google &quot;Re: [R] Weighted median&quot;
</p>


<h3>Note</h3>

<p>Currently - for command line convenience - we map the elements of a single list argument to ..., but this may change in the future.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ffapply">ffapply</a></code>, <code><a href="base.html#topic+do.call">do.call</a></code>, <code><a href="bit.html#topic+na.count">na.count</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- lapply(split(rnorm(1000), 1:10), summary)
   do.call("crbind", X)
   do.call("csummary", X)
   do.call("cmean", X)
   do.call("cfun", c(X, list(FUN=mean, FUNARGS=list(na.rm=TRUE))))
   rm(X)
</code></pre>

<hr>
<h2 id='chunk.ffdf'>
Chunk ff_vector and ffdf
</h2><span id='topic+chunk.ffdf'></span><span id='topic+chunk.ff_vector'></span>

<h3>Description</h3>

<p>Chunking method for ff_vector and ffdf objects (row-wise) automatically considering RAM requirements from recordsize as calculated from <code><a href="base.html#topic+sum">sum</a>(<a href="#topic+.rambytes">.rambytes</a>[<a href="#topic+vmode">vmode</a>])</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff_vector'
chunk(x
, RECORDBYTES = .rambytes[vmode(x)], BATCHBYTES = getOption("ffbatchbytes"), ...)
## S3 method for class 'ffdf'
chunk(x
, RECORDBYTES = sum(.rambytes[vmode(x)]), BATCHBYTES = getOption("ffbatchbytes"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk.ffdf_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+ff">ff</a></code> or <code><a href="#topic+ffdf">ffdf</a></code></p>
</td></tr>
<tr><td><code id="chunk.ffdf_+3A_recordbytes">RECORDBYTES</code></td>
<td>
<p> optional integer scalar representing the bytes needed to process an element of the <code>ff_vector</code> a single row of the <code>ffdf</code> </p>
</td></tr>
<tr><td><code id="chunk.ffdf_+3A_batchbytes">BATCHBYTES</code></td>
<td>
<p> integer scalar limiting the number of bytes to be processed in one chunk, default from <code>getOption("ffbatchbytes")</code>, see also <code><a href="#topic+.rambytes">.rambytes</a></code> </p>
</td></tr>
<tr><td><code id="chunk.ffdf_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="bit.html#topic+chunk">chunk</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code><a href="bit.html#topic+ri">ri</a></code> indexes each representing one chunk
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

 <p><code><a href="bit.html#topic+chunk">chunk</a></code>, <code><a href="#topic+ffdf">ffdf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- data.frame(x=as.double(1:26), y=factor(letters), z=ordered(LETTERS), stringsAsFactors = TRUE)
  a &lt;- as.ffdf(x)
  ceiling(26 / (300 %/% sum(.rambytes[vmode(a)])))
  chunk(a, BATCHBYTES=300)
  ceiling(13 / (100 %/% sum(.rambytes[vmode(a)])))
  chunk(a, from=1, to = 13, BATCHBYTES=100)
  rm(a); gc()

  message("dummy example for linear regression with biglm on ffdf")
  library(biglm)

  message("NOTE that . in formula requires calculating terms manually
    because . as a data-dependant term is not allowed in biglm")
  form &lt;- Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width + Species

  lmfit &lt;- lm(form, data=iris)

  firis &lt;- as.ffdf(iris)
  for (i in chunk(firis, by=50)){
    if (i[1]==1){
      message("first chunk is: ", i[[1]],":",i[[2]])
      biglmfit &lt;- biglm(form, data=firis[i,,drop=FALSE])
    }else{
      message("next chunk is: ", i[[1]],":",i[[2]])
      biglmfit &lt;- update(biglmfit, firis[i,,drop=FALSE])
    }
  }

  summary(lmfit)
  summary(biglmfit)
  stopifnot(all.equal(coef(lmfit), coef(biglmfit)))
</code></pre>

<hr>
<h2 id='clone.ff'> Cloning ff and ram objects </h2><span id='topic+clone.ff'></span>

<h3>Description</h3>

<p><code>clone</code> physically duplicates ff (and ram) objects and can additionally change some features, e.g. length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
clone(x
, initdata = x
, length = NULL
, levels = NULL
, ordered = NULL
, dim = NULL
, dimorder = NULL
, bydim = NULL
, symmetric = NULL
, fixdiag = NULL
, names = NULL
, dimnames = NULL
, ramclass = NULL
, ramattribs = NULL
, vmode = NULL
, update  = NULL
, pattern = NULL
, filename = NULL
, overwrite = FALSE
, pagesize = NULL
, caching = NULL
, finalizer = NULL
, finonexit = NULL
, FF_RETURN = NULL
, BATCHSIZE = .Machine$integer.max
, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE
, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone.ff_+3A_x">x</code></td>
<td>
 <p><code>x</code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_initdata">initdata</code></td>
<td>
<p> scalar or vector of the <code><a href="#topic+.vimplemented">.vimplemented</a></code> <code><a href="#topic+vmode">vmode</a></code>s, recycled if needed, default 0, see also <code><a href="#topic+as.vmode">as.vmode</a></code> and <code><a href="#topic+vector.vmode">vector.vmode</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_length">length</code></td>
<td>
<p> optional vector <code><a href="base.html#topic+length">length</a></code> of the object (default: derive from 'initdata' or 'dim'), see <code><a href="#topic+length.ff">length.ff</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_levels">levels</code></td>
<td>
<p> optional character vector of levels if (in this case initdata must be composed of these) (default: derive from initdata) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_ordered">ordered</code></td>
<td>
<p> indicate whether the levels are ordered (TRUE) or non-ordered factor (FALSE, default) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_dim">dim</code></td>
<td>
<p> optional array <code><a href="base.html#topic+dim">dim</a></code>, see <code><a href="#topic+dim.ff">dim.ff</a></code> and <code><a href="base.html#topic+array">array</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_dimorder">dimorder</code></td>
<td>
<p> physical layout (default seq_along(dim)), see <code><a href="#topic+dimorder">dimorder</a></code> and <code><a href="base.html#topic+aperm">aperm</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_bydim">bydim</code></td>
<td>
<p> dimorder by which to interpret the 'initdata', generalization of the 'byrow' paramter in <code><a href="base.html#topic+matrix">matrix</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_symmetric">symmetric</code></td>
<td>
<p> extended feature: TRUE creates symmetric matrix (default FALSE) 
</p>
</td></tr>
<tr><td><code id="clone.ff_+3A_fixdiag">fixdiag</code></td>
<td>
<p> extended feature: non-NULL scalar requires fixed diagonal for symmetric matrix (default NULL is free diagonal) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_names">names</code></td>
<td>
<p> see <code><a href="base.html#topic+names">names</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_dimnames">dimnames</code></td>
<td>
<p> NOT taken from initdata, see <code><a href="base.html#topic+dimnames">dimnames</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_ramclass">ramclass</code></td>
<td>
<p> class attribute attached when moving all or parts of this ff into ram, see <code><a href="#topic+ramclass">ramclass</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_ramattribs">ramattribs</code></td>
<td>
<p> additional attributes attached when moving all or parts of this ff into ram, see <code><a href="#topic+ramattribs">ramattribs</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_vmode">vmode</code></td>
<td>
<p> virtual storage mode (default: derive from 'initdata'), see <code><a href="#topic+vmode">vmode</a></code> and <code><a href="#topic+as.vmode">as.vmode</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_update">update</code></td>
<td>
<p> set to FALSE to avoid updating with 'initdata' (default TRUE) (used by <code><a href="#topic+ffdf">ffdf</a></code>) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_pattern">pattern</code></td>
<td>
<p> root pattern for automatic ff filename creation (default &quot;ff&quot;), see also <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_filename">filename</code></td>
<td>
<p> ff <code><a href="#topic+filename">filename</a></code> (default tmpfile with 'pattern' prefix), see also <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_overwrite">overwrite</code></td>
<td>
<p> set to TRUE to allow overwriting existing files (default FALSE) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_pagesize">pagesize</code></td>
<td>
<p> pagesize in bytes for the memory mapping (default from getOptions(&quot;ffpagesize&quot;) initialized by <code><a href="#topic+getdefaultpagesize">getdefaultpagesize</a></code>), see also <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_caching">caching</code></td>
<td>
<p> caching scheme for the backend, currently 'mmnoflush' or 'mmeachflush' (flush mmpages at each swap, default from getOptions(&quot;ffcaching&quot;) initialized with 'memorymap'), see also <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_finalizer">finalizer</code></td>
<td>
<p> name of finalizer function called when ff object is <code><a href="base.html#topic+remove">remove</a>d</code>, (default &quot;deleteIfOpen&quot; from getOptions(&quot;fffinalizer&quot;))), standard finalizers are <code><a href="#topic+close.ff">close.ff</a></code>, <code><a href="#topic+delete.ff">delete.ff</a></code> and <code><a href="#topic+deleteIfOpen.ff">deleteIfOpen.ff</a></code>, see also <code><a href="base.html#topic+reg.finalizer">reg.finalizer</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_finonexit">finonexit</code></td>
<td>
<p> logical scalar determining whether finalizer is also called when R is closed via <code><a href="base.html#topic+q">q</a></code>, (default TRUE from getOptions(&quot;fffinonexit&quot;)) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_ff_return">FF_RETURN</code></td>
<td>
<p> logical scalar or ff object to be used. The default NULL creates a ff or ram clone, TRUE returns a ff clone, FALSE returns a ram clone. Handing over an ff object here uses this or stops if not <code><a href="#topic+ffsuitable">ffsuitable</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_batchsize">BATCHSIZE</code></td>
<td>
<p> integer scalar limiting the number of elements to be processed in <code><a href="#topic+update.ff">update.ff</a></code> when length(initdata)&gt;1, default from getOption(&quot;ffbatchsize&quot;) </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_batchbytes">BATCHBYTES</code></td>
<td>
<p> integer scalar limiting the number of bytes to be processed in <code><a href="#topic+update.ff">update.ff</a></code> when length(initdata)&gt;1, default from getOption(&quot;ffbatchbytes&quot;), see also <code><a href="#topic+.rambytes">.rambytes</a></code> </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_verbose">VERBOSE</code></td>
<td>
<p> set to TRUE for verbosing in <code><a href="#topic+update.ff">update.ff</a></code> when length(initdata)&gt;1, default FALSE </p>
</td></tr>
<tr><td><code id="clone.ff_+3A_...">...</code></td>
<td>
<p> further arguments to the generic </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clone</code> is generic. <code>clone.ff</code> is the workhorse behind <code><a href="#topic+as.ram">as.ram</a></code> and <code><a href="#topic+as.ff">as.ff</a></code>.
For creating the desired object it calls <code><a href="#topic+ff">ff</a></code> which calls <code><a href="stats.html#topic+update">update</a></code> for initialization.
</p>


<h3>Value</h3>

<p>an ff or ram object
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="stats.html#topic+update">update</a></code>, <code><a href="#topic+as.ram">as.ram</a></code>, <code><a href="#topic+as.ff">as.ff</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(letters, levels=letters)
  y &lt;- clone(x, length=52)
  rm(x,y); gc()
</code></pre>

<hr>
<h2 id='clone.ffdf'>
Cloning ffdf objects
</h2><span id='topic+clone.ffdf'></span>

<h3>Description</h3>

<p>clone physically duplicates ffdf objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffdf'
clone(x, nrow=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone.ffdf_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ffdf">ffdf</a></code> </p>
</td></tr>
<tr><td><code id="clone.ffdf_+3A_nrow">nrow</code></td>
<td>
<p> optionally the desired number of rows in the new object. Currently this works only together with <code>initdata=NULL</code> </p>
</td></tr>
<tr><td><code id="clone.ffdf_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code><a href="bit.html#topic+clone">clone</a></code> (usually not usefull) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a deep copy of an ffdf object by cloning all <code><a href="#topic+physical.ffdf">physical</a></code> components including the <code><a href="#topic+dimnames.ffdf">row.names</a></code>
</p>


<h3>Value</h3>

<p>An object of type <code><a href="#topic+ffdf">ffdf</a></code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+clone">clone</a></code>, <code><a href="#topic+ffdf">ffdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.ffdf(data.frame(a=1:26, b=letters, stringsAsFactors = TRUE))

  message("Here we change the content of both x and y by reference")
  y &lt;- x
  x$a[1] &lt;- -1
  y$a[1]

  message("Here we change the content only of x because y is a deep copy")
  y &lt;- clone(x)
  x$a[2] &lt;- -2
  y$a[2]
  rm(x, y); gc()
</code></pre>

<hr>
<h2 id='close.ff'> Closing ff files </h2><span id='topic+close.ff'></span><span id='topic+close.ffdf'></span><span id='topic+close.ff_pointer'></span>

<h3>Description</h3>

<p>Close frees the Memory Mapping resources and closes the ff file without deleting the file data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
close(con, ...)
## S3 method for class 'ffdf'
close(con, ...)
## S3 method for class 'ff_pointer'
close(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close.ff_+3A_con">con</code></td>
<td>
<p> an open ff object </p>
</td></tr>
<tr><td><code id="close.ff_+3A_...">...</code></td>
<td>
 <p><code>...</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ff_pointer</code> method is not intended for manual use, it is used at finalizer dispatch time.
Closing ffdf objects will close all of their <code><a href="#topic+physical.ffdf">physical</a></code> components including their <code><a href="#topic+row.names.ffdf">row.names</a></code> if they are <code><a href="#topic+is.ff">is.ff</a></code>
</p>


<h3>Value</h3>

<p>TRUE if the file could be closed, FALSE if it was closed already (or NA if not all components of an ffdf returned FALSE or TRUE on closing)
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+open.ff">open.ff</a></code>, <code><a href="#topic+delete">delete</a></code>, <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  close(x)
  x
  open(x)
  x
  rm(x); gc()
</code></pre>

<hr>
<h2 id='delete'> Deleting the file behind an ff object </h2><span id='topic+delete'></span><span id='topic+delete.ff'></span><span id='topic+delete.ffdf'></span><span id='topic+delete.ff_pointer'></span><span id='topic+delete.default'></span><span id='topic+deleteIfOpen'></span><span id='topic+deleteIfOpen.ff'></span><span id='topic+deleteIfOpen.ff_pointer'></span>

<h3>Description</h3>

<p>The generic <code>delete</code> deletes the content of an object without removing the object itself.
The generic <code>deleteIfOpen</code> does the same, but only if <code><a href="#topic+is.open">is.open</a></code> returns TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete(x, ...)
deleteIfOpen(x, ...)
## S3 method for class 'ff'
delete(x, ...)
## S3 method for class 'ffdf'
delete(x, ...)
## S3 method for class 'ff_pointer'
delete(x, ...)
## Default S3 method:
delete(x, ...)
## S3 method for class 'ff'
deleteIfOpen(x, ...)
## S3 method for class 'ff_pointer'
deleteIfOpen(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="delete_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The proper sequence to fully delete an ff object is: <code>delete(x);rm(x)</code>, where <code>delete.ff</code> frees the Memory Mapping resources and deletes the ff file,
leaving intact the R-side object including its <code><a href="base.html#topic+class">class</a></code>, <code><a href="#topic+physical.ff">physical</a></code> and <code><a href="#topic+physical.ff">virtual</a></code> attributes.
The default method is a compatibility function doing something similar with ram objects: by assiging an empty list to the name of the ram object to the parent frame
we destroy the content of the object, leaving an empty stub that prevents raising an error if the parent frame calls the <code>delete(x);rm(x)</code> sequence. <br />
The <code>deleteIfOpen</code> does the same as <code>delete</code> but protects closed ff objects from deletion, it is mainly intended for use through a finalizer, as are the <code>ff_pointer</code> methods.
</p>


<h3>Value</h3>

<p><code>delete</code> returns TRUE if the/all ff files could be removed and FALSE otherwise. <br />
<code>deleteIfOpen</code> returns TRUE if the/all ff files could be removed, FALSE if not and NA if the ff object was open.
</p>


<h3>Note</h3>

<p>Deletion of ff files can be triggerd automatically via three routes:
</p>

<ol>
<li><p> if an ff object with a 'delete' finalizer is removed
</p>
</li>
<li><p> if an ff object was created with <code>fffinonexit=TRUE</code> the finalizer is also called when R shuts down.
</p>
</li>
<li><p> if an ff object was created in <code>getOption("fftempdir")</code>, it will be unlinked together with the fftempdir <code><a href="base.html#topic+ns-hooks">.onUnload</a></code>
</p>
</li></ol>

<p>Thus in order to retain an ff file, one has to create it elsewhere than in fftempdir with a finalizer that does not destroy the file (by default files outside fftempdir get a 'close' finalizer') i.e. one of the following:
</p>

<ol>
<li><p> name the file AND use <code>fffinalizer="close"</code>
</p>
</li>
<li><p> name the file AND use <code>fffinalizer="deleteIfOpen"</code> AND close the ff object before leaving R
</p>
</li>
<li><p> name the file AND use <code>fffinalizer="delete"</code> AND use <code>fffinonexit=FALSE</code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+close.ff">close.ff</a></code>, <code><a href="#topic+open.ff">open.ff</a></code>, <code><a href="base.html#topic+reg.finalizer">reg.finalizer</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  message('create the ff file outside getOption("fftempir"), 
    it will have default finalizer "close", so you need to delete it explicitely')
  x &lt;- ff(1:12, pattern="./ffexample")
  delete(x)
  rm(x)
</code></pre>

<hr>
<h2 id='dim.ff'> Getting and setting dim and dimorder </h2><span id='topic+dim.ff'></span><span id='topic+dim.ffdf'></span><span id='topic+dim+3C-.ff'></span><span id='topic+dim+3C-.ffdf'></span><span id='topic+dimorder'></span><span id='topic+dimorder.default'></span><span id='topic+dimorder.ff_array'></span><span id='topic+dimorder.ffdf'></span><span id='topic+dimorder+3C-'></span><span id='topic+dimorder+3C-.ff_array'></span><span id='topic+dimorder+3C-.ffdf'></span>

<h3>Description</h3>

<p>Assigning <code>dim</code> to an <code>ff_vector</code> changes it to an <code>ff_array</code>.
Beyond that <code>dimorder</code> can be assigned to change from column-major order to row-major order or generalizations for higher order <code>ff_array</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ff'
dim(x)
  ## S3 method for class 'ffdf'
dim(x)
  ## S3 replacement method for class 'ff'
dim(x) &lt;- value
  ## S3 replacement method for class 'ffdf'
dim(x) &lt;- value
   dimorder(x, ...)
   dimorder(x, ...) &lt;- value
  ## Default S3 method:
dimorder(x, ...)
  ## S3 method for class 'ff_array'
dimorder(x, ...)
  ## S3 method for class 'ffdf'
dimorder(x, ...)
  ## S3 replacement method for class 'ff_array'
dimorder(x, ...) &lt;- value
  ## S3 replacement method for class 'ffdf'
dimorder(x, ...) &lt;- value  # just here to catch forbidden assignments
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.ff_+3A_x">x</code></td>
<td>
<p> a ff object </p>
</td></tr>
<tr><td><code id="dim.ff_+3A_value">value</code></td>
<td>
<p> an appropriate integer vector </p>
</td></tr>
<tr><td><code id="dim.ff_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dim</code> and <code>dimorder</code> are <code><a href="#topic+physical.ff">virtual</a></code> attributes. Thus two copies of an R ff object can point to the same file but interpret it differently.
<code>dim</code> has the usual meaning, <code>dimorder</code> defines the dimension order of storage, i.e. <code>c(1,2)</code> corresponds to R's standard column-major order,
<code>c(1,2)</code> corresponds to row-major order, and for higher dimensional arrays dimorder can also be used. Standard dimorder is <code>seq_along(dim(x))</code>. <br />
For <code><a href="#topic+ffdf">ffdf</a></code> <code>dim</code> returns the number of rows and virtual columns. With <code>dim&lt;-.ffdf</code> only the number of rows can be changed. For convenience you can assign <code>NA</code> to the number of columns. <br />
For <code><a href="#topic+ffdf">ffdf</a></code> the dimorder returns non-standard dimorder if any of its columns contains a ff object with non-standard dimorder (see <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>)
An even higher level of virtualization is available using virtual windows, see <code><a href="#topic+vw">vw</a></code>.
</p>


<h3>Value</h3>

<p><code>names</code> returns a character vector (or NULL)
</p>


<h3>Note</h3>

<p><code>x[]</code> returns a matrix like <code>x[,]</code> and thus respects dimorder, while <code>x[i:j]</code> returns a vector and simply returns elements in the stored order.
Check the corresponding example twice, in order to make sure you understand that for non-standard dimorder <code>x[seq_along(x)]</code> is <em>not the same</em> as <code>as.vector(x[])</code>.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+dim">dim</a></code>, <code><a href="#topic+dimnames.ff">dimnames.ff_array</a></code>, <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>, <code><a href="#topic+vw">vw</a></code>, <code><a href="#topic+physical.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12, dim=c(3,4), dimorder=c(2:1))
  y &lt;- x
  dim(y) &lt;- c(4,3)
  dimorder(y) &lt;- c(1:2)
  x
  y
  x[]
  y[]
  x[,bydim=c(2,1)]
  y[,bydim=c(2,1)]

  message("NOTE that x[] like x[,] returns a matrix (respects dimorder),")
  message("while x[1:12] returns a vector IN STORAGE ORDER")
  message("check the following examples twice to make sure you understand this")
  x[,]
  x[]
  as.vector(x[])
  x[1:12]
  rm(x,y); gc()

  
  ## Not run: 
    message("some performance comparison between different dimorders")
    n &lt;- 100
    m &lt;- 100000
    a &lt;- ff(1L,dim=c(n,m))
    b &lt;- ff(1L,dim=c(n,m), dimorder=2:1)
    system.time(lapply(1:n, function(i)sum(a[i,])))
    system.time(lapply(1:n, function(i)sum(b[i,])))
    system.time(lapply(1:n, function(i){i&lt;-(i-1)*(m/n)+1; sum(a[,i:(i+m/n-1)])}))
    system.time(lapply(1:n, function(i){i&lt;-(i-1)*(m/n)+1; sum(b[,i:(i+m/n-1)])}))
    rm(a,b); gc()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='dimnames.ff'> Getting and setting dimnames </h2><span id='topic+dimnames.ff'></span><span id='topic+dimnames.ff_array'></span><span id='topic+dimnames+3C-.ff_array'></span>

<h3>Description</h3>

<p>For <code>ff_array</code>s you can set dimnames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ff_array'
dimnames(x)
  ## S3 replacement method for class 'ff_array'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames.ff_+3A_x">x</code></td>
<td>
<p> a ff array (or matrix) </p>
</td></tr>
<tr><td><code id="dimnames.ff_+3A_value">value</code></td>
<td>
<p> a list with length(dim(x)) elements (either NULL of character vector of length of dimension </p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code><a href="#topic+vw">vw</a></code> is set, <code>dimnames.ff_array</code> returns the appropriate part of the names, but you can't set <code>dimnames</code> while <code>vw</code> is set.
<code>dimnames</code> returns NULL for <code>ff_vectors</code> and setting <code>dimnames</code> for <code>ff_vector</code> is not allowed, but setting <code><a href="#topic+names.ff">names</a></code> is.
</p>


<h3>Value</h3>

<p><code>dimnames</code> returns a list, see <code><a href="base.html#topic+dimnames">dimnames</a></code>
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+dimnames">dimnames</a></code>, <code><a href="#topic+dim.ff">dim.ff</a></code> , <code><a href="#topic+names.ff">names.ff</a></code> , <code><a href="#topic+vw">vw</a></code>, <code><a href="#topic+physical.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12, dim=c(3,4), dimnames=list(letters[1:3], LETTERS[1:4]))
  dimnames(x)
  dimnames(x) &lt;- list(LETTERS[1:3], letters[1:4])
  dimnames(x)
  dimnames(x) &lt;- NULL
  dimnames(x)
  rm(x); gc()
</code></pre>

<hr>
<h2 id='dimnames.ffdf'>
Getting and setting dimnames of ffdf
</h2><span id='topic+dimnames.ffdf'></span><span id='topic+dimnames+3C-.ffdf'></span><span id='topic+names.ffdf'></span><span id='topic+names+3C-.ffdf'></span><span id='topic+row.names.ffdf'></span><span id='topic+row.names+3C-.ffdf'></span>

<h3>Description</h3>

<p>Getting and setting dimnames, columnnames or rownames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ffdf'
dimnames(x)
  ## S3 replacement method for class 'ffdf'
dimnames(x) &lt;- value
  ## S3 method for class 'ffdf'
names(x)
  ## S3 replacement method for class 'ffdf'
names(x) &lt;- value
  ## S3 method for class 'ffdf'
row.names(x)
  ## S3 replacement method for class 'ffdf'
row.names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames.ffdf_+3A_x">x</code></td>
<td>
<p> a <code><a href="#topic+ffdf">ffdf</a></code> object </p>
</td></tr>
<tr><td><code id="dimnames.ffdf_+3A_value">value</code></td>
<td>
<p> a character vector, or, for dimnames a list with two character vectors </p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended not to assign row.names to a large ffdf object.
</p>


<h3>Value</h3>

<p>The assignment function return the changed ffdf object. The other functions return the expected.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffdf">ffdf</a></code>, <code><a href="#topic+dimnames.ff">dimnames.ff</a></code>, <code><a href="base.html#topic+rownames">rownames</a></code>, <code><a href="base.html#topic+colnames">colnames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ffd &lt;- as.ffdf(data.frame(a=1:26, b=letters, stringsAsFactors = TRUE))
  dimnames(ffd)
  row.names(ffd) &lt;- letters
  dimnames(ffd)
  ffd
  rm(ffd); gc()
</code></pre>

<hr>
<h2 id='dimorderCompatible'> Test for dimorder compatibility </h2><span id='topic+dimorderStandard'></span><span id='topic+vectorStandard'></span><span id='topic+dimorderCompatible'></span><span id='topic+vectorCompatible'></span>

<h3>Description</h3>

<p><code>dimorderStandard</code> returns TRUE if the dimorder is standard (ascending),
<code>vectorStandard</code> returns TRUE if the dimorder-bydim combination is compatible with a standard elementwise vector interpretation,
<code>dimorderCompatible</code> returns TRUE if two dimorders have a compatible  elementwise vector interpretation
and <code>vectorCompatible</code> returns TRUE if dimorder-bydim combinations have a compatible  elementwise vector interpretation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimorderStandard(dimorder)
vectorStandard(dimorder, bydim = NULL)
dimorderCompatible(dim, dim2, dimorder, dimorder2)
vectorCompatible(dim, dim2, dimorder=NULL, dimorder2=NULL, bydim = NULL, bydim2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimorderCompatible_+3A_dim">dim</code></td>
<td>
<p> a <code><a href="base.html#topic+dim">dim</a></code> </p>
</td></tr>
<tr><td><code id="dimorderCompatible_+3A_dim2">dim2</code></td>
<td>
<p> a dim </p>
</td></tr>
<tr><td><code id="dimorderCompatible_+3A_dimorder">dimorder</code></td>
<td>
<p> a <code><a href="#topic+dimorder">dimorder</a></code> </p>
</td></tr>
<tr><td><code id="dimorderCompatible_+3A_dimorder2">dimorder2</code></td>
<td>
<p> a dimorder </p>
</td></tr>
<tr><td><code id="dimorderCompatible_+3A_bydim">bydim</code></td>
<td>
<p> a bydim order, see <code><a href="#topic++5B.ff">[.ff</a></code> </p>
</td></tr>
<tr><td><code id="dimorderCompatible_+3A_bydim2">bydim2</code></td>
<td>
<p> a bydim order, see argument <code>fromdim</code> in <code><a href="#topic+update.ff">update.ff</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if compatibility has been detected, FALSE otherwise
</p>


<h3>Note</h3>

<p> does not yet gurantee to detect all compatible configurations, but the most important ones </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+dimorder">dimorder</a></code>, <code><a href="#topic+ffconform">ffconform</a></code> </p>

<hr>
<h2 id='dummy.dimnames'> Array: make dimnames </h2><span id='topic+dummy.dimnames'></span>

<h3>Description</h3>

<p>makes standard dimnames from letters and integers (for testing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy.dimnames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy.dimnames_+3A_x">x</code></td>
<td>
<p> an <code><a href="base.html#topic+array">array</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with character vectors suitable to be assigned as dimnames to x
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="base.html#topic+dimnames">dimnames</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  dummy.dimnames(matrix(1:12, 3, 4))
</code></pre>

<hr>
<h2 id='Extract.ff'> Reading and writing vectors and arrays (high-level) </h2><span id='topic+Extract.ff'></span><span id='topic++5B.ff'></span><span id='topic++5B+3C-.ff'></span><span id='topic++5B.ff_array'></span><span id='topic++5B+3C-.ff_array'></span><span id='topic++5B+5B.ff'></span><span id='topic++5B+5B+3C-.ff'></span>

<h3>Description</h3>

<p>These are the main methods for reading and writing data from ff files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
x[i, pack = FALSE]
## S3 replacement method for class 'ff'
x[i, add = FALSE, pack = FALSE] &lt;- value
## S3 method for class 'ff_array'
x[..., bydim = NULL, drop = getOption("ffdrop"), pack = FALSE]
## S3 replacement method for class 'ff_array'
x[..., bydim = NULL, add = FALSE, pack = FALSE] &lt;- value
## S3 method for class 'ff'
x[[i]]
## S3 replacement method for class 'ff'
x[[i, add = FALSE]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.ff_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_i">i</code></td>
<td>
<p> missing OR a single index expression OR a <code><a href="#topic+hi">hi</a></code> object </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_...">...</code></td>
<td>
<p> missing OR up to length(dim(x)) index expressions OR <code><a href="#topic+hi">hi</a></code> objects </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_drop">drop</code></td>
<td>
<p> logical scalar indicating whether array dimensions shall be dropped </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_bydim">bydim</code></td>
<td>
<p> the dimorder which shall be used in interpreting vector to/from array data </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_pack">pack</code></td>
<td>
<p> FALSE to prevent rle-packing in hybrid index preprocessing, see <code><a href="#topic+as.hi">as.hi</a></code> </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_value">value</code></td>
<td>
<p> the values to be assigned, possibly recycled </p>
</td></tr>
<tr><td><code id="Extract.ff_+3A_add">add</code></td>
<td>
<p> TRUE if the values should rather increment than overwrite at the target positions, see <code><a href="#topic+readwrite.ff">readwrite.ff</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The single square bracket operators <code>[</code> and <code>[&lt;-</code> are the workhorses for accessing the content of an ff object.
They support <code>ff_vector</code> and <code>ff_array</code> access (<code><a href="#topic+dim.ff">dim.ff</a></code>), they respect virtual windows (<code><a href="#topic+vw">vw</a></code>),
<code><a href="#topic+names.ff">names.ff</a></code> and <code><a href="#topic+dimnames.ff">dimnames.ff</a></code> and retain <code><a href="#topic+ramclass">ramclass</a></code> and <code><a href="#topic+ramattribs">ramattribs</a></code>
and thus support <code><a href="base.html#topic+POSIXct">POSIXct</a></code> and <code><a href="base.html#topic+factor">factor</a></code>, see <code><a href="#topic+levels.ff">levels.ff</a></code>.
<br />
The functionality of <code>[</code> and <code>[&lt;-</code> cn be combined into one efficient operation, see <code><a href="#topic+swap">swap</a></code>.
<br />
The double square bracket operator <code>[[</code> is a shortcut for <code><a href="#topic+get.ff">get.ff</a></code>
resp. <code><a href="#topic+set.ff">set.ff</a></code>, however, you should not rely on this for the future, see <code><a href="#topic+LimWarn">LimWarn</a></code>. For programming please prefer <code>[</code>.
</p>


<h3>Value</h3>

<p>The read operators <code>[</code> and <code>[[</code> return data from the ff object,
possibly decorated with <code><a href="#topic+names.ff">names</a></code>, <code><a href="#topic+dim.ff">dim</a></code>,
<code><a href="#topic+dimnames.ff">dimnames</a></code> and further attributes and classes (see <code><a href="#topic+ramclass">ramclass</a></code>, <code><a href="#topic+ramattribs">ramattribs</a></code>)
<br />
The write operators <code>[&lt;-</code> and <code>[[&lt;-</code> return the 'modified' ff object (like all assignment operators do).
</p>


<h3>Index expressions</h3>

<p><code>x &lt;- ff(1:12, dim=c(3,4), dimnames=list(letters[1:3], NULL))</code>
</p>

<table>
<tr>
 <td style="text-align: right;">
  <em>allowed expression</em>    </td><td style="text-align: left;"> -- </td><td style="text-align: left;"> <em><code>example</code></em>                </td>
</tr>
<tr>
 <td style="text-align: right;">
   positive integers           </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ 1 ,1]</code>                      </td>
</tr>
<tr>
 <td style="text-align: right;">
   negative integers           </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ -(2:12) ]</code>                  </td>
</tr>
<tr>
 <td style="text-align: right;">
   logical                     </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ c(TRUE, FALSE, FALSE) ,1]</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">
   character                   </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ "a" ,1]</code>                    </td>
</tr>
<tr>
 <td style="text-align: right;">
   integer matrices            </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ rbind(c(1,1)) ]</code>            </td>
</tr>
<tr>
 <td style="text-align: right;">
   hybrid index                </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ hi ,1]</code>                     </td>
</tr>
<tr>
 <td style="text-align: right;">
  <em>disallowed expression</em> </td><td style="text-align: left;"> -- </td><td style="text-align: left;"> <em><code>example</code></em>                </td>
</tr>
<tr>
 <td style="text-align: right;">
   zeros                       </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ 0 ]</code>                        </td>
</tr>
<tr>
 <td style="text-align: right;">
   NAs                         </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ NA ]</code>                       </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Dimorder and bydim</h3>

<p>Arrays in R have always standard <code><a href="#topic+dimorder">dimorder</a> seq_along(dim(x))</code> while ff allows to store an array in a different dimorder.
Using nonstandard dimorder (see <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>) can speed up certain access operations: while matrix <code>dimorder=c(1,2)</code> &ndash; column-major order &ndash;
allows fast extraction of columns, <code>dimorder=c(2,1)</code> allows fast extraction of rows.
<br />
While the dimorder &ndash; being an attribute of an <code>ff_array</code> &ndash; controls how the vector in an ff file is interpreted,
the <code>bydim</code> argument to the extractor functions controls, how assigment vector values
in <code>[&lt;-</code> are translated to the array and how the array is translated to a vector in <code>[</code> subscripting.
Note that <code>bydim=c(2,1)</code> corresponds to <code>matrix(..., byrow=TRUE)</code>.
</p>


<h3>Multiple vector interpretation in arrays </h3>

<p>In case of non-standard dimorder (see <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>)
the vector sequence of array elements in R and in the ff file differs.
To access array elements in file order, you can use <code><a href="#topic+getset.ff">getset.ff</a></code>, <code><a href="#topic+readwrite.ff">readwrite.ff</a></code>
or copy the ff object and set <code>dim(ff)&lt;-NULL</code> to get a vector view into the ff object
(using <code>[</code> dispatches the vector method <code><a href="#topic++5B.ff">[.ff</a></code>).
To access the array elements in R standard dimorder you simply use <code>[</code> which dispatches
to <code><a href="#topic++5B.ff_array">[.ff_array</a></code>. Note that in this case <code><a href="#topic+as.hi">as.hi</a></code> will unpack the complete index, see next section.
</p>


<h3>RAM expansion of index expressions</h3>

<p>Some index expressions do not consume RAM due to the <code><a href="#topic+hi">hi</a></code> representation,
for example <code>1:n</code> will almost consume no RAM hoewever large n.
However, some index expressions are expanded and require to <code><a href="bit.html#topic+maxindex">maxindex</a>(i) * .rambytes["integer"]</code> bytes,
either because the sorted sequence of index positions cannot be rle-packed efficiently
or because <code><a href="#topic+hiparse">hiparse</a></code> cannot yet parse such expression and falls back to evaluating/expanding the index expression.
If the index positions are not sorted, the index will be expanded and a second vector is needed to store the information for re-ordering,
thus the index requires <code>2 * <a href="bit.html#topic+maxindex">maxindex</a>(i) * .rambytes["integer"]</code> bytes.
</p>


<h3>RAM expansion when recycling assigment values</h3>

<p>Some assignment expressions do not consume RAM for recycling, for example <code>x[1:n] &lt;- 1:k</code>
will not consume RAM hoewever large n compared to k, when x has standard <code><a href="#topic+dimorder">dimorder</a></code>.
However, if <code>length(value)&gt;1</code>, assignment expressions with non-ascending index positions trigger recycling the value R-side to the full index length.
This will happen if <code><a href="#topic+dimorder">dimorder</a></code> does not match parameter <code>bydim</code> or if the index is not sorted ascending.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+swap">swap</a></code>, <code><a href="#topic+add">add</a></code>, <code><a href="#topic+readwrite.ff">readwrite.ff</a></code>, <code><a href="#topic+LimWarn">LimWarn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   message("look at different dimorders")
   x &lt;- ff(1:12, dim=c(3,4), dimorder=c(1,2))
   x[]
   as.vector(x[])
   x[1:12]
   x &lt;- ff(1:12, dim=c(3,4), dimorder=c(2,1))
   x[]
   as.vector(x[])
   message("Beware (might be changed)")
   x[1:12]

   message("look at different bydim")
   matrix(1:12, nrow=3, ncol=4, byrow=FALSE)
   x &lt;- ff(1:12, dim=c(3,4), bydim=c(1,2))
   x
   matrix(1:12, nrow=3, ncol=4, byrow=TRUE)
   x &lt;- ff(1:12, dim=c(3,4), bydim=c(2,1))
   x
   x[,, bydim=c(2,1)]
   as.vector(x[,, bydim=c(2,1)])
   message("even consistent interpretation of vectors in assignments")
   x[,, bydim=c(1,2)] &lt;- x[,, bydim=c(1,2)]
   x
   x[,, bydim=c(2,1)] &lt;- x[,, bydim=c(2,1)]
   x
   rm(x); gc()

  ## Not run: 
   message("some performance implications of different dimorders")
   n &lt;- 100
   m &lt;- 100000
   a &lt;- ff(1L,dim=c(n,m))
   b &lt;- ff(1L,dim=c(n,m), dimorder=2:1)
   system.time(lapply(1:n, function(i)sum(a[i,])))
   system.time(lapply(1:n, function(i)sum(b[i,])))
   system.time(lapply(1:n, function(i){i&lt;-(i-1)*(m/n)+1; sum(a[,i:(i+m/n-1)])}))
   system.time(lapply(1:n, function(i){i&lt;-(i-1)*(m/n)+1; sum(b[,i:(i+m/n-1)])}))

   n &lt;- 100
   a &lt;- ff(1L,dim=c(n,n,n,n))
   b &lt;- ff(1L,dim=c(n,n,n,n), dimorder=4:1)
   system.time(lapply(1:n, function(i)sum(a[i,,,])))
   system.time(lapply(1:n, function(i)sum(a[,i,,])))
   system.time(lapply(1:n, function(i)sum(a[,,i,])))
   system.time(lapply(1:n, function(i)sum(a[,,,i])))
   system.time(lapply(1:n, function(i)sum(b[i,,,])))
   system.time(lapply(1:n, function(i)sum(b[,i,,])))
   system.time(lapply(1:n, function(i)sum(b[,,i,])))
   system.time(lapply(1:n, function(i)sum(b[,,,i])))

   n &lt;- 100
   m &lt;- 100000
   a &lt;- ff(1L,dim=c(n,m))
   b &lt;- ff(1L,dim=c(n,m), dimorder=2:1)
   system.time(ffrowapply(sum(a[i1:i2,]), a, RETURN=TRUE, CFUN="csum", BATCHBYTES=16104816%/%20))
   system.time(ffcolapply(sum(a[,i1:i2]), a, RETURN=TRUE, CFUN="csum", BATCHBYTES=16104816%/%20))
   system.time(ffrowapply(sum(b[i1:i2,]), b, RETURN=TRUE, CFUN="csum", BATCHBYTES=16104816%/%20))
   system.time(ffcolapply(sum(b[,i1:i2]), b, RETURN=TRUE, CFUN="csum", BATCHBYTES=16104816%/%20))

   rm(a,b); gc()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Extract.ffdf'> Reading and writing data.frames (ffdf) </h2><span id='topic+Extract.ffdf'></span><span id='topic++5B.ffdf'></span><span id='topic++5B+3C-.ffdf'></span><span id='topic++5B+5B.ffdf'></span><span id='topic++5B+5B+3C-.ffdf'></span><span id='topic++24.ffdf'></span><span id='topic++24+3C-.ffdf'></span>

<h3>Description</h3>

<p>These are the main methods for reading and writing data from ffdf objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffdf'
x[i, j, drop = ncols == 1]
## S3 replacement method for class 'ffdf'
x[i, j] &lt;- value
## S3 method for class 'ffdf'
x[[i, j, exact = TRUE]]
## S3 replacement method for class 'ffdf'
x[[i, j]] &lt;- value
## S3 method for class 'ffdf'
x$i
## S3 replacement method for class 'ffdf'
x$i &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.ffdf_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
<tr><td><code id="Extract.ffdf_+3A_i">i</code></td>
<td>
<p> a row subscript or a matrix subscript or a list subscript </p>
</td></tr>
<tr><td><code id="Extract.ffdf_+3A_j">j</code></td>
<td>
<p> a column subscript </p>
</td></tr>
<tr><td><code id="Extract.ffdf_+3A_drop">drop</code></td>
<td>
<p> logical. If TRUE the result is coerced to the lowest possible dimension. The default is to drop if only one column is left, but not to drop if only one row is left. </p>
</td></tr>
<tr><td><code id="Extract.ffdf_+3A_value">value</code></td>
<td>
<p> A suitable replacement value: it will be repeated a whole number of times if necessary and it may be coerced: see the Coercion section.  If <code>NULL</code>, deletes the column if a single column is selected with <code>[[&lt;-</code> or <code>$&lt;-</code>. </p>
</td></tr>
<tr><td><code id="Extract.ffdf_+3A_exact">exact</code></td>
<td>
<p> logical: see <code><a href="base.html#topic++5B">[</a></code>, and applies to column names. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subscript methods <code>[</code>, <code>[[</code> and <code>$</code>, behave symmetrical to the assignment functions <code>[&lt;-</code>, <code>[[&lt;-</code> and <code>$&lt;-</code>.
What the former return is the assignment value to the latter.
A notable exception is assigning <code>NULL</code> in <code>[[&lt;-</code> and <code>$&lt;-</code> which removes the <code><a href="bit.html#topic+virtual">virtual</a></code> column from the ffdf (and the <code><a href="bit.html#topic+physical">physical</a></code> component if it is no longer needed by any virtual column).
Creating new columns via <code>[[&lt;-</code> and <code>$&lt;-</code> requires giving a name to the new column (character subscripting). <code>[&lt;-</code> does not allow to create new columns, only to replace existing ones.
</p>


<h3>Subscript expressions and return values</h3>


<table>
<tr>
 <td style="text-align: right;">
  <em>allowed expression</em>    </td><td style="text-align: left;"> -- </td><td style="text-align: left;"> <em><code>example</code></em>          </td><td style="text-align: left;"> -- </td><td style="text-align: left;"> <em><code>returnvalue</code></em>                </td>
</tr>
<tr>
 <td style="text-align: right;">
   row selection  </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[i, ]</code> </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code><a href="base.html#topic+data.frame">data.frame</a></code> or single row as list if <code>drop=TRUE</code>, like from data.frame </td>
</tr>
<tr>
 <td style="text-align: right;">
   column selection  </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[ ,i]</code> </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code><a href="base.html#topic+data.frame">data.frame</a></code> or single column as vector unless <code>drop=TRUE</code>, like from data.frame  </td>
</tr>
<tr>
 <td style="text-align: right;">
   matrix selection  </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[cbind(i,j)]</code> </td><td style="text-align: left;">    </td><td style="text-align: left;"> vector of the integer-matrix indexed cells (if the column types are compatible) </td>
</tr>
<tr>
 <td style="text-align: right;">
   virtual selection </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[i]</code>   </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code><a href="#topic+ffdf">ffdf</a></code>  with the selected columns only </td>
</tr>
<tr>
 <td style="text-align: right;">
   physical selection </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x[[i]]</code> </td><td style="text-align: left;">    </td><td style="text-align: left;"> the selected <code><a href="#topic+ff">ff</a></code>            </td>
</tr>
<tr>
 <td style="text-align: right;">
   physical selection </td><td style="text-align: left;">    </td><td style="text-align: left;"> <code>x$i</code> </td><td style="text-align: left;">    </td><td style="text-align: left;"> the selected <code><a href="#topic+ff">ff</a></code>            </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ffdf">ffdf</a></code>, <code><a href="base.html#topic++5B.data.frame">Extract.data.frame</a></code>, <code><a href="#topic+Extract.ff">Extract.ff</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>   d &lt;- data.frame(a=letters, b=rev(letters), c=1:26, stringsAsFactors = TRUE)
   x &lt;- as.ffdf(d)

   d[1,]
   x[1,]

   d[1:2,]
   x[1:2,]

   d[,1]
   x[,1]

   d[,1:2]
   x[,1:2]

   d[cbind(1:2,2:1)]
   x[cbind(1:2,2:1)]

   d[1]
   x[1]

   d[[1]]
   x[[1]]

   d$a
   x$a

   d$a[1:2]
   x$a[1:2]

   rm(x); gc()
</code></pre>

<hr>
<h2 id='ff'> ff classes for representing (large) atomic data </h2><span id='topic+ff'></span><span id='topic+ff_pointer'></span>

<h3>Description</h3>

<p>The ff package provides atomic data structures that are stored on disk but behave (almost) as if they were in RAM by
mapping only a section (pagesize) into main memory (the effective main memory consumption per ff object).
Several access optimization techniques such as Hyrid Index Preprocessing (<code><a href="#topic+as.hi">as.hi</a></code>, <code><a href="#topic+update.ff">update.ff</a></code>) and Virtualization (<code><a href="#topic+physical.ff">virtual</a></code>, <code><a href="#topic+vt">vt</a></code>, <code><a href="#topic+vw">vw</a></code>) are implemented to achieve good performance even with large datasets.
In addition to the basic access functions, the ff package also provides compatibility functions that facilitate writing code for ff and ram objects (<code><a href="bit.html#topic+clone">clone</a></code>, <code><a href="#topic+as.ff">as.ff</a></code>, <code><a href="#topic+as.ram">as.ram</a></code>) and very basic support for operating on ff objects (<code><a href="#topic+ffapply">ffapply</a></code>).
While the (possibly packed) raw data is stored on a flat file, meta
informations about the atomic data structure such as its dimension,
virtual storage mode (<code><a href="#topic+vmode">vmode</a></code>), factor level encoding,
internal length etc.. are stored as an ordinary R object (external
pointer plus attributes) and can be saved in the workspace.
The raw flat file data encoding is always in native machine format for
optimal performance and provides several packing schemes for different
data types such as logical, raw, integer and double (in an extended version
support for more tighly packed virtual data types is supported).
flatfile data files can be shared among ff objects in the same R process or
even from different R processes due to Memory-Mapping, although the
caching effects have not been tested extensively.
<br />
Please do read and understand the limitations and warnings in <code><a href="#topic+LimWarn">LimWarn</a></code> before you do anything serious with package ff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff( initdata  = NULL
, length      = NULL
, levels      = NULL
, ordered     = NULL
, dim         = NULL
, dimorder    = NULL
, bydim       = NULL
, symmetric   = FALSE
, fixdiag     = NULL
, names       = NULL
, dimnames    = NULL
, ramclass    = NULL
, ramattribs  = NULL
, vmode       = NULL
, update      = NULL
, pattern     = NULL
, filename    = NULL
, overwrite   = FALSE
, readonly    = FALSE
, pagesize    = NULL  # getOption("ffpagesize")
, caching     = NULL  # getOption("ffcaching")
, finalizer   = NULL
, finonexit   = NULL  # getOption("fffinonexit")
, FF_RETURN   = TRUE
, BATCHSIZE   = .Machine$integer.max
, BATCHBYTES  = getOption("ffbatchbytes")
, VERBOSE     = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_+3A_initdata">initdata</code></td>
<td>
<p> scalar or vector of the <code><a href="#topic+.vimplemented">.vimplemented</a></code> <code><a href="#topic+vmode">vmode</a></code>s, recycled if needed, default 0, see also <code><a href="#topic+as.vmode">as.vmode</a></code> and <code><a href="#topic+vector.vmode">vector.vmode</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_length">length</code></td>
<td>
<p> optional vector <code><a href="base.html#topic+length">length</a></code> of the object (default: derive from 'initdata' or 'dim'), see <code><a href="#topic+length.ff">length.ff</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_levels">levels</code></td>
<td>
<p> optional character vector of levels if (in this case initdata must be composed of these) (default: derive from initdata) </p>
</td></tr>
<tr><td><code id="ff_+3A_ordered">ordered</code></td>
<td>
<p> indicate whether the levels are ordered (TRUE) or non-ordered factor (FALSE, default) </p>
</td></tr>
<tr><td><code id="ff_+3A_dim">dim</code></td>
<td>
<p> optional array <code><a href="base.html#topic+dim">dim</a></code>, see <code><a href="#topic+dim.ff">dim.ff</a></code> and <code><a href="base.html#topic+array">array</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_dimorder">dimorder</code></td>
<td>
<p> physical layout (default seq_along(dim)), see <code><a href="#topic+dimorder">dimorder</a></code> and <code><a href="base.html#topic+aperm">aperm</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_bydim">bydim</code></td>
<td>
<p> dimorder by which to interpret the 'initdata', generalization of the 'byrow' paramter in <code><a href="base.html#topic+matrix">matrix</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_symmetric">symmetric</code></td>
<td>
<p> extended feature: TRUE creates symmetric matrix (default FALSE) 
</p>
</td></tr>
<tr><td><code id="ff_+3A_fixdiag">fixdiag</code></td>
<td>
<p> extended feature: non-NULL scalar requires fixed diagonal for symmetric matrix (default NULL is free diagonal) </p>
</td></tr>
<tr><td><code id="ff_+3A_names">names</code></td>
<td>
<p> NOT taken from initdata, see <code><a href="base.html#topic+names">names</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_dimnames">dimnames</code></td>
<td>
<p> NOT taken from initdata, see <code><a href="base.html#topic+dimnames">dimnames</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_ramclass">ramclass</code></td>
<td>
<p> class attribute attached when moving all or parts of this ff into ram, see <code><a href="#topic+ramclass">ramclass</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_ramattribs">ramattribs</code></td>
<td>
<p> additional attributes attached when moving all or parts of this ff into ram, see <code><a href="#topic+ramattribs">ramattribs</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_vmode">vmode</code></td>
<td>
<p> virtual storage mode (default: derive from 'initdata'), see <code><a href="#topic+vmode">vmode</a></code> and <code><a href="#topic+as.vmode">as.vmode</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_update">update</code></td>
<td>
<p> set to FALSE to avoid updating with 'initdata' (default TRUE) (used by <code><a href="#topic+ffdf">ffdf</a></code>) </p>
</td></tr>
<tr><td><code id="ff_+3A_pattern">pattern</code></td>
<td>
<p> root pattern with or without path for automatic ff filename creation (default NULL translates to &quot;ff&quot;), see also argument 'filename' </p>
</td></tr>
<tr><td><code id="ff_+3A_filename">filename</code></td>
<td>
<p> ff <code><a href="#topic+filename">filename</a></code> with or without path (default tmpfile with 'pattern' prefix); without path the file is created in <code>getOption("fftempdir")</code>, with path '.' the file is created in <code><a href="base.html#topic+getwd">getwd</a></code>. Note that files created in <code>getOption("fftempdir")</code> have default finalizer &quot;delete&quot; while other files have default finalizer &quot;close&quot;. See also arguments 'pattern' and 'finalizer' and <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_overwrite">overwrite</code></td>
<td>
<p> set to TRUE to allow overwriting existing files (default FALSE) </p>
</td></tr>
<tr><td><code id="ff_+3A_readonly">readonly</code></td>
<td>
<p> set to TRUE to forbid writing to existing files </p>
</td></tr>
<tr><td><code id="ff_+3A_pagesize">pagesize</code></td>
<td>
<p> pagesize in bytes for the memory mapping (default from <code>getOptions("ffpagesize")</code> initialized by <code><a href="#topic+getdefaultpagesize">getdefaultpagesize</a></code>), see also <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_caching">caching</code></td>
<td>
<p> caching scheme for the backend, currently 'mmnoflush' or 'mmeachflush' (flush mmpages at each swap, default from <code>getOptions("ffcaching")</code> initialized with 'mmeachflush'), see also <code><a href="#topic+physical.ff">physical</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_finalizer">finalizer</code></td>
<td>
<p> name of finalizer function called when ff object is <code><a href="base.html#topic+remove">remove</a>d</code> (default: ff files created in <code>getOptions("fftempdir")</code> are considered temporary and have default finalizer <code><a href="#topic+delete.ff">delete</a></code>, files created in other locations have default finalizer <code><a href="#topic+close.ff">close</a></code>); available finalizer generics are &quot;close&quot;, &quot;delete&quot; and &quot;deleteIfOpen&quot;, available methods are <code><a href="#topic+close.ff">close.ff</a></code>, <code><a href="#topic+delete.ff">delete.ff</a></code> and <code><a href="#topic+deleteIfOpen.ff">deleteIfOpen.ff</a></code>, see also argument 'finonexit' and <code><a href="#topic+finalizer">finalizer</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_finonexit">finonexit</code></td>
<td>
<p> logical scalar determining whether  and <code><a href="#topic+finalize">finalize</a></code> is also called when R is closed via <code><a href="base.html#topic+q">q</a></code>, (default TRUE from <code>getOptions("fffinonexit")</code>) </p>
</td></tr>
<tr><td><code id="ff_+3A_ff_return">FF_RETURN</code></td>
<td>
<p> logical scalar or ff object to be used. The default TRUE creates a new ff file. FALSE returns a ram object. Handing over an ff object here uses this or stops if not <code><a href="#topic+ffsuitable">ffsuitable</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_batchsize">BATCHSIZE</code></td>
<td>
<p> integer scalar limiting the number of elements to be processed in <code><a href="#topic+update.ff">update.ff</a></code> when length(initdata)&gt;1, default from <code>.Machine$integer.max</code> </p>
</td></tr>
<tr><td><code id="ff_+3A_batchbytes">BATCHBYTES</code></td>
<td>
<p> integer scalar limiting the number of bytes to be processed in <code><a href="#topic+update.ff">update.ff</a></code> when length(initdata)&gt;1, default from <code>getOption("ffbatchbytes")</code>, see also <code><a href="#topic+.rambytes">.rambytes</a></code> </p>
</td></tr>
<tr><td><code id="ff_+3A_verbose">VERBOSE</code></td>
<td>
<p> set to TRUE for verbosing in <code><a href="#topic+update.ff">update.ff</a></code> when length(initdata)&gt;1, default FALSE </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The atomic data is stored in <code><a href="#topic+filename">filename</a></code> as a native encoded raw flat file on disk, OS specific limitations of the file system apply.
The number of elements per ff object is limited to the integer indexing, i.e. <code><a href="base.html#topic+.Machine">.Machine</a>$integer.max</code>.
Atomic objects created with <code>ff</code> are <code><a href="#topic+is.open">is.open</a></code>, a C++ object is ready to access the file via memory-mapping.
Currently the C++ backend provides two caching schemes: 'mmnoflush' let the OS decide when to flash memory mapped pages
and 'mmeachflush' will flush memory mapped pages at each page swap per ff file.
These minimal memory ressources can be released by <code><a href="#topic+close.ff">close</a>ing</code> or <code><a href="#topic+delete.ff">delete</a>ing</code> the ff file.
ff objects can be <code><a href="base.html#topic+save">save</a>d</code> and <code><a href="base.html#topic+load">load</a>ed</code> across R sessions. If the ff file still exists in the same location,
it will be <code><a href="#topic+open.ff">open</a>ed</code> automatically at the first attempt to access its data. If the ff object is <code><a href="base.html#topic+remove">remove</a>d</code>,
at the next garbage collection (see <code><a href="base.html#topic+gc">gc</a></code>) the ff object's <code><a href="#topic+finalizer">finalizer</a></code> is invoked.
Raw data files can be made accessible as an ff object by explicitly given the filename and vmode but no size information (length or dim).
The ff object will open the file and handle the data with respect to the given vmode.
The <code><a href="#topic+close.ff">close</a></code> finalizer will close the ff file, the <code><a href="#topic+delete.ff">delete</a></code> finalizer will delete the ff file.
The default finalizer <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code> will delete open files and do nothing for closed files. If the default finalizer is used,
two actions are needed to protect the ff file against deletion: create the file outside the standard 'fftempdir' and close the ff object before removing it or before quitting R.
When R is exited through <code><a href="base.html#topic+q">q</a></code>, the finalizer will be invoked depending on the 'fffinonexit' option, furthermore the 'fftempdir' is <code><a href="base.html#topic+unlink">unlink</a>ed</code>. <br />
</p>


<h3>Value</h3>

<p>If (<code>!FF_RETURN</code>) then a ram object like those generated by <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="base.html#topic+array">array</a></code> but with attributes 'vmode', 'physical' and 'virtual' accessible via <code><a href="#topic+vmode">vmode</a></code>, <code><a href="#topic+physical.ff">physical</a></code> and <code><a href="#topic+physical.ff">virtual</a></code>  <br />
If (<code>FF_RETURN</code>) an object of class 'ff' which is a a list with two components:
</p>
<table>
<tr><td><code>physical</code></td>
<td>
<p>an external pointer of class '<code>ff_pointer</code>' which carries attributes with copy by reference semantics: changing a physical attribute of a copy changes the original </p>
</td></tr>
<tr><td><code>virtual</code></td>
<td>
<p>an empty list which carries attributes with copy by value semantics: changing a virtual attribute of a copy does not change the original </p>
</td></tr>
</table>


<h3>Physical object component</h3>

<p>The '<code>ff_pointer</code>' carries the following 'physical' or readonly attributes, which are accessible via <code><a href="#topic+physical.ff">physical</a></code>:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>vmode    </code> </td><td style="text-align: left;"> see <code><a href="#topic+vmode">vmode</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>maxlength</code> </td><td style="text-align: left;"> see <code><a href="#topic+maxlength">maxlength</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>pattern  </code> </td><td style="text-align: left;"> see parameter 'pattern' </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>filename </code> </td><td style="text-align: left;"> see <code><a href="#topic+filename">filename</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>pagesize </code> </td><td style="text-align: left;"> see parameter 'pagesize' </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>caching  </code> </td><td style="text-align: left;"> see parameter 'caching' </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>finalizer</code> </td><td style="text-align: left;"> see parameter 'finalizer' </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>finonexit</code> </td><td style="text-align: left;"> see parameter 'finonexit' </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>readonly </code> </td><td style="text-align: left;"> see <code><a href="#topic+is.readonly">is.readonly</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>class    </code> </td><td style="text-align: left;"> The external pointer needs class 'ff_pointer' to allow method dispatch of finalizers  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Virtual object component</h3>

<p>The 'virtual' component carries the following attributes (some of which might be NULL):
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>Length    </code> </td><td style="text-align: left;"> see <code><a href="#topic+length.ff">length.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Levels    </code> </td><td style="text-align: left;"> see <code><a href="#topic+levels.ff">levels.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Names     </code> </td><td style="text-align: left;"> see <code><a href="#topic+names.ff">names.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>VW        </code> </td><td style="text-align: left;"> see <code><a href="#topic+vw.ff">vw.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Dim       </code> </td><td style="text-align: left;"> see <code><a href="#topic+dim.ff">dim.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Dimorder  </code> </td><td style="text-align: left;"> see <code><a href="#topic+dimorder">dimorder</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Symmetric </code> </td><td style="text-align: left;"> see <code><a href="#topic+symmetric.ff">symmetric.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>Fixdiag   </code> </td><td style="text-align: left;"> see <code><a href="#topic+fixdiag.ff">fixdiag.ff</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ramclass  </code> </td><td style="text-align: left;"> see <code><a href="#topic+ramclass">ramclass</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ramattribs</code> </td><td style="text-align: left;"> see <code><a href="#topic+ramattribs">ramattribs</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Class</h3>

<p>You should not rely on the internal structure of ff objects or their ram versions. Instead use the accessor functions like <code><a href="#topic+vmode">vmode</a></code>, <code><a href="#topic+physical.ff">physical</a></code> and <code><a href="#topic+physical.ff">virtual</a></code>.
Still it would be wise to avoid attributes AND classes 'vmode', 'physical' and 'virtual' in any other packages.
Note that the 'ff' object's class attribute also has copy-by-value semantics ('virtual').
For the 'ff' object the following class attritibutes are known:
</p>

<table>
<tr>
 <td style="text-align: right;">
  vector </td><td style="text-align: left;"> <code>c("ff_vector","ff")</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  matrix </td><td style="text-align: left;"> <code>c("ff_matrix","ff_array","ff")</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  array </td><td style="text-align: left;"> <code>c("ff_array","ff")</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  symmetric matrix </td><td style="text-align: left;"> <code>c("ff_symm","ff")</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  distance matrix </td><td style="text-align: left;"> <code>c("ff_dist","ff_symm","ff")</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  reserved for future use </td><td style="text-align: left;"> <code>c("ff_mixed","ff")</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Methods</h3>

<p>The following methods and functions are available for ff objects:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <em> Type</em> </td><td style="text-align: right;">  <em> Name </em>  </td><td style="text-align: left;"> <em> Assign </em>  </td><td style="text-align: left;"> <em>Comment</em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Basic functions</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+ff">ff</a></code>                         </td><td style="text-align: left;">   </td><td style="text-align: left;"> constructor for ff and ram objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+update.ff">update</a></code>       </td><td style="text-align: left;">   </td><td style="text-align: left;"> updates one ff object with the content of another </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="bit.html#topic+clone">clone</a></code>                      </td><td style="text-align: left;">   </td><td style="text-align: left;"> clones an ff object optionally changing some of its features </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+print.ff">print</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> print ff </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+str.ff">str</a></code>             </td><td style="text-align: left;">   </td><td style="text-align: left;"> ff object structure </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Class test and coercion</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+is.ff">is.ff</a></code>                      </td><td style="text-align: left;">   </td><td style="text-align: left;"> check if inherits from ff </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+as.ff">as.ff</a></code>                      </td><td style="text-align: left;">   </td><td style="text-align: left;"> coerce to ff, if not yet </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+as.ram">as.ram</a></code>                     </td><td style="text-align: left;">   </td><td style="text-align: left;"> coerce to ram retaining some of the ff information </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+as.bit.ff">as.bit</a></code>          </td><td style="text-align: left;">   </td><td style="text-align: left;"> coerce to <code><a href="bit.html#topic+bit">bit</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Virtual storage mode</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+vmode">vmode</a></code>                      </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> get and set virtual mode (setting only for ram, not for ff objects) </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+as.vmode">as.vmode</a></code>                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> coerce to vmode (only for ram, not for ff objects) </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Physical attributes</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+physical.ff">physical</a></code>                   </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get physical attributes </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+filename">filename</a></code>                   </td><td style="text-align: left;"> <em>&lt;-</em>  </td><td style="text-align: left;"> get and set filename </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+pattern">pattern</a></code>                    </td><td style="text-align: left;"> <em>&lt;-</em>  </td><td style="text-align: left;"> get pattern and set filename path and prefix via pattern </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+maxlength">maxlength</a></code>                  </td><td style="text-align: left;">   </td><td style="text-align: left;"> get maxlength </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="bit.html#topic+is.sorted">is.sorted</a></code>                  </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get if is marked as sorted </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="bit.html#topic+na.count">na.count</a></code>                   </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get NA count, if set to non-NA only swap methods can change and na.count is maintained automatically </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+is.readonly">is.readonly</a></code>                </td><td style="text-align: left;">    </td><td style="text-align: left;"> get if is readonly </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">    </td><td style="text-align: left;"> <b>Virtual attributes</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+physical.ff">virtual</a></code>                    </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get virtual attributes </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+length.ff">length</a></code>       </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get length </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+dim.ff">dim</a></code>             </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get dim </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+dimorder">dimorder</a></code>                   </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get the order of dimension interpretation </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+vt">vt</a></code>                         </td><td style="text-align: left;">    </td><td style="text-align: left;"> virtually transpose ff_array </td>
</tr>
<tr>
 <td style="text-align: left;">
  method  </td><td style="text-align: right;">   <code><a href="#topic+t.ff">t</a></code>                 </td><td style="text-align: left;">    </td><td style="text-align: left;"> create transposed clone of ff_array </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+vw">vw</a></code>                         </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get virtual windows </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+names.ff">names</a></code>         </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get names </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+dimnames.ff">dimnames</a></code>   </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get dimnames </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+symmetric">symmetric</a></code>                  </td><td style="text-align: left;">    </td><td style="text-align: left;"> get if is symmetric </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+fixdiag">fixdiag</a></code>                    </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get fixed diagonal of symmetric matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="base.html#topic+levels">levels</a></code>                     </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> levels of factor  </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+recodeLevels">recodeLevels</a></code>               </td><td style="text-align: left;">   </td><td style="text-align: left;"> recode a factor to different levels </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+sortLevels">sortLevels</a></code>                 </td><td style="text-align: left;">   </td><td style="text-align: left;"> sort the levels and recoce a factor </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+is.factor">is.factor</a></code>                  </td><td style="text-align: left;">   </td><td style="text-align: left;"> if is factor </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+is.ordered">is.ordered</a></code>                 </td><td style="text-align: left;">   </td><td style="text-align: left;"> if is ordered (factor) </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+ramclass">ramclass</a></code>                   </td><td style="text-align: left;">    </td><td style="text-align: left;"> get ramclass </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+ramattribs">ramattribs</a></code>                 </td><td style="text-align: left;">    </td><td style="text-align: left;"> get ramattribs </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Access functions</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+get.ff">get.ff</a></code>                     </td><td style="text-align: left;">   </td><td style="text-align: left;"> get single ff element (currently <code><a href="#topic+Extract.ff">[[</a></code> is a shortcut) </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+set.ff">set.ff</a></code>                     </td><td style="text-align: left;">   </td><td style="text-align: left;"> set single ff element (currently <code><a href="#topic+Extract.ff">[[&lt;-</a></code> is a shortcut) </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+getset.ff">getset.ff</a></code>                  </td><td style="text-align: left;">   </td><td style="text-align: left;"> set single ff element and get old value in one access operation </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+read.ff">read.ff</a></code>                    </td><td style="text-align: left;">   </td><td style="text-align: left;"> get vector of contiguous elements </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+write.ff">write.ff</a></code>                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> set vector of contiguous elements  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+readwrite.ff">readwrite.ff</a></code>               </td><td style="text-align: left;">   </td><td style="text-align: left;"> set vector of contiguous elements and get old values in one access operation </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+Extract.ff">[</a></code>                 </td><td style="text-align: left;">   </td><td style="text-align: left;"> get vector of indexed elements, uses HIP, see <code><a href="#topic+hi">hi</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+Extract.ff">[&lt;-</a></code>             </td><td style="text-align: left;">   </td><td style="text-align: left;"> set vector of indexed elements, uses HIP, see <code><a href="#topic+hi">hi</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+swap.ff">swap</a></code>           </td><td style="text-align: left;">   </td><td style="text-align: left;"> set vector of indexed elements and get old values in one access operation </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+add.ff">add</a></code>             </td><td style="text-align: left;">   </td><td style="text-align: left;"> (almost) unifies '+=' operation for ff and ram objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+bigsample.ff">bigsample</a></code> </td><td style="text-align: left;">   </td><td style="text-align: left;"> sample from ff object </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Opening/Closing/Deleting</b>                                             </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+is.open">is.open</a></code>                    </td><td style="text-align: left;">   </td><td style="text-align: left;"> check if ff is open </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+open.ff">open</a></code>           </td><td style="text-align: left;">   </td><td style="text-align: left;"> open ff object (is done automatically on access) </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+close.ff">close</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> close ff object (releases C++ memory and protects against file deletion if  <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code>) finalizer is used </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+delete.ff">delete</a></code>       </td><td style="text-align: left;">   </td><td style="text-align: left;"> deletes ff file (unconditionally) </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code>               </td><td style="text-align: left;">   </td><td style="text-align: left;"> deletes ff file if ff object is open (finalization method) </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+finalizer">finalizer</a></code>                  </td><td style="text-align: left;"> <em>&lt;-</em> </td><td style="text-align: left;"> get and set finalizer </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+finalize">finalize</a></code>                   </td><td style="text-align: left;">    </td><td style="text-align: left;"> force finalization </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Other</b>                                                     </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+geterror.ff">geterror.ff</a></code>                </td><td style="text-align: left;">   </td><td style="text-align: left;"> get error code </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+geterrstr.ff">geterrstr.ff</a></code>               </td><td style="text-align: left;">   </td><td style="text-align: left;"> get error message </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>ff options</h3>

<p>Through <code><a href="base.html#topic+options">options</a></code> or <code><a href="base.html#topic+getOption">getOption</a></code> one can change and query global features of the ff package:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <em>option</em>        </td><td style="text-align: left;"> <em>description</em>                           </td><td style="text-align: left;"> <em>default</em> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>fftempdir</code>     </td><td style="text-align: left;"> default directory for creating ff files      </td><td style="text-align: left;"> <code><a href="base.html#topic+tempdir">tempdir</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>fffinalizer</code>   </td><td style="text-align: left;"> name of default finalizer                    </td><td style="text-align: left;"> <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>fffinonexit</code>   </td><td style="text-align: left;"> default for invoking finalizer on exit of R  </td><td style="text-align: left;"> <code>TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ffpagesize</code>    </td><td style="text-align: left;"> default pagesize                             </td><td style="text-align: left;"> <code><a href="#topic+getdefaultpagesize">getdefaultpagesize</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ffcaching</code>     </td><td style="text-align: left;"> caching scheme for the C++ backend           </td><td style="text-align: left;"> <code>'mmnoflush'</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ffdrop</code>        </td><td style="text-align: left;"> default for the <span class="option">drop</span> parameter in the ff subscript methods  </td><td style="text-align: left;"> TRUE </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ffbatchbytes</code>  </td><td style="text-align: left;"> default for the byte limit in batched/chunked processing             </td><td style="text-align: left;"> 16MB </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>OS specific</h3>

<p>The following table gives an overview of file size limits for common file systems (see <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems">https://en.wikipedia.org/wiki/Comparison_of_file_systems</a> for further details):
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>File System</strong> </td><td style="text-align: left;"> <strong>File size limit</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
  FAT16              </td><td style="text-align: left;"> 2GB </td>
</tr>
<tr>
 <td style="text-align: left;">
  FAT32              </td><td style="text-align: left;"> 4GB </td>
</tr>
<tr>
 <td style="text-align: left;">
  NTFS               </td><td style="text-align: left;"> 16GB </td>
</tr>
<tr>
 <td style="text-align: left;">
  ext2/3/4           </td><td style="text-align: left;"> 16GB to 2TB </td>
</tr>
<tr>
 <td style="text-align: left;">
  ReiserFS           </td><td style="text-align: left;"> 4GB (up to version 3.4) / 8TB (from version 3.5) </td>
</tr>
<tr>
 <td style="text-align: left;">
  XFS                </td><td style="text-align: left;"> 8EB </td>
</tr>
<tr>
 <td style="text-align: left;">
  JFS                </td><td style="text-align: left;"> 4PB </td>
</tr>
<tr>
 <td style="text-align: left;">
  HFS                </td><td style="text-align: left;"> 2GB </td>
</tr>
<tr>
 <td style="text-align: left;">
  HFS Plus           </td><td style="text-align: left;"> 16GB </td>
</tr>
<tr>
 <td style="text-align: left;">
  USF1               </td><td style="text-align: left;"> 4GB to 256TB </td>
</tr>
<tr>
 <td style="text-align: left;">
  USF2               </td><td style="text-align: left;"> 512GB to 32PB </td>
</tr>
<tr>
 <td style="text-align: left;">
  UDF                </td><td style="text-align: left;"> 16EB </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Credits</h3>

<p>Package Version 1.0
</p>

<table>
<tr>
 <td style="text-align: left;">
  Daniel Adler       </td><td style="text-align: left;"> <a href="mailto:dadler@uni-goettingen.de">dadler@uni-goettingen.de</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> R package design, C++ generic file vectors, Memory-Mapping, 64-bit Multi-Indexing adapter and Documentation, Platform ports </td>
</tr>
<tr>
 <td style="text-align: left;">
  Oleg Nenadic       </td><td style="text-align: left;"> <a href="mailto:onenadi@uni-goettingen.de">onenadi@uni-goettingen.de</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> Index sequence packing, Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
  Walter Zucchini    </td><td style="text-align: left;"> <a href="mailto:wzucchi@uni-goettingen.de">wzucchi@uni-goettingen.de</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> Array Indexing, Sampling, Documentation </td>
</tr>
<tr>
 <td style="text-align: left;">
  Christian Gläser   </td><td style="text-align: left;"> 	<a href="mailto:christian_glaeser@gmx.de">christian_glaeser@gmx.de</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> Wrapper for biglm package </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Package Version 2.0
</p>

<table>
<tr>
 <td style="text-align: left;">
  Jens Oehlschlägel  </td><td style="text-align: left;"> <a href="mailto:Jens.Oehlschlaegel@truecluster.com">Jens.Oehlschlaegel@truecluster.com</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> R package redesign; Hybrid Index Preprocessing; transparent object creation and finalization; vmode design; virtualization and hybrid copying; arrays with dimorder and bydim; symmetric matrices; factors and POSIXct; virtual windows and transpose; new generics update, clone, swap, add, as.ff and as.ram; ffapply and collapsing functions. R-coding, C-coding and Rd-documentation. </td>
</tr>
<tr>
 <td style="text-align: left;">
  Daniel Adler       </td><td style="text-align: left;"> <a href="mailto:dadler@uni-goettingen.de">dadler@uni-goettingen.de</a> </td>
</tr>
<tr>
 <td style="text-align: left;">
                     </td><td style="text-align: left;"> C++ generic file vectors, vmode implementation and low-level bit-packing/unpacking, arithmetic operations and NA handling, Memory-Mapping and backend caching. C++ coding and platform ports. R-code extensions for opening existing flat files readonly and shared. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Licence</h3>

<p>Package under GPL-2, included C++ code released by Daniel Adler under the less restrictive ISCL</p>


<h3>Note</h3>

<p> Note that the standard finalizers are generic functions, their dispatch to the '<code>ff_pointer</code>' method happens at finalization time, their 'ff' methods exist for direct calling.
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+vector">vector</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="base.html#topic+array">array</a></code>, <code><a href="#topic+as.ff">as.ff</a></code>, <code><a href="#topic+as.ram">as.ram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  message("make sure you understand the following ff options 
    before you start using the ff package!!")
  oldoptions &lt;- options(fffinalizer="deleteIfOpen", fffinonexit="TRUE", fftempdir=tempdir())
  message("an integer vector")
  ff(1:12)                  
  message("a double vector of length 12")
  ff(0, 12)
  message("a 2-bit logical vector of length 12 (vmode='boolean' has 1 bit)")
  ff(vmode="logical", length=12)
  message("an integer matrix 3x4 (standard colwise physical layout)")
  ff(1:12, dim=c(3,4))
  message("an integer matrix 3x4 (rowwise physical layout, but filled in standard colwise order)")
  ff(1:12, dim=c(3,4), dimorder=c(2,1))
  message("an integer matrix 3x4 (standard colwise physical layout, but filled in rowwise order
aka matrix(, byrow=TRUE))")
  ff(1:12, dim=c(3,4), bydim=c(2,1))
  gc()
  options(oldoptions)

  if (ffxtensions()){
     message("a 26-dimensional boolean array using 1-bit representation
      (file size 8 MB compared to 256 MB int in ram)")
     a &lt;- ff(vmode="boolean", dim=rep(2, 26))
     dimnames(a) &lt;- dummy.dimnames(a)
     rm(a); gc()
  }

  ## Not run: 

     message("This 2GB biglm example can take long, you might want to change
       the size in order to define a size appropriate for your computer")
     require(biglm)

     b &lt;- 1000
     n &lt;- 100000
     k &lt;- 3
     memory.size(max = TRUE)
     system.time(
     x &lt;- ff(vmode="double", dim=c(b*n,k), dimnames=list(NULL, LETTERS[1:k]))
     )
     memory.size(max = TRUE)
     system.time(
     ffrowapply({
        l &lt;- i2 - i1 + 1
        z &lt;- rnorm(l)
        x[i1:i2,] &lt;- z + matrix(rnorm(l*k), l, k)
     }, X=x, VERBOSE=TRUE, BATCHSIZE=n)
     )
     memory.size(max = TRUE)

     form &lt;- A ~ B + C
     first &lt;- TRUE
     system.time(
     ffrowapply({
        if (first){
          first &lt;- FALSE
          fit &lt;- biglm(form, as.data.frame(x[i1:i2,,drop=FALSE], stringsAsFactors = TRUE))
        }else
          fit &lt;- update(fit, as.data.frame(x[i1:i2,,drop=FALSE], stringsAsFactors = TRUE))
     }, X=x, VERBOSE=TRUE, BATCHSIZE=n)
     )
     memory.size(max = TRUE)
     first
     fit
     summary(fit)
     rm(x); gc()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='ffapply'> Apply for ff objects </h2><span id='topic+ffapply'></span><span id='topic+ffvecapply'></span><span id='topic+ffrowapply'></span><span id='topic+ffcolapply'></span>

<h3>Description</h3>

<p>The <code>ffapply</code> functions support convenient batched processing of ff objects
such that each single batch or chunk will not exhaust RAM
and such that batchs have sizes as similar as possible, see <code><a href="bit.html#topic+bbatch">bbatch</a></code>.
Differing from R's standard <code><a href="base.html#topic+apply">apply</a></code> which applies a <code>FUNction</code>,
the <code>ffapply</code> functions do apply an <code>EXPRession</code> and provide two indices <code>FROM="i1"</code> and <code>TO="i2"</code>,
which mark beginning and end of the batch and can be used in the applied expression.
Note that the ffapply functions change the two indices in their parent frame, to avoid conflicts you can use different names through <code>FROM="i1"</code> and <code>TO="i2"</code>.
For support of creating return values see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffvecapply(EXPR, X = NULL, N = NULL, VMODE = NULL, VBYTES = NULL, RETURN = FALSE
, CFUN = NULL, USE.NAMES = TRUE, FF_RETURN = TRUE, BREAK = ".break"
, FROM = "i1", TO = "i2"
, BATCHSIZE = .Machine$integer.max, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE)
ffrowapply(EXPR, X = NULL, N = NULL, NCOL = NULL, VMODE = NULL, VBYTES = NULL
, RETURN = FALSE, RETCOL = NCOL, CFUN = NULL, USE.NAMES = TRUE, FF_RETURN = TRUE
, FROM = "i1", TO = "i2"
, BATCHSIZE = .Machine$integer.max, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE)
ffcolapply(EXPR, X = NULL, N = NULL, NROW = NULL, VMODE = NULL, VBYTES = NULL
, RETURN = FALSE, RETROW = NROW, CFUN = NULL, USE.NAMES = TRUE, FF_RETURN = TRUE
, FROM = "i1", TO = "i2"
, BATCHSIZE = .Machine$integer.max, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE)
ffapply(EXPR = NULL, AFUN = NULL, MARGIN = NULL, X = NULL, N = NULL, DIM = NULL
, VMODE = NULL, VBYTES = NULL, RETURN = FALSE, CFUN = NULL, USE.NAMES = TRUE
, FF_RETURN = TRUE, IDIM = "idim"
, FROM = "i1", TO = "i2", BREAK = ".break"
, BATCHSIZE = .Machine$integer.max, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffapply_+3A_expr">EXPR</code></td>
<td>
<p> the <code><a href="base.html#topic+expression">expression</a></code> to be applied </p>
</td></tr>
<tr><td><code id="ffapply_+3A_afun">AFUN</code></td>
<td>
 <p><code>ffapply</code> only: alternatively to <code>EXPR</code> the name of a function to be applied, automatically converted to <code>EXPR</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_margin">MARGIN</code></td>
<td>
 <p><code>ffapply</code> only: the margins along which to loop in <code>ffapply</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_x">X</code></td>
<td>
<p> an ff object from which several parameters can be derived, if they are not given directly: <code>N, NCOL, NROW, DIM, VMODE, VBYTES, FF_RETURN</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_n">N</code></td>
<td>
<p> the total number of elements in the loop, e.g. number of elements in <code>ffvecapply</code> or number of rows in <code>ffrowapply</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_ncol">NCOL</code></td>
<td>
 <p><code>ffrowapply</code> only: the number of columns needed to calculate batch sizes </p>
</td></tr>
<tr><td><code id="ffapply_+3A_nrow">NROW</code></td>
<td>
 <p><code>ffcolapply</code> only: the number of rows needed to calculate batch sizes </p>
</td></tr>
<tr><td><code id="ffapply_+3A_dim">DIM</code></td>
<td>
 <p><code>ffapply</code> only: the dimension of the array needed to calculate batch sizes </p>
</td></tr>
<tr><td><code id="ffapply_+3A_vmode">VMODE</code></td>
<td>
<p> the <code><a href="#topic+vmode">vmode</a></code> needed to prepare the <code>RETURN</code> object and to derive <code>VBYTES</code> if they are not given directly </p>
</td></tr>
<tr><td><code id="ffapply_+3A_vbytes">VBYTES</code></td>
<td>
<p> the bytes per cell &ndash; see <code><a href="#topic+.rambytes">.rambytes</a></code> &ndash; to calculate the RAM requirements per cell </p>
</td></tr>
<tr><td><code id="ffapply_+3A_batchbytes">BATCHBYTES</code></td>
<td>
<p> the max number of bytes per batch, default <code>getOption("ffbatchbytes")</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_batchsize">BATCHSIZE</code></td>
<td>
<p> an additional restriction on the number of loop elements, default=<code>.Machine$integer.max</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_from">FROM</code></td>
<td>
<p> the name of the index that marks the beginning of the batch, default 'i1', change if needed to avoid naming-conflicts in the calling frame </p>
</td></tr>
<tr><td><code id="ffapply_+3A_to">TO</code></td>
<td>
<p> the name of the index that marks the end of the batch, default 'i2', change if needed to avoid naming-conflicts in the calling frame </p>
</td></tr>
<tr><td><code id="ffapply_+3A_idim">IDIM</code></td>
<td>
 <p><code>ffapply</code> only: the name of an R variable used for loop-switching, change if needed to avoid naming-conflicts in the calling frame </p>
</td></tr>
<tr><td><code id="ffapply_+3A_break">BREAK</code></td>
<td>
 <p><code>ffapply</code> only: the name of an R object in the calling frame that triggers break out of the batch loop, if 1) it exists 2) is.logical and 3) is TRUE </p>
</td></tr>
<tr><td><code id="ffapply_+3A_return">RETURN</code></td>
<td>
 <p><code>TRUE</code> to prepare a return value (default <code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="ffapply_+3A_cfun">CFUN</code></td>
<td>
<p> name of a collapsing function, see <code><a href="#topic+CFUN">CFUN</a></code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_retcol">RETCOL</code></td>
<td>
 <p><code>NULL</code> gives return <code>vector[1:N]</code>, <code>RETCOL</code> gives return <code>matrix[1:N, 1:RETCOL]</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_retrow">RETROW</code></td>
<td>
 <p><code>NULL</code> gives return <code>vector[1:N]</code>, <code>RETROW</code> gives return <code>matrix[1:RETROW, 1:N]</code> </p>
</td></tr>
<tr><td><code id="ffapply_+3A_ff_return">FF_RETURN</code></td>
<td>
 <p><code>FALSE</code> to return a ram object, <code>TRUE</code> to return an ff object, or an ff object that is <code><a href="#topic+ffsuitable">ffsuitable</a></code> to absorb the return data </p>
</td></tr>
<tr><td><code id="ffapply_+3A_use.names">USE.NAMES</code></td>
<td>
 <p><code>FALSE</code> to suppress attaching names or dimnames to the result </p>
</td></tr>
<tr><td><code id="ffapply_+3A_verbose">VERBOSE</code></td>
<td>
 <p><code>TRUE</code> to verbose the batches </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ffvecapply</code> is the simplest ffapply method for <code>ff_vectors</code>. <code>ffrowapply</code> and <code>ffcolapply</code> is for <code>ff_matrix</code>,
and <code>ffapply</code> is the most general method for <code>ff_array</code>s and <code>ff_vector</code>s.
<br />
There are many ways to change the return value of the ffapply functions.
In its simplest usage &ndash; batched looping over an expression &ndash; they don't return anything, see <code><a href="base.html#topic+invisible">invisible</a></code>.
If you switch <code>RETURN=TRUE</code> in <code>ffvecapply</code> then it is assumed that all looped expressions together return one vector of length <code>N</code>,
and via parameter <code>FF_RETURN</code>, you can decide whether this vector is in ram or is an ff object (or even which ff object to use).
<code>ffrowapply</code> and <code>ffcolapply</code> additionally have parameter <code>RETCOL</code> resp. <code>RETROW</code> which defaults to returning a matrix of the original size;
in order to just return a vector of length <code>N</code> set this to <code>NULL</code>, or specify a number of columns/rows for the return matrix.
It is assumed that the expression will return appropriate pieces for this return structure (see examples).
If you specify <code>RETURN=TRUE</code> and a collapsing function name <code>CFUN</code>, then it is assumed that the batched expressions return aggregated information,
which is first collected in a list, and finally the collapsing function is called on this list: <code>do.call(CFUN, list)</code>. If you want to return the unmodified list,
you have to specify <code>CFUN="list"</code> for obvious reasons.
<br />
<code>ffapply</code> allows usages not completly unlike <code><a href="base.html#topic+apply">apply</a></code>: you can specify the name of a function <code>AFUN</code> to be applied over <code>MARGIN</code>.
However note that you must specify <code>RETURN=TRUE</code> in order to get a return value.
Also note that currently ffapply assumes that your expression returns exactly one value per cell in <code>DIM[MARGINS]</code>.
If you want to return something more complicated, you MUST specify a <code>CFUN="list"</code> and your return value will be a list with dim attribute <code>DIM[MARGINS]</code>.
This means that for a function <code>AFUN</code> returning a scalar, <code>ffapply</code> behaves very similar to <code><a href="base.html#topic+apply">apply</a></code>, see examples.
Note also that <code>ffapply</code> might create a object named '.ffapply.dimexhausted' in its parent frame,
and it uses a variable in the parent frame for loop-switching between dimensions, the default name 'idim' can be changed using the <code>IDIM</code> parameter.
Finally you can break out of the implied loops by assigning <code>TRUE</code> to a variable with the name in <code>BREAK</code>.
</p>


<h3>Value</h3>

<p>see details
</p>


<h3>Note</h3>

<p> xx The complete generation of the return value is preliminary and the arguments related to defining the return value might still change, especially ffapply is work in progress </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+apply">apply</a></code>, <code><a href="base.html#topic+expression">expression</a></code>, <code><a href="bit.html#topic+bbatch">bbatch</a></code>, <code><a href="bit.html#topic+repfromto">repfromto</a></code>, <code><a href="#topic+ffsuitable">ffsuitable</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   message("ffvecapply examples")
   x &lt;- ff(vmode="integer", length=100)
   message("loop evaluate expression without returning anything")
   ffvecapply(x[i1:i2] &lt;- i1:i2, X=x, VERBOSE=TRUE)
   ffvecapply(x[i1:i2] &lt;- i1:i2, X=x, BATCHSIZE=20, VERBOSE=TRUE)
   ffvecapply(x[i1:i2] &lt;- i1:i2, X=x, BATCHSIZE=19, VERBOSE=TRUE)
   message("lets return the combined expressions as a new ff object")
   ffvecapply(i1:i2, N=length(x), VMODE="integer", RETURN=TRUE, BATCHSIZE=20)
   message("lets return the combined expressions as a new ram object")
   ffvecapply(i1:i2, N=length(x), VMODE="integer", RETURN=TRUE, FF_RETURN=FALSE, BATCHSIZE=20)
   message("lets return the combined expressions in existing ff object x")
   x[] &lt;- 0L
   ffvecapply(i1:i2, N=length(x), VMODE="integer", RETURN=TRUE, FF_RETURN=x, BATCHSIZE=20)
   x
   message("aggregate and collapse")
   ffvecapply(summary(x[i1:i2]), X=x, RETURN=TRUE, CFUN="list", BATCHSIZE=20)
   ffvecapply(summary(x[i1:i2]), X=x, RETURN=TRUE, CFUN="crbind", BATCHSIZE=20)
   ffvecapply(summary(x[i1:i2]), X=x, RETURN=TRUE, CFUN="cmean", BATCHSIZE=20)

   message("how to do colSums with ffrowapply")
   x &lt;- ff(1:1000, vmode="integer", dim=c(100, 10))
   ffrowapply(colSums(x[i1:i2,,drop=FALSE]), X=x, RETURN=TRUE, CFUN="list", BATCHSIZE=20)
   ffrowapply(colSums(x[i1:i2,,drop=FALSE]), X=x, RETURN=TRUE, CFUN="crbind", BATCHSIZE=20)
   ffrowapply(colSums(x[i1:i2,,drop=FALSE]), X=x, RETURN=TRUE, CFUN="csum", BATCHSIZE=20)

   message("further ffrowapply examples")
   x &lt;- ff(1:1000, vmode="integer", dim=c(100, 10))
   message("loop evaluate expression without returning anything")
   ffrowapply(x[i1:i2, ] &lt;- i1:i2, X=x, BATCHSIZE=20)
   message("lets return the combined expressions as a new ff object (x unchanged)")
   ffrowapply(2*x[i1:i2, ], X=x, RETURN=TRUE, BATCHSIZE=20)
   message("lets return a single row aggregate")
   ffrowapply(t(apply(x[i1:i2,,drop=FALSE], 1, mean)), X=x, RETURN=TRUE, RETCOL=NULL, BATCHSIZE=20)
   message("lets return a 6 column aggregates")
   y &lt;- ffrowapply( t(apply(x[i1:i2,,drop=FALSE], 1, summary)), X=x
   , RETURN=TRUE, RETCOL=length(summary(0)), BATCHSIZE=20)
   colnames(y) &lt;- names(summary(0))
   y
   message("determine column minima if a complete column does not fit into RAM")
   ffrowapply(apply(x[i1:i2,], 2, min), X=x, RETURN=TRUE, CFUN="pmin", BATCHSIZE=20)

   message("ffapply examples")
   x &lt;- ff(1:720, dim=c(8,9,10))
   dimnames(x) &lt;- dummy.dimnames(x)
   message("apply function with scalar return value")
   apply(X=x[], MARGIN=3:2, FUN=sum)
   apply(X=x[], MARGIN=2:3, FUN=sum)
   ffapply(X=x, MARGIN=3:2, AFUN="sum", RETURN=TRUE, BATCHSIZE=8)
   message("this is what CFUN is based on")
   ffapply(X=x, MARGIN=2:3, AFUN="sum", RETURN=TRUE, CFUN="list", BATCHSIZE=8)

   message("apply functions with vector or array return value currently have limited support")
   apply(X=x[], MARGIN=3:2, FUN=summary)
   message("you must use CFUN, the rest is up to you")
   y &lt;- ffapply(X=x, MARGIN=3:2, AFUN="summary", RETURN=TRUE, CFUN="list", BATCHSIZE=8)
   y
   y[[1]]

   rm(x); gc()
</code></pre>

<hr>
<h2 id='ffconform'> Get most conforming argument </h2><span id='topic+ffconform'></span>

<h3>Description</h3>

<p><code>ffconform</code> returns position of 'most' conformable ff argument or zero if the arguments are not conforming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffconform(..., vmode = NULL, fail = "stop")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffconform_+3A_...">...</code></td>
<td>
<p> two or more ff objects </p>
</td></tr>
<tr><td><code id="ffconform_+3A_vmode">vmode</code></td>
<td>
<p> handing over target vmode here supresses searching for a common vmode, see <code><a href="#topic+maxffmode">maxffmode</a></code> </p>
</td></tr>
<tr><td><code id="ffconform_+3A_fail">fail</code></td>
<td>
<p> the name of a function to call if not-conforming, default <code><a href="base.html#topic+stop">stop</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A reference argument is defined to be the first argument with a <code><a href="#topic+dim.ff">dim</a></code> attribute or the longest vector.
The other arguements are then compared to the reference to check for conformity,
which is violated if vmodes are not conforming
or if the reference has not a multiple length of each other
or if the dimensions do not match
or if we have a dimorder conflict because not all arguments have the same <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>.
</p>


<h3>Value</h3>

<p>the position of the most conforming argument or 0 (zero) if not conforming.
</p>


<h3>Note</h3>

<p> xx Work in progress for package <span class="pkg">R.ff</span> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ffsuitable">ffsuitable</a></code>, <code><a href="#topic+maxffmode">maxffmode</a></code>, <code><a href="#topic+ymismatch">ymismatch</a></code>, <code><a href="base.html#topic+stop">stop</a></code>, <code><a href="base.html#topic+warning">warning</a></code>, <code><a href="#topic+dimorderStandard">dimorderStandard</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- ff(1:10)
  b &lt;- clone(a)
  c &lt;- ff(1:20)
  d &lt;- ff(1:21)
  ffconform(a,b)
  ffconform(c,a)
  ffconform(a,c)
  ffconform(c,a,b)

  d1 &lt;- ff(1:20, dim=c(2,10))
  d2 &lt;- ff(1:20, dim=c(10,2))
  ffconform(c,d1)
  ffconform(c,d2)
  ffconform(d1,c)
  ffconform(d2,c)
  try(ffconform(d1,d2))
  ffconform(d1,d1)

  rm(a,b,c,d1,d2); gc()
</code></pre>

<hr>
<h2 id='ffdf'>
ff class for data.frames
</h2><span id='topic+ffdf'></span>

<h3>Description</h3>

<p>Function 'ffdf' creates ff data.frames stored on disk very similar to 'data.frame'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffdf(...
, row.names = NULL
, ff_split = NULL
, ff_join = NULL
, ff_args = NULL
, update = TRUE
, BATCHSIZE = .Machine$integer.max
, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffdf_+3A_...">...</code></td>
<td>

<p><code><a href="#topic+ff">ff</a></code> vectors or matrices (optionally wrapped in <code>I()</code> that shall be bound together to an ffdf object
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_row.names">row.names</code></td>
<td>

<p>A <code><a href="base.html#topic+character">character</a></code> vector. Not recommended for large objects with many rows.
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_ff_split">ff_split</code></td>
<td>

<p>A vector of character names or integer positions identifying input components to physically split into single ff_vectors.
If vector elements have names, these are used as root name for the new ff files.
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_ff_join">ff_join</code></td>
<td>

<p>A list of vectors with character names or integer positions identifying input components to physically join in the same ff matrix.
If list elements have names, these are used to name the new ff files.
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_update">update</code></td>
<td>

<p>By default (TRUE) new ff files are updated with content of input ff objects. Setting to FALSE prevents this update.
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_ff_args">ff_args</code></td>
<td>

<p>a list with further arguments passed to <code><a href="#topic+ff">ff</a></code> in case that new ff objects are created via 'ff_split' or 'ff_join'
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_batchsize">BATCHSIZE</code></td>
<td>

<p>passed to <code><a href="#topic+update.ff">update.ff</a></code>
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>passed to <code><a href="#topic+update.ff">update.ff</a></code>
</p>
</td></tr>
<tr><td><code id="ffdf_+3A_verbose">VERBOSE</code></td>
<td>

<p>passed to <code><a href="#topic+update.ff">update.ff</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, creating an 'ffdf' object will NOT create new ff files, instead existing files are referenced.
This differs from <code><a href="base.html#topic+data.frame">data.frame</a></code>, which always creates copies of the input objects,
most notably in <code>data.frame(matrix())</code>, where an input matrix is converted to single columns.
ffdf by contrast, will store an input matrix physically as the same matrix and virtually map it to columns.
Physically copying a large ff matrix to single ff vectors can be expensive.
More generally, ffdf objects have a <code><a href="#topic+physical.ffdf">physical</a></code> and a <code><a href="#topic+virtual.ffdf">virtual</a></code> component,
which allows very flexible dataframe designs: a physically stored matrix can be virtually mapped to single columns,
a couple of physically stored vectors can be virtually mapped to a single matrix.
The means to configure these are <code><a href="base.html#topic+I">I</a></code> for the virtual representation and the 'ff_split' and 'ff_join'
arguments for the physical representation. An ff matrix wrapped into 'I()' will return the input matrix as a single object,
using 'ff_split' will store this matrix as single vectors - and thus create new ff files.
'ff_join' will copy a couple of input vectors into a unified new ff matrix with <code>dimorder=c(2,1)</code>,
but virtually they will remain single columns. The returned ffdf object has also a <code><a href="#topic+dimorder.ffdf">dimorder</a></code> attribute,
which indicates whether the ffdf object contains a matrix with non-standard dimorder <code>c(2,1)</code>, see <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>. <br />
Currently, <code><a href="#topic+vw">virtual windows</a></code> are not supported for ffdf.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>physical</code></td>
<td>
<p>the underlying ff vectors and matrices, to be accessed via <code><a href="#topic+physical.ffdf">physical</a></code></p>
</td></tr>
<tr><td><code>virtual</code></td>
<td>
<p>the virtual features of the ffdf including the virtual-to-physical mapping, to be accessed via <code><a href="#topic+virtual.ffdf">virtual</a></code></p>
</td></tr>
<tr><td><code>row.names</code></td>
<td>
<p>the optional row.names, see argument row.names</p>
</td></tr>
</table>
<p>and class 'ffdf' (NOTE that ffdf dows not inherit from ff)
</p>


<h3>Methods</h3>

<p>The following methods and functions are available for ffdf objects:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <em> Type</em> </td><td style="text-align: right;">  <em> Name </em>  </td><td style="text-align: left;"> <em> Assign </em>  </td><td style="text-align: left;"> <em>Comment</em>  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Basic functions</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+ffdf">ffdf</a></code>                       </td><td style="text-align: left;">   </td><td style="text-align: left;"> constructor for ffdf objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+update.ffdf">update</a></code>       </td><td style="text-align: left;">   </td><td style="text-align: left;"> updates one ffdf object with the content of another </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+clone.ffdf">clone</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> clones an ffdf object </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+print.ffdf">print</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> print ffdf </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+str.ffdf">str</a></code>             </td><td style="text-align: left;">   </td><td style="text-align: left;"> ffdf object structure </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Class test and coercion</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+is.ffdf">is.ffdf</a></code>                    </td><td style="text-align: left;">   </td><td style="text-align: left;"> check if inherits from ff </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+as.ffdf">as.ffdf</a></code>                    </td><td style="text-align: left;">   </td><td style="text-align: left;"> coerce to ff, if not yet </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+as.data.frame.ffdf">as.data.frame</a></code>              </td><td style="text-align: left;">   </td><td style="text-align: left;"> coerce to ram data.frame</td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Virtual storage mode</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+vmode.ffdf">vmode</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> get virtual modes for all (virtual) columns </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Physical attributes</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+physical.ffdf">physical</a></code>   </td><td style="text-align: left;">   </td><td style="text-align: left;"> get physical attributes </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Virtual attributes</b> </td>
</tr>
<tr>
 <td style="text-align: left;">
  function </td><td style="text-align: right;">  <code><a href="#topic+virtual.ffdf">virtual</a></code>     </td><td style="text-align: left;">  </td><td style="text-align: left;"> get virtual attributes </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+length.ffdf">length</a></code>       </td><td style="text-align: left;">   </td><td style="text-align: left;"> get length </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+dim.ffdf">dim </a></code>            </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> get dim and set nrow </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+dimorder.ffdf">dimorder</a></code>   </td><td style="text-align: left;">   </td><td style="text-align: left;"> get the dimorder (non-standard if any component is non-standard) </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+names.ffdf">names</a></code>         </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get names </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+dimnames.ffdf">row.names</a></code>  </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get row.names </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+dimnames.ffdf">dimnames</a></code>   </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set and get dimnames </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+filename">pattern</a></code>         </td><td style="text-align: left;"> <code>&lt;-</code> </td><td style="text-align: left;"> set pattern (rename/move files) </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Access functions</b>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic++5B.ffdf">[</a></code>                 </td><td style="text-align: left;"> <em>&lt;-</em> </td><td style="text-align: left;"> set and get data.frame content (<code>[,]</code>) or get ffdf with less columns (<code>[]</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic++5B+5B.ffdf">[[</a></code>               </td><td style="text-align: left;"> <em>&lt;-</em> </td><td style="text-align: left;"> set and get single column ff object </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic++24.ffdf">$</a></code>                 </td><td style="text-align: left;"> <em>&lt;-</em> </td><td style="text-align: left;"> set and get single column ff object </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Opening/Closing/Deleting</b>                                             </td>
</tr>
<tr>
 <td style="text-align: left;">
  generic  </td><td style="text-align: right;">  <code><a href="#topic+is.open.ffdf">is.open</a></code>     </td><td style="text-align: left;">   </td><td style="text-align: left;"> tri-bool is.open status of the physical ff components </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+open.ffdf">open</a></code>           </td><td style="text-align: left;">   </td><td style="text-align: left;"> open all physical ff objects (is done automatically on access) </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+close.ffdf">close</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> close all physical ff objects </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+delete.ffdf">delete</a></code>       </td><td style="text-align: left;">   </td><td style="text-align: left;"> deletes all physical ff files </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+finalize.ffdf">finalize</a></code>   </td><td style="text-align: left;">   </td><td style="text-align: left;"> call finalizer </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>processing</b>                                             </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+chunk.ffdf">chunk</a></code>         </td><td style="text-align: left;">   </td><td style="text-align: left;"> create chunked index </td>
</tr>
<tr>
 <td style="text-align: left;">
  method   </td><td style="text-align: right;">  <code><a href="#topic+sortLevels.ffdf">sortLevels</a></code> </td><td style="text-align: left;">   </td><td style="text-align: left;"> sort and recode levels </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: right;">                                   </td><td style="text-align: left;">   </td><td style="text-align: left;"> <b>Other</b>                                                     </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Note</h3>

<p>Note that in theory, accessing a chunk of rows from a matrix with <code>dimorder=c(2,1)</code> should be faster than accessing across a bunch of vectors.
However, at least under windows, the OS has difficulties filecaching parts from very large files, therefore - until we have partitioning - the recommended physical storage is in single vectors.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="#topic+ff">ff</a></code>, for more example see <code><a href="#topic+physical.ffdf">physical</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> m &lt;- matrix(1:12, 3, 4, dimnames=list(c("r1","r2","r3"), c("m1","m2","m3","m4")))
 v &lt;- 1:3
 ffm &lt;- as.ff(m)
 ffv &lt;- as.ff(v)

 d &lt;- data.frame(m, v)
 ffd &lt;- ffdf(ffm, v=ffv, row.names=row.names(ffm))
 all.equal(d, ffd[,])
 ffd
 physical(ffd)

 d &lt;- data.frame(m, v)
 ffd &lt;- ffdf(ffm, v=ffv, row.names=row.names(ffm), ff_split=1)
 all.equal(d, ffd[,])
 ffd
 physical(ffd)

 d &lt;- data.frame(m, v)
 ffd &lt;- ffdf(ffm, v=ffv, row.names=row.names(ffm), ff_join=list(newff=c(1,2)))
 all.equal(d, ffd[,])
 ffd
 physical(ffd)

 d &lt;- data.frame(I(m), I(v))
 ffd &lt;- ffdf(m=I(ffm), v=I(ffv), row.names=row.names(ffm))
 all.equal(d, ffd[,])
 ffd
 physical(ffd)

 rm(ffm,ffv,ffd); gc()
</code></pre>

<hr>
<h2 id='ffdfindexget'>
Reading and writing ffdf data.frame using ff subscripts
</h2><span id='topic+ffdfindexget'></span><span id='topic+ffdfindexset'></span>

<h3>Description</h3>

<p>Function <code>ffdfindexget</code> allows to extract rows from an ffdf data.frame according to positive integer suscripts stored in an ff vector.
<br />
Function <code>ffdfindexset</code> allows the inverse operation: assigning to rows of an ffdf data.frame according to positive integer suscripts stored in an ff vector.
These functions allow more control than the method dispatch of <code>[</code> and  <code>[&lt;-</code> if an ff integer subscript is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ffdfindexget(x, index, indexorder = NULL, autoindexorder = 3, FF_RETURN = NULL
  , BATCHSIZE = NULL, BATCHBYTES = getOption("ffmaxbytes"), VERBOSE = FALSE)
  ffdfindexset(x, index, value, indexorder = NULL, autoindexorder = 3
  , BATCHSIZE = NULL, BATCHBYTES = getOption("ffmaxbytes"), VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffdfindexget_+3A_x">x</code></td>
<td>

<p>A <code><a href="#topic+ffdf">ffdf</a></code> data.frame containing the elements
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_index">index</code></td>
<td>

<p>A <code><a href="#topic+ff">ff</a></code> integer vector with integer subscripts in the range from <code>1</code> to <code>length(x)</code>.
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_value">value</code></td>
<td>

<p>A <code><a href="#topic+ffdf">ffdf</a></code> data.frame like <code>x</code> with the rows to be assigned
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_indexorder">indexorder</code></td>
<td>

<p>Optionally the return value of <code><a href="#topic+ffindexorder">ffindexorder</a></code>, see details
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_autoindexorder">autoindexorder</code></td>
<td>

<p>The minimum number of columns (which need chunked indexordering) for which we switch from on-the-fly ordering to stored <code><a href="#topic+ffindexorder">ffindexorder</a></code>
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_ff_return">FF_RETURN</code></td>
<td>

<p>Optionally an <code><a href="#topic+ffdf">ffdf</a></code> data.frame of the same type as x in which the returned values shall be stored, see details.
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_batchsize">BATCHSIZE</code></td>
<td>

<p>Optinal limit for the batchsize (see details)
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>Limit for the number of bytes per batch
</p>
</td></tr>
<tr><td><code id="ffdfindexget_+3A_verbose">VERBOSE</code></td>
<td>

<p>Logical scalar for verbosing
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accessing rows of an ffdf data.frame identified by integer positions in an ff vector is a non-trivial task, because it could easily lead to random-access to disk files.
We avoid random access by loading batches of the subscript values into RAM, order them ascending, and only then access the ff values on disk.
Such ordering is don on-thy-fly for upto <code>autoindexorder-1</code> columns that need ordering.
For <code>autoindexorder</code> o more columns we do the batched ordering upfront with <code><a href="#topic+ffindexorder">ffindexorder</a></code> and then re-use it in each call to <code><a href="#topic+ffindexget">ffindexget</a></code> resp. <code><a href="#topic+ffindexset">ffindexset</a></code>.
</p>


<h3>Value</h3>

<p>Function <code>ffdfindexget</code> returns a ffdf data.frame with those rows selected by the ff <code>index</code> vector.
<br />
Function <code>ffdfindexset</code> returns <code>x</code> with those rows replaced that had been requested by <code>index</code> and <code>value</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Extract.ff">Extract.ff</a></code>, <code><a href="#topic+ffindexget">ffindexget</a></code>, <code><a href="#topic+ffindexorder">ffindexorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("ff integer subscripts with ffdf return/assign values")
x &lt;- ff(factor(letters))
y &lt;- ff(1:26)
d &lt;- ffdf(x,y)
i &lt;- ff(2:9)
di &lt;- d[i,]
di
d[i,] &lt;- di
message("ff integer subscripts: more control with ffindexget/ffindexset")
di &lt;- ffdfindexget(d, i, FF_RETURN=di)
d &lt;- ffdfindexset(d, i, di)
rm(x, y, d, i, di)
gc()
</code></pre>

<hr>
<h2 id='ffdfsort'>
Sorting: convenience wrappers for data.frames
</h2><span id='topic+dfsort'></span><span id='topic+dforder'></span><span id='topic+ramdfsort'></span><span id='topic+ramdforder'></span><span id='topic+ffdfsort'></span><span id='topic+ffdforder'></span>

<h3>Description</h3>

<p>These functions allow convenient sorting and ordering of collections of (ff) vectors organized in (ffdf) data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dforder(x, ...)
dfsort(x, ...)
ramdforder(x, ...)
ramdfsort(x, ...)
ffdforder(x, ...)
ffdfsort(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffdfsort_+3A_x">x</code></td>
<td>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> (for <code>dforder, dfsort, ramorder, ramsort</code>) or an <code><a href="#topic+ffdf">ffdf</a></code> object (for <code>ffdforder, ffdfsort</code>)
</p>
</td></tr>
<tr><td><code id="ffdfsort_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code><a href="base.html#topic+sort">sort</a></code>, <code><a href="bit.html#topic+ramsort">ramsort</a></code> or <code><a href="#topic+ffsort">ffsort</a></code> (for objects with one column)
or passed to <code><a href="base.html#topic+order">order</a></code>, <code><a href="bit.html#topic+ramorder">ramorder</a></code> or <code><a href="#topic+fforder">fforder</a></code> (for objects with mulitple columns)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the order functions return an (ff) vector of integer order positions, the sort functions return a sorted clone of the (ffdf) input data.frame
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort</a></code>, <code><a href="bit.html#topic+ramsort">ramsort</a></code> or <code><a href="#topic+ffsort">ffsort</a></code> <br />
<code><a href="base.html#topic+order">order</a></code>, <code><a href="bit.html#topic+ramorder">ramorder</a></code> or <code><a href="#topic+fforder">fforder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- ff(sample(1e5, 1e6, TRUE))
   y &lt;- ff(sample(1e5, 1e6, TRUE))
   z &lt;- ff(sample(1e5, 1e6, TRUE))
   d &lt;- ffdf(x, y, z)
   d2 &lt;- ffdfsort(d)
   d2
   d
   d2 &lt;- d[1:2]
   i &lt;- ffdforder(d2)
   d[i,]
   rm(x, y, z, i, d, d2)
   gc()
</code></pre>

<hr>
<h2 id='ffdrop'>
Delete an ffarchive
</h2><span id='topic+ffdrop'></span>

<h3>Description</h3>

<p>Delete the <code>&lt;file&gt;.Rdata</code> and <code>&lt;file&gt;.ffData</code> files behind an <code>ffarchive</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffdrop(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffdrop_+3A_file">file</code></td>
<td>

<p>vector of archive filenames (without extensions)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>RData</code></td>
<td>
<p>vector with results of <code><a href="base.html#topic+file.remove">file.remove</a></code> on RData files </p>
</td></tr>
<tr><td><code>ffData</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This deletes file on disk without warning
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffsave">ffsave</a></code>, <code><a href="#topic+ffinfo">ffinfo</a></code>, <code><a href="#topic+ffload">ffload</a></code>
</p>

<hr>
<h2 id='ffindexget'>
Reading and writing ff vectors using ff subscripts
</h2><span id='topic+ffindexget'></span><span id='topic+ffindexset'></span>

<h3>Description</h3>

<p>Function <code>ffindexget</code> allows to extract elements from an ff vector according to positive integer suscripts stored in an ff vector.
<br />
Function <code>ffindexset</code> allows the inverse operation: assigning to elements of an ff vector according to positive integer suscripts stored in an ff vector.
These functions allow more control than the method dispatch of <code>[</code> and  <code>[&lt;-</code> if an ff integer subscript is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffindexget(x, index, indexorder = NULL, FF_RETURN = NULL
, BATCHSIZE = NULL, BATCHBYTES = getOption("ffmaxbytes"), VERBOSE = FALSE)
ffindexset(x, index, value, indexorder = NULL
, BATCHSIZE = NULL, BATCHBYTES = getOption("ffmaxbytes"), VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffindexget_+3A_x">x</code></td>
<td>

<p>A <code><a href="#topic+ff">ff</a></code> vector containing the elements
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_index">index</code></td>
<td>

<p>A <code><a href="#topic+ff">ff</a></code> integer vector with integer subscripts in the range from <code>1</code> to <code>length(x)</code>.
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_value">value</code></td>
<td>

<p>An <code><a href="#topic+ff">ff</a></code> vector of the same <code><a href="#topic+vmode">vmode</a></code> as x containing the values to be assigned
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_indexorder">indexorder</code></td>
<td>

<p>Optionally the return value of <code><a href="#topic+ffindexorder">ffindexorder</a></code>, see details
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_ff_return">FF_RETURN</code></td>
<td>

<p>Optionally an <code><a href="#topic+ff">ff</a></code> vector of the same <code><a href="#topic+vmode">vmode</a></code> as x in which the returned values shall be stored, see details.
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_batchsize">BATCHSIZE</code></td>
<td>

<p>Optinal limit for the batchsize (see details)
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>Limit for the number of bytes per batch
</p>
</td></tr>
<tr><td><code id="ffindexget_+3A_verbose">VERBOSE</code></td>
<td>

<p>Logical scalar for verbosing
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accessing integer positions in an ff vector is a non-trivial task, because it could easily lead to random-access to a disk file.
We avoid random access by loading batches of the subscript values into RAM, order them ascending, and only then access the ff values on disk.
Since ordering is expensive, it may pay to do the batched ordering once upfront and then re-use it with  <code><a href="#topic+ffindexorder">ffindexorder</a></code>,
similar to storing and using hybrid index information with <code><a href="#topic+as.hi">as.hi</a></code>.
</p>


<h3>Value</h3>

<p>Function <code>ffindexget</code> returns an ff vector with the extracted elements.
<br />
Function <code>ffindexset</code> returns the ff vector in which we have updated values.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Extract.ff">Extract.ff</a></code>, <code><a href="#topic+ffdfindexget">ffdfindexget</a></code>, <code><a href="#topic+ffindexorder">ffindexorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("ff integer subscripts with ff return/assign values")
x &lt;- ff(factor(letters))
i &lt;- ff(2:9)
xi &lt;- x[i]
xi
xi[] &lt;- NA
xi
x[i] &lt;- xi
x
message("ff integer subscripts: more control with ffindexget/ffindexset")
xi &lt;- ffindexget(x, i, FF_RETURN=xi)
x &lt;- ffindexset(x, i, xi)
rm(x, i, xi)
gc()
</code></pre>

<hr>
<h2 id='ffindexorder'>
Sorting: chunked ordering of integer suscript positions
</h2><span id='topic+ffindexorder'></span><span id='topic+ffindexordersize'></span>

<h3>Description</h3>

<p>Function <code>ffindexorder</code> will calculate chunkwise the order positions to sort all positions in a chunk ascending.
<br />
Function <code>ffindexordersize</code> does the calculation of the chunksize for <code>ffindexorder</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffindexordersize(length, vmode, BATCHBYTES = getOption("ffmaxbytes"))
ffindexorder(index, BATCHSIZE, FF_RETURN = NULL, VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffindexorder_+3A_index">index</code></td>
<td>

<p>A <code><a href="#topic+ff">ff</a></code> integer vector with integer subscripts.
</p>
</td></tr>
<tr><td><code id="ffindexorder_+3A_batchsize">BATCHSIZE</code></td>
<td>

<p>Limit for the chunksize (see details)
</p>
</td></tr>
<tr><td><code id="ffindexorder_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>Limit for the number of bytes per batch
</p>
</td></tr>
<tr><td><code id="ffindexorder_+3A_ff_return">FF_RETURN</code></td>
<td>

<p>Optionally an <code><a href="#topic+ff">ff</a></code> integer vector in which the chunkwise order positions are stored.
</p>
</td></tr>
<tr><td><code id="ffindexorder_+3A_verbose">VERBOSE</code></td>
<td>

<p>Logical scalar for activating verbosing.
</p>
</td></tr>
<tr><td><code id="ffindexorder_+3A_length">length</code></td>
<td>

<p>Number of elements in the index
</p>
</td></tr>
<tr><td><code id="ffindexorder_+3A_vmode">vmode</code></td>
<td>

<p>The <code><a href="#topic+vmode">vmode</a></code> of the ff vector to which the index shall be applied with <code><a href="#topic+ffindexget">ffindexget</a></code> or <code><a href="#topic+ffindexset">ffindexset</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accessing integer positions in an ff vector is a non-trivial task, because it could easily lead to random-access to a disk file.
We avoid random access by loading batches of the subscript values into RAM, order them ascending, and only then access the ff values on disk.
Such an ordering can be done on-the-fly by <code><a href="#topic+ffindexget">ffindexget</a></code> or it can be created upfront with <code>ffindexorder</code>, stored and re-used,
similar to storing and using hybrid index information with <code><a href="#topic+as.hi">as.hi</a></code>.
</p>


<h3>Value</h3>

<p>Function <code>ffindexorder</code> returns an ff integer vector with an attribute <code>BATCHSIZE</code> (the chunksize finally used, not the one given with argument <code>BATCHSIZE</code>).
<br />
Function <code>ffindexordersize</code> returns a balanced batchsize as returned from <code><a href="bit.html#topic+bbatch">bbatch</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffindexget">ffindexget</a></code>,  <code><a href="#topic+as.hi">as.hi</a></code>,  <code><a href="bit.html#topic+bbatch">bbatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     x &lt;- ff(sample(40))
     message("fforder requires sorting")
     i &lt;- fforder(x)
     message("applying this order i is done by ffindexget")
     x[i]
     message("applying this order i requires random access, 
       therefore ffindexget does chunkwise sorting")
     ffindexget(x, i)
     message("if we want to apply the order i multiple times,
       we can do the chunkwise sorting once and store it")
     s &lt;- ffindexordersize(length(i), vmode(i), BATCHBYTES = 100)
     o &lt;- ffindexorder(i, s$b)
     message("this is how the stored chunkwise sorting is used")
     ffindexget(x, i, o)
     message("")
     rm(x,i,s,o)
     gc()
</code></pre>

<hr>
<h2 id='ffinfo'>
Inspect content of ff saves
</h2><span id='topic+ffinfo'></span>

<h3>Description</h3>

<p>Find out which objects and ff files are in a pair of files saved with <code><a href="#topic+ffsave">ffsave</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffinfo(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffinfo_+3A_file">file</code></td>
<td>

<p>a character string giving the name (without extension) of the <code>.RData</code> and <code>.ffData</code> files to load
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table>
<tr><td><code>RData</code></td>
<td>
<p>a list, one element for each object (named like the object): a character vector with the names of the ff files </p>
</td></tr>
<tr><td><code>ffData</code></td>
<td>
<p>a list, one element for each path (names like the path): a character vector with the names of the ff files </p>
</td></tr>
<tr><td><code>rootpath</code></td>
<td>
<p> the root path relative to which the files are stored in the .ffData zip </p>
</td></tr>
</table>


<h3>Note</h3>

<p>For large files and the zip64 format use <code>zip 3.0</code> and <code>unzip 6.0</code> from <a href="https://infozip.sourceforge.net/">https://infozip.sourceforge.net/</a>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffsave">ffsave</a></code>, <code><a href="#topic+ffload">ffload</a></code>, <code><a href="#topic+ffdrop">ffdrop</a></code>
</p>

<hr>
<h2 id='ffload'>
Reload ffSaved Datasets
</h2><span id='topic+ffload'></span>

<h3>Description</h3>

<p>Reload datasets written with the function <code>ffsave</code> or <code>ffsave.image</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffload(file, list = character(0L), envir = parent.frame()
, rootpath = NULL, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffload_+3A_file">file</code></td>
<td>

<p>a character string giving the name (without extension) of the <code>.RData</code> and <code>.ffData</code> files to load
</p>
</td></tr>
<tr><td><code id="ffload_+3A_list">list</code></td>
<td>

<p>An optional vector of names selecting those objects to be restored (default NULL restores all)
</p>
</td></tr>
<tr><td><code id="ffload_+3A_envir">envir</code></td>
<td>

<p>the environment where the data should be loaded.
</p>
</td></tr>
<tr><td><code id="ffload_+3A_rootpath">rootpath</code></td>
<td>

<p>an optional rootpath where to restore the ff files (default NULL restores in the original location)
</p>
</td></tr>
<tr><td><code id="ffload_+3A_overwrite">overwrite</code></td>
<td>

<p>logical indicating whether possibly existing ff files shall be overwritten
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+ffinfo">ffinfo</a></code> can be used to inspect the contents an ffsaved pair of <code>.RData</code> and <code>.ffData</code> files.
Argument <code>list</code> can then be used to restore only part of the ffsave.
</p>


<h3>Value</h3>

<p>A character vector with the names of the restored ff files
</p>


<h3>Note</h3>

<p>The ff files are not platform-independent with regard to byte order.
For large files and the zip64 format use <code>zip 3.0</code> and <code>unzip 6.0</code> from <a href="https://infozip.sourceforge.net//">https://infozip.sourceforge.net//</a>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+load">load</a></code>, <code><a href="#topic+ffsave">ffsave</a></code>, <code><a href="#topic+ffinfo">ffinfo</a></code>, <code><a href="#topic+ffdrop">ffdrop</a></code>
</p>

<hr>
<h2 id='fforder'>
Sorting: order from ff vectors
</h2><span id='topic+fforder'></span>

<h3>Description</h3>

<p>Returns order with regard to one or more ff vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fforder(...
, index = NULL
, use.index = NULL
, aux = NULL
, auxindex = NULL
, has.na = TRUE
, na.last = TRUE
, decreasing = FALSE
, BATCHBYTES = getOption("ffmaxbytes")
, VERBOSE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fforder_+3A_...">...</code></td>
<td>

<p>one of more ff vectors which define the order
</p>
</td></tr>
<tr><td><code id="fforder_+3A_index">index</code></td>
<td>

<p>an optional ff integer vector used to store the order output
</p>
</td></tr>
<tr><td><code id="fforder_+3A_use.index">use.index</code></td>
<td>

<p>A boolean flag telling fforder whether to use the positions in 'index' as input.
If you do this, it is your responsibility to assure legal positions - otherwise you risk a crash.
</p>
</td></tr>
<tr><td><code id="fforder_+3A_aux">aux</code></td>
<td>

<p>An optional named list of ff vectors that can be used for temporary copying
&ndash; the names of the list identify the <code><a href="#topic+vmode">vmode</a>s</code> for which the respective ff vector is suitable.
</p>
</td></tr>
<tr><td><code id="fforder_+3A_auxindex">auxindex</code></td>
<td>

<p>An optional ff intger vector for temporary storage of integer positions.
</p>
</td></tr>
<tr><td><code id="fforder_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar telling fforder whether the vector might contain <code>NA</code>s.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="fforder_+3A_na.last">na.last</code></td>
<td>

<p>boolean scalar telling fforder whether to order <code>NA</code>s last or first.
<em>Note</em> that 'boolean' means that there is no third option <code>NA</code> as in <code><a href="base.html#topic+order">order</a></code>
</p>
</td></tr>
<tr><td><code id="fforder_+3A_decreasing">decreasing</code></td>
<td>

<p>boolean scalar telling fforder whether to order increasing or decreasing
</p>
</td></tr>
<tr><td><code id="fforder_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>maximum number of RAM bytes fforder should try not to exceed
</p>
</td></tr>
<tr><td><code id="fforder_+3A_verbose">VERBOSE</code></td>
<td>

<p>cat some info about the ordering
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>fforder tries to order the vector in-RAM, if not possible it uses (a yet simple) out-of-memory algorithm.
Like <code><a href="bit.html#topic+ramorder">ramorder</a></code> the in-RAM ordering method is choosen depending on context information.
</p>


<h3>Value</h3>

<p>An ff vector with the positions that ore required to sort the input as specified
&ndash; with an attribute <code><a href="bit.html#topic+na.count">na.count</a></code> with as many values as columns in ...
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+ramorder">ramorder</a></code>, <code><a href="#topic+ffsort">ffsort</a></code>, <code><a href="#topic+ffdforder">ffdforder</a></code>, <code><a href="#topic+ffindexget">ffindexget</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- ff(sample(1e5, 1e6, TRUE))
   y &lt;- ff(sample(1e5, 1e6, TRUE))
   d &lt;- ffdf(x, y)

   i &lt;- fforder(y)
   y[i]
   i &lt;- fforder(x, index=i)
   x[i]
   d[i,]

   i &lt;- fforder(x, y)
   d[i,]

   i &lt;- ffdforder(d)
   d[i,]

   rm(x, y, d, i)
   gc()
</code></pre>

<hr>
<h2 id='ffreturn'> Return suitable ff object </h2><span id='topic+ffreturn'></span>

<h3>Description</h3>

<p><code>ffreturn</code> returns <code>FF_RETURN</code> if it is <code><a href="#topic+ffsuitable">ffsuitable</a></code> otherwise creates a suitable <code><a href="#topic+ffsuitable">ffsuitable</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffreturn(FF_RETURN = NULL, FF_PROTO = NULL, FF_ATTR = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffreturn_+3A_ff_return">FF_RETURN</code></td>
<td>
<p> the object to be tested for suitability </p>
</td></tr>
<tr><td><code id="ffreturn_+3A_ff_proto">FF_PROTO</code></td>
<td>
<p> the prototype object which <code>FF_RETURN</code> should match </p>
</td></tr>
<tr><td><code id="ffreturn_+3A_ff_attr">FF_ATTR</code></td>
<td>
<p> a list of additional attributes dominating those from <code>FF_PROTO</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a suitable <code><a href="#topic+ffsuitable">ffsuitable</a></code> object
</p>


<h3>Note</h3>

<p> xx Work in progress for package <span class="pkg">R.ff</span> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ffconform">ffconform</a></code>, <code><a href="#topic+ffsuitable">ffsuitable</a></code> </p>

<hr>
<h2 id='ffsave'>
Save R and ff objects
</h2><span id='topic+ffsave'></span><span id='topic+ffsave.image'></span>

<h3>Description</h3>

<p><code>ffsave</code> writes an external representation of R and ff objects to an <code>ffarchive</code>.
The objects can be read back from the file at a later date by using the function <code><a href="#topic+ffload">ffload</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffsave(...
, list = character(0L)
, file = stop("'file' must be specified")
, envir = parent.frame()
, rootpath = NULL
, add = FALSE
, move = FALSE
, compress = !move
, compression_level = 6
, precheck=TRUE
)
ffsave.image(file = stop("'file' must be specified"), safe = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffsave_+3A_...">...</code></td>
<td>

<p>For <code>ffsave</code> the names of the objects to be saved (as symbols or character strings),
for <code>ffsave.image</code> further arguments passed to <code>ffsave</code>
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_list">list</code></td>
<td>

<p>A character vector containing the names of objects to be saved.
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_file">file</code></td>
<td>

<p>A name for the the <code>ffarchive</code>, i.e. the two files <code>&lt;file&gt;.RData</code> and <code>&lt;file&gt;.ffData</code>
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_envir">envir</code></td>
<td>

<p>environment to search for objects to be saved.
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_add">add</code></td>
<td>

<p>logical indicating whether the objects shall be added to the <code>ffarchive</code> (in this case <code>rootpath</code> is taken from an existing archive)
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_move">move</code></td>
<td>

<p>logical indicating whether ff files shall be moved instead of copied into the <code>&lt;file&gt;.ffData</code>
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_compress">compress</code></td>
<td>

<p>logical specifying whether saving to a named file is to use compression.
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_compression_level">compression_level</code></td>
<td>

<p>compression level passed to <code>zip</code>, default 6
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_rootpath">rootpath</code></td>
<td>

<p>optional path component that all <em>all</em> ff files share and that can be dropped/replaced when calling <code><a href="#topic+ffload">ffload</a></code>
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_precheck">precheck</code></td>
<td>

<p>logical: should the existence of the objects be checked before starting to save (and in particular before opening the file/connection)?
</p>
</td></tr>
<tr><td><code id="ffsave_+3A_safe">safe</code></td>
<td>

<p>logical. If <code>TRUE</code>, a temporary file is used for creating the saved workspace. The temporary file is renamed to <code>&lt;file&gt;.ffData</code> if the save succeeds.
This preserves an existing workspace <code>&lt;file&gt;.ffData</code> if the save fails,
but at the cost of using extra disk space during the save.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ffsave</code> stores objects and ff files in an <code>ffarchive</code> named <code>&lt;file&gt;</code>:
i.e. it saves all specified objects via <code><a href="base.html#topic+save">save</a></code> in a file named <code>&lt;file&gt;.RData</code>
and saves all ff files related to these objects in a zipfile named <code>&lt;file&gt;.ffData</code> using an external <code>zip</code> utility.
<br />
By default files are stored relative to the <code>rootpath="\"} and will be restored relative to \code{"\"</code> (in its original location).
By providing a partial path prefix via argument <code>rootpath</code> the files are stored relative to this <code>rootpath</code>.
The <code>rootpath</code> is stored in the <code>&lt;file&gt;.RData</code> with the name <code>.ff.rootpath</code>.
I.e. even if the ff objects were saved with argument <code>rootpath</code> to <code>ffsave</code>,
<code><a href="#topic+ffload">ffload</a></code> by default restores in the original location.
By using argument <code>rootpath</code> to <code>ffload</code> you can restore relative to a different <code>rootpath</code>
(and using argument <code>rootpath</code> to <code>ffsave</code> gave you shorter relative paths)
<br />
By using argument <code>add</code> in <code>ffsave</code> you can add more objects to an existing <code>ffarchive</code>
and by using argument <code>list</code> in <code>ffload</code> you can selectively restore objects.
<br />
The content of the <code>ffarchive</code> can be inspected using <code><a href="#topic+ffinfo">ffinfo</a></code> before actually loading any of the objects.
<br />
The <code>ffarchive</code> can be deleted from disk using <code><a href="#topic+ffdrop">ffdrop</a></code>.
</p>


<h3>Value</h3>

<p>a character vector with messages returned from the <code>zip</code> utility (one for each ff file zipped)
</p>


<h3>Note</h3>

<p>The ff files are not platform-independent with regard to byte order.
For large files and the zip64 format use <code>zip 3.0</code> and <code>unzip 6.0</code> from <a href="https://infozip.sourceforge.net/">https://infozip.sourceforge.net/</a>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffinfo">ffinfo</a></code> for inspecting the content of the <code>ffarchive</code> <br />
<code><a href="#topic+ffload">ffload</a></code> for loading all or some of the <code>ffarchive</code> <br />
<code><a href="#topic+ffdrop">ffdrop</a></code> for deleting one or more <code>ffarchives</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  message("let's create some ff objects")
  n &lt;- 8e3
  a &lt;- ff(sample(n, n, TRUE), vmode="integer", length=n, filename="d:/tmp/a.ff")
  b &lt;- ff(sample(255, n, TRUE), vmode="ubyte", length=n, filename="d:/tmp/b.ff")
  x &lt;- ff(sample(255, n, TRUE), vmode="ubyte", length=n, filename="d:/tmp/x.ff")
  y &lt;- ff(sample(255, n, TRUE), vmode="ubyte", length=n, filename="d:/tmp/y.ff")
  z &lt;- ff(sample(255, n, TRUE), vmode="ubyte", length=n, filename="d:/tmp/z.ff")
  df &lt;- ffdf(x=x, y=y, z=z)
  rm(x,y,z)

  message("save all of them")
  ffsave.image("d:/tmp/x")
  str(ffinfo("d:/tmp/x"))

  message("save some of them with shorter relative pathnames ...")
  ffsave(a, b, file="d:/tmp/y", rootpath="d:/tmp")
  str(ffinfo("d:/tmp/y"))

  message("... and add others later")
  ffsave(df, add=TRUE, file="d:/tmp/y", rootpath="d:/tmp")
  str(ffinfo("d:/tmp/y"))

  message("... and add others later")
  system.time(ffsave(a, file="d:/tmp/z", move=TRUE))
  ffinfo("d:/tmp/z")

  message("let's delete/close/remove all objects")
  close(a)  # no file anymore, since we moved a into the ffarchive
  delete(b, df)
  rm(df, a, b, n)
  message("prove it")
  ls()

  message("restore all but ff files in a different directory")
  system.time(ffload("d:/tmp/x", rootpath="d:/tmp2"))
  lapply(ls(), function(i)filename(get(i)))

  delete(a, b, df)
  rm(df, a, b)

  ffdrop(c("d:/tmp/x", "d:/tmp/y", "d:/tmp/z"))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='ffsort'>
Sorting of ff vectors
</h2><span id='topic+ffsort'></span>

<h3>Description</h3>

<p>Sorting: sort an ff vector &ndash; optionally in-place
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffsort(x
, aux = NULL
, has.na = TRUE
, na.last = TRUE
, decreasing = FALSE
, inplace = FALSE
, decorate = FALSE
, BATCHBYTES = getOption("ffmaxbytes")
, VERBOSE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffsort_+3A_x">x</code></td>
<td>

<p>an ff vector
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_aux">aux</code></td>
<td>

<p>NULL or an ff vector of the same type for temporary storage
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar telling ffsort whether the vector might contain <code>NA</code>s.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_na.last">na.last</code></td>
<td>

<p>boolean scalar telling ffsort whether to sort <code>NA</code>s last or first.
<em>Note</em> that 'boolean' means that there is no third option <code>NA</code> as in <code><a href="base.html#topic+sort">sort</a></code>
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_decreasing">decreasing</code></td>
<td>

<p>boolean scalar telling ffsort whether to sort increasing or decreasing
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_inplace">inplace</code></td>
<td>

<p>boolean scalar telling ffsort whether to sort the original ff vector (<code>TRUE</code>)
or to create a sorted copy (<code>FALSE</code>, the default)
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_decorate">decorate</code></td>
<td>

<p>boolean scalar telling ffsort whether to decorate the returned ff vector with <code><a href="bit.html#topic+is.sorted">is.sorted</a></code>
and <code><a href="bit.html#topic+na.count">na.count</a></code> attributes.
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>maximum number of RAM bytes ffsort should try not to exceed
</p>
</td></tr>
<tr><td><code id="ffsort_+3A_verbose">VERBOSE</code></td>
<td>

<p>cat some info about the sorting
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ffsort tries to sort the vector in-RAM respecting the BATCHBYTES limit.
If a fast sort it not possible, it uses a slower in-place sort (shellsort).
If in-RAM is not possible, it uses (a yet simple) out-of-memory algorithm.
Like <code><a href="bit.html#topic+ramsort">ramsort</a></code> the in-RAM sorting method is choosen depending on context information.
If a key-index sort can be used, ffsort completely avoids merging disk based subsorts.
If argument <code>decorate=TRUE</code> is used, then <code>na.count(x)</code> will return the number of NAs
and <code>is.sorted(x)</code> will return TRUE if the sort was done with <code>na.last=TRUE</code> and <code>decreasing=FALSE</code>.
</p>


<h3>Value</h3>

<p>An ff vector &ndash; optionally decorated with <code><a href="bit.html#topic+is.sorted">is.sorted</a></code> and <code><a href="bit.html#topic+na.count">na.count</a></code>, see argument 'decorate'
</p>


<h3>Note</h3>

<p>the ff vector may not have a names attribute
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+ramsort">ramsort</a></code>, <code><a href="#topic+fforder">fforder</a></code>, <code><a href="#topic+ffdfsort">ffdfsort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   n &lt;- 1e6
   x &lt;- ff(c(NA, 999999:1), vmode="double", length=n)
   x &lt;- ffsort(x)
   x
   is.sorted(x)
   na.count(x)
   x &lt;- ffsort(x, decorate=TRUE)
   is.sorted(x)
   na.count(x)
   x &lt;- ffsort(x, BATCHBYTES=n, VERBOSE=TRUE)
</code></pre>

<hr>
<h2 id='ffsuitable'> Test ff object for suitability </h2><span id='topic+ffsuitable'></span><span id='topic+ffsuitable_attribs'></span>

<h3>Description</h3>

<p><code>ffsuitable</code> tests whether <code>FF_RETURN</code> is an <code><a href="#topic+ff">ff</a></code> object like <code>FF_PROTO</code> and having attributes <code>FF_ATTR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffsuitable(FF_RETURN, FF_PROTO = NULL, FF_ATTR = list()
, strict.dimorder = TRUE, fail = "warning")
ffsuitable_attribs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffsuitable_+3A_x">x</code></td>
<td>
<p> an object from which to extract attributes for comparison </p>
</td></tr>
<tr><td><code id="ffsuitable_+3A_ff_return">FF_RETURN</code></td>
<td>
<p> the object to be tested for suitability </p>
</td></tr>
<tr><td><code id="ffsuitable_+3A_ff_proto">FF_PROTO</code></td>
<td>
<p> the prototype object which <code>FF_RETURN</code> should match </p>
</td></tr>
<tr><td><code id="ffsuitable_+3A_ff_attr">FF_ATTR</code></td>
<td>
<p> a list of additional attributes dominating those from <code>FF_PROTO</code> </p>
</td></tr>
<tr><td><code id="ffsuitable_+3A_strict.dimorder">strict.dimorder</code></td>
<td>
<p> if TRUE ffsuitability requires that the dimorders are standard (ascending) </p>
</td></tr>
<tr><td><code id="ffsuitable_+3A_fail">fail</code></td>
<td>
<p> name of a function to be called if not ffsuitable (default <code><a href="base.html#topic+warning">warning</a></code>) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>FF_RETURN</code> object is suitable, FALSE otherwise
</p>


<h3>Note</h3>

<p> xx Work in progress for package <span class="pkg">R.ff</span> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ffconform">ffconform</a></code>, <code><a href="#topic+ffreturn">ffreturn</a></code> </p>

<hr>
<h2 id='ffxtensions'> Test for availability of ff extensions </h2><span id='topic+ffxtensions'></span><span id='topic+ffsymmxtensions'></span>

<h3>Description</h3>

<p>checks if this version of package ff supports ff extensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ffxtensions()
 ffsymmxtensions()
</code></pre>


<h3>Details</h3>

<p>ff extensions are needed for certain bitcompressed vmodes and ff symm extensions for symmetric matrices.
</p>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+vmode">vmode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ffxtensions()
  ffsymmxtensions()
</code></pre>

<hr>
<h2 id='file.resize'> Change size of move an existing file </h2><span id='topic+file.resize'></span><span id='topic+file.move'></span>

<h3>Description</h3>

<p>Change size of an existing file (on some platforms sparse files are
used) or move file to other name and/or location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  file.resize(path, size)
  file.move(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file.resize_+3A_path">path</code></td>
<td>
<p> file path (on windows it uses a 'windows' backslash path!)  </p>
</td></tr>
<tr><td><code id="file.resize_+3A_size">size</code></td>
<td>
<p> new filesize in bytes as double </p>
</td></tr>
<tr><td><code id="file.resize_+3A_from">from</code></td>
<td>
<p> old file path  </p>
</td></tr>
<tr><td><code id="file.resize_+3A_to">to</code></td>
<td>
<p> new file path </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>file.resize</code> can enlarge or shrink the file. When enlarged, the file
is filled up with zeros. Some platform implementations feature
sparse files, so that this operation is very fast. We have tested:
</p>

<ul>
<li><p> Ubuntu Linux 8, i386
</p>
</li>
<li><p> FreeBSD 7, i386
</p>
</li>
<li><p> Gentoo Linux Virtual-Server, i386
</p>
</li>
<li><p> Gentoo Linux, x86_64
</p>
</li>
<li><p> Windows XP
</p>
</li></ul>

<p>The following work but do not support sparse files
</p>

<ul>
<li><p> Mac OS X 10.5, i386
</p>
</li>
<li><p> Mac OS X 10.4, PPC
</p>
</li></ul>

<p><code>file.move</code> tries  to <code><a href="base.html#topic+file.rename">file.rename</a></code>, 
if this fails (e.g. across file systems) the file is copied to the new location and the old file is removed, 
see  <code><a href="base.html#topic+file.copy">file.copy</a></code> and <code><a href="base.html#topic+file.remove">file.remove</a></code>.
</p>


<h3>Value</h3>

<p>logical scalar repesenting the success of this operation
</p>


<h3>Author(s)</h3>

<p> Daniel Adler </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+file.create">file.create</a></code>, <code><a href="base.html#topic+file.rename">file.rename</a></code>, <code><a href="base.html#topic+file.info">file.info</a></code>, <code><a href="base.html#topic+file.copy">file.copy</a></code>, <code><a href="base.html#topic+file.remove">file.remove</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- tempfile()
 newsize &lt;- 23       # resize and size to 23 bytes.
 file.resize(x, newsize)
 file.info(x)$size == newsize
 ## Not run: 
   newsize &lt;- 8*(2^30) # create new file and size to 8 GB.
   file.resize(x, newsize)
   file.info(x)$size == newsize
 
## End(Not run)
 y &lt;- tempfile()
 file.move(x,y)
 file.remove(y)
</code></pre>

<hr>
<h2 id='filename'> Get or set filename </h2><span id='topic+filename'></span><span id='topic+filename.default'></span><span id='topic+filename.ff_pointer'></span><span id='topic+filename.ffdf'></span><span id='topic+filename+3C-'></span><span id='topic+filename+3C-.ff'></span><span id='topic+pattern'></span><span id='topic+pattern+3C-'></span><span id='topic+pattern.ff'></span><span id='topic+pattern+3C-.ff'></span><span id='topic+pattern+3C-.ffdf'></span>

<h3>Description</h3>

<p>Get or set filename from ram or <code><a href="#topic+ff">ff</a></code> object via the <code>filename</code> and <code>filename&lt;-</code> generics
or rename all files behind a <code><a href="#topic+ffdf">ffdf</a></code> using the <code>pattern&lt;-</code> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filename(x, ...)
filename(x, ...) &lt;- value
## Default S3 method:
filename(x, ...)
## S3 method for class 'ff_pointer'
filename(x, ...)
## S3 method for class 'ffdf'
filename(x, ...)
## S3 replacement method for class 'ff'
filename(x, ...) &lt;- value
pattern(x, ...)
pattern(x, ...) &lt;- value
## S3 method for class 'ff'
pattern(x, ...)
## S3 replacement method for class 'ff'
pattern(x, ...) &lt;- value
## S3 replacement method for class 'ffdf'
pattern(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filename_+3A_x">x</code></td>
<td>
<p> a ram or ff  object, or for pattern assignment only - a ffdf object </p>
</td></tr>
<tr><td><code id="filename_+3A_value">value</code></td>
<td>
<p> a new filename </p>
</td></tr>
<tr><td><code id="filename_+3A_...">...</code></td>
<td>
<p> dummy to keep R CMD CHECK quiet </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assigning a <code>filename&lt;-</code> means renaming the corresponding file on disk - even for ram objects. If that fails, the assignment fails.
If a file is moved in or out of <code>getOption("fftempdir")</code> the <code><a href="#topic+finalizer">finalizer</a></code>  is changed accordingly to 'delete' in <code>getOption("fftempdir")</code> and 'close' otherwise.
<br />
A <code>pattern</code> is an incomplete filename (optional path and optional filename-prefix) that is turned to filenames by
adding a random string using and optionally an extension from optionally an extension from <code>getOption("ffextension")</code> (see <code><a href="#topic+fftempfile">fftempfile</a></code>).
<code>filename&lt;-</code> exhibits R's standard behaviour of considering &quot;filename&quot; and &quot;./filename&quot; both to be located in <code><a href="base.html#topic+getwd">getwd</a></code>.
By constrast <code>pattern&lt;-</code> will create &quot;filename&quot; without path in <code>getOption("fftempdir")</code> and only &quot;./filename&quot; in <code><a href="base.html#topic+getwd">getwd</a></code>.
</p>


<h3>Value</h3>

<p><code>filename</code> and <code>pattern</code> return a character filename or pattern.
For <code><a href="#topic+ffdf">ffdf</a></code> returns a list with one filename element for each <code><a href="#topic+physical.ffdf">physical</a></code> component.
The assignment functions return the changed object, which will keep the change even without re-assigning the return-value
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+fftempfile">fftempfile</a></code>, <code><a href="#topic+finalizer">finalizer</a></code>, <code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+as.ff">as.ff</a></code>, <code><a href="#topic+as.ram">as.ram</a></code>, <code><a href="#topic+update.ff">update.ff</a></code>,  <code><a href="#topic+file.move">file.move</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  message("Neither giving pattern nor filename gives a random filename 
with extension ffextension in fftempdir")
  x &lt;- ff(1:12)
  finalizer(x)
  filename(x)
  message("Giving a pattern with just a prefix moves to a random filename 
beginning with the prefix in fftempdir")
  pattern(x) &lt;- "myprefix_"
  filename(x)
  message("Giving a pattern with a path and prefix moves to a random filename 
beginning with prefix in path (use . for getwd) ")
  pattern(x) &lt;- "./myprefix"
  filename(x)
  message("Giving a filename moves to exactly this filename and extension 
in the R-expected place) ")
  if (!file.exists("./myfilename.myextension")){
    filename(x) &lt;- "./myfilename.myextension"
    filename(x)
  }

  message("NOTE that the finalizer has changed from 'delete' to 'close': 
now WE are responsible for deleting the file - NOT the finalizer")
  finalizer(x)
  delete(x)
  rm(x)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='finalize'>
Call finalizer
</h2><span id='topic+finalize'></span><span id='topic+finalize.ff_pointer'></span><span id='topic+finalize.ff'></span><span id='topic+finalize.ffdf'></span>

<h3>Description</h3>

<p>This calls the currently assigned finalizer, either via R's finalization mechanism or manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalize(x, ...)
## S3 method for class 'ff_pointer'
finalize(x, ...)
## S3 method for class 'ff'
finalize(x, ...)
## S3 method for class 'ffdf'
finalize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalize_+3A_x">x</code></td>
<td>
<p> either an <code><a href="#topic+ff">ff</a></code> or <code><a href="#topic+ffdf">ffdf</a></code> object or an <code>ff_pointer</code>, see details </p>
</td></tr>
<tr><td><code id="finalize_+3A_...">...</code></td>
<td>
<p> currently ignored </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>finalize.ff_pointer</code> method is called from R after it had been passed to <code><a href="base.html#topic+reg.finalizer">reg.finalizer</a></code>. It will set the finalizer name to <code>NULL</code> and call the finalizer.
<br />
The <code>finalize</code> generic can be called manually on <code><a href="#topic+ff">ff</a></code> or <code><a href="#topic+ffdf">ffdf</a></code> objects. It will call the finalizer but not touch the finalizer name.
<br />
For more details see <code><a href="#topic+finalizer">finalizer</a></code>
</p>


<h3>Value</h3>

<p>returns whatever the called finalizer returns, for ffdf a list with the finalization returns of each physical component is returned.
</p>


<h3>Note</h3>

<p><code>finalize.ff_pointer</code> MUST NEVER be called manually - neither directly nor by calling the generic on an ff_pointer (could erroneously signal that there is no pending finalization lurking around)
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+finalizer">finalizer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12, pattern="./finalizerdemo")
  fnam &lt;- filename(x)
  finalizer(x)
  is.open(x)
  file.exists(fnam)

  finalize(x)

  finalizer(x)
  is.open(x)
  file.exists(fnam)

  delete(x)
  finalizer(x)
  is.open(x)
  file.exists(fnam)

  rm(x)
  gc()
</code></pre>

<hr>
<h2 id='finalizer'>
Get and set finalizer (name)
</h2><span id='topic+finalizer'></span><span id='topic+finalizer+3C-'></span><span id='topic+finalizer.ff'></span><span id='topic+finalizer+3C-.ff'></span>

<h3>Description</h3>

<p>The generic <code>finalizer</code> allows to get the current finalizer. The generic <code>finalizer&lt;-</code> allows to set the current finalizer or to change an existing finalizer (but not to remove a finalizer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalizer(x, ...)
finalizer(x, ...) &lt;- value
## S3 method for class 'ff'
finalizer(x, ...)
## S3 replacement method for class 'ff'
finalizer(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalizer_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ff">ff</a></code> object</p>
</td></tr>
<tr><td><code id="finalizer_+3A_value">value</code></td>
<td>
<p>the name of the new finalizer</p>
</td></tr>
<tr><td><code id="finalizer_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an <code><a href="#topic+ff">ff</a></code>  object is created a finalizer is assigned, it has the task to free ressources no longer needed, for example remove the ff file or free the C++ RAM associated with an open ff file.
The assigned finalizer depends on the location of the ff file:
if the file is created in <code>getOption(fftempdir)</code> it is considered considered temporary and has default finalizer <code><a href="#topic+delete.ff">delete</a></code>,
files created in other locations have default finalizer <code><a href="#topic+close.ff">close</a></code>.
The user can override this either by setting <code>options("fffinalizer")</code> or by using argument <code>finalizer</code> when creating single <code>ff</code> objects.
Available finalizer generics are &quot;close&quot;, &quot;delete&quot; and &quot;deleteIfOpen&quot;, available methods are <code><a href="#topic+close.ff">close.ff</a></code>, <code><a href="#topic+delete.ff">delete.ff</a></code> and <code><a href="#topic+deleteIfOpen.ff">deleteIfOpen.ff</a></code>.
<br />
In order to be able to change the finalizer before finalization, the finalizer is NOT directly passed to R's finalization mechanism <code><a href="base.html#topic+reg.finalizer">reg.finalizer</a></code> (an active finalizer can never be changed other than be executed).
Instead the NAME of the desired finalizer is stored in the ff object and <code><a href="#topic+finalize.ff_pointer">finalize.ff_pointer</a></code> is passed to <code>reg.finalizer</code>.
<code>finalize.ff_pointer</code> will at finalization-time determine the desired finalizer and call it.
<br />
There are two possible triggers for execution <code>finalize.ff_pointer</code>:
</p>

<ol>
<li><p> the garbage collection <code><a href="base.html#topic+gc">gc</a></code> following removal <code><a href="base.html#topic+rm">rm</a></code> of the ff object
</p>
</li>
<li><p> closing R if <code>finonexit</code> was <code>TRUE</code> at ff creation-time, determined by <code>options("fffinonexit")</code> and ff argument <code>finonexit</code>
</p>
</li></ol>

<p>Furthermore there are two possible triggers for calling the finalizer
</p>

<ol>
<li><p> an explicit call to <code><a href="#topic+finalize">finalize</a></code>
</p>
</li>
<li><p> an explicit call to one of the finalizers <code><a href="#topic+close.ff">close</a></code>, <code><a href="#topic+delete">delete</a></code> and <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code>
</p>
</li></ol>

<p>The user can define custom finalizers by creating a generic function like <code><a href="#topic+delete">delete</a></code>, a ff_pointer method like <code><a href="#topic+delete.ff_pointer">delete.ff_pointer</a></code> and a ff method for manual calls like <code><a href="#topic+delete.ff">delete.ff</a></code>. The user then is responsible to take care of two things
</p>

<ol>
<li><p> adequate freeing of ressources
</p>
</li>
<li><p> proper maintenance of the finalizer name in the ff object via <code><a href="#topic+physical.ff">physical</a>$finalizer</code>
</p>
</li></ol>

<p><code>is.null(finalizer(ff))</code> indicates NO active finalizer, i.e. no pending execution of <code>finalize.ff_pointer</code> lurking around after call of <code>reg.finalizer</code>.
This requires that
</p>

<ol>
<li><p> the <code>ff_pointer</code> method sets the finalizer name to <code>NULL</code>
</p>
</li>
<li><p> the <code>ff</code> may change a non-NULL finalizer name to a different name but not change it to NULL
</p>
</li></ol>



<h3>Value</h3>

<p><code>finalizer</code> returns the name of the active finalizer or <code>NULL</code> if no finalizer is active. <br />
<code>finalizer&lt;-</code> returns the changed ff object (reassignment of this return value not needed to keep the change).
If there was no pending call to <code><a href="#topic+finalize.ff_pointer">finalize.ff_pointer</a></code> (<code>is.null(finalizer(ff))</code>), <code>finalizer&lt;-</code> will create one by calling <code>reg.finalizer</code> with the current setting of <code><a href="#topic+physical.ff">physical</a>$finonexit</code>.
</p>


<h3>Note</h3>

<p>You can not assign NULL to an active finalizer using <code>finalizer&lt;-</code> because this would not stop R's finalization mechanism and would carry the risk of assiging MULTIPLE finalization tasks.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+finalize">finalize</a></code>, <code><a href="base.html#topic+reg.finalizer">reg.finalizer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12, pattern="./finalizerdemo")
  fnam &lt;- filename(x)
  finalizer(x)
  finalizer(x) &lt;- "delete"
  finalizer(x)
  rm(x)
  file.exists(fnam)
  gc()
  file.exists(fnam)
</code></pre>

<hr>
<h2 id='fixdiag'> Test for fixed diagonal </h2><span id='topic+fixdiag'></span><span id='topic+fixdiag+3C-'></span><span id='topic+fixdiag.ff'></span><span id='topic+fixdiag.default'></span><span id='topic+fixdiag.dist'></span>

<h3>Description</h3>

<p>Check if an object has fixed diagonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixdiag(x, ...)
fixdiag(x, ...) &lt;- value
## S3 method for class 'ff'
fixdiag(x, ...)
## Default S3 method:
fixdiag(x, ...)
## S3 method for class 'dist'
fixdiag(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixdiag_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="fixdiag_+3A_value">value</code></td>
<td>
<p> assignement value </p>
</td></tr>
<tr><td><code id="fixdiag_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff symmetric matrices can be declared to have fixed diagonal at creation time. Compatibility function <code>fixdiag.default</code> returns NULL, <code>fixdiag.dist</code> returns 0.
</p>


<h3>Value</h3>

<p>NULL or the scalar representing the fixed diagonal
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fixdiag">fixdiag</a></code>, <code><a href="#topic+ff">ff</a></code> 
, <code><a href="stats.html#topic+dist">dist</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  fixdiag(matrix(1:16, 4, 4))
  fixdiag(dist(rnorm(1:4)))
</code></pre>

<hr>
<h2 id='Forbidden_ffdf'>
Forbidden ffdf functions
</h2><span id='topic+physical+3C-.ffdf'></span><span id='topic+virtual+3C-.ffdf'></span><span id='topic+length+3C-.ffdf'></span><span id='topic+vmode+3C-.ffdf'></span><span id='topic+vw+3C-.ffdf'></span><span id='topic+vw.ffdf'></span>

<h3>Description</h3>

<p>Methods implemented just to prevent using them (because something inppropriate could be find by inheritance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'ffdf'
physical(x) &lt;- value
## S3 replacement method for class 'ffdf'
virtual(x) &lt;- value
## S3 replacement method for class 'ffdf'
length(x) &lt;- value
## S3 replacement method for class 'ffdf'
vmode(x, ...) &lt;- value
## S3 replacement method for class 'ffdf'
vw(x, ...) &lt;- value
## S3 method for class 'ffdf'
vw(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Forbidden_ffdf_+3A_x">x</code></td>
<td>
<p>an ffdf object</p>
</td></tr>
</table>

<hr>
<h2 id='geterror.ff'> Get error and error string </h2><span id='topic+geterror.ff'></span><span id='topic+geterrstr.ff'></span>

<h3>Description</h3>

<p>Get last error code and error string that occured on an ff object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geterror.ff(x)
geterrstr.ff(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geterror.ff_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>geterror.ff</code> returns an error integer code (no error = 0) and <code>geterrstr.ff</code> returns the error message (no error = &quot;no error&quot;).
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel, Daniel Adler (C++ back-end) </p>


<h3>See Also</h3>

  <p><code><a href="#topic+ff">ff</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  geterror.ff(x)
  geterrstr.ff(x)
  rm(x); gc()
</code></pre>

<hr>
<h2 id='getpagesize'>
Get page size information
</h2><span id='topic+getpagesize'></span><span id='topic+getdefaultpagesize'></span><span id='topic+getalignedpagesize'></span>

<h3>Description</h3>

<p>The function is used for obtaining the natural OS-specific page size in Bytes.
<code>getpagesize</code> returns the OS-specific page size in Bytes for memory mapped files, while <code>getdefaultpagesize</code> returns a suggested page size.
<code>getalignedpagesize</code> returns the pagesize as a multiple of the OS-specific page size in Bytes, which is the correct way to specify pagesize in ff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  getpagesize()
  getdefaultpagesize()
  getalignedpagesize(pagesize)
 </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getpagesize_+3A_pagesize">pagesize</code></td>
<td>
<p> a desired pagesize in bytes </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the page size in Bytes.
</p>


<h3>Author(s)</h3>

<p> Daniel Adler, Jens Oehlschlägel </p>


<h3>Examples</h3>

<pre><code class='language-R'>  getpagesize()
  getdefaultpagesize()
  getalignedpagesize(2000000)
  </code></pre>

<hr>
<h2 id='getset.ff'> Reading and writing vectors of values (low-level) </h2><span id='topic+getset.ff'></span><span id='topic+get.ff'></span><span id='topic+set.ff'></span>

<h3>Description</h3>

<p>The three functions <code>get.ff</code>, <code>set.ff</code> and <code>getset.ff</code> provide the simplest interface to access an ff file: getting and setting vector of values identified by positive subscripts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.ff(x, i)
set.ff(x, i, value, add = FALSE)
getset.ff(x, i, value, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getset.ff_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
<tr><td><code id="getset.ff_+3A_i">i</code></td>
<td>
<p> an index position within the ff file </p>
</td></tr>
<tr><td><code id="getset.ff_+3A_value">value</code></td>
<td>
<p> the value to write to position i </p>
</td></tr>
<tr><td><code id="getset.ff_+3A_add">add</code></td>
<td>
<p> TRUE if the value should rather increment than overwrite at the index position </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getset.ff</code> combines the effects of <code>get.ff</code> and <code>set.ff</code> in a single operation: it retrieves the old value at position <code>i</code> before changing it.
<code>getset.ff</code> will maintain <code><a href="bit.html#topic+na.count">na.count</a></code>.
</p>


<h3>Value</h3>

<p><code>get.ff</code> returns a vector, <code>set.ff</code> returns the 'changed' ff object (like all assignment functions do) and <code>getset.ff</code> returns the value at the subscript positions.
More precisely <code>getset.ff(x, i, value, add=FALSE)</code> returns the old values at the subscript positions <code>i</code> while <code>getset.ff(x, i, value, add=TRUE)</code> returns the incremented values at the subscript positions.
</p>


<h3>Note</h3>

 <p><code>get.ff</code>, <code>set.ff</code> and <code>getset.ff</code> are low level functions that do not support <code>ramclass</code> and <code>ramattribs</code> and thus will not give the expected result with <code>factor</code> and <code>POSIXct</code> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+readwrite.ff">readwrite.ff</a></code> for low-level access to contiguous chunks and <code><a href="#topic++5B.ff">[.ff</a></code> for high-level access </p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- ff(0, length=12)
 get.ff(x, 3L)
 set.ff(x, 3L, 1)
 x
 set.ff(x, 3L, 1, add=TRUE)
 x
 getset.ff(x, 3L, 1, add=TRUE)
 getset.ff(x, 3L, 1)
 x
 rm(x); gc()
</code></pre>

<hr>
<h2 id='hi'> Hybrid index class </h2><span id='topic+hi'></span><span id='topic+print.hi'></span><span id='topic+str.hi'></span>

<h3>Description</h3>

<p>Class for hybrid index representation, plain and rle-packed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hi(from, to, by = 1L, maxindex = NA, vw = NULL, pack = TRUE, NAs = NULL)
## S3 method for class 'hi'
print(x, ...)
## S3 method for class 'hi'
str(object, nest.lev=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hi_+3A_from">from</code></td>
<td>
<p> integer vector of lower sequence bounds </p>
</td></tr>
<tr><td><code id="hi_+3A_to">to</code></td>
<td>
<p> integer vector of upper sequence bounds </p>
</td></tr>
<tr><td><code id="hi_+3A_by">by</code></td>
<td>
<p> integer of stepsizes </p>
</td></tr>
<tr><td><code id="hi_+3A_maxindex">maxindex</code></td>
<td>
<p> maximum indep position (needed for negative indices) </p>
</td></tr>
<tr><td><code id="hi_+3A_vw">vw</code></td>
<td>
<p> virtual window information, see <code><a href="#topic+vw">vw</a></code> </p>
</td></tr>
<tr><td><code id="hi_+3A_pack">pack</code></td>
<td>
<p> FALSE to suppress rle-packing </p>
</td></tr>
<tr><td><code id="hi_+3A_nas">NAs</code></td>
<td>
<p> a vector of NA positions (not yet used) </p>
</td></tr>
<tr><td><code id="hi_+3A_x">x</code></td>
<td>
<p> an object of class 'hi' to be printed </p>
</td></tr>
<tr><td><code id="hi_+3A_object">object</code></td>
<td>
<p> an object of class 'hi' to be str'ed </p>
</td></tr>
<tr><td><code id="hi_+3A_nest.lev">nest.lev</code></td>
<td>
<p> current nesting level in the recursive calls to str </p>
</td></tr>
<tr><td><code id="hi_+3A_...">...</code></td>
<td>
<p> further arguments passed to the next method </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Class <code>hi</code> will represent index data either as a plain positive or negative index vector or as an rle-packed version thereof.
The current implementation switches from plain index positions <code>i</code> to rle-packed storage of <code>diff(i)</code> as soon as the compression ratio is 3 or higher.
Note that sequences shorter than 2 must never be packed (could cause C-side crash).
Furthermore hybrid indices are guaranteed to be sorted ascending, which helps <code><a href="#topic+ff">ff</a>s</code> access method avoiding to swap repeatedly over the same memory pages (or file positions).
</p>


<h3>Value</h3>

<p>A list of class 'hi' with components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> directly accessed by the C-code: the sorted index of class 'rlepack' as returned by <code><a href="bit.html#topic+rlepack">rlepack</a></code> </p>
</td></tr>
<tr><td><code>ix</code></td>
<td>
<p> NULL or positions to restore original order </p>
</td></tr>
<tr><td><code>re</code></td>
<td>
<p> logical scalar indicating if sequence was reversed from descending to ascending (in this case <code>is.null(ix)</code>) </p>
</td></tr>
<tr><td><code>minindex</code></td>
<td>
<p> directly accessed by the C-code: represents the lowest positive subscript to be enumerated in case of negative subscripts </p>
</td></tr>
<tr><td><code>maxindex</code></td>
<td>
<p> directly accessed by the C-code: represents the highest positive subscript to be enumerated in case of negative subscripts </p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p> number of subscripts, whether negative or positive, not the number of selected elements </p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p> NULL or dim &ndash; used by <code><a href="#topic+as.matrix.hi">as.matrix.hi</a></code> </p>
</td></tr>
<tr><td><code>dimorder</code></td>
<td>
<p> NULL or <code><a href="#topic+dimorder">dimorder</a></code> </p>
</td></tr>
<tr><td><code>symmetric</code></td>
<td>
<p> logical scalar indicating whether we have a symmetric matrix </p>
</td></tr>
<tr><td><code>fixdiag</code></td>
<td>
<p> logical scalar indicating whether we have a fixed diagonal (can only be true for symmetric matrices) </p>
</td></tr>
<tr><td><code>vw</code></td>
<td>
<p> virtual window information <code><a href="#topic+vw">vw</a></code> </p>
</td></tr>
<tr><td><code>NAs</code></td>
<td>
<p> NULL or NA positions as returned by <code><a href="bit.html#topic+rlepack">rlepack</a></code> </p>
</td></tr>
</table>


<h3>Note</h3>

 <p><code>hi</code> defines the class structure, however usually <code><a href="#topic+as.hi">as.hi</a></code> is used to acturally Hybrid Index Preprocessing for <code><a href="#topic+ff">ff</a></code> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.hi">as.hi</a></code> for coercion, <code><a href="bit.html#topic+rlepack">rlepack</a></code>, <code><a href="bit.html#topic+intrle">intrle</a></code>, <code><a href="bit.html#topic+maxindex">maxindex</a></code>, <code><a href="bit.html#topic+poslength">poslength</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  hi(c(1, 11, 29), c(9, 19, 21), c(1,1,-2))
  as.integer(hi(c(1, 11, 29), c(9, 19, 21), c(1,1,-2)))
</code></pre>

<hr>
<h2 id='hiparse'> Hybrid Index, parsing </h2><span id='topic+hiparse'></span>

<h3>Description</h3>

<p><code>hiparse</code> implements the parsing done in Hybrid Index Preprocessing in order to avoid RAM for expanding index expressions.
<em>Not to be called directly</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hiparse(x, envir, first = NA_integer_, last = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hiparse_+3A_x">x</code></td>
<td>
<p> an index expression, precisely: <code><a href="base.html#topic+call">call</a></code> </p>
</td></tr>
<tr><td><code id="hiparse_+3A_envir">envir</code></td>
<td>
<p> the environemtn in which to evaluate components of the index expression </p>
</td></tr>
<tr><td><code id="hiparse_+3A_first">first</code></td>
<td>
<p> first index position found so far </p>
</td></tr>
<tr><td><code id="hiparse_+3A_last">last</code></td>
<td>
<p> last index position found so far </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This primitive parser recognises the following tokens: numbers like 1, symbols like x, the colon sequence operator <code><a href="base.html#topic++3A">:</a></code> and the concat operator <code><a href="base.html#topic+c">c</a></code>.
<code>hiparse</code> will <code><a href="base.html#topic+Recall">Recall</a></code> until the index expression is parsed or an unknown token is found.
If an unknown token is found, <code>hiparse</code> evluates it, inspects it and either accepts it or throws an error, catched by <code><a href="#topic+as.hi.call">as.hi.call</a></code>,
which falls back to evaluating the index expression and dispatching (again) an appropriate <code><a href="#topic+as.hi">as.hi</a></code> method.
Reasons for suspending the parsing: if the inspected token is of class 'hi', 'ri', 'bit', 'bitwhich', 'is.logical', 'is.character', 'is.matrix' or has length&gt;16.
</p>


<h3>Value</h3>

<p>undefined (and redefined as needed by <code><a href="#topic+as.hi.call">as.hi.call</a></code>)
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hi">hi</a></code>, <code><a href="#topic+as.hi.call">as.hi.call</a></code> </p>

<hr>
<h2 id='Internal_ffdf'>
Internal ffdf functions
</h2><span id='topic+get_nvw'></span>

<h3>Description</h3>

<p>Internal ffdf functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nvw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Internal_ffdf_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'get_nvw' gives the length and vw of an object (or its first dimension, if it is not a vector)
</p>

<hr>
<h2 id='is.ff'> Test for class ff </h2><span id='topic+is.ff'></span>

<h3>Description</h3>

<p>checks if x inherits from class &quot;ff&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ff(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ff_+3A_x">x</code></td>
<td>
<p> any object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="base.html#topic+inherits">inherits</a></code>, <code><a href="#topic+as.ff">as.ff</a></code>, <code><a href="#topic+is.ffdf">is.ffdf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  is.ff(integer())
</code></pre>

<hr>
<h2 id='is.ffdf'> Test for class ff </h2><span id='topic+is.ffdf'></span>

<h3>Description</h3>

<p>checks if x inherits from class &quot;ffdf&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ffdf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.ffdf_+3A_x">x</code></td>
<td>
<p> any object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="base.html#topic+inherits">inherits</a></code>, <code><a href="#topic+as.ffdf">as.ffdf</a></code>, <code><a href="#topic+is.ff">is.ff</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  is.ffdf(integer())
</code></pre>

<hr>
<h2 id='is.open'> Test if object is opened </h2><span id='topic+is.open'></span><span id='topic+is.open.ff'></span><span id='topic+is.open.ffdf'></span><span id='topic+is.open.ff_pointer'></span>

<h3>Description</h3>

<p>Test whether an ff or ffdf object or a <code>ff_pointer</code> is opened.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.open(x, ...)
## S3 method for class 'ff'
is.open(x, ...)
## S3 method for class 'ffdf'
is.open(x, ...)
## S3 method for class 'ff_pointer'
is.open(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.open_+3A_x">x</code></td>
<td>
<p> an <code><a href="#topic+ff">ff</a></code> or <code><a href="#topic+ffdf">ffdf</a></code> object </p>
</td></tr>
<tr><td><code id="is.open_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff objects open automatically if accessed while closed.
For ffdf objects we test all of their <code><a href="#topic+physical.ffdf">physical</a></code> components including their <code><a href="#topic+row.names.ffdf">row.names</a></code> if they are <code><a href="#topic+is.ff">is.ff</a></code>
</p>


<h3>Value</h3>

<p>TRUE or FALSE (or NA if not all components of an ffdf object are opened or closed)
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+is.readonly">is.readonly</a></code>, <code><a href="#topic+open.ff">open.ff</a></code>, <code><a href="#topic+close.ff">close.ff</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  is.open(x)
  close(x)
  is.open(x)
  rm(x); gc()
</code></pre>

<hr>
<h2 id='is.readonly'> Get readonly status </h2><span id='topic+is.readonly'></span><span id='topic+is.readonly.ff'></span>

<h3>Description</h3>

<p>Get readonly status of an ff object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.readonly(x, ...)
## S3 method for class 'ff'
is.readonly(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.readonly_+3A_x">x</code></td>
<td>
 <p><code>x</code> </p>
</td></tr>
<tr><td><code id="is.readonly_+3A_...">...</code></td>
<td>
 <p><code>...</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff objects can be created/opened with <code>readonly=TRUE</code>.
After each opening of the ff file readonly status is stored in the <code><a href="#topic+physical.ff">physical</a></code> attributes and serves as the default for the next opening.
Thus querying a closed ff object gives the last readonly status.
</p>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+open.ff">open.ff</a></code>, <code><a href="#topic+physical.ff">physical</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  is.readonly(x)
  close(x)
  open(x, readonly=TRUE)
  is.readonly(x)
  close(x)
  is.readonly(x)
  rm(x)
</code></pre>

<hr>
<h2 id='is.sorted'> Getting and setting 'is.sorted' physical attribute </h2><span id='topic+is.sorted.default'></span><span id='topic+is.sorted+3C-.default'></span>

<h3>Description</h3>

<p>Functions to mark an ff or ram object as 'is.sorted' and query this. Responsibility to maintain this attribute is with the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
is.sorted(x, ...)
## Default S3 replacement method:
is.sorted(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sorted_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="is.sorted_+3A_...">...</code></td>
<td>
<p> ignored </p>
</td></tr>
<tr><td><code id="is.sorted_+3A_value">value</code></td>
<td>
<p> NULL (to remove the 'is.sorted' attribute) or TRUE or FALSE </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sorting is slow, see <code><a href="base.html#topic+sort">sort</a></code>.
Checking whether an object is sorted can avoid unnessary sorting &ndash; see <code><a href="base.html#topic+is.unsorted">is.unsorted</a></code>, <code><a href="bit.html#topic+intisasc">intisasc</a></code> &ndash; but still takes too much time with large objects stored on disk.
Thus it makes sense to maintain an attribute, that tells us whether sorting can be skipped.
Note that &ndash; though you change it yourself &ndash; <code>is.sorted</code> is a <code><a href="#topic+physical.ff">physical</a></code> attribute of an object,
because it represents an attribute of the <em>data</em>, which is shared between different <code><a href="#topic+physical.ff">virtual</a></code> views of the object.
</p>


<h3>Value</h3>

<p>TRUE (if set to TRUE) or FALSE (if set to NULL or FALSE)
</p>


<h3>Note</h3>

<p><code>ff</code> will set <code>is.sorted(x) &lt;- FALSE</code> if <code><a href="bit.html#topic+clone">clone</a></code> or <code><a href="#topic+length+3C-.ff">length&lt;-.ff</a></code> have increased length.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+is.ordered.ff">is.ordered.ff</a></code> for testing factor levels, <code><a href="base.html#topic+is.unsorted">is.unsorted</a></code> for testing the data, <code><a href="bit.html#topic+intisasc">intisasc</a></code> for a quick version thereof, <code><a href="bit.html#topic+na.count">na.count</a></code> for yet another <code><a href="#topic+physical.ff">physical</a></code> attribute </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:12
  is.sorted(x) &lt;- !( is.na(is.unsorted(x)) || is.unsorted(x))
  is.sorted(x)
  x[1] &lt;- 100L
  message("don't forget to maintain once it's no longer TRUE")
  is.sorted(x) &lt;- FALSE
  message("check whether as 'is.sorted' attribute is maintained")
  !is.null(physical(x)$is.sorted)
  message("remove the 'is.sorted' attribute")
  is.sorted(x) &lt;- NULL
  message("NOTE that querying 'is.sorted' still returns FALSE")
  is.sorted(x)
</code></pre>

<hr>
<h2 id='length.ff'> Getting and setting length </h2><span id='topic+length.ff'></span><span id='topic+length+3C-.ff'></span>

<h3>Description</h3>

<p>Gets and sets length of ff objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
length(x)
## S3 replacement method for class 'ff'
length(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.ff_+3A_x">x</code></td>
<td>
<p> object to query </p>
</td></tr>
<tr><td><code id="length.ff_+3A_value">value</code></td>
<td>
<p> new object length </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Changing the length of ff objects is only allowed if no <code><a href="#topic+vw">vw</a></code> is used.
Changing the length of ff objects will remove any <code><a href="#topic+dim.ff">dim.ff</a></code> and <code><a href="#topic+dimnames.ff">dimnames.ff</a></code> attribute.
Changing the length of ff objects will remove any <code><a href="bit.html#topic+na.count">na.count</a></code> or <code><a href="bit.html#topic+is.sorted">is.sorted</a></code> attribute and warn about this.
New elements are usually zero, but it may depend on OS and filesystem what they really are.
If you want standard R behaviour: filling with NA ,you need to do this yourself.
As an exception to this rule, ff objects with <code><a href="#topic+names.ff">names.ff</a></code> will be filled with NA's automatically,
and the length of the names will be adjusted (filled with position numbers where needed, which can easily consume a lot of RAM,
therefore removing 'names' will help to faster increase length without RAM problems).
</p>


<h3>Value</h3>

<p>Integer scalar
</p>


<h3>Note</h3>

<p>Special care needs to be taken with regard ff objects that represent factors.
For ff factors based on UNSIGNED <code><a href="#topic+vmode">vmode</a>s</code>, new values of zero are silently interpreted as the first factor level.
For ff factors based on SIGNED <code><a href="#topic+vmode">vmode</a>s</code>, new values of zero result in illegal factor levels.
See <code><a href="#topic+nrow+3C-">nrow&lt;-</a></code>.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+length">length</a></code>, <code><a href="#topic+maxlength">maxlength</a></code>, <code><a href="#topic+file.resize">file.resize</a></code>, <code><a href="#topic+dim.ff">dim</a></code>, <code><a href="#topic+physical.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  maxlength(x)
  length(x)
  length(x) &lt;- 10
  maxlength(x)
  length(x)
  length(x) &lt;- 16
  maxlength(x)
  length(x)
  rm(x); gc()
</code></pre>

<hr>
<h2 id='length.ffdf'>
Getting length of a ffdf dataframe
</h2><span id='topic+length.ffdf'></span>

<h3>Description</h3>

<p>Getting &quot;length&quot; (number of columns) of a ffdf dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffdf'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.ffdf_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ffdf">ffdf</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p> integer number of columns</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dim.ffdf">dim.ffdf</a></code>, <code><a href="#topic+length.ff">length.ff</a></code>, <code><a href="#topic+ffdf">ffdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  length(as.ffdf(data.frame(a=1:26, b=letters, stringsAsFactors = TRUE)))
  gc()
</code></pre>

<hr>
<h2 id='length.hi'> Hybrid Index, querying </h2><span id='topic+length.hi'></span><span id='topic+poslength.hi'></span><span id='topic+maxindex.hi'></span>

<h3>Description</h3>

<p>Functions to query some index attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hi'
length(x)
## S3 method for class 'hi'
maxindex(x, ...)
## S3 method for class 'hi'
poslength(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.hi_+3A_x">x</code></td>
<td>
<p> an object of class <code><a href="#topic+hi">hi</a></code> </p>
</td></tr>
<tr><td><code id="length.hi_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>length.hi</code> returns the number of the subsript elements in the index (even if they are negative).
By contrast <code><a href="bit.html#topic+poslength">poslength</a></code> returns the number of selected elements (which for negative indices is <code>maxindex(x) - length(unique(x))</code>).
<code><a href="bit.html#topic+maxindex">maxindex</a></code> returns the highest possible index position.
</p>


<h3>Value</h3>

<p>an integer scalar
</p>


<h3>Note</h3>

<p> duplicated negative indices are removed </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hi">hi</a></code>, <code><a href="#topic+as.hi">as.hi</a></code>, <code><a href="#topic+length.ff">length.ff</a></code>, <code><a href="base.html#topic+length">length</a></code>, <code><a href="bit.html#topic+poslength">poslength</a></code>, <code><a href="bit.html#topic+maxindex">maxindex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  length(as.hi(-1, maxindex=12))
  poslength(as.hi(-1, maxindex=12))
  maxindex(as.hi(-1, maxindex=12))
  message("note that")
  length(as.hi(c(-1, -1), maxindex=12))
  length(as.hi(c(1,1), maxindex=12))
</code></pre>

<hr>
<h2 id='levels.ff'> Getting and setting factor levels </h2><span id='topic+levels.ff'></span><span id='topic+levels+3C-.ff'></span><span id='topic+is.factor'></span><span id='topic+is.factor.default'></span><span id='topic+is.factor.ff'></span><span id='topic+is.ordered'></span><span id='topic+is.ordered.default'></span><span id='topic+is.ordered.ff'></span>

<h3>Description</h3>

<p><code>levels.ff&lt;-</code> sets factor levels, <code>levels.ff</code> gets factor levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
levels(x)
## S3 replacement method for class 'ff'
levels(x) &lt;- value
 is.factor(x)
 is.ordered(x)
## S3 method for class 'ff'
is.factor(x)
## S3 method for class 'ff'
is.ordered(x)
## Default S3 method:
is.factor(x)
## Default S3 method:
is.ordered(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels.ff_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
<tr><td><code id="levels.ff_+3A_value">value</code></td>
<td>
<p> the new factor levels, if NA is an allowed level it needs to be given explicitely, nothing is excluded </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ff object must have an integer vmode, see <code><a href="#topic+.rammode">.rammode</a></code>.
If the mode is unsigned &ndash; see <code><a href="#topic+.vunsigned">.vunsigned</a></code> &ndash; the first factor level is coded with 0L instead of 1L in order to maximize the number of codable levels.
Usually the internal ff coding &ndash; see <code><a href="#topic+ram2ffcode">ram2ffcode</a></code> &ndash; is invisible to the user: when subscripting from an ff factor, unsigend codings are automatically converted to R's standard factor codes starting at 1L.
However, you need to be aware of the internal ff coding in two situtations. <br />
1. If you convert an ff integer object to an ff factor object and vice versa by assigning levels and <code>is.null(oldlevels)!=is.null(newlevels)</code>.  <br />
2. Assigning data that does not match any level usually results in NA, however, in unsigned types there is no NA and all unknown data are mapped to the first level.
</p>


<h3>Value</h3>

<p><code>levels</code> returns a character vector of levels (possibly including <code>as.cha racter(NA)</code>).
</p>


<h3>Note</h3>

<p> When levels as assigned to an ff object that formerly had not levels, we assign automatically <code><a href="#topic+ramclass">ramclass</a></code> == &quot;factor&quot;. If you want to change to an ordered factor, use <code><a href="#topic+virtual.ff">virtual</a>$ramclass &lt;- c("ordered", "factor")</code> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ramclass">ramclass</a></code>, <code><a href="base.html#topic+factor">factor</a></code>, <code><a href="#topic+physical.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  message("--- create an ff factor including NA as last level")
  x &lt;- ff("a", levels=c(letters, NA), length=99)
  message('    we expect a warning because "A" is an unknown level')
  x[] &lt;- c("a", NA,"A")
  x
  levels(x)

  message("--- create an ff ordered factor")
  x &lt;- ff(letters, levels=letters, ramclass=c("ordered","factor"), length=260)
  x
  levels(x)

  message("    make it a non-ordered factor")
  virtual(x)$ramclass &lt;- "factor"
  x
  rm(x); gc()

 ## Not run: 
  message("--- create an unsigned quad factor")
  x &lt;- ff(c("A","T","G","C"), levels=c("A","T","G","C"), vmode="quad", length=100)
  x
  message("  0:3 coding usually invisible to the user")
  unclass(x[1:4])
  message("    after removing levels, the 0:3 coding becomes visible to the user")
  message("    we expect a warning here")
  levels(x) &lt;- NULL
  x[1:4]
  rm(x); gc()
 
## End(Not run)

</code></pre>

<hr>
<h2 id='LimWarn'> ff Limitations and Warnings </h2><span id='topic+LimWarn'></span>

<h3>Description</h3>

<p>This help page lists the currently known limitations of package ff,
as well as differences between ff and ram methods.
</p>


<h3>Automatic file removal</h3>

<p>Remind that not giving parameter <code>ff(filename=)</code> will result in a temporary file in <code>fftempdir</code> with 'delete' finalizer,
while giving parameter <code>ff(filename=)</code> will result in a permanent file with 'close' finalizer.
Do avoid setting <code>setwd(getOption("fftempdir"))</code>!
Make sure you really understand the implications of automatic unlinking of getOption(&quot;fftempdir&quot;) <code><a href="base.html#topic+.onUnload">.onUnload</a></code>,
of finalizer choice and of finalizing behaviour at the end of R sessions as defaulted in getOption(&quot;fffinonexit&quot;).
<b>Otherwise you might experience 'unexpected' losses of files and data.</b>
</p>


<h3>Size of objects</h3>

<p>ff objects can have length zero and are limited to <code>.Machine$integer.max</code> elements. We have not yet ported the R code to support 64bit double indices (in essence 52 bits integer) although the C++ back-end has been prepared for this.
Furthermore filesize limitations of the OS apply, see <code><a href="#topic+ff">ff</a></code>.
</p>


<h3>Side effects</h3>

<p>In contrast to standard R expressions, ff expressions violate the functional programming logic and are called for their side effects.
This is also true for ram compatibility functions <code><a href="#topic+swap.default">swap.default</a></code>, and <code><a href="#topic+add.default">add.default</a></code>.
</p>


<h3>Hybrid copying semantics</h3>

<p>If you modify a copy of an ff object, changes of data (<code><a href="#topic+Extract.ff">[&lt;-</a></code>) and of <code><a href="#topic+physical.ff">physical</a></code> attributes
will be shared, but changes in <code><a href="#topic+physical.ff">virtual</a></code> and class attributes will not.
</p>


<h3>Limits of compatibility between ff and ram objects</h3>

<p>If it's not too big, you can move an ff object completely into R's RAM through <code><a href="#topic+as.ram">as.ram</a></code>.
However, you should watch out for three limitations:
</p>

<ol>
<li><p> Ram objects don't have hybrid copying semantics; changes to a copy of a ram object will never change the original ram object
</p>
</li>
<li><p> Assigning values to a ram object can easily upgrade to a higher <code><a href="base.html#topic+storage.mode">storage.mode</a></code>. This will create conflicts with the
<code><a href="#topic+vmode">vmode</a></code> of the ram object, which goes undetected until you try to write back to disk through <code><a href="#topic+as.ff">as.ff</a></code>.
</p>
</li>
<li><p> Writing back to disk with <code><a href="#topic+as.ff">as.ff</a></code> under the same filename requires that the original ff object has been deleted
(or at least closed if you specify parameter <code>overwrite=TRUE</code>).
</p>
</li></ol>



<h3>Index expressions</h3>

<p>ff index expressions do not allow zeros and NAs, see see <code><a href="#topic++5B.ff">[.ff</a></code> and see <code><a href="#topic+as.hi">as.hi</a></code>
</p>


<h3>Availablility of bydim parameter</h3>

<p>Parameter <code>bydim</code> is only available in ff access methods, see <code><a href="#topic++5B.ff">[.ff</a></code>
</p>


<h3>Availablility of add parameter</h3>

<p>Parameter <code>add</code> is only available in ff access methods, see <code><a href="#topic++5B.ff">[.ff</a></code>
</p>


<h3>Compatibility of swap and add</h3>

<p>If index expressions contain duplicated positions, the ff and ram methods for <code><a href="#topic+swap">swap</a></code>
and <code><a href="#topic+add">add</a></code> will behave differently, see <code><a href="#topic+swap">swap</a></code>.
</p>


<h3>Definition of [[ and [[&lt;-</h3>

<p>You should consider the behaviour of <code><a href="#topic++5B+5B.ff">[[.ff</a></code> and 
<code><a href="#topic++5B+5B+3C-.ff">[[&lt;-.ff</a></code> as undefined and not use them in programming.
Currently they are shortcuts to <code><a href="#topic+get.ff">get.ff</a></code> and <code><a href="#topic+set.ff">set.ff</a></code>, 
which unlike <code><a href="#topic+Extract.ff">[.ff</a></code> and <code><a href="#topic+Extract.ff">[&lt;-.ff</a></code>
do not support <code><a href="base.html#topic+factor">factor</a></code> and <code><a href="base.html#topic+POSIXct">POSIXct</a></code>, 
nor <code><a href="#topic+dimorder">dimorder</a></code> or virtual windows <code><a href="#topic+vw">vw</a></code>.
In contrast to the standard methods, <code><a href="#topic++5B+5B.ff">[[.ff</a></code> and 
<code><a href="#topic++5B+5B+3C-.ff">[[&lt;-.ff</a></code> only accepts positive integer index positions.
The definition of <code><a href="#topic++5B+5B.ff">[[.ff</a></code> and <code><a href="#topic++5B+5B+3C-.ff">[[&lt;-.ff</a></code> may be 
changed in the future.
</p>


<h3>Multiple vector interpretation in arrays </h3>

<p>R objects have always standard <code><a href="#topic+dimorder">dimorder</a> seq_along(dim)</code>.
In case of non-standard dimorder (see <code><a href="#topic+dimorderStandard">dimorderStandard</a></code>)
the vector sequence of array elements in R and in the ff file differs.
To access array elements in file order, you can use <code><a href="#topic+getset.ff">getset.ff</a></code>, <code><a href="#topic+readwrite.ff">readwrite.ff</a></code>
or copy the ff object and set <code>dim(ff)&lt;-NULL</code> to get a vector view into the ff object
(using <code>[</code> dispatches the vector method <code><a href="#topic++5B.ff">[.ff</a></code>).
To access the array elements in R standard dimorder you simply use <code>[</code> which dispatches
to <code><a href="#topic++5B.ff_array">[.ff_array</a></code>. Note that in this case <code><a href="#topic+as.hi">as.hi</a></code> will unpack the complete index, see next section.
</p>


<h3>RAM expansion of index expressions</h3>

<p>Some index expressions do not consume RAM due to the <code><a href="#topic+hi">hi</a></code> representation.
For example <code>1:n</code> will almost consume no RAM however large n.
However, some index expressions are expanded and require to <code><a href="bit.html#topic+maxindex">maxindex</a>(i) * .rambytes["integer"]</code> bytes,
either because the sorted sequence of index positions cannot be rle-packed efficiently
or because <code><a href="#topic+hiparse">hiparse</a></code> cannot yet parse such expression and falls back to evaluating/expanding the index expression.
If the index positions are not sorted, the index will be expanded and a second vector is needed to store the information for re-ordering,
thus the index requires <code>2 * <a href="bit.html#topic+maxindex">maxindex</a>(i) * .rambytes["integer"]</code> bytes.
</p>


<h3>RAM expansion when recycling assigment values</h3>

<p>Some assignment expressions do not consume RAM for recycling. For example <code>x[1:n] &lt;- 1:k</code>
will not consume RAM however large is n compared to k, when x has standard <code><a href="#topic+dimorder">dimorder</a></code>.
However, if <code>length(value)&gt;1</code>, assignment expressions with non-ascending index positions trigger recycling the value R-side to the full index length.
This will happen if <code><a href="#topic+dimorder">dimorder</a></code> does not match parameter <code>bydim</code> or if the index is not sorted in ascending order.
</p>


<h3>Byteorder imcompatibility</h3>

<p>Note that ff files cannot been transferred between systems with different byteorder.
</p>

<hr>
<h2 id='matcomb'> Array: make matrix indices from row and columns positions </h2><span id='topic+matcomb'></span>

<h3>Description</h3>

<p>create matrix indices from row and columns positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matcomb(r, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matcomb_+3A_r">r</code></td>
<td>
<p> integer vector of row positions </p>
</td></tr>
<tr><td><code id="matcomb_+3A_c">c</code></td>
<td>
<p> integer vector of column positions  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>rows rotate faster than columns
</p>


<h3>Value</h3>

<p>a k by 2 matrix of matrix indices where <code> k = length(r) * length(c) </code>
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="base.html#topic+row">row</a></code>, <code><a href="base.html#topic+col">col</a></code> , <code><a href="base.html#topic+expand.grid">expand.grid</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  matcomb(1:3, 1:4)
  matcomb(2:3, 2:4)
</code></pre>

<hr>
<h2 id='matprint'> Print beginning and end of big matrix </h2><span id='topic+matprint'></span><span id='topic+print.matprint'></span>

<h3>Description</h3>

<p>Print beginning and end of big matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matprint(x, maxdim = c(16, 16), digits = getOption("digits"))
## S3 method for class 'matprint'
print(x, quote = FALSE, right = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matprint_+3A_x">x</code></td>
<td>
<p> a <code><a href="base.html#topic+matrix">matrix</a></code> </p>
</td></tr>
<tr><td><code id="matprint_+3A_maxdim">maxdim</code></td>
<td>
<p> max number of rows and columns for printing </p>
</td></tr>
<tr><td><code id="matprint_+3A_digits">digits</code></td>
<td>
<p> see <code><a href="base.html#topic+format">format</a></code> </p>
</td></tr>
<tr><td><code id="matprint_+3A_quote">quote</code></td>
<td>
<p> see <code><a href="base.html#topic+print">print</a></code> </p>
</td></tr>
<tr><td><code id="matprint_+3A_right">right</code></td>
<td>
<p> see <code><a href="base.html#topic+print">print</a></code> </p>
</td></tr>
<tr><td><code id="matprint_+3A_...">...</code></td>
<td>
<p> see <code><a href="base.html#topic+print">print</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class 'matprint' with components
</p>
<table>
<tr><td><code>subscript</code></td>
<td>
<p> a list with four vectors of subscripts: row begin, column begin, row end, column end  </p>
</td></tr>
<tr><td><code>example</code></td>
<td>
<p> the extracted example matrix as.characer including seperators </p>
</td></tr>
<tr><td><code>rsep</code></td>
<td>
<p> logical scalar indicating whether row seperator is included </p>
</td></tr>
<tr><td><code>csep</code></td>
<td>
<p> logical scalar indicating whether column seperator is included </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+vecprint">vecprint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  matprint(matrix(1:(300*400), 300, 400))
</code></pre>

<hr>
<h2 id='maxffmode'> Lossless vmode coercability </h2><span id='topic+maxffmode'></span>

<h3>Description</h3>

<p><code>maxffmode</code> returns the lowest <code><a href="#topic+vmode">vmode</a></code> that can absorb all input vmodes without data loss
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxffmode(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxffmode_+3A_...">...</code></td>
<td>
<p> one or more vectors of vmodes </p>
</td></tr>
</table>


<h3>Value</h3>

<p>the smallest <code><a href="#topic+.ffmode">.ffmode</a></code> which can absorb the input vmodes without data loss
</p>


<h3>Note</h3>

<p>The output can be larger than any of the inputs (if the highest input vmode is an integer type without NA and any other input requires NA).
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+.vcoerceable">.vcoerceable</a></code>, <code><a href="#topic+.ffmode">.ffmode</a></code>, <code><a href="#topic+ffconform">ffconform</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>   maxffmode(c("quad","logical"), "ushort")
</code></pre>

<hr>
<h2 id='maxlength'> Get physical length of an ff or ram object </h2><span id='topic+maxlength'></span><span id='topic+maxlength.ff'></span><span id='topic+maxlength.default'></span>

<h3>Description</h3>

<p><code>maxlength</code> returns the physical length of an ff or ram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxlength(x, ...)
## S3 method for class 'ff'
maxlength(x, ...)
## Default S3 method:
maxlength(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxlength_+3A_x">x</code></td>
<td>
<p> ff or ram object </p>
</td></tr>
<tr><td><code id="maxlength_+3A_...">...</code></td>
<td>
<p> additional arguments (not used) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer scalar
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+length.ff">length.ff</a></code>, <code><a href="bit.html#topic+maxindex">maxindex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  length(x) &lt;- 10
  length(x)
  maxlength(x)
  x
  rm(x); gc()
</code></pre>

<hr>
<h2 id='mismatch'> Test for recycle mismatch </h2><span id='topic+mismatch'></span><span id='topic+ymismatch'></span>

<h3>Description</h3>

<p><code>mismatch</code> will return TRUE if the larger of nx,ny is not a multiple of the other and the other is &gt;0 (see arithmetic.c).
<code>ymismatch</code> will return TRUE if nx is not a multiple of ny and ny&gt;0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mismatch(nx, ny)
ymismatch(nx, ny)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mismatch_+3A_nx">nx</code></td>
<td>
<p> x length </p>
</td></tr>
<tr><td><code id="mismatch_+3A_ny">ny</code></td>
<td>
<p> y length </p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ffconform">ffconform</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ymismatch(4,0)
  ymismatch(4,2)
  ymismatch(4,3)
  ymismatch(2,4)
  mismatch(4,0)
  mismatch(4,2)
  mismatch(4,3)
  mismatch(2,4)
</code></pre>

<hr>
<h2 id='na.count'> Getting and setting 'na.count' physical attribute </h2><span id='topic+na.count.ff'></span><span id='topic+na.count.default'></span><span id='topic+na.count+3C-.ff'></span><span id='topic+na.count+3C-.default'></span>

<h3>Description</h3>

<p>The 'na.count' physical attribute gives the current number of NAs if properly initialized and properly maintained, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
na.count(x, ...)
## Default S3 method:
na.count(x, ...)
## S3 replacement method for class 'ff'
na.count(x, ...) &lt;- value
## Default S3 replacement method:
na.count(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.count_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="na.count_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
<tr><td><code id="na.count_+3A_value">value</code></td>
<td>
<p> NULL (to remove the 'na.count' attribute) or TRUE to activate or an integer value </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'na.count' feature is activated by assigning the current number of NAs to <code>na.count(x) &lt;- currentNA</code> and deactivated by assigning NULL.
The 'na.count' feature is maintained by the, <code><a href="#topic+getset.ff">getset.ff</a></code>, <code><a href="#topic+readwrite.ff">readwrite.ff</a></code> and <code><a href="#topic+swap">swap</a></code>,
other ff methods for writing &ndash; <code><a href="#topic+set.ff">set.ff</a></code>, <code><a href="#topic++5B+5B+3C-.ff">[[&lt;-.ff</a></code>, <code><a href="#topic+write.ff">write.ff</a></code>, <code><a href="#topic+Extract.ff">[&lt;-.ff</a></code> &ndash; will stop if 'na.count' is activated.
The functions <code>na.count</code> and <code>na.count&lt;-</code> are generic.
For ram objects, the default method for <code>na.count</code> calculates the number of NAs on the fly, thus no maintenance restrictions apply.
</p>


<h3>Value</h3>

<p>NA (if set to NULL or NA) or an integer value otherwise
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel, Daniel Adler (C++ back-end) </p>


<h3>See Also</h3>

 <p><code><a href="#topic+getset.ff">getset.ff</a></code>, <code><a href="#topic+readwrite.ff">readwrite.ff</a></code> and <code><a href="#topic+swap">swap</a></code> for methods that support maintenance of 'na.count', <code><a href="base.html#topic+NA">NA</a></code>, <code><a href="bit.html#topic+is.sorted">is.sorted</a></code> for yet another <code><a href="#topic+physical.ff">physical</a></code> attribute </p>


<h3>Examples</h3>

<pre><code class='language-R'>  message("--- ff examples ---")
  x &lt;- ff(1:12)
  na.count(x)
  message("activate the 'na.count' physical attribute and set the current na.count manually")
  na.count(x) &lt;- 0L
  message("add one NA with a method that maintains na.count")
  swap(x, NA, 1)
  na.count(x)
  message("remove the 'na.count' physical attribute (and stop automatic maintenance)")
  na.count(x) &lt;- NULL
  message("activate the 'na.count' physical attribute and have ff automatically 
calculate the current na.count")
  na.count(x) &lt;- TRUE
  na.count(x)
  message("--- ram examples ---")
  x &lt;- 1:12
  na.count(x)
  x[1] &lt;- NA
  message("activate the 'na.count' physical attribute and have R automatically 
calculate the current na.count")
  na.count(x) &lt;- TRUE
  na.count(x)
  message("remove the 'na.count' physical attribute (and stop automatic maintenance)")
  na.count(x) &lt;- NULL
  na.count(x)
  rm(x); gc()
</code></pre>

<hr>
<h2 id='names.ff'> Getting and setting names </h2><span id='topic+names.ff'></span><span id='topic+names+3C-.ff'></span><span id='topic+names.ff_array'></span><span id='topic+names+3C-.ff_array'></span>

<h3>Description</h3>

<p>For <code>ff_vector</code>s you can set names, though this is not recommended for large objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'ff'
names(x)
  ## S3 replacement method for class 'ff'
names(x) &lt;- value
  ## S3 method for class 'ff_array'
names(x)
  ## S3 replacement method for class 'ff_array'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.ff_+3A_x">x</code></td>
<td>
<p> a ff vector </p>
</td></tr>
<tr><td><code id="names.ff_+3A_value">value</code></td>
<td>
<p> a character vector </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code><a href="#topic+vw">vw</a></code> is set, <code>names.ff</code> returns the appropriate part of the names, but you can't set names while <code>vw</code> is set.
<code>names.ff_array</code>
returns NULL and setting names for
<code>ff_array</code>s is not allowed,
but setting <code><a href="#topic+dimnames.ff">dimnames</a></code> is.
</p>


<h3>Value</h3>

<p><code>names</code> returns a character vector (or NULL)
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+names">names</a></code>, <code><a href="#topic+dimnames.ff">dimnames.ff_array</a></code>, <code><a href="#topic+vw">vw</a></code>, <code><a href="#topic+physical.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:26, names=letters)
  names(x)
  names(x) &lt;- LETTERS
  names(x)
  names(x) &lt;- NULL
  names(x)
  rm(x); gc()
</code></pre>

<hr>
<h2 id='nrowAssign'>
Assigning the number of rows or columns
</h2><span id='topic+nrow+3C-'></span><span id='topic+ncol+3C-'></span>

<h3>Description</h3>

<p>Function <code>nrow&lt;-</code> assigns <code><a href="base.html#topic+dim">dim</a></code> with a new number of rows. <br />
Function <code>ncol&lt;-</code> assigns <code><a href="base.html#topic+dim">dim</a></code> with a new number of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow(x) &lt;- value
ncol(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrowAssign_+3A_x">x</code></td>
<td>
<p> a object that has <code><a href="base.html#topic+dim">dim</a></code> AND can be assigned ONE new dimension </p>
</td></tr>
<tr><td><code id="nrowAssign_+3A_value">value</code></td>
<td>
<p> the new size of the assigned dimension </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently only asssigning new rows to <code><a href="#topic+ffdf">ffdf</a></code> is supported.
The new ffdf rows are not initialized (usually become zero).
NOTE that
</p>


<h3>Value</h3>

<p>The object with a modified dimension
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffdf">ffdf</a></code>, <code><a href="#topic+dim.ffdf">dim.ffdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  a &lt;- as.ff(1:26)
  b &lt;- as.ff(factor(letters)) # vmode="integer"
  c &lt;- as.ff(factor(letters), vmode="ubyte")
  df &lt;- ffdf(a,b,c)
  nrow(df) &lt;- 2*26
  df
  message("NOTE that the new rows have silently the first level 'a' for UNSIGNED vmodes")
  message("NOTE that the new rows have an illegal factor level &lt;0&gt; for SIGNED vmodes")
  message("It is your responsibility to put meaningful content here")
  message("As an example we replace the illegal zeros by NA")
  df$b[27:52] &lt;- NA
  df

  rm(a,b,c,df); gc()
</code></pre>

<hr>
<h2 id='open.ff'> Opening an ff file </h2><span id='topic+open.ff'></span><span id='topic+open.ffdf'></span>

<h3>Description</h3>

<p><code>open.ff</code> opens an ff file, optionally marking it readonly and optionally specifying a caching scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'ff'
open(con, readonly = FALSE, pagesize = NULL, caching = NULL, assert = FALSE, ...)
 ## S3 method for class 'ffdf'
open(con, readonly = FALSE, pagesize = NULL, caching = NULL, assert = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="open.ff_+3A_con">con</code></td>
<td>
<p> an <code><a href="#topic+ff">ff</a></code> or <code><a href="#topic+ffdf">ffdf</a></code> object </p>
</td></tr>
<tr><td><code id="open.ff_+3A_readonly">readonly</code></td>
<td>
 <p><code>readonly</code> </p>
</td></tr>
<tr><td><code id="open.ff_+3A_pagesize">pagesize</code></td>
<td>
<p> number of bytes to use as pagesize or NULL to take the pagesize stored in the <code><a href="#topic+physical.ff">physical</a></code> attribute of the ff object, see <code><a href="#topic+getalignedpagesize">getalignedpagesize</a></code> </p>
</td></tr>
<tr><td><code id="open.ff_+3A_caching">caching</code></td>
<td>
<p> one of 'mmnoflush' or 'mmeachflush', see <code><a href="#topic+ff">ff</a></code> </p>
</td></tr>
<tr><td><code id="open.ff_+3A_assert">assert</code></td>
<td>
<p> setting this to TRUE will give a message if the ff was not open already </p>
</td></tr>
<tr><td><code id="open.ff_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff objects will be opened automatically when accessing their content and the file is still closed.
Opening ffdf objects will open all of their <code><a href="#topic+physical.ffdf">physical</a></code> components including their <code><a href="#topic+row.names.ffdf">row.names</a></code> if they are <code><a href="#topic+is.ff">is.ff</a></code>
</p>


<h3>Value</h3>

<p>TRUE if object could be opened, FALSE if it was opened already (or NA if not all components of an ffdf returned FALSE or TRUE on opening)
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+close.ff">close.ff</a></code>, <code><a href="#topic+delete">delete</a></code>, <code><a href="#topic+deleteIfOpen">deleteIfOpen</a></code>, <code><a href="#topic+getalignedpagesize">getalignedpagesize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  close(x)
  is.open(x)
  open(x)
  is.open(x)
  close(x)
  is.open(x)
  x[]
  is.open(x)
  y &lt;- x
  close(y)
  is.open(x)
  rm(x,y); gc()
</code></pre>

<hr>
<h2 id='pagesize'> Pagesize of ff object </h2><span id='topic+pagesize'></span><span id='topic+pagesize.ff'></span>

<h3>Description</h3>

<p>Returns current pagesize of ff object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pagesize(x, ...)
## S3 method for class 'ff'
pagesize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pagesize_+3A_x">x</code></td>
<td>
<p> an <code><a href="#topic+ff">ff</a></code> object </p>
</td></tr>
<tr><td><code id="pagesize_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer number of bytes
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+getpagesize">getpagesize</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  pagesize(x)
</code></pre>

<hr>
<h2 id='physical.ff'> Getting and setting physical and virtual attributes of ff objects </h2><span id='topic+physical.ff'></span><span id='topic+physical+3C-.ff'></span><span id='topic+virtual.ff'></span><span id='topic+virtual+3C-.ff'></span>

<h3>Description</h3>

<p>Functions for getting and setting physical and virtual attributes of ff objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
physical(x)
## S3 method for class 'ff'
virtual(x)
## S3 replacement method for class 'ff'
physical(x) &lt;- value
## S3 replacement method for class 'ff'
virtual(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="physical.ff_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
<tr><td><code id="physical.ff_+3A_value">value</code></td>
<td>
<p> a list with named elements </p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff objects have physical and virtual attributes, which have different copying semantics:
physical attributes are shared between copies of ff objects while virtual attributes might differ between copies.
<code><a href="#topic+as.ram">as.ram</a></code> will retain some physical and virtual atrributes in the ram clone,
such that <code><a href="#topic+as.ff">as.ff</a></code> can restore an ff object with the same attributes.
</p>


<h3>Value</h3>

<p><code>physical</code> and <code>virtual</code> returns a list with named elements
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+physical">physical</a></code>, <code><a href="#topic+physical.ffdf">physical.ffdf</a></code>, <code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+as.ram">as.ram</a></code>; <br />
<code><a href="bit.html#topic+is.sorted">is.sorted</a></code> and <code><a href="bit.html#topic+na.count">na.count</a></code> for applications of physical attributes; <br />
<code><a href="#topic+levels.ff">levels.ff</a></code> and <code><a href="#topic+ramattribs">ramattribs</a></code> for applications of virtual attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:12)
  x
  physical(x)
  virtual(x)
  y &lt;- as.ram(x)
  physical(y)
  virtual(y)
  rm(x,y); gc()
</code></pre>

<hr>
<h2 id='physical.ffdf'>
Getting physical and virtual attributes of ffdf objects
</h2><span id='topic+physical.ffdf'></span><span id='topic+virtual.ffdf'></span>

<h3>Description</h3>

<p>Functions for getting physical and virtual attributes of ffdf objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffdf'
physical(x)
## S3 method for class 'ffdf'
virtual(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="physical.ffdf_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ffdf">ffdf</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+ffdf">ffdf</a></code> objects enjoy a complete decoupling of virtual behaviour from physical storage.
The physical component is simply a (potentially named) list where each element represents an atomic ff vector or matrix.
The virtual component is itself a dataframe, each row of which defines a column of the ffdf through a mapping to the physical component.
</p>


<h3>Value</h3>

<p>'physical.ffdf' returns a <code><a href="base.html#topic+list">list</a></code> with atomic ff objects. <br />
'virtual.ffdf' returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the following columns <br />
</p>
<table>
<tr><td><code>VirtualVmode</code></td>
<td>
<p>the <code><a href="#topic+vmode">vmode</a></code> of this row (=ffdf column)</p>
</td></tr>
<tr><td><code>AsIs</code></td>
<td>
<p>logical defining the <code><a href="base.html#topic+AsIs">AsIs</a></code> status of this row (=ffdf column)</p>
</td></tr>
<tr><td><code>VirtualIsMatrix</code></td>
<td>
<p>logical defining whether this row (=ffdf column) represents a matrix</p>
</td></tr>
<tr><td><code>PhysicalIsMatrix</code></td>
<td>
<p>logical reporting whether the corresponding physical element is a matrix</p>
</td></tr>
<tr><td><code>PhysicalElementNo</code></td>
<td>
<p>integer identifying the corresponding physical element</p>
</td></tr>
<tr><td><code>PhysicalFirstCol</code></td>
<td>
<p>integer identifying the first column of the corresponding physical element (1 if it is not a matrix)</p>
</td></tr>
<tr><td><code>PhysicalLastCol</code></td>
<td>
<p>integer identifying the last column of the corresponding physical element (1 if it is not a matrix)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffdf">ffdf</a></code>, <code><a href="#topic+physical.ff">physical</a></code>, <code><a href="#topic+virtual.ff">virtual</a></code>, <code><a href="#topic+vmode.ffdf">vmode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:2
  y &lt;- matrix(1:4, 2, 2)
  z &lt;- matrix(1:4, 2, 2)

  message("Here the y matrix is first converted to single columns by data.frame, 
then those columns become ff")
  d &lt;- as.ffdf(data.frame(x=x, y=y, z=I(z)))
  physical(d)
  virtual(d)

  message("Here the y matrix is first converted to ff, and then stored still as matrix 
in the ffdf object (although virtually treated as columns of ffdf)")
  d &lt;- ffdf(x=as.ff(x), y=as.ff(y), z=I(as.ff(z)))
  physical(d)
  virtual(d)

  message("Apply the usual methods extracting physical attributes")
  lapply(physical(d), filename)
  lapply(physical(d), vmode)
  message("And don't confuse with virtual vmode")
  vmode(d)

  rm(d); gc()
</code></pre>

<hr>
<h2 id='print.ff'> Print and str methods </h2><span id='topic+print.ff'></span><span id='topic+print.ffdf'></span><span id='topic+print.ff_vector'></span><span id='topic+print.ff_matrix'></span><span id='topic+str.ff'></span><span id='topic+str.ffdf'></span>

<h3>Description</h3>

<p>printing ff objects and compactly showing their structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
print(x, ...)
## S3 method for class 'ff_vector'
print(x, maxlength = 16, ...)
## S3 method for class 'ff_matrix'
print(x, maxdim = c(16, 16), ...)
## S3 method for class 'ff'
str(object, nest.lev=0, ...)
## S3 method for class 'ffdf'
str(object, nest.lev=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ff_+3A_x">x</code></td>
<td>
<p> a ff object </p>
</td></tr>
<tr><td><code id="print.ff_+3A_object">object</code></td>
<td>
<p> a ff object </p>
</td></tr>
<tr><td><code id="print.ff_+3A_nest.lev">nest.lev</code></td>
<td>
<p> current nesting level in the recursive calls to str </p>
</td></tr>
<tr><td><code id="print.ff_+3A_maxlength">maxlength</code></td>
<td>
<p> max number of elements to print from an <code>ff_vector</code> </p>
</td></tr>
<tr><td><code id="print.ff_+3A_maxdim">maxdim</code></td>
<td>
<p> max number of elements to print from each dimension from an <code>ff_array</code> </p>
</td></tr>
<tr><td><code id="print.ff_+3A_...">...</code></td>
<td>
<p> further arguments to print </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print methods just print a few exmplary elements from the beginning and end of the dimensions.
</p>


<h3>Value</h3>

<p><code>invisible()</code>
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="utils.html#topic+str">str</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:10000)
  x
  print(x, maxlength=30)
  dim(x) &lt;- c(100,100)
  x
  rm(x); gc()
</code></pre>

<hr>
<h2 id='ram2ffcode'> Factor codings </h2><span id='topic+ram2ffcode'></span><span id='topic+ram2ramcode'></span>

<h3>Description</h3>

<p>Function <code>ram2ffcode</code> creates the <em>internal</em> factor codes used by ff to store factor levels. Function <code>ram2ramcode</code> is a compatibility function used instead if <code>RETURN_FF==FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ram2ffcode(value, levels, vmode)
ram2ramcode(value, levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ram2ffcode_+3A_value">value</code></td>
<td>
<p> factor or character vector of values </p>
</td></tr>
<tr><td><code id="ram2ffcode_+3A_levels">levels</code></td>
<td>
<p> character vector of factor levels </p>
</td></tr>
<tr><td><code id="ram2ffcode_+3A_vmode">vmode</code></td>
<td>
<p> one of the integer vmodes in <code><a href="#topic+.rammode">.rammode</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Factors stored in unsigned vmodes <code><a href="#topic+.vunsigned">.vunsigned</a></code> have their first level represented as 0L instead of 1L.
</p>


<h3>Value</h3>

<p>A vector of integer values representing the correspnding factor levels.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+factor">factor</a></code>, <code><a href="#topic+levels.ff">levels.ff</a></code>, <code><a href="#topic+vmode">vmode</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ram2ffcode(letters, letters, vmode="byte")
 ram2ffcode(letters, letters, vmode="ubyte")
 ram2ffcode(letters, letters, vmode="nibble")
 message('note that ram2ffcode() does NOT warn that vmode="nibble" cannot store 26 levels')
</code></pre>

<hr>
<h2 id='ramattribs'> Get ramclass and ramattribs </h2><span id='topic+ramclass'></span><span id='topic+ramclass.ff'></span><span id='topic+ramclass.default'></span><span id='topic+ramclass_excludes'></span><span id='topic+ramattribs'></span><span id='topic+ramattribs.ff'></span><span id='topic+ramattribs.default'></span><span id='topic+ramattribs_excludes'></span>

<h3>Description</h3>

<p>Functions <code>ramclass</code> and <code>ramattribs</code> return the respective virtual attributes, that determine which class (and attributes) an ff object receives when subscripted (or coerced) to ram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ramclass(x, ...)
## S3 method for class 'ff'
ramclass(x, ...)
## Default S3 method:
ramclass(x, ...)
ramattribs(x, ...)
## S3 method for class 'ff'
ramattribs(x, ...)
## Default S3 method:
ramattribs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ramattribs_+3A_x">x</code></td>
<td>
 <p><code>x</code> </p>
</td></tr>
<tr><td><code id="ramattribs_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ramclass</code> and <code>ramattribs</code> provide a general mechanism to store atomic classes in ff objects,
for example <code><a href="base.html#topic+factor">factor</a></code> &ndash; see <code><a href="#topic+levels.ff">levels.ff</a></code> &ndash; and <code><a href="base.html#topic+DateTimeClasses">POSIXct</a></code>, see the example.
</p>


<h3>Value</h3>

<p><code>ramclass</code> returns a character vector with classnames and <code>ramattribs</code> returns a list with names elemens just like <code><a href="base.html#topic+attributes">attributes</a></code>.
The vectors <code>ramclass_excludes</code> and <code>ramattribs_excludes</code> name those attributes, which are not exported from ff to ram objects when using <code><a href="#topic+as.ram">as.ram</a></code>.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="#topic+physical.ff">virtual</a></code>, <code><a href="#topic+as.ram">as.ram</a></code>, <code><a href="#topic+levels.ff">levels.ff</a></code>, <code><a href="base.html#topic+attributes">attributes</a></code>, <code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(as.POSIXct(as.POSIXlt(Sys.time(), "GMT")), length=12)
  x
  ramclass(x)
  ramattribs(x)
  class(x[])
  attributes(x[])
  virtual(x)$ramattribs$tzone = NULL
  attributes(x[])
  rm(x); gc()
</code></pre>

<hr>
<h2 id='ramorder.default'>
Sorting: order R vector in-RAM and in-place
</h2><span id='topic+ramorder.default'></span><span id='topic+mergeorder.default'></span><span id='topic+radixorder.default'></span><span id='topic+keyorder.default'></span><span id='topic+shellorder.default'></span>

<h3>Description</h3>

<p>Function <code>ramorder</code> will order the input vector in-place (without making a copy) and return the number of NAs found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ramorder(x, i, has.na = TRUE, na.last = TRUE, decreasing = FALSE
, stable = TRUE, optimize = c("time", "memory"), VERBOSE = FALSE, ...)
## Default S3 method:
mergeorder(x, i, has.na = TRUE, na.last = TRUE, decreasing = FALSE, ...)
## Default S3 method:
radixorder(x, i, has.na = TRUE, na.last = TRUE, decreasing = FALSE, ...)
## Default S3 method:
keyorder(x, i, keyrange=range(x, na.rm=has.na), has.na = TRUE, na.last = TRUE
, decreasing = FALSE, ...)
## Default S3 method:
shellorder(x, i, has.na = TRUE, na.last = TRUE, decreasing = FALSE, stabilize=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ramorder.default_+3A_x">x</code></td>
<td>

<p>an atomic R vector
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_i">i</code></td>
<td>

<p>a integer vector with a permuation of positions in x (you risk a crash if you violate this)
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_keyrange">keyrange</code></td>
<td>

<p>an integer vector with two values giving the smallest and largest possible value in x, note that you should give this explicitely for best performance, relying on the default needs one pass over the data to determine the range
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar telling ramorder whether the vector might contain <code>NA</code>s.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_na.last">na.last</code></td>
<td>

<p>boolean scalar telling ramorder whether to order <code>NA</code>s last or first.
<em>Note</em> that 'boolean' means that there is no third option <code>NA</code> as in <code><a href="base.html#topic+order">order</a></code>
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_decreasing">decreasing</code></td>
<td>

<p>boolean scalar telling ramorder whether to order increasing or decreasing
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_stable">stable</code></td>
<td>

<p>set to false if stable ordering is not needed (may enlarge the set of ordering methods considered)
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_optimize">optimize</code></td>
<td>

<p>by default ramorder optimizes for 'time' which requires more RAM, set to 'memory'
to minimize RAM requirements and sacrifice speed
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_verbose">VERBOSE</code></td>
<td>

<p>cat some info about chosen method
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_stabilize">stabilize</code></td>
<td>

<p>Set to <code>TRUE</code> for stabilizing the result of shellorder (for equal keys the order values will be sorted, this only works if <code>i=1:n</code>)
to minimize RAM requirements and sacrifice speed
</p>
</td></tr>
<tr><td><code id="ramorder.default_+3A_...">...</code></td>
<td>

<p>ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ramorder</code> is a front-end to a couple of single-threaded ordering algorithms
that have been carefully implemented to be fast with and without <code>NA</code>s.
<br />
The default is a mergeorder algorithm without copying (Sedgewick 8.4) for integer and double data
which requires 2x the RAM of its input vector (character or complex data are not supported).
Mergeorder is fast, stable with a reliable runtime.
<br />
For integer data longer than a certain length we improve on mergeorder by using a faster LSD
radixorder algorithm (Sedgewick 10.5) that uses 2x the RAM of its input vector plus 65536+1 integers.
<br />
For booleans, logicals, integers at or below the resolution of smallint and for factors below a certain number of levels
we use a key-index order instead of mergeorder or radix order
(note that R has a (slower) key-index order in <code><a href="base.html#topic+sort.list">sort.list</a></code> available with confusingly named <code>method='radix'</code>
but the standard <code><a href="base.html#topic+order">order</a></code> does not leverage it for factors (2-11.1).
If you call <code>keyorder</code> directly, you should provide a known 'keyrange' directly to obtain the full speed.
<br />
Finally the user can request a order method that minimizes memory use at the price of longer computation time
with <code>optimize='memory'</code> &ndash; currently a shellorder.
</p>


<h3>Value</h3>

<p>integer scalar with the number of NAs. This is always 0 with has.na=FALSE
</p>


<h3>Note</h3>

<p>This function is called for its side-effects and breaks the functional programming paradigm. Use with care.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>References</h3>

<p>Robert Sedgewick (1997). Algorithms in C, Third edition. Addison-Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>, <code><a href="#topic+fforder">fforder</a></code>, <code><a href="#topic+dforder">dforder</a></code>, <code><a href="bit.html#topic+ramsort">ramsort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   n &lt;- 50
   x &lt;- sample(c(NA, NA, 1:26), n, TRUE)
   order(x)
   i &lt;- 1:n
   ramorder(x, i)
   i
   x[i]

   ## Not run: 
      message("Note how the datatype influences sorting speed")
      n &lt;- 1e7
      x &lt;- sample(1:26, n, TRUE)

      y &lt;- as.double(x)
      i &lt;- 1:n
      system.time(ramorder(y, i))

      y &lt;- as.integer(x)
      i &lt;- 1:n
      system.time(ramorder(y, i))

      y &lt;- as.short(x)
      i &lt;- 1:n
      system.time(ramorder(y, i))

      y &lt;- factor(letters)[x]
      i &lt;- 1:n
      system.time(ramorder(y, i))
   
## End(Not run)
</code></pre>

<hr>
<h2 id='ramsort.default'>
Sorting: Sort R vector in-RAM and in-place
</h2><span id='topic+ramsort.default'></span><span id='topic+mergesort.default'></span><span id='topic+radixsort.default'></span><span id='topic+keysort.default'></span><span id='topic+shellsort.default'></span>

<h3>Description</h3>

<p>Function <code>ramsort</code> will sort the input vector in-place (without making a copy) and return the number of NAs found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ramsort(x, has.na = TRUE, na.last = TRUE, decreasing = FALSE
, optimize = c("time", "memory"), VERBOSE = FALSE, ...)
## Default S3 method:
mergesort(x, has.na = TRUE, na.last = TRUE, decreasing = FALSE, ...)
## Default S3 method:
radixsort(x, has.na = TRUE, na.last = TRUE, decreasing = FALSE, ...)
## Default S3 method:
keysort(x, keyrange=range(x, na.rm=has.na), has.na = TRUE
, na.last = TRUE, decreasing = FALSE, ...)
## Default S3 method:
shellsort(x, has.na = TRUE, na.last = TRUE, decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ramsort.default_+3A_x">x</code></td>
<td>

<p>an atomic R vector
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_keyrange">keyrange</code></td>
<td>

<p>an integer vector with two values giving the smallest and largest possible value in x, note that you should give this explicitely for best performance, relying on the default needs one pass over the data to determine the range
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar telling ramsort whether the vector might contain <code>NA</code>s.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_na.last">na.last</code></td>
<td>

<p>boolean scalar telling ramsort whether to sort <code>NA</code>s last or first.
<em>Note</em> that 'boolean' means that there is no third option <code>NA</code> as in <code><a href="base.html#topic+sort">sort</a></code>
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_decreasing">decreasing</code></td>
<td>

<p>boolean scalar telling ramsort whether to sort increasing or decreasing
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_optimize">optimize</code></td>
<td>

<p>by default ramsort optimizes for 'time' which requires more RAM,
set to 'memory' to minimize RAM requirements and sacrifice speed
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_verbose">VERBOSE</code></td>
<td>

<p>cat some info about chosen method
</p>
</td></tr>
<tr><td><code id="ramsort.default_+3A_...">...</code></td>
<td>

<p>ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ramsort</code> is a front-end to a couple of single-threaded sorting algorithms
that have been carefully implemented to be fast with and without <code>NA</code>s.
<br />
The default is a mergesort algorithm without copying (Sedgewick 8.4) for integer and double data
which requires 2x the RAM of its input vector (character or complex data are not supported).
Mergesort is fast, stable with a reliable runtime.
<br />
For integer data longer than a certain length we improve on mergesort by using a faster LSD
radixsort algorithm (Sedgewick 10.5) that uses 2x the RAM of its input vector plus 65536+1 integers.
<br />
For booleans, logicals, integers at or below the resolution of smallint and for factors below a certain number of levels
we use a key-index sort instead of mergesort or radix sort
(note that R has a (slower) key-index sort in <code><a href="base.html#topic+sort.list">sort.list</a></code> available with confusingly named <code>method='radix'</code>
but the standard <code><a href="base.html#topic+sort">sort</a></code> does not leverage it for factors (2-11.1).
If you call <code>keysort</code> directly, you should provide a known 'keyrange' directly to obtain the full speed.
<br />
Finally the user can request a sort method that minimizes memory use at the price of longer computation time
with <code>optimize='memory'</code> &ndash; currently a shellsort.
</p>


<h3>Value</h3>

<p>integer scalar with the number of NAs. This is always 0 with has.na=FALSE
</p>


<h3>Note</h3>

<p>This function is called for its side-effects and breaks the functional programming paradigm. Use with care.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>References</h3>

<p>Robert Sedgewick (1997). Algorithms in C, Third edition. Addison-Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sort">sort</a></code>, <code><a href="#topic+ffsort">ffsort</a></code>, <code><a href="#topic+dfsort">dfsort</a></code>, <code><a href="bit.html#topic+ramorder">ramorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   n &lt;- 50
   x &lt;- sample(c(NA, NA, 1:26), n, TRUE)
   sort(x)
   ramsort(x)
   x

   ## Not run: 
      message("Note how the datatype influences sorting speed")
      n &lt;- 5e6
      x &lt;- sample(1:26, n, TRUE)

      y &lt;- as.double(x)
      system.time(ramsort(y))

      y &lt;- as.integer(x)
      system.time(ramsort(y))

      y &lt;- as.short(x)
      system.time(ramsort(y))

      y &lt;- as.factor(letters)[x]
      system.time(ramsort(y))
   
## End(Not run)
</code></pre>

<hr>
<h2 id='read.table.ffdf'>
Importing csv files into ff data.frames
</h2><span id='topic+read.table.ffdf'></span><span id='topic+read.csv.ffdf'></span><span id='topic+read.csv2.ffdf'></span><span id='topic+read.delim.ffdf'></span><span id='topic+read.delim2.ffdf'></span>

<h3>Description</h3>

<p>Function <code>read.table.ffdf</code> reads separated flat files into <code><a href="#topic+ffdf">ffdf</a></code> objects, very much like (and using) <code><a href="utils.html#topic+read.table">read.table</a></code>.
It can also work with any convenience wrappers like <code><a href="utils.html#topic+read.csv">read.csv</a></code> and provides its own convenience wrapper (e.g. <code>read.csv.ffdf</code>) for R's usual wrappers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.table.ffdf(
  x = NULL
, file, fileEncoding = ""
, nrows = -1, first.rows = NULL, next.rows = NULL
, levels = NULL, appendLevels = TRUE
, FUN = "read.table", ...
, transFUN = NULL
, asffdf_args = list()
, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE
)
read.csv.ffdf(...)
read.csv2.ffdf(...)
read.delim.ffdf(...)
read.delim2.ffdf(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.table.ffdf_+3A_x">x</code></td>
<td>

<p>NULL or an optional <code><a href="#topic+ffdf">ffdf</a></code> object to which the read records are appended.
If this is provided, it defines crucial features that are otherwise determnined during the 'first' chunk of reading:
<code><a href="#topic+vmode.ffdf">vmode</a>s</code>, <code><a href="#topic+dimnames.ffdf">colnames</a></code>, <code>colClasses</code>, sequence of predefined <code><a href="#topic+levels.ff">levels</a></code>.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_file">file</code></td>
<td>

<p>the name of the file which the data are to be read from.
Each row of the table appears as one line of the file.  If it does
not contain an <em>absolute</em> path, the file name is
<em>relative</em> to the current working directory,
<code><a href="base.html#topic+getwd">getwd</a>()</code>. Tilde-expansion is performed where supported.
</p>
<p>Alternatively, <code>file</code> can be a readable text-mode
<code><a href="base.html#topic+connection">connection</a></code> (which will be opened for reading if
necessary, and if so <code><a href="base.html#topic+close">close</a></code>d (and hence destroyed) at
the end of the function call).
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_fileencoding">fileEncoding</code></td>
<td>

<p>character string: if non-empty declares the
encoding used on a file (not a connection) so the character data can
be re-encoded.  See <code><a href="base.html#topic+file">file</a></code>.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of rows to read in (includes first.rows in case a 'first' chunk is read)
Negative and other invalid values are ignored.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_first.rows">first.rows</code></td>
<td>

<p>integer: number of rows to be read in the first chunk, see details. Default is the value given at <code>next.rows</code> or <code>1e3</code> otherwise.
Ignored if <code>x</code> is given.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_next.rows">next.rows</code></td>
<td>

<p>integer: number of rows to be read in further chunks, see details.
By default calculated as <code>BATCHBYTES %/% sum(.rambytes[<a href="#topic+vmode">vmode</a>(x)])</code>
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_levels">levels</code></td>
<td>

<p>NULL or an optional list, each element named with col.names of factor columns specifies the <code><a href="#topic+levels.ff">levels</a></code>
Ignored if <code>x</code> is given.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_appendlevels">appendLevels</code></td>
<td>

<p>logical.
A vector of permissions to expand <code><a href="#topic+levels.ff">levels</a></code> for factor columns.
Recycled as necessary, or if the logical vector is named, unspecified values are taken to be <code>TRUE</code>.
Ignored during processing of the 'first' chunk
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_fun">FUN</code></td>
<td>

<p>character: name of a function that is called for reading each chunk, see <code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="utils.html#topic+read.csv">read.csv</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_...">...</code></td>
<td>

<p>further arguments, passed to <code>FUN</code> in <code>read.table.ffdf</code>, or passed to <code>read.table.ffdf</code> in the convenience wrappers
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_transfun">transFUN</code></td>
<td>

<p>NULL or a function that is called on each data.frame chunk after reading with <code>FUN</code> and before further processing (for filtering, transformations etc.)
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_asffdf_args">asffdf_args</code></td>
<td>

<p>further arguments passed to <code><a href="#topic+as.ffdf">as.ffdf</a></code> when converting the <code><a href="base.html#topic+data.frame">data.frame</a></code> of the first chunk to <code><a href="#topic+ffdf">ffdf</a></code>.
Ignored if <code>x</code> is given.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>integer: bytes allowed for the size of the <code><a href="base.html#topic+data.frame">data.frame</a></code> storing the result of reading one chunk. Default <code>getOption("ffbatchbytes")</code>.
</p>
</td></tr>
<tr><td><code id="read.table.ffdf_+3A_verbose">VERBOSE</code></td>
<td>

<p>logical: TRUE to verbose timings for each processed chunk (default FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read.table.ffdf</code> has been designed to read very large (many rows) separated flatfiles in row-chunks
and store the result in a <code><a href="#topic+ffdf">ffdf</a></code> object on disk, but quickly accessible via <code><a href="#topic+ff">ff</a></code> techniques.
<br />
The first chunk is read with a default of 1000 rows, for subsequent chunks the number of rows is calculated to not require more RAM than <code>getOption("ffbatchbytes")</code>.
The following could be indications to change the parameter <code>first.rows</code>:
</p>

<ol>
<li><p> set <code>first.rows=-1</code> to read the complete file in one go (requires enough RAM)
</p>
</li>
<li><p> set <code>first.rows</code> to a smaller number if the pre-allocation of RAM for the first chunk with parameter <code>nrows</code> in <code><a href="utils.html#topic+read.table">read.table</a></code> is too large, i.e. with many columns on machine with little RAM.
</p>
</li>
<li><p> set <code>first.rows</code> to a larger number if you expect better factor level ordering (factor levels are sorted in the first chunk, but not at subsequent chunks, however, factor level ordering can be fixed later, see below).
</p>
</li></ol>

<p>By default the <code><a href="#topic+ffdf">ffdf</a></code> object is created on the fly at the end of reading the 'first' chunk, see argument <code>first.rows</code>.
The creation of the <code><a href="#topic+ffdf">ffdf</a></code> object is done via <code><a href="#topic+as.ffdf">as.ffdf</a></code> and can be finetuned by passing argument <code>asffdf_args</code>.
Even more control is possible by passing in a <code><a href="#topic+ffdf">ffdf</a></code> object as argument <code>x</code> to which the read records are appended.
<br />
<code>read.table.ffdf</code> has been designed to behave as much like <code><a href="utils.html#topic+read.table">read.table</a></code> as possible. Hoever, note the following differences:
</p>

<ol>
<li><p> Arguments 'colClasses' and 'col.names' are now enforced also during 'next.rows' chunks.
For example giving <code>colClasses=NA</code> will force that no colClasses are derived from the <code>first.rows</code> respective from the <code><a href="#topic+ffdf">ffdf</a></code> object in parameter <code>x</code>.
</p>
</li>
<li><p> colClass 'ordered' is allowed and will create an <code><a href="base.html#topic+ordered">ordered</a></code> factor
</p>
</li>
<li><p> character vector are not supported, character data must be read as one of the following colClasses: 'Date', 'POSIXct', 'factor, 'ordered'.
By default character columns are read as factors.
Accordingly arguments 'as.is' and 'stringsAsFactors' are not allowed.
</p>
</li>
<li><p> the sequence of <code><a href="#topic+levels.ff">levels.ff</a></code> from chunked reading can depend on chunk size: by default new levels found on a chunk are appended to the levels found in previous chunks, no attempt is made to sort and recode the levels during chunked processing, levels can be sorted and recoded most efficiently <em>after</em> all records have been read using <code><a href="#topic+sortLevels">sortLevels</a></code>.
</p>
</li>
<li><p> the default for argument 'comment.char' is <code>""</code> even for those FUN that have a different default. However, explicit specification of 'comment.char' will have priority.
</p>
</li></ol>



<h3>Value</h3>

<p>An <code><a href="#topic+ffdf">ffdf</a></code> object. If created during the 'first' chunk pass, it will have one <code><a href="#topic+physical.ffdf">physical</a></code> component per <code><a href="#topic+virtual.ffdf">virtual</a></code> column.
</p>


<h3>Note</h3>

<p>Note that using the 'skip' argument still requires to read the file from beginning in order to count the lines to be skipped.
If you first read part of the file in order to understand its structure and then want to continue,
a more efficient solution that using 'skip' is opening a <code><a href="base.html#topic+file">file</a></code> <code><a href="base.html#topic+connection">connection</a></code> and pass that to argument 'file'.
<code>read.table.ffdf</code> does the same in order to skip efficiently over previously read chunks.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel, Christophe Dutang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.table.ffdf">write.table.ffdf</a></code>, <code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+ffdf">ffdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> message("create some csv data on disk")
 x &lt;- data.frame(
   log=rep(c(FALSE, TRUE), length.out=26)
 , int=1:26
 , dbl=1:26 + 0.1
 , fac=factor(letters)
 , ord=ordered(LETTERS)
 , dct=Sys.time()+1:26
 , dat=seq(as.Date("1910/1/1"), length.out=26, by=1)
 , stringsAsFactors = TRUE
 )
 x &lt;- x[c(13:1, 13:1),]
 csvfile &lt;- tempPathFile(path=getOption("fftempdir"), extension="csv")
 write.csv(x, file=csvfile, row.names=FALSE)
 
 cat("Simply read csv with header\n")
 y &lt;- read.csv(file=csvfile, header=TRUE)
 y
 cat("Read csv with header\n")
 ffy &lt;- read.csv.ffdf(file=csvfile, header=TRUE)
 ffy
 sapply(ffy[,], class)
 
 message("reading with colClasses (an ordered factor wont'work in read.csv)")
 try(read.csv(file=csvfile, header=TRUE, colClasses=c(ord="ordered")
 , stringsAsFactors = TRUE))
 # TODO could fix this with the following two commands (Gabor Grothendieck) 
 # but does not know what bad side-effects this could have
 #setOldClass("ordered")
 #setAs("character", "ordered", function(from) ordered(from))
 y &lt;- read.csv(file=csvfile, header=TRUE, colClasses=c(dct="POSIXct", dat="Date")
 , stringsAsFactors = TRUE)
 ffy &lt;- read.csv.ffdf(
   file=csvfile
 , header=TRUE
 , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
 )
 rbind(
   ram_class = sapply(y, function(x)paste(class(x), collapse = ","))
 , ff_class = sapply(ffy[,], function(x)paste(class(x), collapse = ","))
 , ff_vmode = vmode(ffy)
 )
 
 message("NOTE that reading in chunks can change the sequence of levels and thus the coding")
 message("(Sorting levels during chunked reading can be too expensive)")
 levels(ffy$fac[])
 ffy &lt;- read.csv.ffdf(
   file=csvfile
 , header=TRUE
 , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
 , first.rows=6
 , next.rows=10
 , VERBOSE=TRUE
 )
 levels(ffy$fac[])
 
 
 message("If we don't know the levels we can sort then after reading")
 message("(Will rewrite all factor codes)")
 message("NOTE that you MUST assign the return value of sortLevels()")
 ffy &lt;- sortLevels(ffy)
 levels(ffy$fac[])
 
 message("If we KNOW the levels we can fix levels upfront")
 ffy &lt;- read.csv.ffdf(
   file=csvfile
 , header=TRUE
 , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
 , first.rows=6
 , next.rows=10
 , levels=list(fac=letters, ord=LETTERS)
 )
 levels(ffy$fac[])
 
 message("Or we inspect a sufficiently large chunk of data and use those")
 table(ffy$fac[], exclude=NULL)
 ffy &lt;- read.csv.ffdf(
   file=csvfile
 , header=TRUE
 , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
 , nrows=13
 , VERBOSE=TRUE
 )
 message("append the rest to ffy")
 ffy &lt;- read.csv.ffdf(
   x=ffy
 , file=csvfile
 , header=FALSE
 , skip=1 + nrow(ffy)
 , VERBOSE=TRUE
 )
 table(ffy$fac[], exclude=NULL)
 
 message("We can turn unexpected factor levels to NA, say we only allowed a:l")
 ffy &lt;- read.csv.ffdf(
   file=csvfile
 , header=TRUE
 , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
 , levels=list(fac=letters[1:12], ord=LETTERS[1:12])
 , appendLevels=FALSE
 )
 sapply(colnames(ffy), function(i)sum(is.na(ffy[[i]][])))

 message("let's store some columns more efficient")
 sum(.ffbytes[vmode(ffy)])
 ffy$log &lt;- clone(ffy$log, vmode="boolean")
 ffy$fac &lt;- clone(ffy$fac, vmode="byte")
 ffy$ord &lt;- clone(ffy$ord, vmode="byte")
 sum(.ffbytes[vmode(ffy)])
 
 message("let's make a template with zero rows")
 ffx &lt;- clone(ffy)  
 nrow(ffx) &lt;- 0
   
 message("reading with template and colClasses")
 ffy &lt;- read.csv.ffdf(
   x=ffx
 , file=csvfile
 , header=TRUE
 , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
 , next.rows = 12
 , VERBOSE = TRUE
 )
 rbind(
   ff_class = sapply(ffy[,], function(x)paste(class(x), collapse = ","))
 , ff_vmode = vmode(ffy)
 )
 levels(ffx$fac[])
 levels(ffy$fac[])
 
 message("reading with template without colClasses")
 ffy &lt;- read.csv.ffdf(
   x=ffx
   , file=csvfile
   , header=TRUE
   , next.rows = 12
   , VERBOSE = TRUE
 )
 rbind(
   ff_class = sapply(ffy[,], function(x)paste(class(x), collapse = ","))
 , ff_vmode = vmode(ffy)
 )
 levels(ffx$fac[])
 levels(ffy$fac[])
 

 message("We can fine-tune the creation of the ffdf")
 message("- let's create the ff files outside of fftempdir")
 message("- let's reduce required disk space and thus file.system cache RAM")
 message("By default we had record size 36.25")
 ffy &lt;- read.csv.ffdf(
   file=csvfile
   , header=TRUE
   , colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
   , asffdf_args=list(
     vmode = c(
         log="boolean"
       , int="byte"
       , dbl="single"
       , fac="nibble"  # no NAs
       , ord="nibble"  # no NAs
       , dct="single"
       , dat="single"
     )
     , col_args=list(pattern = "./csv")  # create in getwd() with prefix csv
   )
 )
 vmode(ffy)
 message("This recordsize is more than 50% reduced")
 sum(.ffbytes[vmode(ffy)]) / 36.25
 
 message("Don't forget to wrap-up files that are not in fftempdir")
 delete(ffy); rm(ffy)
 message("It's a good habit to also wrap-up temporary stuff (or at least know how this is done)")
 rm(ffx); gc()

   
 fwffile &lt;- tempfile()
 
 cat(file=fwffile, "123456", "987654", sep="\n")
 x &lt;- read.fwf(fwffile, widths=c(1,2,3), stringsAsFactors = TRUE)    #&gt; 1 23 456 \ 9 87 654
 y &lt;- read.table.ffdf(file=fwffile, FUN="read.fwf", widths=c(1,2,3))
 stopifnot(identical(x, y[,]))
 x &lt;- read.fwf(fwffile, widths=c(1,-2,3), stringsAsFactors = TRUE)   #&gt; 1 456 \ 9 654
 y &lt;- read.table.ffdf(file=fwffile, FUN="read.fwf", widths=c(1,-2,3))
 stopifnot(identical(x, y[,]))
 unlink(fwffile)
 
 cat(file=fwffile, "123", "987654", sep="\n")
 x &lt;- read.fwf(fwffile, widths=c(1,0, 2,3), stringsAsFactors = TRUE)    #&gt; 1 NA 23 NA \ 9 NA 87 654
 y &lt;- read.table.ffdf(file=fwffile, FUN="read.fwf", widths=c(1,0, 2,3))
 stopifnot(identical(x, y[,]))
 unlink(fwffile)
 
 cat(file=fwffile, "123456", "987654", sep="\n")
 x &lt;- read.fwf(fwffile, widths=list(c(1,0, 2,3), c(2,2,2))
 , stringsAsFactors = TRUE) #&gt; 1 NA 23 456 98 76 54
 y &lt;- read.table.ffdf(file=fwffile, FUN="read.fwf", widths=list(c(1,0, 2,3), c(2,2,2)))
 stopifnot(identical(x, y[,]))
 
 unlink(fwffile)

    

    unlink(csvfile)
</code></pre>

<hr>
<h2 id='readwrite.ff'> Reading and writing vectors (low-level) </h2><span id='topic+read.ff'></span><span id='topic+write.ff'></span><span id='topic+readwrite.ff'></span>

<h3>Description</h3>

<p>Simpe low-level interface for reading and writing vectors from ff files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ff(x, i, n)
write.ff(x, i, value, add = FALSE)
readwrite.ff(x, i, value, add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readwrite.ff_+3A_x">x</code></td>
<td>
<p> an ff object </p>
</td></tr>
<tr><td><code id="readwrite.ff_+3A_i">i</code></td>
<td>
<p> a start position in the ff file </p>
</td></tr>
<tr><td><code id="readwrite.ff_+3A_n">n</code></td>
<td>
<p> number of elements to read </p>
</td></tr>
<tr><td><code id="readwrite.ff_+3A_value">value</code></td>
<td>
<p> vector of elements to write </p>
</td></tr>
<tr><td><code id="readwrite.ff_+3A_add">add</code></td>
<td>
<p> TRUE if the values should rather increment than overwrite at the target positions </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>readwrite.ff</code> combines the effects of <code>read.ff</code> and <code>write.ff</code> in a single operation: it retrieves the old values starting from position <code>i</code> before changing them.
<code>getset.ff</code> will maintain <code><a href="bit.html#topic+na.count">na.count</a></code>.
</p>


<h3>Value</h3>

<p><code>read.ff</code> returns a vector of values, <code>write.ff</code> returns the 'changed' ff object (like all assignment functions do) and <code>readwrite.ff</code> returns the values at the target position.
More precisely <code>readwrite.ff(x, i, value, add=FALSE)</code> returns the old values at the position <code>i</code> while <code>readwrite.ff(x, i, value, add=TRUE)</code> returns the incremented values of <code>x</code>.
</p>


<h3>Note</h3>

 <p><code>read.ff</code>, <code>write.ff</code> and <code>readwrite.ff</code> are low level functions that do not support <code>ramclass</code> and <code>ramattribs</code> and thus will not give the expected result with <code>factor</code> and <code>POSIXct</code> </p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+getset.ff">getset.ff</a></code> for low-level scalar access and <code><a href="#topic++5B.ff">[.ff</a></code> for high-level access </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(0, length=12)
  read.ff(x, 3, 6)
  write.ff(x, 3, rep(1, 6))
  x
  write.ff(x, 3, rep(1, 6), add=TRUE)
  x
  readwrite.ff(x, 3, rep(1, 6), add=TRUE)
  readwrite.ff(x, 3, rep(1, 6))
  x
  rm(x); gc()
</code></pre>

<hr>
<h2 id='regtest.fforder'>
Sorting: regression tests
</h2><span id='topic+regtest.fforder'></span>

<h3>Description</h3>

<p>Some tests verfying the correctness of the sorting routines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regtest.fforder(n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regtest.fforder_+3A_n">n</code></td>
<td>

<p>size of vector to be sorted
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>stops in case of an error
</p>


<h3>Value</h3>

<p>Invisible()
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+ramsort">ramsort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  regtest.fforder()

 ## Not run: 
    n &lt;- 5e6
    message("performance comparison at n=", n, "")

    message("sorting doubles")
    x &lt;- y &lt;- as.double(runif(n))

    x[] &lt;- y
    system.time(sort(x))[3]
    x[] &lt;- y
    system.time(shellsort(x))[3]
    x[] &lt;- y
    system.time(shellsort(x, has.na=FALSE))[3]
    x[] &lt;- y
    system.time(mergesort(x))[3]
    x[] &lt;- y
    system.time(mergesort(x, has.na=FALSE))[3]

    x[] &lt;- y
    system.time(sort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE, has.na=FALSE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE, has.na=FALSE))[3]


    x &lt;- y &lt;- as.double(sample(c(rep(NA, n/2), runif(n/2))))

    x[] &lt;- y
    system.time(sort(x))[3]
    x[] &lt;- y
    system.time(shellsort(x))[3]
    x[] &lt;- y
    system.time(mergesort(x))[3]

    x[] &lt;- y
    system.time(sort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE))[3]



    x &lt;- y &lt;- sort(as.double(runif(n)))

    x[] &lt;- y
    system.time(sort(x))  # only here R is faster because R checks for beeing sorted
    x[] &lt;- y
    system.time(shellsort(x))[3]
    x[] &lt;- y
    system.time(shellsort(x, has.na=FALSE))[3]
    x[] &lt;- y
    system.time(mergesort(x))[3]
    x[] &lt;- y
    system.time(mergesort(x, has.na=FALSE))[3]

    x[] &lt;- y
    system.time(sort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE, has.na=FALSE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE, has.na=FALSE))[3]

    y &lt;- rev(y)
    x[] &lt;- y
    system.time(sort(x))[3]
    x[] &lt;- y
    system.time(shellsort(x))[3]
    x[] &lt;- y
    system.time(shellsort(x, has.na=FALSE))[3]
    x[] &lt;- y
    system.time(mergesort(x))[3]
    x[] &lt;- y
    system.time(mergesort(x, has.na=FALSE))[3]

    x[] &lt;- y
    system.time(sort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(shellsort(x, decreasing=TRUE, has.na=FALSE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE))[3]
    x[] &lt;- y
    system.time(mergesort(x, decreasing=TRUE, has.na=FALSE))[3]

    rm(x,y)


    message("ordering doubles")

    x &lt;- as.double(runif(n))
    system.time(order(x))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i))[3]

    x &lt;- as.double(sample(c(rep(NA, n/2), runif(n/2))))
    system.time(order(x))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i))[3]

    x &lt;- as.double(sort(runif(n)))
    system.time(order(x))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i))[3]

    x &lt;- rev(x)
    system.time(order(x))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i))[3]


    x &lt;- as.double(runif(n))
    system.time(order(x, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i, decreasing=TRUE))[3]

    x &lt;- as.double(sample(c(rep(NA, n/2), runif(n/2))))
    system.time(order(x, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i, decreasing=TRUE))[3]

    x &lt;- as.double(sort(runif(n)))
    system.time(order(x, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i, decreasing=TRUE))[3]

    x &lt;- rev(x)
    system.time(order(x, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE))[3]
    i &lt;- 1:n
    system.time(shellorder(x, i, decreasing=TRUE, stabilize=TRUE))[3]
    i &lt;- 1:n
    system.time(mergeorder(x, i, decreasing=TRUE))[3]


    keys &lt;- c("short","ushort")
    for (v in c("integer", keys)){

      if (v %in% keys){
        k &lt;- .vmax[v]-.vmin[v]+1L
        if (is.na(.vNA[v])){
          y &lt;- sample(c(rep(NA, k), .vmin[v]:.vmax[v]), n, TRUE)
        }else{
          y &lt;- sample(.vmin[v]:.vmax[v], n, TRUE)
        }
      }else{
        k &lt;- .Machine$integer.max
        y &lt;- sample(k, n, TRUE)
      }

      message("sorting ",v)

      x &lt;- y
      message("sort(x) ", system.time(sort(x))[3])
      x &lt;- y
      message("shellsort(x) ", system.time(shellsort(x))[3])
      x &lt;- y
      message("mergesort(x) ", system.time(mergesort(x))[3])
      x &lt;- y
      message("radixsort(x) ", system.time(radixsort(x))[3])
      if (v %in% keys){
        x &lt;- y
        message("keysort(x) ", system.time(keysort(x))[3])
        x &lt;- y
        message("keysort(x, keyrange=c(.vmin[v],.vmax[v])) "
, system.time(keysort(x, keyrange=c(.vmin[v],.vmax[v])))[3])
      }

      if (!is.na(.vNA[v])){
        x &lt;- y
        message("shellsort(x, has.na=FALSE) ", system.time(shellsort(x, has.na=FALSE))[3])
        x &lt;- y
        message("mergesort(x, has.na=FALSE) ", system.time(mergesort(x, has.na=FALSE))[3])
        x &lt;- y
        message("radixsort(x, has.na=FALSE) ", system.time(radixsort(x, has.na=FALSE))[3])
        if (v %in% keys){
          x &lt;- y
          message("keysort(x, has.na=FALSE) ", system.time(keysort(x, has.na=FALSE))[3])
          x &lt;- y
          message("keysort(x, has.na=FALSE, keyrange=c(.vmin[v],.vmax[v])) "
, system.time(keysort(x, has.na=FALSE, keyrange=c(.vmin[v],.vmax[v])))[3])
        }
      }


      message("ordering",v)

      x[] &lt;- y
      i &lt;- 1:n
      message("order(x) ", system.time(order(x))[3])
      x[] &lt;- y
      i &lt;- 1:n
      message("shellorder(x, i) ", system.time(shellorder(x, i))[3])
      x[] &lt;- y
      i &lt;- 1:n
      message("mergeorder(x, i) ", system.time(mergeorder(x, i))[3])
      x[] &lt;- y
      i &lt;- 1:n
      message("radixorder(x, i) ", system.time(radixorder(x, i))[3])
      if (v %in% keys){
        x[] &lt;- y
        i &lt;- 1:n
        message("keyorder(x, i) ", system.time(keyorder(x, i))[3])
        x[] &lt;- y
        i &lt;- 1:n
        message("keyorder(x, i, keyrange=c(.vmin[v],.vmax[v])) "
, system.time(keyorder(x, i, keyrange=c(.vmin[v],.vmax[v])))[3])
      }

      if (!is.na(.vNA[v])){
        x[] &lt;- y
        i &lt;- 1:n
        message("shellorder(x, i, has.na=FALSE) ", system.time(shellorder(x, i, has.na=FALSE))[3])
        x[] &lt;- y
        i &lt;- 1:n
        message("mergeorder(x, i, has.na=FALSE) ", system.time(mergeorder(x, i, has.na=FALSE))[3])
        x[] &lt;- y
        i &lt;- 1:n
        message("radixorder(x, i, has.na=FALSE) ", system.time(radixorder(x, i, has.na=FALSE))[3])
        if (v %in% keys){
          x[] &lt;- y
          i &lt;- 1:n
          message("keyorder(x, i, has.na=FALSE) ", system.time(keyorder(x, i, has.na=FALSE))[3])
          x[] &lt;- y
          i &lt;- 1:n
          message("keyorder(x, i, has.na=FALSE, keyrange=c(.vmin[v],.vmax[v])) "
, system.time(keyorder(x, i, has.na=FALSE, keyrange=c(.vmin[v],.vmax[v])))[3])
        }
      }

    }
  
## End(Not run)
</code></pre>

<hr>
<h2 id='repnam'>
Replicate with names
</h2><span id='topic+repnam'></span>

<h3>Description</h3>

<p>Function <code>repnam</code> replicates its <code>argument</code> to the desired <code>length</code>, either by simply <code><a href="base.html#topic+rep">rep</a>licating</code> or - if it has <code><a href="base.html#topic+names">names</a></code> - by replicating the <code>default</code> and matching the argument by its names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repnam(argument, names = NULL, len=length(names), default = list(NULL))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repnam_+3A_argument">argument</code></td>
<td>

<p>a named or non-named vector or list to be replicated
</p>
</td></tr>
<tr><td><code id="repnam_+3A_names">names</code></td>
<td>

<p>NULL or a charcter vector of names to which the argument names are matched
</p>
</td></tr>
<tr><td><code id="repnam_+3A_len">len</code></td>
<td>

<p>the desired length (required if names is not given)
</p>
</td></tr>
<tr><td><code id="repnam_+3A_default">default</code></td>
<td>

<p>the desired default which is replicated in case names are used (the default <code>list(NULL)</code> is suitable for a list argument)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> an object like argument or default having length len </p>


<h3>Note</h3>

<p>This is for internal use, e.g. to handle argument <code>colClasses</code> in <code><a href="#topic+read.table.ffdf">read.table.ffdf</a></code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep</a></code>, <code><a href="base.html#topic+vector">vector</a></code>, <code><a href="bit.html#topic+repfromto">repfromto</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> message("a list example")
 repnam(list(y=c(1,2), z=3), letters)
 repnam(list(c(1,2), 3), letters)

 message("a vector example")
 repnam(c(y=1, z=3), letters, default=NA)
 repnam(c(1, 3), letters, default=NA)

</code></pre>

<hr>
<h2 id='sortLevels'>
Factor level manipulation
</h2><span id='topic+appendLevels'></span><span id='topic+recodeLevels'></span><span id='topic+recodeLevels.factor'></span><span id='topic+recodeLevels.ff'></span><span id='topic+sortLevels'></span><span id='topic+sortLevels.factor'></span><span id='topic+sortLevels.ff'></span><span id='topic+sortLevels.ffdf'></span>

<h3>Description</h3>

<p><code>appendLevels</code> combines <code><a href="#topic+levels.ff">levels</a></code> without sorting such that levels of the first argument will not require re-coding.
<br />
<code>recodeLevels</code> is a generic for recoding a factor to a desired set of levels - also has a method for large <code><a href="#topic+ff">ff</a></code> objects
<br />
<code>sortLevels</code> is a generic for level sorting and recoding of single factors or of all factors of a <code><a href="#topic+ffdf">ffdf</a></code> dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendLevels(...)
recodeLevels(x, lev)
## S3 method for class 'factor'
recodeLevels(x, lev)
## S3 method for class 'ff'
recodeLevels(x, lev)
sortLevels(x)
## S3 method for class 'factor'
sortLevels(x)
## S3 method for class 'ff'
sortLevels(x)
## S3 method for class 'ffdf'
sortLevels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortLevels_+3A_...">...</code></td>
<td>
<p>character vector of levels or <code><a href="#topic+is.factor.ff">is.factor</a></code> objects from which the level attribute is taken</p>
</td></tr>
<tr><td><code id="sortLevels_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+factor">factor</a></code> or <code><a href="#topic+ff">ff</a></code> factor or a <code><a href="#topic+ffdf">ffdf</a></code> dataframe (<code>sortLevels</code> only) </p>
</td></tr>
<tr><td><code id="sortLevels_+3A_lev">lev</code></td>
<td>
<p>a character vector of levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When reading a long file with categorical columns the final set of factor levels is only known once the complete file has been read.
When a file is so large that we read it in chunks, the new levels need to be added incrementally.
<code><a href="base.html#topic+rbind.data.frame">rbind.data.frame</a></code> sorts combined levels, which requires recoding. For <code><a href="#topic+ff">ff</a></code> factors this would require recoding of all previous chunks at the next chunk - potentially on disk, which is too expensive.
Therefore <code><a href="#topic+read.table.ffdf">read.table.ffdf</a></code> will simply <code>appendLevels</code> without sorting, and the <code>recodeLevels</code> and <code>sortLevels</code> generics provide a convenient means for sorting and recoding levels after all chunks have been read.
</p>


<h3>Value</h3>

<p><code>appendLevels</code> returns a vector of combined levels, <code>recodeLevels</code> and <code>sortLevels</code> return the input object with changed levels. Do read the note!
</p>


<h3>Note</h3>

<p>You need to re-assign the return value not only for ram- but also for ff-objects. Remember ff's hybrid copying semantics: <code><a href="#topic+LimWarn">LimWarn</a></code>.
If you forget to re-assign the returned object, you will end up with ff objects that have their integer codes re-coded to the new levels but still carry the old levels as a <code><a href="#topic+virtual.ff">virtual</a></code> attribute.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.table.ffdf">read.table.ffdf</a></code>, <code><a href="#topic+levels.ff">levels.ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  message("Let's create a factor with little levels")
  x &lt;- ff(letters[4:6], levels=letters[4:6])
  message("Let's interpret the same ff file without levels in order to see the codes")
  y &lt;- x
  levels(y) &lt;- NULL

  levels(x)
  data.frame(factor=x[], codes=y[], stringsAsFactors = TRUE)

  levels(x) &lt;- appendLevels(levels(x), letters)
  levels(x)
  data.frame(factor=x[], codes=y[], stringsAsFactors = TRUE)

  x &lt;- sortLevels(x) # implicit recoding is chunked were necessary
  levels(x)
  data.frame(factor=x[], codes=y[], stringsAsFactors = TRUE)

  message("NEVER forget to reassign the result of recodeLevels or sortLevels, 
look at the following mess")
  recodeLevels(x, rev(levels(x)))
  message("NOW the codings have changed, but not the levels, the result is wrong data")
  levels(x)
  data.frame(factor=x[], codes=y[], stringsAsFactors = TRUE)

  rm(x);gc()

## Not run: 
 n &lt;- 5e7

 message("reading a factor from a file ist as fast ...")
 system.time(
 fx &lt;- ff(factor(letters[1:25]), length=n)
 )
 system.time(x &lt;- fx[])
 str(x)
 rm(x); gc()


 message("... as creating it in-RAM (R-2.11.1) which is theoretically impossible ...")
 system.time({
 x &lt;- integer(n)
 x[] &lt;- 1:25
 levels(x) &lt;- letters[1:25]
 class(x) &lt;- "factor"
 })
 str(x)
 rm(x); gc()


 message("... but is possible if we avoid some  unnecessary copying that is triggered 
by assignment functions")
 system.time({
 x &lt;- integer(n)
 x[] &lt;- 1:25
 setattr(x, "levels", letters[1:25])
 setattr(x, "class", "factor")
 })
 str(x)
 rm(x); gc()

 rm(n)

## End(Not run)

</code></pre>

<hr>
<h2 id='splitPathFile'>
Analyze pathfile-strings
</h2><span id='topic+standardPathFile'></span><span id='topic+splitPathFile'></span><span id='topic+unsplitPathFile'></span><span id='topic+tempPathFile'></span><span id='topic+fftempfile'></span>

<h3>Description</h3>

<p><code>splitPathFile</code> splits a vector of pathfile-strings into path- and file-components without loss of information.
<code>unsplitPathFile</code> restores the original pathfile-string vector.
<code>standardPathFile</code> standardizes a vector of pathfile-strings: backslashes are replaced by slashes, except for the first two leading backslashes indicating a network share.
<code>tempPathFile</code> returns  - similar to <code><a href="base.html#topic+tempfile">tempfile</a></code> - a vector of filenames given path(s) and file-prefix(es) and an optional extension.
<code>fftempfile</code> returns  - similar to <code>tempPathFile</code> - a vector of filenames following a vector of pathfile patterns that are intrepreted in a ff-specific way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitPathFile(x)
unsplitPathFile(splitted)
standardPathFile(x)
tempPathFile(splitted=NULL, path=splitted$path, prefix=splitted$file, extension=NULL)
fftempfile(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitPathFile_+3A_x">x</code></td>
<td>
<p> a character vector of pathfile strings </p>
</td></tr>
<tr><td><code id="splitPathFile_+3A_splitted">splitted</code></td>
<td>
<p> a return value from <code>splitPathFile</code> </p>
</td></tr>
<tr><td><code id="splitPathFile_+3A_path">path</code></td>
<td>
<p> a character vector of path components </p>
</td></tr>
<tr><td><code id="splitPathFile_+3A_prefix">prefix</code></td>
<td>
<p> a character vector of file components </p>
</td></tr>
<tr><td><code id="splitPathFile_+3A_extension">extension</code></td>
<td>
<p> optional extension like &quot;csv&quot; (or NULL) </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+dirname">dirname</a></code> and <code><a href="base.html#topic+basename">basename</a></code> remove trailing file separators and therefore cannot distinguish pathfile string that contains ONLY a path from a pathfile string that contains a path AND file.
Therefore <code><a href="base.html#topic+file.path">file.path</a>(dirname(pathfile), basename(pathfile))</code> cannot always restore the original pathfile string.
<br />
<code>splitPathFile</code> decomposes each pathfile string into three parts: a path BEFORE the last file separator, the file separator, the filename component AFTER the last file separator.
If there is no file separator in the string, <code>splitPathFile</code> tries to guess whether the string is a path or a file component: &quot;.&quot;, &quot;..&quot; and &quot;~&quot; are recognized as path components.
No tilde expansion is done, see <code><a href="base.html#topic+path.expand">path.expand</a></code>.
Backslashes are converted to the current <code><a href="base.html#topic+.Platform">.Platform</a>$file.sep</code> using <code>splitPathFile</code> except for the first two leading backslashes indicating a network share.
<br />
<code>unsplitPathFile</code> restores the original pathfile-string vector up to translated backslashes.
<br />
<code>tempPathFile</code> internally uses <code><a href="base.html#topic+tempfile">tempfile</a></code> to create its filenames, if an extension is given it repeats filename creation until none of them corresponds to an existing file.
<br />
<code>fftempfile</code> takes a path-prefix pattern as input, splits it,
will replace an empty path by <code>getOption("fftempdir")</code> and will use <code>getOption("ffextension")</code> as extension.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>path</code></td>
<td>
<p> a character vector of path components </p>
</td></tr>
<tr><td><code>fsep</code></td>
<td>
<p> a character vector of file separators or &quot;&quot; </p>
</td></tr>
<tr><td><code>file</code></td>
<td>
<p> a character vector of file components </p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is no gurantee that the path and file components contain valid path- or file-names. Like <code><a href="base.html#topic+basename">basename</a></code>,  <code>splitPathFile</code> can return &quot;.&quot;, &quot;..&quot; or even &quot;&quot;, however, all these make sense as a prefix in tempPathFile.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tempfile">tempfile</a></code>, <code><a href="base.html#topic+dirname">dirname</a></code>, <code><a href="base.html#topic+basename">basename</a></code>, <code><a href="base.html#topic+file.path">file.path</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pathfile &lt;- c("", ".", "/.", "./", "./.", "/"
  , "a", "a/", "/a", "a/a", "./a", "a/.", "c:/a/b/c", "c:/a/b/c/"
  , "..", "../", "/..", "../..", "//", "\\\\a\\", "\\\\a/"
  , "\\\\a/b", "\\\\a/b/", "~", "~/", "~/a", "~/a/")
  splitted &lt;- splitPathFile(pathfile)
  restored &lt;- unsplitPathFile(splitted)
  stopifnot(all(gsub("\\\\","/",restored)==gsub("\\\\","/",pathfile)))

  dirnam &lt;- dirname(pathfile)
  basnam &lt;- basename(pathfile)

  db  &lt;- file.path(dirnam,basnam)
  ident = gsub("\\\\","/",db) == gsub("\\\\","/",pathfile)
  sum(!ident)

  do.call("data.frame", c(list(ident=ident, pathfile=pathfile
   , dirnam=dirnam, basnam=basnam), splitted))

  ## Not run: 
    message("show the difference between tempfile and fftempfile")
    do.call("data.frame", c(list(ident=ident, pathfile=pathfile, dirnam=dirnam, basnam=basnam)
, splitted, list(filename=tempPathFile(splitted), fftempfile=fftempfile(pathfile))))

    message("for a single string splitPathFile is slower, 
for vectors of strings it scales much better than dirname+basename")

    system.time(for (i in 1:1000){
      d &lt;- dirname(pathfile)
      b &lt;- basename(pathfile)
    })
    system.time(for (i in 1:1000){
      s &lt;- splitPathFile(pathfile)
    })

    len &lt;- c(1,10,100,1000)
    timings &lt;- matrix(0, 2, length(len), dimnames=list(c("dir.base.name", "splitPathFile"), len))
    for (j in seq(along=len)){
      l &lt;- len[j]
      r &lt;- 10000 / l
      x &lt;- rep("\\\\a/b/", l)
      timings[1,j] &lt;- system.time(for (i in 1:r){
          d &lt;- dirname(x)
          b &lt;- basename(x)
        })[3]
      timings[2,j] &lt;- system.time(for (i in 1:r){
          s &lt;- splitPathFile(x)
        })[3]
    }
    timings
  
## End(Not run)
</code></pre>

<hr>
<h2 id='swap'> Reading and writing in one operation (high-level) </h2><span id='topic+swap'></span><span id='topic+swap.ff'></span><span id='topic+swap.ff_array'></span><span id='topic+swap.default'></span>

<h3>Description</h3>

<p>The generic <code>swap</code> combines <code>x[i]</code> and <code>x[i] &lt;- value</code> in a single operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(x, value, ...)
## S3 method for class 'ff'
swap(x, value, i, add = FALSE, pack = FALSE, ...)
## S3 method for class 'ff_array'
swap(x, value, ..., bydim = NULL, drop = getOption("ffdrop"), add = FALSE, pack = FALSE)
## Default S3 method:
swap(x, value, ..., add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_+3A_x">x</code></td>
<td>
<p> a ff or ram object </p>
</td></tr>
<tr><td><code id="swap_+3A_value">value</code></td>
<td>
<p> the new values to write, possibly recycled, see <code><a href="#topic++5B.ff">[.ff</a></code> </p>
</td></tr>
<tr><td><code id="swap_+3A_i">i</code></td>
<td>
<p> index information, see <code><a href="#topic++5B.ff">[.ff</a></code> </p>
</td></tr>
<tr><td><code id="swap_+3A_...">...</code></td>
<td>
<p> missing OR up to length(dim(x)) index expressions OR (ff only) <code><a href="#topic+hi">hi</a></code> objects </p>
</td></tr>
<tr><td><code id="swap_+3A_drop">drop</code></td>
<td>
<p> logical scalar indicating whether array dimensions shall be dropped </p>
</td></tr>
<tr><td><code id="swap_+3A_bydim">bydim</code></td>
<td>
<p> how to interpret vector to array data, see <code><a href="#topic++5B.ff">[.ff</a></code> </p>
</td></tr>
<tr><td><code id="swap_+3A_add">add</code></td>
<td>
<p> TRUE if the values should rather increment than overwrite at the target positions, see <code><a href="#topic+readwrite.ff">readwrite.ff</a></code> </p>
</td></tr>
<tr><td><code id="swap_+3A_pack">pack</code></td>
<td>
<p> FALSE to prevent rle-packing in hybrid index preprocessing, see <code><a href="#topic+as.hi">as.hi</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<pre>
  y &lt;- swap(x, value, i, add=FALSE, ...)

  is a shorter and more efficient version of

  y &lt;- x[i, add=FALSE, ...]
  x[i, add=FALSE, ...] &lt;- value

  and

  y &lt;- swap(x, value, i, add=TRUE, ...)

  is a shorter and more efficient version of

  y &lt;- x[i, add=TRUE, ...]
  y &lt;- y + value
  x[i, add=FALSE, ...] &lt;- y
  </pre>


<h3>Value</h3>

<p>Values at the target positions.
More precisely <code>swap(x, value, i, add=FALSE)</code> returns the old values at the position <code>i</code> while <code>swap(x, value, i, add=TRUE)</code> returns the incremented values of <code>x</code>.
</p>


<h3>Note</h3>

<p>Note that <code>swap.default</code> changes the object in its parent frame and thus violates R's usual functional programming logic.
When using <code>add=TRUE</code>, duplicated index positions should be avoided, because ff and ram objects behave differently:
</p>
<pre>
  swap.ff(x, 1, c(3,3), add=TRUE)
  # will increment x at position 3 TWICE by 1, while
  swap.default(x, 1, c(3,3), add=TRUE)
  # will increment x at position 3 just ONCE by 1
  </pre>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic++5B.ff">[.ff</a></code>, <code><a href="#topic+add">add</a></code>, <code><a href="#topic+readwrite.ff">readwrite.ff</a></code>, <code><a href="#topic+getset.ff">getset.ff</a></code>, <code><a href="#topic+LimWarn">LimWarn</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff("a", levels=letters, length=52)
  y &lt;- swap(x, "b", sample(length(x), 26))
  x
  y
  rm(x,y); gc()
</code></pre>

<hr>
<h2 id='symmetric'> Test for symmetric structure </h2><span id='topic+symmetric'></span><span id='topic+symmetric.ff'></span><span id='topic+symmetric.default'></span><span id='topic+symmetric.dist'></span>

<h3>Description</h3>

<p>Check if an object is inherently symmetric (its structure, not its data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetric(x, ...)
## S3 method for class 'ff'
symmetric(x, ...)
## Default S3 method:
symmetric(x, ...)
## S3 method for class 'dist'
symmetric(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetric_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="symmetric_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>ff matrices can be declared symmetric at creation time. Compatibility function <code>symmetric.default</code> returns FALSE, <code>symmetric.dist</code> returns TRUE.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+symmetric">symmetric</a></code>, <code><a href="#topic+ff">ff</a></code> 
, <code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="base.html#topic+isSymmetric">isSymmetric</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  symmetric(matrix(1:16, 4, 4))
  symmetric(dist(rnorm(1:4)))
</code></pre>

<hr>
<h2 id='symmIndex2vectorIndex'> Array: make vector positions from symmetric array index </h2><span id='topic+symmIndex2vectorIndex'></span>

<h3>Description</h3>

<p>make vector positions from (non-symmetric) array index respecting <span class="option">dim</span> and <span class="option">fixdiag</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmIndex2vectorIndex(x, dim, fixdiag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmIndex2vectorIndex_+3A_x">x</code></td>
<td>
<p> a matrix[,1:2] with matrix subscripts </p>
</td></tr>
<tr><td><code id="symmIndex2vectorIndex_+3A_dim">dim</code></td>
<td>
<p> the dimensions of the symmetric matrix </p>
</td></tr>
<tr><td><code id="symmIndex2vectorIndex_+3A_fixdiag">fixdiag</code></td>
<td>
<p> NULL assumes free diagonal, any value assumes fixed diagonal </p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <span class="option">fixdiag = NULL</span>
</p>


<h3>Value</h3>

<p>a vector of indices in <code>seq_len(prod(dim(x)))</code>
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+arrayIndex2vectorIndex">arrayIndex2vectorIndex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  symmIndex2vectorIndex(rbind(
   c(1,1)
  ,c(1,10)
  ,c(10,1)
  ,c(10,10)
  ), dim=c(10,10))
  symmIndex2vectorIndex(rbind(
   c(1,1)
  ,c(1,10)
  ,c(10,1)
  ,c(10,10)
  ), dim=c(10,10), fixdiag=1)
</code></pre>

<hr>
<h2 id='unclass_-'> Unclassed assignement </h2><span id='topic+unclass+3C-'></span>

<h3>Description</h3>

<p>With <code>unclass&lt;-</code> you can circumvent class dispatch on the assignment operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unclass(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unclass_-_+3A_x">x</code></td>
<td>
<p> some object </p>
</td></tr>
<tr><td><code id="unclass_-_+3A_value">value</code></td>
<td>
<p> the value to be assigned </p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified object
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+unclass">unclass</a></code>, <code><a href="#topic+undim">undim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- factor(letters)
  unclass(x)[1:3] &lt;- 1L
  x
</code></pre>

<hr>
<h2 id='undim'> Undim </h2><span id='topic+undim'></span>

<h3>Description</h3>

<p><code>undim</code> returns its input with the dim attribute removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="undim_+3A_x">x</code></td>
<td>
<p> an object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>x without dim attribute
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+unclass+3C-">unclass&lt;-</a></code>, <code><a href="base.html#topic+unclass">unclass</a></code>, <code><a href="base.html#topic+unname">unname</a></code>, <code><a href="base.html#topic+dim">dim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(1:12, 3)
  x
  undim(x)
</code></pre>

<hr>
<h2 id='unsort'> Hybrid Index, internal utilities </h2><span id='topic+unsort'></span><span id='topic+unsort.hi'></span><span id='topic+unsort.ahi'></span><span id='topic+subscript2integer'></span>

<h3>Description</h3>

<p>Non-documented internal utilities that might change
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unsort(x, ix)
unsort.hi(x, index)
unsort.ahi(x, index, ixre = any(sapply(index, function(i) {
    if (is.null(i$ix)) {
        if (i$re) TRUE else FALSE
    } else {
        TRUE
    }
})), ix = lapply(index, function(i) {
    if (is.null(i$ix)) {
        if (i$re)
            orig &lt;- rev(seq_len(poslength(i)))
        else orig &lt;- seq_len(poslength(i))
    }
    else {
        orig &lt;- i$ix
    }
    orig
}))
subscript2integer(x, maxindex = NULL, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unsort_+3A_x">x</code></td>
<td>
 <p><code>x</code> </p>
</td></tr>
<tr><td><code id="unsort_+3A_ix">ix</code></td>
<td>
 <p><code>ix</code> </p>
</td></tr>
<tr><td><code id="unsort_+3A_ixre">ixre</code></td>
<td>
 <p><code>ixre</code> </p>
</td></tr>
<tr><td><code id="unsort_+3A_index">index</code></td>
<td>
 <p><code>index</code> </p>
</td></tr>
<tr><td><code id="unsort_+3A_maxindex">maxindex</code></td>
<td>
 <p><code>maxindex</code> </p>
</td></tr>
<tr><td><code id="unsort_+3A_names">names</code></td>
<td>
 <p><code>names</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are utility functions for restoring original order after sorting.
For now we 'mimic' the intuitive but wrong argument order of match()
which should rather have the 'table' argument as its first argument,
then one could properly method-dispatch on the type of table.
xx We might change to proper 'unsort' generic, but then we have to change argument order.
</p>


<h3>Value</h3>

<p>undefined
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+hi">hi</a></code>, <code><a href="#topic+as.hi">as.hi</a></code> </p>

<hr>
<h2 id='update.ff'> Update ff content from another object </h2><span id='topic+update.ff'></span><span id='topic+update.ffdf'></span>

<h3>Description</h3>

<p><code>update</code> copies updates one ff object with the content of another object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ff'
update(object, from, delete = FALSE, bydim = NULL, fromdim = NULL
, BATCHSIZE = .Machine$integer.max, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE, ...)
## S3 method for class 'ffdf'
update(object, from, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.ff_+3A_object">object</code></td>
<td>
<p> an ff object to which to update </p>
</td></tr>
<tr><td><code id="update.ff_+3A_from">from</code></td>
<td>
<p> an object from which to uodate  </p>
</td></tr>
<tr><td><code id="update.ff_+3A_delete">delete</code></td>
<td>
<p> NA for quick update with file-exchange, TRUE for quick update with deleting the 'from' object after the update, can speed up updating significantly </p>
</td></tr>
<tr><td><code id="update.ff_+3A_bydim">bydim</code></td>
<td>
<p> how to interpret the content of the object, see <code><a href="#topic+ff">ff</a></code> </p>
</td></tr>
<tr><td><code id="update.ff_+3A_fromdim">fromdim</code></td>
<td>
<p> how to interpret the content of the 'from' object, see <code><a href="#topic+ff">ff</a></code> </p>
</td></tr>
<tr><td><code id="update.ff_+3A_batchsize">BATCHSIZE</code></td>
<td>
 <p><code>BATCHSIZE</code> </p>
</td></tr>
<tr><td><code id="update.ff_+3A_batchbytes">BATCHBYTES</code></td>
<td>
 <p><code>BATCHBYTES</code> </p>
</td></tr>
<tr><td><code id="update.ff_+3A_verbose">VERBOSE</code></td>
<td>
 <p><code>VERBOSE</code> </p>
</td></tr>
<tr><td><code id="update.ff_+3A_...">...</code></td>
<td>
<p> further arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the source object <code>is.ff</code> and not <code>delete=FALSE</code> then instead of slow copying we - if possible - try to swap and rename the files behind the ff objects.
Quick update requires that the two ff objects are <code><a href="#topic+vectorCompatible">vectorCompatible</a></code>,
that both don't use <code><a href="#topic+vw">vw</a></code>,
that they have identical <code><a href="#topic+maxlength">maxlength</a></code>
and identical <code><a href="#topic+levels.ff">levels.ff</a></code>.
</p>


<h3>Value</h3>

<p>An ff object like the input 'object' updated with the content of the 'from' object.
</p>


<h3>Note</h3>

<p>You don't have a guarantee that with <code>delete=TRUE</code> the 'from' object gets deleted or with <code>delete=NA</code> the 'from' objects carries the content of 'object'.
Such expectations only turn true if really a quick update was possible.
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ff">ff</a></code>, <code><a href="bit.html#topic+clone">clone</a></code>, <code><a href="#topic+ffvecapply">ffvecapply</a></code>, <code><a href="#topic+vectorCompatible">vectorCompatible</a></code>, <code><a href="#topic+filename">filename</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:100)
  y &lt;- ff(-(1:100))
  message("You should make it a habit to re-assign the return value 
of update although this is not needed currently.")
  x &lt;- update(x, from=y)
  x
  y
  x[] &lt;- 1:100
  x &lt;- update(x, from=y, delete=NA)
  x
  y
  x &lt;- update(x, from=y, delete=TRUE)
  x
  y
  x
  rm(x,y); gc()

  ## Not run: 
    message("timings")
    x &lt;- ff(1:10000000)
    y &lt;- ff(-(1:10000000))
    system.time(update(x, from=y))
    system.time(update(y, from=x, delete=NA))
    system.time(update(x, from=y, delete=TRUE))
    rm(x,y); gc()
  
## End(Not run)

</code></pre>

<hr>
<h2 id='vecprint'> Print beginning and end of big vector </h2><span id='topic+vecprint'></span><span id='topic+print.vecprint'></span>

<h3>Description</h3>

<p>Print beginning and end of big vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecprint(x, maxlength = 16, digits = getOption("digits"))
 ## S3 method for class 'vecprint'
print(x, quote = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecprint_+3A_x">x</code></td>
<td>
<p> a vector </p>
</td></tr>
<tr><td><code id="vecprint_+3A_maxlength">maxlength</code></td>
<td>
<p> max number of elements for printing </p>
</td></tr>
<tr><td><code id="vecprint_+3A_digits">digits</code></td>
<td>
<p> see <code><a href="base.html#topic+format">format</a></code> </p>
</td></tr>
<tr><td><code id="vecprint_+3A_quote">quote</code></td>
<td>
<p> see <code><a href="base.html#topic+print">print</a></code> </p>
</td></tr>
<tr><td><code id="vecprint_+3A_...">...</code></td>
<td>
<p> see <code><a href="base.html#topic+print">print</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class 'vecprint' with components
</p>
<table>
<tr><td><code>subscript</code></td>
<td>
<p> a list with two vectors of subscripts: vector begin and vector end </p>
</td></tr>
<tr><td><code>example</code></td>
<td>
<p> the extracted example vector as.character including seperator </p>
</td></tr>
<tr><td><code>sep</code></td>
<td>
<p> the row seperator &quot;:&quot; </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+matprint">matprint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  vecprint(10000:1)
</code></pre>

<hr>
<h2 id='vector.vmode'> Create vector of virtual mode </h2><span id='topic+vector.vmode'></span><span id='topic+vector.vmode.default'></span><span id='topic+vector.vmode.ff'></span><span id='topic+boolean'></span><span id='topic+quad'></span><span id='topic+nibble'></span><span id='topic+byte'></span><span id='topic+ubyte'></span><span id='topic+short'></span><span id='topic+ushort'></span>

<h3>Description</h3>

<p><code>vector.vmode</code> creates a vector of a given vmode and length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector.vmode(vmode = "logical", length = 0)
boolean(length = 0)
quad(length = 0)
nibble(length = 0)
byte(length = 0)
ubyte(length = 0)
short(length = 0)
ushort(length = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector.vmode_+3A_vmode">vmode</code></td>
<td>
<p> virtual mode </p>
</td></tr>
<tr><td><code id="vector.vmode_+3A_length">length</code></td>
<td>
<p> desired length </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>vector.vmode</code> creates the vector in one of the usual <code><a href="base.html#topic+storage.mode">storage.mode</a>s</code> (see <code><a href="#topic+.rammode">.rammode</a></code>) but flags them with an additional attribute 'vmode' if necessary.
The creators can also be used directly:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>boolean</code>    </td><td style="text-align: left;">  1 bit logical without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>logical</code>    </td><td style="text-align: left;">  2 bit logical with NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>quad</code>       </td><td style="text-align: left;">  2 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>nibble</code>     </td><td style="text-align: left;">  4 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>byte</code>       </td><td style="text-align: left;">  8 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ubyte</code>      </td><td style="text-align: left;">  8 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>short</code>      </td><td style="text-align: left;"> 16 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>ushort</code>     </td><td style="text-align: left;"> 16 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>integer</code>    </td><td style="text-align: left;"> 32 bit signed integer with NA       </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>single</code>     </td><td style="text-align: left;"> 32 bit float </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>double</code>     </td><td style="text-align: left;"> 64 bit float </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>complex</code>    </td><td style="text-align: left;"> 2x64 bit float </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>raw</code>        </td><td style="text-align: left;"> 8 bit unsigned char </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>character</code>  </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p>a vector of the desired vmode initialized with 0
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+as.vmode">as.vmode</a></code>, <code><a href="base.html#topic+vector">vector</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  vector.vmode("byte",12)
  vector.vmode("double",12)
  byte(12)
  double(12)
</code></pre>

<hr>
<h2 id='vector2array'> Array: make array from vector </h2><span id='topic+vector2array'></span>

<h3>Description</h3>

<p>makes array from vector respecting <span class="option">dim</span> and <span class="option">dimorder</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector2array(x, dim, dimorder = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector2array_+3A_x">x</code></td>
<td>
<p> an input vector, recyled if needed </p>
</td></tr>
<tr><td><code id="vector2array_+3A_dim">dim</code></td>
<td>
 <p><code><a href="base.html#topic+dim">dim</a></code> </p>
</td></tr>
<tr><td><code id="vector2array_+3A_dimorder">dimorder</code></td>
<td>
 <p><code><a href="#topic+dimorder">dimorder</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>FILLS vector into array of dim where fastest rotating is dim[dimorder[1]], next is dim[dimorder[2]] and so forth.
This is a generalization of converting vector to matrix(, byrow=TRUE).
NOTE that the result is a ram array always stored in STANDARD dimorder !!!
In this usage we sometimes term the dimorder 'bydim' because it does not change the physical layout of the result,
rather bydim refers to the dimorder in which to interpret the vector (not the result).
In <code>ff</code>, <code>update</code> and <code>clone</code> we have 'bydim' to contrast it from 'dimorder', the latter describing the layout of the file.
</p>


<h3>Value</h3>

<p>a suitable <code><a href="base.html#topic+array">array</a></code>
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+array2vector">array2vector</a></code>, <code><a href="#topic+vectorIndex2arrayIndex">vectorIndex2arrayIndex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  vector2array(1:12, dim=c(3, 4))               # matrix(1:12, 3, 4)
  vector2array(1:12, dim=c(3, 4), dimorder=2:1) # matrix(1:12, 3, 4, byrow=TRUE)
</code></pre>

<hr>
<h2 id='vectorIndex2arrayIndex'> Array: make array from index vector positions </h2><span id='topic+vectorIndex2arrayIndex'></span>

<h3>Description</h3>

<p>make array from index vector positions respecting <span class="option">dim</span> and <span class="option">dimorder</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorIndex2arrayIndex(x, dim = NULL, dimorder = NULL, vw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectorIndex2arrayIndex_+3A_x">x</code></td>
<td>
<p> a vector of indices in <code>seq_len(prod(dim))</code> </p>
</td></tr>
<tr><td><code id="vectorIndex2arrayIndex_+3A_dim">dim</code></td>
<td>
<p> NULL or <code><a href="base.html#topic+dim">dim</a></code> </p>
</td></tr>
<tr><td><code id="vectorIndex2arrayIndex_+3A_dimorder">dimorder</code></td>
<td>
<p> NULL or <code><a href="#topic+dimorder">dimorder</a></code> </p>
</td></tr>
<tr><td><code id="vectorIndex2arrayIndex_+3A_vw">vw</code></td>
<td>
<p> NULL or integer matrix[2,m], see details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fastest rotating dimension is dim[dimorder[1]], then dim[dimorder[2]], and so forth. <br />
The parameters 'x' and 'dim' may refer to a subarray of a larger array, in this case, the array indices 'x' are interpreted as 'vw[1,] + x' within the larger array 'vw[1,] + x + vw[2,]'.
</p>


<h3>Value</h3>

<p>an n by m matrix with n m-dimensional array indices
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+vector2array">vector2array</a></code>, <code><a href="#topic+arrayIndex2vectorIndex">arrayIndex2vectorIndex</a></code> , <code><a href="#topic+symmIndex2vectorIndex">symmIndex2vectorIndex</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  matrix(1:12, 3, 4)
  vectorIndex2arrayIndex(1:12, dim=3:4)
  vectorIndex2arrayIndex(1:12, dim=3:4, dimorder=2:1)
  matrix(1:30, 5, 6)
  vectorIndex2arrayIndex(c(6L, 7L, 8L, 11L, 12L, 13L, 16L, 17L, 18L, 21L, 22L, 23L)
, vw=rbind(c(0,1), c(3,4), c(2,1)))
  vectorIndex2arrayIndex(c(2L, 8L, 14L, 3L, 9L, 15L, 4L, 10L, 16L, 5L, 11L, 17L)
, vw=rbind(c(0,1), c(3,4), c(2,1)), dimorder=2:1)

  
</code></pre>

<hr>
<h2 id='vmode'> Virtual storage mode </h2><span id='topic+vmode'></span><span id='topic+vmode.default'></span><span id='topic+vmode.ff'></span><span id='topic+vmode+3C-'></span><span id='topic+vmode+3C-.default'></span><span id='topic+vmode+3C-.ff'></span><span id='topic+.vmode'></span><span id='topic+.vunsigned'></span><span id='topic+.vvalues'></span><span id='topic+.vimplemented'></span><span id='topic+.rammode'></span><span id='topic+.ffmode'></span><span id='topic+.vmin'></span><span id='topic+.vmax'></span><span id='topic+.vNA'></span><span id='topic+.rambytes'></span><span id='topic+.ffbytes'></span><span id='topic+.vcoerceable'></span><span id='topic+regtest.vmode'></span>

<h3>Description</h3>

<p>Function <code>vmode</code> returns virtual storage modes of 'ram' or 'ff' objects, the generic <code>vmode&lt;-</code> sets the vmode of ram objects (vmode of ff objects cannot be changed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vmode(x, ...)
vmode(x) &lt;- value
## Default S3 method:
vmode(x, ...)
## S3 method for class 'ff'
vmode(x, ...)
## Default S3 replacement method:
vmode(x) &lt;- value
## S3 replacement method for class 'ff'
vmode(x) &lt;- value
 regtest.vmode()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmode_+3A_x">x</code></td>
<td>
<p> any object </p>
</td></tr>
<tr><td><code id="vmode_+3A_value">value</code></td>
<td>
<p> a vmode from .vmode </p>
</td></tr>
<tr><td><code id="vmode_+3A_...">...</code></td>
<td>
<p> The <code>...</code> don't have a function yet, they are only defined to keep the generic flexible. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vmode</code> is generic with default and ff methods. The following meta data vectors can be queried by .vmode or .ffmode:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code>.vmode</code>         </td><td style="text-align: left;"> virtual mode </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vunsigned</code>     </td><td style="text-align: left;"> TRUE if unsigned vmode </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vvalues</code>       </td><td style="text-align: left;"> number of possible values (incl. NA) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vimplemented</code>  </td><td style="text-align: left;"> TRUE if this vmode is available in ff (initialized <code><a href="base.html#topic+.onLoad">.onLoad</a></code> and stored in <code><a href="base.html#topic+globalenv">globalenv</a></code> ) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.rammode</code>       </td><td style="text-align: left;"> storage mode of this vmode </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.ffmode</code>        </td><td style="text-align: left;"> integer used to code the vmode in C-code </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vvalues</code>       </td><td style="text-align: left;"> number of possible integers incl. NA in this vmode (or NA for other vmodes) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vmin</code>          </td><td style="text-align: left;"> min integer in this vmode (or NA for other vmodes) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vmax</code>          </td><td style="text-align: left;"> max integer in this vmode (or NA for other vmodes) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vNA</code>           </td><td style="text-align: left;"> NA or 0 if no NA for this vmode </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.rambytes</code>      </td><td style="text-align: left;"> bytes needed in ram </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.ffbytes</code>       </td><td style="text-align: left;"> bytes needed by ff on disk </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>.vcoerceable</code>   </td><td style="text-align: left;"> list of vectors with those vmodes that can absorb this vmode </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>the following functions relate to vmode:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <code><a href="#topic+vector.vmode">vector.vmode</a></code>   </td><td style="text-align: left;"> creating (ram) vector of some vmode </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code><a href="#topic+as.vmode">as.vmode</a></code>       </td><td style="text-align: left;"> generic for coercing to some vmode (dropping other attributes) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>vmode&lt;-</code>               </td><td style="text-align: left;"> generic for coercing to some vmode (keeping other attributes) </td>
</tr>
<tr>
 <td style="text-align: right;">
  <code><a href="#topic+maxffmode">maxffmode</a></code>      </td><td style="text-align: left;"> determine lowest <code>.ffmode</code> that can absorb all input vmodes without information loss </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>some of those call the vmode-specific functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>creation</strong>        </td><td style="text-align: left;"> <strong>coercion</strong>           </td><td style="text-align: left;">  <strong>vmode description</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+boolean">boolean</a></code>    </td><td style="text-align: left;"> <code><a href="#topic+as.boolean">as.boolean</a></code>    </td><td style="text-align: left;">  1 bit logical without NA </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+logical">logical</a></code>    </td><td style="text-align: left;"> <code><a href="base.html#topic+as.logical">as.logical</a></code>    </td><td style="text-align: left;">  2 bit logical with NA </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+quad">quad</a></code>       </td><td style="text-align: left;"> <code><a href="#topic+as.quad">as.quad</a></code>       </td><td style="text-align: left;">  2 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+nibble">nibble</a></code>     </td><td style="text-align: left;"> <code><a href="#topic+as.nibble">as.nibble</a></code>     </td><td style="text-align: left;">  4 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+byte">byte</a></code>       </td><td style="text-align: left;"> <code><a href="#topic+as.byte">as.byte</a></code>       </td><td style="text-align: left;">  8 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+ubyte">ubyte</a></code>      </td><td style="text-align: left;"> <code><a href="#topic+as.ubyte">as.ubyte</a></code>      </td><td style="text-align: left;">  8 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+short">short</a></code>      </td><td style="text-align: left;"> <code><a href="#topic+as.short">as.short</a></code>      </td><td style="text-align: left;"> 16 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+ushort">ushort</a></code>     </td><td style="text-align: left;"> <code><a href="#topic+as.ushort">as.ushort</a></code>     </td><td style="text-align: left;"> 16 bit unsigned integer without NA </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+integer">integer</a></code>    </td><td style="text-align: left;"> <code><a href="base.html#topic+as.integer">as.integer</a></code>    </td><td style="text-align: left;"> 32 bit signed integer with NA      </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+single">single</a></code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+as.single">as.single</a></code>     </td><td style="text-align: left;"> 32 bit float </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+double">double</a></code>     </td><td style="text-align: left;"> <code><a href="base.html#topic+as.double">as.double</a></code>     </td><td style="text-align: left;"> 64 bit float </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+complex">complex</a></code>    </td><td style="text-align: left;"> <code><a href="base.html#topic+as.complex">as.complex</a></code>    </td><td style="text-align: left;"> 2x64 bit float </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+raw">raw</a></code>        </td><td style="text-align: left;"> <code><a href="base.html#topic+as.raw">as.raw</a></code>        </td><td style="text-align: left;"> 8 bit unsigned char </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="base.html#topic+character">character</a></code>  </td><td style="text-align: left;"> <code><a href="base.html#topic+as.character">as.character</a></code>  </td><td style="text-align: left;"> character </td>
</tr>
<tr>
 <td style="text-align: left;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p><code>vmode</code> returns a character scalar from <code>.vmode</code> or &quot;NULL&quot; for NULL <br />
<code>rambytes</code> returns a vector of byte counts required by each of the vmodes
</p>


<h3>Note</h3>

 <p><code>regtest.vmode</code> checks correctness of some vmode features
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

  <p><code><a href="#topic+ff">ff</a></code>, <code><a href="base.html#topic+storage.mode">storage.mode</a></code>, <code><a href="base.html#topic+mode">mode</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> data.frame(.vmode=.vmode, .vimplemented=.vimplemented, .rammode=.rammode, .ffmode=.ffmode
, .vmin=.vmin, .vmax=.vmax, .vNA=.vNA, .rambytes=.rambytes, .ffbytes=.ffbytes)
  vmode(1)
  vmode(1L)
  .vcoerceable[["byte"]]
  .vcoerceable[["ubyte"]]
</code></pre>

<hr>
<h2 id='vmode.ffdf'>
Virtual storage mode of ffdf
</h2><span id='topic+vmode.ffdf'></span>

<h3>Description</h3>

<p>Function vmode returns the virtual storage mode of each ffdf column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffdf'
vmode(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vmode.ffdf_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+ffdf">ffdf</a></code></p>
</td></tr>
<tr><td><code id="vmode.ffdf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with one element for each column
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+vmode">vmode</a></code>, <code><a href="#topic+ffdf">ffdf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  vmode(as.ffdf(data.frame(a=as.double(1:26), b=letters, stringsAsFactors = TRUE)))
  gc()
</code></pre>

<hr>
<h2 id='vt'> Virtual transpose </h2><span id='topic+vt'></span><span id='topic+vt.ff'></span><span id='topic+vt.default'></span><span id='topic+t.ff'></span>

<h3>Description</h3>

<p>The <code>vt</code> generic does a matrix  or array transpose by modifying <code><a href="#topic+virtual.ff">virtual</a></code> attributes
rather than by physically copying matrix elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vt(x, ...)
## S3 method for class 'ff'
vt(x, ...)
## Default S3 method:
vt(x, ...)
## S3 method for class 'ff'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vt_+3A_x">x</code></td>
<td>
<p> an ff or ram object </p>
</td></tr>
<tr><td><code id="vt_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>vt.ff</code> method does transpose through reversing <code><a href="#topic+dim.ff">dim.ff</a></code> and <code><a href="#topic+dimorder">dimorder</a></code>.
The <code>vt.default</code> method is a wrapper to the standard transpose <code><a href="base.html#topic+t">t</a></code>. <br />
The <code>t.ff</code> method creates a transposed <code><a href="bit.html#topic+clone">clone</a></code>. <br />
If <code>x</code> has a virtual window <code><a href="#topic+vw">vw</a></code> defined, <code>vt.ff</code> returns an ff object with a transposed virtual window,
the <code>t.ff</code> method return a transposed clone of the virtual window content only.
</p>


<h3>Value</h3>

<p>an object that behaves like a transposed matrix
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+dim.ff">dim.ff</a></code>, <code><a href="#topic+vw">vw</a></code>, <code><a href="#topic+virtual.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:20, dim=c(4,5))
  x
  vt(x)
  y &lt;- t(x)
  y
  vw(x) &lt;- cbind(c(1,3,0),c(1,4,0))
  x
  vt(x)
  y &lt;- t(x)
  y
  rm(x,y); gc()
</code></pre>

<hr>
<h2 id='vw'> Getting and setting virtual windows </h2><span id='topic+vw'></span><span id='topic+vw+3C-'></span><span id='topic+vw.ff'></span><span id='topic+vw.default'></span><span id='topic+vw+3C-.ff_vector'></span><span id='topic+vw+3C-.ff_array'></span>

<h3>Description</h3>

<p>The virtual window <code>vw</code> function allows one to define a virtual window into an <code>ff_vector</code> or <code>ff_array</code>.
The ff object will behave like a smaller array and it is mapped into the specified region of the complete array.
This allows for example to execute recursive divide and conquer algorithms that work on parts of the full object,
without the need to repeatedly create subfiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vw(x, ...)
vw(x, ...) &lt;- value
## S3 method for class 'ff'
vw(x, ...)
## Default S3 method:
vw(x, ...)
## S3 replacement method for class 'ff_vector'
vw(x, ...) &lt;- value
## S3 replacement method for class 'ff_array'
vw(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vw_+3A_x">x</code></td>
<td>
<p> an <code>ff_vector</code> or <code>ff_array</code> </p>
</td></tr>
<tr><td><code id="vw_+3A_...">...</code></td>
<td>
<p> further arguments (not used) </p>
</td></tr>
<tr><td><code id="vw_+3A_value">value</code></td>
<td>
<p> a vector or matrix with an Offset, Window and Rest component, see details and examples </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each dimension of an ff array (or vector) is decomposed into three components, an invisible Offset, a visibe Window and an invisible Rest.
For each dimension the sum of the vw components must match the dimension (or length).
For an <code>ff_vector</code>, <code>vw</code> is simply a vector[1:3], for an array is is a <code>matrix[1:3,seq_along(dim(x))]</code>.
<code>vw</code> is a <code><a href="#topic+physical.ff">virtual</a></code> attribute. <br />
</p>


<h3>Value</h3>

<p>NULL or a vw specification, see details
</p>


<h3>Author(s)</h3>

<p> Jens Oehlschlägel </p>


<h3>See Also</h3>

 <p><code><a href="#topic+length.ff">length.ff</a></code>, <code><a href="#topic+dim.ff">dim.ff</a></code>, <code><a href="#topic+physical.ff">virtual</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- ff(1:26, names=letters)
  y &lt;- x
  vw(x) &lt;- c(0, 13, 13)
  vw(y) &lt;- c(13, 13, 0)
  x
  y
  x[1] &lt;- -1
  y[1] &lt;- -2
  vw(x) &lt;- NULL
  x[]

  z &lt;- ff(1:24, dim=c(4,6), dimnames=list(letters[1:4], LETTERS[1:6]))
  z
  vw(z) &lt;- rbind(c(1,1), c(2,4), c(1,1))
  z

  rm(x,y,z); gc()
</code></pre>

<hr>
<h2 id='write.table.ffdf'>
Exporting csv files from ff data.frames
</h2><span id='topic+write.table.ffdf'></span><span id='topic+write.csv.ffdf'></span><span id='topic+write.csv2.ffdf'></span><span id='topic+write.csv'></span><span id='topic+write.csv2'></span>

<h3>Description</h3>

<p>Function <code>write.table.ffdf</code> writes a <code><a href="#topic+ffdf">ffdf</a></code> object to a separated flat file, very much like (and using) <code><a href="utils.html#topic+write.table">write.table</a></code>.
It can also work with any convenience wrappers like <code><a href="#topic+write.csv">write.csv</a></code> and provides its own convenience wrapper (e.g. <code>write.csv.ffdf</code>) for R's usual wrappers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.table.ffdf(x = NULL
, file, append = FALSE
, nrows = -1, first.rows = NULL, next.rows = NULL
, FUN = "write.table", ...
, transFUN = NULL
, BATCHBYTES = getOption("ffbatchbytes")
, VERBOSE = FALSE
)
write.csv.ffdf(...)
write.csv2.ffdf(...)
write.csv(...)
write.csv2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.table.ffdf_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+ffdf">ffdf</a></code> object which to export to the separated file
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_file">file</code></td>
<td>

<p>either a character string naming a file or a connection
open for writing.  <code>""</code> indicates output to the console.
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_append">append</code></td>
<td>

<p>logical. Only relevant if <code>file</code> is a character
string.  If <code>TRUE</code>, the output is appended to the
file.  If <code>FALSE</code>, any existing file of the name is destroyed.
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_nrows">nrows</code></td>
<td>

<p>integer: the maximum number of rows to write in (includes first.rows in case a 'first' chunk is read)
Negative and other invalid values are ignored.
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_first.rows">first.rows</code></td>
<td>

<p>the number of rows to write with the first chunk (default: next.rows)
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_next.rows">next.rows</code></td>
<td>

<p>integer: number of rows to write in further chunks, see details.
By default calculated as <code>BATCHBYTES %/% sum(.rambytes[<a href="#topic+vmode">vmode</a>(x)])</code>
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_fun">FUN</code></td>
<td>

<p>character: name of a function that is called for writing each chunk, see <code><a href="utils.html#topic+write.table">write.table</a></code>, <code><a href="#topic+write.csv">write.csv</a></code>, etc.
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_...">...</code></td>
<td>

<p>further arguments, passed to <code>FUN</code> in <code>write.table.ffdf</code>, or passed to <code>write.table.ffdf</code> in the convenience wrappers
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_transfun">transFUN</code></td>
<td>

<p>NULL or a function that is called on each data.frame chunk before writing with <code>FUN</code> (for filtering, transformations etc.)
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_batchbytes">BATCHBYTES</code></td>
<td>

<p>integer: bytes allowed for the size of the <code><a href="base.html#topic+data.frame">data.frame</a></code> storing the result of reading one chunk. Default <code>getOption("ffbatchbytes")</code>.
</p>
</td></tr>
<tr><td><code id="write.table.ffdf_+3A_verbose">VERBOSE</code></td>
<td>

<p>logical: TRUE to verbose timings for each processed chunk (default FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>write.table.ffdf</code> has been designed to export very large <code><a href="#topic+ffdf">ffdf</a></code> objects to separated flatfiles in chunks.
The first chunk is potentially written with col.names. Further chunks are appended.
<br />
<code>write.table.ffdf</code> has been designed to behave as much like <code><a href="utils.html#topic+write.table">write.table</a></code> as possible. However, note the following differences:
</p>

<ol>
<li><p> by default <code><a href="#topic+dimnames.ffdf">row.names</a></code> are only written if the <code><a href="#topic+ffdf">ffdf</a></code> has row.names.
</p>
</li></ol>



<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible</a></code>
</p>


<h3>Note</h3>

<p><code><a href="#topic+write.csv">write.csv</a></code> and <code><a href="#topic+write.csv2">write.csv2</a></code> have been fixed in order to suppress <code>col.names</code> if <code>append=TRUE</code> is passed.
Note also that <code>write.table.ffdf</code> passes <code>col.names=FALSE</code> for all chunks following the first chunk - but not so for <code>FUN="write.csv"</code> and <code>FUN="write.csv2"</code> .
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel, Christophe Dutang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.table.ffdf">read.table.ffdf</a></code>, <code><a href="utils.html#topic+write.table">write.table</a></code>, <code><a href="#topic+ffdf">ffdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   x &lt;- data.frame(log=rep(c(FALSE, TRUE), length.out=26), int=1:26, dbl=1:26 + 0.1
, fac=factor(letters), ord=ordered(LETTERS), dct=Sys.time()+1:26
, dat=seq(as.Date("1910/1/1"), length.out=26, by=1), stringsAsFactors = TRUE)
   ffx &lt;- as.ffdf(x)

   csvfile &lt;- tempPathFile(path=getOption("fftempdir"), extension="csv")

   write.csv.ffdf(ffx, file=csvfile)
   write.csv.ffdf(ffx, file=csvfile, append=TRUE)

   ffy &lt;- read.csv.ffdf(file=csvfile, header=TRUE
, colClasses=c(ord="ordered", dct="POSIXct", dat="Date"))

   rm(ffx, ffy); gc()
   unlink(csvfile)

 ## Not run: 
  # Attention, this takes very long
  vmodes &lt;- c(log="boolean", int="byte", dbl="single"
, fac="short", ord="short", dct="single", dat="single")

  message("create a ffdf with 7 columns and 78 mio rows")
  system.time({
    x &lt;- data.frame(log=rep(c(FALSE, TRUE), length.out=26), int=1:26, dbl=1:26 + 0.1
, fac=factor(letters), ord=ordered(LETTERS), dct=Sys.time()+1:26
, dat=seq(as.Date("1910/1/1"), length.out=26, by=1), stringsAsFactors = TRUE)
    x &lt;- do.call("rbind", rep(list(x), 10))
    x &lt;- do.call("rbind", rep(list(x), 10))
    x &lt;- do.call("rbind", rep(list(x), 10))
    x &lt;- do.call("rbind", rep(list(x), 10))
    ffx &lt;- as.ffdf(x, vmode = vmodes)
    for (i in 2:300){
      message(i, "\n")
      last &lt;- nrow(ffx) + nrow(x)
      first &lt;- last - nrow(x) + 1L
      nrow(ffx) &lt;- last
      ffx[first:last,] &lt;- x
    }
  })


  csvfile &lt;- tempPathFile(path=getOption("fftempdir"), extension="csv")

  write.csv.ffdf(ffx, file=csvfile, VERBOSE=TRUE)
  ffy &lt;- read.csv.ffdf(file=csvfile, header=TRUE
, colClasses=c(ord="ordered", dct="POSIXct", dat="Date")
, asffdf_args=list(vmode = vmodes), VERBOSE=TRUE)

  rm(ffx, ffy); gc()
  unlink(csvfile)
 
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
