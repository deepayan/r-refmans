<!DOCTYPE html><html><head><title>Help for package additiveDEA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {additiveDEA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dea.fast'>
<p>Faster Solving of Additive DEA Models with Large Datasets</p></a></li>
<li><a href='#dea.gem'>
<p>Generalized Efficiency Measures (Additive DEA Models)</p></a></li>
<li><a href='#dea.sbm'>
<p>Slacks-Based Measure (SBM) of Efficiency</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Additive Data Envelopment Analysis Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-10-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Diomedes Soteriades</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Diomedes Soteriades &lt;andreassot10@yahoo.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for calculating efficiency with two types of additive Data Envelopment Analysis models: (i) Generalized Efficiency Measures: unweighted additive model (Cooper et al., 2007 &lt;<a href="https://doi.org/10.1007%2F978-0-387-45283-8">doi:10.1007/978-0-387-45283-8</a>&gt;), Range Adjusted Measure (Cooper et al., 1999, &lt;<a href="https://doi.org/10.1023%2FA%3A1007701304281">doi:10.1023/A:1007701304281</a>&gt;), Bounded Adjusted Measure (Cooper et al., 2011 &lt;<a href="https://doi.org/10.1007%2Fs11123-010-0190-2">doi:10.1007/s11123-010-0190-2</a>&gt;), Measure of Inefficiency Proportions (Cooper et al., 1999 &lt;<a href="https://doi.org/10.1023%2FA%3A1007701304281">doi:10.1023/A:1007701304281</a>&gt;), and the Lovell-Pastor Measure (Lovell and Pastor, 1995 &lt;<a href="https://doi.org/10.1016%2F0167-6377%2895%2900044-5">doi:10.1016/0167-6377(95)00044-5</a>&gt;); and (ii) the Slacks-Based Measure (Tone, 2001 &lt;<a href="https://doi.org/10.1016%2FS0377-2217%2899%2900407-5">doi:10.1016/S0377-2217(99)00407-5</a>&gt;). The functions provide several options: (i) constant and variable returns to scale; (ii) fixed (non-controllable) inputs and/or outputs; (iii) bounding the slacks so that unrealistically large slack values are avoided; and (iv) calculating the efficiency of specific Decision-Making Units (DMUs), rather than of the whole sample. Package additiveDEA also provides a function for reducing computation time when datasets are large.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), lpSolveAPI</td>
</tr>
<tr>
<td>Imports:</td>
<td>Benchmarking</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-10-02 11:05:32 UTC; mac</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-10-02 11:14:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='dea.fast'>
Faster Solving of Additive DEA Models with Large Datasets
</h2><span id='topic+dea.fast'></span>

<h3>Description</h3>

<p>Reduce calculation time of additive DEA efficiency models when the data comprise of several thousand DMUs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dea.fast(base, noutput, fixed = NULL, rts = 2, bound = NULL,
  add.model = c("additive", "RAM", "BAM", "MIP", "LovPast", "SBM"),
  blockSize = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.fast_+3A_base">base</code></td>
<td>

<p>A data frame with N rows and S+M columns, where N is the number of Decision-Making Units (DMUs), S is the number of
outputs and M is the number of inputs. 
</p>
</td></tr>
<tr><td><code id="dea.fast_+3A_noutput">noutput</code></td>
<td>

<p>The number of outputs produced by the DMUs. All DMUs must produce the same number of outputs.
</p>
</td></tr>
<tr><td><code id="dea.fast_+3A_fixed">fixed</code></td>
<td>

<p>A numeric vector containing column indices for fixed (non-controllable) outputs and/or inputs (if any) in the data.
Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="dea.fast_+3A_rts">rts</code></td>
<td>

<p>Returns to scale specification. 1 for constant returns to scale and 2 (default) for variable returns to scale.
</p>
</td></tr>
<tr><td><code id="dea.fast_+3A_bound">bound</code></td>
<td>

<p>A data frame with N rows and S+M columns containing user-defined bounds on the slacks of each DMU. If bounds are
supplied by the user in cases where some outputs and/or inputs are fixed, values should be 0 for these fixed
variables. Same for slacks that do not require bounds. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="dea.fast_+3A_add.model">add.model</code></td>
<td>

<p>Additive model to calculate efficiency. additive: unweighted additive model (Cooper et al., 2007); RAM: Range
Adjusted Measure (Cooper et al., 1999; 2001); BAM: Bounded Adjusted Measure (Cooper et al., 2011); MIP: Measure
of Inefficiency Proportions (Cooper et al., 1999); LovPast: the Lovell-Pastor Measure (Lovell and Pastor, 1995); SBM:   Slacks-Based Measure (Tone, 2001).
</p>
</td></tr>
<tr><td><code id="dea.fast_+3A_blocksize">blockSize</code></td>
<td>

<p>How many DMUs should each sub-problem comprise of? Defaults to 200.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+dea.fast">dea.fast</a></code> speeds up computation time of functions <code><a href="#topic+dea.gem">dea.gem</a></code> and <code><a href="#topic+dea.sbm">dea.sbm</a></code> when the data comprise of several thousand DMUs. It does so by dividing the data into several blocks consisting of a few hundred DMUs. Then, it finds the efficient DMUs in each block. The next step is to merge the efficient DMUs into one final set and to find the efficient DMUs in this set. Finally, the DMUs in each block are benchmarked against the DMUs that were found to be efficient in the final set of the previous step. See Newsletter 16 in <a href="http://www.saitech-inc.com/Products/Prod-DSP.asp">http://www.saitech-inc.com/Products/Prod-DSP.asp</a>.
If N is not divisible by blockSize, dea.fast will split the data into a number of even blocks plus a final block with the remaining DMUs. For instance, if N=1050 and blockSize=200, there will be five blocks with 200 DMUs and a sixth one with 50 DMUs.
</p>


<h3>Value</h3>

<p>Returns a numeric vector containing the (in)efficiency scores of the DMUs.
</p>


<h3>Note</h3>

<p>The presence of DMUs with solution status other than 0 (see dea.gem and dea.sbm) will result in dea.fast NOT working. Ensure that there is a solution for all DMUs or, when the solution status is 5, that the data are scaled appropriately.
</p>
<p>Extreme care is needed when add.model = 'RAM' when ranges are too large relative to the slacks. In such a case, the slack-range ratios can be so small that an inefficient DMU may seem to have near-zero inefficiency (see Cooper et al., 1999). This makes it extremely hard for the algorithm to distinguish between efficient and inefficient DMUs when the former must be separated from the latter within each block (as described earlier). Avoiding using RAM with <code><a href="#topic+dea.fast">dea.fast</a></code> for the time being is strongly recommended.
</p>


<h3>Author(s)</h3>

<p>Andreas Diomedes Soteriades, <a href="mailto:andreassot10@yahoo.com">andreassot10@yahoo.com</a>
</p>


<h3>References</h3>

<p>Cooper W. W., Park K. S., Pastor J. T. (1999) RAM: a range adjusted measure of inefficiency for use with additive models, and relations to other models and measures in DEA. <em>Journal of Productivity Analysis</em>, <b>11</b>, 5&ndash;42
</p>
<p>Cooper W. W., Park K. S., Pastor J. T. (2001) The range adjusted measure (RAM) in DEA: a response to the comment by Steinmann and Zweifel. <em>Journal of Productivity Analysis</em>, <b>15</b>, 145&ndash;152
</p>
<p>Cooper W. W., Pastor J. T., Borras F., Aparicio J., Pastor D. (2011) BAM: a bounded adjusted measure of efficiency for use with bounded additive models. <em>Journal of Productivity Analysis</em>, <b>35</b>, 85&ndash;94
</p>
<p>Cooper W. W., Seiford L., Tone K. (2007) <em>Data Envelopment Analysis: a comprehensive text with models, applications, references and DEA-Solver software</em>. New York: Springer
</p>
<p>Lovell, C. A. K., Pastor J. T. (1995) Units invariant and translation invariant DEA models. <em>Operations Research Letters</em>, <b>18</b>, 147&ndash;151
</p>
<p>Tone K. (2001) A slacks-based measure of efficiency in data envelopment analysis. <em>European Journal of Operational Research</em>, <b>130</b>, 498&ndash;509
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea.gem">dea.gem</a></code>, <code><a href="#topic+dea.sbm">dea.sbm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get data from package Benchmarking:
library(Benchmarking)
data(pigdata)
base &lt;- pigdata[, 2:9][, c(7,8,1:6)]
# Create trivial but large dataset
base &lt;- rbind(base,base,base,base)
system.time(dea.fast(base, noutput= 2, rts= 2,
  add.model= "LovPast", blockSize = 200))

## The function is currently defined as
function (base, noutput, fixed = NULL, rts = 2, bound = NULL, 
    add.model = c("additive", "RAM", "BAM", "MIP", "LovPast", 
        "SBM"), blockSize = 200) 
{
    baseEfficient &lt;- list()
    n &lt;- nrow(base)
    mod &lt;- (n - (n%%blockSize))/blockSize
    blocks &lt;- c(1, 1:mod * blockSize + 1)
    for (i in 1:mod) {
        aux &lt;- blocks[i]:(blocks[i + 1] - 1)
        base1 &lt;- base[aux, ]
        bound1 &lt;- bound[aux, ]
        if (add.model != "SBM") {
            eff &lt;- round(dea.gem(base = base1, noutput, fixed, 
                rts, bound = bound1, add.model)$eff, 7)
            index &lt;- which(is.na(eff))
            if (length(index) &gt; 0) {
                eff[index] &lt;- round(dea.gem(base = base1, noutput, 
                  fixed, rts, bound = bound1, add.model, whichDMUs = index)$eff, 
                  7)
            }
            baseEfficient[[i]] &lt;- base1[which(eff == 0), ]
        }
        else {
            eff &lt;- round(dea.sbm(base = base1, noutput, fixed, 
                rts, bound = bound1)$eff, 7)
            index &lt;- which(is.na(eff))
            if (length(index) &gt; 0) {
                eff[index] &lt;- round(dea.sbm(base = base1, noutput, 
                  fixed, rts, bound = bound1, whichDMUs = index)$eff, 
                  7)
            }
            baseEfficient[[i]] &lt;- base1[which(eff == 1), ]
        }
    }
    if (n%%blockSize != 0) {
        aux &lt;- (n - (n%%blockSize) + 1):n
        base1 &lt;- base[aux, ]
        bound1 &lt;- bound[aux, ]
        if (add.model != "SBM") {
            eff &lt;- round(dea.gem(base = base1, noutput, fixed, 
                rts, bound = bound1, add.model)$eff, 7)
            index &lt;- which(is.na(eff))
            if (length(index) &gt; 0) {
                eff[index] &lt;- round(dea.gem(base = base1, noutput, 
                  fixed, rts, bound = bound1, add.model, whichDMUs = index)$eff, 
                  7)
            }
            baseEfficient[[i + 1]] &lt;- base1[which(eff == 0), 
                ]
        }
        else {
            eff &lt;- round(dea.sbm(base = base1, noutput, fixed, 
                rts, bound = bound1)$eff, 7)
            index &lt;- which(is.na(eff))
            if (length(index) &gt; 0) {
                eff[index] &lt;- round(dea.sbm(base = base1, noutput, 
                  fixed, rts, bound = bound1, whichDMUs = index)$eff, 
                  7)
            }
            baseEfficient[[i + 1]] &lt;- base1[which(eff == 1), 
                ]
        }
    }
    baseEfficient &lt;- do.call("rbind", baseEfficient)
    if (add.model != "SBM") {
        eff &lt;- round(dea.gem(base = base1, noutput, fixed, rts, 
            bound = bound1, add.model)$eff, 7)
        index &lt;- which(is.na(eff))
        if (length(index) &gt; 0) {
            eff[index] &lt;- round(dea.gem(base = base1, noutput, 
                fixed, rts, bound = bound1, add.model, whichDMUs = index)$eff, 
                7)
        }
        baseEfficient &lt;- base1[which(eff == 0), ]
    }
    else {
        eff &lt;- round(dea.sbm(base = base1, noutput, fixed, rts, 
            bound = bound1)$eff, 7)
        index &lt;- which(is.na(eff))
        if (length(index) &gt; 0) {
            eff[index] &lt;- round(dea.sbm(base = base1, noutput, 
                fixed, rts, bound = bound1, whichDMUs = index)$eff, 
                7)
        }
        baseEfficient &lt;- base1[which(eff == 1), ]
    }
    eff &lt;- list()
    for (i in 1:mod) {
        aux &lt;- blocks[i]:(blocks[i + 1] - 1)
        base1 &lt;- base[aux, ]
        base1 &lt;- rbind(base1, baseEfficient)
        bound1 &lt;- bound[aux, ]
        if (!is.null(bound)) {
            df &lt;- data.frame(matrix(0, nrow = nrow(base1[1:(nrow(base1) - 
                blockSize), ]), ncol = ncol(base1)))
            names(df) &lt;- names(bound1)
            bound1 &lt;- rbind(bound1, df)
        }
        if (add.model != "SBM") {
            eff[[i]] &lt;- dea.gem(base = base1, noutput, fixed, 
                rts, bound = bound1, add.model, whichDMUs = 1:blockSize)$eff
            index &lt;- which(is.na(eff[[i]]))
            if (length(index) &gt; 0) {
                eff[[i]][index] &lt;- dea.gem(base = base1, noutput, 
                  fixed, rts, bound = bound1, add.model, whichDMUs = index)$eff
            }
        }
        else {
            eff[[i]] &lt;- dea.sbm(base = base1, noutput, fixed, 
                rts, bound = bound1, whichDMUs = 1:blockSize)$eff
            index &lt;- which(is.na(eff[[i]]))
            if (length(index) &gt; 0) {
                eff[[i]][index] &lt;- dea.sbm(base = base1, noutput, 
                  fixed, rts, bound = bound1, whichDMUs = index)$eff
            }
        }
    }
    if (n%%blockSize != 0) {
        aux &lt;- (n - (n%%blockSize) + 1):n
        base1 &lt;- base[aux, ]
        base1 &lt;- rbind(base1, baseEfficient)
        bound1 &lt;- bound[aux, ]
        newBlockSize &lt;- nrow(base) - mod * blockSize
        if (!is.null(bound)) {
            df &lt;- data.frame(matrix(0, nrow = nrow(base1[1:(nrow(base1) - 
                newBlockSize), ]), ncol = ncol(base1)))
            names(df) &lt;- names(bound1)
            bound1 &lt;- rbind(bound1, df)
        }
        if (add.model != "SBM") {
            eff[[i + 1]] &lt;- dea.gem(base = base1, noutput, fixed, 
                rts, bound = bound1, add.model, whichDMUs = 1:newBlockSize)$eff
            index &lt;- which(is.na(eff[[i + 1]]))
            if (length(index) &gt; 0) {
                eff[[i + 1]][index] &lt;- dea.gem(base = base1, 
                  noutput, fixed, rts, bound = bound1, add.model, 
                  whichDMUs = index)$eff
            }
        }
        else {
            eff[[i + 1]] &lt;- dea.sbm(base = base1, noutput, fixed, 
                rts, bound = bound1, whichDMUs = 1:newBlockSize)$eff
            index &lt;- which(is.na(eff[[i + 1]]))
            if (length(index) &gt; 0) {
                eff[[i + 1]][index] &lt;- dea.sbm(base = base1, 
                  noutput, fixed, rts, bound = bound1, whichDMUs = index)$eff
            }
        }
    }
    eff &lt;- unlist(eff)
    return(eff)
  }
</code></pre>

<hr>
<h2 id='dea.gem'>
Generalized Efficiency Measures (Additive DEA Models)
</h2><span id='topic+dea.gem'></span>

<h3>Description</h3>

<p>Calculate additive Data Envelopment Analysis (DEA) efficiency with five Generalized Efficiency Measures (GEM): unweighted additive model (Cooper et al., 2007), Range Adjusted Measure (Cooper et al., 1999; 2001), Bounded Adjusted Measure (Cooper et al., 2011), Measure of Inefficiency Proportions (Cooper et al., 1999), and the Lovell-Pastor Measure (Lovell and Pastor, 1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dea.gem(base, noutput, fixed = NULL, rts = 2, bound = NULL,
  add.model = c("additive", "RAM", "BAM", "MIP", "LovPast"),
  whichDMUs = NULL, print.status = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.gem_+3A_base">base</code></td>
<td>

<p>A data frame with N rows and S+M columns, where N is the number of Decision-Making Units (DMUs), S is the number of
outputs and M is the number of inputs. 
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_noutput">noutput</code></td>
<td>

<p>The number of outputs produced by the DMUs. All DMUs must produce the same number of outputs.
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_fixed">fixed</code></td>
<td>

<p>A numeric vector containing column indices for fixed (non-controllable) outputs and/or inputs (if any) in the data.
Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_rts">rts</code></td>
<td>

<p>Returns to scale specification. 1 for constant returns to scale and 2 (default) for variable returns to scale.
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_bound">bound</code></td>
<td>

<p>A data frame with N rows and S+M columns containing user-defined bounds on the slacks of each DMU. If bounds are
supplied by the user in cases where some outputs and/or inputs are fixed, values should be 0 for these fixed
variables. Same for slacks that do not require bounds. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_add.model">add.model</code></td>
<td>

<p>Additive model to calculate efficiency. additive: unweighted additive model (Cooper et al., 2007); RAM: Range
Adjusted Measure (Cooper et al., 1999; 2001); BAM: Bounded Adjusted Measure (Cooper et al., 2011); MIP: Measure
of Inefficiency Proportions (Cooper et al., 1999); LovPast: the Lovell-Pastor Measure (Lovell and Pastor, 1995).
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_whichdmus">whichDMUs</code></td>
<td>

<p>Numeric vector specifying the line numbers of the DMUs for which efficiency should be calculated. Defaults to NULL, 
i.e. by default efficiency is calculated for all DMUs in the dataset.
</p>
</td></tr>
<tr><td><code id="dea.gem_+3A_print.status">print.status</code></td>
<td>

<p>Defaults to FALSE. If the solution of the linear program is NA for one or more DMUs, print.status can be set to TRUE to     find out why.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized Efficiency Measures (GEMs) are additive DEA models that maximize the sum of input and output slacks for each DMU. This sum is an aggregate measure of all inefficiencies that a DMU may exhibit in its inputs and outputs and can thus be seen as a holistic measure of (Pareto-Koopmans) inefficiency (efficient DMUs have no inefficiencies, thus their sum of slacks is 0). GEMs differ in that they weigh slacks in the objective function in different manners: the unweighted additive model does not in fact weigh the slacks, i.e. all slacks are assigned a trivial weight of 1 (Cooper et al., 2007); RAM weighs input and output slacks by the ranges in inputs and outputs respectively (Cooper et al., 1999). BAM weighs input and output slacks by the lower-sided ranges in inputs and the upper-sided ranges in outputs respectively (Cooper et al., 2011). MIP weighs input and output slacks by the respective inputs used and outputs produced by each DMU (Cooper et al., 1999); the Lovell-Pastor Measure weighs input and output slacks by the standard deviations in inputs and outputs respectively (Lovell and Pastor, 1995).
</p>
<p>Models RAM, BAM, MIP and the Lovell-Pastor measure are units invariant, that is, the value of the aggregate inefficiency score of a DMU is independent of the units in which the inputs and outputs are measured, as long as these units are the same for every DMU. When a variable returns to scale specification is assumed, the unweighted additive model, RAM, BAM and the Lovell-Pastor measure are translation invariant, that is, they can accommodate zero or negative values of inputs and outputs.
</p>


<h3>Value</h3>

<p>If print.status=FALSE, returns a data frame with N rows and 1+N+S+M columns. Column 1 reports the inefficiency score of each DMU. Columns 2 to N+1 contain the lambda values (intensity variables) indicating the DMU(s) that serve as reference for each DMU. Columns 1+N+1 to 1+N+S report the optimal output slacks for each DMU. Columns 1+N+S+1 to 1+N+S+M report the optimal input slacks for each DMU. When the linear program of a DMU is infeasible, the row of this DMU in the data frame will have NA values.
</p>
<p>If print.status=TRUE, returns a list with two elements. The first element is the aforementioned data frame. The second element is a numeric vector indicating the solution status of the linear program (e.g. 0: solution found; 2: problem is infeasible; 5: problem needs scaling; etc. See <a href="https://CRAN.R-project.org/package=lpSolveAPI">https://CRAN.R-project.org/package=lpSolveAPI</a>).
</p>


<h3>Note</h3>

<p>Models RAM and BAM return an inefficiency score that is bounded by 0 and 1. Subtracting this inefficiency score from 1 gives an efficiency score that is also bounded by 0 and 1, with 1 indicating that the DMU under evaluation is fully efficient (zero slacks). The other GEMs do not carry this property, unless the slacks are bounded appropriately. For instance, the user may demand that output slacks are bounded by the actual outputs produced by each DMU, resulting in a MIP measure of inefficiency that, when divided by S+M and subtracted from 1, can be converted to an efficiency measure that is bounded by 0 and 1. Note that with RAM and BAM the bounds must be smaller than, or equal to, the ranges (for RAM) or the sided ranges (for BAM) for the inefficiency scores to be bounded by 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Andreas Diomedes Soteriades, <a href="mailto:andreassot10@yahoo.com">andreassot10@yahoo.com</a>
</p>


<h3>References</h3>

<p>Cooper W. W., Park K. S., Pastor J. T. (1999) RAM: a range adjusted measure of inefficiency for use with additive models, and relations to other models and measures in DEA. <em>Journal of Productivity Analysis</em>, <b>11</b>, 5&ndash;42
</p>
<p>Cooper W. W., Park K. S., Pastor J. T. (2001) The range adjusted measure (RAM) in DEA: a response to the comment by Steinmann and Zweifel. <em>Journal of Productivity Analysis</em>, <b>15</b>, 145&ndash;152
</p>
<p>Cooper W. W., Pastor J. T., Borras F., Aparicio J., Pastor D. (2011) BAM: a bounded adjusted measure of efficiency for use with bounded additive models. <em>Journal of Productivity Analysis</em>, <b>35</b>, 85&ndash;94
</p>
<p>Cooper W. W., Seiford L., Tone K. (2007) <em>Data Envelopment Analysis: a comprehensive text with models, applications, references and DEA-Solver software</em>. New York: Springer
</p>
<p>Lovell, C. A. K., Pastor J. T. (1995) Units invariant and translation invariant DEA models. <em>Operations Research Letters</em>, <b>18</b>, 147&ndash;151
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea.sbm">dea.sbm</a></code>, <code><a href="#topic+dea.fast">dea.fast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Twelve DMUs, 2 inputs, 2 outputs
# (see Table 1.5 in Cooper et al., 2007):
base &lt;- data.frame(
  y1= c(100,150,160,180,94,230,220,152,190,250,260,250),
  y2= c(90,50,55,72,66,90,88,80,100,100,147,120),
  x1= c(20,19,25,27,22,55,33,31,30,50,53,38),
  x2= c(151,131,160,168,158,255,235,206,244,268,306,284))

# Example 1: Get inefficiency scores,
# lambdas and slacks for all DMUs, with each GEM:
models &lt;- c("additive", "RAM", "BAM", "MIP", "LovPast")
for(i in models) {
  print(i)
  results &lt;- dea.gem(base, noutput= 2, add.model= i)
  print(results)
}

# Example 2: Same as above, but consider output y2 and input x1 as fixed:
for(i in models) {
  print(i)
  results &lt;- dea.gem(base, noutput= 2, add.model= i, fixed= c(2, 3))
  print(results)
}

# Example 3: Impose upper bounds to slacks and get BAM inefficiency:
# upper-sided range for output:
Uo &lt;- sweep(-base[c(1,2)], 2,
  apply(base[c(1,2)], 2, max), '+')
# lower-sided range for input
Li &lt;- sweep(base[c(3,4)], 2,
  apply(base[c(3,4)], 2, min), '-')
# ensure bounds are &lt;= the sided ranges:
bound &lt;- cbind(Uo, Li)/2
# results with bounds:
dea.gem(base, noutput= 2, add.model= "BAM", bound= bound)$eff
# removing bounds allows for larger inefficiencies:
dea.gem(base, noutput= 2, add.model= "BAM", bound= NULL)$eff
# check solution status of linear programs when y2 and x1 are fixed
# and y1, x2 slacks are bounded:
fixed &lt;- c(2,3)
bound[fixed] &lt;- 0
for(i in models) {
  print(i)
  results &lt;- dea.gem(base, noutput= 2, add.model= i,
    bound= bound, fixed= c(2, 3), rts= 1, print.status= TRUE)[[2]]
  print(results)
}

# Example 4: Get inefficiency scores for DMUs 11 and 12:
bound &lt;- base
fixed &lt;- c(2,3)
bound[fixed] &lt;- 0
for(i in models) {
  print(i)
  results &lt;- dea.gem(base, noutput= 2, add.model= i,
    bound= base, fixed= c(2, 3), rts= 1, whichDMUs= c(11, 12))$eff
  print(results)
}

# Example 5: a typical scaling problem in linear programing
# and how to deal with it:
# get data from package Benchmarking:
library(Benchmarking)
data(pigdata)
base &lt;- pigdata[, 2:9][, c(7,8,1:6)]
results &lt;- dea.gem(base, noutput= 2, rts= 1,
  add.model= 'RAM', print.status= TRUE)
# inefficiency for DMU 37 is NA:
which(is.na(results[[1]]$eff))
# error status: 5, i.e. scaling problem:
results[[2]][37]
# scale data:
results &lt;- dea.gem(base/1000, noutput= 2, rts= 1,
  add.model= 'RAM', print.status= TRUE)
which(is.na(results[[1]]$eff)) # problem solved!

## The function is currently defined as
function (base, noutput, fixed = NULL, rts = 2, bound = NULL, 
    add.model = c("additive", "RAM", "BAM", "MIP", "LovPast"), 
    whichDMUs = NULL, print.status = FALSE) 
{
    s &lt;- noutput
    m &lt;- ncol(base) - s
    n &lt;- nrow(base)
    ifelse(!is.null(whichDMUs), nn &lt;- length(whichDMUs), nn &lt;- n)
    if (is.null(whichDMUs)) {
        whichDMUs &lt;- 1:n
    }
    re &lt;- data.frame(matrix(0, nrow = nn, ncol = 1 + n + s + 
        m))
    names(re) &lt;- c("eff", paste("lambda", 1:n, sep = ""), paste("slack.y", 
        1:s, sep = ""), paste("slack.x", 1:m, sep = ""))
    lpmodel &lt;- make.lp(nrow = 0, ncol = n + s + m)
    slacks &lt;- diag(s + m)
    slacks[1:s, ] &lt;- -slacks[1:s, ]
    type &lt;- rep("=", s + m)
    if (!is.null(fixed)) {
        slacks[, fixed] &lt;- 0
        type[fixed[fixed &lt;= s]] &lt;- "&gt;="
        type[fixed[fixed &gt; s]] &lt;- "&lt;="
    }
    A &lt;- cbind(t(base), slacks)
    for (i in 1:(s + m)) {
        add.constraint(lpmodel, xt = A[i, ], type = type[i], 
            rhs = 0)
    }
    if (add.model == "BAM") {
        Uo &lt;- t(apply(data.frame(base[, 1:s]), 2, max) - t(base[, 
            1:s]))
        Li &lt;- t(t(base[, (s + 1):(s + m)]) - apply(data.frame(base[, 
            (s + 1):(s + m)]), 2, min))
        if (!is.null(bound) &amp; rts == 1) {
            index1 &lt;- which(colSums(bound) == 0)
            bound[, index1] &lt;- data.frame(Uo, Li)[, index1]
            if (!is.null(fixed)) {
                bound[fixed] &lt;- 0
            }
        }
        if (is.null(bound) &amp; rts == 1) {
            bound &lt;- data.frame(Uo, Li)
            if (!is.null(fixed)) {
                bound[fixed] &lt;- 0
            }
        }
    }
    if (add.model == "RAM") {
        Ro &lt;- apply(data.frame(base[, 1:s]), 2, max) - apply(data.frame(base[, 
            1:s]), 2, min)
        Ri &lt;- apply(data.frame(base[, (s + 1):(s + m)]), 2, max) - 
            apply(data.frame(base[, (s + 1):(s + m)]), 2, min)
        if (!is.null(bound) &amp; rts == 1) {
            index1 &lt;- which(colSums(bound) == 0)
            bound[, index1] &lt;- t(as.data.frame(matrix(c(Ro, Ri), 
                nrow = s + m, ncol = nrow(base))))[, index1]
            if (!is.null(fixed)) {
                bound[fixed] &lt;- 0
            }
        }
        if (is.null(bound) &amp; rts == 1) {
            bound &lt;- t(as.data.frame(matrix(c(Ro, Ri), nrow = s + 
                m, ncol = nrow(base))))
            if (!is.null(fixed)) {
                bound[fixed] &lt;- 0
            }
        }
    }
    if (!is.null(bound)) {
        index &lt;- which(colSums(bound) != 0)
        nrows &lt;- length(index)
        A.bound &lt;- matrix(0, nrow = nrows, ncol = n + s + m)
        k &lt;- 0
        for (i in index) {
            k &lt;- k + 1
            A.bound[k, n + index[k]] &lt;- 1
        }
        A &lt;- rbind(A, A.bound)
        for (i in 1:k) {
            add.constraint(lpmodel, xt = A[s + m + i, ], type = "&lt;=", 
                rhs = 0)
        }
    }
    syx &lt;- rep(-1, s + m)
    syx[fixed] &lt;- 0
    if (add.model == "additive") {
        set.objfn(lpmodel, c(rep(0, n), syx))
    }
    if (add.model == "RAM") {
        Ro[Ro == 0] &lt;- Inf
        Ri[Ri == 0] &lt;- Inf
        Ranges &lt;- (1/c(Ro, Ri))/abs(sum(syx))
        set.objfn(lpmodel, c(rep(0, n), as.numeric(syx * Ranges)))
    }
    if (add.model == "LovPast") {
        st.dev &lt;- apply(base, 2, sd)
        st.dev[st.dev == 0] &lt;- Inf
        set.objfn(lpmodel, c(rep(0, n), syx/st.dev))
    }
    k &lt;- 0
    if (print.status == TRUE) {
        ifelse(!is.null(whichDMUs), solution.status &lt;- rep(0, 
            nn), solution.status &lt;- rep(0, n))
    }
    if (rts == 2 &amp; is.null(bound)) {
        add.constraint(lpmodel, xt = c(rep(1, n), rep(0, s + 
            m)), type = "=", rhs = 0)
        for (i in whichDMUs) {
            k &lt;- k + 1
            if (add.model == "MIP") {
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx/base[i, 
                  ])))
            }
            if (add.model == "BAM") {
                Uo[i, ][Uo[i, ] == 0] &lt;- Inf
                Li[i, ][Li[i, ] == 0] &lt;- Inf
                Ranges &lt;- (1/c(Uo[i, ], Li[i, ]))/abs(sum(syx))
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx * 
                  Ranges)))
            }
            set.rhs(lpmodel, b = as.numeric(c(base[i, ], 1)))
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(-get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                s + m + n))
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (rts == 2 &amp; !is.null(bound)) {
        add.constraint(lpmodel, xt = c(rep(1, n), rep(0, s + 
            m)), type = "=", rhs = 0)
        for (i in whichDMUs) {
            k &lt;- k + 1
            if (add.model == "MIP") {
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx/base[i, 
                  ])))
            }
            if (add.model == "BAM") {
                Uo[i, ][Uo[i, ] == 0] &lt;- Inf
                Li[i, ][Li[i, ] == 0] &lt;- Inf
                Ranges &lt;- (1/c(Uo[i, ], Li[i, ]))/abs(sum(syx))
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx * 
                  Ranges)))
            }
            if (add.model %in% c("RAM", "BAM")) {
                set.rhs(lpmodel, b = as.numeric(c(base[i, ], 
                  bound[i, index], 1)))
            }
            if (sum(add.model == c("RAM", "BAM")) == 0) {
                bound[bound == 0] &lt;- 10^10
                set.rhs(lpmodel, b = as.numeric(c(base[i, ], 
                  bound[i, index], 1)))
            }
            solve(lpmodel)
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(-get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                s + m + n))
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (rts == 1 &amp; is.null(bound)) {
        for (i in whichDMUs) {
            k &lt;- k + 1
            if (add.model == "MIP") {
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx/base[i, 
                  ])))
            }
            set.rhs(lpmodel, b = as.numeric(base[i, ]))
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(-get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                s + m + n))
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (rts == 1 &amp; !is.null(bound)) {
        for (i in whichDMUs) {
            k &lt;- k + 1
            if (add.model == "MIP") {
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx/base[i, 
                  ])))
            }
            if (add.model == "BAM") {
                Uo[i, ][Uo[i, ] == 0] &lt;- Inf
                Li[i, ][Li[i, ] == 0] &lt;- Inf
                Ranges &lt;- (1/c(Uo[i, ], Li[i, ]))/abs(sum(syx))
                set.objfn(lpmodel, c(rep(0, n), as.numeric(syx * 
                  Ranges)))
            }
            if (add.model %in% c("RAM", "BAM")) {
                set.rhs(lpmodel, b = as.numeric(c(base[i, ], 
                  bound[i, index])))
            }
            if (sum(add.model == c("RAM", "BAM")) == 0) {
                bound[bound == 0] &lt;- 10^10
                set.rhs(lpmodel, b = as.numeric(c(base[i, ], 
                  bound[i, index])))
            }
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            ifelse(x != 0, re[k, ] &lt;- rep(NA, ncol(re)), re[k, 
                ] &lt;- c(-get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                s + m + n)))
        }
    }
    if (!is.null(fixed)) {
        re &lt;- re[, -(1 + n + fixed)]
    }
    if (print.status == TRUE) {
        reList &lt;- list()
        reList[[1]] &lt;- re
        reList[[2]] &lt;- solution.status
        names(reList[[2]]) &lt;- whichDMUs
        re &lt;- reList
    }
    return(re)
  }
</code></pre>

<hr>
<h2 id='dea.sbm'>
Slacks-Based Measure (SBM) of Efficiency
</h2><span id='topic+dea.sbm'></span>

<h3>Description</h3>

<p>Calculate additive Data Envelopment Analysis (DEA) efficiency with the Slacks-Based Measure (SBM) of efficiency (Tone, 2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dea.sbm(base, noutput, fixed = NULL, rts = 2,
  bound = NULL, whichDMUs = NULL, print.status = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dea.sbm_+3A_base">base</code></td>
<td>

<p>A data frame with N rows and S+M columns, where N is the number of Decision-Making Units (DMUs), S is the number of
outputs and M is the number of inputs. 
</p>
</td></tr>
<tr><td><code id="dea.sbm_+3A_noutput">noutput</code></td>
<td>

<p>The number of outputs produced by the DMUs. All DMUs must produce the same number of outputs.
</p>
</td></tr>
<tr><td><code id="dea.sbm_+3A_fixed">fixed</code></td>
<td>

<p>A numeric vector containing column indices for fixed (non-controllable) outputs and/or inputs (if any) in the data.
Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="dea.sbm_+3A_rts">rts</code></td>
<td>

<p>Returns to scale specification. 1 for constant returns to scale and 2 (default) for variable returns to scale.
</p>
</td></tr>
<tr><td><code id="dea.sbm_+3A_bound">bound</code></td>
<td>

<p>A data frame with N rows and S+M columns containing user-defined bounds on the slacks of each DMU. If bounds are
supplied by the user in cases where some outputs and/or inputs are fixed, values should be 0 for these fixed
variables. Same for slacks that do not require bounds. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="dea.sbm_+3A_whichdmus">whichDMUs</code></td>
<td>

<p>Numeric vector specifying the line numbers of the DMUs for which efficiency should be calculated. Defaults to NULL, 
i.e. by default efficiency is calculated for all DMUs in the dataset.
</p>
</td></tr>
<tr><td><code id="dea.sbm_+3A_print.status">print.status</code></td>
<td>

<p>Defaults to FALSE. If the solution of the linear program is NA for one or more DMUs, print.status can be set to TRUE to     find out why.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Slacks-Based Measure (SBM) of efficiency (Tone, 2001) is an additive DEA model that maximizes the sum of input and output slacks for each DMU. Unlike other additive DEA models, SBM's objective function has a ratio form, with input slacks summed in the numerator and output slacks summed in the denominator. These sums in the ratio result in an aggregate measure of all inefficiencies that a DMU may exhibit in its inputs and outputs and can thus be seen as a holistic measure of (Pareto-Koopmans) efficiency. SBM weighs input and output slacks in the objective function with the respective inputs used and outputs produced by each DMU. SBM is units invariant, that is, the value of the aggregate inefficiency score of a DMU is independent of the units in which the inputs and outputs are measured, as long as these units are the same for every DMU. For each DMU, SBM returns an efficiency score that is bounded by 0 and 1.
</p>


<h3>Value</h3>

<p>If print.status=FALSE, returns a data frame with N rows and 1+N+S+M columns. Column 1 reports the inefficiency score of each DMU. Columns 2 to N+1 contain the lambda values (intensity variables) indicating the DMU(s) that serve as reference for each DMU. Columns 1+N+1 to 1+N+S report the optimal output slacks for each DMU. Columns 1+N+S+1 to 1+N+S+M report the optimal input slacks for each DMU. When the linear program of a DMU is infeasible, the row of this DMU in the data frame will have NA values.
</p>
<p>If print.status=TRUE, returns a list with two elements. The first element is the aforementioned data frame. The second element is a numeric vector indicating the solution status of the linear program (e.g. 0: solution found; 2: problem is infeasible; 5: problem needs scaling; etc. See <a href="https://CRAN.R-project.org/package=lpSolveAPI">https://CRAN.R-project.org/package=lpSolveAPI</a>).
</p>


<h3>Author(s)</h3>

<p>Andreas Diomedes Soteriades, <a href="mailto:andreassot10@yahoo.com">andreassot10@yahoo.com</a>
</p>


<h3>References</h3>

<p>Tone K. (2001) A slacks-based measure of efficiency in data envelopment analysis. <em>European Journal of Operational Research</em>, <b>130</b>, 498&ndash;509
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dea.gem">dea.gem</a></code>, <code><a href="#topic+dea.fast">dea.fast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Twelve DMUs, 2 inputs, 2 outputs
# (see Table 1.5 in Cooper et al., 2007):
base &lt;- data.frame(
  y1= c(100,150,160,180,94,230,220,152,190,250,260,250),
  y2= c(90,50,55,72,66,90,88,80,100,100,147,120),
  x1= c(20,19,25,27,22,55,33,31,30,50,53,38),
  x2= c(151,131,160,168,158,255,235,206,244,268,306,284))
  
# Example 1: Get inefficiency scores,
# lambdas and slacks for all DMUs:
dea.sbm(base, noutput= 2, rts= 1)
dea.sbm(base, noutput= 2, rts= 2)

# Example 2: Same as above, but consider output y2 and input x1 as fixed:
dea.sbm(base, noutput= 2, rts= 1, fixed= c(2,3))
dea.sbm(base, noutput= 2, rts= 2, fixed= c(2,3))

# Example 3: Impose an upper bound to all slacks:
# results with bounds
dea.sbm(base, noutput= 2, rts= 1, bound= base/12)$eff
# removing bounds allows for larger inefficiencies:
dea.sbm(base, noutput= 2, rts= 1, bound= NULL)$eff
# check solution status of linear programs when y2 and x1 are fixed
# and y1, x2 slacks are bounded:
bound &lt;- base
fixed &lt;- c(2,3)
bound[fixed] &lt;- 0
dea.sbm(base, noutput= 2, bound= bound,
  fixed= c(2, 3), rts= 1, print.status= TRUE)[[2]]
dea.sbm(base, noutput= 2, bound= bound,
  fixed= c(2, 3), rts= 2, print.status= TRUE)[[2]]

# Example 4: Get inefficiency scores for DMUs 11 and 12:
bound &lt;- base
fixed &lt;- c(2,3)
bound[fixed] &lt;- 0
dea.sbm(base, noutput= 2, bound= bound,
  fixed= c(2, 3), rts= 1, whichDMUs= c(11, 12))$eff
dea.sbm(base, noutput= 2, bound= bound,
  fixed= c(2, 3), rts= 2, whichDMUs= c(11, 12))$eff

## The function is currently defined as
function (base, noutput, fixed = NULL, rts = 2, bound = NULL, 
    whichDMUs = NULL, print.status = FALSE) 
{
    s &lt;- noutput
    m &lt;- ncol(base) - s
    n &lt;- nrow(base)
    ifelse(!is.null(whichDMUs), nn &lt;- length(whichDMUs), nn &lt;- n)
    if (is.null(whichDMUs)) {
        whichDMUs &lt;- 1:n
    }
    re &lt;- data.frame(matrix(0, nrow = nn, ncol = 1 + n + s + 
        m))
    names(re) &lt;- c("eff", paste("lambda", 1:n, sep = ""), paste("slack.y", 
        1:s, sep = ""), paste("slack.x", 1:m, sep = ""))
    slacks &lt;- diag(s + m)
    slacks[1:s, ] &lt;- -slacks[1:s, ]
    type &lt;- rep("=", s + m)
    if (!is.null(fixed)) {
        slacks[, fixed] &lt;- 0
        type[fixed[fixed &lt;= s]] &lt;- "&gt;="
        type[fixed[fixed &gt; s]] &lt;- "&lt;="
    }
    k &lt;- 0
    A.aux &lt;- cbind(t(base), slacks)
    index.fixed.y &lt;- fixed[which(fixed %in% 1:s)]
    index.fixed.x &lt;- fixed[which(fixed %in% (s + 1):(s + m))]
    S &lt;- s - length(index.fixed.y)
    M &lt;- m - length(index.fixed.x)
    if (print.status == TRUE) {
        ifelse(!is.null(whichDMUs), solution.status &lt;- rep(0, 
            nn), solution.status &lt;- rep(0, n))
    }
    if (rts == 2 &amp; is.null(bound)) {
        for (i in whichDMUs) {
            k &lt;- k + 1
            lpmodel &lt;- make.lp(nrow = 0, ncol = 1 + n + s + m)
            A &lt;- cbind(-t(base)[, i], A.aux)
            xt &lt;- as.numeric((1/S) * (1/base[i, 1:s]))
            if (!is.null(fixed)) {
                xt[index.fixed.y] &lt;- 0
            }
            xt &lt;- c(1, rep(0, n), xt, rep(0, m))
            add.constraint(lpmodel, xt = xt, type = "=", rhs = 0)
            for (j in 1:(s + m)) {
                add.constraint(lpmodel, xt = A[j, ], type = type[j], 
                  rhs = 0)
            }
            add.constraint(lpmodel, xt = c(-1, rep(1, n), rep(0, 
                s + m)), type = "=", rhs = 0)
            set.rhs(lpmodel, b = c(1, rep(0, s + m + 1)))
            obj &lt;- as.numeric((-1/M) * (1/base[i, (s + 1):(s + 
                m)]))
            if (!is.null(fixed)) {
                obj[index.fixed.x - s] &lt;- 0
            }
            obj &lt;- c(1, rep(0, n + s), obj)
            set.objfn(lpmodel, obj = obj)
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                n + s + m)/get.primal.solution(lpmodel)[1 + 1 + 
                s + m + 1 + 1])
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (rts == 2 &amp; !is.null(bound)) {
        index &lt;- which(colSums(bound) != 0)
        nrows &lt;- length(index)
        A.bound &lt;- matrix(0, nrow = nrows, ncol = n + s + m)
        kk &lt;- 0
        for (i in index) {
            kk &lt;- kk + 1
            A.bound[kk, n + index[kk]] &lt;- 1
        }
        A.bound &lt;- cbind(0, A.bound)
        for (i in whichDMUs) {
            A.bound &lt;- matrix(0, nrow = nrows, ncol = n + s + 
                m)
            kk &lt;- 0
            for (j in index) {
                kk &lt;- kk + 1
                A.bound[kk, n + index[kk]] &lt;- 1
            }
            A.bound &lt;- cbind(0, A.bound)
            k &lt;- k + 1
            lpmodel &lt;- make.lp(nrow = 0, ncol = 1 + n + s + m)
            A &lt;- cbind(-t(base)[, i], A.aux)
            A.bound[, 1] &lt;- as.numeric(-bound[i, index])
            A.bound[A.bound[, 1] == 0, ] &lt;- 0
            A &lt;- rbind(A, A.bound)
            xt &lt;- as.numeric((1/S) * (1/base[i, 1:s]))
            if (!is.null(fixed)) {
                xt[index.fixed.y] &lt;- 0
            }
            xt &lt;- c(1, rep(0, n), xt, rep(0, m))
            add.constraint(lpmodel, xt = xt, type = "=", rhs = 0)
            for (j in 1:(s + m)) {
                add.constraint(lpmodel, xt = A[j, ], type = type[j], 
                  rhs = 0)
            }
            add.constraint(lpmodel, xt = c(-1, rep(1, n), rep(0, 
                s + m)), type = "=", rhs = 0)
            for (l in 1:kk) {
                add.constraint(lpmodel, xt = A[s + m + l, ], 
                  type = "&lt;=", rhs = 0)
            }
            set.rhs(lpmodel, b = c(1, rep(0, s + m + 1 + l)))
            obj &lt;- as.numeric((-1/M) * (1/base[i, (s + 1):(s + 
                m)]))
            if (!is.null(fixed)) {
                obj[index.fixed.x - s] &lt;- 0
            }
            obj &lt;- c(1, rep(0, n + s), obj)
            set.objfn(lpmodel, obj = obj)
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                n + s + m)/get.primal.solution(lpmodel)[1 + 1 + 
                s + m + 1 + sum(colSums(bound) != 0) + 1])
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (rts == 1 &amp; is.null(bound)) {
        for (i in whichDMUs) {
            k &lt;- k + 1
            lpmodel &lt;- make.lp(nrow = 0, ncol = 1 + n + s + m)
            A &lt;- cbind(-t(base)[, i], A.aux)
            xt &lt;- as.numeric((1/S) * (1/base[i, 1:s]))
            if (!is.null(fixed)) {
                xt[index.fixed.y] &lt;- 0
            }
            xt &lt;- c(1, rep(0, n), xt, rep(0, m))
            add.constraint(lpmodel, xt = xt, type = "=", rhs = 0)
            for (j in 1:(s + m)) {
                add.constraint(lpmodel, xt = A[j, ], type = type[j], 
                  rhs = 0)
            }
            set.rhs(lpmodel, b = c(1, rep(0, s + m)))
            obj &lt;- as.numeric((-1/M) * (1/base[i, (s + 1):(s + 
                m)]))
            if (!is.null(fixed)) {
                obj[index.fixed.x - s] &lt;- 0
            }
            obj &lt;- c(1, rep(0, n + s), obj)
            set.objfn(lpmodel, obj = obj)
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                n + s + m)/get.primal.solution(lpmodel)[1 + 1 + 
                s + m + 1])
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (rts == 1 &amp; !is.null(bound)) {
        index &lt;- which(colSums(bound) != 0)
        nrows &lt;- length(index)
        A.bound &lt;- matrix(0, nrow = nrows, ncol = n + s + m)
        kk &lt;- 0
        for (i in index) {
            kk &lt;- kk + 1
            A.bound[kk, n + index[kk]] &lt;- 1
        }
        A.bound &lt;- cbind(0, A.bound)
        for (i in whichDMUs) {
            k &lt;- k + 1
            lpmodel &lt;- make.lp(nrow = 0, ncol = 1 + n + s + m)
            A &lt;- cbind(-t(base)[, i], A.aux)
            A.bound[, 1] &lt;- as.numeric(-bound[i, index])
            A.bound[A.bound[, 1] == 0, ] &lt;- 0
            A &lt;- rbind(A, A.bound)
            xt &lt;- as.numeric((1/S) * (1/base[i, 1:s]))
            if (!is.null(fixed)) {
                xt[index.fixed.y] &lt;- 0
            }
            xt &lt;- c(1, rep(0, n), xt, rep(0, m))
            add.constraint(lpmodel, xt = xt, type = "=", rhs = 0)
            for (j in 1:(s + m)) {
                add.constraint(lpmodel, xt = A[j, ], type = type[j], 
                  rhs = 0)
            }
            for (l in 1:kk) {
                add.constraint(lpmodel, xt = A[s + m + l, ], 
                  type = "&lt;=", rhs = 0)
            }
            set.rhs(lpmodel, b = c(1, rep(0, s + m + l)))
            obj &lt;- as.numeric((-1/M) * (1/base[i, (s + 1):(s + 
                m)]))
            if (!is.null(fixed)) {
                obj[index.fixed.x - s] &lt;- 0
            }
            obj &lt;- c(1, rep(0, n + s), obj)
            set.objfn(lpmodel, obj = obj)
            x &lt;- solve(lpmodel)
            if (print.status == TRUE) {
                solution.status[k] &lt;- x
            }
            re[k, ] &lt;- c(get.objective(lpmodel), tail(get.primal.solution(lpmodel), 
                n + s + m)/get.primal.solution(lpmodel)[1 + 1 + 
                s + m + sum(colSums(bound) != 0) + 1])
            if (x != 0) {
                re[k, ] &lt;- rep(NA, ncol(re))
            }
        }
    }
    if (!is.null(fixed)) {
        re &lt;- re[, -(1 + n + fixed)]
    }
    if (print.status == TRUE) {
        reList &lt;- list()
        reList[[1]] &lt;- re
        reList[[2]] &lt;- solution.status
        names(reList[[2]]) &lt;- whichDMUs
        re &lt;- reList
    }
    return(re)
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
