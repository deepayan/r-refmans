<!DOCTYPE html><html lang="en"><head><title>Help for package WARDEN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WARDEN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_item'><p>Defining parameters that may be used in model calculations</p></a></li>
<li><a href='#add_reactevt'><p>Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event</p></a></li>
<li><a href='#add_tte'><p>Define events and the initial event time</p></a></li>
<li><a href='#ast_as_list'><p>Transform a substituted expression to its Abstract Syntax Tree (AST) as a list</p></a></li>
<li><a href='#ceac_des'><p>Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result</p></a></li>
<li><a href='#cond_dirichlet'><p>Calculate conditional dirichlet values</p></a></li>
<li><a href='#cond_mvn'><p>Calculate conditional multivariate normal values</p></a></li>
<li><a href='#create_indicators'><p>Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis</p></a></li>
<li><a href='#disc_cycle'><p>Cycle discounting</p></a></li>
<li><a href='#disc_cycle_v'><p>Cycle discounting for vectors</p></a></li>
<li><a href='#disc_instant'><p>Calculate instantaneous discounted costs or qalys</p></a></li>
<li><a href='#disc_instant_v'><p>Calculate instantaneous discounted costs or qalys for vectors</p></a></li>
<li><a href='#disc_ongoing'><p>Calculate discounted costs and qalys between events</p></a></li>
<li><a href='#disc_ongoing_v'><p>Calculate discounted costs and qalys between events for vectors</p></a></li>
<li><a href='#draw_tte'><p>Draw a time to event from a list of parametric survival functions</p></a></li>
<li><a href='#evpi_des'><p>Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result</p></a></li>
<li><a href='#extract_elements_from_list'><p>Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event</p></a></li>
<li><a href='#extract_from_reactions'><p>Extract all items and events and their interactions from the event reactions list</p></a></li>
<li><a href='#extract_psa_result'><p>Extract PSA results from a treatment</p></a></li>
<li><a href='#luck_adj'><p>Perform luck adjustment</p></a></li>
<li><a href='#modify_event'><p>Modify the time of existing events</p></a></li>
<li><a href='#modify_item'><p>Modify the value of existing items</p></a></li>
<li><a href='#modify_item_seq'><p>Modify the value of existing items</p></a></li>
<li><a href='#new_event'><p>Generate new events to be added to existing vector of events</p></a></li>
<li><a href='#pcond_gompertz'><p>Survival Probaility function for conditional Gompertz distribution (lower bound only)</p></a></li>
<li><a href='#pick_psa'><p>Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within <code>pick_val_v</code>.</p></a></li>
<li><a href='#pick_val_v'><p>Select which values should be applied in the corresponding loop for several values (vector or list).</p></a></li>
<li><a href='#qbeta_mse'><p>Draw from a beta distribution based on mean and se (quantile)</p></a></li>
<li><a href='#qcond_exp'><p>Conditional quantile function for exponential distribution</p></a></li>
<li><a href='#qcond_gamma'><p>Conditional quantile function for gamma distribution</p></a></li>
<li><a href='#qcond_gompertz'><p>Quantile function for conditional Gompertz distribution (lower bound only)</p></a></li>
<li><a href='#qcond_llogis'><p>Conditional quantile function for loglogistic distribution</p></a></li>
<li><a href='#qcond_lnorm'><p>Conditional quantile function for lognormal distribution</p></a></li>
<li><a href='#qcond_norm'><p>Conditional quantile function for normal distribution</p></a></li>
<li><a href='#qcond_weibull'><p>Conditional quantile function for weibull distribution</p></a></li>
<li><a href='#rbeta_mse'><p>Draw from a beta distribution based on mean and se</p></a></li>
<li><a href='#rcond_gompertz'><p>Draw from a conditional Gompertz distribution (lower bound only)</p></a></li>
<li><a href='#rcond_gompertz_lu'><p>Draw from a Conditional Gompertz distribution (lower and upper bound)</p></a></li>
<li><a href='#rdirichlet'><p>Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet</p></a></li>
<li><a href='#rdirichlet_prob'><p>Draw from a dirichlet distribution based on mean transition probabilities and standard errors</p></a></li>
<li><a href='#replicate_profiles'><p>Replicate profiles data.frame</p></a></li>
<li><a href='#rgamma_mse'><p>Draw from a gamma distribution based on mean and se</p></a></li>
<li><a href='#rpoisgamma'><p>Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process</p></a></li>
<li><a href='#run_sim'><p>Run the simulation</p></a></li>
<li><a href='#run_sim_parallel'><p>Run simulations in parallel mode (at the simulation level)</p></a></li>
<li><a href='#summary_results_det'><p>Deterministic results for a specific treatment</p></a></li>
<li><a href='#summary_results_sens'><p>Summary of sensitivity outputs for a treatment</p></a></li>
<li><a href='#summary_results_sim'><p>Summary of PSA outputs for a treatment</p></a></li>
<li><a href='#tte.df'><p>Example TTE IPD data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Workflows for Health Technology Assessments in R using Discrete
EveNts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Toolkit to support and perform discrete event simulations without
    resource constraints in the context of health technology assessments (HTA).
    The package focuses on cost-effectiveness modelling and aims to be submission-ready
    to relevant HTA bodies in alignment with 'NICE TSD 15'
    <a href="https://www.sheffield.ac.uk/nice-dsu/tsds/patient-level-simulation">https://www.sheffield.ac.uk/nice-dsu/tsds/patient-level-simulation</a>.
    More details an examples can be found in the package website <a href="https://jsanchezalv.github.io/WARDEN/">https://jsanchezalv.github.io/WARDEN/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, ggplot2, knitr, rmarkdown, kableExtra, DiagrammeR,
testthat (&ge; 3.0.0), survminer, survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr, data.table, foreach, future, doFuture, stats, utils,
flexsurv, MASS, zoo, progressr, magrittr, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jsanchezalv.github.io/WARDEN/">https://jsanchezalv.github.io/WARDEN/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-12 15:05:06 UTC; Javier</td>
</tr>
<tr>
<td>Author:</td>
<td>Javier Sanchez Alvarez [aut, cre],
  Gabriel Lemyre [ctb],
  Valerie Aponte Ribero [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javier Sanchez Alvarez &lt;javiersanchezeco@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-13 16:40:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_item'>Defining parameters that may be used in model calculations</h2><span id='topic+add_item'></span>

<h3>Description</h3>

<p>Defining parameters that may be used in model calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_item(.data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_item_+3A_.data">.data</code></td>
<td>
<p>Existing data</p>
</td></tr>
<tr><td><code id="add_item_+3A_...">...</code></td>
<td>
<p>Items to define for the simulation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions to add/modify events/inputs use lists. Whenever several inputs/events are added or modified, it's recommended to group them within one function, as it reduces the computation cost.
So rather than use two <code>add_item</code> with a list of one element, it's better to group them into a single <code>add_item</code> with a list of two elements.
</p>
<p>Whenever a function is directly implemented which must be evaluated later and that has no object name attached (e.g., <code>pick_val_v</code>),
it should be implemented after a first <code>add_item()</code> (empty or with content) to avoid confusing the <code>.data</code> argument, or wrapping the function within <code>substitute()</code>
</p>


<h3>Value</h3>

<p>A list of items
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)

add_item(fl.idfs = 0)
add_item(util_idfs = if(psa_bool){rnorm(1,0.8,0.2)} else{0.8}, util.mbc = 0.6, cost_idfs = 2500)
common_inputs &lt;- add_item() %&gt;%
add_item(pick_val_v(
  base      = l_statics[["base"]],
  psa       = pick_psa(
    l_statics[["function"]],
    l_statics[["n"]],
    l_statics[["a"]],
    l_statics[["b"]]
  ),
  sens      = l_statics[[sens_name_used]],
  psa_ind   = psa_bool,
  sens_ind  = sensitivity_bool,
  indicator = indicators_statics,
  names_out = l_statics[["parameter_name"]]
)
)

</code></pre>

<hr>
<h2 id='add_reactevt'>Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event</h2><span id='topic+add_reactevt'></span>

<h3>Description</h3>

<p>Define the modifications to other events, costs, utilities, or other items affected by the occurrence of the event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_reactevt(.data = NULL, name_evt, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_reactevt_+3A_.data">.data</code></td>
<td>
<p>Existing data for event reactions</p>
</td></tr>
<tr><td><code id="add_reactevt_+3A_name_evt">name_evt</code></td>
<td>
<p>Name of the event for which reactions are defined.</p>
</td></tr>
<tr><td><code id="add_reactevt_+3A_input">input</code></td>
<td>
<p>Expressions that define what happens at the event, using functions as defined in the Details section</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are a series of objects that can be used in this context to help define the event reactions.
</p>
<p>The following functions may be used to define event reactions within this <code>add_reactevt()</code> function:
<code>modify_item()</code> | Adds &amp; Modifies items/flags/variables for future events (does not consider sequential)
<code>modify_item_seq()</code> | Adds &amp; Modifies items/flags/variables for future events in a sequential manner
<code>new_event()</code> | Adds events to the vector of events for that patient
<code>modify_event()</code> | Modifies existing events by changing their time
</p>
<p>Apart from the items defined with add_item(), we can also use standard variables that are always defined within the simulation:
<code>curtime</code> | Current event time (numeric)
<code>prevtime</code> | Time of the previous event (numeric)
<code>cur_evtlist</code> | Named vector of events that is yet to happen for that patient (named numeric vector)
<code>evt</code> | Current event being processed (character)
<code>i</code> | Patient being iterated (character)
<code>simulation</code> | Simulation being iterated (numeric)
</p>
<p>The model will run until <code>curtime</code> is set to <code>Inf</code>, so the event that terminates the model should modify <code>curtime</code> and set it to <code>Inf</code>.
</p>
<p>The user can use <code>extract_from_reactions</code> function on the output to obtain a data.frame with all the relationships defined in the reactions in the model.
</p>


<h3>Value</h3>

<p>A named list with the event name, and inside it the substituted expression saved for later evaluation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_reactevt(name_evt = "start",input = {})
add_reactevt(name_evt = "idfs",input = {modify_item(list("fl.idfs"= 0))})
</code></pre>

<hr>
<h2 id='add_tte'>Define events and the initial event time</h2><span id='topic+add_tte'></span>

<h3>Description</h3>

<p>Define events and the initial event time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_tte(.data = NULL, arm, evts, other_inp = NULL, input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_tte_+3A_.data">.data</code></td>
<td>
<p>Existing data for initial event times</p>
</td></tr>
<tr><td><code id="add_tte_+3A_arm">arm</code></td>
<td>
<p>The intervention for which the events and initial event times are defined</p>
</td></tr>
<tr><td><code id="add_tte_+3A_evts">evts</code></td>
<td>
<p>A vector of the names of the events</p>
</td></tr>
<tr><td><code id="add_tte_+3A_other_inp">other_inp</code></td>
<td>
<p>A vector of other input variables that should be saved during the simulation</p>
</td></tr>
<tr><td><code id="add_tte_+3A_input">input</code></td>
<td>
<p>The definition of initial event times for the events listed in the evts argument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Events need to be separately defined for each intervention.
</p>
<p>For each event that is defined in this list, the user needs to add a reaction to the event using the <code>add_reactevt()</code> function which will determine what calculations will happen at an event.
</p>


<h3>Value</h3>

<p>A list of initial events and event times
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_tte(arm="int",evts = c("start","ttot","idfs","os"),
input={
start &lt;- 0
idfs &lt;- draw_tte(1,'lnorm',coef1=2, coef2=0.5)
ttot &lt;- min(draw_tte(1,'lnorm',coef1=1, coef2=4),idfs)
os &lt;- draw_tte(1,'lnorm',coef1=0.8, coef2=0.2)
})

</code></pre>

<hr>
<h2 id='ast_as_list'>Transform a substituted expression to its Abstract Syntax Tree (AST) as a list</h2><span id='topic+ast_as_list'></span>

<h3>Description</h3>

<p>Transform a substituted expression to its Abstract Syntax Tree (AST) as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ast_as_list(ee)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ast_as_list_+3A_ee">ee</code></td>
<td>
<p>Substituted expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list with the Abstract Syntax Tree (AST)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- substitute({

a &lt;- sum(5+7)

modify_item(list(afsa=ifelse(TRUE,"asda",NULL)))

modify_item_seq(list(
  
  o_other_q_gold1 = if(gold == 1) { utility } else { 0 },
  
  o_other_q_gold2 = if(gold == 2) { utility } else { 0 },
  
  o_other_q_gold3 = if(gold == 3) { utility } else { 0 },
  
  o_other_q_gold4 = if(gold == 4) { utility } else { 0 },
  
  o_other_q_on_dup = if(on_dup) { utility } else { 0 }
 
))

if(a==1){
  modify_item(list(a=list(6+b)))
  
  modify_event(list(e_exn = curtime + 14 / days_in_year + qexp(rnd_exn, r_exn)))
} else{
  modify_event(list(e_exn = curtime + 14 / days_in_year + qexp(rnd_exn, r_exn)))
  if(a&gt;6){
    modify_item(list(a=8))
  }
  
}


if (sel_resp_incl == 1 &amp; on_dup == 1) {
  
  modify_event(list(e_response = curtime, z = 6))
  
}

})


out &lt;- ast_as_list(expr)

</code></pre>

<hr>
<h2 id='ceac_des'>Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result</h2><span id='topic+ceac_des'></span>

<h3>Description</h3>

<p>Calculate the cost-effectiveness acceptability curve (CEAC) for a DES model with a PSA result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceac_des(wtp, results, interventions = NULL, sensitivity_used = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ceac_des_+3A_wtp">wtp</code></td>
<td>
<p>Vector of length &gt;=1 with the willingness to pay</p>
</td></tr>
<tr><td><code id="ceac_des_+3A_results">results</code></td>
<td>
<p>The list object returned by <code>run_sim()</code></p>
</td></tr>
<tr><td><code id="ceac_des_+3A_interventions">interventions</code></td>
<td>
<p>A character vector with the names of the interventions to be used for the analysis</p>
</td></tr>
<tr><td><code id="ceac_des_+3A_sensitivity_used">sensitivity_used</code></td>
<td>
<p>Integer signaling which sensitivity analysis to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the CEAC results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- list(list(list(sensitivity_name = "", arm_list = c("int", "noint"
), total_lys = c(int = 9.04687362556945, noint = 9.04687362556945
), total_qalys = c(int = 6.20743830697466, noint = 6.18115138126336
), total_costs = c(int = 49921.6357486899, noint = 41225.2544659378
), total_lys_undisc = c(int = 10.8986618377039, noint = 10.8986618377039
), total_qalys_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), total_costs_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), c_default = c(int = 49921.6357486899, noint = 41225.2544659378
), c_default_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), q_default = c(int = 6.20743830697466, noint = 6.18115138126336
), q_default_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), merged_df = list(simulation = 1L, sensitivity = 1L))))

ceac_des(seq(from=10000,to=500000,by=10000),res)

</code></pre>

<hr>
<h2 id='cond_dirichlet'>Calculate conditional dirichlet values</h2><span id='topic+cond_dirichlet'></span>

<h3>Description</h3>

<p>Calculate conditional dirichlet values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_dirichlet(alpha, i, xi, full_output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cond_dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="cond_dirichlet_+3A_i">i</code></td>
<td>
<p>index of the known parameter (1-based index)</p>
</td></tr>
<tr><td><code id="cond_dirichlet_+3A_xi">xi</code></td>
<td>
<p>known value of the i-th parameter (should be &gt;0)</p>
</td></tr>
<tr><td><code id="cond_dirichlet_+3A_full_output">full_output</code></td>
<td>
<p>boolean indicating whether to return the full list of parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to compute conditional dirichlet values
</p>


<h3>Value</h3>

<p>List of length 2, one with new mu and other with covariance parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha &lt;- c(2, 3, 4)
i &lt;- 2  # Index of the known parameter
xi &lt;- 0.5  # Known value of the second parameter

# Compute the conditional alpha parameters with full output
cond_dirichlet(alpha, i, xi, full_output = TRUE)
</code></pre>

<hr>
<h2 id='cond_mvn'>Calculate conditional multivariate normal values</h2><span id='topic+cond_mvn'></span>

<h3>Description</h3>

<p>Calculate conditional multivariate normal values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_mvn(mu, Sigma, i, xi, full_output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cond_mvn_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="cond_mvn_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code id="cond_mvn_+3A_i">i</code></td>
<td>
<p>index of the known parameter (1-based index)</p>
</td></tr>
<tr><td><code id="cond_mvn_+3A_xi">xi</code></td>
<td>
<p>known value of the i-th parameter</p>
</td></tr>
<tr><td><code id="cond_mvn_+3A_full_output">full_output</code></td>
<td>
<p>boolean indicating whether to return the full list of parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to compute conditional multivariate normal values
</p>


<h3>Value</h3>

<p>List of length 2, one with new mu and other with covariance parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(1, 2, 3)
Sigma &lt;- matrix(c(0.2, 0.05, 0.1, 
                  0.05, 0.3, 0.05, 
                  0.1, 0.05, 0.4), nrow = 3)

i &lt;- 1:2  # Index of the known parameter
xi &lt;- c(1.2,2.3)  # Known value of the first parameter

cond_mvn(mu, Sigma, i, xi,full_output = TRUE)
</code></pre>

<hr>
<h2 id='create_indicators'>Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis</h2><span id='topic+create_indicators'></span>

<h3>Description</h3>

<p>Creates a vector of indicators (0 and 1) for sensitivity/DSA analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_indicators(sens, n_sensitivity, elem, n_elem_before = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_indicators_+3A_sens">sens</code></td>
<td>
<p>current analysis iterator</p>
</td></tr>
<tr><td><code id="create_indicators_+3A_n_sensitivity">n_sensitivity</code></td>
<td>
<p>total number of analyses to be run</p>
</td></tr>
<tr><td><code id="create_indicators_+3A_elem">elem</code></td>
<td>
<p>vector of 0s and 1s of elements to iterate through (1 = parameter is to be included in scenario/DSA)</p>
</td></tr>
<tr><td><code id="create_indicators_+3A_n_elem_before">n_elem_before</code></td>
<td>
<p>Sum of 1s (# of parameters to be included in scenario/DSA) that go before elem</p>
</td></tr>
</table>


<h3>Details</h3>

<p>n_elem_before is to be used when several indicators want to be used (e.g., for patient level and common level inputs) while facilitating readibility of the code
</p>


<h3>Value</h3>

<p>Numeric vector composed of 0 and 1, where value 1 will be used by <code>pick_val_v</code> to pick the corresponding index in its <code>sens</code> argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_indicators(10,20,c(1,1,1,1))
create_indicators(7,20,c(1,0,0,1,1,1,0,0,1,1),2)
</code></pre>

<hr>
<h2 id='disc_cycle'>Cycle discounting</h2><span id='topic+disc_cycle'></span>

<h3>Description</h3>

<p>Cycle discounting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_cycle(
  lcldr = 0.035,
  lclprvtime = 0,
  cyclelength,
  lclcurtime,
  lclval,
  starttime = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_cycle_+3A_lcldr">lcldr</code></td>
<td>
<p>The discount rate</p>
</td></tr>
<tr><td><code id="disc_cycle_+3A_lclprvtime">lclprvtime</code></td>
<td>
<p>The time of the previous event in the simulation</p>
</td></tr>
<tr><td><code id="disc_cycle_+3A_cyclelength">cyclelength</code></td>
<td>
<p>The cycle length</p>
</td></tr>
<tr><td><code id="disc_cycle_+3A_lclcurtime">lclcurtime</code></td>
<td>
<p>The time of the current event in the simulation</p>
</td></tr>
<tr><td><code id="disc_cycle_+3A_lclval">lclval</code></td>
<td>
<p>The  value to be discounted</p>
</td></tr>
<tr><td><code id="disc_cycle_+3A_starttime">starttime</code></td>
<td>
<p>The start time for accrual of cycle costs (if not 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double based on cycle discounting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_cycle(lcldr=0.035, lclprvtime=0, cyclelength=1/12, lclcurtime=2, lclval=500,starttime=0)


</code></pre>

<hr>
<h2 id='disc_cycle_v'>Cycle discounting for vectors</h2><span id='topic+disc_cycle_v'></span>

<h3>Description</h3>

<p>Cycle discounting for vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_cycle_v(
  lcldr = 0.035,
  lclprvtime = 0,
  cyclelength,
  lclcurtime,
  lclval,
  starttime = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_cycle_v_+3A_lcldr">lcldr</code></td>
<td>
<p>The discount rate</p>
</td></tr>
<tr><td><code id="disc_cycle_v_+3A_lclprvtime">lclprvtime</code></td>
<td>
<p>The time of the previous event in the simulation</p>
</td></tr>
<tr><td><code id="disc_cycle_v_+3A_cyclelength">cyclelength</code></td>
<td>
<p>The cycle length</p>
</td></tr>
<tr><td><code id="disc_cycle_v_+3A_lclcurtime">lclcurtime</code></td>
<td>
<p>The time of the current event in the simulation</p>
</td></tr>
<tr><td><code id="disc_cycle_v_+3A_lclval">lclval</code></td>
<td>
<p>The  value to be discounted</p>
</td></tr>
<tr><td><code id="disc_cycle_v_+3A_starttime">starttime</code></td>
<td>
<p>The start time for accrual of cycle costs (if not 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double based on cycle discounting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_cycle_v(lcldr=0.035, lclprvtime=0, cyclelength=1/12, lclcurtime=2, lclval=500,starttime=0)


</code></pre>

<hr>
<h2 id='disc_instant'>Calculate instantaneous discounted costs or qalys</h2><span id='topic+disc_instant'></span>

<h3>Description</h3>

<p>Calculate instantaneous discounted costs or qalys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_instant(lcldr = 0.035, lclcurtime, lclval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_instant_+3A_lcldr">lcldr</code></td>
<td>
<p>The discount rate</p>
</td></tr>
<tr><td><code id="disc_instant_+3A_lclcurtime">lclcurtime</code></td>
<td>
<p>The time of the current event in the simulation</p>
</td></tr>
<tr><td><code id="disc_instant_+3A_lclval">lclval</code></td>
<td>
<p>The value to be discounted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double based on discrete time discounting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_instant(lcldr=0.035, lclcurtime=3, lclval=2500)


</code></pre>

<hr>
<h2 id='disc_instant_v'>Calculate instantaneous discounted costs or qalys for vectors</h2><span id='topic+disc_instant_v'></span>

<h3>Description</h3>

<p>Calculate instantaneous discounted costs or qalys for vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_instant_v(lcldr = 0.035, lclcurtime, lclval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_instant_v_+3A_lcldr">lcldr</code></td>
<td>
<p>The discount rate</p>
</td></tr>
<tr><td><code id="disc_instant_v_+3A_lclcurtime">lclcurtime</code></td>
<td>
<p>The time of the current event in the simulation</p>
</td></tr>
<tr><td><code id="disc_instant_v_+3A_lclval">lclval</code></td>
<td>
<p>The value to be discounted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double based on discrete time discounting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_instant_v(lcldr=0.035, lclcurtime=3, lclval=2500)


</code></pre>

<hr>
<h2 id='disc_ongoing'>Calculate discounted costs and qalys between events</h2><span id='topic+disc_ongoing'></span>

<h3>Description</h3>

<p>Calculate discounted costs and qalys between events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_ongoing(lcldr = 0.035, lclprvtime, lclcurtime, lclval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_ongoing_+3A_lcldr">lcldr</code></td>
<td>
<p>The discount rate</p>
</td></tr>
<tr><td><code id="disc_ongoing_+3A_lclprvtime">lclprvtime</code></td>
<td>
<p>The time of the previous event in the simulation</p>
</td></tr>
<tr><td><code id="disc_ongoing_+3A_lclcurtime">lclcurtime</code></td>
<td>
<p>The time of the current event in the simulation</p>
</td></tr>
<tr><td><code id="disc_ongoing_+3A_lclval">lclval</code></td>
<td>
<p>The value to be discounted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double based on continuous time discounting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_ongoing(lcldr=0.035,lclprvtime=0.5, lclcurtime=3, lclval=2500)


</code></pre>

<hr>
<h2 id='disc_ongoing_v'>Calculate discounted costs and qalys between events for vectors</h2><span id='topic+disc_ongoing_v'></span>

<h3>Description</h3>

<p>Calculate discounted costs and qalys between events for vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc_ongoing_v(lcldr = 0.035, lclprvtime, lclcurtime, lclval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_ongoing_v_+3A_lcldr">lcldr</code></td>
<td>
<p>The discount rate</p>
</td></tr>
<tr><td><code id="disc_ongoing_v_+3A_lclprvtime">lclprvtime</code></td>
<td>
<p>The time of the previous event in the simulation</p>
</td></tr>
<tr><td><code id="disc_ongoing_v_+3A_lclcurtime">lclcurtime</code></td>
<td>
<p>The time of the current event in the simulation</p>
</td></tr>
<tr><td><code id="disc_ongoing_v_+3A_lclval">lclval</code></td>
<td>
<p>The value to be discounted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Double based on continuous time discounting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>disc_ongoing_v(lcldr=0.035,lclprvtime=0.5, lclcurtime=3, lclval=2500)


</code></pre>

<hr>
<h2 id='draw_tte'>Draw a time to event from a list of parametric survival functions</h2><span id='topic+draw_tte'></span>

<h3>Description</h3>

<p>Draw a time to event from a list of parametric survival functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_tte(
  n_chosen,
  dist,
  coef1 = NULL,
  coef2 = NULL,
  coef3 = NULL,
  ...,
  beta_tx = 1,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_tte_+3A_n_chosen">n_chosen</code></td>
<td>
<p>The number of observations to be drawn</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_dist">dist</code></td>
<td>
<p>The distribution; takes values 'lnorm','norm','mvnorm','weibullPH','weibull','llogis','gompertz','gengamma','gamma','exp','beta','poisgamma'</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_coef1">coef1</code></td>
<td>
<p>First coefficient of the distribution, defined as in the coef() output on a flexsurvreg object (rate in &quot;rpoisgamma&quot;)</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_coef2">coef2</code></td>
<td>
<p>Second coefficient of the distribution, defined as in the coef() output on a flexsurvreg object (theta in &quot;rpoisgamma&quot;)</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_coef3">coef3</code></td>
<td>
<p>Third coefficient of the distribution, defined as in the coef() output on a flexsurvreg object (not used in &quot;rpoisgamma&quot;)</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_...">...</code></td>
<td>
<p>Additional arguments to be used by the specific distribution (e.g., return_ind_rate if dist = &quot;poisgamma&quot;)</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_beta_tx">beta_tx</code></td>
<td>
<p>Parameter in natural scale applied in addition to the scale/rate coefficient -e.g., a HR if used in an exponential- (not used in &quot;rpoisgamma&quot; nor &quot;beta&quot;)</p>
</td></tr>
<tr><td><code id="draw_tte_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Other arguments relevant to each function can be called directly
</p>


<h3>Value</h3>

<p>A vector of time to event estimates from the given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_tte(n_chosen=1,dist='exp',coef1=1,beta_tx=1)
draw_tte(n_chosen=10,"poisgamma",coef1=1,coef2=1,obs_time=1,return_ind_rate=FALSE)
</code></pre>

<hr>
<h2 id='evpi_des'>Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result</h2><span id='topic+evpi_des'></span>

<h3>Description</h3>

<p>Calculate the Expected Value of Perfect Information (EVPI) for a DES model with a PSA result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evpi_des(wtp, results, interventions = NULL, sensitivity_used = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evpi_des_+3A_wtp">wtp</code></td>
<td>
<p>Vector of length &gt;=1 with the willingness to pay</p>
</td></tr>
<tr><td><code id="evpi_des_+3A_results">results</code></td>
<td>
<p>The list object returned by <code>run_sim()</code></p>
</td></tr>
<tr><td><code id="evpi_des_+3A_interventions">interventions</code></td>
<td>
<p>A character vector with the names of the interventions to be used for the analysis</p>
</td></tr>
<tr><td><code id="evpi_des_+3A_sensitivity_used">sensitivity_used</code></td>
<td>
<p>Integer signaling which sensitivity analysis to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the EVPI results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- list(list(list(sensitivity_name = "", arm_list = c("int", "noint"
), total_lys = c(int = 9.04687362556945, noint = 9.04687362556945
), total_qalys = c(int = 6.20743830697466, noint = 6.18115138126336
), total_costs = c(int = 49921.6357486899, noint = 41225.2544659378
), total_lys_undisc = c(int = 10.8986618377039, noint = 10.8986618377039
), total_qalys_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), total_costs_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), c_default = c(int = 49921.6357486899, noint = 41225.2544659378
), c_default_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), q_default = c(int = 6.20743830697466, noint = 6.18115138126336
), q_default_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), merged_df = list(simulation = 1L, sensitivity = 1L))))

evpi_des(seq(from=10000,to=500000,by=10000),res)

</code></pre>

<hr>
<h2 id='extract_elements_from_list'>Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event</h2><span id='topic+extract_elements_from_list'></span>

<h3>Description</h3>

<p>Extracts items and events by looking into modify_item, modify_item_seq, modify_event and new_event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_elements_from_list(node, conditional_flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_elements_from_list_+3A_node">node</code></td>
<td>
<p>Relevant node within the nested AST list</p>
</td></tr>
<tr><td><code id="extract_elements_from_list_+3A_conditional_flag">conditional_flag</code></td>
<td>
<p>Boolean whether the statement is contained within a conditional statement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the relevant item/event, the event where it's assigned,
and whether it's contained within a conditional statement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expr &lt;- substitute({

a &lt;- sum(5+7)

modify_item(list(afsa=ifelse(TRUE,"asda",NULL)))

modify_item_seq(list(
  
  o_other_q_gold1 = if(gold == 1) { utility } else { 0 },
  
  o_other_q_gold2 = if(gold == 2) { utility } else { 0 },
  
  o_other_q_gold3 = if(gold == 3) { utility } else { 0 },
  
  o_other_q_gold4 = if(gold == 4) { utility } else { 0 },
  
  o_other_q_on_dup = if(on_dup) { utility } else { 0 }
 
))

if(a==1){
  modify_item(list(a=list(6+b)))
  
  modify_event(list(e_exn = curtime + 14 / days_in_year + qexp(rnd_exn, r_exn)))
} else{
  modify_event(list(e_exn = curtime + 14 / days_in_year + qexp(rnd_exn, r_exn)))
  if(a&gt;6){
    modify_item(list(a=8))
  }
  
}


if (sel_resp_incl == 1 &amp; on_dup == 1) {
  
  modify_event(list(e_response = curtime, z = 6))
  
}

})


out &lt;- ast_as_list(expr)

results &lt;- extract_elements_from_list(out)


</code></pre>

<hr>
<h2 id='extract_from_reactions'>Extract all items and events and their interactions from the event reactions list</h2><span id='topic+extract_from_reactions'></span>

<h3>Description</h3>

<p>Extract all items and events and their interactions from the event reactions list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_from_reactions(reactions)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_from_reactions_+3A_reactions">reactions</code></td>
<td>
<p>list generated through <code>add_reactevt</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the relevant item/event, the event where it's assigned,
and whether it's contained within a conditional statement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- add_reactevt(name_evt="example",
   input={
      modify_item(list(w=5))
   })
   
 extract_from_reactions(a)


</code></pre>

<hr>
<h2 id='extract_psa_result'>Extract PSA results from a treatment</h2><span id='topic+extract_psa_result'></span>

<h3>Description</h3>

<p>Extract PSA results from a treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_psa_result(x, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_psa_result_+3A_x">x</code></td>
<td>
<p>The output_sim data frame from the list object returned by <code>run_sim()</code></p>
</td></tr>
<tr><td><code id="extract_psa_result_+3A_element">element</code></td>
<td>
<p>Variable for which PSA results are being extracted (single string)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with PSA results from the specified intervention
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- list(list(list(sensitivity_name = "", arm_list = c("int", "noint"
), total_lys = c(int = 9.04687362556945, noint = 9.04687362556945
), total_qalys = c(int = 6.20743830697466, noint = 6.18115138126336
), total_costs = c(int = 49921.6357486899, noint = 41225.2544659378
), total_lys_undisc = c(int = 10.8986618377039, noint = 10.8986618377039
), total_qalys_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), total_costs_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), c_default = c(int = 49921.6357486899, noint = 41225.2544659378
), c_default_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), q_default = c(int = 6.20743830697466, noint = 6.18115138126336
), q_default_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), merged_df = list(simulation = 1L, sensitivity = 1L))))


extract_psa_result(res[[1]],"total_costs")
</code></pre>

<hr>
<h2 id='luck_adj'>Perform luck adjustment</h2><span id='topic+luck_adj'></span>

<h3>Description</h3>

<p>Perform luck adjustment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>luck_adj(prevsurv, cursurv, luck, condq = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="luck_adj_+3A_prevsurv">prevsurv</code></td>
<td>
<p>Value of the previous survival</p>
</td></tr>
<tr><td><code id="luck_adj_+3A_cursurv">cursurv</code></td>
<td>
<p>Value of the current survival</p>
</td></tr>
<tr><td><code id="luck_adj_+3A_luck">luck</code></td>
<td>
<p>Luck used to be adjusted (number between 0 and 1)</p>
</td></tr>
<tr><td><code id="luck_adj_+3A_condq">condq</code></td>
<td>
<p>Conditional quantile approach or standard approach</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the luck adjustment automatically for the user, returning the adjusted luck number.
Luck is interpreted in the same fashion as is standard in R (higher luck, higher time to event).
</p>
<p>Note that if TTE is predicted using a conditional quantile function (e.g., conditional gompertz, conditional quantile weibull...) <code>prevsurv</code> and <code>cursurv</code>
are the unconditional survival using the &quot;previous&quot; parametrization but at the previous time for <code>presurv</code> and at the current time for <code>cursurv</code>.
For other distributions, <code>presurv</code> is the survival up to current time using the previous parametrization, and <code>cursurv</code>
is the survival up to current time using the current parametrization.
</p>
<p>Note that the advantage of the conditional quantile function is that it does not need the new parametrization to update the luck,
which makes this approach computationally more efficient.
This function can also work with vectors, which could allow to update multiple lucks in a single approach, and it can preserve names
</p>


<h3>Value</h3>

<p>Adjusted luck number between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>luck_adj(prevsurv = 0.8,
 cursurv = 0.7,
 luck = 0.5,
 condq = TRUE)
 
luck_adj(prevsurv = c(1,0.8,0.7),
 cursurv = c(0.7,0.6,0.5),
 luck = setNames(c(0.5,0.6,0.7),c("A","B","C")),
 condq = TRUE)
 
luck_adj(prevsurv = 0.8,
 cursurv = 0.7,
 luck = 0.5,
 condq = FALSE) #different results

#Unconditional approach, timepoint of change is 25,
# parameter goes from 0.02 at time 10 to 0.025 to 0.015 at time 25,
#  starting luck is 0.37
new_luck &lt;- luck_adj(prevsurv = 1 - pweibull(q=10,3,1/0.02),
 cursurv = 1 - pweibull(q=10,3,1/0.025),
 luck = 0.37,
 condq = FALSE) #time 10 change
 
new_luck &lt;- luck_adj(prevsurv = 1 - pweibull(q=25,3,1/0.025),
 cursurv = 1 - pweibull(q=25,3,1/0.015),
 luck = new_luck,
 condq = FALSE) #time 25 change
 
qweibull(new_luck, 3, 1/0.015) #final TTE 

#Conditional quantile approach 
new_luck &lt;- luck_adj(prevsurv = 1-pweibull(q=0,3,1/0.02),
                      cursurv = 1- pweibull(q=10,3,1/0.02),
                      luck = 0.37,
                      condq = TRUE) #time 10 change, previous time is 0 so prevsurv will be 1

new_luck &lt;- luck_adj(prevsurv = 1-pweibull(q=10,3,1/0.025),
                      cursurv = 1- pweibull(q=25,3,1/0.025),
                      luck = new_luck,
                      condq = TRUE) #time 25 change

qcond_weibull(rnd = new_luck,
                     shape = 3,
                     scale = 1/0.015,
                     lower_bound = 25) + 25 #final TTE
</code></pre>

<hr>
<h2 id='modify_event'>Modify the time of existing events</h2><span id='topic+modify_event'></span>

<h3>Description</h3>

<p>Modify the time of existing events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_event(evt, create_if_null = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_event_+3A_evt">evt</code></td>
<td>
<p>A list of events and their times</p>
</td></tr>
<tr><td><code id="modify_event_+3A_create_if_null">create_if_null</code></td>
<td>
<p>A boolean.
If TRUE, it will create non-existing events with the chosen time to event.
If FALSE, it will ignore those.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions to add/modify events/inputs use lists. Whenever several inputs/events are added or modified, it's recommended to group them within one function, as it reduces the computation cost.
So rather than use two <code>modify_event</code> with a list of one element, it's better to group them into a single <code>modify_event</code> with a list of two elements.
</p>
<p>This function does not evaluate sequentially.
</p>
<p>This function is intended to be used only within the <code>add_reactevt</code> function in its <code>input</code> parameter and should not be run elsewhere or it will return an error.
</p>


<h3>Value</h3>

<p>No return value, modifies/adds event to <code>cur_evtlist</code> and integrates it with the main list for storage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_reactevt(name_evt = "idfs",input = {modify_event(list("os"=5))})
</code></pre>

<hr>
<h2 id='modify_item'>Modify the value of existing items</h2><span id='topic+modify_item'></span>

<h3>Description</h3>

<p>Modify the value of existing items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_item(list_item)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_item_+3A_list_item">list_item</code></td>
<td>
<p>A list of items and their values or expressions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions to add/modify events/inputs use lists. Whenever several inputs/events are added or modified, it's recommended to group them within one function, as it reduces the computation cost.
So rather than use two <code>modify_item</code> with a list of one element, it's better to group them into a single <code>modify_item</code> with a list of two elements.
</p>
<p>Costs and utilities can be modified by using the construction <code>type_name_category</code>, where type is either &quot;qaly&quot; or &quot;cost&quot;,
name is the name (e.g., &quot;default&quot;) and category is the category used (e.g., &quot;instant&quot;), so one could pass <code>cost_default_instant</code> and modify the cost.
This will overwrite the value defined in the corresponding cost/utility section.
</p>
<p>This function is intended to be used only within the <code>add_reactevt</code> function in its <code>input</code> parameter and should not be run elsewhere or it will return an error.
</p>


<h3>Value</h3>

<p>No return value, modifies/adds item to the environment and integrates it with the main list for storage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_reactevt(name_evt = "idfs",input = {modify_item(list("cost.it"=5))})
</code></pre>

<hr>
<h2 id='modify_item_seq'>Modify the value of existing items</h2><span id='topic+modify_item_seq'></span>

<h3>Description</h3>

<p>Modify the value of existing items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_item_seq(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_item_seq_+3A_...">...</code></td>
<td>
<p>A list of items and their values or expressions. Will be evaluated sequentially (so one could have list(a= 1, b = a +2 ))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions to add/modify events/inputs use lists. Whenever several inputs/events are added or modified, it's recommended to group them within one function, as it reduces the computation cost.
So rather than use two <code>modify_item</code> with a list of one element, it's better to group them into a single <code>modify_item</code> with a list of two elements.
</p>
<p>Costs and utilities can be modified by using the construction <code>type_name_category</code>, where type is either &quot;qaly&quot; or &quot;cost&quot;,
name is the name (e.g., &quot;default&quot;) and category is the category used (e.g., &quot;instant&quot;), so one could pass <code>cost_default_instant</code> and modify the cost.
This will overwrite the value defined in the corresponding cost/utility section.
</p>
<p>The function is different from modify_item in that this function evaluates sequentially the arguments within the list passed.
This implies a slower performance relative to modify_item, but it can be more cleaner and convenient in certain instances.
</p>
<p>This function is intended to be used only within the <code>add_reactevt</code> function in its <code>input</code> parameter and should not be run elsewhere or it will return an error.
</p>


<h3>Value</h3>

<p>No return value, modifies/adds items sequentially and deploys to the environment and with the main list for storage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_reactevt(name_evt = "idfs",input = {
  modify_item_seq(list(cost.idfs = 500, cost.tx = cost.idfs + 4000))
  })
</code></pre>

<hr>
<h2 id='new_event'>Generate new events to be added to existing vector of events</h2><span id='topic+new_event'></span>

<h3>Description</h3>

<p>Generate new events to be added to existing vector of events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_event(evt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_event_+3A_evt">evt</code></td>
<td>
<p>Event name and event time</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions to add/modify events/inputs use lists. Whenever several inputs/events are added or modified, it's recommended to group them within one function, as it reduces the computation cost.
So rather than use two <code>new_event</code> with a list of one element, it's better to group them into a single <code>new_event</code> with a list of two elements.
</p>
<p>This function is intended to be used only within the <code>add_reactevt</code> function in its <code>input</code> parameter and should not be run elsewhere or it will return an error.
</p>


<h3>Value</h3>

<p>No return value, adds event to <code>cur_evtlist</code> and integrates it with the main list for storage
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_reactevt(name_evt = "idfs",input = {new_event(list("ae"=5))})
</code></pre>

<hr>
<h2 id='pcond_gompertz'>Survival Probaility function for conditional Gompertz distribution (lower bound only)</h2><span id='topic+pcond_gompertz'></span>

<h3>Description</h3>

<p>Survival Probaility function for conditional Gompertz distribution (lower bound only)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcond_gompertz(time = 1, shape, rate, lower_bound = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcond_gompertz_+3A_time">time</code></td>
<td>
<p>Vector of times</p>
</td></tr>
<tr><td><code id="pcond_gompertz_+3A_shape">shape</code></td>
<td>
<p>The shape parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="pcond_gompertz_+3A_rate">rate</code></td>
<td>
<p>The rate parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="pcond_gompertz_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound of the conditional distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional Gompertz distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcond_gompertz(time=1,shape=0.05,rate=0.01,lower_bound = 50)
</code></pre>

<hr>
<h2 id='pick_psa'>Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within <code>pick_val_v</code>.</h2><span id='topic+pick_psa'></span>

<h3>Description</h3>

<p>Helper function to create a list with random draws or whenever a series of functions needs to be called. Can be implemented within <code>pick_val_v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_psa(f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_psa_+3A_f">f</code></td>
<td>
<p>A string or vector of strings with the function to be called, e.g., &quot;rnorm&quot;</p>
</td></tr>
<tr><td><code id="pick_psa_+3A_...">...</code></td>
<td>
<p>parameters to be passed to the function (e.g., if &quot;rnorm&quot;, arguments <code>n</code>, <code>mean</code>, <code>sd</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to pick values for the PSA within <code>pick_val_v.</code>
</p>
<p>The function will ignore NA items within the respective parameter (see example below).
If an element in f is NA (e.g., a non PSA input) then it will return NA as its value
This feature is convenient when mixing distributions with different number of arguments, e.g., <code>rnorm</code> and <code>rgengamma</code>.
</p>
<p>While it's slightly lower than individually calling each function, it makes the code easier to read and more transparent
</p>


<h3>Value</h3>

<p>List with length equal to <code>f</code> of parameters called
</p>


<h3>Examples</h3>

<pre><code class='language-R'>params &lt;- list(
param=list("a","b"),
dist=list("rlnorm","rnorm"),
n=list(4,1),
a=list(c(1,2,3,4),1),
b=list(c(0.5,0.5,0.5,0.5),0.5),
dsa_min=list(c(1,2,3,4),2),
dsa_max=list(c(1,2,3,4),3)
)
pick_psa(params[["dist"]],params[["n"]],params[["a"]],params[["b"]])

#It works with functions that require different number of parameters
params &lt;- list(
 param=list("a","b","c"),
 dist=list("rlnorm","rnorm","rgengamma"),
 n=list(4,1,1),
 a=list(c(1,2,3,4),1,0),
 b=list(c(0.5,0.5,0.5,0.5),0.5,1),
 c=list(NA,NA,0.2),
 dsa_min=list(c(1,2,3,4),2,1),
 dsa_max=list(c(1,2,3,4),3,3)
)

pick_psa(params[["dist"]],params[["n"]],params[["a"]],params[["b"]],params[["c"]])

#Can be combined with multiple type of functions and distributions if parameters are well located

params &lt;- list(
param=list("a","b","c","d"),
dist=list("rlnorm","rnorm","rgengamma","draw_tte"),
n=list(4,1,1,1),
a=list(c(1,2,3,4),1,0,"norm"),
b=list(c(0.5,0.5,0.5,0.5),0.5,1,1),
c=list(NA,NA,0.2,0.5),
c=list(NA,NA,NA,NA), #NA arguments will be ignored
dsa_min=list(c(1,2,3,4),2,1,0),
dsa_max=list(c(1,2,3,4),3,3,2)
)
</code></pre>

<hr>
<h2 id='pick_val_v'>Select which values should be applied in the corresponding loop for several values (vector or list).</h2><span id='topic+pick_val_v'></span>

<h3>Description</h3>

<p>Select which values should be applied in the corresponding loop for several values (vector or list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_val_v(
  base,
  psa,
  sens,
  psa_ind = psa_bool,
  sens_ind = sens_bool,
  indicator,
  indicator_psa = NULL,
  names_out = NULL,
  indicator_sens_binary = TRUE,
  sens_iterator = NULL,
  distributions = NULL,
  covariances = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pick_val_v_+3A_base">base</code></td>
<td>
<p>Value if no PSA/DSA/Scenario</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_psa">psa</code></td>
<td>
<p>Value if PSA</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_sens">sens</code></td>
<td>
<p>Value if DSA/Scenario</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_psa_ind">psa_ind</code></td>
<td>
<p>Boolean whether PSA is active</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_sens_ind">sens_ind</code></td>
<td>
<p>Boolean whether Scenario/DSA is active</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_indicator">indicator</code></td>
<td>
<p>Indicator which checks whether the specific parameter/parameters is/are active in the DSA or Scenario loop</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_indicator_psa">indicator_psa</code></td>
<td>
<p>Indicator which checks whether the specific parameter/parameters is/are active in the PSA loop.
If NULL, it's assumed to be a vector of 1s of length equal to length(indicator)</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_names_out">names_out</code></td>
<td>
<p>Names to give the output list</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_indicator_sens_binary">indicator_sens_binary</code></td>
<td>
<p>Boolean, TRUE if parameters will be varied fully, FALSE if some elements of the parameters may be changed but not all</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_sens_iterator">sens_iterator</code></td>
<td>
<p>Current iterator number of the DSA/scenario being run, e.g., 5 if it corresponds to the 5th DSA parameter being changed</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_distributions">distributions</code></td>
<td>
<p>List with length equal to length of base where the distributions are stored</p>
</td></tr>
<tr><td><code id="pick_val_v_+3A_covariances">covariances</code></td>
<td>
<p>List with length equal to length of base where the variance/covariances are stored (only relevant if multivariate normal are being used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used with vectors or lists, but will always return a list.
Lists should be used when correlated variables are introduced to make sure the selector knows how to choose among those
This function allows to choose between using an approach where only the full parameters are varied, and an approach where subelements of the parameters can be changed
</p>


<h3>Value</h3>

<p>List used for the inputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pick_val_v(base = list(0,0),
             psa =list(rnorm(1,0,0.1),rnorm(1,0,0.1)),
             sens = list(2,3),
             psa_ind = FALSE,
             sens_ind = TRUE,
             indicator=list(1,2),
             indicator_sens_binary = FALSE,
             sens_iterator = 2,
             distributions = list("rnorm","rnorm")
)

pick_val_v(base = list(2,3,c(1,2)),
             psa =sapply(1:3,
                         function(x) eval(call(
                           c("rnorm","rnorm","mvrnorm")[[x]],
                           1,
                           c(2,3,list(c(1,2)))[[x]],
                           c(0.1,0.1,list(matrix(c(1,0.1,0.1,1),2,2)))[[x]]
                         ))),
             sens = list(4,5,c(1.3,2.3)),
             psa_ind = FALSE,
             sens_ind = TRUE,
             indicator=list(1,2,c(3,4)),
             names_out=c("util","util2","correlated_vector") ,
             indicator_sens_binary = FALSE,
             sens_iterator = 4,
             distributions = list("rnorm","rnorm","mvrnorm"),
             covariances = list(0.1,0.1,matrix(c(1,0.1,0.1,1),2,2))
)
 
</code></pre>

<hr>
<h2 id='qbeta_mse'>Draw from a beta distribution based on mean and se (quantile)</h2><span id='topic+qbeta_mse'></span>

<h3>Description</h3>

<p>Draw from a beta distribution based on mean and se (quantile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qbeta_mse(q, mean_v, se)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qbeta_mse_+3A_q">q</code></td>
<td>
<p>Quantiles to be used</p>
</td></tr>
<tr><td><code id="qbeta_mse_+3A_mean_v">mean_v</code></td>
<td>
<p>A vector of the mean values</p>
</td></tr>
<tr><td><code id="qbeta_mse_+3A_se">se</code></td>
<td>
<p>A vector of the standard errors of the means</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single estimate from the beta distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qbeta_mse(q=0.5,mean_v=0.8,se=0.2)
</code></pre>

<hr>
<h2 id='qcond_exp'>Conditional quantile function for exponential distribution</h2><span id='topic+qcond_exp'></span>

<h3>Description</h3>

<p>Conditional quantile function for exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_exp(rnd = 0.5, rate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_exp_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_exp_+3A_rate">rate</code></td>
<td>
<p>The rate parameter
</p>
<p>Note taht the conditional quantile for an exponential is independent of time due to constant hazard</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional exponential distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_exp(rnd = 0.5,rate = 3)
</code></pre>

<hr>
<h2 id='qcond_gamma'>Conditional quantile function for gamma distribution</h2><span id='topic+qcond_gamma'></span>

<h3>Description</h3>

<p>Conditional quantile function for gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_gamma(rnd = 0.5, rate, shape, lower_bound = 0, s_obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_gamma_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_gamma_+3A_rate">rate</code></td>
<td>
<p>The rate parameter</p>
</td></tr>
<tr><td><code id="qcond_gamma_+3A_shape">shape</code></td>
<td>
<p>The shape parameter</p>
</td></tr>
<tr><td><code id="qcond_gamma_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound to be used (current time)</p>
</td></tr>
<tr><td><code id="qcond_gamma_+3A_s_obs">s_obs</code></td>
<td>
<p>is the survival observed up to lower_bound time,
normally defined from time 0 as 1 - pgamma(q = lower_bound, rate, shape) but may be different if parametrization has changed previously</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional gamma distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_gamma(rnd = 0.5, rate = 1.06178, shape = 0.01108,lower_bound = 1, s_obs=0.8)
</code></pre>

<hr>
<h2 id='qcond_gompertz'>Quantile function for conditional Gompertz distribution (lower bound only)</h2><span id='topic+qcond_gompertz'></span>

<h3>Description</h3>

<p>Quantile function for conditional Gompertz distribution (lower bound only)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_gompertz(rnd = 0.5, shape, rate, lower_bound = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_gompertz_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_gompertz_+3A_shape">shape</code></td>
<td>
<p>The shape parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="qcond_gompertz_+3A_rate">rate</code></td>
<td>
<p>The rate parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="qcond_gompertz_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound of the conditional distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional Gompertz distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_gompertz(rnd=0.5,shape=0.05,rate=0.01,lower_bound = 50)
</code></pre>

<hr>
<h2 id='qcond_llogis'>Conditional quantile function for loglogistic distribution</h2><span id='topic+qcond_llogis'></span>

<h3>Description</h3>

<p>Conditional quantile function for loglogistic distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_llogis(rnd = 0.5, shape, scale, lower_bound = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_llogis_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_llogis_+3A_shape">shape</code></td>
<td>
<p>The shape parameter</p>
</td></tr>
<tr><td><code id="qcond_llogis_+3A_scale">scale</code></td>
<td>
<p>The scale parameter</p>
</td></tr>
<tr><td><code id="qcond_llogis_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound to be used (current time)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional loglogistic distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_llogis(rnd = 0.5,shape = 1,scale = 1,lower_bound = 1)
</code></pre>

<hr>
<h2 id='qcond_lnorm'>Conditional quantile function for lognormal distribution</h2><span id='topic+qcond_lnorm'></span>

<h3>Description</h3>

<p>Conditional quantile function for lognormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_lnorm(rnd = 0.5, meanlog, sdlog, lower_bound = 0, s_obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_lnorm_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_lnorm_+3A_meanlog">meanlog</code></td>
<td>
<p>The meanlog parameter</p>
</td></tr>
<tr><td><code id="qcond_lnorm_+3A_sdlog">sdlog</code></td>
<td>
<p>The sdlog parameter</p>
</td></tr>
<tr><td><code id="qcond_lnorm_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound to be used (current time)</p>
</td></tr>
<tr><td><code id="qcond_lnorm_+3A_s_obs">s_obs</code></td>
<td>
<p>is the survival observed up to lower_bound time,
normally defined from time 0 as 1 - plnorm(q = lower_bound, meanlog, sdlog) but may be different if parametrization has changed previously</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional lognormal distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_lnorm(rnd = 0.5, meanlog = 1,sdlog = 1,lower_bound = 1, s_obs=0.8)
</code></pre>

<hr>
<h2 id='qcond_norm'>Conditional quantile function for normal distribution</h2><span id='topic+qcond_norm'></span>

<h3>Description</h3>

<p>Conditional quantile function for normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_norm(rnd = 0.5, mean, sd, lower_bound = 0, s_obs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_norm_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_norm_+3A_mean">mean</code></td>
<td>
<p>The mean parameter</p>
</td></tr>
<tr><td><code id="qcond_norm_+3A_sd">sd</code></td>
<td>
<p>The sd parameter</p>
</td></tr>
<tr><td><code id="qcond_norm_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound to be used (current time)</p>
</td></tr>
<tr><td><code id="qcond_norm_+3A_s_obs">s_obs</code></td>
<td>
<p>is the survival observed up to lower_bound time,
normally defined from time 0 as 1 - pnorm(q = lower_bound, mean, sd) but may be different if parametrization has changed previously</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional normal distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_norm(rnd = 0.5, mean = 1,sd = 1,lower_bound = 1, s_obs=0.8)
</code></pre>

<hr>
<h2 id='qcond_weibull'>Conditional quantile function for weibull distribution</h2><span id='topic+qcond_weibull'></span>

<h3>Description</h3>

<p>Conditional quantile function for weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcond_weibull(rnd = 0.5, shape, scale, lower_bound = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcond_weibull_+3A_rnd">rnd</code></td>
<td>
<p>Vector of quantiles</p>
</td></tr>
<tr><td><code id="qcond_weibull_+3A_shape">shape</code></td>
<td>
<p>The shape parameter as in R stats package weibull</p>
</td></tr>
<tr><td><code id="qcond_weibull_+3A_scale">scale</code></td>
<td>
<p>The scale parameter as in R stats package weibull</p>
</td></tr>
<tr><td><code id="qcond_weibull_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound to be used (current time)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional weibull distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qcond_weibull(rnd = 0.5,shape = 3,scale = 66.66,lower_bound = 50)
</code></pre>

<hr>
<h2 id='rbeta_mse'>Draw from a beta distribution based on mean and se</h2><span id='topic+rbeta_mse'></span>

<h3>Description</h3>

<p>Draw from a beta distribution based on mean and se
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbeta_mse(n = 1, mean_v, se, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbeta_mse_+3A_n">n</code></td>
<td>
<p>Number of draws (must be &gt;= 1)</p>
</td></tr>
<tr><td><code id="rbeta_mse_+3A_mean_v">mean_v</code></td>
<td>
<p>A vector of the mean values</p>
</td></tr>
<tr><td><code id="rbeta_mse_+3A_se">se</code></td>
<td>
<p>A vector of the standard errors of the means</p>
</td></tr>
<tr><td><code id="rbeta_mse_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single estimate from the beta distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rbeta_mse(n=1,mean_v=0.8,se=0.2)
</code></pre>

<hr>
<h2 id='rcond_gompertz'>Draw from a conditional Gompertz distribution (lower bound only)</h2><span id='topic+rcond_gompertz'></span>

<h3>Description</h3>

<p>Draw from a conditional Gompertz distribution (lower bound only)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcond_gompertz(n = 1, shape, rate, lower_bound = 0, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcond_gompertz_+3A_n">n</code></td>
<td>
<p>The number of observations to be drawn</p>
</td></tr>
<tr><td><code id="rcond_gompertz_+3A_shape">shape</code></td>
<td>
<p>The shape parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="rcond_gompertz_+3A_rate">rate</code></td>
<td>
<p>The rate parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="rcond_gompertz_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound of the conditional distribution</p>
</td></tr>
<tr><td><code id="rcond_gompertz_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the conditional Gompertz distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcond_gompertz(1,shape=0.05,rate=0.01,lower_bound = 50)
</code></pre>

<hr>
<h2 id='rcond_gompertz_lu'>Draw from a Conditional Gompertz distribution (lower and upper bound)</h2><span id='topic+rcond_gompertz_lu'></span>

<h3>Description</h3>

<p>Draw from a Conditional Gompertz distribution (lower and upper bound)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcond_gompertz_lu(
  n,
  shape,
  rate,
  lower_bound = 0,
  upper_bound = Inf,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcond_gompertz_lu_+3A_n">n</code></td>
<td>
<p>The number of observations to be drawn</p>
</td></tr>
<tr><td><code id="rcond_gompertz_lu_+3A_shape">shape</code></td>
<td>
<p>The shape parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="rcond_gompertz_lu_+3A_rate">rate</code></td>
<td>
<p>The rate parameter of the Gompertz distribution, defined as in the coef() output on a flexsurvreg object</p>
</td></tr>
<tr><td><code id="rcond_gompertz_lu_+3A_lower_bound">lower_bound</code></td>
<td>
<p>The lower bound of the conditional distribution</p>
</td></tr>
<tr><td><code id="rcond_gompertz_lu_+3A_upper_bound">upper_bound</code></td>
<td>
<p>The upper bound of the conditional distribution</p>
</td></tr>
<tr><td><code id="rcond_gompertz_lu_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate(s) from the Conditional Gompertz distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcond_gompertz_lu(1,shape=0.05,rate=0.01,lower_bound = 50)
</code></pre>

<hr>
<h2 id='rdirichlet'>Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Draw from a dirichlet distribution based on number of counts in transition. Adapted from brms::rdirichlet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(n = 1, alpha, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdirichlet_+3A_n">n</code></td>
<td>
<p>Number of draws (must be &gt;= 1). If n&gt;1, it will return a list of matrices.</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_alpha">alpha</code></td>
<td>
<p>A matrix of alphas (transition counts)</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transition matrix. If n&gt;1, it will return a list of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdirichlet(n=1,alpha= matrix(c(1251, 0, 350, 731),2,2))
rdirichlet(n=2,alpha= matrix(c(1251, 0, 350, 731),2,2))
</code></pre>

<hr>
<h2 id='rdirichlet_prob'>Draw from a dirichlet distribution based on mean transition probabilities and standard errors</h2><span id='topic+rdirichlet_prob'></span>

<h3>Description</h3>

<p>Draw from a dirichlet distribution based on mean transition probabilities and standard errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet_prob(n = 1, alpha, se, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdirichlet_prob_+3A_n">n</code></td>
<td>
<p>Number of draws (must be &gt;= 1). If n&gt;1, it will return a list of matrices.</p>
</td></tr>
<tr><td><code id="rdirichlet_prob_+3A_alpha">alpha</code></td>
<td>
<p>A matrix of transition probabilities</p>
</td></tr>
<tr><td><code id="rdirichlet_prob_+3A_se">se</code></td>
<td>
<p>A matrix of standard errors</p>
</td></tr>
<tr><td><code id="rdirichlet_prob_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transition matrix. If n&gt;1, it will return a list of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdirichlet_prob(n=1,alpha= matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7),3,3),
se=matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7)/10,3,3))

rdirichlet_prob(n=2,alpha= matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7),3,3),
se=matrix(c(0.7,0.3,0,0.1,0.7,0.2,0.1,0.2,0.7)/10,3,3))
</code></pre>

<hr>
<h2 id='replicate_profiles'>Replicate profiles data.frame</h2><span id='topic+replicate_profiles'></span>

<h3>Description</h3>

<p>Replicate profiles data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replicate_profiles(
  profiles,
  replications,
  probabilities = NULL,
  replacement = TRUE,
  seed_used = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replicate_profiles_+3A_profiles">profiles</code></td>
<td>
<p>data.frame of profiles</p>
</td></tr>
<tr><td><code id="replicate_profiles_+3A_replications">replications</code></td>
<td>
<p>integer, final number of observations</p>
</td></tr>
<tr><td><code id="replicate_profiles_+3A_probabilities">probabilities</code></td>
<td>
<p>vector of probabilities with the same length as the number of rows of profiles. Does not need to add up to 1 (are reweighted)</p>
</td></tr>
<tr><td><code id="replicate_profiles_+3A_replacement">replacement</code></td>
<td>
<p>Boolean whether replacement is used</p>
</td></tr>
<tr><td><code id="replicate_profiles_+3A_seed_used">seed_used</code></td>
<td>
<p>Integer with the seed to be used for consistent results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Resampled data.frame of profiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replicate_profiles(profiles=data.frame(id=1:100,age=rnorm(100,60,5)),
replications=200,probabilities=rep(1,100))
</code></pre>

<hr>
<h2 id='rgamma_mse'>Draw from a gamma distribution based on mean and se</h2><span id='topic+rgamma_mse'></span>

<h3>Description</h3>

<p>Draw from a gamma distribution based on mean and se
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgamma_mse(n = 1, mean_v, se, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgamma_mse_+3A_n">n</code></td>
<td>
<p>Number of draws (must be &gt;= 1)</p>
</td></tr>
<tr><td><code id="rgamma_mse_+3A_mean_v">mean_v</code></td>
<td>
<p>A vector of the mean values</p>
</td></tr>
<tr><td><code id="rgamma_mse_+3A_se">se</code></td>
<td>
<p>A vector of the standard errors of the means</p>
</td></tr>
<tr><td><code id="rgamma_mse_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single estimate from the gamma distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rgamma_mse(n=1,mean_v=0.8,se=0.2)

</code></pre>

<hr>
<h2 id='rpoisgamma'>Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process</h2><span id='topic+rpoisgamma'></span>

<h3>Description</h3>

<p>Draw time to event (tte) from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpoisgamma(
  n,
  rate,
  theta = NULL,
  obs_time = 1,
  t_reps,
  seed = NULL,
  return_ind_rate = FALSE,
  return_df = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpoisgamma_+3A_n">n</code></td>
<td>
<p>The number of observations to be drawn</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_rate">rate</code></td>
<td>
<p>rate of the event (in terms of events per observation-time)</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_theta">theta</code></td>
<td>
<p>Optional.  When omitted, the function simulates times for a Poisson process.
Represents the shape of the gamma mixture distribution.
Estimated and reported as theta in negative binomial regression analyses in r.</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_obs_time">obs_time</code></td>
<td>
<p>period over which events are observable</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_t_reps">t_reps</code></td>
<td>
<p>Optional. Number of TBEs to be generated to capture events within the observation window.
When omitted, the function sets t_reps to the 99.99th quantile of the Poisson (if no theta is provided)
or negative binomial (if theta is provided). Thus, the risk of missing possible events in the observation window
is 0.01%.</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_seed">seed</code></td>
<td>
<p>An integer which will be used to set the seed for this draw.</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_return_ind_rate">return_ind_rate</code></td>
<td>
<p>A boolean that indicates whether an additional vector with the rate parameters used per observation is used.
It will alter the structure of the results to two lists, one storing tte with name tte, and the other with name ind_rate</p>
</td></tr>
<tr><td><code id="rpoisgamma_+3A_return_df">return_df</code></td>
<td>
<p>A boolean that indicates whether a data.table object should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to simulate event times from a Poisson or Poisson-Gamma (PG) Mixture/Negative Binomial (NB) Process
Event times are determined by sampling times between events (TBEs) from an exponential distribution, and cumulating
these to derive the event times. Events occurring within the set observation time window are retained and returned.
For times for a Poisson process, the provided rate is assumed constant.
For a PG or NB, the individual rates are sampled from a Gamma distribution with shape = theta and scale = rate/theta.
</p>


<h3>Value</h3>

<p>Estimate(s) from the time to event based on poisson/Poisson-Gamma (PG) Mixture/Negative Binomial (NB) distribution based on given parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rpoisgamma(1,rate=1,obs_time=1,theta=1)
</code></pre>

<hr>
<h2 id='run_sim'>Run the simulation</h2><span id='topic+run_sim'></span>

<h3>Description</h3>

<p>Run the simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_sim(
  arm_list = c("int", "noint"),
  sensitivity_inputs = NULL,
  common_all_inputs = NULL,
  common_pt_inputs = NULL,
  unique_pt_inputs = NULL,
  init_event_list = NULL,
  evt_react_list = evt_react_list,
  util_ongoing_list = NULL,
  util_instant_list = NULL,
  util_cycle_list = NULL,
  cost_ongoing_list = NULL,
  cost_instant_list = NULL,
  cost_cycle_list = NULL,
  other_ongoing_list = NULL,
  other_instant_list = NULL,
  npats = 500,
  n_sim = 1,
  psa_bool = NULL,
  sensitivity_bool = FALSE,
  sensitivity_names = NULL,
  n_sensitivity = 1,
  input_out = NULL,
  ipd = 1,
  timed_freq = NULL,
  debug = FALSE,
  accum_backwards = FALSE,
  continue_on_error = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_sim_+3A_arm_list">arm_list</code></td>
<td>
<p>A vector of the names of the interventions evaluated in the simulation</p>
</td></tr>
<tr><td><code id="run_sim_+3A_sensitivity_inputs">sensitivity_inputs</code></td>
<td>
<p>A list of sensitivity inputs that do not change within a sensitivity in a similar fashion to common_all_inputs, etc</p>
</td></tr>
<tr><td><code id="run_sim_+3A_common_all_inputs">common_all_inputs</code></td>
<td>
<p>A list of inputs common across patients that do not change within a simulation</p>
</td></tr>
<tr><td><code id="run_sim_+3A_common_pt_inputs">common_pt_inputs</code></td>
<td>
<p>A list of inputs that change across patients but are not affected by the intervention</p>
</td></tr>
<tr><td><code id="run_sim_+3A_unique_pt_inputs">unique_pt_inputs</code></td>
<td>
<p>A list of inputs that change across each intervention</p>
</td></tr>
<tr><td><code id="run_sim_+3A_init_event_list">init_event_list</code></td>
<td>
<p>A list of initial events and event times. If no initial events are given, a &quot;Start&quot; event at time 0 is created automatically</p>
</td></tr>
<tr><td><code id="run_sim_+3A_evt_react_list">evt_react_list</code></td>
<td>
<p>A list of event reactions</p>
</td></tr>
<tr><td><code id="run_sim_+3A_util_ongoing_list">util_ongoing_list</code></td>
<td>
<p>Vector of QALY named variables that are accrued at an ongoing basis (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_util_instant_list">util_instant_list</code></td>
<td>
<p>Vector of QALY named variables that are accrued instantaneously at an event (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_util_cycle_list">util_cycle_list</code></td>
<td>
<p>Vector of QALY named variables that are accrued in cycles (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_cost_ongoing_list">cost_ongoing_list</code></td>
<td>
<p>Vector of cost named variables that are accrued at an ongoing basis (discounted using drc)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_cost_instant_list">cost_instant_list</code></td>
<td>
<p>Vector of cost named variables that are accrued instantaneously at an event (discounted using drc)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_cost_cycle_list">cost_cycle_list</code></td>
<td>
<p>Vector of cost named variables that are accrued in cycles (discounted using drc)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_other_ongoing_list">other_ongoing_list</code></td>
<td>
<p>Vector of other named variables that are accrued at an ongoing basis (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_other_instant_list">other_instant_list</code></td>
<td>
<p>Vector of other named variables that are accrued instantaneously at an event (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_npats">npats</code></td>
<td>
<p>The number of patients to be simulated (it will simulate npats * length(arm_list))</p>
</td></tr>
<tr><td><code id="run_sim_+3A_n_sim">n_sim</code></td>
<td>
<p>The number of simulations to run per sensitivity</p>
</td></tr>
<tr><td><code id="run_sim_+3A_psa_bool">psa_bool</code></td>
<td>
<p>A boolean to determine if PSA should be conducted. If n_sim &gt; 1 and psa_bool = FALSE, the differences between simulations will be due to sampling</p>
</td></tr>
<tr><td><code id="run_sim_+3A_sensitivity_bool">sensitivity_bool</code></td>
<td>
<p>A boolean to determine if Scenarios/DSA should be conducted.</p>
</td></tr>
<tr><td><code id="run_sim_+3A_sensitivity_names">sensitivity_names</code></td>
<td>
<p>A vector of scenario/DSA names that can be used to select the right sensitivity (e.g., c(&quot;Scenario_1&quot;, &quot;Scenario_2&quot;)). The parameter &quot;sens_name_used&quot; is created from it which corresponds to the one being used for each iteration.</p>
</td></tr>
<tr><td><code id="run_sim_+3A_n_sensitivity">n_sensitivity</code></td>
<td>
<p>Number of sensitivity analysis (DSA or Scenarios) to run. It will be interacted with sensitivity_names argument if not null (n_sensitivityitivity = n_sensitivity * length(sensitivity_names)). For DSA, it should be as many parameters as there are. For scenario, it should be 1.</p>
</td></tr>
<tr><td><code id="run_sim_+3A_input_out">input_out</code></td>
<td>
<p>A vector of variables to be returned in the output data frame</p>
</td></tr>
<tr><td><code id="run_sim_+3A_ipd">ipd</code></td>
<td>
<p>Integer taking value 1 for full IPD data returned, and 2 IPD data but aggregating events (returning last value for numeric/character/factor variables. For other objects (e.g., matrices), the IPD will still be returned as the aggregation rule is not clear). Other values mean no IPD data returned (removes non-numerical or length&gt;1 items)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_timed_freq">timed_freq</code></td>
<td>
<p>If NULL, it does not produce any timed outputs. Otherwise should be a number (e.g., every 1 year)</p>
</td></tr>
<tr><td><code id="run_sim_+3A_debug">debug</code></td>
<td>
<p>If TRUE, will generate a log file</p>
</td></tr>
<tr><td><code id="run_sim_+3A_accum_backwards">accum_backwards</code></td>
<td>
<p>If TRUE, the ongoing accumulators will count backwards (i.e., the current value is applied until the previous update). If FALSE, the current value is applied between the current event and the next time it is updated.</p>
</td></tr>
<tr><td><code id="run_sim_+3A_continue_on_error">continue_on_error</code></td>
<td>
<p>If TRUE, on error it will attempt to continue by skipping the current simulation</p>
</td></tr>
<tr><td><code id="run_sim_+3A_seed">seed</code></td>
<td>
<p>Starting seed to be used for the whole analysis. If null, it's set to 1 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is slightly different from <code>run_sim_parallel</code>.
<code>run_sim_parallel</code> only runs multiple-core at the simulation level.
<code>run_sim</code> uses only-single core.
<code>run_sim</code> can be more efficient if using only one simulation (e.g., deterministic),
while <code>run_sim_parallel</code> will be more efficient if the number of simulations is &gt;1 (e.g., PSA).
</p>
<p>Event ties are processed in the order declared within the <code>init_event_list</code> argument (<code>evts</code> argument within the first sublist of that object).
To do so, the program automatically adds a sequence from to 0 to the (number of events - 1) times 1e-10 to add to the event times when selecting the event with minimum time.
This time has been selected as it's relatively small yet not so small as to be ignored by which.min (see .Machine for more details)
</p>
<p>A list of protected objects that should not be used by the user as input names  or in the global environment to avoid the risk of overwriting them is as follows:
c(&quot;arm&quot;, &quot;arm_list&quot;, &quot;categories_for_export&quot;, &quot;cur_evtlist&quot;, &quot;curtime&quot;, &quot;evt&quot;, &quot;i&quot;, &quot;prevtime&quot;, &quot;sens&quot;, &quot;simulation&quot;, &quot;sens_name_used&quot;,&quot;list_env&quot;,&quot;uc_lists&quot;,&quot;npats&quot;,&quot;ipd&quot;).
</p>
<p>The engine uses the L'Ecuyer-CMRG for the random number generator.
Note that the random seeds are set to be unique in their category (i.e., at patient level, patient-arm level, etc.)
</p>
<p>If no <code>drc</code> or 'drq parameters are passed within any of the input lists, these are assigned value 0.03.
</p>
<p>Ongoing items will look backward to the last time updated when performing the discounting and accumulation.
This means that the user does not necessarily need to keep updating the value, but only add it when the value
changes looking forward (e.g., o_q = utility at event 1, at event 2 utility does not change, but at event 3 it does,
so we want to make sure to add o_q = utility at event 3 before updating utility. The program will automatically
look back until event 1). Note that in previous versions of the package backward was the default, and now this has switched to forward.
</p>
<p>It is important to note that the QALYs and Costs (ongoing or instant or per cycle) used should be of length 1.
If they were of length &gt; 1, the model would expand the data,
so instead of having each event as a row, the event would have N rows (equal to the length of the costs/qalys to discount passed).
This means more processing of the results data would be needed in order for it to provide the correct results.
</p>
<p>If the <code>cycle</code> lists are used, then it is expected the user will declare as well the name of the variable
pasted with <code>cycle_l</code> and <code>cycle_starttime</code> (e.g., c_default_cycle_l and c_default_cycle_starttime) to
ensure the discounting can be computed using cycles, with cycle_l being the cycle length, and cycle_starttime
being the starting time in which the variable started counting.
</p>
<p><code>debug = TRUE</code> will export a log file with the timestamp up the error in the main working directory.
</p>
<p><code>continue_on_error</code> will skip the current simulation (so it won't continue for the rest of patient-arms) if TRUE.
Note that this will make the progress bar not correct, as a set of patients that were expected to be run is not.
</p>


<h3>Value</h3>

<p>A list of data frames with the simulation results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
common_all_inputs &lt;-add_item(
util.sick = 0.8,
util.sicker = 0.5,
cost.sick = 3000,
cost.sicker = 7000,
cost.int = 1000,
coef_noint = log(0.2),
HR_int = 0.8,
drc = 0.035, #different values than what's assumed by default
drq = 0.035,
random_seed_sicker_i = sample.int(100000,5,replace = FALSE)
)

common_pt_inputs &lt;- add_item(death= max(0.0000001,rnorm(n=1, mean=12, sd=3))) 

unique_pt_inputs &lt;- add_item(fl.sick = 1,
                             q_default = util.sick,
                             c_default = cost.sick + if(arm=="int"){cost.int}else{0}) 
                             
init_event_list &lt;- 
add_tte(arm=c("noint","int"), evts = c("sick","sicker","death") ,input={
  sick &lt;- 0
  sicker &lt;- draw_tte(1,dist="exp",
   coef1=coef_noint, beta_tx = ifelse(arm=="int",HR_int,1),
    seed = random_seed_sicker_i[i])
  
})   

evt_react_list &lt;-
add_reactevt(name_evt = "sick",
             input = {}) %&gt;%
  add_reactevt(name_evt = "sicker",
               input = {
                 modify_item(list(q_default = util.sicker,
                                  c_default = cost.sicker + if(arm=="int"){cost.int}else{0},
                                  fl.sick = 0)) 
               }) %&gt;%
  add_reactevt(name_evt = "death",
               input = {
                 modify_item(list(q_default = 0,
                                  c_default = 0, 
                                  curtime = Inf)) 
               }) 
               
util_ongoing &lt;- "q_default"
cost_ongoing &lt;- "c_default"
                          

run_sim(arm_list=c("int","noint"),
common_all_inputs = common_all_inputs,
common_pt_inputs = common_pt_inputs,
unique_pt_inputs = unique_pt_inputs,
init_event_list = init_event_list,
evt_react_list = evt_react_list,
util_ongoing_list = util_ongoing,
cost_ongoing_list = cost_ongoing,
npats = 2,
n_sim = 1,
psa_bool = FALSE,
ipd = 1)

</code></pre>

<hr>
<h2 id='run_sim_parallel'>Run simulations in parallel mode (at the simulation level)</h2><span id='topic+run_sim_parallel'></span>

<h3>Description</h3>

<p>Run simulations in parallel mode (at the simulation level)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_sim_parallel(
  arm_list = c("int", "noint"),
  sensitivity_inputs = NULL,
  common_all_inputs = NULL,
  common_pt_inputs = NULL,
  unique_pt_inputs = NULL,
  init_event_list = NULL,
  evt_react_list = evt_react_list,
  util_ongoing_list = NULL,
  util_instant_list = NULL,
  util_cycle_list = NULL,
  cost_ongoing_list = NULL,
  cost_instant_list = NULL,
  cost_cycle_list = NULL,
  other_ongoing_list = NULL,
  other_instant_list = NULL,
  npats = 500,
  n_sim = 1,
  psa_bool = NULL,
  sensitivity_bool = FALSE,
  sensitivity_names = NULL,
  n_sensitivity = 1,
  ncores = 1,
  input_out = NULL,
  ipd = 1,
  timed_freq = NULL,
  debug = FALSE,
  accum_backwards = FALSE,
  continue_on_error = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_sim_parallel_+3A_arm_list">arm_list</code></td>
<td>
<p>A vector of the names of the interventions evaluated in the simulation</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_sensitivity_inputs">sensitivity_inputs</code></td>
<td>
<p>A list of sensitivity inputs that do not change within a sensitivity in a similar fashion to common_all_inputs, etc</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_common_all_inputs">common_all_inputs</code></td>
<td>
<p>A list of inputs common across patients that do not change within a simulation</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_common_pt_inputs">common_pt_inputs</code></td>
<td>
<p>A list of inputs that change across patients but are not affected by the intervention</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_unique_pt_inputs">unique_pt_inputs</code></td>
<td>
<p>A list of inputs that change across each intervention</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_init_event_list">init_event_list</code></td>
<td>
<p>A list of initial events and event times. If no initial events are given, a &quot;Start&quot; event at time 0 is created automatically</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_evt_react_list">evt_react_list</code></td>
<td>
<p>A list of event reactions</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_util_ongoing_list">util_ongoing_list</code></td>
<td>
<p>Vector of QALY named variables that are accrued at an ongoing basis (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_util_instant_list">util_instant_list</code></td>
<td>
<p>Vector of QALY named variables that are accrued instantaneously at an event (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_util_cycle_list">util_cycle_list</code></td>
<td>
<p>Vector of QALY named variables that are accrued in cycles (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_cost_ongoing_list">cost_ongoing_list</code></td>
<td>
<p>Vector of cost named variables that are accrued at an ongoing basis (discounted using drc)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_cost_instant_list">cost_instant_list</code></td>
<td>
<p>Vector of cost named variables that are accrued instantaneously at an event (discounted using drc)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_cost_cycle_list">cost_cycle_list</code></td>
<td>
<p>Vector of cost named variables that are accrued in cycles (discounted using drc)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_other_ongoing_list">other_ongoing_list</code></td>
<td>
<p>Vector of other named variables that are accrued at an ongoing basis (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_other_instant_list">other_instant_list</code></td>
<td>
<p>Vector of other named variables that are accrued instantaneously at an event (discounted using drq)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_npats">npats</code></td>
<td>
<p>The number of patients to be simulated (it will simulate npats * length(arm_list))</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_n_sim">n_sim</code></td>
<td>
<p>The number of simulations to run per sensitivity</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_psa_bool">psa_bool</code></td>
<td>
<p>A boolean to determine if PSA should be conducted. If n_sim &gt; 1 and psa_bool = FALSE, the differences between simulations will be due to sampling</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_sensitivity_bool">sensitivity_bool</code></td>
<td>
<p>A boolean to determine if Scenarios/DSA should be conducted.</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_sensitivity_names">sensitivity_names</code></td>
<td>
<p>A vector of scenario/DSA names that can be used to select the right sensitivity (e.g., c(&quot;Scenario_1&quot;, &quot;Scenario_2&quot;)). The parameter &quot;sens_name_used&quot; is created from it which corresponds to the one being used for each iteration.</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_n_sensitivity">n_sensitivity</code></td>
<td>
<p>Number of sensitivity analysis (DSA or Scenarios) to run. It will be interacted with sensitivity_names argument if not null (n_sensitivityitivity = n_sensitivity * length(sensitivity_names)). For DSA, it should be as many parameters as there are. For scenario, it should be 1.</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use for parallel computing</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_input_out">input_out</code></td>
<td>
<p>A vector of variables to be returned in the output data frame</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_ipd">ipd</code></td>
<td>
<p>Integer taking value 0 if no IPD data returned, 1 for full IPD data returned, and 2 IPD data but aggregating events</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_timed_freq">timed_freq</code></td>
<td>
<p>If NULL, it does not produce any timed outputs. Otherwise should be a number (e.g., every 1 year)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_debug">debug</code></td>
<td>
<p>If TRUE, will generate a log file</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_accum_backwards">accum_backwards</code></td>
<td>
<p>If TRUE, the ongoing accumulators will count backwards (i.e., the current value is applied until the previous update). If FALSE, the current value is applied between the current event and the next time it is updated.</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_continue_on_error">continue_on_error</code></td>
<td>
<p>If TRUE, on error  at patient stage will attempt to continue to the next simulation (only works if n_sim and/or n_sensitivity are &gt; 1, not at the patient level)</p>
</td></tr>
<tr><td><code id="run_sim_parallel_+3A_seed">seed</code></td>
<td>
<p>Starting seed to be used for the whole analysis. If null, it's set to 1 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is slightly different from <code>run_sim</code>.
<code>run_sim</code> allows to run single-core.
<code>run_sim_parallel</code> allows to use multiple-core at the simulation level,
making it more efficient for a large number of simulations relative to <code>run_sim</code> (e.g., for  PSA).
</p>
<p>Event ties are processed in the order declared within the <code>init_event_list</code> argument (<code>evts</code> argument within the first sublist of that object).
To do so, the program automatically adds a sequence from to 0 to the (number of events - 1) times 1e-10 to add to the event times when selecting the event with minimum time.
This time has been selected as it's relatively small yet not so small as to be ignored by which.min (see .Machine for more details)
</p>
<p>A list of protected objects that should not be used by the user as input names or in the global environment to avoid the risk of overwriting them is as follows:
c(&quot;arm&quot;, &quot;arm_list&quot;, &quot;categories_for_export&quot;, &quot;cur_evtlist&quot;, &quot;curtime&quot;, &quot;evt&quot;, &quot;i&quot;, &quot;prevtime&quot;, &quot;sens&quot;, &quot;simulation&quot;, &quot;sens_name_used&quot;,&quot;list_env&quot;,&quot;uc_lists&quot;,&quot;npats&quot;,&quot;ipd&quot;).
</p>
<p>The engine uses the L'Ecuyer-CMRG for the random number generator.
Note that if ncores &gt; 1, then results per simulation will only be exactly replicable if using run_sim_parallel
(as seeds are automatically transformed to be seven integer seeds -i.e, L'Ecuyer-CMRG seeds-)
</p>
<p>If no <code>drc</code> or <code>drq</code> parameters are passed within any of the input lists, these are assigned value 0.03.
Note that the random seeds are set to be unique in their category (i.e., at patient level, patient-arm level, etc.)
</p>
<p>Ongoing items will look backward to the last time updated when performing the discounting and accumulation.
This means that the user does not necessarily need to keep updating the value, but only add it when the value
changes looking forward (e.g., o_q = utility at event 1, at event 2 utility does not change, but at event 3 it does,
so we want to make sure to add o_q = utility at event 3 before updating utility. The program will automatically
look back until event 1). Note that in previous versions of the package backward was the default, and now this has switched to forward.
</p>
<p>If the <code>cycle</code> lists are used, then it is expected the user will declare as well the name of the variable
pasted with <code>cycle_l</code> and <code>cycle_starttime</code> (e.g., c_default_cycle_l and c_default_cycle_starttime) to
ensure the discounting can be computed using cycles, with cycle_l being the cycle length, and cycle_starttime
being the starting time in which the variable started counting.
</p>
<p><code>debug = TRUE</code> will export a log file with the timestamp up the error in the main working directory.
If <code>continue_on_error</code> is set to FALSE, it will only export analysis level inputs due to the parallel engine
(use single-engine for those inputs)
</p>
<p><code>continue_on_error</code> will skip the current simulation (so it won't continue for the rest of patient-arms) if TRUE.
Note that this will make the progress bar not correct, as a set of patients that were expected to be run is not.
</p>


<h3>Value</h3>

<p>A list of lists with the analysis results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
common_all_inputs &lt;-add_item(
util.sick = 0.8,
util.sicker = 0.5,
cost.sick = 3000,
cost.sicker = 7000,
cost.int = 1000,
coef_noint = log(0.2),
HR_int = 0.8,
drc = 0.035, #different values than what's assumed by default
drq = 0.035,
random_seed_sicker_i = sample.int(100000,5,replace = FALSE)
)

common_pt_inputs &lt;- add_item(death= max(0.0000001,rnorm(n=1, mean=12, sd=3))) 

unique_pt_inputs &lt;- add_item(fl.sick = 1,
                             q_default = util.sick,
                             c_default = cost.sick + if(arm=="int"){cost.int}else{0}) 
                             
init_event_list &lt;- 
add_tte(arm=c("noint","int"), evts = c("sick","sicker","death") ,input={
  sick &lt;- 0
  sicker &lt;- draw_tte(1,dist="exp",
   coef1=coef_noint, beta_tx = ifelse(arm=="int",HR_int,1),
   seed = random_seed_sicker_i[i])
  
})   

evt_react_list &lt;-
add_reactevt(name_evt = "sick",
             input = {}) %&gt;%
  add_reactevt(name_evt = "sicker",
               input = {
                 modify_item(list(q_default = util.sicker,
                                  c_default = cost.sicker + if(arm=="int"){cost.int}else{0},
                                  fl.sick = 0)) 
               }) %&gt;%
  add_reactevt(name_evt = "death",
               input = {
                 modify_item(list(q_default = 0,
                                  c_default = 0, 
                                  curtime = Inf)) 
               }) 
               
util_ongoing &lt;- "q_default"
cost_ongoing &lt;- "c_default"
                          

run_sim_parallel(arm_list=c("int","noint"),
common_all_inputs = common_all_inputs,
common_pt_inputs = common_pt_inputs,
unique_pt_inputs = unique_pt_inputs,
init_event_list = init_event_list,
evt_react_list = evt_react_list,
util_ongoing_list = util_ongoing,
cost_ongoing_list = cost_ongoing,
npats = 2,
n_sim = 1,
psa_bool = FALSE,
ipd = 1,
ncores = 1)

</code></pre>

<hr>
<h2 id='summary_results_det'>Deterministic results for a specific treatment</h2><span id='topic+summary_results_det'></span>

<h3>Description</h3>

<p>Deterministic results for a specific treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_results_det(out = results[[1]][[1]], arm = NULL, wtp = 50000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_results_det_+3A_out">out</code></td>
<td>
<p>The final_output data frame from the list object returned by <code>run_sim()</code></p>
</td></tr>
<tr><td><code id="summary_results_det_+3A_arm">arm</code></td>
<td>
<p>The reference treatment for calculation of incremental outcomes</p>
</td></tr>
<tr><td><code id="summary_results_det_+3A_wtp">wtp</code></td>
<td>
<p>Willingness to pay to have INMB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with absolute costs, LYs, QALYs, and ICER and ICUR for each intervention
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res &lt;- list(list(list(sensitivity_name = "", arm_list = c("int", "noint"
), total_lys = c(int = 9.04687362556945, noint = 9.04687362556945
), total_qalys = c(int = 6.20743830697466, noint = 6.18115138126336
), total_costs = c(int = 49921.6357486899, noint = 41225.2544659378
), total_lys_undisc = c(int = 10.8986618377039, noint = 10.8986618377039
), total_qalys_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), total_costs_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), c_default = c(int = 49921.6357486899, noint = 41225.2544659378
), c_default_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), q_default = c(int = 6.20743830697466, noint = 6.18115138126336
), q_default_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), merged_df = list(simulation = 1L, sensitivity = 1L))))


summary_results_det(res[[1]][[1]],arm="int")

</code></pre>

<hr>
<h2 id='summary_results_sens'>Summary of sensitivity outputs for a treatment</h2><span id='topic+summary_results_sens'></span>

<h3>Description</h3>

<p>Summary of sensitivity outputs for a treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_results_sens(out = results, arm = NULL, wtp = 50000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_results_sens_+3A_out">out</code></td>
<td>
<p>The list object returned by <code>run_sim()</code></p>
</td></tr>
<tr><td><code id="summary_results_sens_+3A_arm">arm</code></td>
<td>
<p>The reference treatment for calculation of incremental outcomes</p>
</td></tr>
<tr><td><code id="summary_results_sens_+3A_wtp">wtp</code></td>
<td>
<p>Willingness to pay to have INMB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each sensitivity output per arm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- list(list(list(sensitivity_name = "", arm_list = c("int", "noint"
), total_lys = c(int = 9.04687362556945, noint = 9.04687362556945
), total_qalys = c(int = 6.20743830697466, noint = 6.18115138126336
), total_costs = c(int = 49921.6357486899, noint = 41225.2544659378
), total_lys_undisc = c(int = 10.8986618377039, noint = 10.8986618377039
), total_qalys_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), total_costs_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), c_default = c(int = 49921.6357486899, noint = 41225.2544659378
), c_default_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), q_default = c(int = 6.20743830697466, noint = 6.18115138126336
), q_default_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), merged_df = list(simulation = 1L, sensitivity = 1L))))


summary_results_sens(res,arm="int")
</code></pre>

<hr>
<h2 id='summary_results_sim'>Summary of PSA outputs for a treatment</h2><span id='topic+summary_results_sim'></span>

<h3>Description</h3>

<p>Summary of PSA outputs for a treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_results_sim(out = results[[1]], arm = NULL, wtp = 50000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_results_sim_+3A_out">out</code></td>
<td>
<p>The output_sim data frame from the list object returned by <code>run_sim()</code></p>
</td></tr>
<tr><td><code id="summary_results_sim_+3A_arm">arm</code></td>
<td>
<p>The reference treatment for calculation of incremental outcomes</p>
</td></tr>
<tr><td><code id="summary_results_sim_+3A_wtp">wtp</code></td>
<td>
<p>Willingness to pay to have INMB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with mean and 95% CI of absolute costs, LYs, QALYs, ICER and ICUR for each intervention from the PSA samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- list(list(list(sensitivity_name = "", arm_list = c("int", "noint"
), total_lys = c(int = 9.04687362556945, noint = 9.04687362556945
), total_qalys = c(int = 6.20743830697466, noint = 6.18115138126336
), total_costs = c(int = 49921.6357486899, noint = 41225.2544659378
), total_lys_undisc = c(int = 10.8986618377039, noint = 10.8986618377039
), total_qalys_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), total_costs_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), c_default = c(int = 49921.6357486899, noint = 41225.2544659378
), c_default_undisc = c(int = 59831.3573929783, noint = 49293.1025437205
), q_default = c(int = 6.20743830697466, noint = 6.18115138126336
), q_default_undisc = c(int = 7.50117621700097, noint = 7.47414569286751
), merged_df = list(simulation = 1L, sensitivity = 1L))))


summary_results_sim(res[[1]],arm="int")
</code></pre>

<hr>
<h2 id='tte.df'>Example TTE IPD data</h2><span id='topic+tte.df'></span>

<h3>Description</h3>

<p>An example of TTE IPD data for the example_ipd file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tte.df
</code></pre>


<h3>Format</h3>



<h4><code>tte.df</code></h4>

<p>A data frame with 1000 rows and 8 columns:
</p>

<dl>
<dt>USUBJID</dt><dd><p>Patient ID</p>
</dd>
<dt>ARMCD, ARM</dt><dd><p>Arm code and variables</p>
</dd>
<dt>PARAMCD, PARAM</dt><dd><p>Parameter</p>
</dd>
<dt>AVAL, AVALCD</dt><dd><p>Values of interest</p>
</dd>
<dt>CNSR</dt><dd><p>Censored observation?</p>
</dd>
</dl>




<h3>Source</h3>

<p>Simulated through FlexsurvPlus package using sim_adtte(seed = 821, rho = 0, beta_1a = log(0.6), beta_1b = log(0.6), beta_pd = log(0.2))
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
