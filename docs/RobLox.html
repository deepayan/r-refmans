<!DOCTYPE html><html><head><title>Help for package RobLox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobLox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RobLox-package'>
<p>Optimally robust influence curves and estimators for location and scale</p></a></li>
<li><a href='#finiteSampleCorrection'><p>Function to compute finite-sample corrected radii</p></a></li>
<li><a href='#rlOptIC'><p>Computation of the optimally robust IC for AL estimators</p></a></li>
<li><a href='#rlsOptIC.AL'><p>Computation of the optimally robust IC for AL estimators</p></a></li>
<li><a href='#rlsOptIC.An1'><p>Computation of the optimally robust IC for An1 estimators</p></a></li>
<li><a href='#rlsOptIC.An2'><p>Computation of the optimally robust IC for An2 estimators</p></a></li>
<li><a href='#rlsOptIC.AnMad'><p>Computation of the optimally robust IC for AnMad estimators</p></a></li>
<li><a href='#rlsOptIC.BM'><p>Computation of the optimally robust IC for BM estimators</p></a></li>
<li><a href='#rlsOptIC.Ha3'><p>Computation of the optimally robust IC for Ha3 estimators</p></a></li>
<li><a href='#rlsOptIC.Ha4'><p>Computation of the optimally robust IC for Ha4 estimators</p></a></li>
<li><a href='#rlsOptIC.HaMad'><p>Computation of the optimally robust IC for HuMad estimators</p></a></li>
<li><a href='#rlsOptIC.Hu1'><p>Computation of the optimally robust IC for Hu1 estimators</p></a></li>
<li><a href='#rlsOptIC.Hu2'><p>Computation of the optimally robust IC for Hu2 estimators</p></a></li>
<li><a href='#rlsOptIC.Hu2a'><p>Computation of the optimally robust IC for Hu2a estimators</p></a></li>
<li><a href='#rlsOptIC.Hu3'><p>Computation of the optimally robust IC for Hu3 estimators</p></a></li>
<li><a href='#rlsOptIC.HuMad'><p>Computation of the optimally robust IC for HuMad estimators</p></a></li>
<li><a href='#rlsOptIC.M'><p>Computation of the optimally robust IC for M estimators</p></a></li>
<li><a href='#rlsOptIC.MM2'><p>Computation of the optimally robust IC for MM2 estimators</p></a></li>
<li><a href='#rlsOptIC.Tu1'><p>Computation of the optimally robust IC for Tu1 estimators</p></a></li>
<li><a href='#rlsOptIC.Tu2'><p>Computation of the optimally robust IC for Tu2 estimators</p></a></li>
<li><a href='#rlsOptIC.TuMad'><p>Computation of the optimally robust IC for TuMad estimators</p></a></li>
<li><a href='#roblox'><p>Optimally robust estimator for location and/or scale</p></a></li>
<li><a href='#rowRoblox+20and+20colRoblox'><p>Optimally robust estimation for location and/or scale</p></a></li>
<li><a href='#rsOptIC'><p>Computation of the optimally robust IC for AL estimators</p></a></li>
<li><a href='#showdown'><p>Estimator Showdown by Monte-Carlo Study.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimally Robust Influence Curves and Estimators for Location
and Scale</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the determination of optimally robust influence curves and
             estimators in case of normal location and/or scale 
             (see Chapter 8 in Kohl (2005) <a href="https://epub.uni-bayreuth.de/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/839/2/DissMKohl.pdf</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.4), stats, distrMod(&ge; 2.8.0), RobAStBase(&ge; 1.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, lattice, RColorBrewer, Biobase, RandVar(&ge; 1.2.0),
distr(&ge; 2.8.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://robast.r-forge.r-project.org/">http://robast.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>LastChangedDate:</td>
<td>{$LastChangedDate: 2024-02-04 09:41:04 +0100 (So, 04.
Feb 2024) $}</td>
</tr>
<tr>
<td>LastChangedRevision:</td>
<td>{$LastChangedRevision: 1271 $}</td>
</tr>
<tr>
<td>VCS/SVNRevision:</td>
<td>1214</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-10 08:31:23 UTC; kohlm</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Kohl [cre, cph],
  Peter Ruckdeschel [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Kohl &lt;Matthias.Kohl@stamats.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-10 23:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='RobLox-package'>
Optimally robust influence curves and estimators for location and scale
</h2><span id='topic+RobLox-package'></span><span id='topic+RobLox'></span>

<h3>Description</h3>

<p>Functions for the determination of optimally robust influence curves and 
estimators in case of normal location and/or scale 
(see Chapter 8 in Kohl (2005) &lt;https://epub.uni-bayreuth.de/839/2/DissMKohl.pdf&gt;).
</p>


<h3>Package versions</h3>

<p>Note: The first two numbers of package versions do not necessarily reflect
package-individual development, but rather are chosen for the
RobAStXXX family as a whole in order to ease updating &quot;depends&quot;
information.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl  <a href="mailto:matthias.kohl@stamats.de">matthias.kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of Not Knowing the Radius.
Statistical Methods and Applications  <em>17</em>(1): 13-40. <a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>M. Kohl and H.P. Deigner (2010). Preprocessing of gene expression data by 
optimally robust estimators. BMC Bioinformatics <em>11</em>, 583.
<a href="https://doi.org/10.1186/1471-2105-11-583">doi:10.1186/1471-2105-11-583</a>.
</p>
<p>M. Kohl (2012). Bounded influence estimation for regression and scale.
Statistics, <b>46</b>(4): 437-488. <a href="https://doi.org/10.1080/02331888.2010.540668">doi:10.1080/02331888.2010.540668</a>
</p>


<h3>See Also</h3>

 <p><code><a href="RobAStBase.html#topic+0RobAStBase-package">RobAStBase-package</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobLox)
ind &lt;- rbinom(100, size=1, prob=0.05) 
x &lt;- rnorm(100, mean=ind*3, sd=(1-ind) + ind*9)
roblox(x)
res &lt;- roblox(x, eps.lower = 0.01, eps.upper = 0.1, returnIC = TRUE)
estimate(res)
confint(res)
confint(res, method = symmetricBias())
pIC(res)
## don't run to reduce check time on CRAN
## Not run: 
checkIC(pIC(res))
Risks(pIC(res))
Infos(pIC(res))
plot(pIC(res))
infoPlot(pIC(res))

## End(Not run)
## row-wise application
ind &lt;- rbinom(200, size=1, prob=0.05) 
X &lt;- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
rowRoblox(X)
</code></pre>

<hr>
<h2 id='finiteSampleCorrection'>Function to compute finite-sample corrected radii</h2><span id='topic+finiteSampleCorrection'></span>

<h3>Description</h3>

<p>Given some radius and some sample size the function computes
the corresponding finite-sample corrected radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finiteSampleCorrection(r, n, model = "locsc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finiteSampleCorrection_+3A_r">r</code></td>
<td>
<p> asymptotic radius (non-negative numeric) </p>
</td></tr>
<tr><td><code id="finiteSampleCorrection_+3A_n">n</code></td>
<td>
<p> sample size </p>
</td></tr>
<tr><td><code id="finiteSampleCorrection_+3A_model">model</code></td>
<td>
<p> has to be <code>"locsc"</code> (for location and scale),
<code>"loc"</code> (for location) or <code>"sc"</code> (for scale), respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The finite-sample correction is based on empirical results obtained via 
simulation studies. 
</p>
<p>Given some radius of a shrinking contamination neighborhood which leads 
to an asymptotically optimal robust estimator, the finite-sample empirical 
MSE based on contaminated samples was minimized for this class of 
asymptotically optimal estimators and the corresponding finite-sample 
radius determined and saved.
</p>
<p>The computation is based on the saved results of these Monte-Carlo simulations.
</p>


<h3>Value</h3>

<p>Finite-sample corrected radius.</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>M. Kohl and H.P. Deigner (2010). Preprocessing of gene expression data by 
optimally robust estimators. BMC Bioinformatics <em>11</em>, 583.
<a href="https://doi.org/10.1186/1471-2105-11-583">doi:10.1186/1471-2105-11-583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roblox">roblox</a></code>, <code><a href="#topic+rowRoblox">rowRoblox</a></code>, 
<code><a href="#topic+colRoblox">colRoblox</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>finiteSampleCorrection(n = 3, r = 0.001, model = "locsc")
finiteSampleCorrection(n = 10, r = 0.02, model = "loc")
finiteSampleCorrection(n = 250, r = 0.15, model = "sc")
</code></pre>

<hr>
<h2 id='rlOptIC'>Computation of the optimally robust IC for AL estimators</h2><span id='topic+rlOptIC'></span>

<h3>Description</h3>

<p>The function <code>rlOptIC</code> computes the optimally robust IC for 
AL estimators in case of normal location and (convex) contamination 
neighborhoods. The definition of these estimators can be found 
in Rieder (1994) or Kohl (2005), respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlOptIC(r, mean = 0, sd = 1, bUp = 1000, computeIC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlOptIC_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlOptIC_+3A_mean">mean</code></td>
<td>
<p> specified mean.</p>
</td></tr>
<tr><td><code id="rlOptIC_+3A_sd">sd</code></td>
<td>
<p> specified standard deviation.</p>
</td></tr>
<tr><td><code id="rlOptIC_+3A_bup">bUp</code></td>
<td>
<p> positive real: the upper end point of the 
interval to be searched for the clipping bound b. </p>
</td></tr>
<tr><td><code id="rlOptIC_+3A_computeic">computeIC</code></td>
<td>
<p> logical: should IC be computed. See details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'computeIC' is 'FALSE' only the Lagrange multipliers 'A', 'a', and
'b' contained in the optimally robust IC are computed.
</p>


<h3>Value</h3>

<p>If 'computeIC' is 'TRUE' an object of class <code>"ContIC"</code> is returned, 
otherwise a list of Lagrange multipliers
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p> standardizing constant </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> centering constant; always '= 0' is this symmetric setup </p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p> optimal clipping bound </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="#topic+roblox">roblox</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlOptIC(r = 0.1)
distrExOptions("ErelativeTolerance" = 1e-12)
checkIC(IC1)
distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25) # default
Risks(IC1)
cent(IC1)
clip(IC1)
stand(IC1)
plot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.AL'>Computation of the optimally robust IC for AL estimators</h2><span id='topic+rlsOptIC.AL'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.AL</code> computes the optimally robust IC for 
AL estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Section 8.2 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.AL(r, mean = 0, sd = 1, A.loc.start = 1, a.sc.start = 0, 
            A.sc.start = 0.5, bUp = 1000, delta = 1e-6, itmax = 100, 
            check = FALSE, computeIC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.AL_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_mean">mean</code></td>
<td>
<p> specified mean.</p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_sd">sd</code></td>
<td>
<p> specified standard deviation.</p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_a.loc.start">A.loc.start</code></td>
<td>
<p> positive real: starting value for 
the standardizing constant of the location part. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_a.sc.start">a.sc.start</code></td>
<td>
<p> real: starting value for centering
constant of the scale part. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_a.sc.start">A.sc.start</code></td>
<td>
<p> positive real: starting value for 
the standardizing constant of the scale part. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_bup">bUp</code></td>
<td>
<p> positive real: the upper end point of the 
interval to be searched for the clipping bound b. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_itmax">itmax</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_check">check</code></td>
<td>
<p> logical: should constraints be checked. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AL_+3A_computeic">computeIC</code></td>
<td>
<p> logical: should IC be computed. See details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lagrange multipliers contained in the expression
of the optimally robust IC can be accessed via the
accessor functions <code>cent</code>, <code>clip</code> and <code>stand</code>.
If 'computeIC' is 'FALSE' only the Lagrange multipliers 'A', 'a', 
and 'b' contained in the optimally robust IC are computed.
</p>


<h3>Value</h3>

<p>If 'computeIC' is 'TRUE' an object of class <code>"ContIC"</code> is returned, 
otherwise a list of Lagrange multipliers
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p> standardizing matrix </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> centering vector </p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p> optimal clipping bound </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="#topic+roblox">roblox</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.AL(r = 0.1, check = TRUE)
distrExOptions("ErelativeTolerance" = 1e-12)
checkIC(IC1)
distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25) # default
Risks(IC1)
cent(IC1)
clip(IC1)
stand(IC1)

## don't run to reduce check time on CRAN
## Not run: 
plot(IC1)
infoPlot(IC1)

## k-step estimation
## better use function roblox (see ?roblox)
## 1. data: random sample
ind &lt;- rbinom(100, size=1, prob=0.05) 
x &lt;- rnorm(100, mean=0, sd=(1-ind) + ind*9)
mean(x)
sd(x)
median(x)
mad(x)

## 2. Kolmogorov(-Smirnov) minimum distance estimator (default)
## -&gt; we use it as initial estimate for one-step construction
(est0 &lt;- MDEstimator(x, ParamFamily = NormLocationScaleFamily()))

## 3.1 one-step estimation: radius known
IC1 &lt;- rlsOptIC.AL(r = 0.5, mean = estimate(est0)[1], sd = estimate(est0)[2])
(est1 &lt;- oneStepEstimator(x, IC1, est0))

## 3.2 k-step estimation: radius known
## Choose k = 3
(est2 &lt;- kStepEstimator(x, IC1, est0, steps = 3L))

## 4.1 one-step estimation: radius unknown
## take least favorable radius r = 0.579
## cf. Table 8.1 in Kohl(2005)
IC2 &lt;- rlsOptIC.AL(r = 0.579, mean = estimate(est0)[1], sd = estimate(est0)[2])
(est3 &lt;- oneStepEstimator(x, IC2, est0))

## 4.2 k-step estimation: radius unknown
## take least favorable radius r = 0.579
## cf. Table 8.1 in Kohl(2005)
## choose k = 3
(est4 &lt;- kStepEstimator(x, IC2, est0, steps = 3L))

## End(Not run)
</code></pre>

<hr>
<h2 id='rlsOptIC.An1'>Computation of the optimally robust IC for An1 estimators</h2><span id='topic+rlsOptIC.An1'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.An1</code> computes the optimally robust IC for 
An1 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.3 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.An1(r, aUp = 2.5, delta = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.An1_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.An1_+3A_aup">aUp</code></td>
<td>
<p> positive real: the upper end point of the interval 
to be searched for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.An1_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal value of the tuning constant a can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Andrews, D.F., Bickel, P.J., Hampel, F.R., Huber, P.J.,
Rogers, W.H. and Tukey, J.W. (1972) <em>Robust estimates of location</em>. 
Princeton University Press.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.An1(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
## don't run to reduce check time on CRAN
## Not run: 
plot(IC1)
infoPlot(IC1)

## End(Not run)
</code></pre>

<hr>
<h2 id='rlsOptIC.An2'>Computation of the optimally robust IC for An2 estimators</h2><span id='topic+rlsOptIC.An2'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.An2</code> computes the optimally robust IC for 
An2 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.3 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.An2(r, a.start = 1.5, k.start = 1.5, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.An2_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.An2_+3A_a.start">a.start</code></td>
<td>
<p> positive real: starting value for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.An2_+3A_k.start">k.start</code></td>
<td>
<p> positive real: starting value for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.An2_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.An2_+3A_max">MAX</code></td>
<td>
<p> if a or k are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for An2 estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on a and k. The optimal values of the 
tuning constants a and k can be read off from the slot 
<code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Andrews, D.F., Bickel, P.J., Hampel, F.R., Huber, P.J.,
Rogers, W.H. and Tukey, J.W. (1972) <em>Robust estimates of location</em>. 
Princeton University Press.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.An2(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.AnMad'>Computation of the optimally robust IC for AnMad estimators</h2><span id='topic+rlsOptIC.AnMad'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.AnMad</code> computes the optimally robust IC for 
AnMad estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators were 
considered in Andrews et al. (1972). A definition of these estimators 
can also be found in Subsection 8.5.3 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.AnMad(r, aUp = 2.5, delta = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.AnMad_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AnMad_+3A_aup">aUp</code></td>
<td>
<p> positive real: the upper end point of the interval 
to be searched for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.AnMad_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal value of the tuning constant a can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Andrews, D.F., Bickel, P.J., Hampel, F.R., Huber, P.J.,
Rogers, W.H. and Tukey, J.W. (1972) <em>Robust estimates of location</em>. 
Princeton University Press.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.AnMad(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.BM'>Computation of the optimally robust IC for BM estimators</h2><span id='topic+rlsOptIC.BM'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.BM</code> computes the optimally robust IC for 
BM estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators were proposed 
by Bednarski and Mueller (2001). A definition of these 
estimators can also be found in Section 8.4 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.BM(r, bL.start = 2, bS.start = 1.5, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.BM_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.BM_+3A_bl.start">bL.start</code></td>
<td>
<p> positive real: starting value for <code class="reqn">b_{\rm loc}</code>. </p>
</td></tr>
<tr><td><code id="rlsOptIC.BM_+3A_bs.start">bS.start</code></td>
<td>
<p> positive real: starting value for <code class="reqn">b_{{\rm sc},0}</code>. </p>
</td></tr>
<tr><td><code id="rlsOptIC.BM_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.BM_+3A_max">MAX</code></td>
<td>
<p> if <code class="reqn">b_{\rm loc}</code> or <code class="reqn">b_{{\rm sc},0}</code> 
are beyond the admitted values, <code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for BM estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on <code class="reqn">b_{\rm loc}</code> 
and <code class="reqn">b_{{\rm sc},0}</code>. The optimal values of the  
tuning constants <code class="reqn">b_{\rm loc}</code>, <code class="reqn">b_{{\rm sc},0}</code>, 
<code class="reqn">\alpha</code> and <code class="reqn">\gamma</code> can be read off 
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Bednarski, T and Mueller, C.H. (2001) Optimal bounded influence
regression and scale M-estimators in the context of experimental
design. Statistics, <b>35</b>(4): 349-369.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>M. Kohl (2012). Bounded influence estimation for regression and scale.
Statistics, <b>46</b>(4): 437-488. <a href="https://doi.org/10.1080/02331888.2010.540668">doi:10.1080/02331888.2010.540668</a>
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.BM(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Ha3'>Computation of the optimally robust IC for Ha3 estimators</h2><span id='topic+rlsOptIC.Ha3'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Ha3</code> computes the optimally robust IC for 
Ha3 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.2 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Ha3(r, a.start = 0.25, b.start = 2.5, c.start = 5, 
             delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Ha3_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha3_+3A_a.start">a.start</code></td>
<td>
<p> positive real: starting value for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha3_+3A_b.start">b.start</code></td>
<td>
<p> positive real: starting value for b. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha3_+3A_c.start">c.start</code></td>
<td>
<p> positive real: starting value for c. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha3_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha3_+3A_max">MAX</code></td>
<td>
<p> if a or b or c are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for Ha3 estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on a, b and c. The optimal values of 
the tuning constants a, b and c can be read off 
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Ha3(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
## don't run to reduce check time on CRAN
## Not run: 
plot(IC1)
infoPlot(IC1)

## End(Not run)
</code></pre>

<hr>
<h2 id='rlsOptIC.Ha4'>Computation of the optimally robust IC for Ha4 estimators</h2><span id='topic+rlsOptIC.Ha4'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Ha4</code> computes the optimally robust IC for 
Ha4 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.2 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Ha4(r, a.start = 0.25, b.start = 2.5, c.start = 5, 
             k.start = 1, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Ha4_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha4_+3A_a.start">a.start</code></td>
<td>
<p> positive real: starting value for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha4_+3A_b.start">b.start</code></td>
<td>
<p> positive real: starting value for b. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha4_+3A_c.start">c.start</code></td>
<td>
<p> positive real: starting value for c. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha4_+3A_k.start">k.start</code></td>
<td>
<p> positive real: starting value for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha4_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.Ha4_+3A_max">MAX</code></td>
<td>
<p> if a or b or c or k are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for Ha4 estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on a, b, c and k. The optimal values of 
the tuning constants a, b, c and k can be read off 
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Marazzi, A. (1993) <em>Algorithms, routines, and S functions 
for robust statistics</em>. Wadsworth and Brooks / Cole.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Ha4(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.HaMad'>Computation of the optimally robust IC for HuMad estimators</h2><span id='topic+rlsOptIC.HaMad'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.HuMad</code> computes the optimally robust IC for 
HuMad estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators were 
considered in Andrews et al. (1972). A definition of these estimators 
can also be found in Subsection 8.5.2 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.HaMad(r, a.start = 0.25, b.start = 2.5, c.start = 5, 
               delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.HaMad_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.HaMad_+3A_a.start">a.start</code></td>
<td>
<p> positive real: starting value for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.HaMad_+3A_b.start">b.start</code></td>
<td>
<p> positive real: starting value for b. </p>
</td></tr>
<tr><td><code id="rlsOptIC.HaMad_+3A_c.start">c.start</code></td>
<td>
<p> positive real: starting value for c. </p>
</td></tr>
<tr><td><code id="rlsOptIC.HaMad_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.HaMad_+3A_max">MAX</code></td>
<td>
<p> if a or b or c are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for HaMad estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on a, b and c. The optimal values of 
the tuning constants a, b, and c can be read off 
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Andrews, D.F., Bickel, P.J., Hampel, F.R., Huber, P.J.,
Rogers, W.H. and Tukey, J.W. (1972) <em>Robust estimates of location</em>. 
Princeton University Press.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.HaMad(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Hu1'>Computation of the optimally robust IC for Hu1 estimators</h2><span id='topic+rlsOptIC.Hu1'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Hu1</code> computes the optimally robust IC for 
Hu1 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators were 
proposed by Huber (1964), Proposal 2. A definition of these 
estimators can also be found in Subsection 8.5.1 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Hu1(r, kUp = 2.5, delta = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Hu1_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu1_+3A_kup">kUp</code></td>
<td>
<p> positive real: the upper end point of the interval 
to be searched for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu1_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal value of the tuning constant k can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Huber, P.J. (1964) Robust estimation of a location parameter. 
Ann. Math. Stat. <b>35</b>: 73&ndash;101.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Hu1(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Hu2'>Computation of the optimally robust IC for Hu2 estimators</h2><span id='topic+rlsOptIC.Hu2'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Hu2</code> computes the optimally robust IC for 
Hu2 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators were
proposed in Example 6.4.1 of Huber (1981). A definition of these 
estimators can also be found in Subsection 8.5.1 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Hu2(r, k.start = 1.5, c.start = 1.5, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Hu2_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2_+3A_k.start">k.start</code></td>
<td>
<p> positive real: starting value for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2_+3A_c.start">c.start</code></td>
<td>
<p> positive real: starting value for c. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2_+3A_max">MAX</code></td>
<td>
<p> if k1 or k2 are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for Hu2 estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on k and c. The optimal values of 
the tuning constants k and c can be read off 
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Hu2(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Hu2a'>Computation of the optimally robust IC for Hu2a estimators</h2><span id='topic+rlsOptIC.Hu2a'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Hu2a</code> computes the optimally robust IC for 
Hu2a estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators are a
simple modification of Huber (1964), Proposal 2 where we, in addition,
admit a clipping from below. The definition of 
these estimators can be found in Subsection 8.5.1 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Hu2a(r, k1.start = 0.25, k2.start = 2.5, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Hu2a_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2a_+3A_k1.start">k1.start</code></td>
<td>
<p> positive real: starting value for k1. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2a_+3A_k2.start">k2.start</code></td>
<td>
<p> positive real: starting value for k2. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2a_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu2a_+3A_max">MAX</code></td>
<td>
<p> if k1 or k2 are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for Hu2a estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on k1 and k2. The optimal values of 
the tuning constants k1 and k2 can be read off 
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Huber, P.J. (1964) Robust estimation of a location parameter. 
Ann. Math. Stat. <b>35</b>: 73&ndash;101.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Hu2a(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Hu3'>Computation of the optimally robust IC for Hu3 estimators</h2><span id='topic+rlsOptIC.Hu3'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Hu3</code> computes the optimally robust IC for 
Hu3 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.1 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Hu3(r, k.start = 1, c1.start = 0.1, c2.start = 0.5, 
             delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Hu3_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu3_+3A_k.start">k.start</code></td>
<td>
<p> positive real: starting value for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu3_+3A_c1.start">c1.start</code></td>
<td>
<p> positive real: starting value for c1. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu3_+3A_c2.start">c2.start</code></td>
<td>
<p> positive real: starting value for c2. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu3_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.Hu3_+3A_max">MAX</code></td>
<td>
<p> if k or c1 or c2 are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for Hu2 estimators
is based on <code>optim</code> where <code>MAX</code> is used to
control the constraints on k, c1 and c2. The optimal values of
the tuning constants k, c1 and c2 can be read off
from the slot <code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Hu3(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.HuMad'>Computation of the optimally robust IC for HuMad estimators</h2><span id='topic+rlsOptIC.HuMad'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.HuMad</code> computes the optimally robust IC for 
HuMad estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators were 
proposed by Andrews et al. (1972), p. 12. A definition of these 
estimators can also be found in Subsection 8.5.1 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.HuMad(r, kUp = 2.5, delta = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.HuMad_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.HuMad_+3A_kup">kUp</code></td>
<td>
<p> positive real: the upper end point of the interval 
to be searched for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.HuMad_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal value of the tuning constant k can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Andrews, D.F., Bickel, P.J., Hampel, F.R., Huber, P.J.,
Rogers, W.H. and Tukey, J.W. (1972) <em>Robust estimates of location</em>. 
Princeton University Press.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.HuMad(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.M'>Computation of the optimally robust IC for M estimators</h2><span id='topic+rlsOptIC.M'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.M</code> computes the optimally robust IC for 
M estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Section 8.3 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.M(r, ggLo = 0.5, ggUp = 1.5, a1.start = 0.75, a3.start = 0.25, 
           bUp = 1000, delta = 1e-05, itmax = 100, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.M_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_gglo">ggLo</code></td>
<td>
<p> non-negative real: the lower end point of the interval to be searched 
for <code class="reqn">\gamma</code>. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_ggup">ggUp</code></td>
<td>
<p> positive real: the upper end point of the interval to be searched 
for <code class="reqn">\gamma</code>. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_a1.start">a1.start</code></td>
<td>
<p> real: starting value for <code class="reqn">\alpha_1</code>. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_a3.start">a3.start</code></td>
<td>
<p> real: starting value for <code class="reqn">\alpha_3</code>. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_bup">bUp</code></td>
<td>
<p> positive real: upper bound used in the 
computation of the optimal clipping bound b. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_itmax">itmax</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="rlsOptIC.M_+3A_check">check</code></td>
<td>
<p> logical. Should constraints be checked. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal values of the tuning constants <code class="reqn">\alpha_1</code>, 
<code class="reqn">\alpha_3</code>, b and <code class="reqn">\gamma</code> can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Huber, P.J. (1981) <em>Robust Statistics</em>. New York: Wiley.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.M(r = 0.1, check = TRUE)
distrExOptions("ErelativeTolerance" = 1e-12)
checkIC(IC1, NormLocationScaleFamily())
distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.MM2'>Computation of the optimally robust IC for MM2 estimators</h2><span id='topic+rlsOptIC.MM2'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.MM2</code> computes the optimally robust IC for 
MM2 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. These estimators are based
on a proposal of Fraiman et al. (2001), p. 206. A definition of 
these estimators can also be found in Section 8.6 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.MM2(r, c.start = 1.5, d.start = 2, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.MM2_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.MM2_+3A_c.start">c.start</code></td>
<td>
<p> positive real: starting value for c. </p>
</td></tr>
<tr><td><code id="rlsOptIC.MM2_+3A_d.start">d.start</code></td>
<td>
<p> positive real: starting value for d. </p>
</td></tr>
<tr><td><code id="rlsOptIC.MM2_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.MM2_+3A_max">MAX</code></td>
<td>
<p> if a or k are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for MM2 estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on c and d. The optimal values of 
the tuning constants c and d can be read off from the slot 
<code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Fraiman, R., Yohai, V.J. and Zamar, R.H. (2001) Optimal robust
M-estimates of location. Ann. Stat. <b>29</b>(1): 194-223.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.MM2(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Tu1'>Computation of the optimally robust IC for Tu1 estimators</h2><span id='topic+rlsOptIC.Tu1'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Tu1</code> computes the optimally robust IC for 
Tu1 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.4 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Tu1(r, aUp = 10, delta = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Tu1_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Tu1_+3A_aup">aUp</code></td>
<td>
<p> positive real: the upper end point of the interval 
to be searched for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Tu1_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal value of the tuning constant a can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Beaton, A.E. and Tukey, J.W. (1974) The fitting of power series,
meaning polynomials, illustrated on band-spectroscopic data.
Discussions. Technometrics <b>16</b>: 147&ndash;185.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Tu1(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.Tu2'>Computation of the optimally robust IC for Tu2 estimators</h2><span id='topic+rlsOptIC.Tu2'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.Tu2</code> computes the optimally robust IC for 
Tu2 estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.4 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.Tu2(r, a.start = 5, k.start = 1.5, delta = 1e-06, MAX = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.Tu2_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Tu2_+3A_a.start">a.start</code></td>
<td>
<p> positive real: starting value for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Tu2_+3A_k.start">k.start</code></td>
<td>
<p> positive real: starting value for k. </p>
</td></tr>
<tr><td><code id="rlsOptIC.Tu2_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rlsOptIC.Tu2_+3A_max">MAX</code></td>
<td>
<p> if a or k are beyond the admitted values, 
<code>MAX</code> is returned. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computation of the optimally robust IC for Tu2 estimators
is based on <code>optim</code> where <code>MAX</code> is used to 
control the constraints on a and k. The optimal values of 
the tuning constant a and k can be read off from the slot 
<code>Infos</code> of the resulting IC.
</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Beaton, A.E. and Tukey, J.W. (1974) The fitting of power series,
meaning polynomials, illustrated on band-spectroscopic data.
Discussions. Technometrics <b>16</b>: 147&ndash;185.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.Tu2(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='rlsOptIC.TuMad'>Computation of the optimally robust IC for TuMad estimators</h2><span id='topic+rlsOptIC.TuMad'></span>

<h3>Description</h3>

<p>The function <code>rlsOptIC.TuMad</code> computes the optimally robust IC for 
TuMad estimators in case of normal location with unknown scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Subsection 8.5.4 of Kohl (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlsOptIC.TuMad(r, aUp = 10, delta = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlsOptIC.TuMad_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rlsOptIC.TuMad_+3A_aup">aUp</code></td>
<td>
<p> positive real: the upper end point of the interval 
to be searched for a. </p>
</td></tr>
<tr><td><code id="rlsOptIC.TuMad_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal value of the tuning constant a can be read off 
from the slot <code>Infos</code> of the resulting IC.</p>


<h3>Value</h3>

<p>Object of class <code>"IC"</code></p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Beaton, A.E. and Tukey, J.W. (1974) The fitting of power series,
meaning polynomials, illustrated on band-spectroscopic data.
Discussions. Technometrics <b>16</b>: 147&ndash;185.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+IC-class">IC-class</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rlsOptIC.TuMad(r = 0.1)
checkIC(IC1)
Risks(IC1)
Infos(IC1)
plot(IC1)
infoPlot(IC1)
</code></pre>

<hr>
<h2 id='roblox'>Optimally robust estimator for location and/or scale</h2><span id='topic+roblox'></span>

<h3>Description</h3>

<p>The function <code>roblox</code> computes the optimally robust estimator
and corresponding IC for normal location und/or scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Rieder (1994) or Kohl (2005),
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roblox(x, mean, sd, eps, eps.lower, eps.upper, initial.est, k = 1L, 
       fsCor = TRUE, returnIC = FALSE, mad0 = 1e-4, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roblox_+3A_x">x</code></td>
<td>
<p> vector <code>x</code> of data values, may also be a matrix or data.frame
with one row, respectively one column/(numeric) variable. </p>
</td></tr>
<tr><td><code id="roblox_+3A_mean">mean</code></td>
<td>
<p> specified mean. </p>
</td></tr>
<tr><td><code id="roblox_+3A_sd">sd</code></td>
<td>
<p> specified standard deviation which has to be positive. </p>
</td></tr>
<tr><td><code id="roblox_+3A_eps">eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors. 
See details below. </p>
</td></tr>
<tr><td><code id="roblox_+3A_eps.lower">eps.lower</code></td>
<td>
<p> positive real (0 &lt;= <code>eps.lower</code> &lt;= <code>eps.upper</code>): 
lower bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="roblox_+3A_eps.upper">eps.upper</code></td>
<td>
<p> positive real (<code>eps.lower</code> &lt;= <code>eps.upper</code> &lt;= 0.5): 
upper bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="roblox_+3A_initial.est">initial.est</code></td>
<td>
<p> initial estimate for <code>mean</code> and/or <code>sd</code>. If missing 
median and/or MAD are used. </p>
</td></tr>
<tr><td><code id="roblox_+3A_k">k</code></td>
<td>
<p> positive integer. k-step is used to compute the optimally robust estimator. </p>
</td></tr>
<tr><td><code id="roblox_+3A_fscor">fsCor</code></td>
<td>
<p> logical: perform finite-sample correction. See function <code><a href="#topic+finiteSampleCorrection">finiteSampleCorrection</a></code>. </p>
</td></tr>
<tr><td><code id="roblox_+3A_returnic">returnIC</code></td>
<td>
<p> logical: should IC be returned. See details below. </p>
</td></tr>
<tr><td><code id="roblox_+3A_mad0">mad0</code></td>
<td>
<p> scale estimate used if computed MAD is equal to zero</p>
</td></tr>
<tr><td><code id="roblox_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the optimally robust estimator for location with scale specified,
scale with location specified, or both if neither is specified. The computation
uses a k-step construction with an appropriate initial estimate for location
or scale or location and scale, respectively. Valid candidates are e.g. 
median and/or MAD (default) as well as Kolmogorov(-Smirnov) or von Mises minimum 
distance estimators; cf. Rieder (1994) and Kohl (2005).
</p>
<p>If the amount of gross errors (contamination) is known, it can be 
specified by <code>eps</code>. The radius of the corresponding infinitesimal 
contamination neighborhood is obtained by multiplying <code>eps</code> 
by the square root of the sample size. 
</p>
<p>If the amount of gross errors (contamination) is unknown, try to find a 
rough estimate for the amount of gross errors, such that it lies 
between <code>eps.lower</code> and <code>eps.upper</code>.
</p>
<p>In case <code>eps.lower</code> is specified and <code>eps.upper</code> is missing, 
<code>eps.upper</code> is set to 0.5. In case <code>eps.upper</code> is specified and
<code>eps.lower</code> is missing, <code>eps.lower</code> is set to 0.
</p>
<p>If neither <code>eps</code> nor <code>eps.lower</code> and/or <code>eps.upper</code> is 
specified, <code>eps.lower</code> and <code>eps.upper</code> are set to 0 and 0.5, 
respectively.
</p>
<p>If <code>eps</code> is missing, the radius-minimax estimator in sense of 
Rieder et al. (2008), respectively Section 2.2 of Kohl (2005) is returned.
</p>
<p>In case of location, respectively scale one additionally has to specify
<code>sd</code>, respectively <code>mean</code> where <code>sd</code> and <code>mean</code> have
to be a single number.
</p>
<p>For sample size &lt;= 2, median and/or MAD are used for estimation.
</p>
<p>If <code>eps = 0</code>, mean and/or sd are computed. In this situation it's better
to use function <code><a href="distrMod.html#topic+MLEstimator">MLEstimator</a></code>.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>. </p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of Not Knowing the Radius.
Statistical Methods and Applications  <em>17</em>(1): 13-40. <a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>M. Kohl and H.P. Deigner (2010). Preprocessing of gene expression data by 
optimally robust estimators. BMC Bioinformatics <em>11</em>, 583.
<a href="https://doi.org/10.1186/1471-2105-11-583">doi:10.1186/1471-2105-11-583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="#topic+rlOptIC">rlOptIC</a></code>, 
<code><a href="#topic+rsOptIC">rsOptIC</a></code>, <code><a href="#topic+rlsOptIC.AL">rlsOptIC.AL</a></code>,
<code><a href="RobAStBase.html#topic+kStepEstimate-class">kStepEstimate-class</a></code>,
<code><a href="ROptEst.html#topic+roptest">roptest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ind &lt;- rbinom(100, size=1, prob=0.05) 
x &lt;- rnorm(100, mean=ind*3, sd=(1-ind) + ind*9)

## amount of gross errors known
res1 &lt;- roblox(x, eps = 0.05, returnIC = TRUE)
estimate(res1)
## don't run to reduce check time on CRAN
## Not run: 
confint(res1)
confint(res1, method = symmetricBias())
pIC(res1)
checkIC(pIC(res1))
Risks(pIC(res1))
Infos(pIC(res1))
plot(pIC(res1))
infoPlot(pIC(res1))

## End(Not run)

## amount of gross errors unknown
res2 &lt;- roblox(x, eps.lower = 0.01, eps.upper = 0.1, returnIC = TRUE)
estimate(res2)
## don't run to reduce check time on CRAN
## Not run: 
confint(res2)
confint(res2, method = symmetricBias())
pIC(res2)
checkIC(pIC(res2))
Risks(pIC(res2))
Infos(pIC(res2))
plot(pIC(res2))
infoPlot(pIC(res2))

## End(Not run)

## estimator comparison
# classical optimal (non-robust)
c(mean(x), sd(x))

# most robust
c(median(x), mad(x))

# optimally robust (amount of gross errors known)
estimate(res1)

# optimally robust (amount of gross errors unknown)
estimate(res2)

# Kolmogorov(-Smirnov) minimum distance estimator (robust)
(ks.est &lt;- MDEstimator(x, ParamFamily = NormLocationScaleFamily()))

# optimally robust (amount of gross errors known)
roblox(x, eps = 0.05, initial.est = estimate(ks.est))

# Cramer von Mises minimum distance estimator (robust)
(CvM.est &lt;- MDEstimator(x, ParamFamily = NormLocationScaleFamily(), distance = CvMDist))

# optimally robust (amount of gross errors known)
roblox(x, eps = 0.05, initial.est = estimate(CvM.est))
</code></pre>

<hr>
<h2 id='rowRoblox+20and+20colRoblox'>Optimally robust estimation for location and/or scale</h2><span id='topic+rowRoblox'></span><span id='topic+colRoblox'></span>

<h3>Description</h3>

<p>The functions <code>rowRoblox</code> and <code>colRoblox</code> compute 
optimally robust estimates for normal location und/or scale and 
(convex) contamination neighborhoods. The definition of 
these estimators can be found in Rieder (1994) or Kohl (2005),
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowRoblox(x, mean, sd, eps, eps.lower, eps.upper, initial.est, k = 1L,
          fsCor = TRUE, mad0 = 1e-4, na.rm = TRUE)
colRoblox(x, mean, sd, eps, eps.lower, eps.upper, initial.est, k = 1L,
          fsCor = TRUE, mad0 = 1e-4, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_x">x</code></td>
<td>
<p> matrix or data.frame of (numeric) data values. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_mean">mean</code></td>
<td>
<p> specified mean. See details below. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_sd">sd</code></td>
<td>
<p> specified standard deviation which has to be positive. 
See also details below. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_eps">eps</code></td>
<td>
<p> positive real (0 &lt; <code>eps</code> &lt;= 0.5): amount of gross errors. 
See details below. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_eps.lower">eps.lower</code></td>
<td>
<p> positive real (0 &lt;= <code>eps.lower</code> &lt;= <code>eps.upper</code>): 
lower bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_eps.upper">eps.upper</code></td>
<td>
<p> positive real (<code>eps.lower</code> &lt;= <code>eps.upper</code> &lt;= 0.5): 
upper bound for the amount of gross errors. See details below. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_initial.est">initial.est</code></td>
<td>
<p> initial estimate for <code>mean</code> and/or <code>sd</code>. If missing 
median and/or MAD are used. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_k">k</code></td>
<td>
<p> positive integer. k-step is used to compute the optimally robust estimator.</p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_fscor">fsCor</code></td>
<td>
<p> logical: perform finite-sample correction. See function <code><a href="#topic+finiteSampleCorrection">finiteSampleCorrection</a></code>. </p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_mad0">mad0</code></td>
<td>
<p> scale estimate used if computed MAD is equal to zero</p>
</td></tr>
<tr><td><code id="rowRoblox+2B20and+2B20colRoblox_+3A_na.rm">na.rm</code></td>
<td>
<p>logical: if  <code>TRUE</code>, the estimator is evaluated at <code>complete.cases(x)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the optimally robust estimator for location with scale specified,
scale with location specified, or both if neither is specified. The computation
uses a k-step construction with an appropriate initial estimate for location
or scale or location and scale, respectively. Valid candidates are e.g. 
median and/or MAD (default) as well as Kolmogorov(-Smirnov) or Cram\'er von 
Mises minimum distance estimators; cf. Rieder (1994) and Kohl (2005). In case 
package Biobase from Bioconductor is installed as is suggested, 
median and/or MAD are computed using function <code>rowMedians</code>.
</p>
<p>These functions are optimized for the situation where one has a matrix 
and wants to compute the optimally robust estimator for every row, 
respectively column of this matrix. In particular, the amount of cross
errors is assumed to be constant for all rows, respectively columns.
</p>
<p>If the amount of gross errors (contamination) is known, it can be 
specified by <code>eps</code>. The radius of the corresponding infinitesimal 
contamination neighborhood is obtained by multiplying <code>eps</code> 
by the square root of the sample size.
</p>
<p>If the amount of gross errors (contamination) is unknown, try to find a 
rough estimate for the amount of gross errors, such that it lies 
between <code>eps.lower</code> and <code>eps.upper</code>.
</p>
<p>In case <code>eps.lower</code> is specified and <code>eps.upper</code> is missing, 
<code>eps.upper</code> is set to 0.5. In case <code>eps.upper</code> is specified and
<code>eps.lower</code> is missing, <code>eps.lower</code> is set to 0.
</p>
<p>If neither <code>eps</code> nor <code>eps.lower</code> and/or <code>eps.upper</code> is 
specified, <code>eps.lower</code> and <code>eps.upper</code> are set to 0 and 0.5, 
respectively.
</p>
<p>If <code>eps</code> is missing, the radius-minimax estimator in sense of 
Rieder et al. (2008), respectively Section 2.2 of Kohl (2005) is returned.
</p>
<p>In case of location, respectively scale one additionally has to specify
<code>sd</code>, respectively <code>mean</code> where <code>sd</code> and <code>mean</code> can
be a single number, i.e., identical for all rows, respectively columns,
or a vector with length identical to the number of rows, respectively 
columns.
</p>
<p>For sample size &lt;= 2, median and/or MAD are used for estimation.
</p>
<p>If <code>eps = 0</code>, mean and/or sd are computed.
</p>


<h3>Value</h3>

<p>Object of class <code>"kStepEstimate"</code>. </p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of Not Knowing the Radius.
Statistical Methods and Applications  <em>17</em>(1): 13-40. <a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>M. Kohl and H.P. Deigner (2010). Preprocessing of gene expression data by 
optimally robust estimators. BMC Bioinformatics <em>11</em>, 583.
<a href="https://doi.org/10.1186/1471-2105-11-583">doi:10.1186/1471-2105-11-583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roblox">roblox</a></code>, <code><a href="RobAStBase.html#topic+kStepEstimate-class">kStepEstimate-class</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ind &lt;- rbinom(200, size=1, prob=0.05) 
X &lt;- matrix(rnorm(200, mean=ind*3, sd=(1-ind) + ind*9), nrow = 2)
rowRoblox(X)
rowRoblox(X, k = 3)
rowRoblox(X, eps = 0.05)
rowRoblox(X, eps = 0.05, k = 3)

X1 &lt;- t(X)
colRoblox(X1)
colRoblox(X1, k = 3)
colRoblox(X1, eps = 0.05)
colRoblox(X1, eps = 0.05, k = 3)

X2 &lt;- rbind(rnorm(100, mean = -2, sd = 3), rnorm(100, mean = -1, sd = 4))
rowRoblox(X2, sd = c(3, 4))
rowRoblox(X2, eps = 0.03, sd = c(3, 4))
rowRoblox(X2, sd = c(3, 4), k = 4)
rowRoblox(X2, eps = 0.03, sd = c(3, 4), k = 4)

X3 &lt;- cbind(rnorm(100, mean = -2, sd = 3), rnorm(100, mean = 1, sd = 2))
colRoblox(X3, mean = c(-2, 1))
colRoblox(X3, eps = 0.02, mean = c(-2, 1))
colRoblox(X3, mean = c(-2, 1), k = 4)
colRoblox(X3, eps = 0.02, mean = c(-2, 1), k = 4)
</code></pre>

<hr>
<h2 id='rsOptIC'>Computation of the optimally robust IC for AL estimators</h2><span id='topic+rsOptIC'></span>

<h3>Description</h3>

<p>The function <code>rsOptIC</code> computes the optimally robust IC for 
AL estimators in case of normal scale and (convex) contamination 
neighborhoods. The definition of these estimators can be found 
in Rieder (1994) or Kohl (2005), respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsOptIC(r, mean = 0, sd = 1, bUp = 1000, delta = 1e-06, itmax = 100, computeIC = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsOptIC_+3A_r">r</code></td>
<td>
<p> non-negative real: neighborhood radius. </p>
</td></tr>
<tr><td><code id="rsOptIC_+3A_mean">mean</code></td>
<td>
<p> specified mean.</p>
</td></tr>
<tr><td><code id="rsOptIC_+3A_sd">sd</code></td>
<td>
<p> specified standard deviation.</p>
</td></tr>
<tr><td><code id="rsOptIC_+3A_bup">bUp</code></td>
<td>
<p> positive real: the upper end point of the 
interval to be searched for the clipping bound b. </p>
</td></tr>
<tr><td><code id="rsOptIC_+3A_delta">delta</code></td>
<td>
<p> the desired accuracy (convergence tolerance). </p>
</td></tr>
<tr><td><code id="rsOptIC_+3A_itmax">itmax</code></td>
<td>
<p> the maximum number of iterations. </p>
</td></tr>
<tr><td><code id="rsOptIC_+3A_computeic">computeIC</code></td>
<td>
<p> logical: should IC be computed. See details below. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'computeIC' is 'FALSE' only the Lagrange multipliers 'A', 'a', and
'b' contained in the optimally robust IC are computed.
</p>


<h3>Value</h3>

<p>If 'computeIC' is 'TRUE' an object of class <code>"ContIC"</code> is returned, 
otherwise a list of Lagrange multipliers
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p> standardizing constant </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> centering constant </p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p> optimal clipping bound </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

 
<p>Rieder, H. (1994) <em>Robust Asymptotic Statistics</em>. New York: Springer.
</p>
<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="RobAStBase.html#topic+ContIC-class">ContIC-class</a></code>, <code><a href="#topic+roblox">roblox</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>IC1 &lt;- rsOptIC(r = 0.1)
distrExOptions("ErelativeTolerance" = 1e-12)
checkIC(IC1)
distrExOptions("ErelativeTolerance" = .Machine$double.eps^0.25) # default
Risks(IC1)
cent(IC1)
clip(IC1)
stand(IC1)
plot(IC1)
</code></pre>

<hr>
<h2 id='showdown'>Estimator Showdown by Monte-Carlo Study.</h2><span id='topic+showdown'></span>

<h3>Description</h3>

<p>The function <code>showdown</code> can be used to perform Monte-Carlo studies 
comparing a competitor with rmx estimators in case of normal location and scale. 
In addition, maximum likelihood (ML) estimators (mean and sd) and median and 
MAD are computed. The comparison is based on the empirical MSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showdown(n, M, eps, contD, seed = 123, estfun, estMean, estSd,
         eps.lower = 0, eps.upper = 0.05, steps = 3L, fsCor = TRUE, 
         plot1 = FALSE, plot2 = FALSE, plot3 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showdown_+3A_n">n</code></td>
<td>
<p>integer; sample size, should be at least 3.</p>
</td></tr>
<tr><td><code id="showdown_+3A_m">M</code></td>
<td>
<p>integer; Monte-Carlo replications.</p>
</td></tr>
<tr><td><code id="showdown_+3A_eps">eps</code></td>
<td>
<p>amount of contamination in [0, 0.5].</p>
</td></tr>
<tr><td><code id="showdown_+3A_contd">contD</code></td>
<td>
<p>object of class <code>"UnivariateDistribution"</code>; contaminating distribution.</p>
</td></tr>
<tr><td><code id="showdown_+3A_seed">seed</code></td>
<td>
<p>random seed.</p>
</td></tr>
<tr><td><code id="showdown_+3A_estfun">estfun</code></td>
<td>
<p>function to compute location and scale estimator; see details below.</p>
</td></tr>
<tr><td><code id="showdown_+3A_estmean">estMean</code></td>
<td>
<p>function to compute location estimator; see details below.</p>
</td></tr>
<tr><td><code id="showdown_+3A_estsd">estSd</code></td>
<td>
<p>function to compute scale estimator; see details below.</p>
</td></tr>
<tr><td><code id="showdown_+3A_eps.lower">eps.lower</code></td>
<td>
<p>used by rmx estimator.</p>
</td></tr>
<tr><td><code id="showdown_+3A_eps.upper">eps.upper</code></td>
<td>
<p>used by rmx estimator.</p>
</td></tr>
<tr><td><code id="showdown_+3A_steps">steps</code></td>
<td>
<p>integer; steps used for estimator construction.</p>
</td></tr>
<tr><td><code id="showdown_+3A_fscor">fsCor</code></td>
<td>
<p>logical; use finite-sample correction.</p>
</td></tr>
<tr><td><code id="showdown_+3A_plot1">plot1</code></td>
<td>
<p>logical; plot cdf of ideal and real distribution.</p>
</td></tr>
<tr><td><code id="showdown_+3A_plot2">plot2</code></td>
<td>
<p>logical; plot 20 (or M if M &lt; 20) randomly selected samples.</p>
</td></tr>
<tr><td><code id="showdown_+3A_plot3">plot3</code></td>
<td>
<p>logical; generate boxplots of the results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normal location and scale with mean = 0 and sd = 1 is used as ideal model (without
restriction due to equivariance).
</p>
<p>Since there is no estimator which yields reliable results if 50 percent or more of the
observations are contaminated, we use a modification where we re-simulate all samples
including at least 50 percent contaminated data.
</p>
<p>If <code>estfun</code> is specified it has to compute and return a location and scale estimate
(vector of length 2). One can also specify the location and scale estimator separately 
by using <code>estMean</code> and <code>estSd</code> where <code>estMean</code> computes and returns
the location estimate and <code>estSd</code> the scale estimate.
</p>
<p>We use funtion <code><a href="#topic+rowRoblox">rowRoblox</a></code> for the computation of the rmx estimator.
</p>


<h3>Value</h3>

<p>Data.frame including empirical MSE (standardized by sample size n) and
relMSE with respect to the rmx estimator.
</p>


<h3>Author(s)</h3>

<p>Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a></p>


<h3>References</h3>

<p>M. Kohl (2005). Numerical Contributions to the Asymptotic Theory of Robustness.
Dissertation. University of Bayreuth. <a href="https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf">https://epub.uni-bayreuth.de/id/eprint/839/2/DissMKohl.pdf</a>.
</p>
<p>H. Rieder (1994): Robust Asymptotic Statistics. Springer. <a href="https://doi.org/10.1007/978-1-4684-0624-5">doi:10.1007/978-1-4684-0624-5</a>
</p>
<p>H. Rieder, M. Kohl, and P. Ruckdeschel (2008). The Costs of Not Knowing the Radius.
Statistical Methods and Applications  <em>17</em>(1): 13-40. <a href="https://doi.org/10.1007/s10260-007-0047-7">doi:10.1007/s10260-007-0047-7</a>
</p>
<p>M. Kohl, P. Ruckdeschel, and H. Rieder (2010). Infinitesimally Robust Estimation in 
General Smoothly Parametrized Models. Statistical Methods and Applications <em>19</em>(3): 333-354.
<a href="https://doi.org/10.1007/s10260-010-0133-0">doi:10.1007/s10260-010-0133-0</a>.
</p>
<p>M. Kohl and H.P. Deigner (2010). Preprocessing of gene expression data by 
optimally robust estimators. BMC Bioinformatics <em>11</em>, 583.
<a href="https://doi.org/10.1186/1471-2105-11-583">doi:10.1186/1471-2105-11-583</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowRoblox">rowRoblox</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
## compare with Huber's Proposal 2
showdown(n = 20, M = 100, eps = 0.02, contD = Norm(mean = 3, sd = 3), 
         estfun = function(x){ unlist(hubers(x)) },
         plot1 = TRUE, plot2 = TRUE, plot3 = TRUE)

## compare with Huber M estimator with MAD scale
showdown(n = 20, M = 100, eps = 0.02, contD = Norm(mean = 3, sd = 3), 
         estfun = function(x){ unlist(huber(x)) },
         plot1 = TRUE, plot2 = TRUE, plot3 = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
