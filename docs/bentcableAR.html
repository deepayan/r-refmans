<!DOCTYPE html><html><head><title>Help for package bentcableAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bentcableAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bentcableAR'><p> The Bent-Cable Regression Package</p></a></li>
<li><a href='#bentcable.ar'><p> Bent-Cable Regression for Independent and Autoregressive Data</p></a></li>
<li><a href='#bentcableAR-internal'><p>Internal 'bentcableAR' Functions</p></a></li>
<li><a href='#cable.ar.p.diag'><p> Bent-Cable AR(p&gt;0) Diagnostics</p></a></li>
<li><a href='#cable.ar.p.iter'><p> Bent-Cable Regression for Independent or AR Data, With Exception</p></a></li>
<li><a href='#cable.ar.p.plot'><p> Plot Bent Cable AR(p) Fit Over Data</p></a></li>
<li><a href='#cable.ar.p.resid'><p> Fitted Residuals and Innovations for AR(p&gt;0) Bent Cable</p></a></li>
<li><a href='#cable.change.conf'><p> Confidence Interval for CTP of AR(p) Bent Cable</p></a></li>
<li><a href='#cable.fit.known.change'><p> Grid-based Bent-Cable Regression for Independent or AR Data</p></a></li>
<li><a href='#cable.lines'><p> Overlay Bent Cable On Existing Plot</p></a></li>
<li><a href='#fullcable.t'><p> Evaluate Bent Cable Function</p></a></li>
<li><a href='#is.stationary'><p> Stationarity Check of AR Time Series</p></a></li>
<li><a href='#sockeye'><p>Rivers Inlet Sockeye Abundance</p></a></li>
<li><a href='#stagnant'><p> Stagnant Band Height Data</p></a></li>
<li><a href='#stick.ar.0'><p> Broken-Stick Regression for Independent Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bent-Cable Regression for Independent Data or Autoregressive
Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-27</td>
</tr>
<tr>
<td>Author:</td>
<td>
	Grace Chiu &lt;bentcable@gmail.com&gt;,
	Virginia Institute of Marine Science, William &amp; Mary
	PO Box 1346, Gloucester Point, VA 23062, USA</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Grace Chiu &lt;bentcable@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
	Included are two main interfaces, bentcable.ar() and
	bentcable.dev.plot(), for fitting and diagnosing bent-cable
	regressions for autoregressive time-series data (Chiu and
	Lockhart 2010, &lt;<a href="https://doi.org/10.1002%2Fcjs.10070">doi:10.1002/cjs.10070</a>&gt;) or independent data (time
	series or otherwise - Chiu, Lockhart and Routledge 2006,
	&lt;<a href="https://doi.org/10.1198%2F016214505000001177">doi:10.1198/016214505000001177</a>&gt;). Some components in the package
	can also be used as stand-alone functions. The bent cable
	(linear-quadratic-linear) generalizes the broken stick
	(linear-linear), which is also handled by this package. Version
	0.2 corrected a glitch in the computation of confidence intervals
	for the CTP. References that were updated from Versions 0.2.1 and
	0.2.2 appear in Version 0.2.3 and up. Version 0.3.0 improved
	robustness of the error-message producing mechanism. Version 0.3.1
	improves the NAMESPACE file of the package. It is the author's
	intention to distribute any future updates via GitHub.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-28 02:13:33 UTC; gschiu</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-28 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bentcableAR'> The Bent-Cable Regression Package </h2><span id='topic+bentcableAR'></span><span id='topic+bentcable'></span><span id='topic+bentcableAR-package'></span>

<h3>Description</h3>

<p>Perform bent-cable (including broken-stick) regression to independent
data or autoregressive time series.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bentcableAR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-05-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=3)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>There are two main interfaces in this package:
<code><a href="#topic+bentcable.dev.plot">bentcable.dev.plot</a></code> for plotting profile deviance
surfaces, and <code><a href="#topic+bentcable.ar">bentcable.ar</a></code> for fitting and diagnosing 
the regression. In some cases, confidence intervals for the
<em>change point</em> are also computed..
</p>
<p>Detailed documentation and examples are available on the function help
pages.
</p>
<p>The major engines for <code>bentcable.dev.plot</code> are
<code><a href="#topic+cable.dev">cable.dev</a></code> and <code><a href="#topic+cable.fit.known.change">cable.fit.known.change</a></code>.
The computational engines for <code>bentcable.ar</code> are
<code><a href="#topic+cable.ar.p.iter">cable.ar.p.iter</a></code>, <code><a href="#topic+cable.ar.0.fit">cable.ar.0.fit</a></code>,
<code><a href="#topic+stick.ar.0">stick.ar.0</a></code>, and <code><a href="#topic+cable.change.conf">cable.change.conf</a></code>,
while the plotting engine is <code><a href="#topic+cable.ar.p.diag">cable.ar.p.diag</a></code>.
Although these and other <em>lesser</em> functions are called
internally by the two main interfaces described above, they can be
used as stand-alone functions, and the user is advised to
refer to their documentation. Type
<code>library(help="bentcableAR")</code> for a full list of available
functions.
</p>
<p><b>Disclaimer:</b>
The package functions and examples (including those provided as &quot;not
run&quot;) up to V0.2.x were thoroughly tested in <span class="rlang"><b>R</b></span> 2.6.2 installed on the
author's two Mac machines running OS X. Results are known to vary
depending on machine and platform. It is the author's intention to
distribute any future updates via GitHub.
</p>


<h3>Author(s)</h3>

<p>Grace Chiu &lt;bentcable@gmail.com&gt;
</p>
<p>Maintainer: Grace Chiu &lt;bentcable@gmail.com&gt;
</p>


<h3>References</h3>

<p>Chiu, G.S. and Lockhart, R.A. (2010), Bent-Cable Regression with
Autoregressive Noise, <em>Canadian Journal of Statistics</em>,
<b>38</b>, 386&ndash;407. DOI: 10.1002/cjs.10070. URL:  
<a href="https://www.researchgate.net/publication/227652258_Bent-cable_regression_with_autoregressive_noise">https://www.researchgate.net/publication/227652258_Bent-cable_regression_with_autoregressive_noise</a>
</p>
<p>Chiu, G., Lockhart, R. and Routledge, R. (2006), Bent-Cable Regression
Theory and Applications, <em>Journal of the American Statistical
Association</em>, <b>101</b>, 542&ndash;553. DOI: 10.1198/016214505000001177. URL:  
<a href="https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications">https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications</a>
</p>

<hr>
<h2 id='bentcable.ar'> Bent-Cable Regression for Independent and Autoregressive Data </h2><span id='topic+bentcable.ar'></span><span id='topic+bentcable.dev.plot'></span>

<h3>Description</h3>

<p>These two functions are the main interfaces in the
<code>bentcableAR</code> package. They perform bent-cable (including
broken-stick) regression to AR(p) time-series data or independent
data (time-series or otherwise) and produce diagnostic plots.
Confidence intervals for the <em>critical time point</em> (CTP) are
included in some cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bentcable.ar(y.vect, tgdev = NULL, p = 0, stick = FALSE, t.vect = NULL,
	init.cable = NULL, init.phi = NULL, tol = 1e-04,
	method0 = "css", method1 = "yw", ci.level = 0.95,
	main = NULL)
bentcable.dev.plot(tau.vect, gamma.vect = NULL, y.vect, t.vect = NULL,
	stick = FALSE, p = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bentcable.ar_+3A_y.vect">y.vect</code></td>
<td>
<p> A numeric vector of response data. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_t.vect">t.vect</code></td>
<td>
<p> A numeric vector of design points, which <b>MUST</b>
be equidistant with unit increments if p&gt;0 is assumed. They need
not be equidistant for independent data. Specifying
<code>t.vect=NULL</code> is equivalent to specifying the default time
points <code>c(0,1,2,...)</code>. Also see <b>Warnings</b> below. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_tau.vect">tau.vect</code>, <code id="bentcable.ar_+3A_gamma.vect">gamma.vect</code></td>
<td>
<p> Numeric vectors specifying a
<code class="reqn">(\tau,\gamma)</code>-grid over which the bent-cable profile
deviance surface / function is to be evaluated. If
<code>stick=TRUE</code>, then <code>gamma.vect</code> is overwritten by
<code>c(0)</code> in <code>bentcable.dev.plot</code>. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_tgdev">tgdev</code></td>
<td>
<p> A <code>bentcable.dev.plot</code> object. An error results
if this is supplied together with <code>init.cable</code> or
<code>init.phi</code>. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_p">p</code></td>
<td>
<p> The autoregressive order (non-negative integer).
<code>p=0</code> specifies independent data that may or may not be
from a time series context. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_stick">stick</code></td>
<td>
<p> A logical value; if <code>TRUE</code> then a broken stick
(i.e. bent cable with <code class="reqn">\gamma</code>=0.) is fitted. Also see
<code>gamma.vect</code> above. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_init.cable">init.cable</code></td>
<td>
<p> A numeric vector of initial values for the
bent-cable parameters. If <code>stick=FALSE</code>, then <code>init.cable</code>
should have the form <code>c(b0,b1,b2,tau,gamma,...)</code>. If
<code>stick=TRUE</code>, then <code>init.cable</code> should have the form
<code>c(b0,b1,b2,tau,...)</code>. In either case, <code>...</code>
will be ignored. An error results if this is supplied together
with <code>tgdev</code>. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_init.phi">init.phi</code></td>
<td>
<p> A numeric vector of initial values for the AR
coefficients. If not provided, then a default value is assigned,
consisting of the first <code>p</code> elements of the vector
<code>c(0.5,-0.5,0.5,-0.5,...)</code>. When provided and its
dimension does not match <code>p</code>, then the function determines
which to reject depending on the situation, and reports its
decision in the screen output. An error results if this is
supplied together with <code>tgdev</code>. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_tol">tol</code></td>
<td>
<p> Tolerance for determining convergence. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_method0">method0</code>, <code id="bentcable.ar_+3A_method1">method1</code></td>
<td>
<p> The fitting method when p&gt;0. <code>"css"</code>
stands for <em>conditional sum-of-squares</em> and corresponds to
conditional maximum likelihood. <code>"yw"</code> stands for
<em>Yule-Walker</em>, and <code>"mle"</code> for (full) <em>maximum
likelihood estimation</em>. If <code>method0</code> fails to converge,
then <code>method1</code> is attempted. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_ci.level">ci.level</code></td>
<td>
<p> A numeric value between 0 and 1, exclusive. Used to
compute the CTP confidence interval when <code>p</code> is
greater than 0. See <code>cable.change.conf</code> and
<b>Warnings</b> below. </p>
</td></tr>
<tr><td><code id="bentcable.ar_+3A_main">main</code></td>
<td>
<p> A title for the set of diagnostic plots. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bentcable.dev.plot</code> involves bent-cable regression assuming a
known transition. It plots a profile deviance surface over a fixed
grid (see <b>References</b>). It also returns the grid and the
profile deviance surface matrix, which can be used to generate
initial values for an overall bent-cable regression (no known
parameters).
</p>
<p><code>bentcable.ar</code> is used mainly for overall bent-cable
regression, with one exception. Different scenarios
determine the behaviour of <code>bentcable.ar</code>, as follows.
</p>
<p><b>(1) Independent data and <code>tgdev</code> is supplied.</b> In this case,
<code>bentcable.ar</code> calls <code>cable.ar.0.fit</code> which identifies
the best grid-based fit from <code>tgdev</code>, then feeds it through an
internal engine <code>cable.ar.p.iter</code> or <code>stick.ar.0</code> that
performs overall bent-cable regression. This best fit is returned
but not plotted, and the autocorrelation is diagnosed (even for
non-time-series data) by a PACF plot and a suggested value of p
based on the AIC (see <code>ar</code>). As stated in the screen
output, these diagnostics should be used only for time-series data,
where the returned best AR(0) estimates are intended to be supplied
as <code>init.cable</code> in a subsequent call of <code>bentcable.ar</code>
for an AR(p&gt;0) fit. To produce a plot of the returned
best AR(0) fit and/or the corresponding CTP confidence interval,
the user can supply the returned parameter estimates as
<code>init.cable</code> in another call of <code>bentcable.ar</code> with
<code>p=0</code> (see Scenario (3)).
</p>
<p><b>(2) AR(p&gt;0) data and <code>tgdev</code> is supplied.</b> In this case, no
graphics are produced; <code>bentcable.ar</code> simply locates the
highest point on the grid-based profile deviance surface and
returns the corresponding (crude) parameter estimates to be used as
<code>init.cable</code> and <code>init.phi</code> in subsequent overall
bent-cable fits. If multiple peaks exist (such as along a ridge),
then only that at the smallest <code class="reqn">\tau</code> and smallest <code class="reqn">\gamma</code>
is used.
</p>
<p><b>(3) Independent data (time series or otherwise) and
<code>init.cable</code> are supplied.</b> In this case, <code>bentcable.ar</code>
performs overall bent-cable regression and produces a
scatterplot of the data superimposed with the best fit and
estimated transition. For time series data where the CTP is
applicable (see <b>Warnings</b>), the CTP confidence interval is
additionally computed and superimposed in blue. No other plots are
produced. Since <code>init.cable</code> is supposed to have come from a
reasonable source (such as grid-based), this fit is not intended to
be fed to another round of <code>bentcable.ar</code>, except when the
user wishes to explore using a positive p (but this should be
performed in conjunction with another round of grid-based approach
in Scenario (2)).
</p>
<p><b>(4) AR(p&gt;0) data and <code>init.cable</code> are supplied.</b> In this
case, <code>bentcacble.ar</code> computes the overall bent-cable fit and
CTP confidence interval (see <code>cable.change.conf</code>). Also
included are the following diagnostics: a scatterplot of the data
superimposed with the best fit and estimated transition
<code class="reqn">(\tau-\gamma,\tau,\tau+\gamma)</code> (in red) and the CTP
confidence interval (in blue, if it exists - see <b>Warnings</b>),
and ACF and PACF plots for the fitted residuals and innovations
(see <code><a href="#topic+cable.ar.p.resid">cable.ar.p.resid</a></code> for their difference). Since
<code>init.cable</code> is supposed to have come from a reasonable
source (such as grid-based), this fit is not intended to be fed
to another round of <code>bentcable.ar</code>, except when the user
wishes to explore using an alternative p (but this should be
performed in conjunction with another round of grid-based approach
in Scenario (1) or (2)), or when the <code>"css"</code> algorithm fails
to converge but the SSE value is desired (see <b>Details</b>).
</p>
<p>Below is a summary of the bent-cable regression methodology, and
how one may apply it by using the <code>bentcableAR</code> package. 
</p>
<p>The <em>bent cable</em> is a linear-quadratic-linear function, where
the quadratic bend is regarded as the transition from the incoming
linear phase to the outgoing linear phase. A bent cable has the form
<code class="reqn">f(t) = b_0 + b_1 t + b_2 q(t)</code>, where <code class="reqn">q(t)</code> is the
<em>basic bent cable</em> with incoming slope 0 and outgoing slope 1,
and a quadratic bend that is centred at <code class="reqn">\tau</code> with half-width
<code class="reqn">\gamma\ge 0</code>:
</p>
<p style="text-align: center;"><code class="reqn">q(t)=\frac{(t-\tau+\gamma)^2}{4\gamma} I\{|t-\tau|\le\gamma\}
	+ (t-\tau) I\{t&gt;\tau+\gamma\}.</code>
</p>

<p>The <em>broken stick</em> is a special bent cable with no quadratic
bend (i.e. <code class="reqn">\gamma</code>=0). The term <em>bent-cable regression</em>
implicitly includes <em>broken-stick regression</em>.
</p>
<p>For independent data (time series or otherwise), bent-cable
regression by maximum likelihood is performed via nonlinear
least-squares estimation of <code class="reqn">\theta=(b_0,b_1,b_2,\tau,\gamma)</code>.
For AR(p) data, the AR coefficients are
<code class="reqn">\phi=(\phi_1,\phi_2,\ldots,\phi_p)</code>, and conditional maximum
likelihood (CML) estimation of <code class="reqn">(\theta,\phi)</code> (conditioned on
the first p data points) is performed by nonlinear conditional
least squares (i.e. minimizing the conditional sum-of-squares error
(SSE)). In this time-series context, time points are assumed to be
equidistant with unit increments.
</p>
<p>Minimization of the (conditional) SSE is specified as <code>"css"</code>
by default for <code>method0</code>. However, <code>"css"</code> sometimes
fails to converge, or the resulting <code class="reqn">\phi</code> estimate sometimes
corresponds to non-stationarity.  In this case, the alternative
estimation approach specified for <code>method1</code> is attempted.
<code>"mle"</code> specifies the <em>CML-ML hybrid</em> algorithm, and
<code>"yw"</code> the <em>CML-ML-MM hybrid</em> algorithm (<em>MM</em> stands
for <em>method of moments</em>; see <b>References</b>.) Both
<code>"yw"</code> and <code>"mle"</code> guarantee stationarity, but often take
much longer than <code>"css"</code> to converge.
</p>
<p>Due to nonlinearity, initial values must be supplied for proper
parameter estimation. Also, bent-cable regression is a notoriously
irregular estimation problem (due to low-order differentiability),
and the estimation algorithms (mainly the built-in <span class="rlang"><b>R</b></span>
functions <code>nls</code> and <code>optim</code>) may fail to converge from
initial values that are unrefined guesses of the parameters. When
this happens, the user is advised to generate an initial value from
a grid-based procedure.
</p>
<p>The grid-based procedure involves specifying a
<code class="reqn">(\tau,\gamma)</code>-grid over which the bent-cable profile deviance
surface is evaluated and plotted, such as by
<code>bentcable.dev.plot</code>. At each grid
point, the transition is fixed, and bent-cable regression involves
only linear parameters <code class="reqn">b_0, b_1, b_2</code> and AR coefficients
<code class="reqn">\phi</code>, all of which can be estimated using standard
time-series algorithms (mainly the built-in <span class="rlang"><b>R</b></span> functions <code>ar</code>
and <code>arima</code>). Regression at each grid point yields a point on
the profile deviance surface. The grid point at which the profile
deviance is maximum corresponds to a bent-cable fit (given a known
transition) that is best among the specified grid points. Thus, for
a high-resolution grid, this <em>best grid point</em> together with
the corresponding estimates of <code class="reqn">b_0, b_1, b_2</code> and <code class="reqn">\phi</code>
may be regarded as the ML or CML estimate for the model. However,
high-resolution grid-based estimation may be computationally
infeasible. Instead, the <em>best grid point</em> on a coarser grid
can give good initial values for the true ML or CML estimate that
is trapped between grid points.
</p>
<p>However, the <em>true</em> ML or CML estimate may not easily come by
even with good initial values. Irregularity of bent-cable
regression often manifests itself in the form of multiple peaks on
the deviance surface. Thus, the user should be aware of different
local maxima on which the optimization algorithm can converge
despite initial values for <code class="reqn">\theta</code> that are very similar. The
user is advised to combine several exploratory analyses as well as
model diagnoses before settling on a <em>best</em> fit.
</p>
<p>For example, one may first fix p=0 as the AR order, then use
<code>bentcable.dev.plot</code> to conduct a visual inspection of the
profile deviance surface over a fine <code class="reqn">(\tau,\gamma)</code>-grid. This
is to identify the neighbourhood of the global maximum for p=0. If
necessary, one can <em>zoom in</em> to this neighbourhood by placing
over it an even finer grid to hone the grid-based approximation.
The resulting <code>bentcable.dev.plot</code> object can then be fed to
<code>bentcable.ar</code> to produce a best overall fit for the AR(0)
assumption in that neighbourhood. If p=0 is deemed inadequate based
on the <code>bentcable.ar</code> diagnostics, then the regression must
now be repeated for a newly chosen p. Since the bent-cable
parameter estimates will differ for different values of p, the
earlier AR(0) estimates may or may not be good initial values for
this new AR(p) fit. The user is advised to try several additional
initial values, possibly repeating the grid-based procedure, but
this time using the new p. To further screen out local maxima, the
SSE values for these AR(p) fits (with common p) should be compared.
For a <code>"css"</code> fit, the SSE is stored in
<code>$cable$ar.p.fit$value</code> of the returned object. The SSE is not
directly retrievable for a <code>"yw"</code> or <code>"mle"</code> fit, but the
user can apply the estimates returned in <code>$cable$est</code> as the initial
values to a subsequent <code>"yw"</code> fit, and the SSE will appear in
the screen output as <em>initial value</em> while the <code>"css"</code>
algorithm iterates.
</p>
<p>As with any numerical optimization procedure, there is no guarantee
that the fit observed to have the smallest SSE value indeed
corresponds to the global maximum.
</p>


<h3>Value</h3>

<table>
<tr><td><code>cable</code></td>
<td>
<p> An object that is compatible with a
<code><a href="#topic+cable.ar.p.iter">cable.ar.p.iter</a></code> object. Returned by <code>bentcable.ar</code>
in Scenarios (3) and (4). Note the different components of
<code>cable</code> depending on the scenario. See
<code>cable.ar.p.iter</code> and <code><a href="#topic+stick.ar.0">stick.ar.0</a></code>. </p>
</td></tr>
<tr><td><code>ctp</code></td>
<td>
<p> A <code><a href="#topic+cable.change.conf">cable.change.conf</a></code> object, if the CTP is
successfully estimated; returned by <code>bentcable.ar</code> in
Scenarios (3) and (4). This object has three components: the CTP
estimate, its estimated asymptotic variance, and the
corresponding Wald confidence interval. </p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p> Returned by <code>bentcable.ar</code> in Scenarios (1) and (2).
In (1), the returned <code>bentcable.ar</code> object is a
<code><a href="#topic+cable.ar.0.fit">cable.ar.0.fit</a></code> object (largely compatible with
<code>cable.ar.p.iter</code> objects); thus, <code>fit</code> is an
<code>nls</code> object containing the overall independent-data
bent-cable fit. In (2), the returned <code>bentcable.ar</code> object is a
<code><a href="#topic+cable.fit.known.change">cable.fit.known.change</a></code> object; thus, <code>fit</code>
is an <code>arima</code> object containing the AR(p&gt;0) bent-cable fit
at the known transition grid point. In either scenario,
<code>fit</code> is intended to be fed through another round of
<code>bentcable.ar</code> for subsequent overall AR(p&gt;0) fits. </p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p> Returned by <code>bentcable.ar</code> in Scenario (2). It is
the vector of parameter estimates extracted from <code>fit</code> and
intended to be used as initial values in subsequent calls to
<code>bentcable.ar</code> for overall bent-cable regression. </p>
</td></tr>
<tr><td><code>y</code>, <code>t</code>, <code>n</code>, <code>p</code>, <code>stick</code></td>
<td>
<p> Returned by <code>bentcable.ar</code>
explicitly in Scenario (1) (but embedded in <code>cable</code> of
Scenarios (3) and (4)). They are <code>y.vect</code>, <code>t.vect</code>,
<code>n</code>, <code>p</code>, and <code>stick</code> as supplied by the user. </p>
</td></tr>
<tr><td><code>dev</code>, <code>tau</code>, <code>gamma</code></td>
<td>
<p> Returned by <code>bentcable.dev.plot</code>. Note
that <code>dev</code> is a <code>cable.dev</code> object, i.e. a matrix of
profile deviance values evaluated at the grid specified by
<code>tau</code> and <code>gamma</code>. </p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>For time-series data, <code>t.vect</code> <em>MUST</em> be 
equidistant with unit increments; otherwise, these 
functions will return meaningless values. (For 
independent data, <code>t.vect</code> can be non-equidistant.)   
</p>
<p>Computations for the CTP estimate and confidence interval are based on a time
vector of the form <code>c(0,1,2,...)</code>. For any other form for the time
vector, the CTP will not be computed, and on-screen warnings
will appear. To ensure compatibility between the model fit and CTP
estimates, the user is advised to fit the model using the default
time vector. Then, if necessary, the user may transform the results
to the preferred time scale after the model and CTP estimates have
been produced.
</p>
<p>The above computational issue implies that the CTP cannot
be computed for non-time-series data. <b>Rationale</b>:
In a non-time-series context design points are often
non-equidistant, and the cable's slope often never changes sign;
even with a sign change, the point at which this takes place may be
less interpretable. In such a context, the user is advised to rely
on confidence regions for <code class="reqn">(\tau,\gamma)</code> (see
<b>References</b>).
</p>


<h3>Note</h3>

<p>The major engines for <code>bentcable.dev.plot</code> are
<code><a href="#topic+cable.dev">cable.dev</a></code> and <code><a href="#topic+cable.fit.known.change">cable.fit.known.change</a></code>.
The computational engines for <code>bentcable.ar</code> are
<code><a href="#topic+cable.ar.p.iter">cable.ar.p.iter</a></code>, <code><a href="#topic+cable.ar.0.fit">cable.ar.0.fit</a></code>,
<code><a href="#topic+stick.ar.0">stick.ar.0</a></code>, and <code><a href="#topic+cable.change.conf">cable.change.conf</a></code>,
while the plotting engine is <code><a href="#topic+cable.ar.p.diag">cable.ar.p.diag</a></code>.
Although these and other <em>lesser</em> functions are called
internally by the two main interfaces described here, they can be
used as stand-alone functions, and the user is advised to
refer to their documentation. Type
<code>library(help="bentcableAR")</code> for a full list of available
functions.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p>Chiu, G.S. and Lockhart, R.A. (2010), Bent-Cable Regression with
Autoregressive Noise, <em>Canadian Journal of Statistics</em>,
<b>38</b>, 386&ndash;407. DOI: 10.1002/cjs.10070. URL:  
<a href="https://www.researchgate.net/publication/227652258_Bent-cable_regression_with_autoregressive_noise">https://www.researchgate.net/publication/227652258_Bent-cable_regression_with_autoregressive_noise</a>
</p>
<p>Chiu, G., Lockhart, R. and Routledge, R. (2006), Bent-Cable Regression
Theory and Applications, <em>Journal of the American Statistical
Association</em>, <b>101</b>, 542&ndash;553. DOI: 10.1198/016214505000001177. URL:  
<a href="https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications">https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications</a>
</p>


<h3>See Also</h3>

 	<p><code><a href="#topic+cable.lines">cable.lines</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+ar">ar</a></code>, <code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# Scenario (1)
##############

# independent non-time-series cable:

data(stagnant)

bentcable.dev.plot( seq(-1,1,length=20),
	seq(.1,1,length=20), stagnant$loght, stagnant$logflow )

	# zoom in to global max
	dev0 &lt;- bentcable.dev.plot( seq(-.04,.16,length=20), 
		seq(.2,.65,length=20), stagnant$loght, stagnant$logflow )
			# locally smooth deviance surface

	cable &lt;- bentcable.ar( stagnant$loght, tgdev=dev0, t.vect=stagnant$logflow )
		# ignore time-series diagnostics
		# local regularity - expect to be true best fit
		# SSE=0.005
		# feed 'cable' in Scenario (3) to get fitted plot:
		#	bentcable.ar( cable$y, init.cable=coef(cable$fit),
		#		t.vect=cable$t )


# AR(0) stick, start time at 80:
dev0 &lt;- bentcable.dev.plot( seq(85,97,length=15), 0,
	sockeye$logReturns, sockeye$year, TRUE )  # obvious global max
stick0 &lt;- bentcable.ar( sockeye$logReturns, tgdev=dev0, stick=TRUE,
	t.vect=sockeye$year )
		# local regularity - should be true best fit
		# SSE=8.85
		# diagnostics: take p=0 to 4 ??

# AR(0) cable, start at time 0:
bentcable.dev.plot( seq(1,20,length=25), 
	seq(.1,15,length=25), sockeye$logReturns )

	# zoom in to global max
	dev0 &lt;- bentcable.dev.plot( seq(10,15,length=25),
		seq(2,10,length=20), sockeye$logReturns )
			# surface has ridge - expect some trouble locating true peak

	cable0 &lt;- bentcable.ar( sockeye$logReturns, tgdev=dev0 )
		# apparent best AR(0) fit: SSE=8.68
		# diagnostics: take p=2 to 6

		# compare to this:
		# dev1 &lt;- bentcable.dev.plot( seq(10,15,length=25),
		#	seq(2,10,length=15), sockeye$logReturns )
		# bentcable.ar( sockeye$logReturns, tgdev=dev1 ) # SSE=8.683
		#	# not an obvious local max!

		# feed 'cable0' in Scenario (3) to get fitted plot:
		#	bentcable.ar( cable0$y, init.cable=coef(cable0$fit) )


## End(Not run)




# Scenario (2)
##############

data(sockeye)

# AR(2) cable, start time at 0:
bentcable.dev.plot( seq(6,18,length=15),
	seq(.01,12,length=15), sockeye$logReturns, p=2 )

	# zoom in to global max
	dev2 &lt;- bentcable.dev.plot( seq(10,12,length=15),
		seq(1,5,length=15), sockeye$logReturns, p=2 )

	# best grid-based fit
	gr.cable2 &lt;- bentcable.ar( sockeye$logReturns, tgdev=dev2, p=2 )
		# to be used in Scenario (4)
		# local regularity - expect little trouble

# AR(2) stick, start time at 80:
bentcable.dev.plot( seq(86,98,length=15), y.vect=sockeye$logReturns, 
	p=2, stick=TRUE, t.vect=sockeye$year )

	# zoom in to global max
	dev3 &lt;- bentcable.dev.plot( seq(88.5,93,length=25),
		y.vect=sockeye$logReturns, 
		p=2, stick=TRUE, t.vect=sockeye$year )
			# camel hump - double peaks!

	# best grid-based fit
	gr.stick2 &lt;- bentcable.ar( sockeye$logReturns, tgdev=dev3, p=2, stick=TRUE,
		t.vect=sockeye$year )
			# irregularity - expect some trouble if used in Scenario (4)



## Not run: 

# AR(4) cable, start time at 0:
bentcable.dev.plot( seq(6,18,length=15), seq(.01,12,length=15), 
	sockeye$logReturns, p=4 )

	# zoom in to global max
	dev4 &lt;- bentcable.dev.plot( seq(10,12,length=15),
		seq(1,7,length=25), sockeye$logReturns, p=4 )
			# slight ridge

	# best grid-based fit
	gr.cable4 &lt;- bentcable.ar( sockeye$logReturns, tgdev=dev4, p=4 )
		# to be used in Scenario (4)
		# will ridge be problem???




# Scenario (3)
##############

# independent non-time-series cable:

data(stagnant)

bentcable.ar( stagnant$loght, t.vect=stagnant$logflow,
	init.cable=c(.6,-.4,-.7,0,.5) )   # SSE=0.005
		# identical to 'cable' in Scenario (1)
		# no irregularity, no ambiguity!



# AR(0) stick, start time at 80:
bentcable.ar( sockeye$logReturns, init.cable=c(10,.1,-.5,90),
	stick=TRUE, t.vect=sockeye$year )
		# identical to 'stick0' in Scenario (1)
		# local regularity, no trouble


# AR(0) stick, start time at 0:
bentcable.ar( sockeye$logReturns, init.cable=coef(cable0$fit)[1:5],
	stick=TRUE )
		# identical to 'cable0' in Scenario (1)
		# here you get plot of fit and CTP confidence interval


## End(Not run)




# Scenario (4)
##############

# AR(2) cable, start time at 0:
# use 'gr.cable2' from Scenario (2)
cable2 &lt;- bentcable.ar( sockeye$logReturns,
	init.cable=gr.cable2$init[1:5], init.phi=gr.cable2$init[-c(1:5)] )
		# "css" successful
		# best AR(2) fit, SSE=4.868
	
	# compare to this:
	# bentcable.ar( sockeye$logReturns,
	#	init.cable=c(13,.1,-.5,11,4), p=2 )
			# "css" successful, same SSE, virtually same fit
			# recall local regularity from 'dev2'

# AR(2) stick, start time at 80:
# use 'gr.stick2' from Scenario (2)
stick2 &lt;- bentcable.ar( sockeye$logReturns, init.cable=gr.stick2$init[1:4],
		init.phi=gr.stick2$init[-c(1:4)], stick=TRUE, t.vect=sockeye$year )
			# "css" successful, best AR(2) fit, SSE=5.0

			# compare this to the other peak shown in 'dev3'
			#	bentcable.ar( sockeye$logReturns,
			#	init.cable=c(10,0,-.5,91.5), p=2, stick=TRUE,
			#		t.vect=sockeye$year )
						# "css" successful, SSE=5.1, not best fit!


## Not run: 

# AR(4) cable, start time at 0:
cable4 &lt;- bentcable.ar( sockeye$logReturns,
	init.cable=gr.cable4$init[1:5], init.phi=gr.cable4$init[-c(1:5)] )
		# "css" unsuccessful, switched to "yw"
		# feed 'cable4' in Scenario (4) to get SSE from screen output:

		bentcable.ar( cable4$cable$y, init.cable=cable4$cable$est[1:5],
			init.phi=cable4$cable$est[-c(1:5)] )
				# SSE=2.47 from screen output

## End(Not run)
</code></pre>

<hr>
<h2 id='bentcableAR-internal'>Internal 'bentcableAR' Functions</h2><span id='topic+alph.vect'></span><span id='topic+alpha'></span><span id='topic+ar.p.resid.core'></span><span id='topic+basic.cable'></span><span id='topic+cable.Sig.ar.p'></span><span id='topic+cable.design.mat'></span><span id='topic+cable.diagnose.resid'></span><span id='topic+cable.loop'></span><span id='topic+cable.loop.ar.p'></span><span id='topic+find.fisher'></span><span id='topic+grad'></span><span id='topic+loglik.given.g'></span><span id='topic+loglik.given.g.ar.p'></span><span id='topic+loglik.surf'></span><span id='topic+loglik.surf.ar.p'></span><span id='topic+pick.peak'></span><span id='topic+sse.ar.p'></span><span id='topic+sse.ar.p.core'></span><span id='topic+sse.ar.p.given.beta.phi'></span><span id='topic+sse.ar.p.given.g'></span><span id='topic+sse.ar.p.given.t.g'></span>

<h3>Description</h3>

<p>Internal functions for the <code>bentcableAR</code> package.
</p>


<h3>Details</h3>

<p>These are not intended to be called by the user.
</p>

<hr>
<h2 id='cable.ar.p.diag'> Bent-Cable AR(p&gt;0) Diagnostics </h2><span id='topic+cable.ar.p.diag'></span>

<h3>Description</h3>

<p>ACF, PACF, and other plots are produced for diagnosing an AR(p)
bent-cable fit when p&gt;0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.ar.p.diag(ar.p.fit, resid.type = "p", xlab = "time", ylab = "",
	main = NULL, main.all = NULL, ctp.ci = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.ar.p.diag_+3A_ar.p.fit">ar.p.fit</code></td>
<td>
<p> A <code>cable.ar.p.iter</code> object for AR(p) data, p&gt;0. </p>
</td></tr>
<tr><td><code id="cable.ar.p.diag_+3A_resid.type">resid.type</code></td>
<td>
<p> A <code>type</code> argument for the <code>plot</code>
function; used to control the way fitted residuals and
innovations are displayed. Default is <code>"p"</code> for
<em>points</em>. </p>
</td></tr>
<tr><td><code id="cable.ar.p.diag_+3A_xlab">xlab</code></td>
<td>
<p> Character string: x-axis label. </p>
</td></tr>
<tr><td><code id="cable.ar.p.diag_+3A_ylab">ylab</code></td>
<td>
<p> Character string: y-axis label. </p>
</td></tr>
<tr><td><code id="cable.ar.p.diag_+3A_main">main</code></td>
<td>
<p> Character string: title for the time series plot. </p>
</td></tr>
<tr><td><code id="cable.ar.p.diag_+3A_main.all">main.all</code></td>
<td>
<p> Character string: title for the entire set of
plots. </p>
</td></tr>
<tr><td><code id="cable.ar.p.diag_+3A_ctp.ci">ctp.ci</code></td>
<td>
<p> A <code>cable.change.conf</code> object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function splits the plotting canvas into several panels. For
one panel, <code>ar.p.fit</code> is fed to <code>cable.ar.p.plot</code> that
produces a scatterplot of the data and overlays on it the fitted
bent cable with the estimated transition. The optioinal
<code>ctp.ci</code> is also fed to <code>cable.ar.p.plot</code> to add the
CTP confidence interval to the same panel. Additionally,
<code>ar.p.fit</code> is fed to <code>cable.ar.p.resid</code> to extract the
fitted residuals and innovations, which are then plotted in
separate panels that again show the estimated transition and
confidence interval. Finally, four panels show ACF and PACF
diagnostics for the fitted residuals and innovations, via the
built-in <span class="rlang"><b>R</b></span> functions <code>acf</code> and <code>pacf</code>.
</p>


<h3>Warning</h3>

<p>See the warnings from <code><a href="#topic+cable.ar.p.plot">cable.ar.p.plot</a></code> and
<code><a href="#topic+cable.ar.p.resid">cable.ar.p.resid</a></code>. </p>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cable.lines">cable.lines</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="stats.html#topic+pacf">pacf</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sockeye)

# AR(2) cable fit
fit.ar2 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,4,.5,-.5),
	sockeye$logReturns, tol=1e-4 )
cable.ar.p.diag( fit.ar2, main="bent cable", main.all="Sockeye",
	ctp.ci=cable.change.conf( fit.ar2, .9 ) )
		# compare to this:
		# fit.ar2 &lt;- bentcable.ar( sockeye$logReturns,
		#	init.cable=c(13,.1,-.5,11,4), p=2, main="Sockeye bent cable",
		#	ci.level=.9 )

# AR(4) stick fit
fit.ar4 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,.5,-.5,.5,-.5),
	sockeye$logReturns, tol=1e-4, stick=TRUE )
cable.ar.p.diag( fit.ar4, ctp.ci=cable.change.conf( fit.ar4, .95 ) )
		# compare to this:
		# fit.ar4 &lt;- bentcable.ar( sockeye$logReturns,
		#	init.cable=c(13,.1,-.5,11), p=4, stick=TRUE )
</code></pre>

<hr>
<h2 id='cable.ar.p.iter'> Bent-Cable Regression for Independent or AR Data, With Exception  </h2><span id='topic+cable.ar.p.iter'></span>

<h3>Description</h3>

<p>This function is the main engine for <code>bentcable.ar</code>. It performs
bent-cable (including broken-stick) regression to AR(p) time-series data
or independent data (time-series or otherwise). However, it 
<b>cannot fit broken sticks to independent data</b> (see
<code>stick.ar.0</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.ar.p.iter(init, y.vect, t.vect = NULL, n = NA, tol,
	method0 = "css", method1 = "yw", stick = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.ar.p.iter_+3A_init">init</code></td>
<td>
<p> A numeric vector of initial values, in the form of
<code>c(b0,b1,b2,tau,gamma,phi.1,...,phi.p)</code> when <code>stick=FALSE</code>, and
<code>c(b0,b1,b2,tau,phi.1,...,phi.p)</code> when <code>stick=TRUE</code>.
<code>phi</code> values correspond to AR(p) coefficients - if not included,
then independent data are assumed. </p>
</td></tr>
<tr><td><code id="cable.ar.p.iter_+3A_y.vect">y.vect</code></td>
<td>
<p> A numeric vector of response data. </p>
</td></tr>
<tr><td><code id="cable.ar.p.iter_+3A_t.vect">t.vect</code></td>
<td>
<p> A numeric vector of design points, which <b>MUST</b> be
equidistant with unit increments if AR(p) is assumed. They need not be
equidistant for independent data. Specifying <code>t.vect=NULL</code> is
equivalent to specifying the default time points <code>c(0,1,2,...)</code>. </p>
</td></tr>
<tr><td><code id="cable.ar.p.iter_+3A_n">n</code></td>
<td>
<p> Length of response vector (optional). </p>
</td></tr>
<tr><td><code id="cable.ar.p.iter_+3A_tol">tol</code></td>
<td>
<p> Tolerance for determining convergence. </p>
</td></tr>
<tr><td><code id="cable.ar.p.iter_+3A_method0">method0</code>, <code id="cable.ar.p.iter_+3A_method1">method1</code></td>
<td>
<p> The fitting method when p&gt;0. <code>"css"</code> stands for
<em>conditional sum-of-squares</em> and corresponds to conditional maximum
likelihood. <code>"yw"</code> stands for <em>Yule-Walker</em>, and <code>"mle"</code>
for (full) <em>maximum likelihood estimation</em>. If <code>method0</code> fails
to converge, then <code>method1</code> is attempted. </p>
</td></tr>
<tr><td><code id="cable.ar.p.iter_+3A_stick">stick</code></td>
<td>
<p> A logical value; if <code>TRUE</code>, a broken-stick regression is performed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>bent cable</em> has the form
<code class="reqn">f(t) = b_0 + b_1 t + b_2 q(t)</code>, where <code class="reqn">q(t)</code> is
the <em>basic bent cable</em> 
</p>
<p style="text-align: center;"><code class="reqn">q(t)=\frac{(t-\tau+\gamma)^2}{4\gamma} I\{|t-\tau|\le\gamma\}
	+ (t-\tau) I\{t&gt;\tau+\gamma\}</code>
</p>

<p>for <code class="reqn">\gamma\ge 0</code>.
</p>
<p>For independent data (time series or otherwise), bent-cable
regression by maximum likelihood is performed via nonlinear
least-squares estimation of
<code class="reqn">\theta=(b_0,b_1,b_2,\tau,\gamma)</code> through the built-in <span class="rlang"><b>R</b></span>
function <code>nls</code>. For AR(p) data, conditional maximum
likelihood (CML) estimation of <code class="reqn">(\theta,\phi)</code>
(conditioned on the first p data points) is performed through
the built-in <span class="rlang"><b>R</b></span> function <code>optim</code> with the <code>"BFGS"</code>
algorithm, where <code class="reqn">\phi=(\phi_1,\ldots,\phi_p)</code> are the AR
coefficients. In either case, the estimation relies on the
user-supplied initial values in <code>init</code>. A Gaussian model
is assumed, so that CML estimation is equivalent to minimizing
the conditional sum-of-squares error, specified as
<code>"css"</code> by default for <code>method0</code>. However,
<code>"css"</code> sometimes fails to converge, or the resulting
<code class="reqn">\phi</code> estimate sometimes corresponds to non-stationarity.
In this case, the alternative estimation approach specified
for <code>method1</code> is attempted. <code>"mle"</code> specifies the
<em>CML-ML hybrid</em> algorithm, and <code>"yw"</code> the
<em>CML-ML-MM hybrid</em> algorithm (<em>MM</em> stands for
<em>method of moments</em>; see <b>References</b>.) Both
<code>"yw"</code> and <code>"mle"</code> guarantee stationarity, but often
take much longer than <code>"css"</code> to converge.
</p>
<p>The bent-cable likelihood / deviance often has multiple peaks. Thus, the
user should be aware of different local maxima on which the optimization
algorithm can converge despite initial values for <code class="reqn">\theta</code> that
are very similar. The user is advised to combine several exploratory
analyses as well as model diagnoses before settling on a
<em>best</em> fit. See <b>Details</b> on the
<code><a href="#topic+bentcable.ar">bentcable.ar</a></code> help page for a detailed description.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p> An <code>nls</code> object, returned if independent data are assumed. It is 
the maximum likelihood bent-cable fit. </p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p> A numeric vector, returned if AR(p&gt;0) is assumed. It is the
estimated value of (<code class="reqn">\theta,\phi</code>). </p>
</td></tr>
<tr><td><code>ar.p.fit</code></td>
<td>
<p> Returned if AR(p&gt;0) is assumed. If <code>"css"</code> is used,
converges, and yields a <code class="reqn">\phi</code> estimate that corresponds to
stationarity, then <code>$ar.p.fit</code> is an <code>optim</code> object containing
the CML fit. If <code>"yw"</code> or <code>"mle"</code> is used and converges, then
<code>$ar.p.fit</code> is an <code>ar</code> object containing the CML-ML(-MM) fit. </p>
</td></tr>
<tr><td><code>y</code>, <code>t</code>, <code>n</code>, <code>p</code>, <code>stick</code></td>
<td>
<p> As supplied by the user; always returned. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> A character string, returned if AR(p&gt;0) is assumed. It indicates
the method that yielded the returned fit. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>
<p>For several fits that assume a common p, their (conditional) likelihood
values should be compared to screen out those that result from local
maxima. Equivalently, the (conditional) sum-of-squares error (SSE) can
be compared and only the smallest kept. See <b>Examples</b> below.
Also see <b>Details</b> on the <code><a href="#topic+bentcable.ar">bentcable.ar</a></code> help
page.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+stick.ar.0">stick.ar.0</a></code>, <code><a href="#topic+fullcable.t">fullcable.t</a></code>, 
<code><a href="#topic+bentcable.dev.plot">bentcable.dev.plot</a></code>,
<code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="stats.html#topic+ar">ar</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stagnant)
data(sockeye)

# 'stagnant': independent data cable fit
fit0 &lt;- cable.ar.p.iter( c(.6,-.4,-.7,0,.5),
	stagnant$loght, stagnant$logflow )    # 'nls' fit
	# compare to this:
	# bentcable.ar( stagnant$loght, t.vect=stagnant$logflow,
	#	init.cable=c(.6,-.4,-.7,0,.5) )

fit0$fit   # 'fit0' SSE=0.005


# 'sockeye': AR(2) cable fit
fit1 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,4,.5,-.5),
	sockeye$logReturns, tol=1e-4 )    # "css" successful
	# compare to this:
	# fit1 &lt;- bentcable.ar( sockeye$logReturns, 
	#	init.cable=c(13,.1,-.5,11,4), p=2 )

fit1$ar.p.fit$value     # 'fit1' SSE=4.9


# 'sockeye': AR(2) cable fit
fit2 &lt;- cable.ar.p.iter( c(10,0,0,5,.1,.5,-.5), sockeye$logReturns, 
	tol=1e-4 )    # "css" unsuccessful, switched to "yw"
	# compare to this:
	# fit2 &lt;- bentcable.ar(sockeye$logReturns, 
	#	init.cable=c(10,0,0,5,.1), p=2 )

cable.ar.p.iter( fit2$est, sockeye$logReturns, 
	tol=1e-4 )   # 'fit2' SSE=13.8 (from first line of screen output)


# 'sockeye': AR(4) stick fit
cable.ar.p.iter( c(13,.1,-.5,11,.5,-.5,.5,-.5),
	sockeye$logReturns, tol=1e-4, stick=TRUE )
	# compare to this:
	# bentcable.ar( sockeye$logReturns,
	#	init.cable=c(13,.1,-.5,11), p=4, stick=TRUE )
</code></pre>

<hr>
<h2 id='cable.ar.p.plot'> Plot Bent Cable AR(p) Fit Over Data </h2><span id='topic+cable.ar.p.plot'></span>

<h3>Description</h3>

<p>Plot the bent-cable AR(p) regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.ar.p.plot(ar.p.fit, xlab = "time", ylab = "", main = NULL, ctp.ci = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.ar.p.plot_+3A_ar.p.fit">ar.p.fit</code></td>
<td>
<p> A <code>cable.ar.p.iter</code> object for AR(p) data, p&gt;0. </p>
</td></tr>
<tr><td><code id="cable.ar.p.plot_+3A_xlab">xlab</code></td>
<td>
<p> Character string: x-axis label. </p>
</td></tr>
<tr><td><code id="cable.ar.p.plot_+3A_ylab">ylab</code></td>
<td>
<p> Character string: y-axis label. </p>
</td></tr>
<tr><td><code id="cable.ar.p.plot_+3A_main">main</code></td>
<td>
<p> Character string: plot title. </p>
</td></tr>
<tr><td><code id="cable.ar.p.plot_+3A_ctp.ci">ctp.ci</code></td>
<td>
<p> A <code>cable.change.conf</code> object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time series data and bent-cable / broken-stick fit are extracted 
from the argument <code>ar.p.fit</code>. These data are then plotted, with
the fitted regression superimposed in red. The estimated transition
<code class="reqn">\tau</code> and <code class="reqn">\tau \pm \gamma</code> are also marked in red. The 
optional <code>ctp.ci</code>, if provided, adds to the plot in blue the 
confidence interval for the CTP (unique point at which the cable's 
slope changes sign).
</p>


<h3>Warning</h3>

<p>This function fails if <code>ar.p.fit</code> is from a non-AR(p&gt;0) fit.
For fits with independent data, use <code>cable.lines</code>. </p>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cable.lines">cable.lines</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+par">par</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sockeye)

# AR(2) cable fit
fit.ar2 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,4,.5,-.5),
	sockeye$logReturns, tol=1e-4 )
cable.ar.p.plot( fit.ar2, ctp.ci=cable.change.conf( fit.ar2, .9 ) )

	# compare to this:
	# fit.ar2 &lt;- bentcable.ar( sockeye$logReturns, 
	#	init.cable=c(13,.1,-.5,11,4), p=2, ci.level=.9 )
	# cable.ar.p.plot( fit.ar2$cable, ctp.ci=fit.ar2$ctp )

# AR(4) stick fit
fit.ar4 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,.5,-.5,.5,-.5),
	sockeye$logReturns, tol=1e-4, stick=TRUE )
cable.ar.p.plot( fit.ar4, ctp.ci=cable.change.conf( fit.ar4, .9 ) )

	# compare to this:
	# fit.ar4 &lt;- bentcable.ar( sockeye$logReturns,
	#	init.cable=c(13,.1,-.5,11), p=4, stick=TRUE, ci.level=.9 )
	# cable.ar.p.plot( fit.ar4$cable, ctp.ci=fit.ar4$ctp )
</code></pre>

<hr>
<h2 id='cable.ar.p.resid'> Fitted Residuals and Innovations for AR(p&gt;0) Bent Cable </h2><span id='topic+cable.ar.p.resid'></span>

<h3>Description</h3>

<p>This function computes the fitted residuals and
fitted innovations from an AR(p&gt;0) bent-cable
regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.ar.p.resid(ar.p.fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.ar.p.resid_+3A_ar.p.fit">ar.p.fit</code></td>
<td>
<p> A <code>cable.ar.p.iter</code> object for AR(p) data, p&gt;0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitted residuals correspond to the detrended time series,
where the fitted bent cable is subtracted from the data.
They retain the autocorrelation structure of the response 
time series.
</p>
<p>Fitted innovations are the <em>estimated</em> residual noise
after adjusting for the AR(p) structure, and should be
approximately independent if the AR(p) fit successfully
captures the actual autocorrelation in the data.
</p>
<p>Both types of errors may be used for model diagnosis.
</p>


<h3>Value</h3>

<table>
<tr><td><code>resid</code></td>
<td>
<p> A numeric vector of fitted residuals; it has the same length as
the response data. </p>
</td></tr>
<tr><td><code>innov</code></td>
<td>
<p> A numeric vector of fitted innovations; the first value
in the vector corresponds to the (p+1)st time point. </p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>This function fails if <code>ar.p.fit</code> is from a non-AR(p&gt;0) fit. 
</p>
<p>The fitted innovations are only meaningful if <code>ar.p.fit</code> is
associated with equidistant time points with unit increments.
</p>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cable.ar.p.diag">cable.ar.p.diag</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sockeye)

fit.ar2 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,4,.5,-.5),
	sockeye$logReturns, tol=1e-4 )
cable.ar.p.resid( fit.ar2 )
</code></pre>

<hr>
<h2 id='cable.change.conf'> Confidence Interval for CTP of AR(p) Bent Cable </h2><span id='topic+cable.change.conf'></span>

<h3>Description</h3>

<p>The <em>critical time point</em> (CTP) is estimated and
accompanied by a Wald confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.change.conf(ar.p.fit, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.change.conf_+3A_ar.p.fit">ar.p.fit</code></td>
<td>
<p> A <code>cable.ar.p.iter</code> object for AR(p<code class="reqn">\ge</code>0)
data. </p>
</td></tr>
<tr><td><code id="cable.change.conf_+3A_level">level</code></td>
<td>
<p> A numeric value between 0 and 1, exclusive. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CTP is the unique time point at which the cable's 
slope changes sign. If this exists, then it must happen
inside the transition <code class="reqn">\tau\pm\gamma</code>, and is estimated
by this function based on the bent-cable regression
supplied as <code>ar.p.fit</code>. Additionally, an approximate
confidence interval using the Wald method is obtained by
estimating the asymptotic variance of the CTP estimator.
Variance estimation involves inverting an approximate
Fisher information matrix by calling the built-in <span class="rlang"><b>R</b></span>
function <code>solve</code>.
</p>
<p><code>cable.change.conf</code> returns an error if the CTP (almost) 
does not exist, e.g. when the estimated bent cable slope 
(almost) does not change signs, or when the fit from
<code>ar.p.fit</code> is obtained with a time vector that is not
<code>c(0,1,2,...)</code>. See <b>Warnings</b> below.
</p>


<h3>Value</h3>

<table>
<tr><td><code>change.hat</code></td>
<td>
<p> The estimated CTP. </p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p> The estimated asymptotic variance of the CTP estimator. </p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p> The 100*<code>level</code> percent Wald confidence interval 
for the CTP. </p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>Computations for the CTP estimate and confidence interval are based on a time
vector of the form <code>c(0,1,2,...)</code>. For any other form for the time
vector, the CTP will not be computed, and on-screen warnings
will appear. To ensure compatibility between the model fit and CTP
estimates, the user is advised to fit the model using the default
time vector. Then, if necessary, the user may transform the results
to the preferred time scale after the model and CTP estimates have
been produced.
</p>
<p>The above computational issue implies that the function cannot
handle non-time-series data. <b>Rationale</b>:
In a non-time-series context design points are often
non-equidistant, and the cable's slope often never changes sign;
even with a sign change, the point at which this takes place may be
less interpretable. In such a context, the user is advised to rely
on confidence regions for <code class="reqn">(\tau,\gamma)</code> (see
<b>References</b>).
</p>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="Matrix.html#topic+solve">solve</a></code>, <code><a href="#topic+cable.ar.p.plot">cable.ar.p.plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sockeye)

# AR(2) cable fit
fit.ar2 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,4,.5,-.5),
	sockeye$logReturns, tol=1e-4 )
cable.change.conf( fit.ar2, .9 )

	# compare to this:
	# fit.ar2 &lt;- bentcable.ar( sockeye$logReturns, 
	#	init.cable=c(13,.1,-.5,11,4), p=2, ci.level=.9 )
	# cable.change.conf( fit.ar2$cable, .9 )

# AR(2) stick fit
stick.ar2 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,.5,-.5),
	sockeye$logReturns, tol=1e-4, stick=TRUE)
cable.change.conf( stick.ar2, .9)
	# compare to this:
	# stick.ar2 &lt;- bentcable.ar( sockeye$logReturns,
	#	init.cable=c(13,.1,-.5,11), p=2, stick=TRUE, ci.level=.9 )
	#	cable.change.conf( stick.ar2$cable, .9 )

# AR(4) stick fit
fit.ar4 &lt;- cable.ar.p.iter( c(13,.1,-.5,11,.5,-.5,.5,-.5),
	sockeye$logReturns, tol=1e-4, stick=TRUE )
cable.change.conf( fit.ar4, .9 )

	# compare to this:
	# fit.ar4 &lt;- bentcable.ar( sockeye$logReturns,
	#	init.cable=c(13,.1,-.5,11), p=4, stick=TRUE, ci.level=.9 )
	# cable.change.conf( fit.ar4$cable, .9 )
</code></pre>

<hr>
<h2 id='cable.fit.known.change'> Grid-based Bent-Cable Regression for Independent or AR Data </h2><span id='topic+cable.fit.known.change'></span><span id='topic+cable.dev'></span><span id='topic+cable.ar.0.fit'></span>

<h3>Description</h3>

<p>These functions compute the profile deviance over a <code class="reqn">(\tau,\gamma)</code>-grid
to either fit a bent-cable regression with known transition, or to
generate initial values for a bent-cable regression with unknown
transition. <code>cable.dev</code> and <code>cable.fit.known.change</code> form
the main engine of <code>bentcable.dev.plot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.ar.0.fit(y.vect, t.vect = NULL, tau.vect, gamma.vect, dev.mat,
	stick = FALSE)
cable.dev(tau.vect, gamma.vect, y.vect, t.vect = NULL, p = 0)
cable.fit.known.change(y.vect, t.vect = NULL, n = NA,
	tau.vect, gamma.vect, dev.mat, p = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.fit.known.change_+3A_y.vect">y.vect</code></td>
<td>
<p> A numeric vector of response values. </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_t.vect">t.vect</code></td>
<td>
<p> A numeric vector of design points. Specifying
<code>t.vect=NULL</code> is equivalent to specifying the default time points
<code>c(0,1,2,...)</code>. Also see <b>Warnings</b> below. </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_n">n</code></td>
<td>
<p> Length of response vector (optional). </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_tau.vect">tau.vect</code></td>
<td>
<p> A numeric vector of <code class="reqn">\tau</code>-coordinates of the grid points. </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_gamma.vect">gamma.vect</code></td>
<td>
<p> A numeric vector of <code class="reqn">\gamma</code>-coordinates of the grid points. </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_dev.mat">dev.mat</code></td>
<td>
<p> A numeric matrix (can be single column) corresponding to the bent-cable
profile deviance surface / function over the <code class="reqn">(\tau,\gamma)</code>-grid. </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_p">p</code></td>
<td>
<p> The autoregressive order (non-negative integer).
<code>p=0</code> specifies independent data that may or may not be from a
time series context. </p>
</td></tr>
<tr><td><code id="cable.fit.known.change_+3A_stick">stick</code></td>
<td>
<p> A logical value; if <code>TRUE</code> then a broken stick (i.e. bent cable
with <code class="reqn">\gamma</code>=0.) is fitted. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the response data in <code>y.vect</code> and design points 
in <code>t.vect</code>, <code>cable.dev</code> evaluates the bent-cable 
profile deviance surface / function over the user-specified
<code class="reqn">(\tau,\gamma)</code>-grid. The returned values are intended 
to be used in conjunction with <code>contour</code> or <code>persp</code>, 
in which case <code>tau.vect</code> and <code>gamma.vect</code> should have length
greater than 1 so that the returned object is a matrix with at least
two columns.  If such a plot is not required, then <code>tau.vect</code>
and/or <code>gamma.vect</code> can be scalar. This function is internal
to the main plotting interface <code><a href="#topic+bentcable.dev.plot">bentcable.dev.plot</a></code>.
</p>
<p>The grid point at which the profile deviance is maximum
corresponds to a bent-cable fit given a known transition
that is best among the specified grid points. 
<code>cable.fit.known.change</code> locates this peak and computes 
this fit. If multiple peaks exist (such as along a ridge), 
then only that at the smallest <code class="reqn">\tau</code> and smallest <code class="reqn">\gamma</code> 
is used.
</p>
<p>For both functions, <code>p=0</code> should be specified to indicate 
independent data (time series or otherwise). For time-series 
data, a positive integer <code>p</code> should be specified as the
autoregressive order. Fitting is done by internally calling 
the built-in <span class="rlang"><b>R</b></span> function <code>lm</code> for <code>p=0</code> and <code>arima</code> 
for non-zero <code>p</code>; this procedure is appropriate since 
bent-cable regression with a known transition is linear.
</p>
<p>Note that the grid-based <code>cable.fit.known.change</code>
does not locate the true peak of the continuous profile 
deviance surface / function. However, for a grid that traps 
the true peak between grid points, the returned fit is 
approximately the overall best fit (with all parameters
unknown), and thus can be fed into <code>bentcable.ar</code> 
as initial values for computing the actual best fit. A special 
case is <code>p=0</code> for independent data (time-series or otherwise),
which can be handled by <code>cable.ar.0.fit</code> (called internally by 
<code>bentcable.ar</code>). <code>cable.ar.0.fit</code> calls
<code>cable.ar.p.iter</code> when <code>stick=FALSE</code> but calls <code>stick.ar.0</code>
when <code>stick=TRUE</code>; in both cases, the built-in <span class="rlang"><b>R</b></span> function <code>nls</code>
is utilized to perform maximum likelihood.
</p>
<p>For all three functions, to fit a broken stick with a known 
break point, <code>gamma.vect</code> should be the single 
value 0, and thus <code>dev.mat</code> is a column matrix (see 
<code><a href="#topic+bentcable.dev.plot">bentcable.dev.plot</a></code>).
</p>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p> Returned by <code>cable.fit.known.change</code>
and <code>cable.ar.0.fit</code>. 
</p>
<p>For <code>cable.fit.known.change</code>,
<code>$fit</code> is the AR(p) bent-cable regression at the known 
transition grid point; if <code>p=0</code>, it is
an <code>lm</code> object, otherwise it is an <code>arima</code> object. 
</p>
<p>For <code>cable.ar.0.fit</code>, <code>$fit</code> is an <code>nls</code> object 
that is the maximum likelihood bent-cable fit. </p>
</td></tr>
<tr><td><code>init</code></td>
<td>
<p> Returned by <code>cable.fit.known.change</code>, containing
the coefficients from <code>$fit</code> that can be used as initial 
values in bent-cable regression with unknown transition. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> Same as <code>y.vect</code>: returned by <code>cable.ar.0.fit</code>. </p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p> Same as <code>t.vect</code>: returned by <code>cable.ar.0.fit</code>. </p>
</td></tr>
<tr><td><code>n</code>, <code>p</code>, <code>stick</code></td>
<td>
<p> As supplied by the user: returned by <code>cable.ar.0.fit</code>. </p>
</td></tr>
</table>
<p><code>cable.dev</code> returns the evaluated profile deviance 
surface / function as a matrix.
</p>


<h3>Warnings</h3>

<p>For time-series data, <code>t.vect</code> <em>MUST</em> be 
equidistant with unit increments; otherwise, these 
functions will return meaningless values. (For 
independent data, <code>t.vect</code> can be non-equidistant.)   
</p>
<p>Grid-based bent-cable regression and its use in 
subsequent overall fits rely on locating the region
in which the continous deviance surface truly peaks. 
The user should be aware of possible local maxima and/or
coarse grids that result in less-than-best fits.
</p>


<h3>Note</h3>

<p>These functions are intended for internal use by <code>bentcable.dev.plot</code>
and <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bentcable.dev.plot">bentcable.dev.plot</a></code>, <code><a href="#topic+bentcable.ar">bentcable.ar</a></code>,
<code><a href="stats.html#topic+nls">nls</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+arima">arima</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stagnant)
data(sockeye)

# non-time-series data: compute grid-based profile deviance
cable.dev( seq(-.04,.16,length=10), seq(.2,.65,length=10), 
	stagnant$loght, stagnant$logflow )
	# compare to this:
	# bentcable.dev.plot( seq(-.04,.16,length=10), 
	#	seq(.2,.65,length=10), stagnant$loght, stagnant$logflow )$dev

# AR(2) bent cable, start time at 0: find best grid-based fit
dev &lt;- cable.dev( seq(6,18,length=15), seq(.01,12,length=15),
		sockeye$logReturns, p=2 )
contour( seq(6,18,length=15), seq(.01,12,length=15), dev )
cable.fit.known.change( sockeye$logReturns, tau.v=seq(6,18,length=15), 
	gamma.v=seq(.01,12,length=15), dev.mat=dev, p=2 )

# AR(0) broken stick, start time at 80: find best overall fit
dev &lt;- cable.dev ( seq(85,97,length=15), 0, sockeye$logReturns, 
	sockeye$year)
plot( seq(85,97,length=15), dev, type="l" )
cable.ar.0.fit( sockeye$logReturns, sockeye$year,
	tau.v=seq(85,97,length=15), gamma.v=0, dev.mat=dev, 
	stick=TRUE )
	# compare to this:
	# bentcable.ar( sockeye$logReturns, bentcable.dev.plot(
	#	seq(85,97,length=15), 0, sockeye$logReturns, sockeye$year, TRUE
	#	), stick=TRUE, t.vect=sockeye$year )
</code></pre>

<hr>
<h2 id='cable.lines'> Overlay Bent Cable On Existing Plot </h2><span id='topic+cable.lines'></span>

<h3>Description</h3>

<p>A user-specified bent cable is added to an existing plot.
Its intended use is for superimposing a bent-cable regression
fit to a scatterplot of the data. The transition is marked
by vertical lines at <code class="reqn">\tau</code> and <code class="reqn">\tau\pm\gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cable.lines(x, theta, col = "black", lwd = 1, lty = 2, fit.lty = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cable.lines_+3A_x">x</code></td>
<td>
<p> A numeric vector of design points or the range of these
design points on the existing scatterplot. </p>
</td></tr>
<tr><td><code id="cable.lines_+3A_theta">theta</code></td>
<td>
<p> A vector of bent-cable coefficients, in the form of
<code>c(b0,b1,b2,tau,gamma)</code>. </p>
</td></tr>
<tr><td><code id="cable.lines_+3A_col">col</code>, <code id="cable.lines_+3A_lwd">lwd</code></td>
<td>
<p> Graphical parameters for plotting the bent-cable
function and transition. </p>
</td></tr>
<tr><td><code id="cable.lines_+3A_lty">lty</code></td>
<td>
<p> Graphical parameter for marking the transition. </p>
</td></tr>
<tr><td><code id="cable.lines_+3A_fit.lty">fit.lty</code></td>
<td>
<p> Graphical parameter of type <code>lty</code> for
plotting the bent-cable function. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fullcable.t">fullcable.t</a></code>, <code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="graphics.html#topic+lines">lines</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sockeye)

	plot(sockeye)
	cable.lines( sockeye$year, c(6.6,.08,-.68,92,6.01) )
</code></pre>

<hr>
<h2 id='fullcable.t'> Evaluate Bent Cable Function </h2><span id='topic+fullcable.t'></span>

<h3>Description</h3>

<p>The bent-cable response is evaluated at a provided design point <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullcable.t(t, b0, b1, b2, tau, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fullcable.t_+3A_t">t</code></td>
<td>
<p> A design point at which the bent cable is to be evaluated. </p>
</td></tr>
<tr><td><code id="fullcable.t_+3A_b0">b0</code></td>
<td>
<p> Intercept. </p>
</td></tr>
<tr><td><code id="fullcable.t_+3A_b1">b1</code></td>
<td>
<p> Incoming slope. </p>
</td></tr>
<tr><td><code id="fullcable.t_+3A_b2">b2</code></td>
<td>
<p> Coefficient of the <em>basic bent cable</em>. </p>
</td></tr>
<tr><td><code id="fullcable.t_+3A_tau">tau</code></td>
<td>
<p> Centre of the quadratic bend (transition). </p>
</td></tr>
<tr><td><code id="fullcable.t_+3A_gamma">gamma</code></td>
<td>
<p> Non-negative half-width of the quadratic bend. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All arguments must be numeric, and at most one can be a vector.
</p>
<p>The <em>full bent cable</em> has the form
<code class="reqn">f(t) = b_0 + b_1 t + b_2 q(t)</code>, where <code class="reqn">q(t)</code> is
the <em>basic bent cable</em> function with intercept and slope 0
and outgoing slope 1:
</p>
<p style="text-align: center;"><code class="reqn">q(t)=\frac{(t-\tau+\gamma)^2}{4\gamma} I\{|t-\tau|\leq\gamma\}
	+ (t-\tau) I\{t&gt;\tau+\gamma\}</code>
</p>

<p>for <code class="reqn">\gamma\geq 0</code>.
</p>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>
and <code>bentcable.dev.plot</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>Examples</h3>

<pre><code class='language-R'>	# basic broken stick, kink at 0:
	plot( seq(-10,10), fullcable.t(seq(-10,10),0,0,1,0,0) )
	
	# full bent cable, bend centred at 0 with half-width 3:
	plot( seq(-10,10), fullcable.t(seq(-10,10),1,.1,-.5,0,3) )
</code></pre>

<hr>
<h2 id='is.stationary'> Stationarity Check of AR Time Series </h2><span id='topic+is.stationary'></span>

<h3>Description</h3>

<p>Check if AR coefficients correspond to stationarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.stationary(phi.vect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.stationary_+3A_phi.vect">phi.vect</code></td>
<td>
<p> A vector of at least one AR coefficient. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stationarity check is performed via the simulation of an AR
time series using the built-in <span class="rlang"><b>R</b></span> function <code>arima.sim</code>.
</p>


<h3>Value</h3>

<p>logical
</p>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>Examples</h3>

<pre><code class='language-R'>  is.stationary(1) # F
  is.stationary(c(-.5,.2)) # T
</code></pre>

<hr>
<h2 id='sockeye'>Rivers Inlet Sockeye Abundance</h2><span id='topic+sockeye'></span>

<h3>Description</h3>

<p>This dataset contains the figures for the returns of Rivers Inlet
sockeye salmon (<em>Oncorhynchus nerka</em>) recorded annually from
1980 to 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sockeye)</code></pre>


<h3>Format</h3>

<p>A data frame with two columns:
</p>

<ul>
<li><p><code>year</code> The year minus 1900. E.g. <code>80</code> is 1980 and
<code>100</code> is the year 2000. 
</p>
</li>
<li><p><code>logReturns</code> The figure for the returning number of
salmon, converted to the natural logarithmic scale. 
</p>
</li></ul>



<h3>Source</h3>

<p>Fisheries and Oceans Canada, Pacific Region.</p>


<h3>References</h3>

<p>Chiu, G., Lockhart, R. and Routledge, R. (2006), Bent-Cable Regression
Theory and Applications, <em>Journal of the American Statistical
Association</em>, <b>101</b>, 542&ndash;553. DOI: 10.1198/016214505000001177. URL:  
<a href="https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications">https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications</a>
</p>

<hr>
<h2 id='stagnant'> Stagnant Band Height Data </h2><span id='topic+stagnant'></span>

<h3>Description</h3>

<p>This is the well-studied data from R.A. Cook's Ph.D.
thesis (Queen's University) on the relationship between the flow
rate and band height of water on an incline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stagnant)</code></pre>


<h3>Format</h3>

<p>A data frame with two columns:
</p>

<ul>
<li><p><code>logflow</code> The flow rate in g/cm-s, log-transformed 
</p>
</li>
<li><p><code>loght</code> The band height in cm, log-transformed. 
</p>
</li></ul>



<h3>Source</h3>

<p> Seber, G. A. F. and Wild, C. J. (2003), <em>Nonlinear
Regression</em>, Hoboken: Wiley. </p>


<h3>References</h3>

<p>Chiu, G., Lockhart, R. and Routledge, R. (2006), Bent-Cable Regression
Theory and Applications, <em>Journal of the American Statistical
Association</em>, <b>101</b>, 542&ndash;553. DOI: 10.1198/016214505000001177. URL:  
<a href="https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications">https://www.researchgate.net/publication/4742466_Bent-Cable_Regression_Theory_and_Applications</a>
</p>

<hr>
<h2 id='stick.ar.0'> Broken-Stick Regression for Independent Data </h2><span id='topic+stick.ar.0'></span>

<h3>Description</h3>

<p>This function is the main engine for <code>bentcable.ar</code> when a
broken stick (i.e. <code class="reqn">\gamma</code>=0 for bent cable) model is assumed
for independent data.  For AR(p) time-series data, this function is
intended for determining an appropriate p and initial values for
the stick parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stick.ar.0(init.vect, y.vect, t.vect = NULL, n = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stick.ar.0_+3A_init.vect">init.vect</code></td>
<td>
<p> A numeric vector of initial values, in the form
of <code>c(b0,b1,b2,tau)</code>. </p>
</td></tr>
<tr><td><code id="stick.ar.0_+3A_y.vect">y.vect</code></td>
<td>
<p> A numeric vector of response data. </p>
</td></tr>
<tr><td><code id="stick.ar.0_+3A_t.vect">t.vect</code></td>
<td>
<p> A numeric vector of design points, which need not be
equidistant. Specifying <code>t.vect=NULL</code> is equivalent to
specifying the default time points <code>c(0,1,2,...)</code>. </p>
</td></tr>
<tr><td><code id="stick.ar.0_+3A_n">n</code></td>
<td>
<p> Length of response vector (optional). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object is compatible with a <code>cable.ar.p.iter</code>
object for independent data.
</p>
<p>The broken stick as a special case of the bent cable has form
<code class="reqn">f(t) = b_0 + b_1 t + b_2 (t-\tau) I\{t&gt;\tau\} </code>.
</p>
<p>Broken-stick regression by maximum likelihood for independent data
is performed via nonlinear least-squares estimation of
<code class="reqn">\theta=(b_0,b_1,b_2,\tau)</code> through the built-in <span class="rlang"><b>R</b></span> function
<code>nls</code>. The estimation relies on the user-supplied initial
values in <code>init</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p> An <code>nls</code> object that is the maximum likelihood fit. </p>
</td></tr>
<tr><td><code>y</code>, <code>t</code>, <code>n</code></td>
<td>
<p> As supplied by the user. </p>
</td></tr>
<tr><td><code>p</code>, <code>stick</code></td>
<td>
<p> The values <code>0</code> and <code>TRUE</code>, respectively;
used internally by <code>bentcable.ar</code> and <code>cable.ar.0.fit</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended for internal use by <code>bentcable.ar</code>.
</p>


<h3>Author(s)</h3>

<p> Grace Chiu </p>


<h3>References</h3>

<p> See the <code><a href="#topic+bentcableAR">bentcableAR</a></code> package references. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cable.ar.p.iter">cable.ar.p.iter</a></code>, <code><a href="#topic+fullcable.t">fullcable.t</a></code>, 
<code><a href="#topic+cable.fit.known.change">cable.fit.known.change</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sockeye)

stick.ar.0( c(13,.1,-.7,12), sockeye$logReturns )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
