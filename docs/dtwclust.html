<!DOCTYPE html><html lang="en"><head><title>Help for package dtwclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtwclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dtwclust-package'><p>Time series clustering along with optimizations for the Dynamic Time Warping distance</p></a></li>
<li><a href='#as.matrix'><p>as.matrix</p></a></li>
<li><a href='#compare_clusterings'><p>Compare different clustering configurations</p></a></li>
<li><a href='#compare_clusterings_configs'><p>Create clustering configurations.</p></a></li>
<li><a href='#compute_envelope'><p>Time series warping envelopes</p></a></li>
<li><a href='#cvi'><p>Cluster validity indices</p></a></li>
<li><a href='#cvi_evaluators'><p>Cluster comparison based on CVIs</p></a></li>
<li><a href='#DBA'><p>DTW Barycenter Averaging</p></a></li>
<li><a href='#Distmat-class'><p>Distance matrix</p></a></li>
<li><a href='#Distmat-generics'><p>Generics for <code>Distmat</code></p></a></li>
<li><a href='#DistmatLowerTriangular-class'><p>Distance matrix's lower triangular</p></a></li>
<li><a href='#DistmatLowerTriangular-generics'><p>Generics for <code>DistmatLowerTriangular</code></p></a></li>
<li><a href='#dtw_basic'><p>Basic DTW distance</p></a></li>
<li><a href='#dtw_lb'><p>DTW distance matrix guided by Lemire's improved lower bound</p></a></li>
<li><a href='#dtw2'><p>DTW distance with L2 norm</p></a></li>
<li><a href='#dtwclustTimings'><p>Results of timing experiments</p></a></li>
<li><a href='#explore__plot'><p>This helper will produce the plot in the Explore tab panel.</p></a></li>
<li><a href='#explore__tidy_series'><p>This helper will create the data frame used to plot in the Explore tab panel</p></a></li>
<li><a href='#GAK'><p>Fast global alignment kernels</p></a></li>
<li><a href='#interactive_clustering'><p>A shiny app for interactive clustering</p></a></li>
<li><a href='#lb_improved'><p>Lemire's improved DTW lower bound</p></a></li>
<li><a href='#lb_keogh'><p>Keogh's DTW lower bound</p></a></li>
<li><a href='#NCCc'><p>Cross-correlation with coefficient normalization</p></a></li>
<li><a href='#PairTracker-class'><p>Helper for semi-supervised DTW clustering</p></a></li>
<li><a href='#pam_cent'><p>Centroid for partition around medoids</p></a></li>
<li><a href='#parse_input'><p>This helper will parse comma-separated key-value pairs</p></a></li>
<li><a href='#pdc_configs'><p>Helper function for preprocessing/distance/centroid configurations</p></a></li>
<li><a href='#reinterpolate'><p>Wrapper for simple linear reinterpolation</p></a></li>
<li><a href='#repeat_clustering'><p>Repeat a clustering configuration</p></a></li>
<li><a href='#SBD'><p>Shape-based distance</p></a></li>
<li><a href='#sdtw'><p>Soft-DTW distance</p></a></li>
<li><a href='#sdtw_cent'><p>Centroid calculation based on soft-DTW</p></a></li>
<li><a href='#shape_extraction'><p>Shape average of several time series</p></a></li>
<li><a href='#SparseDistmat-class'><p>Sparse distance matrix</p></a></li>
<li><a href='#SparseDistmat-generics'><p>Generics for <code>SparseDistmat</code></p></a></li>
<li><a href='#ssdtwclust'><p>A shiny app for semi-supervised DTW-based clustering</p></a></li>
<li><a href='#TADPole'><p>TADPole clustering</p></a></li>
<li><a href='#tsclust'><p>Time series clustering</p></a></li>
<li><a href='#tsclust-controls'><p>Control parameters for clusterings with <code>tsclust()</code></p></a></li>
<li><a href='#TSClusters-class'><p>Class definition for <code>TSClusters</code> and derived classes</p></a></li>
<li><a href='#tsclusters-methods'><p>Methods for <code>TSClusters</code></p></a></li>
<li><a href='#tsclustFamily-class'><p>Class definition for <code>tsclustFamily</code></p></a></li>
<li><a href='#tslist'><p>Coerce matrices or data frames to a list of time series</p></a></li>
<li><a href='#uciCT'><p>Subset of character trajectories data set</p></a></li>
<li><a href='#zscore'><p>Wrapper for z-normalization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Clustering Along with Optimizations for the Dynamic
Time Warping Distance</td>
</tr>
<tr>
<td>Description:</td>
<td>Time series clustering along with optimized techniques related
    to the Dynamic Time Warping distance and its corresponding lower bounds.
    Implementations of partitional, hierarchical, fuzzy, k-Shape and TADPole
    clustering are available. Functionality can be easily extended with
    custom distance measures and centroid definitions. Implementations of
    DTW barycenter averaging, a distance based on global alignment kernels,
    and the soft-DTW distance and centroid routines are also provided. 
    All included distance functions have custom loops optimized for the 
    calculation of cross-distance matrices, including parallelization support.
    Several cluster validity indices are included.</td>
</tr>
<tr>
<td>Version:</td>
<td>6.0.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), methods, proxy (&ge; 0.4-16), dtw</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, stats, utils, clue, cluster, dplyr, flexclust,
foreach, ggplot2, ggrepel, rlang, Matrix (&ge; 1.5-0), RSpectra,
Rcpp, RcppParallel (&ge; 4.4.0), reshape2, shiny, shinyjs</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel, RcppThread</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, iterators, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexis Sarda-Espinosa</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexis Sarda &lt;alexis.sarda@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/asardaes/dtwclust/issues">https://github.com/asardaes/dtwclust/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/asardaes/dtwclust">https://github.com/asardaes/dtwclust</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'CENTROIDS-dba.R' 'CENTROIDS-pam.R' 'CENTROIDS-sdtw-cent.R'
'CENTROIDS-shape-extraction.R' 'CLUSTERING-all-cent2.R'
'CLUSTERING-compare-clusterings.R'
'CLUSTERING-cvi-evaluators.R' 'CLUSTERING-ddist2.R'
'CLUSTERING-partitional-fuzzy.R'
'CLUSTERING-repeat-clustering.R' 'CLUSTERING-tadpole.R'
'CLUSTERING-tsclust-controls.R' 'CLUSTERING-tsclust.R'
'DISTANCES-dtw-basic.R' 'DISTANCES-dtw-lb.R' 'DISTANCES-dtw2.R'
'DISTANCES-gak.R' 'DISTANCES-lb-improved.R'
'DISTANCES-lb-keogh.R' 'DISTANCES-sbd.R' 'DISTANCES-sdtw.R'
'GENERICS-cvi.R' 'RD-helpers.R' 'S4-Distmat.R'
'S4-DistmatLowerTriangular.R' 'S4-PairTracker.R'
'S4-SparseDistmat.R' 'S4-tsclustFamily.R'
'S4-TSClusters-classes.R' 'S4-TSClusters-methods.R'
'SHINY-interactive-clustering.R' 'SHINY-ssdtwclust.R'
'SHINY-utils.R' 'UTILS-as-methods.R' 'UTILS-compute-envelope.R'
'UTILS-data.R' 'UTILS-expressions.R' 'UTILS-globals-internal.R'
'UTILS-nccc.R' 'UTILS-reinterpolate.R' 'UTILS-rng.R'
'UTILS-tslist.R' 'UTILS-utils.R' 'UTILS-zscore.R' 'pkg.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-20 11:27:44 UTC; oso</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-23 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dtwclust-package'>Time series clustering along with optimizations for the Dynamic Time Warping distance</h2><span id='topic+dtwclust'></span><span id='topic+dtwclust-package'></span>

<h3>Description</h3>

<p>Time series clustering with a wide variety of strategies and a series of optimizations specific
to the Dynamic Time Warping (DTW) distance and its corresponding lower bounds (LBs).
</p>


<h3>Details</h3>

<p>Many of the algorithms implemented in this package are specifically tailored to DTW, hence its
name. However, the main clustering function is flexible so that one can test many different
clustering approaches, using either the time series directly, or by applying suitable
transformations and then clustering in the resulting space. Other implementations included in the
package provide some alternatives to DTW.
</p>
<p>DTW is a dynamic programming algorithm that tries to find the optimum warping path between two
series. Over the years, several variations have appeared in order to make the procedure faster or
more efficient. Please refer to the included references for more information, especially Giorgino
(2009), which is a good practical introduction.
</p>
<p>Most optimizations require equal dimensionality, which means time series should have equal
length. DTW itself does not require this, but it is relatively expensive to compute. Other
distance definitions may be used, or series could be reinterpolated to a matching length
(Ratanamahatana and Keogh 2004).
</p>
<p>The main clustering function and entry point for this package is <code><a href="#topic+tsclust">tsclust()</a></code>, with a convenience
wrapper for multiple tests in <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>, and a shiny app in
<code><a href="#topic+interactive_clustering">interactive_clustering()</a></code>. There is another less-general-purpose shiny app in <code><a href="#topic+ssdtwclust">ssdtwclust()</a></code>.
</p>
<p>Please note the random number generator is set to L'Ecuyer-CMRG when <span class="pkg">dtwclust</span> is attached
in an attempt to preserve reproducibility. You are free to change this afterwards if you wish
(see <code><a href="base.html#topic+Random">base::RNGkind()</a></code>), but <span class="pkg">dtwclust</span> will always use L'Ecuyer-CMRG internally.
</p>
<p>For more information, please read the included package vignettes, which can be accessed by typing
<code>browseVignettes("dtwclust")</code>.
</p>


<h3>Note</h3>

<p>This software package was developed independently of any organization or institution that is or
has been associated with the author.
</p>
<p>This package can be used without attaching it with <code><a href="base.html#topic+library">base::library()</a></code> with some caveats:
</p>

<ul>
<li><p> The <span class="pkg">methods</span> <a href="methods.html#topic+methods-package">package</a> must be attached. <code>R</code> usually does this
automatically, but <code><a href="utils.html#topic+Rscript">utils::Rscript()</a></code> only does so in R versions 3.5.0 and above.
</p>
</li>
<li><p> If you want to use the <span class="pkg">proxy</span> version of <code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code> (e.g. for clustering), you have to
attach the <span class="pkg">dtw</span> package manually.
</p>
</li></ul>

<p>Be careful with reproducibility, <code>R</code>'s random number generator is only changed session-wide if
<span class="pkg">dtwclust</span> is attached.
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>References</h3>

<p>Please refer to the package's vignette's references.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsclust">tsclust()</a></code>, <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>, <code><a href="#topic+interactive_clustering">interactive_clustering()</a></code>, <code><a href="#topic+ssdtwclust">ssdtwclust()</a></code>, <code><a href="#topic+dtw_basic">dtw_basic()</a></code>,
<code><a href="proxy.html#topic+dist">proxy::dist()</a></code>.
</p>

<hr>
<h2 id='as.matrix'>as.matrix</h2><span id='topic+as.matrix'></span>

<h3>Description</h3>

<p><span class="pkg">proxy</span> exported a non-generic <code>as.matrix</code> function. This is to re-export the base version
and add coercion methods for <code>pairdist</code> and <code>crossdist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix_+3A_x">x</code>, <code id="as.matrix_+3A_...">...</code></td>
<td>
<p>See <code><a href="base.html#topic+matrix">base::as.matrix()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+matrix">base::as.matrix()</a></code>
</p>

<hr>
<h2 id='compare_clusterings'>Compare different clustering configurations</h2><span id='topic+compare_clusterings'></span>

<h3>Description</h3>

<p>Compare many different clustering algorithms with support for parallelization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_clusterings(
  series = NULL,
  types = c("p", "h", "f", "t"),
  configs = compare_clusterings_configs(types),
  seed = NULL,
  trace = FALSE,
  ...,
  score.clus = function(...) stop("No scoring"),
  pick.clus = function(...) stop("No picking"),
  shuffle.configs = FALSE,
  return.objects = FALSE,
  packages = character(0L),
  .errorhandling = "stop"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_clusterings_+3A_series">series</code></td>
<td>
<p>A list of series, a numeric matrix or a data frame. Matrices and data frames are
coerced to a list row-wise (see <code><a href="#topic+tslist">tslist()</a></code>).</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_types">types</code></td>
<td>
<p>Clustering types. It must be any combination of (possibly abbreviated):
&quot;partitional&quot;, &quot;hierarchical&quot;, &quot;fuzzy&quot;, &quot;tadpole.&quot;</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_configs">configs</code></td>
<td>
<p>The list of data frames with the desired configurations to run. See
<code><a href="#topic+pdc_configs">pdc_configs()</a></code> and <code><a href="#topic+compare_clusterings_configs">compare_clusterings_configs()</a></code>.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_seed">seed</code></td>
<td>
<p>Seed for random reproducibility.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_trace">trace</code></td>
<td>
<p>Logical indicating that more output should be printed to screen.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_...">...</code></td>
<td>
<p>Further arguments for <code><a href="#topic+tsclust">tsclust()</a></code>, <code>score.clus</code> or <code>pick.clus</code>.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_score.clus">score.clus</code></td>
<td>
<p>A function that gets the list of results (and <code>...</code>) and scores each one. It
may also be a named list of functions, one for each type of clustering. See Scoring section.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_pick.clus">pick.clus</code></td>
<td>
<p>A function to pick the best result. See Picking section.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_shuffle.configs">shuffle.configs</code></td>
<td>
<p>Randomly shuffle the order of configs, which can be useful to balance load
when using parallel computation.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_return.objects">return.objects</code></td>
<td>
<p>Logical indicating whether the objects returned by <code><a href="#topic+tsclust">tsclust()</a></code> should be
given in the result.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_packages">packages</code></td>
<td>
<p>A character vector with the names of any packages needed for any functions used
(distance, centroid, preprocessing, etc.). The name &quot;dtwclust&quot; is added automatically. Relevant
for parallel computation.</p>
</td></tr>
<tr><td><code id="compare_clusterings_+3A_.errorhandling">.errorhandling</code></td>
<td>
<p>This will be passed to <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>. See Parallel section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+tsclust">tsclust()</a></code> with different configurations and evaluates the results with the
provided functions. Parallel support is included. See the examples.
</p>
<p>Parameters specified in <code>configs</code> whose values are <code>NA</code> will be ignored automatically.
</p>
<p>The scoring and picking functions are for convenience, if they are not specified, the <code>scores</code>
and <code>pick</code> elements of the result will be <code>NULL</code>.
</p>
<p>See <code><a href="#topic+repeat_clustering">repeat_clustering()</a></code> for when <code>return.objects = FALSE</code>.
</p>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>results</code>: A list of data frames with the flattened configs and the corresponding scores
returned by <code>score.clus</code>.
</p>
</li>
<li> <p><code>scores</code>: The scores given by <code>score.clus</code>.
</p>
</li>
<li> <p><code>pick</code>: The object returned by <code>pick.clus</code>.
</p>
</li>
<li> <p><code>proc_time</code>: The measured execution time, using <code><a href="base.html#topic+proc.time">base::proc.time()</a></code>.
</p>
</li>
<li> <p><code>seeds</code>: A list of lists with the random seeds computed for each configuration.
</p>
</li></ul>

<p>The cluster objects are also returned if <code>return.objects</code> <code>=</code> <code>TRUE</code>.
</p>


<h3>Parallel computation</h3>

<p>The configurations for each clustering type can be evaluated in parallel (multi-processing)
with the <span class="pkg">foreach</span> package. A parallel backend can be registered, e.g., with
<span class="pkg">doParallel</span>.
</p>
<p>If the <code>.errorhandling</code> parameter is changed to &quot;pass&quot; and a custom <code>score.clus</code> function is
used, said function should be able to deal with possible error objects.
</p>
<p>If it is changed to &quot;remove&quot;, it might not be possible to attach the scores to the results data
frame, or it may be inconsistent. Additionally, if <code>return.objects</code> is <code>TRUE</code>, the names given
to the objects might also be inconsistent.
</p>
<p>Parallelization can incur a lot of deep copies of data when returning the cluster objects,
since each one will contain a copy of <code>datalist</code>. If you want to avoid this, consider
specifying <code>score.clus</code> and setting <code>return.objects</code> to <code>FALSE</code>, and then using
<code><a href="#topic+repeat_clustering">repeat_clustering()</a></code>.
</p>


<h3>Scoring</h3>

<p>The clustering results are organized in a <em>list of lists</em> in the following way (where only
applicable <code>types</code> exist; first-level list names in bold):
</p>

<ul>
<li> <p><strong>partitional</strong> - list with
</p>

<ul>
<li><p> Clustering results from first partitional config
</p>
</li>
<li><p> etc.
</p>
</li></ul>

</li>
<li> <p><strong>hierarchical</strong> - list with
</p>

<ul>
<li><p> Clustering results from first hierarchical config
</p>
</li>
<li><p> etc.
</p>
</li></ul>

</li>
<li> <p><strong>fuzzy</strong> - list with
</p>

<ul>
<li><p> Clustering results from first fuzzy config
</p>
</li>
<li><p> etc.
</p>
</li></ul>

</li>
<li> <p><strong>tadpole</strong> - list with
</p>

<ul>
<li><p> Clustering results from first tadpole config
</p>
</li>
<li><p> etc.
</p>
</li></ul>

</li></ul>

<p>If <code>score.clus</code> is a function, it will be applied to the available partitional, hierarchical,
fuzzy and/or tadpole results via:
</p>
<div class="sourceCode"><pre>scores &lt;- lapply(list_of_lists, score.clus, ...)
</pre></div>
<p>Otherwise, <code>score.clus</code> should be a list of functions with the same names as the list above, so
that <code>score.clus$partitional</code> is used to score <code>list_of_lists$partitional</code> and so on (via
<code><a href="base.html#topic+funprog">base::Map()</a></code>).
</p>
<p>Therefore, the scores returned shall always be a list of lists with first-level names as above.
</p>


<h3>Picking</h3>

<p>If <code>return.objects</code> is <code>TRUE</code>, the results' data frames and the list of <a href="#topic+TSClusters-class">TSClusters</a>
objects are given to <code>pick.clus</code> as first and second arguments respectively, followed by <code>...</code>.
Otherwise, <code>pick.clus</code> will receive only the data frames and the contents of <code>...</code> (since the
objects will not be returned by the preceding step).
</p>


<h3>Limitations</h3>

<p>Note that the configurations returned by the helper functions assign special names to
preprocessing/distance/centroid arguments, and these names are used internally to recognize
them.
</p>
<p>If some of these arguments are more complex (e.g. matrices) and should <em>not</em> be expanded,
consider passing them directly via the ellipsis (<code>...</code>) instead of using <code><a href="#topic+pdc_configs">pdc_configs()</a></code>. This
assumes that said arguments can be passed to all functions without affecting their results.
</p>
<p>The distance matrices (if calculated) are not re-used across configurations. Given the way the
configurations are created, this shouldn't matter, because clusterings with arguments that can
use the same distance matrix are already grouped together by <code><a href="#topic+compare_clusterings_configs">compare_clusterings_configs()</a></code>
and <code><a href="#topic+pdc_configs">pdc_configs()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare_clusterings_configs">compare_clusterings_configs()</a></code>, <code><a href="#topic+tsclust">tsclust()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fuzzy preprocessing: calculate autocorrelation up to 50th lag
acf_fun &lt;- function(series, ...) {
    lapply(series, function(x) {
        as.numeric(acf(x, lag.max = 50, plot = FALSE)$acf)
    })
}

# Define overall configuration
cfgs &lt;- compare_clusterings_configs(
    types = c("p", "h", "f", "t"),
    k = 19L:20L,
    controls = list(
        partitional = partitional_control(
            iter.max = 30L,
            nrep = 1L
        ),
        hierarchical = hierarchical_control(
            method = "all"
        ),
        fuzzy = fuzzy_control(
            # notice the vector
            fuzziness = c(2, 2.5),
            iter.max = 30L
        ),
        tadpole = tadpole_control(
            # notice the vectors
            dc = c(1.5, 2),
            window.size = 19L:20L
        )
    ),
    preprocs = pdc_configs(
        type = "preproc",
        # shared
        none = list(),
        zscore = list(center = c(FALSE)),
        # only for fuzzy
        fuzzy = list(
            acf_fun = list()
        ),
        # only for tadpole
        tadpole = list(
            reinterpolate = list(new.length = 205L)
        ),
        # specify which should consider the shared ones
        share.config = c("p", "h")
    ),
    distances = pdc_configs(
        type = "distance",
        sbd = list(),
        fuzzy = list(
            L2 = list()
        ),
        share.config = c("p", "h")
    ),
    centroids = pdc_configs(
        type = "centroid",
        partitional = list(
            pam = list()
        ),
        # special name 'default'
        hierarchical = list(
            default = list()
        ),
        fuzzy = list(
            fcmdd = list()
        ),
        tadpole = list(
            default = list(),
            shape_extraction = list(znorm = TRUE)
        )
    )
)

# Number of configurations is returned as attribute
num_configs &lt;- sapply(cfgs, attr, which = "num.configs")
cat("\nTotal number of configurations without considering optimizations:",
    sum(num_configs),
    "\n\n")

# Define evaluation functions based on CVI: Variation of Information (only crisp partition)
vi_evaluators &lt;- cvi_evaluators("VI", ground.truth = CharTrajLabels)
score_fun &lt;- vi_evaluators$score
pick_fun &lt;- vi_evaluators$pick

# ====================================================================================
# Short run with only fuzzy clustering
# ====================================================================================

comparison_short &lt;- compare_clusterings(CharTraj, types = c("f"), configs = cfgs,
                                        seed = 293L, trace = TRUE,
                                        score.clus = score_fun, pick.clus = pick_fun,
                                        return.objects = TRUE)

## Not run: 
# ====================================================================================
# Parallel run with all comparisons
# ====================================================================================

require(doParallel)
registerDoParallel(cl &lt;- makeCluster(detectCores()))

comparison_long &lt;- compare_clusterings(CharTraj, types = c("p", "h", "f", "t"),
                                       configs = cfgs,
                                       seed = 293L, trace = TRUE,
                                       score.clus = score_fun,
                                       pick.clus = pick_fun,
                                       return.objects = TRUE)

# Using all external CVIs and majority vote
external_evaluators &lt;- cvi_evaluators("external", ground.truth = CharTrajLabels)
score_external &lt;- external_evaluators$score
pick_majority &lt;- external_evaluators$pick

comparison_majority &lt;- compare_clusterings(CharTraj, types = c("p", "h", "f", "t"),
                                           configs = cfgs,
                                           seed = 84L, trace = TRUE,
                                           score.clus = score_external,
                                           pick.clus = pick_majority,
                                           return.objects = TRUE)

# best results
plot(comparison_majority$pick$object)
print(comparison_majority$pick$config)

stopCluster(cl); registerDoSEQ()

# ====================================================================================
# A run with only partitional clusterings
# ====================================================================================

p_cfgs &lt;- compare_clusterings_configs(
    types = "p", k = 19L:21L,
    controls = list(
        partitional = partitional_control(
            iter.max = 20L,
            nrep = 8L
        )
    ),
    preprocs = pdc_configs(
        "preproc",
        none = list(),
        zscore = list(center = c(FALSE, TRUE))
    ),
    distances = pdc_configs(
        "distance",
        sbd = list(),
        dtw_basic = list(window.size = 19L:20L,
                         norm = c("L1", "L2")),
        gak = list(window.size = 19L:20L,
                   sigma = 100)
    ),
    centroids = pdc_configs(
        "centroid",
        partitional = list(
            pam = list(),
            shape = list()
        )
    )
)

# Remove redundant (shape centroid always uses zscore preprocessing)
id_redundant &lt;- p_cfgs$partitional$preproc == "none" &amp;
    p_cfgs$partitional$centroid == "shape"
p_cfgs$partitional &lt;- p_cfgs$partitional[!id_redundant, ]

# LONG! 30 minutes or so, sequentially
comparison_partitional &lt;- compare_clusterings(CharTraj, types = "p",
                                              configs = p_cfgs,
                                              seed = 32903L, trace = TRUE,
                                              score.clus = score_fun,
                                              pick.clus = pick_fun,
                                              shuffle.configs = TRUE,
                                              return.objects = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_clusterings_configs'>Create clustering configurations.</h2><span id='topic+compare_clusterings_configs'></span>

<h3>Description</h3>

<p>Create configurations for <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_clusterings_configs(
  types = c("p", "h", "f"),
  k = 2L,
  controls = NULL,
  preprocs = pdc_configs("preproc", none = list()),
  distances = pdc_configs("distance", dtw_basic = list()),
  centroids = pdc_configs("centroid", default = list()),
  no.expand = character(0L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_clusterings_configs_+3A_types">types</code></td>
<td>
<p>Clustering types. It must be any combination of (possibly abbreviated): partitional,
hierarchical, fuzzy, tadpole.</p>
</td></tr>
<tr><td><code id="compare_clusterings_configs_+3A_k">k</code></td>
<td>
<p>A numeric vector with one or more elements specifying the number of clusters to test.</p>
</td></tr>
<tr><td><code id="compare_clusterings_configs_+3A_controls">controls</code></td>
<td>
<p>A named list of <a href="#topic+tsclust-controls">tsclust-controls</a>. <code>NULL</code> means defaults. See details.</p>
</td></tr>
<tr><td><code id="compare_clusterings_configs_+3A_preprocs">preprocs</code></td>
<td>
<p>Preprocessing configurations. See details.</p>
</td></tr>
<tr><td><code id="compare_clusterings_configs_+3A_distances">distances</code></td>
<td>
<p>Distance configurations. See details.</p>
</td></tr>
<tr><td><code id="compare_clusterings_configs_+3A_centroids">centroids</code></td>
<td>
<p>Centroid configurations. See details.</p>
</td></tr>
<tr><td><code id="compare_clusterings_configs_+3A_no.expand">no.expand</code></td>
<td>
<p>A character vector indicating parameters that should <em>not</em> be expanded between
<code><a href="#topic+pdc_configs">pdc_configs()</a></code> configurations. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preprocessing, distance and centroid configurations are specified with the helper function
<code><a href="#topic+pdc_configs">pdc_configs()</a></code>, refer to the examples in <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> to see how this is used.
</p>
<p>The controls list may be specified with the usual <a href="#topic+tsclust-controls">tsclust-controls</a> functions. The names of the
list must correspond to &quot;partitional&quot;, &quot;hierarchical&quot;, &quot;fuzzy&quot; or &quot;tadpole&quot; clustering. Again,
please refer to the examples in <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>.
</p>


<h3>Value</h3>

<p>A list for each clustering type, each of which includes a data frame with the computed and merged
configurations. Each data frame has an extra attribute <code>num.configs</code> specifying the number of
configurations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# compare this with leaving no.expand empty
compare_clusterings_configs(
    distances = pdc_configs("d", dtw_basic = list(window.size = 1L:2L, norm = c("L1", "L2"))),
    centroids = pdc_configs("c", dba = list(window.size = 1L:2L, norm = c("L1", "L2"))),
    no.expand = c("window.size", "norm")
)

</code></pre>

<hr>
<h2 id='compute_envelope'>Time series warping envelopes</h2><span id='topic+compute_envelope'></span>

<h3>Description</h3>

<p>This function computes the envelopes for DTW lower bound calculations with a Sakoe-Chiba band for
a given univariate time series using the streaming algorithm proposed by Lemire (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_envelope(x, window.size, error.check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_envelope_+3A_x">x</code></td>
<td>
<p>A univariate time series.</p>
</td></tr>
<tr><td><code id="compute_envelope_+3A_window.size">window.size</code></td>
<td>
<p>Window size for envelope calculation. See details.</p>
</td></tr>
<tr><td><code id="compute_envelope_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>A list with two elements (lower and upper envelopes respectively): <code>lower</code> and <code>upper</code>.
</p>


<h3>Note</h3>

<p>This envelope is calculated assuming a Sakoe-Chiba constraint for DTW.
</p>


<h3>References</h3>

<p>Lemire D (2009). &ldquo;Faster retrieval with a two-pass dynamic-time-warping lower bound .&rdquo; <em>Pattern
Recognition</em>, <strong>42</strong>(9), pp. 2169 - 2180. ISSN 0031-3203,
<a href="https://doi.org/10.1016/j.patcog.2008.11.030">doi:10.1016/j.patcog.2008.11.030</a>,
<a href="https://www.sciencedirect.com/science/article/pii/S0031320308004925">https://www.sciencedirect.com/science/article/pii/S0031320308004925</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uciCT)

H &lt;- compute_envelope(CharTraj[[1L]], 18L)

matplot(do.call(cbind, H), type = "l", col = 2:3)
lines(CharTraj[[1L]])

</code></pre>

<hr>
<h2 id='cvi'>Cluster validity indices</h2><span id='topic+cvi'></span><span id='topic+cvi+2Cmatrix-method'></span><span id='topic+cvi+2CPartitionalTSClusters-method'></span><span id='topic+cvi+2CPartitionalTSClusters'></span><span id='topic+cvi+2CHierarchicalTSClusters-method'></span><span id='topic+cvi+2CHierarchicalTSClusters'></span><span id='topic+cvi+2CFuzzyTSClusters-method'></span><span id='topic+cvi+2CFuzzyTSClusters'></span>

<h3>Description</h3>

<p>Compute different cluster validity indices (CVIs) of a given cluster partition, using the
clustering distance measure and centroid function if applicable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvi(a, b = NULL, type = "valid", ..., log.base = 10)

## S4 method for signature 'matrix'
cvi(a, b = NULL, type = "valid", ..., log.base = 10)

## S4 method for signature 'PartitionalTSClusters'
cvi(a, b = NULL, type = "valid", ..., log.base = 10)

## S4 method for signature 'HierarchicalTSClusters'
cvi(a, b = NULL, type = "valid", ..., log.base = 10)

## S4 method for signature 'FuzzyTSClusters'
cvi(a, b = NULL, type = "valid", ..., log.base = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvi_+3A_a">a</code></td>
<td>
<p>An object returned by <code><a href="#topic+tsclust">tsclust()</a></code>, for crisp partitions a vector that can be coerced to
integers which indicate the cluster memberships, or the membership matrix for soft clustering.</p>
</td></tr>
<tr><td><code id="cvi_+3A_b">b</code></td>
<td>
<p>If needed, a vector that can be coerced to integers which indicate the cluster
memberships. The ground truth (if known) should be provided here.</p>
</td></tr>
<tr><td><code id="cvi_+3A_type">type</code></td>
<td>
<p>Character vector indicating which indices are to be computed. See supported values
below.</p>
</td></tr>
<tr><td><code id="cvi_+3A_...">...</code></td>
<td>
<p>Arguments to pass to and from other methods.</p>
</td></tr>
<tr><td><code id="cvi_+3A_log.base">log.base</code></td>
<td>
<p>Base of the logarithm to be used in the calculation of VI (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clustering is commonly considered to be an unsupervised procedure, so evaluating its performance
can be rather subjective. However, a great amount of effort has been invested in trying to
standardize cluster evaluation metrics by using cluster validity indices (CVIs).
</p>
<p>In general, CVIs can be either tailored to crisp or fuzzy partitions. CVIs can be classified as
internal, external or relative depending on how they are computed. Focusing on the first two, the
crucial difference is that internal CVIs only consider the partitioned data and try to define a
measure of cluster purity, whereas external CVIs compare the obtained partition to the correct
one. Thus, external CVIs can only be used if the ground truth is known.
</p>
<p>Note that even though a fuzzy partition can be changed into a crisp one, making it compatible
with many of the existing crisp CVIs, there are also fuzzy CVIs tailored specifically to fuzzy
clustering, and these may be more suitable in those situations. Fuzzy partitions usually have no
ground truth associated with them, but there are exceptions depending on the task's goal.
</p>
<p>Each index defines their range of values and whether they are to be minimized or maximized. In
many cases, these CVIs can be used to evaluate the result of a clustering algorithm regardless of
how the clustering works internally, or how the partition came to be.
</p>
<p>Knowing which CVI will work best cannot be determined a priori, so they should be tested for each
specific application. Usually, many CVIs are utilized and compared to each other, maybe using a
majority vote to decide on a final result. Furthermore, it should be noted that many CVIs perform
additional distance calculations when being computed, which can be very considerable if using DTW
or GAK.
</p>


<h3>Value</h3>

<p>The chosen CVIs.
</p>


<h3>External CVIs</h3>


<ul>
<li><p> Crisp partitions (the first 4 are calculated via <code><a href="flexclust.html#topic+randIndex">flexclust::comPart()</a></code>)
</p>

<ul>
<li> <p><code>"RI"</code>: Rand Index (to be maximized).
</p>
</li>
<li> <p><code>"ARI"</code>: Adjusted Rand Index (to be maximized).
</p>
</li>
<li> <p><code>"J"</code>: Jaccard Index (to be maximized).
</p>
</li>
<li> <p><code>"FM"</code>: Fowlkes-Mallows (to be maximized).
</p>
</li>
<li> <p><code>"VI"</code>: Variation of Information (Meila (2003); to be minimized).
</p>
</li></ul>

</li>
<li><p> Fuzzy partitions (based on Lei et al. (2017))
</p>

<ul>
<li> <p><code>"RI"</code>: Soft Rand Index (to be maximized).
</p>
</li>
<li> <p><code>"ARI"</code>: Soft Adjusted Rand Index (to be maximized).
</p>
</li>
<li> <p><code>"VI"</code>: Soft Variation of Information (to be minimized).
</p>
</li>
<li> <p><code>"NMIM"</code>: Soft Normalized Mutual Information based on Max entropy (to be maximized).
</p>
</li></ul>

</li></ul>



<h3>Internal CVIs</h3>

<p>The indices marked with an exclamation mark (!) calculate (or re-use if already available) the
whole distance matrix between the series in the data. If you were trying to avoid this in the
first place, then these CVIs might not be suitable for your application.
</p>
<p>The indices marked with a question mark (?) depend on the extracted centroids, so bear that in
mind if a hierarchical procedure was used and/or the centroid function has associated
randomness (such as <code><a href="#topic+shape_extraction">shape_extraction()</a></code> with series of different length).
</p>
<p>The indices marked with a tilde (~) require the calculation of a global centroid. Since <code><a href="#topic+DBA">DBA()</a></code>
and <code><a href="#topic+shape_extraction">shape_extraction()</a></code> (for series of different length) have some randomness associated,
these indices might not be appropriate for those centroids.
</p>

<ul>
<li><p> Crisp partitions
</p>

<ul>
<li> <p><code>"Sil"</code> (!): Silhouette index (Rousseeuw (1987); to be maximized).
</p>
</li>
<li> <p><code>"D"</code> (!): Dunn index (Arbelaitz et al. (2013); to be maximized).
</p>
</li>
<li> <p><code>"COP"</code> (!): COP index (Arbelaitz et al. (2013); to be minimized).
</p>
</li>
<li> <p><code>"DB"</code> (?): Davies-Bouldin index (Arbelaitz et al. (2013); to be minimized).
</p>
</li>
<li> <p><code>"DBstar"</code> (?): Modified Davies-Bouldin index (DB*) (Kim and Ramakrishna (2005); to be
minimized).
</p>
</li>
<li> <p><code>"CH"</code> (~): Calinski-Harabasz index (Arbelaitz et al. (2013); to be maximized).
</p>
</li>
<li> <p><code>"SF"</code> (~): Score Function (Saitta et al. (2007); to be maximized; see notes).
</p>
</li></ul>

</li>
<li><p> Fuzzy partitions (using the nomenclature from Wang and Zhang (2007))
</p>

<ul>
<li> <p><code>"MPC"</code>: to be maximized.
</p>
</li>
<li> <p><code>"K"</code> (~): to be minimized.
</p>
</li>
<li> <p><code>"T"</code>: to be minimized.
</p>
</li>
<li> <p><code>"SC"</code> (~): to be maximized.
</p>
</li>
<li> <p><code>"PBMF"</code> (~): to be maximized (see notes).
</p>
</li></ul>

</li></ul>



<h3>Additionally</h3>


<ul>
<li> <p><code>"valid"</code>: Returns all valid indices depending on the type of <code>a</code> and whether <code>b</code> was
provided or not.
</p>
</li>
<li> <p><code>"internal"</code>: Returns all internal CVIs. Only supported for <a href="#topic+TSClusters-class">TSClusters</a> objects.
</p>
</li>
<li> <p><code>"external"</code>: Returns all external CVIs. Requires <code>b</code> to be provided.
</p>
</li></ul>



<h3>Note</h3>

<p>In the original definition of many internal and fuzzy CVIs, the Euclidean distance and a mean
centroid was used. <strong>The implementations here change this, making use of whatever
distance/centroid was chosen during clustering</strong>. However, some of the CVIs assume that the
distances are symmetric, since cross-distance matrices are calculated and only the upper/lower
triangulars are considered. A warning will be given if the matrices are not symmetric and the CVI
assumes so.
</p>
<p>Because of the above, calculating CVIs for clusterings made with <code><a href="#topic+TADPole">TADPole()</a></code> is a special case.
Since TADPole uses 3 distances during its execution (DTW, LB_Keogh and Euclidean), it is not
obvious which one should be used for the calculation of CVIs. Nevertheless, <code><a href="#topic+dtw_basic">dtw_basic()</a></code> is used
by default.
</p>
<p>The formula for the SF index in Saitta et al. (2007) does not correspond to the one in Arbelaitz
et al. (2013). The one specified in the former is used here.
</p>
<p>The formulas for the Silhouette index are not entirely correct in Arbelaitz et al. (2013), refer
to Rousseeuw (1987) for the correct ones.
</p>
<p>The formulas for the PBMF index are not entirely unambiguous in the literature, the ones given in
Lin (2013) are used here.
</p>


<h3>References</h3>

<p>Arbelaitz, O., Gurrutxaga, I., Muguerza, J., Perez, J. M., &amp; Perona, I. (2013). An extensive
comparative study of cluster validity indices. Pattern Recognition, 46(1), 243-256.
</p>
<p>Kim, M., &amp; Ramakrishna, R. S. (2005). New indices for cluster validity assessment. Pattern
Recognition Letters, 26(15), 2353-2363.
</p>
<p>Lei, Y., Bezdek, J. C., Chan, J., Vinh, N. X., Romano, S., &amp; Bailey, J. (2017). Extending
information-theoretic validity indices for fuzzy clustering. IEEE Transactions on Fuzzy Systems,
25(4), 1013-1018.
</p>
<p>Lin, H. Y. (2013). Effective Feature Selection for Multi-class Classification Models. In
Proceedings of the World Congress on Engineering (Vol. 3).
</p>
<p>Meila, M. (2003). Comparing clusterings by the variation of information. In Learning theory and
kernel machines (pp. 173-187). Springer Berlin Heidelberg.
</p>
<p>Rousseeuw, P. J. (1987). Silhouettes: a graphical aid to the interpretation and validation of
cluster analysis. Journal of computational and applied mathematics, 20, 53-65.
</p>
<p>Saitta, S., Raphael, B., &amp; Smith, I. F. (2007). A bounded index for cluster validity. In
International Workshop on Machine Learning and Data Mining in Pattern Recognition (pp. 174-187).
Springer Berlin Heidelberg.
</p>
<p>Wang, W., &amp; Zhang, Y. (2007). On fuzzy cluster validity indices. Fuzzy sets and systems, 158(19),
2095-2117.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cvi(CharTrajLabels, sample(CharTrajLabels), type = c("ARI", "VI"))

</code></pre>

<hr>
<h2 id='cvi_evaluators'>Cluster comparison based on CVIs</h2><span id='topic+cvi_evaluators'></span>

<h3>Description</h3>

<p>Create evaluation functions for <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvi_evaluators(type = "valid", fuzzy = FALSE, ground.truth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvi_evaluators_+3A_type">type</code></td>
<td>
<p>A character vector with options supported by <code><a href="#topic+cvi">cvi()</a></code>.</p>
</td></tr>
<tr><td><code id="cvi_evaluators_+3A_fuzzy">fuzzy</code></td>
<td>
<p>Logical indicating whether to use fuzzy CVIs or not.</p>
</td></tr>
<tr><td><code id="cvi_evaluators_+3A_ground.truth">ground.truth</code></td>
<td>
<p>A vector that can be coerced to integers used for the calculation of external
CVIs (passed as <code>b</code> to <code><a href="#topic+cvi">cvi()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Think of this as a factory for <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> that creates functions that can be passed
as its <code>score.clus</code> and <code>pick.clus</code> arguments. It is somewhat limited in scope because it depends
on the cluster validity indices available in <code><a href="#topic+cvi">cvi()</a></code> for scoring and performs <em>majority voting</em>
for picking. They always assume that no errors occurred.
</p>
<p>The scoring function takes the CVIs that are to be minimized and &quot;inverts&quot; them by taking their
reciprocal so that maximization can be considered uniformly for the purpose of majority voting.
Its ellipsis (<code>...</code>) is passed to <code><a href="#topic+cvi">cvi()</a></code>.
</p>
<p>The picking function returns the best configuration if <code>return.objects</code> is <code>FALSE</code>, or a list
with the chosen <a href="#topic+TSClusters-class">TSClusters</a> object and the corresponding configuration otherwise.
</p>
<p>Refer to the examples in <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>.
</p>


<h3>Value</h3>

<p>A list with two functions: <code>score</code> and <code>pick</code>.
</p>


<h3>Note</h3>

<p>To avoid ambiguity, if this function is used, configurations for both fuzzy and crisp clusterings
should <em>not</em> be provided in the same call to <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>. In such cases the scoring
function may fail entirely, e.g. if it was created with <code>type = "valid"</code>.
</p>

<hr>
<h2 id='DBA'>DTW Barycenter Averaging</h2><span id='topic+DBA'></span><span id='topic+dba'></span>

<h3>Description</h3>

<p>A global averaging method for time series under DTW (Petitjean, Ketterlin and Gancarski 2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBA(
  X,
  centroid = NULL,
  ...,
  window.size = NULL,
  norm = "L1",
  max.iter = 20L,
  delta = 0.001,
  error.check = TRUE,
  trace = FALSE,
  mv.ver = "by-variable"
)

dba(
  X,
  centroid = NULL,
  ...,
  window.size = NULL,
  norm = "L1",
  max.iter = 20L,
  delta = 0.001,
  error.check = TRUE,
  trace = FALSE,
  mv.ver = "by-variable"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBA_+3A_x">X</code></td>
<td>
<p>A matrix or data frame where each row is a time series, or a list where each element is
a time series. Multivariate series should be provided as a list of matrices where time spans
the rows and the variables span the columns of each matrix.</p>
</td></tr>
<tr><td><code id="DBA_+3A_centroid">centroid</code></td>
<td>
<p>Optionally, a time series to use as reference. Defaults to a random series of <code>X</code>
if <code>NULL</code>. For multivariate series, this should be a matrix with the same characteristics as
the matrices in <code>X</code>.</p>
</td></tr>
<tr><td><code id="DBA_+3A_...">...</code></td>
<td>
<p>Further arguments for <code><a href="#topic+dtw_basic">dtw_basic()</a></code>. However, the following are already pre-
specified: <code>window.size</code>, <code>norm</code> (passed along), and <code>backtrack</code>.</p>
</td></tr>
<tr><td><code id="DBA_+3A_window.size">window.size</code></td>
<td>
<p>Window constraint for the DTW calculations. <code>NULL</code> means no constraint. A
slanted band is used.</p>
</td></tr>
<tr><td><code id="DBA_+3A_norm">norm</code></td>
<td>
<p>Norm for the local cost matrix of DTW. Either &quot;L1&quot; for Manhattan distance or &quot;L2&quot; for
Euclidean distance.</p>
</td></tr>
<tr><td><code id="DBA_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="DBA_+3A_delta">delta</code></td>
<td>
<p>At iteration <code>i</code>, if <code style="white-space: pre;">&#8288;all(abs(centroid_{i}&#8288;</code> <code>-</code> <code style="white-space: pre;">&#8288;centroid_{i-1})&#8288;</code> <code style="white-space: pre;">&#8288;&lt; delta)&#8288;</code>,
convergence is assumed.</p>
</td></tr>
<tr><td><code id="DBA_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
<tr><td><code id="DBA_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code>, the current iteration is printed to output.</p>
</td></tr>
<tr><td><code id="DBA_+3A_mv.ver">mv.ver</code></td>
<td>
<p>Multivariate version to use. See below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to find the optimum average series between a group of time series in DTW
space. Refer to the cited article for specific details on the algorithm.
</p>
<p>If a given series reference is provided in <code>centroid</code>, the algorithm should always converge to
the same result provided the elements of <code>X</code> keep the same values, although their order may
change.
</p>
<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>The average time series.
</p>


<h3>Parallel Computing</h3>

<p>Please note that running tasks in parallel does <strong>not</strong> guarantee faster computations.
The overhead introduced is sometimes too large, and it's better to run tasks sequentially.
</p>
<p>This function uses the <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a> package for parallelization.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>
<p>This function appears to be very sensitive to numerical inaccuracies if multi-threading is used
in a <strong>32 bit</strong> installation. In such systems, consider limiting calculations to 1 thread.
</p>


<h3>Multivariate series</h3>

<p>There are currently 2 versions of DBA implemented for multivariate series (see examples):
</p>

<ul>
<li><p> If <code>mv.ver = "by-variable"</code>, then each variable of each series in <code>X</code> and <code>centroid</code> are
extracted, and the univariate version of the algorithm is applied to each set of variables,
binding the results by column. Therefore, the DTW backtracking is different for each variable.
</p>
</li>
<li><p> If <code>mv.ver = "by-series"</code>, then all variables are considered at the same time, so the DTW
backtracking is computed based on each multivariate series as a whole. This version was
implemented in version 4.0.0 of <span class="pkg">dtwclust</span>, and it is faster, but not necessarily more
correct.
</p>
</li></ul>



<h3>Note</h3>

<p>The indices of the DTW alignment are obtained by calling <code><a href="#topic+dtw_basic">dtw_basic()</a></code> with <code>backtrack = TRUE</code>.
</p>


<h3>References</h3>

<p>Petitjean F, Ketterlin A and Gancarski P (2011). &ldquo;A global averaging method for dynamic time
warping, with applications to clustering.&rdquo; <em>Pattern Recognition</em>, <strong>44</strong>(3), pp. 678 - 693. ISSN
0031-3203, <a href="https://doi.org/10.1016/j.patcog.2010.09.013">doi:10.1016/j.patcog.2010.09.013</a>,
<a href="https://www.sciencedirect.com/science/article/pii/S003132031000453X">https://www.sciencedirect.com/science/article/pii/S003132031000453X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample data
data(uciCT)

# Obtain an average for the first 5 time series
dtw_avg &lt;- DBA(CharTraj[1:5], CharTraj[[1]], trace = TRUE)

# Plot
matplot(do.call(cbind, CharTraj[1:5]), type = "l")
points(dtw_avg)

# Change the provided order
dtw_avg2 &lt;- DBA(CharTraj[5:1], CharTraj[[1]], trace = TRUE)

# Same result?
all.equal(dtw_avg, dtw_avg2)

## Not run: 
# ====================================================================================
# Multivariate versions
# ====================================================================================

# sample centroid reference
cent &lt;- CharTrajMV[[3L]]
# sample series
x &lt;- CharTrajMV[[1L]]
# sample set of series
X &lt;- CharTrajMV[1L:5L]

# the by-series version does something like this for each series and the centroid
alignment &lt;- dtw_basic(x, cent, backtrack = TRUE)
# alignment$index1 and alginment$index2 indicate how to map x to cent (row-wise)

# the by-variable version treats each variable separately
alignment1 &lt;- dtw_basic(x[,1L], cent[,1L], backtrack = TRUE)
alignment2 &lt;- dtw_basic(x[,2L], cent[,2L], backtrack = TRUE)
alignment3 &lt;- dtw_basic(x[,3L], cent[,3L], backtrack = TRUE)

# effectively doing:
X1 &lt;- lapply(X, function(x) { x[,1L] })
X2 &lt;- lapply(X, function(x) { x[,2L] })
X3 &lt;- lapply(X, function(x) { x[,3L] })

dba1 &lt;- dba(X1, cent[,1L])
dba2 &lt;- dba(X2, cent[,2L])
dba3 &lt;- dba(X3, cent[,3L])

new_cent &lt;- cbind(dba1, dba2, dba3)

# sanity check
newer_cent &lt;- dba(X, cent, mv.ver = "by-variable")
all.equal(newer_cent, new_cent, check.attributes = FALSE) # ignore names


## End(Not run)
</code></pre>

<hr>
<h2 id='Distmat-class'>Distance matrix</h2><span id='topic+Distmat-class'></span><span id='topic+Distmat'></span>

<h3>Description</h3>

<p>Reference class that is used internally for cross-distance matrices.
</p>


<h3>Fields</h3>


<dl>
<dt><code>distmat</code></dt><dd><p>A distance matrix.</p>
</dd>
<dt><code>series</code></dt><dd><p>Time series list.</p>
</dd>
<dt><code>distfun</code></dt><dd><p>The distance function to calculate the distance matrix.</p>
</dd>
<dt><code>dist_args</code></dt><dd><p>Arguments for the distance function.</p>
</dd>
<dt><code>id_cent</code></dt><dd><p>Indices of the centroids (if any).</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>initialize(..., distmat, series, distance, control, error.check = TRUE)</code></dt><dd><p>Initialization based on needed parameters</p>
</dd>
</dl>

<hr>
<h2 id='Distmat-generics'>Generics for <code>Distmat</code></h2><span id='topic+Distmat-generics'></span><span id='topic++5B+2CDistmat+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CDistmat+2CANY+2CANY+2CANY'></span>

<h3>Description</h3>

<p>Generics with methods for <a href="#topic+Distmat-class">Distmat</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Distmat,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Distmat-generics_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+Distmat-class">Distmat</a> object.</p>
</td></tr>
<tr><td><code id="Distmat-generics_+3A_i">i</code></td>
<td>
<p>Row indices.</p>
</td></tr>
<tr><td><code id="Distmat-generics_+3A_j">j</code></td>
<td>
<p>Column indices.</p>
</td></tr>
<tr><td><code id="Distmat-generics_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="Distmat-generics_+3A_drop">drop</code></td>
<td>
<p>Logical to drop dimensions after subsetting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accessing matrix elements with <code style="white-space: pre;">&#8288;[]&#8288;</code> first calculates the values if necessary.
</p>

<hr>
<h2 id='DistmatLowerTriangular-class'>Distance matrix's lower triangular</h2><span id='topic+DistmatLowerTriangular-class'></span><span id='topic+DistmatLowerTriangular'></span>

<h3>Description</h3>

<p>Reference class that is used internally for PAM centroids when <code>pam.precompute = TRUE</code> and
<code>pam.sparse = FALSE</code>. It contains <a href="#topic+Distmat-class">Distmat</a>.
</p>


<h3>Details</h3>

<p>If you wish to, you can use this class to access <code>dist</code> elements with <code>[</code> as if it were a normal
matrix. You can use <a href="methods.html#topic+new">methods::new</a> passing the <code>dist</code> object in a <code>distmat</code> argument.
</p>


<h3>Fields</h3>


<dl>
<dt><code>distmat</code></dt><dd><p>The lower triangular.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>initialize(..., distmat, series, distance, control, error.check = TRUE)</code></dt><dd><p>Initialization based on needed parameters</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
dm &lt;- new("DistmatLowerTriangular",
          distmat = proxy::dist(CharTraj[1:5], method = "gak", sigma = 5.5, window.size = 10L))

dm[2:3, 4:5]

</code></pre>

<hr>
<h2 id='DistmatLowerTriangular-generics'>Generics for <code>DistmatLowerTriangular</code></h2><span id='topic+DistmatLowerTriangular-generics'></span><span id='topic+show+2CDistmatLowerTriangular-method'></span><span id='topic+show+2CDistmatLowerTriangular'></span><span id='topic++5B+2CDistmatLowerTriangular+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CDistmatLowerTriangular+2CANY+2CANY+2CANY'></span>

<h3>Description</h3>

<p>Generics with methods for <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DistmatLowerTriangular'
show(object)

## S4 method for signature 'DistmatLowerTriangular,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DistmatLowerTriangular-generics_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a> object.</p>
</td></tr>
<tr><td><code id="DistmatLowerTriangular-generics_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a> object.</p>
</td></tr>
<tr><td><code id="DistmatLowerTriangular-generics_+3A_i">i</code></td>
<td>
<p>Row indices.</p>
</td></tr>
<tr><td><code id="DistmatLowerTriangular-generics_+3A_j">j</code></td>
<td>
<p>Column indices.</p>
</td></tr>
<tr><td><code id="DistmatLowerTriangular-generics_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='dtw_basic'>Basic DTW distance</h2><span id='topic+dtw_basic'></span>

<h3>Description</h3>

<p>This is a custom implementation of the DTW algorithm without all the functionality included in
<code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code>. Because of that, it should be faster, while still supporting the most common
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw_basic(
  x,
  y,
  window.size = NULL,
  norm = "L1",
  step.pattern = dtw::symmetric2,
  backtrack = FALSE,
  normalize = FALSE,
  sqrt.dist = TRUE,
  ...,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw_basic_+3A_x">x</code>, <code id="dtw_basic_+3A_y">y</code></td>
<td>
<p>Time series. Multivariate series must have time spanning the rows and variables
spanning the columns.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_window.size">window.size</code></td>
<td>
<p>Size for slanted band window. <code>NULL</code> means no constraint.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_norm">norm</code></td>
<td>
<p>Norm for the LCM calculation, &quot;L1&quot; for Manhattan or &quot;L2&quot; for (squared) Euclidean. See
notes.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_step.pattern">step.pattern</code></td>
<td>
<p>Step pattern for DTW. Only <code>symmetric1</code> or <code>symmetric2</code> supported here. Note
that these are <em>not</em> characters. See <a href="dtw.html#topic+stepPattern">dtw::stepPattern</a>.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_backtrack">backtrack</code></td>
<td>
<p>Also compute the warping path between series? See details.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_normalize">normalize</code></td>
<td>
<p>Should the distance be normalized? Only supported for <code>symmetric2</code>.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_sqrt.dist">sqrt.dist</code></td>
<td>
<p>Only relevant for <code>norm = "L2"</code>, see notes.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="dtw_basic_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>backtrack</code> is <code>TRUE</code>, the mapping of indices between series is returned in a list.
</p>
<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>The DTW distance. For <code>backtrack</code> <code>=</code> <code>TRUE</code>, a list with:
</p>

<ul>
<li> <p><code>distance</code>: The DTW distance.
</p>
</li>
<li> <p><code>index1</code>: <code>x</code> indices for the matched elements in the warping path.
</p>
</li>
<li> <p><code>index2</code>: <code>y</code> indices for the matched elements in the warping path.
</p>
</li></ul>



<h3>Proxy version</h3>

<p>The version registered with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> is custom (<code>loop = FALSE</code> in <a href="proxy.html#topic+registry">proxy::pr_DB</a>).
The custom function handles multi-threaded parallelization directly with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a>.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>
<p>It also includes symmetric optimizations to calculate only half a distance matrix when appropriate&mdash;only one list of series should be provided in <code>x</code>.
Starting with version 6.0.0, this optimization means that the function returns an array with the lower triangular values of the distance matrix,
similar to what <code><a href="stats.html#topic+dist">stats::dist()</a></code> does;
see <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a> for a helper to access elements as it if were a normal matrix.
If you want to avoid this optimization, call <a href="proxy.html#topic+dist">proxy::dist</a> by giving the same list of series in both <code>x</code> and <code>y</code>.
</p>
<p>In order for symmetry to apply here, the following must be true: no window constraint is used
(<code>window.size</code> is <code>NULL</code>) or, if one is used, all series have the same length.
</p>


<h3>Note</h3>

<p>The elements of the local cost matrix are calculated by using either Manhattan or squared
Euclidean distance. This is determined by the <code>norm</code> parameter. When the squared Euclidean
version is used, the square root of the resulting DTW distance is calculated at the end (as
defined in Ratanamahatana and Keogh 2004; Lemire 2009; see vignette references). This can be
avoided by passing <code>FALSE</code> in <code>sqrt.dist</code>.
</p>
<p>The DTW algorithm (and the functions that depend on it) might return different values in 32 bit
installations compared to 64 bit ones.
</p>
<p>An infinite distance value indicates that the constraints could not be fulfilled, probably due to
a too small <code>window.size</code> or a very large length difference between the series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# ====================================================================================
# Understanding multivariate DTW
# ====================================================================================

# The variables for each multivariate time series are:
# tip force, x velocity, and y velocity
A1 &lt;- CharTrajMV[[1L]] # A character
B1 &lt;- CharTrajMV[[6L]] # B character

# Let's extract univariate time series
A1_TipForce &lt;- A1[,1L] # first variable (column)
A1_VelX &lt;- A1[,2L] # second variable (column)
A1_VelY &lt;- A1[,3L] # third variable (column)
B1_TipForce &lt;- B1[,1L] # first variable (column)
B1_VelX &lt;- B1[,2L] # second variable (column)
B1_VelY &lt;- B1[,3L] # third variable (column)

# Looking at each variable independently:

# Just force
dtw_basic(A1_TipForce, B1_TipForce, norm = "L1", step.pattern = symmetric1)
# Corresponding LCM
proxy::dist(A1_TipForce, B1_TipForce, method = "L1")

# Just x velocity
dtw_basic(A1_VelX, B1_VelX, norm = "L1", step.pattern = symmetric1)
# Corresponding LCM
proxy::dist(A1_VelX, B1_VelX, method = "L1")

# Just y velocity
dtw_basic(A1_VelY, B1_VelY, norm = "L1", step.pattern = symmetric1)
# Corresponding LCM
proxy::dist(A1_VelY, B1_VelY, method = "L1")

# NOTES:
# In the previous examples there was one LCM for each *pair* of series.
# Additionally, each LCM has dimensions length(A1_*) x length(B1_*)

# proxy::dist won't return the LCM for multivariate series,
# but we can do it manually:
mv_lcm &lt;- function(mvts1, mvts2) {
    # Notice how the number of variables (columns) doesn't come into play here
    num_obs1 &lt;- nrow(mvts1)
    num_obs2 &lt;- nrow(mvts2)

    lcm &lt;- matrix(0, nrow = num_obs1, ncol = num_obs2)

    for (i in 1L:num_obs1) {
        for (j in 1L:num_obs2) {
            # L1 norm for ALL variables (columns).
            # Consideration: mvts1 and mvts2 MUST have the same number of variables
            lcm[i, j] &lt;- sum(abs(mvts1[i,] - mvts2[j,]))
        }
    }

    # return
    lcm
}

# Let's say we start with only x velocity and y velocity for each character
mvts1 &lt;- cbind(A1_VelX, A1_VelY)
mvts2 &lt;- cbind(B1_VelX, B1_VelY)

# DTW distance
dtw_d &lt;- dtw_basic(mvts1, mvts2, norm = "L1", step.pattern = symmetric1)
# Corresponding LCM
lcm &lt;- mv_lcm(mvts1, mvts2) # still 178 x 174
# Sanity check
all.equal(
    dtw_d,
    dtw::dtw(lcm, step.pattern = symmetric1)$distance # supports LCM as input
)

# Now let's consider all variables for each character
mvts1 &lt;- cbind(mvts1, A1_TipForce)
mvts2 &lt;- cbind(mvts2, B1_TipForce)

# Notice how the next code is exactly the same as before,
# even though we have one extra variable now

# DTW distance
dtw_d &lt;- dtw_basic(mvts1, mvts2, norm = "L1", step.pattern = symmetric1)
# Corresponding LCM
lcm &lt;- mv_lcm(mvts1, mvts2) # still 178 x 174
# Sanity check
all.equal(
    dtw_d,
    dtw::dtw(lcm, step.pattern = symmetric1)$distance # supports LCM as input
)

# By putting things in a list,
# proxy::dist returns the *cross-distance matrix*, not the LCM
series_list &lt;- list(mvts1, mvts2)
distmat &lt;- proxy::dist(series_list, method = "dtw_basic",
                       norm = "L1", step.pattern = symmetric1)
# So this should be TRUE
all.equal(distmat[1L, 2L], dtw_d)

# NOTE: distmat is a 2 x 2 matrix, because there are 2 multivariate series.
# Each *cell* in distmat has a corresponding LCM (not returned by the function).
# Proof:
manual_distmat &lt;- matrix(0, nrow = 2L, ncol = 2L)
for (i in 1L:nrow(manual_distmat)) {
    for (j in 1L:ncol(manual_distmat)) {
        lcm_cell &lt;- mv_lcm(series_list[[i]], series_list[[j]]) # LCM for this pair
        manual_distmat[i, j] &lt;- dtw::dtw(lcm_cell, step.pattern = symmetric1)$distance
    }
}
# TRUE
all.equal(
    as.matrix(distmat),
    manual_distmat
)

## End(Not run)
</code></pre>

<hr>
<h2 id='dtw_lb'>DTW distance matrix guided by Lemire's improved lower bound</h2><span id='topic+dtw_lb'></span>

<h3>Description</h3>

<p>Calculation of a distance matrix with the Dynamic Time Warping (DTW) distance guided by Lemire's
improved lower bound (LB_Improved).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw_lb(
  x,
  y = NULL,
  window.size = NULL,
  norm = "L1",
  error.check = TRUE,
  pairwise = FALSE,
  dtw.func = "dtw_basic",
  nn.margin = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw_lb_+3A_x">x</code>, <code id="dtw_lb_+3A_y">y</code></td>
<td>
<p>A matrix or data frame where rows are time series, or a list of time series.</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_window.size">window.size</code></td>
<td>
<p>Window size to use with the LB and DTW calculation. See details.</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_norm">norm</code></td>
<td>
<p>Either <code>"L1"</code> for Manhattan distance or <code>"L2"</code> for Euclidean.</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_pairwise">pairwise</code></td>
<td>
<p>Calculate pairwise distances?</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_dtw.func">dtw.func</code></td>
<td>
<p>Which function to use for the core DTW calculations, either &quot;dtw&quot; or &quot;dtw_basic&quot;.
See <code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code> and <code><a href="#topic+dtw_basic">dtw_basic()</a></code>.</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_nn.margin">nn.margin</code></td>
<td>
<p>Either 1 to search for nearest neighbors row-wise, or 2 to search column-wise.
Only implemented for <code>dtw.func</code> = &quot;dtw_basic&quot;.</p>
</td></tr>
<tr><td><code id="dtw_lb_+3A_...">...</code></td>
<td>
<p>Further arguments for <code>dtw.func</code> or <code><a href="#topic+lb_improved">lb_improved()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first calculates an initial estimate of a distance matrix between two sets of time
series using <code><a href="#topic+lb_improved">lb_improved()</a></code> (the <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> version). Afterwards, it uses the estimate to
calculate the corresponding true DTW distance between <em>only</em> the nearest neighbors of each series
in <code>x</code> found in <code>y</code>, and it continues iteratively until no changes in the nearest neighbors
occur.
</p>
<p>If only <code>x</code> is provided, the distance matrix is calculated between all its time series,
effectively returning a matrix filled with the LB_Improved values.
</p>
<p>This could be useful in case one is interested in only the nearest neighbor of one or more series
within a dataset.
</p>
<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>The distance matrix with class <code>crossdist</code>.
</p>


<h3>Parallel Computing</h3>

<p>Please note that running tasks in parallel does <strong>not</strong> guarantee faster computations.
The overhead introduced is sometimes too large, and it's better to run tasks sequentially.
</p>
<p>This function uses the <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a> package for parallelization.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>


<h3>Note</h3>

<p>This function uses a lower bound that is only defined for time series of equal length.
</p>
<p>The <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> version simply calls this function.
</p>
<p>A considerably large dataset is probably necessary before this is faster than using <code><a href="#topic+dtw_basic">dtw_basic()</a></code>
with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>. Also note that <code><a href="#topic+lb_improved">lb_improved()</a></code> calculates warping envelopes for the series
in <code>y</code>, so be careful with the provided order and <code>nn.margin</code> (see examples).
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>References</h3>

<p>Lemire D (2009). &ldquo;Faster retrieval with a two-pass dynamic-time-warping lower bound .&rdquo; <em>Pattern
Recognition</em>, <strong>42</strong>(9), pp. 2169 - 2180. ISSN 0031-3203,
<a href="https://doi.org/10.1016/j.patcog.2008.11.030">doi:10.1016/j.patcog.2008.11.030</a>,
<a href="https://www.sciencedirect.com/science/article/pii/S0031320308004925">https://www.sciencedirect.com/science/article/pii/S0031320308004925</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lb_keogh">lb_keogh()</a></code>, <code><a href="#topic+lb_improved">lb_improved()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data(uciCT)

# Reinterpolate to same length
data &lt;- reinterpolate(CharTraj, new.length = max(lengths(CharTraj)))

# Calculate the DTW distance between a certain subset aided with the lower bound
system.time(d &lt;- dtw_lb(data[1:5], data[6:50], window.size = 20L))

# Nearest neighbors
NN1 &lt;- apply(d, 1L, which.min)

# Calculate the DTW distances between all elements (slower)
system.time(d2 &lt;- proxy::dist(data[1:5], data[6:50], method = "DTW",
                              window.type = "sakoechiba", window.size = 20L))

# Nearest neighbors
NN2 &lt;- apply(d2, 1L, which.min)

# Calculate the DTW distances between all elements using dtw_basic
# (might be faster, see notes)
system.time(d3 &lt;- proxy::dist(data[1:5], data[6:50], method = "DTW_BASIC",
                              window.size = 20L))

# Nearest neighbors
NN3 &lt;- apply(d3, 1L, which.min)

# Change order and margin for nearest neighbor search
# (usually fastest, see notes)
system.time(d4 &lt;- dtw_lb(data[6:50], data[1:5],
                         window.size = 20L, nn.margin = 2L))

# Nearest neighbors *column-wise*
NN4 &lt;- apply(d4, 2L, which.min)

# Same results?
identical(NN1, NN2)
identical(NN1, NN3)
identical(NN1, NN4)

</code></pre>

<hr>
<h2 id='dtw2'>DTW distance with L2 norm</h2><span id='topic+dtw2'></span>

<h3>Description</h3>

<p>Wrapper for the <code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code> function using L2 norm for both the local cost matrix (LCM) creation
as well as the final cost aggregation step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtw2(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dtw2_+3A_x">x</code>, <code id="dtw2_+3A_y">y</code></td>
<td>
<p>A time series. A multivariate series should have time spanning the rows and variables
spanning the columns.</p>
</td></tr>
<tr><td><code id="dtw2_+3A_...">...</code></td>
<td>
<p>Further arguments for <code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The L-norms are used in two different steps by the DTW algorithm. First when creating the LCM,
where the element <code class="reqn">(i,j)</code> of the matrix is computed as the L-norm of <code class="reqn">x^v_i - y^v_j</code> for
all variables <code class="reqn">v</code>. Note that this means that, in case of multivariate series, they must have
the same number of variables, and that univariate series will produce the same LCM regardless of
the L-norm used. After the warping path is found by DTW, the final distance is calculated as the
L-norm of all <code class="reqn">(i,j)</code> elements of the LCM that fall on the warping path.
</p>
<p>The <code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code> function allows changing the norm by means of its <code>dist.method</code> parameter, but
it only uses it when creating the LCM, and not when calculating the final aggregated cost, i.e.
the DTW distance.
</p>
<p>This wrapper simply returns the appropriate DTW distance using L2 norm (Euclidean norm). A
<code><a href="proxy.html#topic+dist">proxy::dist()</a></code> version is also registered.
</p>
<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>An object of class <code>dtw</code>.
</p>

<hr>
<h2 id='dtwclustTimings'>Results of timing experiments</h2><span id='topic+dtwclustTimings'></span>

<h3>Description</h3>

<p>This is the list with data frames containing the results of the timing experiments vignette
included with <span class="pkg">dtwclust</span>. See <code>browseVignettes("dtwclust")</code>.
</p>


<h3>Format</h3>

<p>The results are organized into different data frames and saved in one list with nested lists.
For more details, refer to the included vignette or the scripts available at
<a href="https://github.com/asardaes/dtwclust/tree/master/timing-experiments">https://github.com/asardaes/dtwclust/tree/master/timing-experiments</a>.
</p>


<h3>Source</h3>

<p>Refer to the timing experiments vignette.
</p>

<hr>
<h2 id='explore__plot'>This helper will produce the plot in the Explore tab panel.</h2><span id='topic+explore__plot'></span>

<h3>Description</h3>

<p>This helper will produce the plot in the Explore tab panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore__plot(ids, df, series)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explore__plot_+3A_ids">ids</code></td>
<td>
<p>A character with the expression that should yield the integer ids.</p>
</td></tr>
<tr><td><code id="explore__plot_+3A_df">df</code></td>
<td>
<p>The data frame with the melted time series.</p>
</td></tr>
<tr><td><code id="explore__plot_+3A_series">series</code></td>
<td>
<p>The list of time series.</p>
</td></tr>
</table>

<hr>
<h2 id='explore__tidy_series'>This helper will create the data frame used to plot in the Explore tab panel</h2><span id='topic+explore__tidy_series'></span>

<h3>Description</h3>

<p>This helper will create the data frame used to plot in the Explore tab panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore__tidy_series(series)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explore__tidy_series_+3A_series">series</code></td>
<td>
<p>The list of time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>

<hr>
<h2 id='GAK'>Fast global alignment kernels</h2><span id='topic+GAK'></span><span id='topic+gak'></span>

<h3>Description</h3>

<p>Distance based on (triangular) global alignment kernels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAK(
  x,
  y,
  ...,
  sigma = NULL,
  window.size = NULL,
  normalize = TRUE,
  error.check = TRUE
)

gak(
  x,
  y,
  ...,
  sigma = NULL,
  window.size = NULL,
  normalize = TRUE,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GAK_+3A_x">x</code>, <code id="GAK_+3A_y">y</code></td>
<td>
<p>Time series. A multivariate series should have time spanning the rows and variables
spanning the columns.</p>
</td></tr>
<tr><td><code id="GAK_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="GAK_+3A_sigma">sigma</code></td>
<td>
<p>Parameter for the Gaussian kernel's width. See details for the interpretation of
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="GAK_+3A_window.size">window.size</code></td>
<td>
<p>Parameterization of the constraining band (<em>T</em> in Cuturi (2011)). See details.</p>
</td></tr>
<tr><td><code id="GAK_+3A_normalize">normalize</code></td>
<td>
<p>Normalize the result by considering diagonal terms.</p>
</td></tr>
<tr><td><code id="GAK_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the Triangular Global Alignment Kernel (TGAK) described in Cuturi (2011). It
supports series of different length and multivariate series, so long as the ratio of the series'
lengths doesn't differ by more than 2 (or less than 0.5).
</p>
<p>The <code>window.size</code> parameter is similar to the one used in DTW, so <code>NULL</code> signifies no constraint,
and its value should be greater than 1 if used with series of different length.
</p>
<p>The Gaussian kernel is parameterized by <code>sigma</code>. Providing <code>NULL</code> means that the value will be
estimated by using the strategy mentioned in Cuturi (2011) with a constant of 1. This estimation
is subject to <strong>randomness</strong>, so consider estimating the value once and re-using it (the estimate
is returned as an attribute of the result). See the examples.
</p>
<p>For more information, refer to the package vignette and the referenced article.
</p>


<h3>Value</h3>

<p>The logarithm of the GAK if <code>normalize = FALSE</code>, otherwise 1 minus the normalized GAK. The value
of <code>sigma</code> is assigned as an attribute of the result.
</p>


<h3>Proxy version</h3>

<p>The version registered with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> is custom (<code>loop = FALSE</code> in <a href="proxy.html#topic+registry">proxy::pr_DB</a>).
The custom function handles multi-threaded parallelization directly with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a>.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>
<p>It also includes symmetric optimizations to calculate only half a distance matrix when appropriate&mdash;only one list of series should be provided in <code>x</code>.
Starting with version 6.0.0, this optimization means that the function returns an array with the lower triangular values of the distance matrix,
similar to what <code><a href="stats.html#topic+dist">stats::dist()</a></code> does;
see <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a> for a helper to access elements as it if were a normal matrix.
If you want to avoid this optimization, call <a href="proxy.html#topic+dist">proxy::dist</a> by giving the same list of series in both <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>The estimation of <code>sigma</code> does <em>not</em> depend on <code>window.size</code>.
</p>
<p>If <code>normalize</code> is set to <code>FALSE</code>, the returned value is <strong>not</strong> a distance, rather a similarity.
The <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> version is thus always normalized. Use <code><a href="proxy.html#topic+dist">proxy::simil()</a></code> with <code>method</code> set to
&quot;uGAK&quot; if you want the unnormalized similarities.
</p>
<p>A constrained unnormalized calculation (i.e. with <code>window.size &gt; 0</code> and <code>normalize = FALSE</code>) will
return negative infinity if <code style="white-space: pre;">&#8288;abs(NROW(x)&#8288;</code> <code>-</code> <code style="white-space: pre;">&#8288;NROW(y))&#8288;</code> <code>&gt;</code> <code>window.size</code>. Since the function
won't perform calculations in that case, it might be faster, but if this behavior is not desired,
consider reinterpolating the time series (see <code><a href="#topic+reinterpolate">reinterpolate()</a></code>) or increasing the window size.
</p>


<h3>References</h3>

<p>Cuturi, M. (2011). Fast global alignment kernels. In <em>Proceedings of the 28th international
conference on machine learning (ICML-11)</em> (pp. 929-936).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(uciCT)

set.seed(832)
GAKd &lt;- proxy::dist(zscore(CharTraj), method = "gak",
                    pairwise = TRUE, window.size = 18L)

# Obtained estimate of sigma
sigma &lt;- attr(GAKd, "sigma")

# Use value for clustering
tsclust(CharTraj, k = 20L,
        distance = "gak", centroid = "shape",
        trace = TRUE,
        args = tsclust_args(dist = list(sigma = sigma,
                                        window.size = 18L)))

## End(Not run)

# Unnormalized similarities
proxy::simil(CharTraj[1L:5L], method = "ugak")

</code></pre>

<hr>
<h2 id='interactive_clustering'>A shiny app for interactive clustering</h2><span id='topic+interactive_clustering'></span>

<h3>Description</h3>

<p>Display a shiny user interface to do clustering based on the provided series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactive_clustering(series, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interactive_clustering_+3A_series">series</code></td>
<td>
<p>Time series in the formats accepted by <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</td></tr>
<tr><td><code id="interactive_clustering_+3A_...">...</code></td>
<td>
<p>More arguments for <code><a href="shiny.html#topic+runApp">shiny::runApp()</a></code>.</p>
</td></tr>
</table>


<h3>Explore</h3>

<p>This part of the app is simply to see some basic characteristics of the provided series and
plot some of them. The field for integer IDs expects a valid R expression that specifies which
of the <code>series</code> should be plotted. Multivariate series are plotted with each variable in a
different facet.
</p>


<h3>Cluster</h3>

<p>This part of the app wraps <code><a href="#topic+tsclust">tsclust()</a></code>, so you should be familiar with it. Some remarks:
</p>

<ul>
<li><p> Specifying a custom centroid or hierarchical method expects the name of a function available
in the R session (without quotes). Naturally, any required package should be loaded before
calling <code>interactive_clustering</code>. For example, if you want to use <code><a href="cluster.html#topic+agnes">cluster::agnes()</a></code>, you
should load <span class="pkg">cluster</span> beforehand.
</p>
</li>
<li><p> A random seed of 0 means that it will be left as <code>NULL</code> when calling <code><a href="#topic+tsclust">tsclust()</a></code>.
</p>
</li>
<li><p> The input fields for Extra parameters (distance, centroid and ellipsis) expect a comma-
separated sequence of key-value pairs. For example: <code>window.size = 10L</code>, <code>trace = TRUE</code>. You
should be able to pass any variables available in the R session's global environment.
</p>
</li>
<li><p> Regarding plot parameters:
</p>

<ul>
<li><p> The <code>Clusters</code> field is like the integer IDs from the Explore section.
</p>
</li>
<li><p> The <code>Labels</code> field is passed to the plot method (see <a href="#topic+TSClusters-methods">TSClusters-methods</a>). You can specify
several values like with the Extra parameters, e.g.: <code>nudge_x = 10</code>, <code>nudge_y = 1</code>. You can
type an empty space to activate them with the defaults, and delete everything to hide them.
Note that the location of the labels is random each time.
</p>
</li></ul>

</li></ul>

<p>The plot area reacts to the plot parameters, but the actual clustering with <code><a href="#topic+tsclust">tsclust()</a></code> won't
be executed until you click the <code style="white-space: pre;">&#8288;Cluster!&#8288;</code> button. <strong>The plot can take a couple of seconds to
load!</strong> Plotting multivariate series might generate warnings about missing values, they can be
safely ignored.
</p>
<p>Some of the control parameters are disabled when <span class="pkg">dtwclust</span> detects them automatically.
</p>
<p>The cross-distance matrix is cached so that it can be re-used when appropriate. The cached
version is invalidated automatically when necessary.
</p>


<h3>Evaluate</h3>

<p>This part of the app provides results of the current clustering. External CVIs can be
calculated if the name of a variable with the ground truth is provided (see <code><a href="#topic+cvi">cvi()</a></code>).
</p>


<h3>Note</h3>

<p>Tracing is printed to the console.
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
interactive_clustering(CharTrajMV)

## End(Not run)

</code></pre>

<hr>
<h2 id='lb_improved'>Lemire's improved DTW lower bound</h2><span id='topic+lb_improved'></span>

<h3>Description</h3>

<p>This function calculates an improved lower bound (LB) on the Dynamic Time Warp (DTW) distance
between two time series. It uses a Sakoe-Chiba constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lb_improved(
  x,
  y,
  window.size = NULL,
  norm = "L1",
  lower.env = NULL,
  upper.env = NULL,
  force.symmetry = FALSE,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lb_improved_+3A_x">x</code></td>
<td>
<p>A time series (reference).</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_y">y</code></td>
<td>
<p>A time series with the same length as <code>x</code> (query).</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_window.size">window.size</code></td>
<td>
<p>Window size for envelope calculation. See details.</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_norm">norm</code></td>
<td>
<p>Vector norm. Either <code>"L1"</code> for Manhattan distance or <code>"L2"</code> for Euclidean.</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_lower.env">lower.env</code></td>
<td>
<p>Optionally, a pre-computed lower envelope for <strong><code>y</code></strong> can be provided (non-proxy
version only). See <code><a href="#topic+compute_envelope">compute_envelope()</a></code>.</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_upper.env">upper.env</code></td>
<td>
<p>Optionally, a pre-computed upper envelope for <strong><code>y</code></strong> can be provided (non-proxy
version only). See <code><a href="#topic+compute_envelope">compute_envelope()</a></code>.</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_force.symmetry">force.symmetry</code></td>
<td>
<p>If <code>TRUE</code>, a second lower bound is calculated by swapping <code>x</code> and <code>y</code>, and
whichever result has a <em>higher</em> distance value is returned. The proxy version can only work if
a square matrix is obtained, but use carefully.</p>
</td></tr>
<tr><td><code id="lb_improved_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reference time series should go in <code>x</code>, whereas the query time series should go in <code>y</code>.
</p>
<p>If the envelopes are provided, they should be provided together. If either one is missing, both
will be computed.
</p>
<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>The improved lower bound for the DTW distance.
</p>


<h3>Proxy version</h3>

<p>The version registered with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> is custom (<code>loop = FALSE</code> in <a href="proxy.html#topic+registry">proxy::pr_DB</a>).
The custom function handles multi-threaded parallelization directly with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a>.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>


<h3>Note</h3>

<p>The lower bound is only defined for time series of equal length and is <strong>not</strong> symmetric.
</p>
<p>If you wish to calculate the lower bound between several time series, it would be better to use
the version registered with the <code>proxy</code> package, since it includes some small optimizations. The
convention mentioned above for references and queries still holds. See the examples.
</p>
<p>The proxy version of <code>force.symmetry</code> should only be used when only <code>x</code> is provided or both <code>x</code>
and <code>y</code> are identical. It compares the lower and upper triangular of the resulting distance
matrix and forces symmetry in such a way that the tightest lower bound is obtained.
</p>


<h3>References</h3>

<p>Lemire D (2009). &ldquo;Faster retrieval with a two-pass dynamic-time-warping lower bound .&rdquo; <em>Pattern
Recognition</em>, <strong>42</strong>(9), pp. 2169 - 2180. ISSN 0031-3203,
<a href="https://doi.org/10.1016/j.patcog.2008.11.030">doi:10.1016/j.patcog.2008.11.030</a>,
<a href="https://www.sciencedirect.com/science/article/pii/S0031320308004925">https://www.sciencedirect.com/science/article/pii/S0031320308004925</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data
data(uciCT)

# Lower bound distance between two series
d.lbi &lt;- lb_improved(CharTraj[[1]], CharTraj[[2]], window.size = 20)

# Corresponding true DTW distance
d.dtw &lt;- dtw(CharTraj[[1]], CharTraj[[2]],
             window.type = "sakoechiba", window.size = 20)$distance

d.lbi &lt;= d.dtw

# Calculating the LB between several time series using the 'proxy' package
# (notice how both argments must be lists)
D.lbi &lt;- proxy::dist(CharTraj[1], CharTraj[2:5], method = "LB_Improved",
                     window.size = 20, norm = "L2")

# Corresponding true DTW distance
D.dtw &lt;- proxy::dist(CharTraj[1], CharTraj[2:5], method = "dtw_basic",
                     norm = "L2", window.size = 20)

D.lbi &lt;= D.dtw

</code></pre>

<hr>
<h2 id='lb_keogh'>Keogh's DTW lower bound</h2><span id='topic+lb_keogh'></span>

<h3>Description</h3>

<p>This function calculates a lower bound (LB) on the Dynamic Time Warp (DTW) distance between two
time series. It uses a Sakoe-Chiba constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lb_keogh(
  x,
  y,
  window.size = NULL,
  norm = "L1",
  lower.env = NULL,
  upper.env = NULL,
  force.symmetry = FALSE,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lb_keogh_+3A_x">x</code></td>
<td>
<p>A time series (reference).</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_y">y</code></td>
<td>
<p>A time series with the same length as <code>x</code> (query).</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_window.size">window.size</code></td>
<td>
<p>Window size for envelope calculation. See details.</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_norm">norm</code></td>
<td>
<p>Vector norm. Either <code>"L1"</code> for Manhattan distance or <code>"L2"</code> for Euclidean.</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_lower.env">lower.env</code></td>
<td>
<p>Optionally, a pre-computed lower envelope for <strong><code>y</code></strong> can be provided (non-proxy
version only). See <code><a href="#topic+compute_envelope">compute_envelope()</a></code>.</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_upper.env">upper.env</code></td>
<td>
<p>Optionally, a pre-computed upper envelope for <strong><code>y</code></strong> can be provided (non-proxy
version only). See <code><a href="#topic+compute_envelope">compute_envelope()</a></code>.</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_force.symmetry">force.symmetry</code></td>
<td>
<p>If <code>TRUE</code>, a second lower bound is calculated by swapping <code>x</code> and <code>y</code>, and
whichever result has a <em>higher</em> distance value is returned. The proxy version can only work if
a square matrix is obtained, but use carefully.</p>
</td></tr>
<tr><td><code id="lb_keogh_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reference time series should go in <code>x</code>, whereas the query time series should go in <code>y</code>.
</p>
<p>If the envelopes are provided, they should be provided together. If either one is missing, both
will be computed.
</p>
<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>d</code>: The lower bound of the DTW distance.
</p>
</li>
<li> <p><code>upper.env</code>: The time series of <code>y</code>'s upper envelope.
</p>
</li>
<li> <p><code>lower.env</code>: The time series of <code>y</code>'s lower envelope.
</p>
</li></ul>



<h3>Proxy version</h3>

<p>The version registered with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> is custom (<code>loop = FALSE</code> in <a href="proxy.html#topic+registry">proxy::pr_DB</a>).
The custom function handles multi-threaded parallelization directly with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a>.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>


<h3>Note</h3>

<p>The lower bound is only defined for time series of equal length and is <strong>not</strong> symmetric.
</p>
<p>If you wish to calculate the lower bound between several time series, it would be better to use
the version registered with the <code>proxy</code> package, since it includes some small optimizations. The
convention mentioned above for references and queries still holds. See the examples.
</p>
<p>The proxy version of <code>force.symmetry</code> should only be used when only <code>x</code> is provided or both <code>x</code>
and <code>y</code> are identical. It compares the lower and upper triangular of the resulting distance
matrix and forces symmetry in such a way that the tightest lower bound is obtained.
</p>


<h3>References</h3>

<p>Keogh E and Ratanamahatana CA (2005). &ldquo;Exact indexing of dynamic time warping.&rdquo; <em>Knowledge and
information systems</em>, <strong>7</strong>(3), pp. 358-386.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data
data(uciCT)

# Lower bound distance between two series
d.lbk &lt;- lb_keogh(CharTraj[[1]], CharTraj[[2]], window.size = 20)$d

# Corresponding true DTW distance
d.dtw &lt;- dtw(CharTraj[[1]], CharTraj[[2]],
             window.type = "sakoechiba", window.size = 20)$distance

d.lbk &lt;= d.dtw

# Calculating the LB between several time series using the 'proxy' package
# (notice how both argments must be lists)
D.lbk &lt;- proxy::dist(CharTraj[1], CharTraj[2:5], method = "LB_Keogh",
                     window.size = 20, norm = "L2")

# Corresponding true DTW distance
D.dtw &lt;- proxy::dist(CharTraj[1], CharTraj[2:5], method = "dtw_basic",
                     norm = "L2", window.size = 20)

D.lbk &lt;= D.dtw

</code></pre>

<hr>
<h2 id='NCCc'>Cross-correlation with coefficient normalization</h2><span id='topic+NCCc'></span>

<h3>Description</h3>

<p>This function uses the FFT to compute the cross-correlation sequence between two series. They
need <em>not</em> be of equal length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCCc(x, y, error.check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCCc_+3A_x">x</code>, <code id="NCCc_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="NCCc_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cross-correlation sequence with length <code>length(x) + length(y) - 1L</code>.
</p>


<h3>References</h3>

<p>Paparrizos J and Gravano L (2015). &ldquo;k-Shape: Efficient and Accurate Clustering of Time Series.&rdquo;
In <em>Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</em>, series
SIGMOD '15, pp. 1855-1870. ISBN 978-1-4503-2758-9, <a href="https://doi.org/10.1145/2723372.2737793">doi:10.1145/2723372.2737793</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SBD">SBD()</a></code>
</p>

<hr>
<h2 id='PairTracker-class'>Helper for semi-supervised DTW clustering</h2><span id='topic+PairTracker-class'></span><span id='topic+PairTracker'></span>

<h3>Description</h3>

<p>Helper for semi-supervised DTW clustering
</p>


<h3>Fields</h3>


<dl>
<dt><code>xptr</code></dt><dd><p>External pointer (C++ class). See corresponding file in src/utils/</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>get_unseen_pair()</code></dt><dd><p>Get a pair that is not contained in any graph,
NULL means no unseen pairs left.</p>
</dd>
<dt><code>initialize(max_size)</code></dt><dd><p>Initialization of C++ helper</p>
</dd>
<dt><code>link(i, j, link_type)</code></dt><dd><p>Link indices i and j.
Link types: dont_know = -1, cannot_link = 0, must_link = 1.
Returns TRUE if underlying graph is complete/complete/connected after insertion.</p>
</dd>
</dl>

<hr>
<h2 id='pam_cent'>Centroid for partition around medoids</h2><span id='topic+pam_cent'></span>

<h3>Description</h3>

<p>Extract the medoid time series based on a distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pam_cent(
  series,
  distance,
  ids = seq_along(series),
  distmat = NULL,
  ...,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pam_cent_+3A_series">series</code></td>
<td>
<p>The time series in one of the formats accepted by <code><a href="#topic+tslist">tslist()</a></code>.</p>
</td></tr>
<tr><td><code id="pam_cent_+3A_distance">distance</code></td>
<td>
<p>A character indicating which distance to use. Only needed if <code>distmat</code> is <code>NULL</code>.
The distance must be registered in <code><a href="proxy.html#topic+registry">proxy::pr_DB()</a></code>.</p>
</td></tr>
<tr><td><code id="pam_cent_+3A_ids">ids</code></td>
<td>
<p>Integer vector indicating which of the <code>series</code> should be considered.</p>
</td></tr>
<tr><td><code id="pam_cent_+3A_distmat">distmat</code></td>
<td>
<p>Optionally, a pre-computed cross-distance matrix of <em>all</em> <code>series</code>.</p>
</td></tr>
<tr><td><code id="pam_cent_+3A_...">...</code></td>
<td>
<p>Any extra parameters for the <code>distance</code> function that may be used.</p>
</td></tr>
<tr><td><code id="pam_cent_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The medoid's index is determined by taking the <code class="reqn">arg min</code> of the <code>distmat</code>'s row-sums
(considering only the rows in <code>ids</code>). The distance matrix is calculated if needed.
</p>


<h3>Value</h3>

<p>The medoid time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Computes the distance matrix for all series
pam_cent(CharTraj, "dtw_basic", ids = 6L:10L, window.size = 15L) # series_id = 7L

# Computes the distance matrix for the chosen subset only
pam_cent(CharTraj[6L:10L], "dtw_basic", window.size = 15L) # series_id = 2L

</code></pre>

<hr>
<h2 id='parse_input'>This helper will parse comma-separated key-value pairs</h2><span id='topic+parse_input'></span>

<h3>Description</h3>

<p>This helper will parse comma-separated key-value pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_input(input_text, into = "list")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_input_+3A_input_text">input_text</code></td>
<td>
<p>A character.</p>
</td></tr>
<tr><td><code id="parse_input_+3A_into">into</code></td>
<td>
<p>The name of the function that will contain the resulting values.</p>
</td></tr>
</table>

<hr>
<h2 id='pdc_configs'>Helper function for preprocessing/distance/centroid configurations</h2><span id='topic+pdc_configs'></span>

<h3>Description</h3>

<p>Create preprocessing, distance and centroid configurations for <code><a href="#topic+compare_clusterings_configs">compare_clusterings_configs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdc_configs(
  type = c("preproc", "distance", "centroid"),
  ...,
  partitional = NULL,
  hierarchical = NULL,
  fuzzy = NULL,
  tadpole = NULL,
  share.config = c("p", "h", "f", "t")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdc_configs_+3A_type">type</code></td>
<td>
<p>Which type of function is being targeted by this configuration.</p>
</td></tr>
<tr><td><code id="pdc_configs_+3A_...">...</code></td>
<td>
<p>Any number of named lists with functions and arguments that will be shared by all
clusterings. See details.</p>
</td></tr>
<tr><td><code id="pdc_configs_+3A_partitional">partitional</code></td>
<td>
<p>A named list of lists with functions and arguments for partitional
clusterings.</p>
</td></tr>
<tr><td><code id="pdc_configs_+3A_hierarchical">hierarchical</code></td>
<td>
<p>A named list of lists with functions and arguments for hierarchical
clusterings.</p>
</td></tr>
<tr><td><code id="pdc_configs_+3A_fuzzy">fuzzy</code></td>
<td>
<p>A named list of lists with functions and arguments for fuzzy clusterings.</p>
</td></tr>
<tr><td><code id="pdc_configs_+3A_tadpole">tadpole</code></td>
<td>
<p>A named list of lists with functions and arguments for TADPole clusterings.</p>
</td></tr>
<tr><td><code id="pdc_configs_+3A_share.config">share.config</code></td>
<td>
<p>A character vector specifying which clusterings should include the shared
lists (the ones specified in <code>...</code>). It must be any combination of (possibly abbreviated):
partitional, hierarchical, fuzzy, tadpole.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The named lists are interpreted in the following way: the name of the list will be considered to
be a function name, and the elements of the list will be the possible parameters for the
function. Each function must have at least an empty list. The parameters may be vectors that
specify different values to be tested.
</p>
<p>For preprocessing, the special name <code>none</code> signifies no preprocessing.
</p>
<p>For centroids, the special name <code>default</code> leaves the centroid unspecified.
</p>
<p>Please see the examples in <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> to see how this is used.
</p>


<h3>Value</h3>

<p>A list for each clustering, each of which includes a data frame with the computed configurations.
</p>

<hr>
<h2 id='reinterpolate'>Wrapper for simple linear reinterpolation</h2><span id='topic+reinterpolate'></span>

<h3>Description</h3>

<p>This function is just a wrapper for the native function <code><a href="stats.html#topic+approxfun">stats::approx()</a></code> to do simple linear
reinterpolation. It also supports matrices, data frames, and lists of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reinterpolate(x, new.length, multivariate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reinterpolate_+3A_x">x</code></td>
<td>
<p>Data to reinterpolate. Either a vector, a matrix/data.frame where each row is to be
reinterpolated, or a list of vectors/matrices.</p>
</td></tr>
<tr><td><code id="reinterpolate_+3A_new.length">new.length</code></td>
<td>
<p>Desired length of the output series.</p>
</td></tr>
<tr><td><code id="reinterpolate_+3A_multivariate">multivariate</code></td>
<td>
<p>Is <code>x</code> a multivariate time series? It will be detected automatically if a
list is provided in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate series must have time spanning the rows and variables spanning the columns.
</p>


<h3>Value</h3>

<p>Reinterpolated time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uciCT)

# list of univariate series
series &lt;- reinterpolate(CharTraj, 205L)

# list of multivariate series
series &lt;- reinterpolate(CharTrajMV, 205L)

# single multivariate series
series &lt;- reinterpolate(CharTrajMV[[1L]], 205L, TRUE)

</code></pre>

<hr>
<h2 id='repeat_clustering'>Repeat a clustering configuration</h2><span id='topic+repeat_clustering'></span>

<h3>Description</h3>

<p>Repeat a clustering made with <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> in order to obtain the <a href="#topic+TSClusters-class">TSClusters</a>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeat_clustering(series, clusterings, config_id, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeat_clustering_+3A_series">series</code></td>
<td>
<p>The same time series that were given to <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>.</p>
</td></tr>
<tr><td><code id="repeat_clustering_+3A_clusterings">clusterings</code></td>
<td>
<p>The list returned by <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>.</p>
</td></tr>
<tr><td><code id="repeat_clustering_+3A_config_id">config_id</code></td>
<td>
<p>The character indicating which configuration should be re-computed. Obtained
from the <code>clusterings</code>' <code>results</code>' data frames.</p>
</td></tr>
<tr><td><code id="repeat_clustering_+3A_...">...</code></td>
<td>
<p>More arguments for <code><a href="#topic+tsclust">tsclust()</a></code> (e.g. <code>trace</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the purpose of <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> is to test many configurations, it is desirable to
set its <code>return.objects</code> parameter to <code>FALSE</code> in order to save RAM. This function can then be
used to compute the clustering object for a specific <code>config_id</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+TSClusters-class">TSClusters</a> object.
</p>


<h3>Limitations</h3>

<p>If the preprocessing function is subject to randomness, the clustering will not be correctly
re-created by this function, since <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> applies all preprocessing before
calling <code><a href="#topic+tsclust">tsclust()</a></code>.
</p>
<p>If any parameters were given to <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> through its ellipsis, they should
probably be given to this function too.
</p>

<hr>
<h2 id='SBD'>Shape-based distance</h2><span id='topic+SBD'></span><span id='topic+sbd'></span>

<h3>Description</h3>

<p>Distance based on coefficient-normalized cross-correlation as proposed by Paparrizos and Gravano
(2015) for the k-Shape clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SBD(x, y, znorm = FALSE, error.check = TRUE, return.shifted = TRUE)

sbd(x, y, znorm = FALSE, error.check = TRUE, return.shifted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SBD_+3A_x">x</code>, <code id="SBD_+3A_y">y</code></td>
<td>
<p>Univariate time series.</p>
</td></tr>
<tr><td><code id="SBD_+3A_znorm">znorm</code></td>
<td>
<p>Logical. Should each series be z-normalized before calculating the distance?</p>
</td></tr>
<tr><td><code id="SBD_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
<tr><td><code id="SBD_+3A_return.shifted">return.shifted</code></td>
<td>
<p>Logical. Should the shifted version of <code>y</code> be returned? See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This distance works best if the series are <em>z-normalized</em>. If not, at least they should have
appropriate amplitudes, since the values of the signals <strong>do</strong> affect the outcome.
</p>
<p>If <code>x</code> and <code>y</code> do <strong>not</strong> have the same length, it would be best if the longer sequence is
provided in <code>y</code>, because it will be shifted to match <code>x</code>. After matching, the series may have to
be truncated or extended and padded with zeros if needed.
</p>
<p>The output values lie between 0 and 2, with 0 indicating perfect similarity.
</p>


<h3>Value</h3>

<p>For <code>return.shifted = FALSE</code>, the numeric distance value, otherwise a list with:
</p>

<ul>
<li> <p><code>dist</code>: The shape-based distance between <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>yshift</code>: A shifted version of <code>y</code> so that it optimally matches <code>x</code> (based on <code><a href="#topic+NCCc">NCCc()</a></code>).
</p>
</li></ul>



<h3>Proxy version</h3>

<p>The version registered with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> is custom (<code>loop = FALSE</code> in <a href="proxy.html#topic+registry">proxy::pr_DB</a>).
The custom function handles multi-threaded parallelization directly with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a>.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>
<p>It also includes symmetric optimizations to calculate only half a distance matrix when appropriate&mdash;only one list of series should be provided in <code>x</code>.
Starting with version 6.0.0, this optimization means that the function returns an array with the lower triangular values of the distance matrix,
similar to what <code><a href="stats.html#topic+dist">stats::dist()</a></code> does;
see <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a> for a helper to access elements as it if were a normal matrix.
If you want to avoid this optimization, call <a href="proxy.html#topic+dist">proxy::dist</a> by giving the same list of series in both <code>x</code> and <code>y</code>.
</p>
<p>In some situations, e.g. for relatively small distance matrices, the overhead introduced by the
logic that computes only half the distance matrix can be bigger than just calculating the whole
matrix.
</p>


<h3>Note</h3>

<p>If you wish to calculate the distance between several time series, it would be better to use the
version registered with the <code>proxy</code> package, since it includes some small optimizations. See the
examples.
</p>
<p>This distance is calculated with help of the Fast Fourier Transform, so it can be sensitive to
numerical precision. Thus, this function (and the functions that depend on it) might return
different values in 32 bit installations compared to 64 bit ones.
</p>


<h3>References</h3>

<p>Paparrizos J and Gravano L (2015). &ldquo;k-Shape: Efficient and Accurate Clustering of Time Series.&rdquo;
In <em>Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</em>, series
SIGMOD '15, pp. 1855-1870. ISBN 978-1-4503-2758-9, <a href="https://doi.org/10.1145/2723372.2737793">doi:10.1145/2723372.2737793</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NCCc">NCCc()</a></code>, <code><a href="#topic+shape_extraction">shape_extraction()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data(uciCT)

# distance between series of different lengths
sbd &lt;- SBD(CharTraj[[1]], CharTraj[[100]], znorm = TRUE)$dist

# cross-distance matrix for series subset (notice the two-list input)
sbD &lt;- proxy::dist(CharTraj[1:10], CharTraj[1:10], method = "SBD", znorm = TRUE)

</code></pre>

<hr>
<h2 id='sdtw'>Soft-DTW distance</h2><span id='topic+sdtw'></span>

<h3>Description</h3>

<p>Soft-DTW distance measure as proposed in Cuturi and Blondel (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdtw(x, y, gamma = 0.01, ..., error.check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdtw_+3A_x">x</code>, <code id="sdtw_+3A_y">y</code></td>
<td>
<p>Time series. Multivariate series must have time spanning the rows and variables
spanning the columns.</p>
</td></tr>
<tr><td><code id="sdtw_+3A_gamma">gamma</code></td>
<td>
<p>Positive regularization parameter, with lower values resulting in less smoothing.</p>
</td></tr>
<tr><td><code id="sdtw_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="sdtw_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike other distances, soft-DTW can return negative values, and <code>sdtw(x, x)</code> is not always equal
to zero. Like DTW, soft-DTW does not fulfill the triangle inequality, but it is always symmetric.
</p>


<h3>Value</h3>

<p>The Soft DTW distance.
</p>


<h3>Proxy version</h3>

<p>The version registered with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> is custom (<code>loop = FALSE</code> in <a href="proxy.html#topic+registry">proxy::pr_DB</a>).
The custom function handles multi-threaded parallelization directly with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a>.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>
<p>It also includes symmetric optimizations to calculate only half a distance matrix when appropriate&mdash;only one list of series should be provided in <code>x</code>.
Starting with version 6.0.0, this optimization means that the function returns an array with the lower triangular values of the distance matrix,
similar to what <code><a href="stats.html#topic+dist">stats::dist()</a></code> does;
see <a href="#topic+DistmatLowerTriangular-class">DistmatLowerTriangular</a> for a helper to access elements as it if were a normal matrix.
If you want to avoid this optimization, call <a href="proxy.html#topic+dist">proxy::dist</a> by giving the same list of series in both <code>x</code> and <code>y</code>.
</p>
<p>Note that, due to the fact that this distance is not always zero when a series is compared
against itself, this optimization is likely problematic for soft-DTW, as the <code>dist</code> object will
be handled by many functions as if it had only zeroes in the diagonal. An exception is
<code><a href="#topic+tsclust">tsclust()</a></code> when using partitional clustering with PAM centroids&mdash;actual diagonal values will
be calculated and considered internally in that case.
</p>


<h3>References</h3>

<p>Cuturi, M., &amp; Blondel, M. (2017). Soft-DTW: a Differentiable Loss Function for Time-Series. arXiv
preprint arXiv:1703.01541.
</p>

<hr>
<h2 id='sdtw_cent'>Centroid calculation based on soft-DTW</h2><span id='topic+sdtw_cent'></span>

<h3>Description</h3>

<p>Soft-DTW centroid function as proposed in Cuturi and Blondel (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdtw_cent(
  series,
  centroid = NULL,
  gamma = 0.01,
  weights = rep(1, length(series)),
  ...,
  error.check = TRUE,
  opts = list(algorithm = "NLOPT_LD_LBFGS", maxeval = 20L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdtw_cent_+3A_series">series</code></td>
<td>
<p>A matrix or data frame where each row is a time series, or a list where each
element is a time series. Multivariate series should be provided as a list of matrices where
time spans the rows and the variables span the columns of each matrix.</p>
</td></tr>
<tr><td><code id="sdtw_cent_+3A_centroid">centroid</code></td>
<td>
<p>Optionally, a time series to use as reference. Defaults to a random series of
<code>series</code> if <code>NULL</code>. For multivariate series, this should be a matrix with the same
characteristics as the matrices in <code>series</code>.</p>
</td></tr>
<tr><td><code id="sdtw_cent_+3A_gamma">gamma</code></td>
<td>
<p>Positive regularization parameter, with lower values resulting in less smoothing.</p>
</td></tr>
<tr><td><code id="sdtw_cent_+3A_weights">weights</code></td>
<td>
<p>A vector of weights for each element of <code>series</code>.</p>
</td></tr>
<tr><td><code id="sdtw_cent_+3A_...">...</code></td>
<td>
<p>Further arguments for the optimization backend (except <code>opts</code> for <code>nloptr</code>, <code>control</code>
for <code>optim</code>, and <code>...</code> for both).</p>
</td></tr>
<tr><td><code id="sdtw_cent_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
<tr><td><code id="sdtw_cent_+3A_opts">opts</code></td>
<td>
<p>List of options to pass to <code>nloptr</code> or <code><a href="stats.html#topic+optim">stats::optim()</a></code>'s <code>control</code>. The defaults in
the function's formals are for <code>nloptr</code>, but the value will be adjusted for <code>optim</code> if needed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can delegate the optimization to the <span class="pkg">nloptr</span> package. For that to happen, you
must load it with either <code><a href="base.html#topic+library">base::library()</a></code> or <code><a href="base.html#topic+ns-load">base::loadNamespace()</a></code>. If the aforementioned is
not fulfilled, the function will delegate to <code><a href="stats.html#topic+optim">stats::optim()</a></code>.
</p>


<h3>Value</h3>

<p>The resulting centroid, with the optimization results as attributes (except for the
returned centroid).
</p>


<h3>Parallel Computing</h3>

<p>Please note that running tasks in parallel does <strong>not</strong> guarantee faster computations.
The overhead introduced is sometimes too large, and it's better to run tasks sequentially.
</p>
<p>This function uses the <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a> package for parallelization.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>
<p>For unknown reasons, this function has returned different results (in the order of 1e-6) when
using multi-threading in x64 Windows installations in comparison to other environments (using
nloptr v1.0.4). Consider limiting the number of threads if you run into reproducibility
problems.
</p>


<h3>References</h3>

<p>Cuturi, M., &amp; Blondel, M. (2017). Soft-DTW: a Differentiable Loss Function for Time-Series. arXiv
preprint arXiv:1703.01541.
</p>

<hr>
<h2 id='shape_extraction'>Shape average of several time series</h2><span id='topic+shape_extraction'></span>

<h3>Description</h3>

<p>Time-series shape extraction based on optimal alignments as proposed by Paparrizos and Gravano
(2015) for the k-Shape clustering algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_extraction(X, centroid = NULL, znorm = FALSE, ..., error.check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_extraction_+3A_x">X</code></td>
<td>
<p>A matrix or data frame where each row is a time series, or a list where each element is
a time series. Multivariate series should be provided as a list of matrices where time spans
the rows and the variables span the columns.</p>
</td></tr>
<tr><td><code id="shape_extraction_+3A_centroid">centroid</code></td>
<td>
<p>Optionally, a time series to use as reference. Defaults to a random series of <code>X</code>
if <code>NULL</code>. For multivariate series, this should be a matrix with the same characteristics as
the matrices in <code>X</code>. <strong>It will be z-normalized</strong>.</p>
</td></tr>
<tr><td><code id="shape_extraction_+3A_znorm">znorm</code></td>
<td>
<p>Logical flag. Should z-scores be calculated for <code>X</code> before processing?</p>
</td></tr>
<tr><td><code id="shape_extraction_+3A_...">...</code></td>
<td>
<p>Further arguments for <code><a href="#topic+zscore">zscore()</a></code>.</p>
</td></tr>
<tr><td><code id="shape_extraction_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works only if the series are <em>z-normalized</em>, since the output will also have this
normalization.
</p>
<p>The resulting centroid will have the same length as <code>centroid</code> if provided. Otherwise, there are
two possibilities: if all series from <code>X</code> have the same length, all of them will be used as-is,
and the output will have the same length as the series; if series have different lengths, a
series will be chosen at random and used as reference. The output series will then have the same
length as the chosen series.
</p>
<p>This centroid computation is cast as an optimization problem called maximization of Rayleigh
Quotient. It depends on the <code><a href="#topic+SBD">SBD()</a></code> algorithm. See the cited article for more details.
</p>


<h3>Value</h3>

<p>Centroid time series (z-normalized).
</p>


<h3>References</h3>

<p>Paparrizos J and Gravano L (2015). &ldquo;k-Shape: Efficient and Accurate Clustering of Time Series.&rdquo;
In <em>Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data</em>, series
SIGMOD '15, pp. 1855-1870. ISBN 978-1-4503-2758-9, <a href="https://doi.org/10.1145/2723372.2737793">doi:10.1145/2723372.2737793</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SBD">SBD()</a></code>, <code><a href="#topic+zscore">zscore()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data
data(uciCT)

# Normalize desired subset
X &lt;- zscore(CharTraj[1:5])

# Obtain centroid series
C &lt;- shape_extraction(X)

# Result
matplot(do.call(cbind, X),
        type = "l", col = 1:5)
points(C)

</code></pre>

<hr>
<h2 id='SparseDistmat-class'>Sparse distance matrix</h2><span id='topic+SparseDistmat-class'></span><span id='topic+SparseDistmat'></span>

<h3>Description</h3>

<p>Reference class that is used internally for PAM centroids when <code>pam.precompute = FALSE</code> and
<code>pam.sparse = TRUE</code>. It allows for mutable state. It contains <a href="#topic+Distmat-class">Distmat</a>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>distmat</code></dt><dd><p>The sparse matrix.</p>
</dd>
<dt><code>symmetric</code></dt><dd><p>Logical indicating if the matrix is symmetric.</p>
</dd>
<dt><code>distmat_indices</code></dt><dd><p>External pointer (C++ class) with the indices of existing values within
the matrix, and the method to update them.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>initialize(..., distmat, series, distance, control, error.check = TRUE)</code></dt><dd><p>Initialization based on needed parameters</p>
</dd>
</dl>

<hr>
<h2 id='SparseDistmat-generics'>Generics for <code>SparseDistmat</code></h2><span id='topic+SparseDistmat-generics'></span><span id='topic+show+2CSparseDistmat-method'></span><span id='topic+show+2CSparseDistmat'></span><span id='topic++5B+2CSparseDistmat+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CSparseDistmat+2CANY+2CANY+2CANY'></span>

<h3>Description</h3>

<p>Generics with methods for <a href="#topic+SparseDistmat-class">SparseDistmat</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SparseDistmat'
show(object)

## S4 method for signature 'SparseDistmat,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SparseDistmat-generics_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+SparseDistmat-class">SparseDistmat</a> object.</p>
</td></tr>
<tr><td><code id="SparseDistmat-generics_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+SparseDistmat-class">SparseDistmat</a> object.</p>
</td></tr>
<tr><td><code id="SparseDistmat-generics_+3A_i">i</code></td>
<td>
<p>Row indices.</p>
</td></tr>
<tr><td><code id="SparseDistmat-generics_+3A_j">j</code></td>
<td>
<p>Column indices.</p>
</td></tr>
<tr><td><code id="SparseDistmat-generics_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="SparseDistmat-generics_+3A_drop">drop</code></td>
<td>
<p>Logical to drop dimensions after subsetting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accessing matrix elements with <code style="white-space: pre;">&#8288;[]&#8288;</code> first calculates the values if necessary.
</p>

<hr>
<h2 id='ssdtwclust'>A shiny app for semi-supervised DTW-based clustering</h2><span id='topic+ssdtwclust'></span>

<h3>Description</h3>

<p>Display a shiny user interface that implements the approach in Dau et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssdtwclust(series, ..., complexity = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssdtwclust_+3A_series">series</code></td>
<td>
<p>Time series in the formats accepted by <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>.</p>
</td></tr>
<tr><td><code id="ssdtwclust_+3A_...">...</code></td>
<td>
<p>More arguments for <code><a href="shiny.html#topic+runApp">shiny::runApp()</a></code>.</p>
</td></tr>
<tr><td><code id="ssdtwclust_+3A_complexity">complexity</code></td>
<td>
<p>A function to calculate a constraint's complexity. See details in the Cluster
section.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach developed in Dau et al. (2016) argues that finding a good value of <code>window.size</code> for
the DTW distance is very important, and suggests how to find one by using user-provided feedback.
After clustering is done, a pair of series is presented at a time, and the user must annotate the
pair as:
</p>

<ul>
<li><p> Must link: the series should be in the same cluster.
</p>
</li>
<li><p> Cannot link: the series should <em>not</em> be in the same cluster.
</p>
</li>
<li><p> Skip: the choice is unclear.
</p>
</li></ul>

<p>After each step, a good value of the window size is suggested by evaluating which clusterings
fulfill the constraint(s) so far, and how (see Dau et al. (2016) for more information), and
performing a majority vote using the window sizes inferred from each constraint. The (main)
procedure is thus interactive and can be abandoned at any point.
</p>


<h3>Explore</h3>

<p>This part of the app is simply to see some basic characteristics of the provided series and
plot some of them. The field for integer IDs expects a valid R expression that specifies which
of the <code>series</code> should be plotted. Multivariate series are plotted with each variable in a
different facet.
</p>


<h3>Cluster</h3>

<p>This part of the app implements the main procedure by leveraging <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>. The
interface is similar to <code><a href="#topic+interactive_clustering">interactive_clustering()</a></code>, so it's worth checking its documentation
too. Since <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code> supports parallelization with <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>, you can
register a parallel backend before opening the shiny app, but you should pre-load the workers
with the necessary packages and/or functions. See <code><a href="parallel.html#topic+clusterApply">parallel::clusterEvalQ()</a></code> and
<code><a href="parallel.html#topic+clusterApply">parallel::clusterExport()</a></code>, as well as the examples below.
</p>
<p>The range of window sizes is specified with a slider, and represents the size as a percentage
of the shortest series' length. The <code>step</code> parameter indicates how spaced apart should the
sizes be (parameter <code>'by'</code> in <code><a href="base.html#topic+seq">base::seq()</a></code>). A 0-size window should only be used if all series
have the same length. If the series have different lengths, using small window sizes can be
problematic if the length differences are very big, see the notes in <code><a href="#topic+dtw_basic">dtw_basic()</a></code>.
</p>
<p>A <code>window.size</code> should <em>not</em> be specified in the extra parameters, it will be replaced with the
computed values based on the slider. Using <code><a href="#topic+dba">dba()</a></code> centroid is detected, and will use the same
window sizes.
</p>
<p>For partitional clusterings with many repetitions, and hierarchical clusterings with many
linkage methods, the resulting partitions are aggregated by calling <code><a href="clue.html#topic+cl_medoid">clue::cl_medoid()</a></code> with
the specified aggregation <code>method</code>.
</p>
<p>By default, complexity of a constraint is calculated differently from what is suggested in Dau
et al. (2016):
</p>

<ul>
<li><p> Allocate a logical flag vector with length equal to the number of tested window sizes.
</p>
</li>
<li><p> For each window size, set the corresponding flag to <code>TRUE</code> if the constraint given by the
user is fulfilled.
</p>
</li>
<li><p> Calculate complexity as: (number of sign changes in the vector) / (number of window sizes -
1L) / (maximum number of <em>contiguous</em> <code>TRUE</code> flags).
</p>
</li></ul>

<p>You can provide your own function in the <code>complexity</code> parameter. It will receive the flag
vector as only input, and a single number is expected as a result.
</p>
<p>The complexity threshold can be specified in the app. Any constraint whose complexity is higher
than the threshold will not be considered for the majority vote. Constraints with a complexity
of 0 are also ignored. An infinite complexity means that the constraint is never fulfilled by
any clustering.
</p>


<h3>Evaluate</h3>

<p>This section provides numerical results for reference. The latest results can be saved in the
global environment, which includes clustering results, constraints so far, and the suggested
window size. Since this includes everything returned by <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>, you could also
use <code><a href="#topic+repeat_clustering">repeat_clustering()</a></code> afterwards.
</p>
<p>The constraint plots depict if the constraints are fulfilled or not for the given window sizes,
where 1 means it was fulfilled and 0 means it wasn't. An error about a zero-dimension viewport
indicates the plot height is too small to fit the plots, so please increase the height.
</p>


<h3>Note</h3>

<p>The optimization mentioned in section 3.4 of Dau et al. (2016) is also implemented here.
</p>
<p>Tracing is printed to the console.
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>References</h3>

<p>Dau, H. A., Begum, N., &amp; Keogh, E. (2016). Semi-supervision dramatically improves time series
clustering under dynamic time warping. In Proceedings of the 25th ACM International on Conference
on Information and Knowledge Management (pp. 999-1008). ACM.
<a href="https://sites.google.com/site/dtwclustering/">https://sites.google.com/site/dtwclustering/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interactive_clustering">interactive_clustering()</a></code>, <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
require(doParallel)
workers &lt;- makeCluster(detectCores())
clusterEvalQ(workers, {
    library(dtwclust)
    RcppParallel::setThreadOptions(1L)
})
registerDoParallel(workers)
ssdtwclust(reinterpolate(CharTraj[1L:20L], 150L))

## End(Not run)

</code></pre>

<hr>
<h2 id='TADPole'>TADPole clustering</h2><span id='topic+TADPole'></span><span id='topic+tadpole'></span>

<h3>Description</h3>

<p>Time-series Anytime Density Peaks Clustering as proposed by Begum et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TADPole(
  data,
  k = 2L,
  dc,
  window.size,
  error.check = TRUE,
  lb = "lbk",
  trace = FALSE
)

tadpole(
  data,
  k = 2L,
  dc,
  window.size,
  error.check = TRUE,
  lb = "lbk",
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TADPole_+3A_data">data</code></td>
<td>
<p>A matrix or data frame where each row is a time series, or a list where each element
is a time series. Multivariate series are <strong>not</strong> supported.</p>
</td></tr>
<tr><td><code id="TADPole_+3A_k">k</code></td>
<td>
<p>The number of desired clusters. Can be a vector with several values.</p>
</td></tr>
<tr><td><code id="TADPole_+3A_dc">dc</code></td>
<td>
<p>The cutoff distance(s). Can be a vector with several values.</p>
</td></tr>
<tr><td><code id="TADPole_+3A_window.size">window.size</code></td>
<td>
<p>Window size constraint for DTW (Sakoe-Chiba). See details.</p>
</td></tr>
<tr><td><code id="TADPole_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
<tr><td><code id="TADPole_+3A_lb">lb</code></td>
<td>
<p>Which lower bound to use, &quot;lbk&quot; for <code><a href="#topic+lb_keogh">lb_keogh()</a></code> or &quot;lbi&quot; for <code><a href="#topic+lb_improved">lb_improved()</a></code>.</p>
</td></tr>
<tr><td><code id="TADPole_+3A_trace">trace</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, more output regarding the progress is printed to screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be called either directly or through <code><a href="#topic+tsclust">tsclust()</a></code>.
</p>
<p>TADPole clustering adopts a relatively new clustering framework and adapts it to time series
clustering with DTW. See the cited article for the details of the algorithm.
</p>
<p>Because of the way the algorithm works, it can be considered a kind of Partitioning Around
Medoids (PAM). This means that the cluster centroids are always elements of the data. However,
this algorithm is deterministic, depending on the value of <code>dc</code>.
</p>
<p>The algorithm first uses the DTW's upper and lower bounds (Euclidean and LB_Keogh respectively)
to find series with many close neighbors (in DTW space). Anything below the cutoff distance
(<code>dc</code>) is considered a neighbor. Aided with this information, the algorithm then tries to prune
as many DTW calculations as possible in order to accelerate the clustering procedure. The series
that lie in dense areas (i.e. that have lots of neighbors) are taken as cluster centroids.
</p>
<p>The algorithm relies on the DTW bounds, which are only defined for univariate time series of
equal length.
</p>
<p>Parallelization is supported in the following way:
</p>

<ul>
<li><p> For multiple <code>dc</code> values, multi-processing with <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>.
</p>
</li>
<li><p> The internal distance calculations use multi-threading with <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel::RcppParallel</a>.
</p>
</li></ul>

<p>The windowing constraint uses a centered window.
The calculations expect a value in <code>window.size</code> that represents the distance between the point considered and one of the edges of the window.
Therefore, if, for example, <code>window.size = 10</code>, the warping for an observation <code class="reqn">x_i</code> considers the points between <code class="reqn">x_{i-10}</code> and <code class="reqn">x_{i+10}</code>,
resulting in <code>10(2) + 1 = 21</code> observations falling within the window.
</p>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li> <p><code>cl</code>: Cluster indices.
</p>
</li>
<li> <p><code>centroids</code>: Indices of the centroids.
</p>
</li>
<li> <p><code>distCalcPercentage</code>: Percentage of distance calculations that were actually performed.
</p>
</li></ul>

<p>For multiple <code>k</code>/<code>dc</code> values, a list of lists is returned, each internal list having the
aforementioned elements.
</p>


<h3>Parallel Computing</h3>

<p>Please note that running tasks in parallel does <strong>not</strong> guarantee faster computations.
The overhead introduced is sometimes too large, and it's better to run tasks sequentially.
</p>
<p>This function uses the <a href="RcppParallel.html#topic+RcppParallel-package">RcppParallel</a> package for parallelization.
It uses all available threads by default (see <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::defaultNumThreads()</a></code>),
but this can be changed by the user with <code><a href="RcppParallel.html#topic+setThreadOptions">RcppParallel::setThreadOptions()</a></code>.
</p>
<p>An exception to the above is when it is called within a <code><a href="foreach.html#topic+foreach">foreach</a></code> parallel loop <strong>made by dtwclust</strong>.
If the parallel workers do not have the number of threads explicitly specified,
this function will default to 1 thread per worker.
See the parallelization vignette for more information - <code>browseVignettes("dtwclust")</code>
</p>


<h3>References</h3>

<p>Begum N, Ulanova L, Wang J and Keogh E (2015). &ldquo;Accelerating Dynamic Time Warping Clustering
with a Novel Admissible Pruning Strategy.&rdquo; In <em>Conference on Knowledge Discovery and Data
Mining</em>, series KDD '15. ISBN 978-1-4503-3664-2/15/08, <a href="https://doi.org/10.1145/2783258.2783286">doi:10.1145/2783258.2783286</a>.
</p>

<hr>
<h2 id='tsclust'>Time series clustering</h2><span id='topic+tsclust'></span>

<h3>Description</h3>

<p>This is the main function to perform time series clustering. See the details and the examples for
more information, as well as the included package vignettes (which can be found by typing
<code>browseVignettes("dtwclust")</code>). A convenience wrapper is available in <code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>,
and a shiny app in <code><a href="#topic+interactive_clustering">interactive_clustering()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsclust(
  series = NULL,
  type = "partitional",
  k = 2L,
  ...,
  preproc = NULL,
  distance = "dtw_basic",
  centroid = ifelse(type == "fuzzy", "fcm", "pam"),
  control = do.call(paste0(type, "_control"), list()),
  args = tsclust_args(),
  seed = NULL,
  trace = FALSE,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsclust_+3A_series">series</code></td>
<td>
<p>A list of series, a numeric matrix or a data frame. Matrices and data frames are
coerced to a list row-wise (see <code><a href="#topic+tslist">tslist()</a></code>).</p>
</td></tr>
<tr><td><code id="tsclust_+3A_type">type</code></td>
<td>
<p>What type of clustering method to use: <code>"partitional"</code>, <code>"hierarchical"</code>, <code>"tadpole"</code>
or <code>"fuzzy"</code>.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_k">k</code></td>
<td>
<p>Number of desired clusters. It can be a numeric vector with different values.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_...">...</code></td>
<td>
<p>Arguments to pass to preprocessing, centroid <strong>and</strong> distance functions (added to
<code>args</code>). Also passed to <code>method</code> from <code><a href="#topic+hierarchical_control">hierarchical_control()</a></code> if it happens to be a function,
and to <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> if it contains the <code>members</code> parameter.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_preproc">preproc</code></td>
<td>
<p>Function to preprocess data. Defaults to <code><a href="#topic+zscore">zscore()</a></code> <em>only</em> if <code>centroid</code> <code>=</code>
<code>"shape"</code>, but will be replaced by a custom function if provided.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_distance">distance</code></td>
<td>
<p>A registered distance from <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>. Ignored for <code>type</code> <code>=</code> <code>"tadpole"</code>.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_centroid">centroid</code></td>
<td>
<p>Either a supported string, or an appropriate function to calculate centroids when
using partitional/hierarchical/tadpole methods. See Centroids section.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_control">control</code></td>
<td>
<p>An appropriate list of controls. See <a href="#topic+tsclust-controls">tsclust-controls</a>.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_args">args</code></td>
<td>
<p>An appropriate list of arguments for preprocessing, distance and centroid functions.
See <code><a href="#topic+tsclust_args">tsclust_args()</a></code> and the examples.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_trace">trace</code></td>
<td>
<p>Logical flag. If <code>TRUE</code>, more output regarding the progress is printed to screen.</p>
</td></tr>
<tr><td><code id="tsclust_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partitional and fuzzy clustering procedures use a custom implementation. Hierarchical clustering
is done with <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> by default. TADPole clustering uses the <code><a href="#topic+TADPole">TADPole()</a></code> function.
Specifying <code>type</code> = <code>"partitional"</code>, <code>preproc</code> = <code>zscore</code>, <code>distance</code> = <code>"sbd"</code> and <code>centroid</code> =
<code>"shape"</code> is equivalent to the k-Shape algorithm (Paparrizos and Gravano 2015).
</p>
<p>The <code>series</code> may be provided as a matrix, a data frame or a list. Matrices and data frames are
coerced to a list, both row-wise. Only lists can have series with different lengths or multiple
dimensions. Most of the optimizations require series to have the same length, so consider
reinterpolating them to save some time (see Ratanamahatana and Keogh 2004; <code><a href="#topic+reinterpolate">reinterpolate()</a></code>). No
missing values are allowed.
</p>
<p>In the case of multivariate time series, they should be provided as a list of matrices, where
time spans the rows of each matrix and the variables span the columns (see <a href="#topic+CharTrajMV">CharTrajMV</a> for an
example). All included centroid functions should work with the aforementioned format, although
<code>shape</code> is <em>not</em> recommended. Note that the <code>plot</code> method will simply append all dimensions
(columns) one after the other.
</p>


<h3>Value</h3>

<p>An object with an appropriate class from <a href="#topic+TSClusters-class">TSClusters</a>.
</p>
<p>If <code>control$nrep &gt; 1</code> and a partitional procedure is used, <code>length(method)</code> <code style="white-space: pre;">&#8288;&gt; 1&#8288;</code> and
hierarchical procedures are used, or <code>length(k)</code> <code>&gt;</code> <code>1</code>, a list of objects is returned.
</p>


<h3>Centroid Calculation</h3>

<p>In the case of partitional/fuzzy algorithms, a suitable function should calculate the cluster
centroids at every iteration. In this case, the centroids may also be time series. Fuzzy
clustering uses the standard fuzzy c-means centroid by default.
</p>
<p>In either case, a custom function can be provided. If one is provided, it will receive the
following parameters with the shown names (examples for partitional clustering are shown in
parentheses):
</p>

<ul>
<li> <p><code>x</code>: The <em>whole</em> data list (<code>list(ts1, ts2, ts3)</code>)
</p>
</li>
<li> <p><code>cl_id</code>: An integer vector with length equal to the number of series in <code>data</code>, indicating
which cluster a series belongs to (<code>c(1L, 2L, 2L)</code>)
</p>
</li>
<li> <p><code>k</code>: The desired number of total clusters (<code>2L</code>)
</p>
</li>
<li> <p><code>cent</code>: The current centroids in order, in a list (<code>list(centroid1, centroid2)</code>)
</p>
</li>
<li> <p><code>cl_old</code>: The membership vector of the <em>previous</em> iteration (<code>c(1L, 1L, 2L)</code>)
</p>
</li>
<li><p> The elements of <code>...</code> that match its formal arguments
</p>
</li></ul>

<p>In case of fuzzy clustering, the membership vectors (2nd and 5th elements above) are matrices
with number of rows equal to amount of elements in the data, and number of columns equal to the
number of desired clusters. Each row must sum to 1.
</p>
<p>The other option is to provide a character string for the custom implementations. The following
options are available:
</p>

<ul>
<li><p> &quot;mean&quot;: The average along each dimension. In other words, the average of all <code class="reqn">x^j_i</code>
among the <code class="reqn">j</code> series that belong to the same cluster for all time points <code class="reqn">t_i</code>.
</p>
</li>
<li><p> &quot;median&quot;: The median along each dimension. Similar to mean.
</p>
</li>
<li><p> &quot;shape&quot;: Shape averaging. By default, all series are z-normalized in this case, since the
resulting centroids will also have this normalization. See <code><a href="#topic+shape_extraction">shape_extraction()</a></code> for more
details.
</p>
</li>
<li><p> &quot;dba&quot;: DTW Barycenter Averaging. See <code><a href="#topic+DBA">DBA()</a></code> for more details.
</p>
</li>
<li><p> &quot;sdtw_cent&quot;: Soft-DTW centroids, See <code><a href="#topic+sdtw_cent">sdtw_cent()</a></code> for more details.
</p>
</li>
<li><p> &quot;pam&quot;: Partition around medoids (PAM). This basically means that the cluster centroids are
always one of the time series in the data. In this case, the distance matrix can be
pre-computed once using all time series in the data and then re-used at each iteration. It
usually saves overhead overall for small datasets (see <a href="#topic+tsclust-controls">tsclust-controls</a>).
</p>
</li>
<li><p> &quot;fcm&quot;: Fuzzy c-means. Only supported for fuzzy clustering and used by default in that case.
</p>
</li>
<li><p> &quot;fcmdd&quot;: Fuzzy c-medoids. Only supported for fuzzy clustering. It <strong>always</strong> precomputes/uses
the whole cross-distance matrix.
</p>
</li></ul>

<p>The <code>dba</code>, <code>shape</code> and <code>sdtw_cent</code> implementations check for parallelization. Note that only
<code>shape</code>, <code>dba</code>, <code>sdtw_cent</code>, <code>pam</code> and <code>fcmdd</code> support series of different length. Also note
that for <code>shape</code>, <code>dba</code> and <code>sdtw_cent</code>, this support has a caveat: the final centroids' length
will depend on the length of those series that were randomly chosen at the beginning of the
clustering algorithm. For example, if the series in the dataset have a length of either 10 or
15, 2 clusters are desired, and the initial choice selects two series with length of 10, the
final centroids will have this same length.
</p>
<p>As special cases, if hierarchical or tadpole clustering is used, you can provide a centroid
function that takes a list of series as first input. It will also receive the contents of
<code>args$cent</code> that match its formal arguments, and should return a single centroid series. These
centroids are returned in the <code>centroids</code> slot. By default, the medoid of each cluster is
extracted (similar to what <code><a href="#topic+pam_cent">pam_cent()</a></code> does).
</p>
<p>In the following cases, the <code>centroids</code> list will have an attribute <code>series_id</code> with an integer
vector indicating which <code>series</code> were chosen as centroids:
</p>

<ul>
<li><p> Partitional clustering using &quot;pam&quot; centroid.
</p>
</li>
<li><p> Fuzzy clustering using &quot;fcmdd&quot; centroid.
</p>
</li>
<li><p> Hierarchical clustering with the default centroid extraction.
</p>
</li>
<li><p> TADPole clustering with the default centroid extraction.
</p>
</li></ul>



<h3>Distance Measures</h3>

<p>The distance measure to be used with partitional, hierarchical and fuzzy clustering can be
modified with the <code>distance</code> parameter. The supported option is to provide a string, which must
represent a compatible distance registered with <code>proxy</code>'s <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>. Registration is done
via <code><a href="proxy.html#topic+registry">proxy::pr_DB()</a></code>, and extra parameters can be provided in <code>args$dist</code> (see the examples).
</p>
<p>Note that you are free to create your own distance functions and register them. Optionally, you
can use one of the following custom implementations (all registered with <code>proxy</code>):
</p>

<ul>
<li> <p><code>"dtw"</code>: DTW, optionally with a Sakoe-Chiba/Slanted-band constraint. Done with <code><a href="dtw.html#topic+dtw">dtw::dtw()</a></code>.
</p>
</li>
<li> <p><code>"dtw2"</code>: DTW with L2 norm and optionally a Sakoe-Chiba/Slanted-band constraint. See
<code><a href="#topic+dtw2">dtw2()</a></code>.
</p>
</li>
<li> <p><code>"dtw_basic"</code>: A custom version of DTW with less functionality, but faster. See
<code><a href="#topic+dtw_basic">dtw_basic()</a></code>.
</p>
</li>
<li> <p><code>"dtw_lb"</code>: DTW with L1 or L2 norm and a Sakoe-Chiba constraint. Some computations are
avoided by first estimating the distance matrix with Lemire's lower bound and then
iteratively refining with DTW. See <code><a href="#topic+dtw_lb">dtw_lb()</a></code>. Not suitable for <code>pam.precompute</code> = <code>TRUE</code> nor
hierarchical clustering.
</p>
</li>
<li> <p><code>"lbk"</code>: Keogh's lower bound for DTW with either L1 or L2 norm for the Sakoe-Chiba
constraint. See <code><a href="#topic+lb_keogh">lb_keogh()</a></code>.
</p>
</li>
<li> <p><code>"lbi"</code>: Lemire's lower bound for DTW with either L1 or L2 norm for the Sakoe-Chiba
constraint. See <code><a href="#topic+lb_improved">lb_improved()</a></code>.
</p>
</li>
<li> <p><code>"sbd"</code>: Shape-based distance. See <code><a href="#topic+sbd">sbd()</a></code>.
</p>
</li>
<li> <p><code>"gak"</code>: Global alignment kernels. See <code><a href="#topic+gak">gak()</a></code>.
</p>
</li>
<li> <p><code>"sdtw"</code>: Soft-DTW. See <code><a href="#topic+sdtw">sdtw()</a></code>.
</p>
</li></ul>

<p>Out of the aforementioned, only the distances based on DTW lower bounds <em>don't</em> support series
of different length. The lower bounds are probably unsuitable for direct clustering unless
series are very easily distinguishable.
</p>
<p>If you know that the distance function is symmetric, and you use a hierarchical algorithm, or a
partitional algorithm with PAM centroids, or fuzzy c-medoids, some time can be saved by
calculating only half the distance matrix. Therefore, consider setting the symmetric control
parameter to <code>TRUE</code> if this is the case (see <a href="#topic+tsclust-controls">tsclust-controls</a>).
</p>


<h3>Preprocessing</h3>

<p>It is strongly advised to use z-normalization in case of <code>centroid = "shape"</code>, because the
resulting series have this normalization (see <code><a href="#topic+shape_extraction">shape_extraction()</a></code>). Therefore, <code><a href="#topic+zscore">zscore()</a></code> is
the default in this case. The user can, however, specify a custom function that performs any
transformation on the data, but the user must make sure that the format stays consistent, i.e.
a list of time series.
</p>
<p>Setting to <code>NULL</code> means no preprocessing (except for <code>centroid = "shape"</code>). A provided function
will receive the data as first argument, followed by the contents of <code>args$preproc</code> that match
its formal arguments.
</p>
<p>It is convenient to provide this function if you're planning on using the <code><a href="stats.html#topic+predict">stats::predict()</a></code>
generic (see also <a href="#topic+TSClusters-methods">TSClusters-methods</a>).
</p>


<h3>Repetitions</h3>

<p>Due to their stochastic nature, partitional clustering is usually repeated several times with
different random seeds to allow for different starting points. This function uses
<code><a href="parallel.html#topic+RngStream">parallel::nextRNGStream()</a></code> to obtain different seed streams for each repetition, utilizing the
<code>seed</code> parameter (if provided) to initialize it. If more than one repetition is made, the
streams are returned in an attribute called <code>rng</code>.
</p>
<p>Multiple values of <code>k</code> can also be provided to get different partitions using any <code>type</code> of
clustering.
</p>
<p>Repetitions are greatly optimized when PAM centroids are used and the whole distance matrix is
precomputed, since said matrix is reused for every repetition.
</p>


<h3>Parallel Computing</h3>

<p>Please note that running tasks in parallel does <strong>not</strong> guarantee faster computations. The
overhead introduced is sometimes too large, and it's better to run tasks sequentially.
</p>
<p>The user can register a parallel backend, e.g. with the <span class="pkg">doParallel</span> package, in order to
attempt to speed up the calculations (see the examples). This relies on <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>,
i.e. it uses multi-processing.
</p>
<p>Multi-processing is used in partitional and fuzzy clustering for multiple values of <code>k</code> and/or
<code>nrep</code> (in <code><a href="#topic+partitional_control">partitional_control()</a></code>). See <code><a href="#topic+TADPole">TADPole()</a></code> to know how it uses parallelization. For
cross-distance matrix calculations, the parallelization strategy depends on whether the
distance is included with <span class="pkg">dtwclust</span> or not, see the caveats in <a href="#topic+tsclustFamily-class">tsclustFamily</a>.
</p>
<p>If you register a parallel backend and special packages must be loaded, provide their names in
the <code>packages</code> element of <code>control</code>. Note that &quot;dtwclust&quot; is always loaded in each parallel
worker, so that doesn't need to be included. Alternatively, you may want to pre-load
<span class="pkg">dtwclust</span> in each worker with <code><a href="parallel.html#topic+clusterApply">parallel::clusterEvalQ()</a></code>.
</p>


<h3>Note</h3>

<p>The lower bounds are defined only for time series of equal length. They are <strong>not</strong> symmetric,
and <code>DTW</code> is not symmetric in general.
</p>


<h3>Author(s)</h3>

<p>Alexis Sarda-Espinosa
</p>


<h3>References</h3>

<p>Please refer to the package vignette references (which can be loaded by typing
<code>vignette("dtwclust")</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+TSClusters-class">TSClusters</a>, <a href="#topic+TSClusters-methods">TSClusters-methods</a>, <a href="#topic+tsclustFamily-class">tsclustFamily</a>, <a href="#topic+tsclust-controls">tsclust-controls</a>,
<code><a href="#topic+compare_clusterings">compare_clusterings()</a></code>, <code><a href="#topic+interactive_clustering">interactive_clustering()</a></code>, <code><a href="#topic+ssdtwclust">ssdtwclust()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' NOTE: More examples are available in the vignette. Here are just some miscellaneous
#' examples that might come in handy. They should all work, but some don't run
#' automatically.

# Load data
data(uciCT)

# ====================================================================================
# Simple partitional clustering with Euclidean distance and PAM centroids
# ====================================================================================

# Reinterpolate to same length
series &lt;- reinterpolate(CharTraj, new.length = max(lengths(CharTraj)))

# Subset for speed
series &lt;- series[1:20]
labels &lt;- CharTrajLabels[1:20]

# Making many repetitions
pc.l2 &lt;- tsclust(series, k = 4L,
                 distance = "L2", centroid = "pam",
                 seed = 3247, trace = TRUE,
                 control = partitional_control(nrep = 10L))

# Cluster validity indices
sapply(pc.l2, cvi, b = labels)

# ====================================================================================
# Hierarchical clustering with Euclidean distance
# ====================================================================================

# Re-use the distance matrix from the previous example (all matrices are the same)
# Use all available linkage methods for function hclust
hc.l2 &lt;- tsclust(series, type = "hierarchical",
                 k = 4L, trace = TRUE,
                 control = hierarchical_control(method = "all",
                                                distmat = pc.l2[[1L]]@distmat))

# Plot the best dendrogram according to variation of information
plot(hc.l2[[which.min(sapply(hc.l2, cvi, b = labels, type = "VI"))]])

# ====================================================================================
# Multivariate time series
# ====================================================================================

# Multivariate series, provided as a list of matrices
mv &lt;- CharTrajMV[1L:20L]

# Using GAK distance
mvc &lt;- tsclust(mv, k = 4L, distance = "gak", seed = 390,
               args = tsclust_args(dist = list(sigma = 100)))

# Note how the variables of each series are appended one after the other in the plot
plot(mvc)

## Not run: 
# ====================================================================================
# This function is more verbose but allows for more explicit fine-grained control
# ====================================================================================

tsc &lt;- tsclust(series, k = 4L,
               distance = "gak", centroid = "dba",
               preproc = zscore, seed = 382L, trace = TRUE,
               control = partitional_control(iter.max = 30L),
               args = tsclust_args(preproc = list(center = FALSE),
                                   dist = list(window.size = 20L,
                                               sigma = 100),
                                   cent = list(window.size = 15L,
                                               norm = "L2",
                                               trace = TRUE)))

# ====================================================================================
# Registering a custom distance with the 'proxy' package and using it
# ====================================================================================

# Normalized asymmetric DTW distance
ndtw &lt;- function(x, y, ...) {
    dtw::dtw(x, y, step.pattern = asymmetric,
             distance.only = TRUE, ...)$normalizedDistance
}

# Registering the function with 'proxy'
if (!pr_DB$entry_exists("nDTW"))
    proxy::pr_DB$set_entry(FUN = ndtw, names=c("nDTW"),
                           loop = TRUE, type = "metric", distance = TRUE,
                           description = "Normalized asymmetric DTW")

# Subset of (original) data for speed
pc.ndtw &lt;- tsclust(series[-1L], k = 4L,
                   distance = "nDTW",
                   seed = 8319,
                   trace = TRUE,
                   args = tsclust_args(dist = list(window.size = 18L)))

# Which cluster would the first series belong to?
# Notice that newdata is provided as a list
predict(pc.ndtw, newdata = series[1L])

# ====================================================================================
# Custom hierarchical clustering
# ====================================================================================

require(cluster)

hc.diana &lt;- tsclust(series, type = "h", k = 4L,
                    distance = "L2", trace = TRUE,
                    control = hierarchical_control(method = diana))

plot(hc.diana, type = "sc")

# ====================================================================================
# TADPole clustering
# ====================================================================================

pc.tadp &lt;- tsclust(series, type = "tadpole", k = 4L,
                   control = tadpole_control(dc = 1.5,
                                             window.size = 18L))

# Modify plot, show only clusters 3 and 4
plot(pc.tadp, clus = 3:4,
     labs.arg = list(title = "TADPole, clusters 3 and 4",
                     x = "time", y = "series"))

# Saving and modifying the ggplot object with custom time labels
require(scales)
t &lt;- seq(Sys.Date(), len = length(series[[1L]]), by = "day")
gpc &lt;- plot(pc.tadp, time = t, plot = FALSE)

gpc + ggplot2::scale_x_date(labels = date_format("%b-%Y"),
                            breaks = date_breaks("2 months"))

# ====================================================================================
# Specifying a centroid function for prototype extraction in hierarchical clustering
# ====================================================================================

# Seed is due to possible randomness in shape_extraction when selecting a basis series
hc.sbd &lt;- tsclust(CharTraj, type = "hierarchical",
                  k = 20L, distance = "sbd",
                  preproc = zscore, centroid = shape_extraction,
                  seed = 320L)

plot(hc.sbd, type = "sc")

# ====================================================================================
# Using parallel computation to optimize several random repetitions
# and distance matrix calculation
# ====================================================================================
require(doParallel)

# Create parallel workers
cl &lt;- makeCluster(detectCores())
invisible(clusterEvalQ(cl, library(dtwclust)))
registerDoParallel(cl)

## Use constrained DTW and PAM
pc.dtw &lt;- tsclust(CharTraj, k = 20L, seed = 3251, trace = TRUE,
                  args = tsclust_args(dist = list(window.size = 18L)))

## Use constrained DTW with DBA centroids
pc.dba &lt;- tsclust(CharTraj, k = 20L, centroid = "dba",
                  seed = 3251, trace = TRUE,
                  args = tsclust_args(dist = list(window.size = 18L),
                                      cent = list(window.size = 18L)))

#' Using distance based on global alignment kernels
pc.gak &lt;- tsclust(CharTraj, k = 20L,
                  distance = "gak",
                  centroid = "dba",
                  seed = 8319,
                  trace = TRUE,
                  control = partitional_control(nrep = 8L),
                  args = tsclust_args(dist = list(window.size = 18L),
                                      cent = list(window.size = 18L)))

# Stop parallel workers
stopCluster(cl)

# Return to sequential computations. This MUST be done if stopCluster() was called
registerDoSEQ()

## End(Not run)
</code></pre>

<hr>
<h2 id='tsclust-controls'>Control parameters for clusterings with <code><a href="#topic+tsclust">tsclust()</a></code></h2><span id='topic+tsclust-controls'></span><span id='topic+partitional_control'></span><span id='topic+hierarchical_control'></span><span id='topic+fuzzy_control'></span><span id='topic+tadpole_control'></span><span id='topic+tsclust_args'></span>

<h3>Description</h3>

<p>Control parameters for fine-grained control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partitional_control(
  pam.precompute = TRUE,
  iter.max = 100L,
  nrep = 1L,
  symmetric = FALSE,
  packages = character(0L),
  distmat = NULL,
  pam.sparse = FALSE,
  version = 2L
)

hierarchical_control(
  method = "average",
  symmetric = FALSE,
  packages = character(0L),
  distmat = NULL
)

fuzzy_control(
  fuzziness = 2,
  iter.max = 100L,
  delta = 0.001,
  packages = character(0L),
  symmetric = FALSE,
  version = 2L,
  distmat = NULL
)

tadpole_control(dc, window.size, lb = "lbk")

tsclust_args(preproc = list(), dist = list(), cent = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsclust-controls_+3A_pam.precompute">pam.precompute</code></td>
<td>
<p>Logical flag. Precompute the whole distance matrix once and reuse it on
each iteration if using PAM centroids. Otherwise calculate distances at every iteration. See
details.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_iter.max">iter.max</code></td>
<td>
<p>Integer. Maximum number of allowed iterations for partitional/fuzzy clustering.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_nrep">nrep</code></td>
<td>
<p>Integer. How many times to repeat clustering with different starting points (i.e.,
different random seeds).</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical flag. Is the distance function symmetric? In other words, is <code>dist(x,y)</code>
== <code>dist(y,x)</code>? If <code>TRUE</code>, only half the distance matrix needs to be computed. Automatically
detected and overridden for the distances included in <span class="pkg">dtwclust</span>.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_packages">packages</code></td>
<td>
<p>Character vector with the names of any packages required for custom <code>proxy</code>
functions. Relevant for parallel computation, although since the distance entries are
re-registered in each parallel worker if needed, this is probably useless, but just in case.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_distmat">distmat</code></td>
<td>
<p>If available, the cross-distance matrix can be provided here. Only relevant for
partitional with PAM centroids, fuzzy with FCMdd centroids, or hierarchical clustering.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_pam.sparse">pam.sparse</code></td>
<td>
<p>Attempt to use a sparse matrix for PAM centroids. See details.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_version">version</code></td>
<td>
<p>Which version of partitional/fuzzy clustering to use. See details.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_method">method</code></td>
<td>
<p>Character vector with one or more linkage methods to use in hierarchical procedures
(see <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>), the character <code>"all"</code> to use all of the available ones, or a function
that performs hierarchical clustering based on distance matrices (e.g. <code><a href="cluster.html#topic+diana">cluster::diana()</a></code>). See
details.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_fuzziness">fuzziness</code></td>
<td>
<p>Numeric. Exponent used for fuzzy clustering. Commonly termed <code>m</code> in the
literature.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_delta">delta</code></td>
<td>
<p>Numeric. Convergence criterion for fuzzy clustering.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_dc">dc</code></td>
<td>
<p>The cutoff distance for the TADPole algorithm.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_window.size">window.size</code></td>
<td>
<p>The window.size specifically for the TADPole algorithm.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_lb">lb</code></td>
<td>
<p>The lower bound to use with TADPole. Either <code>"lbk"</code> or <code>"lbi"</code>.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_preproc">preproc</code></td>
<td>
<p>A list of arguments for a preprocessing function to be used in <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_dist">dist</code></td>
<td>
<p>A list of arguments for a distance function to be used in <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</td></tr>
<tr><td><code id="tsclust-controls_+3A_cent">cent</code></td>
<td>
<p>A list of arguments for a centroid function to be used in <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions essentially return their function arguments in a classed list, although some checks
are performed.
</p>
<p>Regarding parameter <code>version</code>: the first version of partitional/fuzzy clustering implemented
in the package always performed an extra iteration, which is unnecessary. Use version 1 to mimic
this previous behavior.
</p>


<h3>Partitional</h3>

<p>When <code>pam.precompute = FALSE</code>, using <code>pam.sparse = TRUE</code> defines a sparse matrix (refer to
<code><a href="Matrix.html#topic+sparseMatrix">Matrix::sparseMatrix()</a></code>) and updates it every iteration (except for <code>"dtw_lb"</code> distance). For
most cases, precomputing the whole distance matrix is still probably faster. See the timing
experiments in <code>browseVignettes("dtwclust")</code>.
</p>
<p>Parallel computations for PAM centroids have the following considerations:
</p>

<ul>
<li><p> If <code>pam.precompute</code> is <code>TRUE</code>, both distance matrix calculations and repetitions are done in
parallel, regardless of <code>pam.sparse</code>.
</p>
</li>
<li><p> If <code>pam.precompute</code> is <code>FALSE</code> and <code>pam.sparse</code> is <code>TRUE</code>, repetitions are done sequentially,
so that the distance calculations can be done in parallel and the sparse matrix updated
iteratively.
</p>
</li>
<li><p> If both <code>pam.precompute</code> and <code>pam.sparse</code> are <code>FALSE</code>, repetitions are done in parallel, and
each repetition performs distance calculations sequentially, but the distance matrix cannot be
updated iteratively.
</p>
</li></ul>



<h3>Hierarchical</h3>

<p>There are some limitations when using a custom hierarchical function in <code>method</code>: it will
receive the lower triangular of the distance matrix as first argument (see <code><a href="stats.html#topic+dist">stats::as.dist()</a></code>)
and the result should support the <code><a href="stats.html#topic+as.hclust">stats::as.hclust()</a></code> generic. This functionality was added
with the <span class="pkg">cluster</span> package in mind, since its functions follow this convention, but other
functions could be used if they are adapted to work similarly.
</p>


<h3>TADPole</h3>

<p>When using TADPole, the <code>dist</code> argument list includes the <code>window.size</code> and specifies <code>norm = "L2"</code>.
</p>

<hr>
<h2 id='TSClusters-class'>Class definition for <code>TSClusters</code> and derived classes</h2><span id='topic+TSClusters-class'></span><span id='topic+TSClusters'></span><span id='topic+PartitionalTSClusters-class'></span><span id='topic+PartitionalTSClusters'></span><span id='topic+HierarchicalTSClusters-class'></span><span id='topic+HierarchicalTSClusters'></span><span id='topic+FuzzyTSClusters-class'></span><span id='topic+FuzzyTSClusters'></span>

<h3>Description</h3>

<p>Formal S4 classes for time-series clusters. See class hierarchy and slot organization at the
<strong>bottom</strong>.
</p>


<h3>Details</h3>

<p>The base class is <code>TSClusters</code>. The 3 classes that inherit from it are: <code>PartitionalTSClusters</code>,
<code>HierarchicalTSClusters</code> and <code>FuzzyTSClusters</code>.
</p>
<p><code>HierarchicalTSClusters</code> also contain <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> as parent class.
</p>
<p>Package <span class="pkg">clue</span> is supported, but generics from <span class="pkg">flexclust</span> are not. See also
<a href="#topic+TSClusters-methods">TSClusters-methods</a>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>The function call.</p>
</dd>
<dt><code>family</code></dt><dd><p>An object of class <a href="#topic+tsclustFamily-class">tsclustFamily</a>.</p>
</dd>
<dt><code>control</code></dt><dd><p>An appropriate control object for <code><a href="#topic+tsclust">tsclust()</a></code>. See <a href="#topic+tsclust-controls">tsclust-controls</a>.</p>
</dd>
<dt><code>datalist</code></dt><dd><p>The provided data in the form of a list, where each element is a time series.</p>
</dd>
<dt><code>type</code></dt><dd><p>A string indicating one of the supported clustering types of <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</dd>
<dt><code>distance</code></dt><dd><p>A string indicating the distance used.</p>
</dd>
<dt><code>centroid</code></dt><dd><p>A string indicating the centroid used.</p>
</dd>
<dt><code>preproc</code></dt><dd><p>A string indicating the preprocessing used.</p>
</dd>
<dt><code>k</code></dt><dd><p>Integer indicating the number of desired clusters.</p>
</dd>
<dt><code>cluster</code></dt><dd><p>Integer vector indicating which cluster a series belongs to (crisp partition). For
fuzzy clustering, this is based on <strong>distance</strong>, not on <code>fcluster</code>. For hierarchical, this is
obtained by calling <code><a href="stats.html#topic+cutree">stats::cutree()</a></code> with the given value of <code>k</code>.</p>
</dd>
<dt><code>centroids</code></dt><dd><p>A list with the centroid time series.</p>
</dd>
<dt><code>distmat</code></dt><dd><p>If computed, the cross-distance matrix.</p>
</dd>
<dt><code>proctime</code></dt><dd><p>Time during function execution, as measured with <code><a href="base.html#topic+proc.time">base::proc.time()</a></code>.</p>
</dd>
<dt><code>dots</code></dt><dd><p>The contents of the original call's ellipsis (...).</p>
</dd>
<dt><code>args</code></dt><dd><p>The contents of the original call's <code>args</code> parameter. See <code><a href="#topic+tsclust_args">tsclust_args()</a></code>.</p>
</dd>
<dt><code>seed</code></dt><dd><p>The random seed that was used.</p>
</dd>
<dt><code>iter</code></dt><dd><p>The number of iterations used.</p>
</dd>
<dt><code>converged</code></dt><dd><p>A logical indicating whether the function converged.</p>
</dd>
<dt><code>clusinfo</code></dt><dd><p>A data frame with two columns: <code>size</code> indicates the number of series each cluster
has, and <code>av_dist</code> indicates, for each cluster, the average distance between series and their
respective centroids (crisp partition).</p>
</dd>
<dt><code>cldist</code></dt><dd><p>A column vector with the distance between each series in the data and its
corresponding centroid (crisp partition).</p>
</dd>
<dt><code>method</code></dt><dd><p>A string indicating which hierarchical method was used.</p>
</dd>
<dt><code>fcluster</code></dt><dd><p>Numeric matrix that contains membership of fuzzy clusters. It has one row for each
series and one column for each cluster. The rows must sum to 1. Only relevant for fuzzy
clustering.</p>
</dd>
</dl>


<h3>TSClusters</h3>

<p>The base class contains the following slots:
</p>

<ul>
<li> <p><code>call</code>
</p>
</li>
<li> <p><code>family</code>
</p>
</li>
<li> <p><code>control</code>
</p>
</li>
<li> <p><code>datalist</code>
</p>
</li>
<li> <p><code>type</code>
</p>
</li>
<li> <p><code>distance</code>
</p>
</li>
<li> <p><code>centroid</code>
</p>
</li>
<li> <p><code>preproc</code>
</p>
</li>
<li> <p><code>k</code>
</p>
</li>
<li> <p><code>cluster</code>
</p>
</li>
<li> <p><code>centroids</code>
</p>
</li>
<li> <p><code>distmat</code>
</p>
</li>
<li> <p><code>proctime</code>
</p>
</li>
<li> <p><code>dots</code>
</p>
</li>
<li> <p><code>args</code>
</p>
</li>
<li> <p><code>seed</code>
</p>
</li></ul>



<h3>PartitionalTSClusters</h3>

<p>This class adds the following slots to the base class:
</p>

<ul>
<li> <p><code>iter</code>
</p>
</li>
<li> <p><code>converged</code>
</p>
</li>
<li> <p><code>clusinfo</code>
</p>
</li>
<li> <p><code>cldist</code>
</p>
</li></ul>



<h3>HierarchicalTSClusters</h3>

<p>This class adds the following slots to the base class:
</p>

<ul>
<li> <p><code>method</code>
</p>
</li>
<li> <p><code>clusinfo</code>
</p>
</li>
<li> <p><code>cldist</code>
</p>
</li></ul>



<h3>FuzzyTSClusters</h3>

<p>This class adds the following slots to the base class:
</p>

<ul>
<li> <p><code>iter</code>
</p>
</li>
<li> <p><code>converged</code>
</p>
</li>
<li> <p><code>fcluster</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+TSClusters-methods">TSClusters-methods</a>
</p>

<hr>
<h2 id='tsclusters-methods'>Methods for <code>TSClusters</code></h2><span id='topic+tsclusters-methods'></span><span id='topic+TSClusters-methods'></span><span id='topic+initialize+2CTSClusters-method'></span><span id='topic+initialize+2CTSClusters'></span><span id='topic+show+2CTSClusters-method'></span><span id='topic+show+2CTSClusters'></span><span id='topic+update.TSClusters'></span><span id='topic+update+2CTSClusters-method'></span><span id='topic+update+2CTSClusters'></span><span id='topic+predict.TSClusters'></span><span id='topic+predict+2CTSClusters-method'></span><span id='topic+predict+2CTSClusters'></span><span id='topic+plot.TSClusters'></span><span id='topic+plot+2CTSClusters+2Cmissing-method'></span><span id='topic+plot+2CTSClusters+2Cmissing'></span>

<h3>Description</h3>

<p>Methods associated with <a href="#topic+TSClusters-class">TSClusters</a> and derived objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TSClusters'
initialize(.Object, ..., override.family = TRUE)

## S4 method for signature 'TSClusters'
show(object)

## S3 method for class 'TSClusters'
update(object, ..., evaluate = TRUE)

## S4 method for signature 'TSClusters'
update(object, ..., evaluate = TRUE)

## S3 method for class 'TSClusters'
predict(object, newdata = NULL, ...)

## S4 method for signature 'TSClusters'
predict(object, newdata = NULL, ...)

## S3 method for class 'TSClusters'
plot(
  x,
  y,
  ...,
  clus = seq_len(x@k),
  labs.arg = NULL,
  series = NULL,
  time = NULL,
  plot = TRUE,
  type = NULL,
  labels = NULL
)

## S4 method for signature 'TSClusters,missing'
plot(
  x,
  y,
  ...,
  clus = seq_len(x@k),
  labs.arg = NULL,
  series = NULL,
  time = NULL,
  plot = TRUE,
  type = NULL,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsclusters-methods_+3A_.object">.Object</code></td>
<td>
<p>A <code>TSClusters</code> prototype. You <em>shouldn't</em> use this, see Initialize section and the
examples.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_...">...</code></td>
<td>
<p>For <code>initialize</code>, any valid slots. For <code>plot</code>, passed to <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_line()</a></code> for
the plotting of the <em>cluster centroids</em>, or to <code><a href="stats.html#topic+hclust">stats::plot.hclust()</a></code>; see Plotting section and
the examples. For <code>update</code>, any supported argument. Otherwise ignored.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_override.family">override.family</code></td>
<td>
<p>Logical. Attempt to substitute the default family with one that conforms
to the provided elements? See Initialize section.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_object">object</code>, <code id="tsclusters-methods_+3A_x">x</code></td>
<td>
<p>An object that inherits from <a href="#topic+TSClusters-class">TSClusters</a> as returned by <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_evaluate">evaluate</code></td>
<td>
<p>Logical. Defaults to <code>TRUE</code> and evaluates the updated call, which will result in
a new <code>TSClusters</code> object. Otherwise, it returns the unevaluated call.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_newdata">newdata</code></td>
<td>
<p>New data to be assigned to a cluster. It can take any of the supported formats of
<code><a href="#topic+tsclust">tsclust()</a></code>. Note that for multivariate series, this means that it <strong>must</strong> be a list of
matrices, even if the list has only one matrix.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_clus">clus</code></td>
<td>
<p>A numeric vector indicating which clusters to plot.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_labs.arg">labs.arg</code></td>
<td>
<p>A list with arguments to change the title and/or axis labels. See the examples
and <code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_series">series</code></td>
<td>
<p>Optionally, the data in the same format as it was provided to <code><a href="#topic+tsclust">tsclust()</a></code>.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_time">time</code></td>
<td>
<p>Optional values for the time axis. If series have different lengths, provide the time
values of the longest series.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_plot">plot</code></td>
<td>
<p>Logical flag. You can set this to <code>FALSE</code> in case you want to save the ggplot object
without printing anything to screen</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_type">type</code></td>
<td>
<p>What to plot. <code>NULL</code> means default. See details.</p>
</td></tr>
<tr><td><code id="tsclusters-methods_+3A_labels">labels</code></td>
<td>
<p>Whether to include labels in the plot (not for dendrogram plots). See details and
note that this is subject to <strong>randomness</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>update</code> method takes the original function call, replaces any provided argument and
optionally evaluates the call again. Use <code>evaluate = FALSE</code> if you want to get the unevaluated
call. If no arguments are provided, the object is updated to a new version if necessary (this is
due to changes in the internal functions of the package, here for backward compatibility).
</p>


<h3>Value</h3>

<p>The plot method returns a <code>gg</code> object (or <code>NULL</code> for dendrogram plot) invisibly.
</p>


<h3>Initialize</h3>

<p>The initialize method is used when calling <code><a href="methods.html#topic+new">methods::new()</a></code>. The <code>family</code> slot can be
substituted with an appropriate one if certain elements are provided by the user. The
initialize methods of derived classes also inherit the family and can use it to calculate other
slots. In order to get a fully functional object, at least the following slots should be
provided:
</p>

<ul>
<li> <p><code>type</code>: &quot;partitional&quot;, &quot;hierarchical&quot;, &quot;fuzzy&quot; or &quot;tadpole&quot;.
</p>
</li>
<li> <p><code>datalist</code>: The data in one of the supported formats.
</p>
</li>
<li> <p><code>centroids</code>: The time series centroids in one of the supported formats.
</p>
</li>
<li> <p><code>cluster</code>: The cluster indices for each series in the <code>datalist</code>.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;control*&#8288;</code>: A <a href="#topic+tsclust-controls">tsclust-controls</a> object with the desired parameters.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;distance*&#8288;</code>: A string indicating the distance that should be used.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;centroid*&#8288;</code>: A string indicating the centroid to use (only necessary for partitional
clustering).
</p>
</li></ul>

<p>*Necessary when overriding the default family for the calculation of other slots, CVIs or
prediction. Maybe not always needed, e.g. for plotting.
</p>


<h3>Prediction</h3>

<p>The <code>predict</code> generic can take the usual <code>newdata</code> argument. If <code>NULL</code>, the method simply
returns the obtained cluster indices. Otherwise, a nearest-neighbor classification based on the
centroids obtained from clustering is performed:
</p>

<ol>
<li> <p><code>newdata</code> is preprocessed with <code>object@family@preproc</code> using the parameters in
<code>object@args$preproc</code>.
</p>
</li>
<li><p> A cross-distance matrix between the processed series and <code>object@centroids</code> is computed with
<code>object@family@dist</code> using the parameters in <code>object@args$dist</code>.
</p>
</li>
<li><p> For non-fuzzy clustering, the series are assigned to their nearest centroid's cluster. For
fuzzy clustering, the fuzzy membership matrix for the series is calculated. In both cases,
the function in <code>object@family@cluster</code> is used.
</p>
</li></ol>



<h3>Plotting</h3>

<p>The plot method uses the <code>ggplot2</code> plotting system (see <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>).
</p>
<p>The default depends on whether a hierarchical method was used or not. In those cases, the
dendrogram is plotted by default; you can pass any extra parameters to <code><a href="stats.html#topic+hclust">stats::plot.hclust()</a></code>
via the ellipsis (<code>...</code>).
</p>
<p>Otherwise, the function plots the time series of each cluster along with the obtained centroid.
The default values for cluster centroids are: <code>linetype = "dashed"</code>, <code>linewidth = 1.5</code>,
<code>colour = "black"</code>, <code>alpha = 0.5</code>. You can change this by means of the ellipsis (<code>...</code>).
</p>
<p>You can choose what to plot with the <code>type</code> parameter. Possible options are:
</p>

<ul>
<li> <p><code>"dendrogram"</code>: Only available for hierarchical clustering.
</p>
</li>
<li> <p><code>"series"</code>: Plot the time series divided into clusters without including centroids.
</p>
</li>
<li> <p><code>"centroids"</code>: Plot the obtained centroids only.
</p>
</li>
<li> <p><code>"sc"</code>: Plot both series and centroids
</p>
</li></ul>

<p>In order to enable labels on the (non-dendrogram) plot, you have to select an option that plots
the series and at least provide an empty list in the <code>labels</code> argument. This list can contain
arguments for <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel()</a></code> and will be passed along. The following are
set by the plot method if they are not provided:
</p>

<ul>
<li> <p><code>"mapping"</code>: set to <a href="ggplot2.html#topic+aes">aes</a>(x = t, y = value, label = label)
</p>
</li>
<li> <p><code>"data"</code>: a data frame with as many rows as series in the <code>datalist</code> and 4 columns:
</p>

<ul>
<li> <p><code>t</code>: x coordinate of the label for each series.
</p>
</li>
<li> <p><code>value</code>: y coordinate of the label for each series.
</p>
</li>
<li> <p><code>cl</code>: index of the cluster to which the series belongs (i.e. <code>x@cluster</code>).
</p>
</li>
<li> <p><code>label</code>: the label for the given series (i.e. <code>names(x@datalist)</code>).
</p>
</li></ul>

</li></ul>

<p>You can provide your own data frame if you want, but it must have those columns and, even if
you override <code>mapping</code>, the <code>cl</code> column must have that name. The method will attempt to spread
the labels across the plot, but note that this is <strong>subject to randomness</strong>, so be careful if
you need reproducibility of any commands used after plotting (see examples).
</p>
<p>If created, the function returns the <code>gg</code> object invisibly, in case you want to modify it to
your liking. You might want to look at <code><a href="ggplot2.html#topic+ggplot_build">ggplot2::ggplot_build()</a></code> if that's the case.
</p>
<p>If you want to free the scale of the X axis, you can do the following:
</p>
<p><code>plot(x, plot = FALSE)</code> <code>+</code> <code>facet_wrap(~cl, scales = "free")</code>
</p>
<p>For more complicated changes, you're better off looking at the source code at
<a href="https://github.com/asardaes/dtwclust/blob/master/R/S4-TSClusters-methods.R">https://github.com/asardaes/dtwclust/blob/master/R/S4-TSClusters-methods.R</a> and creating your
own plotting function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uciCT)

# Assuming this was generated by some clustering procedure
centroids &lt;- CharTraj[seq(1L, 100L, 5L)]
cluster &lt;- unclass(CharTrajLabels)

pc_obj &lt;- new("PartitionalTSClusters",
              type = "partitional", datalist = CharTraj,
              centroids = centroids, cluster = cluster,
              distance = "sbd", centroid = "dba",
              control = partitional_control(),
              args = tsclust_args(cent = list(window.size = 8L, norm = "L2")))

fc_obj &lt;- new("FuzzyTSClusters",
              type = "fuzzy", datalist = CharTraj,
              centroids = centroids, cluster = cluster,
              distance = "sbd", centroid = "fcm",
              control = fuzzy_control())

show(fc_obj)


## Not run: 
plot(pc_obj, type = "c", linetype = "solid",
     labs.arg = list(title = "Clusters' centroids"))

set.seed(15L)
plot(pc_obj, labels = list(nudge_x = -5, nudge_y = 0.2),
     clus = c(1L,4L))

## End(Not run)

</code></pre>

<hr>
<h2 id='tsclustFamily-class'>Class definition for <code>tsclustFamily</code></h2><span id='topic+tsclustFamily-class'></span><span id='topic+tsclustFamily'></span>

<h3>Description</h3>

<p>Formal S4 class with a family of functions used in <code><a href="#topic+tsclust">tsclust()</a></code>.
</p>


<h3>Details</h3>

<p>The custom implementations also handle parallelization.
</p>
<p>Since the distance function makes use of <span class="pkg">proxy</span>, it also supports any extra <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>
parameters in <code>...</code>.
</p>
<p>The prototype includes the <code>cluster</code> function for partitional methods, as well as a pass-through
<code>preproc</code> function. The initializer expects a control from <a href="#topic+tsclust-controls">tsclust-controls</a>. See more below.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dist</code></dt><dd><p>The function to calculate the distance matrices.</p>
</dd>
<dt><code>allcent</code></dt><dd><p>The function to calculate centroids on each iteration.</p>
</dd>
<dt><code>cluster</code></dt><dd><p>The function used to assign a series to a cluster.</p>
</dd>
<dt><code>preproc</code></dt><dd><p>The function used to preprocess the data (relevant for <code><a href="stats.html#topic+predict">stats::predict()</a></code>).</p>
</dd>
</dl>


<h3>Distance function</h3>

<p>The family's dist() function works like <code><a href="proxy.html#topic+dist">proxy::dist()</a></code> but supports parallelization and
optimized symmetric calculations. If you like, you can use the function more or less directly,
but provide a control argument when creating the family (see examples). However, bear in mind
the following considerations.
</p>

<ul>
<li><p> The second argument is called <code>centroids</code> (inconsistent with <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>).
</p>
</li>
<li><p> If <code>control$distmat</code> is <em>not</em> <code>NULL</code>, the function will try to subset it.
</p>
</li>
<li><p> If <code>control$symmetric</code> is <code>TRUE</code>, <code>centroids</code> is <code>NULL</code>, <em>and</em> there is no argument
<code>pairwise</code> that is <code>TRUE</code>, only half the distance matrix will be computed.
</p>
</li></ul>

<p>Note that all distances implemented as part of <span class="pkg">dtwclust</span> have custom proxy loops that use
multi-threading independently of <span class="pkg">foreach</span>, so see their respective documentation to see
what optimizations apply to each one.
</p>
<p>For distances <em>not</em> included in <span class="pkg">dtwclust</span>, the computation can be in parallel using
multi-processing with <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>. If you install and load or attach (see
<code><a href="base.html#topic+library">base::library()</a></code> or <code><a href="base.html#topic+ns-load">base::loadNamespace()</a></code>) the <span class="pkg">bigmemory</span> package, the function will
take advantage of said package when all of the following conditions are met, reducing the
overhead of data copying across processes:
</p>

<ul>
<li> <p><code>control$symmetric</code> is <code>TRUE</code>
</p>
</li>
<li> <p><code>centroids</code> is <code>NULL</code>
</p>
</li>
<li> <p><code>pairwise</code> is <code>FALSE</code> or <code>NULL</code>
</p>
</li>
<li><p> The distance was registered in <a href="proxy.html#topic+registry">proxy::pr_DB</a> with <code>loop = TRUE</code>
</p>
</li>
<li><p> A parallel backend with more than 1 worker has been registered with <span class="pkg">foreach</span>
</p>
</li></ul>

<p>This symmetric, parallel case makes chunks for parallel workers, but they are not perfectly
balanced, so some workers might finish before the others.
</p>


<h3>Centroid function</h3>

<p>The default partitional allcent() function is a closure with the implementations of the
included centroids. The ones for <code><a href="#topic+DBA">DBA()</a></code>, <code><a href="#topic+shape_extraction">shape_extraction()</a></code> and <code><a href="#topic+sdtw_cent">sdtw_cent()</a></code> can use
multi-process parallelization with <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>. Its formal arguments are described in
the Centroid Calculation section from <code><a href="#topic+tsclust">tsclust()</a></code>.
</p>


<h3>Note</h3>

<p>This class is meant to group together the relevant functions, but they are <strong>not</strong> linked with
each other automatically. In other words, neither <code>dist</code> nor <code>allcent</code> apply <code>preproc</code>. They
essentially don't know of each other's existence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dtw_basic">dtw_basic()</a></code>, <code><a href="#topic+dtw_lb">dtw_lb()</a></code>, <code><a href="#topic+gak">gak()</a></code>, <code><a href="#topic+lb_improved">lb_improved()</a></code>, <code><a href="#topic+lb_keogh">lb_keogh()</a></code>, <code><a href="#topic+sbd">sbd()</a></code>, <code><a href="#topic+sdtw">sdtw()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(uciCT)
# See "GAK" documentation
fam &lt;- new("tsclustFamily", dist = "gak")

# This is done with symmetric optimizations, regardless of control$symmetric
crossdist &lt;- fam@dist(CharTraj, window.size = 18L)

# This is done without symmetric optimizations, regardless of control$symmetric
crossdist &lt;- fam@dist(CharTraj, CharTraj, window.size = 18L)

# For non-dtwclust distances, symmetric optimizations only apply
# with an appropriate control AND a single data argument:
fam &lt;- new("tsclustFamily", dist = "dtw",
           control = partitional_control(symmetric = TRUE))
fam@dist(CharTraj[1L:5L])

# If you want the fuzzy family, use fuzzy = TRUE
ffam &lt;- new("tsclustFamily", control = fuzzy_control(), fuzzy = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='tslist'>Coerce matrices or data frames to a list of time series</h2><span id='topic+tslist'></span>

<h3>Description</h3>

<p>Change a matrix or data frame to a list of univariate time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tslist(series, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tslist_+3A_series">series</code></td>
<td>
<p>A matrix or data frame where each row is a time series.</p>
</td></tr>
<tr><td><code id="tslist_+3A_simplify">simplify</code></td>
<td>
<p>Coerce all series in the resulting list to either matrix (multivariate) or
numeric (univariate).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Almost all functions in <span class="pkg">dtwclust</span> work internally with lists of time series. If you want to
avoid constant coercion, create a list of time series once by calling this function.
</p>
<p>For matrices and data frames, each <strong>row</strong> is considered as one time series. A list input is
simply passed through.
</p>


<h3>Value</h3>

<p>A list of time series.
</p>


<h3>Note</h3>

<p>The function assumes that matrix-like objects can be first coerced via <code><a href="base.html#topic+matrix">base::as.matrix()</a></code>, so
that the result can be indexed with <code>series[i, ]</code>.
</p>
<p>No consistency checks are performed by this function.
</p>

<hr>
<h2 id='uciCT'>Subset of character trajectories data set</h2><span id='topic+uciCT'></span><span id='topic+ucict'></span><span id='topic+CharTraj'></span><span id='topic+CharTrajLabels'></span><span id='topic+CharTrajMV'></span>

<h3>Description</h3>

<p>Subset: only 5 examples of each considered character. See details.
</p>


<h3>Format</h3>

<p>Lists with 100 elements. Each element is a time series. Labels included as factor vector.
</p>


<h3>Details</h3>

<p>Quoting the source:
</p>
<p>&quot;Multiple, labelled samples of pen tip trajectories recorded whilst writing individual
characters. All samples are from the same writer, for the purposes of primitive extraction. Only
characters with a single pen-down segment were considered.&quot;
</p>
<p>The subset included in <code>CharTraj</code> has only 5 examples of the X velocity for each character. A
vector with labels is also loaded in <code>CharTrajLabels</code>.
</p>
<p>The subset included in <code>CharTrajMV</code> has 5 examples too, but includes tip force as well as X and Y
velocity. Each element of the list is a multivariate series with 3 variables.
</p>
<p>Please note that even though both <code>CharTraj</code> and <code>CharTrajMV</code> have the same series names, the
actual series in each subset are <strong>not</strong> the same, i.e., <code>CharTraj$A.V1</code> is not in
<code>CharTrajMV$A.V1</code>.
</p>


<h3>Source</h3>

<p><a href="https://archive.ics.uci.edu/ml/datasets/Character+Trajectories">https://archive.ics.uci.edu/ml/datasets/Character+Trajectories</a>
</p>

<hr>
<h2 id='zscore'>Wrapper for z-normalization</h2><span id='topic+zscore'></span>

<h3>Description</h3>

<p>Wrapper for function <code><a href="base.html#topic+scale">base::scale()</a></code> that returns zeros instead of <code>NaN</code>. It also supports
matrices, data frames, and lists of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zscore(
  x,
  ...,
  multivariate = FALSE,
  keep.attributes = FALSE,
  error.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zscore_+3A_x">x</code></td>
<td>
<p>Data to normalize. Either a vector, a matrix/data.frame where each row is to be
normalized, or a list of vectors/matrices.</p>
</td></tr>
<tr><td><code id="zscore_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code><a href="base.html#topic+scale">base::scale()</a></code>.</p>
</td></tr>
<tr><td><code id="zscore_+3A_multivariate">multivariate</code></td>
<td>
<p>Is <code>x</code> a multivariate time series? It will be detected automatically if a
list is provided in <code>x</code>.</p>
</td></tr>
<tr><td><code id="zscore_+3A_keep.attributes">keep.attributes</code></td>
<td>
<p>Should the mean and standard deviation returned by <code><a href="base.html#topic+scale">base::scale()</a></code> be
preserved?</p>
</td></tr>
<tr><td><code id="zscore_+3A_error.check">error.check</code></td>
<td>
<p>Logical indicating whether the function should try to detect inconsistencies
and give more informative errors messages. Also used internally to avoid repeating checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate series must have time spanning the rows and variables spanning the columns.
</p>


<h3>Value</h3>

<p>Normalized data in the same format as provided.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
