<!DOCTYPE html><html lang="en"><head><title>Help for package longmixr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {longmixr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#crosssectional_consensus_cluster'><p>Cross-sectional clustering with categorical variables</p></a></li>
<li><a href='#fake_questionnaire_data'><p>Fake questionnaire data</p></a></li>
<li><a href='#get_clusters'><p>Extract the cluster assignments</p></a></li>
<li><a href='#longitudinal_consensus_cluster'><p>Longitudinal consensus clustering with flexmix</p></a></li>
<li><a href='#plot.lcc'><p>Plot a longitudinal consensus clustering</p></a></li>
<li><a href='#test_clustering_methods'><p>Try out different linkage methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Longitudinal Consensus Clustering with 'flexmix'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An adaption of the consensus clustering approach from
    'ConsensusClusterPlus' for longitudinal data. The longitudinal data is
    clustered with flexible mixture models from 'flexmix', while the consensus
    matrices are hierarchically clustered as in 'ConsensusClusterPlus'. By using
    the flexibility from 'flexmix' and 'FactoMineR', one can use mixed data
    types for the clustering.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cellmapslab.github.io/longmixr/">https://cellmapslab.github.io/longmixr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cellmapslab/longmixr/issues">https://github.com/cellmapslab/longmixr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, ConsensusClusterPlus, graphics, grDevices, flexmix,
StatMatch, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, dplyr, tidyr, ggplot2,
ggalluvial, FactoMineR, factoextra, lme4, purrr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-13 15:26:02 UTC; jonas_hagenberg</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Hagenberg <a href="https://orcid.org/0000-0002-1849-1106"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matt Wilkerson [aut, cph],
  Peter Waltman [aut, cph],
  Max Planck Institute of Psychiatry [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Hagenberg &lt;jonas_hagenberg@psych.mpg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-13 20:32:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='crosssectional_consensus_cluster'>Cross-sectional clustering with categorical variables</h2><span id='topic+crosssectional_consensus_cluster'></span>

<h3>Description</h3>

<p>This function uses the <code>ConsensusClusterPlus</code> function from the package
with the same name with defaults for clustering data with categorical
variables. As the distance function, the Gower distance is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosssectional_consensus_cluster(
  data,
  reps = 1000,
  finalLinkage = "ward.D2",
  innerLinkage = "ward.D2",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosssectional_consensus_cluster_+3A_data">data</code></td>
<td>
<p>a matrix or data.frame containing variables that should be used
for computing the distance. This argument is passed to <code>StatMatch::gower.dist</code></p>
</td></tr>
<tr><td><code id="crosssectional_consensus_cluster_+3A_reps">reps</code></td>
<td>
<p>number of repetitions, same as in <code>ConsensusClusterPlus</code></p>
</td></tr>
<tr><td><code id="crosssectional_consensus_cluster_+3A_finallinkage">finalLinkage</code></td>
<td>
<p>linkage method for final clustering,
same as in <code>ConsensusClusterPlus</code>same as in <code>ConsensusClusterPlus</code></p>
</td></tr>
<tr><td><code id="crosssectional_consensus_cluster_+3A_innerlinkage">innerLinkage</code></td>
<td>
<p>linkage method for clustering steps,
same as in <code>ConsensusClusterPlus</code></p>
</td></tr>
<tr><td><code id="crosssectional_consensus_cluster_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>ConsensusClusterPlus</code>, attention:
the <code>d</code> argument can <b>not</b> be set as it is directly computed by
<code>crosssectional_consensus_cluster</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> can take all input data types that <code><a href="StatMatch.html#topic+gower.dist">gower.dist</a></code>
can handle, i.e. <code>numeric</code>, <code>character</code>/<code>factor</code>, <code>ordered</code>
and <code>logical</code>.
</p>


<h3>Value</h3>

<p>The output is produced by <code>ConsensusClusterPlus</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dc &lt;- mtcars
# scale continuous variables
dc &lt;- sapply(mtcars[, 1:7], scale)
# code factor variables
dc &lt;- cbind(as.data.frame(dc),
            vs = as.factor(mtcars$vs),
            am = as.factor(mtcars$am),
            gear = as.factor(mtcars$gear),
            carb = as.factor(mtcars$carb))
cc &lt;- crosssectional_consensus_cluster(
  data = dc,
  reps = 10,
  seed = 1
)
</code></pre>

<hr>
<h2 id='fake_questionnaire_data'>Fake questionnaire data</h2><span id='topic+fake_questionnaire_data'></span>

<h3>Description</h3>

<p>A simulated data set containing observations of 100 individuals at four time
points. The data was simulated in two groups (50 individuals each) and
contains two questionnaires with five items each, one questionnaire with
five continuous variables and one additional cross-sectional continuous
variable. In this data set the group variable from the simulation is
included. You typically don't have this group variable in your data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fake_questionnaire_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 20 variables:
</p>

<dl>
<dt>ID</dt><dd><p>patient ID</p>
</dd>
<dt>visit</dt><dd><p>time point of the observation</p>
</dd>
<dt>group</dt><dd><p>to which simulated group the observation belongs to</p>
</dd>
<dt>age_visit_1</dt><dd><p>age of the patient at time point 1</p>
</dd>
<dt>single_continuous_variable</dt><dd><p>a cross-sectional continuous variable,
i.e. there is only one unique value per individual</p>
</dd>
<dt>questionnaire_A_1</dt><dd><p>the first item of questionnaire A with categories
1 to 5</p>
</dd>
<dt>questionnaire_A_2</dt><dd><p>the second item of questionnaire A with categories
1 to 5</p>
</dd>
<dt>questionnaire_A_3</dt><dd><p>the third item of questionnaire A with categories
1 to 5</p>
</dd>
<dt>questionnaire_A_4</dt><dd><p>the fourth item of questionnaire A with categories
1 to 5</p>
</dd>
<dt>questionnaire_A_5</dt><dd><p>the fifth item of questionnaire A with categories
1 to 5</p>
</dd>
<dt>questionnaire_B_1</dt><dd><p>the first item of questionnaire B with categories
1 to 5</p>
</dd>
<dt>questionnaire_B_2</dt><dd><p>the second item of questionnaire B with categories
1 to 5</p>
</dd>
<dt>questionnaire_B_3</dt><dd><p>the third item of questionnaire B with categories
1 to 5</p>
</dd>
<dt>questionnaire_B_4</dt><dd><p>the fourth item of questionnaire B with categories
1 to 5</p>
</dd>
<dt>questionnaire_B_5</dt><dd><p>the fifth item of questionnaire B with categories
1 to 5</p>
</dd>
<dt>questionnaire_C_1</dt><dd><p>the first continuous variable of questionnaire C</p>
</dd>
<dt>questionnaire_C_2</dt><dd><p>the second continuous variable of questionnaire C</p>
</dd>
<dt>questionnaire_C_3</dt><dd><p>the third continuous variable of questionnaire C</p>
</dd>
<dt>questionnaire_C_4</dt><dd><p>the fourth continuous variable of questionnaire C</p>
</dd>
<dt>questionnaire_C_5</dt><dd><p>the fifth continuous variable of questionnaire C</p>
</dd>
</dl>



<h3>Source</h3>

<p>simulated data
</p>

<hr>
<h2 id='get_clusters'>Extract the cluster assignments</h2><span id='topic+get_clusters'></span>

<h3>Description</h3>

<p>This functions extracts the cluster assignments from an <code>lcc</code> object.
One can specify which for which number of clusters the assignments
should be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters(cluster_solution, number_clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_clusters_+3A_cluster_solution">cluster_solution</code></td>
<td>
<p>an <code>lcc</code> object</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_number_clusters">number_clusters</code></td>
<td>
<p>default is <code>NULL</code> to return all assignments.
Otherwise specify a numeric vector with the number of clusters for which the
assignments should be returned, e.g. <code>2:4</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with an ID column (the name of the ID column
was specified by the user when calling the
<code>longitudinal_consensus_cluster</code>) function and one column with cluster
assignments for every specified number of clusters. Only the assignments
included in <code>number_clusters</code> are returned in the form of columns with
the names <code>assignment_num_clus_x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># not run
set.seed(5)
test_data &lt;- data.frame(patient_id = rep(1:10, each = 4),
visit = rep(1:4, 10),
var_1 = c(rnorm(20, -1), rnorm(20, 3)) +
rep(seq(from = 0, to = 1.5, length.out = 4), 10),
var_2 = c(rnorm(20, 0.5, 1.5), rnorm(20, -2, 0.3)) +
rep(seq(from = 1.5, to = 0, length.out = 4), 10))
model_list &lt;- list(flexmix::FLXMRmgcv(as.formula("var_1 ~ .")),
flexmix::FLXMRmgcv(as.formula("var_2 ~ .")))
clustering &lt;- longitudinal_consensus_cluster(
data = test_data,
id_column = "patient_id",
max_k = 2,
reps = 3,
model_list = model_list,
flexmix_formula = as.formula("~s(visit, k = 4) | patient_id"))
cluster_assignments &lt;- get_clusters(clustering, number_clusters = 2)
# end not run
</code></pre>

<hr>
<h2 id='longitudinal_consensus_cluster'>Longitudinal consensus clustering with flexmix</h2><span id='topic+longitudinal_consensus_cluster'></span>

<h3>Description</h3>

<p>This function performs longitudinal clustering with flexmix. To get robust
results, the data is subsampled and the clustering is performed on this
subsample. The results are combined in a consensus matrix and a final
hierarchical clustering step performed on this matrix. In this, it follows
the approach from the <code>ConsensusClusterPlus</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longitudinal_consensus_cluster(
  data = NULL,
  id_column = NULL,
  max_k = 3,
  reps = 10,
  p_item = 0.8,
  model_list = NULL,
  flexmix_formula = as.formula("~s(visit, k = 4) | patient_id"),
  title = "untitled_consensus_cluster",
  final_linkage = c("average", "ward.D", "ward.D2", "single", "complete", "mcquitty",
    "median", "centroid"),
  seed = 3794,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longitudinal_consensus_cluster_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> with one or several observations per subject.
It needs to contain one column that specifies to which subject the entry (row)
belongs to. This ID column is specified in <code>id_column</code>. Otherwise, there
are no restrictions on the column names, as the model is specified in
<code>flexmix_formula</code>.</p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_id_column">id_column</code></td>
<td>
<p>name (character vector) of the ID column in <code>data</code> to
identify all observations of one subject</p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_max_k">max_k</code></td>
<td>
<p>maximum number of clusters, default is <code>3</code></p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_reps">reps</code></td>
<td>
<p>number of repetitions, default is <code>10</code></p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_p_item">p_item</code></td>
<td>
<p>fraction of samples contained in subsampled sample, default is
<code>0.8</code></p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_model_list">model_list</code></td>
<td>
<p>either one <code>flexmix</code> driver or a list of <code>flexmix</code>
drivers of class <code>FLXMR</code></p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_flexmix_formula">flexmix_formula</code></td>
<td>
<p>a <code>formula</code> object that describes the <code>flexmix</code>
model relative to the formula in the flexmix drivers (the dot in the flexmix
drivers is replaced, see the example). That means that you usually only
specify the right-hand side of the formula here. However, this is not enforced
or checked to give you more flexibility over the <code>flexmix</code> interface</p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_title">title</code></td>
<td>
<p>name of the clustering; used if <code>writeTable = TRUE</code></p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_final_linkage">final_linkage</code></td>
<td>
<p>linkage used for the last hierarchical clustering step on
the consensus matrix; has to be <code>average, ward.D, ward.D2, single, complete, mcquitty, median</code>
or <code>centroid</code>. The default is <code>average</code></p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_seed">seed</code></td>
<td>
<p>seed for reproducibility</p>
</td></tr>
<tr><td><code id="longitudinal_consensus_cluster_+3A_verbose">verbose</code></td>
<td>
<p><code>boolean</code> if status messages should be displayed.
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data types <code>longitudinal_consensus_cluster</code> can handle depends on
how the <code>flexmix</code> models are set up, in principle all data types are
supported for which there is a <code>flexmix</code> driver with the desired
outcome variable.
</p>
<p>If you follow the dimension reduction approach outlined in
<code>vignette("Example clustering analysis", package = "longmixr")</code>, the
input data types depend on what <code>FAMD</code> from the <code>FactoMineR</code>
package can handle. <code>FAMD</code> accepts <code>numeric</code> variables and treats
all other variables as <code>factor</code> variables which it can handle as well.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>lcc</code> with length <code>maxk</code>.
The first entry <code>general_information</code> contains the entries:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>consensus_matrices</code> </td><td style="text-align: left;"> a list of all consensus matrices (for all specified clusters) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cluster_assignments</code> </td><td style="text-align: left;"> a <code>data.frame</code> with an ID column named after <code>id_column</code> and a column for every specified number of clusters, e.g. <code>assignment_num_clus_2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>call</code> </td><td style="text-align: left;"> the call/all arguments how <code>longitudinal_consensus_cluster</code> was called
</td>
</tr>

</table>

<p>The other entries correspond to the number of specified clusters (e.g. the
second entry corresponds to 2 specified clusters) and each contains a list with the
following entries:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>consensus_matrix</code> </td><td style="text-align: left;"> the consensus matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>consensus_tree</code> </td><td style="text-align: left;"> the result of the hierarchical clustering on the consensus matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>consensus_class</code> </td><td style="text-align: left;"> the resulting class for every observation </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>found_flexmix_clusters</code> </td><td style="text-align: left;"> a vector of the actual found number of clusters by <code>flexmix</code> (which can deviate from the specified number)
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
test_data &lt;- data.frame(patient_id = rep(1:10, each = 4),
visit = rep(1:4, 10),
var_1 = c(rnorm(20, -1), rnorm(20, 3)) +
rep(seq(from = 0, to = 1.5, length.out = 4), 10),
var_2 = c(rnorm(20, 0.5, 1.5), rnorm(20, -2, 0.3)) +
rep(seq(from = 1.5, to = 0, length.out = 4), 10))
model_list &lt;- list(flexmix::FLXMRmgcv(as.formula("var_1 ~ .")),
flexmix::FLXMRmgcv(as.formula("var_2 ~ .")))
clustering &lt;- longitudinal_consensus_cluster(
data = test_data,
id_column = "patient_id",
max_k = 2,
reps = 3,
model_list = model_list,
flexmix_formula = as.formula("~s(visit, k = 4) | patient_id"))
# not run
# plot(clustering)
# end not run
</code></pre>

<hr>
<h2 id='plot.lcc'>Plot a longitudinal consensus clustering</h2><span id='topic+plot.lcc'></span>

<h3>Description</h3>

<p>Plot a longitudinal consensus clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcc'
plot(x, color_palette = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lcc_+3A_x">x</code></td>
<td>
<p><code>lcc</code> object (output from <code><a href="#topic+longitudinal_consensus_cluster">longitudinal_consensus_cluster</a></code>)</p>
</td></tr>
<tr><td><code id="plot.lcc_+3A_color_palette">color_palette</code></td>
<td>
<p>optional character vector of colors for consensus matrix</p>
</td></tr>
<tr><td><code id="plot.lcc_+3A_...">...</code></td>
<td>
<p>additional parameters for plotting; currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots the following plots:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>consensus matrix legend</code> </td><td style="text-align: left;"> the legend for the following consensus matrix plots </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>consensus matrix plot</code> </td><td style="text-align: left;"> for every specified number of clusters, a heatmap of the consensus matrix and the result of the final clustering is shown </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>consensus CDF</code> </td><td style="text-align: left;"> a line plot of the CDFs for all different specified numbers of clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Delta area</code> </td><td style="text-align: left;"> elbow plot of the difference in the CDFs between the different numbers of clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tracking plot</code> </td><td style="text-align: left;"> cluster assignment of the subjects throughout the different cluster solutions </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>item-consensus</code> </td><td style="text-align: left;"> for every item (subject), calculate the average consensus value with all items that are assigned to one consensus cluster. This is repeated for every cluster and for all different numbers of clusters </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cluster-consensus</code> </td><td style="text-align: left;"> every bar represents the average pair-wise item-consensus within one consensus cluster
</td>
</tr>

</table>


<hr>
<h2 id='test_clustering_methods'>Try out different linkage methods</h2><span id='topic+test_clustering_methods'></span>

<h3>Description</h3>

<p>In the final step, the consensus clustering performs a hierarchical clustering
step on the consensus cluster. This function tries out different linkage
methods and returns the corresponding clusterings. The outputs can be plotted
like the results from <code><a href="#topic+longitudinal_consensus_cluster">longitudinal_consensus_cluster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_clustering_methods(
  results,
  use_methods = c("average", "ward.D", "ward.D2", "single", "complete", "mcquitty",
    "median", "centroid")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_clustering_methods_+3A_results">results</code></td>
<td>
<p>clustering result of class <code>lcc</code></p>
</td></tr>
<tr><td><code id="test_clustering_methods_+3A_use_methods">use_methods</code></td>
<td>
<p>character vector of one or several items of <code>average</code>,
<code>ward.D</code>, <code>ward.D2</code>, <code>single</code>, <code>complete</code>, <code>mcquitty</code>,
<code>median</code> or <code>centroid</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of elements, each element of class <code>lcc</code>. The entries are
named after the used linkage method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5)
test_data &lt;- data.frame(patient_id = rep(1:10, each = 4),
visit = rep(1:4, 10),
var_1 = c(rnorm(20, -1), rnorm(20, 3)) +
rep(seq(from = 0, to = 1.5, length.out = 4), 10),
var_2 = c(rnorm(20, 0.5, 1.5), rnorm(20, -2, 0.3)) +
rep(seq(from = 1.5, to = 0, length.out = 4), 10))
model_list &lt;- list(flexmix::FLXMRmgcv(as.formula("var_1 ~ .")),
flexmix::FLXMRmgcv(as.formula("var_2 ~ .")))
clustering &lt;- longitudinal_consensus_cluster(
data = test_data,
id_column = "patient_id",
max_k = 2,
reps = 3,
model_list = model_list,
flexmix_formula = as.formula("~s(visit, k = 4) | patient_id"))

clustering_linkage &lt;- test_clustering_methods(results = clustering,
use_methods = c("average", "single"))
# not run
# plot(clustering_linkage[["single"]])
# end not run
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
