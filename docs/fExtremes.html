<!DOCTYPE html><html><head><title>Help for package fExtremes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fExtremes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DataPreprocessing'><p>Extremes Data Preprocessing</p></a></li>
<li><a href='#ExtremeIndex'><p>Extremal Index Estimation</p></a></li>
<li><a href='#ExtremesData'><p>Explorative Data Analysis</p></a></li>
<li><a href='#fExtremes-internal'><p>Internal fExtremes functions</p></a></li>
<li><a href='#fExtremes-package'><p>Modelling Extreme Events in Finance</p></a></li>
<li><a href='#GevDistribution'><p>Generalized Extreme Value Distribution</p></a></li>
<li><a href='#GevMdaEstimation'><p>Generalized Extreme Value Modelling</p></a></li>
<li><a href='#GevModelling'><p>Generalized Extreme Value Modelling</p></a></li>
<li><a href='#GevRisk'><p>Generalized Extreme Value Modelling</p></a></li>
<li><a href='#GpdDistribution'><p>Generalized Pareto Distribution</p></a></li>
<li><a href='#GpdModelling'><p>GPD Distributions for Extreme Value Theory</p></a></li>
<li><a href='#gpdRisk'><p>GPD Distributions for Extreme Value Theory</p></a></li>
<li><a href='#TimeSeriesData'><p>Time Series Data Sets</p></a></li>
<li><a href='#ValueAtRisk'><p>Value-at-Risk</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Rmetrics - Modelling Extreme Events in Finance</td>
</tr>
<tr>
<td>Version:</td>
<td>4032.84</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for analysing
  and modelling extreme events in financial time Series. The
  topics include: (i) data pre-processing, (ii) explorative 
  data analysis, (iii) peak over threshold modelling, (iv) block
  maxima modelling, (v) estimation of VaR and CVaR, and (vi) the
  computation of the extreme index.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fBasics, fGarch, graphics, methods, stats, timeDate,
timeSeries</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, tcltk</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.rmetrics.org">https://www.rmetrics.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/projects/rmetrics">https://r-forge.r-project.org/projects/rmetrics</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-21 19:35:48 UTC; Paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Diethelm Wuertz [aut],
  Tobias Setz [aut],
  Yohan Chalabi [aut],
  Paul J. Northrop [cre, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='DataPreprocessing'>Extremes Data Preprocessing</h2><span id='topic+DataPreprocessing'></span><span id='topic+blockMaxima'></span><span id='topic+findThreshold'></span><span id='topic+pointProcess'></span><span id='topic+deCluster'></span>

<h3>Description</h3>

<p>A collection and description of functions for data 
preprocessing of extreme values. This includes tools 
to separate data beyond a threshold value, to compute 
blockwise data like block maxima, and to decluster 
point process data.
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>blockMaxima</code> </td><td style="text-align: left;"> Block Maxima from a vector or a time series, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>findThreshold</code> </td><td style="text-align: left;"> Upper threshold for a given number of extremes, </td>
</tr>
<tr>
 <td style="text-align: left;">  
    <code>pointProcess</code> </td><td style="text-align: left;"> Peaks over Threshold from a vector or a time series, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>deCluster</code> </td><td style="text-align: left;"> Declusters clustered point process data. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>blockMaxima(x, block = c("monthly", "quarterly"), doplot = FALSE)
findThreshold(x, n = floor(0.05*length(as.vector(x))), doplot = FALSE)
pointProcess(x, u = quantile(x, 0.95), doplot = FALSE)
deCluster(x, run = 20, doplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataPreprocessing_+3A_block">block</code></td>
<td>

<p>the block size. A numeric value is interpreted as the number  
of data values in each successive block. All the data is used,
so the last block may not contain <code>block</code> observations. 
If the <code>data</code> has a  <code>times</code> attribute containing (in
an object of class <code>"POSIXct"</code>, or an object that can be
converted to that class, see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>) the
times/dates of each observation, then <code>block</code> may instead
take the character values <code>"month"</code>, <code>"quarter"</code>,
<code>"semester"</code> or <code>"year"</code>. By default monthly blocks
from daily data are assumed.
</p>
</td></tr>
<tr><td><code id="DataPreprocessing_+3A_doplot">doplot</code></td>
<td>

<p>a logical value. Should the results be plotted? By 
default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="DataPreprocessing_+3A_n">n</code></td>
<td>

<p>a numeric value or vector giving number of extremes above 
the threshold. By default, <code>n</code> is 
set to an integer representing 5% of the data from the 
whole data set <code>x</code>.
</p>
</td></tr>
<tr><td><code id="DataPreprocessing_+3A_run">run</code></td>
<td>

<p>parameter to be used in the runs method; any two consecutive 
threshold exceedances separated by more than this number of 
observations/days are considered to belong to different clusters.
</p>
</td></tr>  
<tr><td><code id="DataPreprocessing_+3A_u">u</code></td>
<td>

<p>a numeric value at which level the data are to be truncated. By 
default the threshold value which belongs to the 95% quantile,
<code>u=quantile(x,0.95)</code>.       
</p>
</td></tr>
<tr><td><code id="DataPreprocessing_+3A_x">x</code></td>
<td>

<p>a numeric data vector from which <code>findThreshold</code> and 
<code>blockMaxima</code> determine the threshold values and block 
maxima values. 
For the function <code>deCluster</code> the argument
<code>x</code> represents a numeric vector of threshold exceedances
with a <code>times</code> attribute which should be a numeric
vector containing either the indices or the times/dates
of each exceedance (if times/dates, the attribute should
be an object of class <code>"POSIXct"</code> or an object that
can be converted to that class; see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p><b>Computing Block Maxima:</b> 
<br /><br />  
The function <code>blockMaxima</code> calculates block maxima from a vector 
or a time series, whereas the function
<code>blocks</code> is more general and allows for the calculation of
an arbitrary function <code>FUN</code> on blocks.
<br />
</p>
<p><b>Finding Thresholds:</b> 
<br /><br />
The function <code>findThreshold</code> finds a threshold so that a given 
number of extremes lie above. When the data are tied a threshold is 
found so that at least the specified number of extremes lie above.
<br />
</p>
<p><b>De-Clustering Point Processes:</b> 
<br /><br />
The function <code>deCluster</code> declusters clustered point process 
data so that Poisson assumption is more tenable over a high threshold.
</p>


<h3>Value</h3>

<p><code>blockMaxima</code> 
<br />
returns a timeSeries object or a numeric vector of block 
maxima data.
</p>
<p><code>findThreshold</code> 
<br />
returns a numeric value or vector of suitable thresholds. 
</p>
<p><code>pointProcess</code> 
<br />
returns a timeSeries object or a numeric vector of peaks over
a threshold.
</p>
<p><code>deCluster</code> 
<br />
returns a timeSeries object or a numeric vector for the 
declustered point process. 
</p>


<h3>Author(s)</h3>

<p>Some of the functions were implemented from Alec Stephenson's 
R-package <code>evir</code> ported from Alexander McNeil's S library 
<code>EVIS</code>, <em>Extreme Values in S</em>, some from Alec Stephenson's 
R-package <code>ismev</code> based on Stuart Coles code from his book, 
<em>Introduction to Statistical Modeling of Extreme Values</em> and 
some were written by Diethelm Wuertz.
</p>


<h3>References</h3>

<p>Coles S. (2001);
<em>Introduction to Statistical Modelling of Extreme Values</em>,
Springer.
</p>
<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, Springer.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## findThreshold -
# Threshold giving (at least) fifty exceedances for Danish data:
library(timeSeries)
x &lt;- as.timeSeries(data(danishClaims))
findThreshold(x, n = c(10, 50, 100))    

## blockMaxima -
# Block Maxima (Minima) for left tail of BMW log returns:
BMW &lt;- as.timeSeries(data(bmwRet))
colnames(BMW) &lt;- "BMW.RET"
head(BMW)
x &lt;- blockMaxima( BMW, block = 65)
head(x)
## Not run: 
y &lt;- blockMaxima(-BMW, block = 65)    
head(y) 
y &lt;- blockMaxima(-BMW, block = "monthly")    
head(y)
## End(Not run)

## pointProcess -
# Return Values above threshold in negative BMW log-return data:
PP = pointProcess(x = -BMW, u = quantile(as.vector(x), 0.75))
PP
nrow(PP)

## deCluster -
# Decluster the 200 exceedances of a particular  
DC = deCluster(x = PP, run = 15, doplot = TRUE) 
DC
nrow(DC)
</code></pre>

<hr>
<h2 id='ExtremeIndex'>Extremal Index Estimation</h2><span id='topic+ExtremeIndex'></span><span id='topic+fTHETA'></span><span id='topic+fTHETA-class'></span><span id='topic+show+2CfTHETA-method'></span><span id='topic+thetaSim'></span><span id='topic+blockTheta'></span><span id='topic+clusterTheta'></span><span id='topic+runTheta'></span><span id='topic+ferrosegersTheta'></span><span id='topic+exindexPlot'></span><span id='topic+exindexesPlot'></span>

<h3>Description</h3>

<p>A collection and description of functions to simulate
time series with a known extremal index, and to estimate 
the extremal index by four different kind of methods, 
the blocks method, the reciprocal mean cluster size 
method, the runs method, and the method of Ferro and
Segers.
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>thetaSim</code> </td><td style="text-align: left;"> Simulates a time Series with known theta, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>blockTheta</code> </td><td style="text-align: left;"> Computes theta from Block Method, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>clusterTheta</code> </td><td style="text-align: left;"> Computes theta from Reciprocal Cluster Method, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>runTheta</code> </td><td style="text-align: left;"> Computes theta from Run Method, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ferrosegersTheta</code> </td><td style="text-align: left;"> Computes Theta according to Ferro and Segers, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>exindexPlot</code> </td><td style="text-align: left;"> Calculate and Plot Theta(1,2,3), </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>exindexesPlot</code> </td><td style="text-align: left;"> Calculate Theta(1,2) and Plot Theta(1). </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'fTHETA'
show(object)

thetaSim(model = c("max", "pair"), n = 1000, theta = 0.5)

blockTheta(x, block = 22, quantiles = seq(0.950, 0.995, length = 10),
    title = NULL, description = NULL)
clusterTheta(x, block = 22, quantiles = seq(0.950, 0.995, length = 10),
    title = NULL, description = NULL)
runTheta(x, block = 22, quantiles = seq(0.950, 0.995, length = 10),
    title = NULL, description = NULL)
ferrosegersTheta(x, quantiles = seq(0.950, 0.995, length = 10),
    title = NULL, description = NULL)
    
exindexPlot(x, block = c("monthly", "quarterly"), start = 5, end = NA, 
    doplot = TRUE, plottype = c("thresh", "K"), labels = TRUE, ...)
    
exindexesPlot(x, block = 22, quantiles = seq(0.950, 0.995, length = 10), 
    doplot = TRUE, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtremeIndex_+3A_block">block</code></td>
<td>

<p>[*Theta] - <br />
an integer value, the block size. Currently only integer specified
block sizes are supported.
<br />
[exindex*Plot] - <br />
the block size. Either <code>"monthly"</code>, <code>"quarterly"</code> or
an integer value. An integer value is interpreted as the number 
of data values in each successive block. The default value is
<code>"monthly"</code> which corresponds for daily data to an approximately
22-day periods.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_doplot">doplot</code></td>
<td>

<p>a logical, should the results be plotted?
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_labels">labels</code></td>
<td>

<p>whether or not axes should be labelled. If set to <code>FALSE</code>
then user specified labels can be passed through the <code>"..."</code>
argument.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_model">model</code></td>
<td>

<p>[thetaSim] - <br />
a character string denoting the name of the model. Either 
<code>"max"</code> or <code>"pair"</code>, the first representing the 
maximum Frechet series, and the second the paired exponential
series.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_n">n</code></td>
<td>

<p>[thetaSim] - <br />
an integer value, the length of the time series to be generated.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_object">object</code></td>
<td>

<p>an object of class <code>"fTHETA"</code> as returned by the functions
<code>*Theta</code>.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_plottype">plottype</code></td>
<td>

<p>[exindexPlot] - <br />
whether plot is to be by increasing threshold (<code>thresh</code>) 
or increasing K value (<code>K</code>).
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_quantiles">quantiles</code></td>
<td>

<p>[exindexesPlot] - <br />
a numeric vector of quantile values.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_start">start</code>, <code id="ExtremeIndex_+3A_end">end</code></td>
<td>

<p>[exindexPlot] - <br />
<code>start</code> is the lowest value of <code>K</code> at which to plot 
a point, and <code>end</code> the highest value; <code>K</code> is the
number of blocks in which a specified threshold is exceeded.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_theta">theta</code></td>
<td>

<p>[thetaSim] - <br />
a numeric value between 0 and 1 setting the value of the
extremal index for the maximum Frechet time series. (Not used
in the case of the paired exponential series.)
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_x">x</code></td>
<td>

<p>a 'timeSeries' object or any other object which can be transformed
by the function <code>as.vector</code> into a numeric vector. <code>"monthly"</code>
and <code>"quarterly"</code> blocks require <code>x</code> to be an object of
class <code>"timeSeries"</code>.
</p>
</td></tr>
<tr><td><code id="ExtremeIndex_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the plot function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>exindexPlot</code>
<br />
returns a data frame of results with the 
following columns: <code>N</code>, <code>K</code>, <code>un</code>, <code>theta2</code>,
and <code>theta</code>. A plot with <code>K</code> on the lower x-axis and
threshold Values on the upper x-axis versus the extremal index
is displayed.
</p>
<p><code>exindexesPlot</code>
<br />
returns a data.frame with four columns: 
<code>thresholds</code>, <code>theta1</code>, <code>theta2</code>, and <code>theta3</code>.
A plot with quantiles on the x-axis and versus the extremal indexes
is displayed.
</p>


<h3>Author(s)</h3>

<p>Alexander McNeil, for parts of the <code>exindexPlot</code> function, and <br />
Diethelm Wuertz for the <code>exindexesPlot</code> function.
</p>


<h3>References</h3>

<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, 
Springer. Chapter 8, 413&ndash;429.  
</p>


<h3>See Also</h3>

<p><code>hillPlot</code>,
<code>gevFit</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Extremal Index for the right and left tails 
## of the BMW log returns:
   data(bmwRet)
   par(mfrow = c(2, 2), cex = 0.7)
   library(timeSeries)
   exindexPlot( as.timeSeries(bmwRet), block = "quarterly")
   exindexPlot(-as.timeSeries(bmwRet), block = "quarterly")   
   
## Extremal Index for the right and left tails 
## of the BMW log returns:
   exindexesPlot( as.timeSeries(bmwRet), block = 65)
   exindexesPlot(-as.timeSeries(bmwRet), block = 65)   
</code></pre>

<hr>
<h2 id='ExtremesData'>Explorative Data Analysis</h2><span id='topic+ExtremesData'></span><span id='topic+emdPlot'></span><span id='topic+qqparetoPlot'></span><span id='topic+mePlot'></span><span id='topic+mrlPlot'></span><span id='topic+mxfPlot'></span><span id='topic+msratioPlot'></span><span id='topic+recordsPlot'></span><span id='topic+ssrecordsPlot'></span><span id='topic+sllnPlot'></span><span id='topic+lilPlot'></span><span id='topic+xacfPlot'></span><span id='topic+normMeanExcessFit'></span><span id='topic+ghMeanExcessFit'></span><span id='topic+hypMeanExcessFit'></span><span id='topic+nigMeanExcessFit'></span><span id='topic+ghtMeanExcessFit'></span>

<h3>Description</h3>

<p>A collection and description of functions for 
explorative data analysis. The tools include 
plot functions for empirical distributions, quantile 
plots, graphs exploring the properties of exceedances 
over a threshold, plots for mean/sum ratio and for 
the development of records.
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>emdPlot</code> </td><td style="text-align: left;"> Plot of empirical distribution function, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qqparetoPlot</code> </td><td style="text-align: left;"> Exponential/Pareto quantile plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>mePlot</code> </td><td style="text-align: left;"> Plot of mean excesses over a threshold, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>mrlPlot</code> </td><td style="text-align: left;"> another variant, mean residual life plot, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>mxfPlot</code> </td><td style="text-align: left;"> another variant, with confidence intervals, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>msratioPlot</code> </td><td style="text-align: left;"> Plot of the ratio of maximum and sum, </td>
</tr>
<tr>
 <td style="text-align: left;">   
    <code>recordsPlot</code> </td><td style="text-align: left;"> Record development compared with iid data, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ssrecordsPlot</code> </td><td style="text-align: left;"> another variant, investigates subsamples, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>sllnPlot</code> </td><td style="text-align: left;"> verifies Kolmogorov's strong law of large numbers, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lilPlot</code> </td><td style="text-align: left;"> verifies Hartman-Wintner's law of the iterated logarithm, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>xacfPlot</code> </td><td style="text-align: left;"> ACF of exceedances over a threshold, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>normMeanExcessFit</code> </td><td style="text-align: left;"> fits mean excesses with a normal density, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>ghMeanExcessFit</code> </td><td style="text-align: left;"> fits mean excesses with a GH density, </td>
</tr>
<tr>
 <td style="text-align: left;">   
    <code>hypMeanExcessFit</code> </td><td style="text-align: left;"> fits mean excesses with a HYP density, </td>
</tr>
<tr>
 <td style="text-align: left;">   
    <code>nigMeanExcessFit</code> </td><td style="text-align: left;"> fits mean excesses with a NIG density, </td>
</tr>
<tr>
 <td style="text-align: left;">  
    <code>ghtMeanExcessFit</code> </td><td style="text-align: left;"> fits mean excesses with a GHT density. </td>
</tr>

</table>
   


<h3>Usage</h3>

<pre><code class='language-R'>emdPlot(x, doplot = TRUE, plottype = c("xy", "x", "y", " "), 
    labels = TRUE, ...)

qqparetoPlot(x, xi = 0, trim = NULL, threshold = NULL, doplot = TRUE, 
    labels = TRUE, ...)

mePlot(x, doplot = TRUE, labels = TRUE, ...)
mrlPlot(x, ci = 0.95, umin = mean(x), umax = max(x), nint = 100, doplot = TRUE, 
     plottype = c("autoscale", ""), labels = TRUE, ...)  
mxfPlot(x, u = quantile(x, 0.05), doplot = TRUE, labels = TRUE, ...)  
   
msratioPlot(x, p = 1:4, doplot = TRUE, labels = TRUE, ...) 
   
recordsPlot(x, ci = 0.95, doplot = TRUE, labels = TRUE, ...)
ssrecordsPlot(x, subsamples = 10, doplot = TRUE, plottype = c("lin", "log"),
    labels = TRUE, ...)
    
sllnPlot(x, doplot = TRUE, labels = TRUE, ...)
lilPlot(x, doplot = TRUE, labels = TRUE, ...)

xacfPlot(x, u = quantile(x, 0.95), lag.max = 15, doplot = TRUE, 
    which = c("all", 1, 2, 3, 4), labels = TRUE, ...)
    
normMeanExcessFit(x, doplot = TRUE, trace = TRUE, ...)
ghMeanExcessFit(x, doplot = TRUE, trace = TRUE, ...)
hypMeanExcessFit(x, doplot = TRUE, trace = TRUE, ...)
nigMeanExcessFit(x, doplot = TRUE, trace = TRUE, ...)
ghtMeanExcessFit(x, doplot = TRUE, trace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtremesData_+3A_ci">ci</code></td>
<td>

<p>[recordsPlot] - <br />
a confidence level. By default 0.95, i.e. 95%.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_doplot">doplot</code></td>
<td>

<p>a logical value. Should the results be plotted? By 
default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_labels">labels</code></td>
<td>

<p>a logical value. Whether or not x- and y-axes should be automatically 
labelled and a default main title should be added to the plot.
By default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_lag.max">lag.max</code></td>
<td>

<p>[xacfPlot] - <br />
maximum number of lags at which to calculate the autocorrelation 
functions. The default value is 15.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_nint">nint</code></td>
<td>

<p>[mrlPlot] - <br />
the number of intervals, see <code>umin</code> and <code>umax</code>. The 
default value is 100.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_p">p</code></td>
<td>

<p>[msratioPlot] - <br />
the power exponents, a numeric vector. By default a sequence from  
1 to 4 in unit integer steps.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_plottype">plottype</code></td>
<td>

<p>[emdPlot] - <br />
which axes should be on a log scale: <code>"x"</code> x-axis only; 
<code>"y"</code> y-axis only; <code>"xy"</code> both axes; <code>""</code> 
neither axis.
<br />
[msratioPlot] - <br />
a logical, if set to <code>"autoscale"</code>, then the scale of the 
plots are automatically determined, any other string allows user
specified scale information through the <code>...</code> argument.
<br />
[ssrecordsPlot] - <br />
one from two options can be select either <code>"lin"</code>
or <code>"log"</code>. The default creates a linear plot.
</p>
</td></tr> 
<tr><td><code id="ExtremesData_+3A_subsamples">subsamples</code></td>
<td>

<p>[ssrecordsPlot] - <br />
the number of subsamples, by default 10, an integer value.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_threshold">threshold</code>, <code id="ExtremesData_+3A_trim">trim</code></td>
<td>

<p>[qPlot][xacfPlot] - <br />
a numeric value at which data are to be left-truncated, value 
at which data are to be right-truncated or the threshold value, 
by default 95%.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_trace">trace</code></td>
<td>

<p>a logical flag, by default <code>TRUE</code>. Should the calculations     
be traced?
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_u">u</code></td>
<td>

<p>a numeric value at which level the data are to be truncated. By 
default the threshold value which belongs to the 95% quantile,
<code>u=quantile(x,0.95)</code>.       
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_umin">umin</code>, <code id="ExtremesData_+3A_umax">umax</code></td>
<td>

<p>[mrlPlot] - <br />
range of threshold values. If <code>umin</code> and/or <code>umax</code> are 
not available, then by default they are set to the following 
values: <code>umin=mean(x)</code> and <code>umax=max(x)</code>.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_which">which</code></td>
<td>

<p>[xacfPlot] - <br />
a numeric or character value, if <code>which="all"</code> then all
four plots are displayed, if <code>which</code> is an integer between
one and four, then the first, second, third or fourth plot will
be displayed.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_x">x</code>, <code id="ExtremesData_+3A_y">y</code></td>
<td>

<p>numeric data vectors or in the case of x an object to be plotted.  
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_xi">xi</code></td>
<td>

<p>the shape parameter of the generalized Pareto distribution.
</p>
</td></tr>
<tr><td><code id="ExtremesData_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the FUN or plot function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Empirical Distribution Function:</b>
<br /><br />
The function <code>emdPlot</code> is a simple explanatory function. A 
straight line on the double log scale indicates Pareto tail behaviour.
<br />
</p>
<p><b>Quantile&ndash;Quantile Pareto Plot:</b>
<br /><br />      
<code>qqparetoPlot</code> creates a quantile-quantile plot for threshold 
data. If <code>xi</code> is zero the reference distribution is the 
exponential; if <code>xi</code> is non-zero the reference distribution 
is the generalized Pareto with that parameter value expressed 
by <code>xi</code>. In the case of the exponential, the plot is 
interpreted as follows: Concave departures from a straight line are a 
sign of heavy-tailed behaviour, convex departures show thin-tailed 
behaviour. 
<br />
</p>
<p><b>Mean Excess Function Plot:</b>
<br /><br />
Three variants to plot the mean excess function are available: 
A sample mean excess plot over increasing thresholds, and two mean 
excess function plots with confidence intervals for discrimination 
in the tails of a distribution.
In general, an upward trend in a mean excess function plot shows 
heavy-tailed behaviour. In particular, a straight line with positive 
gradient above some threshold is a sign of Pareto behaviour in tail. 
A downward trend shows thin-tailed behaviour whereas a line with 
zero gradient shows an exponential tail. Here are some hints:
Because upper plotting points are the average of a handful of extreme 
excesses, these may be omitted for a prettier plot. 
For <code>mrlPlot</code> and <code>mxfPlot</code> the upper tail is investigated; 
for the lower tail reverse the sign of the <code>data</code> vector.
<br />
</p>
<p><b>Plot of the Maximum/Sum Ratio:</b>
<br /><br />
The ratio of maximum and sum is a simple tool for detecting heavy 
tails of a distribution and for giving a rough estimate of
the order of its finite moments. Sharp increases in the curves
of a <code>msratioPlot</code> are a sign for heavy tail behaviour.
<br />
</p>
<p><b>Plot of the Development of Records:</b>
<br /><br />
These are functions that investigate the development of records in 
a dataset and calculate the expected behaviour for iid data.
<code>recordsPlot</code> counts records and reports the observations 
at which they occur. In addition subsamples can be investigated
with the help of the function <code>ssrecordsPlot</code>.
<br />
</p>
<p><b>Plot of Kolmogorov's and Hartman-Wintner's Laws:</b>
<br /><br />
The function <code>sllnPlot</code> verifies Kolmogorov's strong law of 
large numbers, and the function <code>lilPlot</code> verifies 
Hartman-Wintner's law of the iterated logarithm.
<br />
</p>
<p><b>ACF Plot of Exceedances over a Threshold:</b>
<br /><br />
This function plots the autocorrelation functions of heights and 
distances of exceedances over a threshold.
<br />
</p>


<h3>Value</h3>

<p>The functions return a plot.
</p>


<h3>Note</h3>

<p>The plots are labeled by default with a x-label, a y-label and
a main title. If the argument <code>labels</code> is set to <code>FALSE</code>
neither a x-label, a y-label nor a main title will be added to the
graph. To add user defined label strings just use the 
function <code>title(xlab="\dots", ylab="\dots", main="\dots")</code>.
</p>


<h3>Author(s)</h3>

<p>Some of the functions were implemented from Alec Stephenson's 
R-package <code>evir</code> ported from Alexander McNeil's S library 
<code>EVIS</code>, <em>Extreme Values in S</em>, some from Alec Stephenson's 
R-package <code>ismev</code> based on Stuart Coles code from his book, 
<em>Introduction to Statistical Modeling of Extreme Values</em> and 
some were written by Diethelm Wuertz.
</p>


<h3>References</h3>

<p>Coles S. (2001);
<em>Introduction to Statistical Modelling of Extreme Values</em>,
Springer.
</p>
<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, Springer.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Danish fire insurance data:
   data(danishClaims)
   library(timeSeries)
   danishClaims = as.timeSeries(danishClaims)
   
## emdPlot -
   # Show Pareto tail behaviour:
   par(mfrow = c(2, 2), cex = 0.7)
   emdPlot(danishClaims) 
   
## qqparetoPlot -
   # QQ-Plot of heavy-tailed Danish fire insurance data:
   qqparetoPlot(danishClaims, xi = 0.7) 
 
## mePlot -
   # Sample mean excess plot of heavy-tailed Danish fire:
   mePlot(danishClaims)
      
## ssrecordsPlot -
   # Record fire insurance losses in Denmark:
   ssrecordsPlot(danishClaims, subsamples = 10) 
</code></pre>

<hr>
<h2 id='fExtremes-internal'>Internal fExtremes functions</h2><span id='topic+fExtremes-internal'></span><span id='topic+.depd'></span><span id='topic+.devd'></span><span id='topic+.emaTA'></span><span id='topic+.garch11MetricsPlot'></span><span id='topic+.gev1Plot'></span><span id='topic+.gev2Plot'></span><span id='topic+.gev3Plot'></span><span id='topic+.gev4Plot'></span><span id='topic+.gevFit'></span><span id='topic+.gevLLH'></span><span id='topic+.gevmleFit'></span><span id='topic+.gevpwmFit'></span><span id='topic+.gevrlevelLLH'></span><span id='topic+.gpd1Plot'></span><span id='topic+.gpd2Plot'></span><span id='topic+.gpd3Plot'></span><span id='topic+.gpd4Plot'></span><span id='topic+.gpdLLH'></span><span id='topic+.gpdmleFit'></span><span id='topic+.gpdmleFitCheck'></span><span id='topic+.gpdpwmFit'></span><span id='topic+.gpdpwmFitCheck'></span><span id='topic+.gumLLH'></span><span id='topic+.gummleFit'></span><span id='topic+.gumpwmFit'></span><span id='topic+.meanExcessPlot'></span><span id='topic+.pepd'></span><span id='topic+.pevd'></span><span id='topic+.qepd'></span><span id='topic+.qevd'></span><span id='topic+.repd'></span><span id='topic+.revd'></span><span id='topic+.riskMetricsPlot'></span><span id='topic+.tailSlider.Thresholds'></span><span id='topic+.tailSlider.conf'></span><span id='topic+.tailSlider.counter'></span><span id='topic+.tailSlider.last.Quantile'></span><span id='topic+.tailSlider.last.nThresholds'></span><span id='topic+.tailSlider.param'></span>

<h3>Description</h3>

<p>Internal fExtremes functions
</p>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='fExtremes-package'>Modelling Extreme Events in Finance</h2><span id='topic+fExtremes-package'></span><span id='topic+fExtremes'></span>

<h3>Description</h3>

<p>The Rmetrics &quot;fExtremes&quot; package is a collection of functions to 
analyze and model extreme events in Finance and Insurance.
</p>


<h3>Details</h3>

<pre>
        Package:    fExtremes
        Type:       Package
        License:    GPL Version 2 or later
        Copyright:  (c) 1999-2014 Rmetrics Association
        URL:        https://www.rmetrics.org
    </pre>


<h3>1 Introduction</h3>

<p>The <code>fExtremes</code> package provides functions for analyzing
and modeling extreme events in financial time Series. The
topics include: (i) data pre-processing, (ii) explorative 
data analysis, (iii) peak over threshold modeling, (iv) block
maxima modeling, (v) estimation of VaR and CVaR, and (vi) the
computation of the extreme index.
</p>


<h3>2 Data and their Preprocessing</h3>

<p><em>Data Sets:</em>
</p>
<p>Data sets used in the examples of the timeSeries packages.
</p>
<p><em>Data Preprocessing:</em>
</p>
<p>These are tools for data preprocessing, including functions to 
separate data beyond a threshold value, to compute blockwise data 
like block maxima, and to decluster point process data.
</p>
<pre>
    blockMaxima     extracts block maxima from a vector or a time series 
    findThreshold   finds upper threshold for a given number of extremes  
    pointProcess    extracts peaks over Threshold from a vector or a time series 
    deCluster       de-clusters clustered point process data
    </pre>


<h3>2 Explorative Data Analysis of Extremes</h3>

<p>This section contains a collection of functions for explorative data 
analysis of extreme values in financial time series. The tools include 
plot functions for empirical distributions, quantile plots, graphs 
exploring the properties of exceedances over a threshold, plots for 
mean/sum ratio and for the development of records. The functions are:
</p>
<pre>
    emdPlot         plots of empirical distribution function
    qqparetoPlot    exponential/Pareto quantile plot
    mePlot          plot of mean excesses over a threshold
    mrlPlot         another variant, mean residual life plot
    mxfPlot         another variant, with confidence intervals
    msratioPlot     plot of the ratio of maximum and sum
    </pre>
<pre>
    recordsPlot     Record development compared with iid data
    ssrecordsPlot   another variant, investigates subsamples
    sllnPlot        verifies Kolmogorov's strong law of large numbers
    lilPlot         verifies Hartman-Wintner's law of the iterated logarithm
    </pre>
<pre>
    xacfPlot        plots ACF of exceedances over a threshold
    </pre>
<p><em>Parameter Fitting of Mean Excesses:</em>
</p>
<pre>
    normMeanExcessFit    fits mean excesses with a normal density
    ghMeanExcessFit      fits mean excesses with a GH density   
    hypMeanExcessFit     fits mean excesses with a HYP density   
    nigMeanExcessFit     fits mean excesses with a NIG density  
    ghtMeanExcessFit     fits mean excesses with a GHT density
    </pre>


<h3>3 GPD Peak over Threshold Modeling</h3>

<p><em>GPD Distribution:</em>
</p>
<p>A collection of functions to compute the generalized Pareto 
distribution. The functions compute density, distribution 
function, quantile function and generate random deviates 
for the GPD. In addition functions to compute the true 
moments and to display the distribution and random variates 
changing parameters interactively are available.
</p>
<pre>
    dgpd            returns the density of the GPD distribution
    pgpd            returns the probability function of the GPD
    qgpd            returns quantile function of the GPD distribution
    rgpd            generates random variates from the GPD distribution
    gpdSlider       displays density or rvs from a GPD
    </pre>
<p><em>GPD Moments:</em>
</p>
<pre>
    gpdMoments      computes true mean and variance of GDP
    </pre>
<p><em>GPD Parameter Estimation:</em>
</p>
<p>This section contains functions to fit and to simulate processes that
are generated from the generalized Pareto distribution. Two 
approaches for parameter estimation are provided: Maximum likelihood 
estimation and the probability weighted moment method.
</p>
<pre>
    gpdSim          generates data from the GPD distribution
    gpdFit          fits data to the GPD istribution
    </pre>
<p><em>GPD print, plot and summary methods:</em>
</p>
<pre>
    print           print method for a fitted GPD object
    plot            plot method for a fitted GPD object
    summary         summary method for a fitted GPD object
    </pre>
<p><em>GDP Tail Risk:</em>
</p>
<p>The following functions compute tail risk under the GPD approach.
</p>
<pre>
    gpdQPlot        estimation of high quantiles
    gpdQuantPlot    variation of high quantiles with threshold
    gpdRiskMeasures prescribed quantiles and expected shortfalls
    gpdSfallPlot    expected shortfall with confidence intervals
    gpdShapePlot    variation of GPD shape with threshold
    gpdTailPlot     plot of the GPD tail
    </pre>







<h3>4 GEV Block Maxima Modeling</h3>

<p><em>GEV Distribution:</em>
</p>
<p>This section contains functions to fit and to simulate processes 
that are generated from the generalized extreme value distribution
including the Frechet, Gumbel, and Weibull distributions.
</p>
<pre>
    dgev            returns density of the GEV distribution
    pgev            returns probability function of the GEV
    qgev            returns quantile function of the GEV distribution
    rgev            generates random variates from the GEV distribution
    gevSlider       displays density or rvs from a GEV
    </pre>
<p><em>GEV Moments:</em>
</p>
<pre>
    gevMoments      computes true mean and variance
    </pre>
<p><em>GEV Parameter Estimation:</em>
</p>
<p>A collection to simulate and to estimate the parameters of
processes generated from GEV distribution.
</p>
<pre>
    gevSim          generates data from the GEV distribution
    gumbelSim       generates data from the Gumbel distribution
    gevFit          fits data to the GEV distribution
    gumbelFit       fits data to the Gumbel distribution
    </pre>
<pre>
    print           print method for a fitted GEV object
    plot            plot method for a fitted GEV object
    summary         summary method for a fitted GEV object
    </pre>
<p><em>GEV MDA Estimation:</em>
</p>
<p>Here we provide Maximum Domain of Attraction estimators and visualize 
the results by a Hill plot and a common shape parameter plot from
the Pickands, Einmal-Decker-deHaan, and Hill estimators.
</p>
<pre>
    hillPlot        shape parameter and Hill estimate of the tail index
    shaparmPlot     variation of shape parameter with tail depth
    </pre>
<p><em>GEV Risk Estimation:</em>
</p>
<pre>
    gevrlevelPlot   k-block return level with confidence intervals
    </pre>


<h3>4 Value at Risk</h3>

<p>Two functions to compute Value-at-Risk and conditional 
Value-at-Risk.
</p>
<pre>
    VaR             computes Value-at-Risk
    CVaR            computes conditional Value-at-Risk
    </pre>


<h3>5 Extreme Index</h3>

<p>A collection of functions to simulate time series with a known extremal 
index, and to estimate the extremal index by four different kind of 
methods, the blocks method, the reciprocal mean cluster size method, 
the runs method, and the method of Ferro and Segers.
</p>
<pre>
    thetaSim             simulates a time Series with known theta
    blockTheta           computes theta from Block Method
    clusterTheta         computes theta from Reciprocal Cluster Method
    runTheta             computes theta from Run Method
    ferrosegersTheta     computes theta according to Ferro and Segers
    </pre>
<pre>
    exindexPlot          calculates and plots Theta(1,2,3)
    exindexesPlot        calculates Theta(1,2) and plots Theta(1)
    </pre>


<h3>About Rmetrics</h3>

<p>The <code>fExtremes</code> Rmetrics package is written for educational 
support in teaching &quot;Computational Finance and Financial Engineering&quot; 
and licensed under the GPL.
</p>

<hr>
<h2 id='GevDistribution'>Generalized Extreme Value Distribution</h2><span id='topic+GevDistribution'></span><span id='topic+dgev'></span><span id='topic+pgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span><span id='topic+gevMoments'></span><span id='topic+gevSlider'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random 
number generation, and true moments for the GEV including 
the Frechet, Gumbel, and Weibull distributions.
<br />
</p>
<p>The GEV distribution functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>dgev</code> </td><td style="text-align: left;"> density of the GEV distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>pgev</code> </td><td style="text-align: left;"> probability function of the GEV distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qgev</code> </td><td style="text-align: left;"> quantile function of the GEV distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rgev</code> </td><td style="text-align: left;"> random variates from the GEV distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gevMoments</code> </td><td style="text-align: left;"> computes true mean and variance, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gevSlider</code> </td><td style="text-align: left;"> displays density or rvs from a GEV.</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>dgev(x, xi = 1, mu = 0, beta = 1, log = FALSE)
pgev(q, xi = 1, mu = 0, beta = 1, lower.tail = TRUE)
qgev(p, xi = 1, mu = 0, beta = 1, lower.tail = TRUE)
rgev(n, xi = 1, mu = 0, beta = 1)

gevMoments(xi = 0, mu = 0, beta = 1)

gevSlider(method = c("dist", "rvs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GevDistribution_+3A_log">log</code></td>
<td>

<p>a logical, if <code>TRUE</code>, the log density is returned.
</p>
</td></tr>
<tr><td><code id="GevDistribution_+3A_lower.tail">lower.tail</code></td>
<td>

<p>a logical, if <code>TRUE</code>, the default, then
probabilities are <code>P[X &lt;= x]</code>, otherwise, <code>P[X &gt; x]</code>.
</p>
</td></tr>
<tr><td><code id="GevDistribution_+3A_method">method</code></td>
<td>
       
<p>a character string denoting what should be displayed. Either
the density and <code>"dist"</code> or random variates <code>"rvs"</code>.
</p>
</td></tr> 
<tr><td><code id="GevDistribution_+3A_n">n</code></td>
<td>
      
<p>the number of observations.
</p>
</td></tr> 
<tr><td><code id="GevDistribution_+3A_p">p</code></td>
<td>

<p>a numeric vector of probabilities.
[hillPlot] - <br />
probability required when option <code>quantile</code> is
chosen.
</p>
</td></tr>
<tr><td><code id="GevDistribution_+3A_q">q</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="GevDistribution_+3A_x">x</code></td>
<td>

<p>a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="GevDistribution_+3A_xi">xi</code>, <code id="GevDistribution_+3A_mu">mu</code>, <code id="GevDistribution_+3A_beta">beta</code></td>
<td>

<p><code>xi</code> is the shape parameter, <code>mu</code> the location parameter,
and <code>beta</code> is the scale parameter. The default values are 
<code>xi=1</code>, <code>mu=0</code>, and <code>beta=1</code>. Note, if <code>xi=0</code> 
the distribution is of type Gumbel.
</p>
</td></tr>   
</table>


<h3>Value</h3>

<p><code>d*</code> returns the density, <br />
<code>p*</code> returns the probability, <br />
<code>q*</code> returns the quantiles, and <br />
<code>r*</code> generates random variates. <br />
</p>
<p>All values are numeric vectors.
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for R's <code>evd</code> and <code>evir</code> package, and <br />
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Coles S. (2001);
<em>Introduction to Statistical Modelling of Extreme Values</em>,
Springer.
</p>
<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, 
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rgev -
   # Create and plot 1000 Weibull distributed rdv:
   r = rgev(n = 1000, xi = -1)
   plot(r, type = "l", col = "steelblue", main = "Weibull Series")
   grid()
   
## dgev - 
   # Plot empirical density and compare with true density:
   hist(r[abs(r)&lt;10], nclass = 25, freq = FALSE, xlab = "r", 
     xlim = c(-5,5), ylim = c(0,1.1), main = "Density")
   box()
   x = seq(-5, 5, by = 0.01)
   lines(x, dgev(x, xi = -1), col = "steelblue")
   
## pgev -
   # Plot df and compare with true df:
   plot(sort(r), (1:length(r)/length(r)), 
     xlim = c(-3, 6), ylim = c(0, 1.1),
     cex = 0.5, ylab = "p", xlab = "q", main = "Probability")
   grid()
   q = seq(-5, 5, by = 0.1)
   lines(q, pgev(q, xi = -1), col = "steelblue")
 
## qgev -   
   # Compute quantiles, a test:
   qgev(pgev(seq(-5, 5, 0.25), xi = -1), xi = -1)   

## gevMoments:
   # Returns true mean and variance:
   gevMoments(xi = 0, mu = 0, beta = 1)
   
## Slider:
   # gevSlider(method = "dist")
   # gevSlider(method = "rvs")
</code></pre>

<hr>
<h2 id='GevMdaEstimation'>Generalized Extreme Value Modelling</h2><span id='topic+GevMdaEstimation'></span><span id='topic+hillPlot'></span><span id='topic+shaparmPlot'></span><span id='topic+shaparmPickands'></span><span id='topic+shaparmHill'></span><span id='topic+shaparmDEHaan'></span>

<h3>Description</h3>

<p>A collection and description functions to estimate 
the parameters of the GEV distribution. To model
the GEV three types of approaches for parameter 
estimation are provided: Maximum likelihood
estimation, probability weighted moment method,
and estimation by the MDA approach. MDA includes
functions for the Pickands, Einmal-Decker-deHaan, 
and Hill estimators together with several plot 
variants.
<br />
</p>
<p>Maximum Domain of Attraction estimators:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>hillPlot</code> </td><td style="text-align: left;"> shape parameter and Hill estimate of the tail index, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>shaparmPlot</code> </td><td style="text-align: left;"> variation of shape parameter with tail depth. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>hillPlot(x, start = 15, ci = 0.95, 
    doplot = TRUE, plottype = c("alpha", "xi"), labels = TRUE, ...)
shaparmPlot(x, p = 0.01*(1:10), xiRange = NULL, alphaRange = NULL,
    doplot = TRUE, plottype = c("both", "upper"))
    
shaparmPickands(x, p = 0.05, xiRange = NULL,  
    doplot = TRUE, plottype = c("both", "upper"), labels = TRUE, ...) 
shaparmHill(x, p = 0.05, xiRange = NULL,  
    doplot = TRUE, plottype = c("both", "upper"), labels = TRUE, ...)
shaparmDEHaan(x, p = 0.05, xiRange = NULL,  
    doplot = TRUE, plottype = c("both", "upper"), labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GevMdaEstimation_+3A_alpharange">alphaRange</code>, <code id="GevMdaEstimation_+3A_xirange">xiRange</code></td>
<td>

<p>[saparmPlot] - <br />
plotting ranges for <code>alpha</code> and <code>xi</code>. By default the
values are automatically selected.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_ci">ci</code></td>
<td>

<p>[hillPlot] - <br />
probability for asymptotic confidence band; for no
confidence band set <code>ci</code> to zero.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_doplot">doplot</code></td>
<td>

<p>a logical. Should the results be plotted?
<br />
[shaparmPlot] - <br />
a vector of logicals of the same lengths as tails
defining for which tail depths plots should be created,
by default plots will be generated for a tail depth of 5
percent. By default <code>c(FALSE, FALSE, FALSE, FALSE, 
        TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)</code>.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_labels">labels</code></td>
<td>

<p>[hillPlot] - <br />
whether or not axes should be labelled.
</p>
</td></tr> 
<tr><td><code id="GevMdaEstimation_+3A_plottype">plottype</code></td>
<td>

<p>[hillPlot] - <br />
whether <code>alpha</code>, <code>xi</code> (1/alpha) or
<code>quantile</code> (a quantile estimate) should be plotted.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_p">p</code></td>
<td>

<p>[qgev] - <br />
a numeric vector of probabilities.
[hillPlot] - <br />
probability required when option <code>quantile</code> is
chosen.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_start">start</code></td>
<td>

<p>[hillPlot] - <br />
lowest number of order statistics at which to plot
a point.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_x">x</code></td>
<td>

<p>[dgev][devd] - <br />
a numeric vector of quantiles.
<br />
[gevFit] - <br />
data vector. In the case of <code>method="mle"</code> the interpretation 
depends on the value of block: if no block size is specified then 
data are interpreted as block maxima; if block size is set, then data
are interpreted as raw data and block maxima are calculated. 
<br />
[hillPlot][shaparmPlot] - <br />
the data from which to calculate the shape parameter, a
numeric vector.
<br />
[print][plot] - <br />
a fitted object of class <code>"gevFit"</code>.
</p>
</td></tr>
<tr><td><code id="GevMdaEstimation_+3A_...">...</code></td>
<td>

<p>[gevFit] - <br />
control parameters optionally passed to the 
optimization function. Parameters for the optimization
function are passed to components of the <code>control</code> argument of
<code>optim</code>. 
<br />
[hillPlot] - <br />
other graphics parameters.
<br />
[plot][summary] - <br />
arguments passed to the plot function.
</p>
</td></tr>    
</table>


<h3>Details</h3>

<p><b>Parameter Estimation:</b>
<br /><br />
<code>gevFit</code> and <code>gumbelFit</code> estimate the parameters either 
by the probability weighted moment method, <code>method="pwm"</code> or 
by maximum log likelihood estimation <code>method="mle"</code>. The 
summary method produces diagnostic plots for fitted GEV or Gumbel 
models.
<br />
</p>
<p><b>Methods:</b>
<br /><br />
<code>print.gev</code>, <code>plot.gev</code> and <code>summary.gev</code> are
print, plot, and summary methods for a fitted object of class 
<code>gev</code>. Concerning the summary method, the data are 
converted to unit exponentially distributed residuals under null 
hypothesis that GEV fits. Two diagnostics for iid exponential data 
are offered. The plot method provides two different residual plots 
for assessing the fitted GEV model. Two diagnostics for 
iid exponential data are offered. 
<br />
</p>
<p><b>Return Level Plot:</b>
<br /><br />
<code>gevrlevelPlot</code> calculates and plots the k-block return level 
and 95% confidence interval based on a GEV model for block maxima, 
where <code>k</code> is specified by the user. The k-block return level 
is that level exceeded once every <code>k</code> blocks, on average. The 
GEV likelihood is reparameterized in terms of the unknown return 
level and profile likelihood arguments are used to construct a 
confidence interval. 
<br />
</p>
<p><b>Hill Plot:</b>
<br /><br />
The function <code>hillPlot</code> investigates the shape parameter and 
plots the Hill estimate of the tail index of heavy-tailed data, or 
of an associated quantile estimate. This plot is usually calculated 
from the alpha perspective. For a generalized Pareto analysis of 
heavy-tailed data using the <code>gpdFit</code> function, it helps to 
plot the Hill estimates for <code>xi</code>. 
<br />
</p>
<p><b>Shape Parameter Plot:</b>
<br /><br />
The function <code>shaparmPlot</code> investigates the shape parameter and 
plots for the upper and lower tails the shape parameter as a function 
of the taildepth. Three approaches are considered, the <em>Pickands</em> 
estimator, the <em>Hill</em> estimator, and the
<em>Decker-Einmal-deHaan</em> estimator.
</p>


<h3>Value</h3>

<p><code>gevSim</code>
<br />
returns a vector of data points from the simulated series.
<br />
</p>
<p><code>gevFit</code>
<br />
returns an object of class <code>gev</code> describing the fit.
<br />
</p>
<p><code>print.summary</code>
<br />
prints a report of the parameter fit.
<br />
</p>
<p><code>summary</code>
<br />
performs diagnostic analysis. The method provides two different 
residual plots for assessing the fitted GEV model.  
<br />
</p>
<p><code>gevrlevelPlot</code>
<br />
returns a vector containing the lower 95% bound of the confidence 
interval, the estimated return level and the upper 95% bound. 
<br />
</p>
<p><code>hillPlot</code>
<br />
displays a plot.
<br />
</p>
<p><code>shaparmPlot</code> 
<br />
returns a list with one or two entries, depending on the
selection of the input variable <code>both.tails</code>. The two 
entries <code>upper</code> and <code>lower</code> determine the position of 
the tail. Each of the two variables is again a list with entries 
<code>pickands</code>, <code>hill</code>, and <code>dehaan</code>. If one of the 
three methods will be discarded the printout will display zeroes.
</p>


<h3>Note</h3>

<p><b>GEV Parameter Estimation:</b>
<br /><br />
If method <code>"mle"</code> is selected the parameter fitting in <code>gevFit</code> 
is passed to the internal function <code>gev.mle</code> or <code>gumbel.mle</code>
depending on the value of <code>gumbel</code>, <code>FALSE</code> or <code>TRUE</code>.
On the other hand, if method <code>"pwm"</code> is selected the parameter 
fitting in <code>gevFit</code> is passed to the internal function 
<code>gev.pwm</code> or <code>gumbel.pwm</code> again depending on the value of 
<code>gumbel</code>, <code>FALSE</code> or <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for R's <code>evd</code> and <code>evir</code> package, and <br />
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Coles S. (2001);
<em>Introduction to Statistical Modelling of Extreme Values</em>,
Springer.
</p>
<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, 
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
## Load Data:
   library(timeSeries)
   x = as.timeSeries(data(danishClaims))
   colnames(x) &lt;- "Danish"
   head(x)
   
## hillPlot -
   # Hill plot of heavy-tailed Danish fire insurance data 
   par(mfrow = c(1, 1))
   hillPlot(x, plottype = "xi")
   grid()
</code></pre>

<hr>
<h2 id='GevModelling'>Generalized Extreme Value Modelling</h2><span id='topic+GevModelling'></span><span id='topic+fGEVFIT'></span><span id='topic+fGEVFIT-class'></span><span id='topic+show+2CfGEVFIT-method'></span><span id='topic+gevSim'></span><span id='topic+gumbelSim'></span><span id='topic+gevFit'></span><span id='topic+gumbelFit'></span><span id='topic+plot.fGEVFIT'></span><span id='topic+summary.fGEVFIT'></span>

<h3>Description</h3>

<p>A collection and description functions to estimate 
the parameters of the GEV distribution. To model
the GEV three types of approaches for parameter 
estimation are provided: Maximum likelihood
estimation, probability weighted moment method,
and estimation by the MDA approach. MDA includes
functions for the Pickands, Einmal-Decker-deHaan, 
and Hill estimators together with several plot 
variants.
<br />
</p>
<p>The GEV modelling functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>gevSim</code> </td><td style="text-align: left;"> generates data from the GEV distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gumbelSim</code> </td><td style="text-align: left;"> generates data from the Gumbel distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gevFit</code> </td><td style="text-align: left;"> fits data to the GEV distribution, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>gumbelFit</code> </td><td style="text-align: left;"> fits data to the Gumbel distribution, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>print</code> </td><td style="text-align: left;"> print method for a fitted GEV object, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plot</code> </td><td style="text-align: left;"> plot method for a fitted GEV object, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>summary</code> </td><td style="text-align: left;"> summary method for a fitted GEV object, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gevrlevelPlot</code> </td><td style="text-align: left;"> k-block return level with confidence intervals. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>gevSim(model = list(xi = -0.25, mu = 0, beta = 1), n = 1000, seed = NULL)
gumbelSim(model = list(mu = 0, beta = 1), n = 1000, seed = NULL)

gevFit(x, block = 1, type = c("mle", "pwm"), title = NULL, description = NULL, ...)
gumbelFit(x, block = 1, type = c("mle", "pwm"), title = NULL, description = NULL, ...)

## S4 method for signature 'fGEVFIT'
show(object)
## S3 method for class 'fGEVFIT'
plot(x, which = "ask", ...)
## S3 method for class 'fGEVFIT'
summary(object, doplot = TRUE, which = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GevModelling_+3A_block">block</code></td>
<td>

<p>block size.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_doplot">doplot</code></td>
<td>

<p>a logical. Should the results be plotted?
<br />
[shaparmPlot] - <br />
a vector of logicals of the same lengths as tails
defining for which tail depths plots should be created,
by default plots will be generated for a tail depth of 5
percent. By default <code>c(FALSE, FALSE, FALSE, FALSE, 
        TRUE, FALSE, FALSE, FALSE, FALSE, FALSE)</code>.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_model">model</code></td>
<td>

<p>[gevSim][gumbelSim] - <br />
a list with components <code>shape</code>, <code>location</code> and 
<code>scale</code> giving the parameters of the GEV distribution.
By default the shape parameter has the value -0.25, the
location is zero and the scale is one.
To fit random deviates from a Gumbel distribution set 
<code>shape=0</code>.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_n">n</code></td>
<td>

<p>[gevSim][gumbelSim] - <br />
number of generated data points, an integer value.
<br />
[rgev] - <br />        
the number of observations.
</p>
</td></tr> 
<tr><td><code id="GevModelling_+3A_object">object</code></td>
<td>

<p>[summary][grlevelPlot] - <br />
a fitted object of class <code>"gevFit"</code>.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_seed">seed</code></td>
<td>

<p>[gevSim] - <br />
an integer value to set the seed for the random number generator.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_title">title</code></td>
<td>

<p>[gevFit] - <br />
a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_type">type</code></td>
<td>

<p>a character string denoting the type of parameter estimation,
either by maximum likelihood estimation <code>"mle"</code>, the
default value, or by the probability weighted moment method
<code>"pwm"</code>.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_which">which</code></td>
<td>

<p>[plot][summary] - <br />
a vector of logicals, one for each plot, denoting which plot 
should be displayed. Alternatively if <code>which="ask"</code> the
user will be interactively asked which of the plots should be
displayed. By default <code>which="all"</code>.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_x">x</code></td>
<td>

<p>[dgev][devd] - <br />
a numeric vector of quantiles.
<br />
[gevFit] - <br />
data vector. In the case of <code>method="mle"</code> the interpretation 
depends on the value of block: if no block size is specified then 
data are interpreted as block maxima; if block size is set, then data
are interpreted as raw data and block maxima are calculated. 
<br />
[hillPlot][shaparmPlot] - <br />
the data from which to calculate the shape parameter, a
numeric vector.
<br />
[print][plot] - <br />
a fitted object of class <code>"gevFit"</code>.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_xi">xi</code>, <code id="GevModelling_+3A_mu">mu</code>, <code id="GevModelling_+3A_beta">beta</code></td>
<td>

<p>[*gev] - <br />
<code>xi</code> is the shape parameter, <code>mu</code> the location parameter,
and <code>beta</code> is the scale parameter. The default values are 
<code>xi=1</code>, <code>mu=0</code>, and <code>beta=1</code>. Note, if <code>xi=0</code> 
the distribution is of type Gumbel.
</p>
</td></tr>
<tr><td><code id="GevModelling_+3A_...">...</code></td>
<td>

<p>[gevFit] - <br />
control parameters optionally passed to the 
optimization function. Parameters for the optimization
function are passed to components of the <code>control</code> argument of
<code>optim</code>. 
<br />
[hillPlot] - <br />
other graphics parameters.
<br />
[plot][summary] - <br />
arguments passed to the plot function.
</p>
</td></tr>    
</table>


<h3>Details</h3>

<p><b>Parameter Estimation:</b>
<br /><br />
<code>gevFit</code> and <code>gumbelFit</code> estimate the parameters either 
by the probability weighted moment method, <code>method="pwm"</code> or 
by maximum log likelihood estimation <code>method="mle"</code>. The 
summary method produces diagnostic plots for fitted GEV or Gumbel 
models.
<br />
</p>
<p><b>Methods:</b>
<br /><br />
<code>print.gev</code>, <code>plot.gev</code> and <code>summary.gev</code> are
print, plot, and summary methods for a fitted object of class 
<code>gev</code>. Concerning the summary method, the data are 
converted to unit exponentially distributed residuals under null 
hypothesis that GEV fits. Two diagnostics for iid exponential data 
are offered. The plot method provides two different residual plots 
for assessing the fitted GEV model. Two diagnostics for 
iid exponential data are offered. 
<br />
</p>
<p><b>Return Level Plot:</b>
<br /><br />
<code>gevrlevelPlot</code> calculates and plots the k-block return level 
and 95% confidence interval based on a GEV model for block maxima, 
where <code>k</code> is specified by the user. The k-block return level 
is that level exceeded once every <code>k</code> blocks, on average. The 
GEV likelihood is reparameterized in terms of the unknown return 
level and profile likelihood arguments are used to construct a 
confidence interval. 
<br />
</p>
<p><b>Hill Plot:</b>
<br /><br />
The function <code>hillPlot</code> investigates the shape parameter and 
plots the Hill estimate of the tail index of heavy-tailed data, or 
of an associated quantile estimate. This plot is usually calculated 
from the alpha perspective. For a generalized Pareto analysis of 
heavy-tailed data using the <code>gpdFit</code> function, it helps to 
plot the Hill estimates for <code>xi</code>. 
<br />
</p>
<p><b>Shape Parameter Plot:</b>
<br /><br />
The function <code>shaparmPlot</code> investigates the shape parameter and 
plots for the upper and lower tails the shape parameter as a function 
of the taildepth. Three approaches are considered, the <em>Pickands</em> 
estimator, the <em>Hill</em> estimator, and the
<em>Decker-Einmal-deHaan</em> estimator.
</p>


<h3>Value</h3>

<p><code>gevSim</code>
<br />
returns a vector of data points from the simulated series.
<br />
</p>
<p><code>gevFit</code>
<br />
returns an object of class <code>gev</code> describing the fit.
<br />
</p>
<p><code>print.summary</code>
<br />
prints a report of the parameter fit.
<br />
</p>
<p><code>summary</code>
<br />
performs diagnostic analysis. The method provides two different 
residual plots for assessing the fitted GEV model.  
<br />
</p>
<p><code>gevrlevelPlot</code>
<br />
returns a vector containing the lower 95% bound of the confidence 
interval, the estimated return level and the upper 95% bound. 
<br />
</p>
<p><code>hillPlot</code>
<br />
displays a plot.
<br />
</p>
<p><code>shaparmPlot</code> 
<br />
returns a list with one or two entries, depending on the
selection of the input variable <code>both.tails</code>. The two 
entries <code>upper</code> and <code>lower</code> determine the position of 
the tail. Each of the two variables is again a list with entries 
<code>pickands</code>, <code>hill</code>, and <code>dehaan</code>. If one of the 
three methods will be discarded the printout will display zeroes.
</p>


<h3>Note</h3>

<p><b>GEV Parameter Estimation:</b>
<br /><br />
If method <code>"mle"</code> is selected the parameter fitting in <code>gevFit</code> 
is passed to the internal function <code>gev.mle</code> or <code>gumbel.mle</code>
depending on the value of <code>gumbel</code>, <code>FALSE</code> or <code>TRUE</code>.
On the other hand, if method <code>"pwm"</code> is selected the parameter 
fitting in <code>gevFit</code> is passed to the internal function 
<code>gev.pwm</code> or <code>gumbel.pwm</code> again depending on the value of 
<code>gumbel</code>, <code>FALSE</code> or <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for R's <code>evd</code> and <code>evir</code> package, and <br />
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Coles S. (2001);
<em>Introduction to Statistical Modelling of Extreme Values</em>,
Springer.
</p>
<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, 
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gevSim -
   # Simulate GEV Data, use default length n=1000
   x = gevSim(model = list(xi = 0.25, mu = 0 , beta = 1), n = 1000)
   head(x)

## gumbelSim -
   # Simulate GEV Data, use default length n=1000
   x = gumbelSim(model = list(xi = 0.25, mu = 0 , beta = 1))
     
## gevFit -
   # Fit GEV Data by Probability Weighted Moments:
   fit = gevFit(x, type = "pwm") 
   print(fit)
   
## summary -
   # Summarize Results:
   par(mfcol = c(2, 2))
   summary(fit)
</code></pre>

<hr>
<h2 id='GevRisk'>Generalized Extreme Value Modelling</h2><span id='topic+GevRisk'></span><span id='topic+gevrlevelPlot'></span>

<h3>Description</h3>

<p>A collection and description functions to estimate 
the parameters of the GEV distribution. To model
the GEV three types of approaches for parameter 
estimation are provided: Maximum likelihood
estimation, probability weighted moment method,
and estimation by the MDA approach. MDA includes
functions for the Pickands, Einmal-Decker-deHaan, 
and Hill estimators together with several plot 
variants.
<br />
</p>
<p>The GEV modelling functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>gevrlevelPlot</code> </td><td style="text-align: left;"> k-block return level with confidence intervals.</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>gevrlevelPlot(object, kBlocks = 20,  ci = c(0.90, 0.95, 0.99), 
    plottype = c("plot", "add"), labels = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GevRisk_+3A_add">add</code></td>
<td>

<p>[gevrlevelPlot] - <br />
whether the return level should be added graphically to a
time series plot; if <code>FALSE</code> a graph of the profile
likelihood curve showing the return level and its confidence
interval is produced.
</p>
</td></tr>
<tr><td><code id="GevRisk_+3A_ci">ci</code></td>
<td>

<p>[hillPlot] - <br />
probability for asymptotic confidence band; for no
confidence band set <code>ci</code> to zero.
</p>
</td></tr>
<tr><td><code id="GevRisk_+3A_kblocks">kBlocks</code></td>
<td>

<p>[gevrlevelPlot] - <br />
specifies the particular return level to be estimated; default 
set arbitrarily to 20.
</p>
</td></tr>
<tr><td><code id="GevRisk_+3A_labels">labels</code></td>
<td>

<p>[hillPlot] - <br />
whether or not axes should be labelled.
</p>
</td></tr> 
<tr><td><code id="GevRisk_+3A_object">object</code></td>
<td>

<p>[summary][grlevelPlot] - <br />
a fitted object of class <code>"gevFit"</code>.
</p>
</td></tr>
<tr><td><code id="GevRisk_+3A_plottype">plottype</code></td>
<td>

<p>[hillPlot] - <br />
whether <code>alpha</code>, <code>xi</code> (1/alpha) or
<code>quantile</code> (a quantile estimate) should be plotted.
</p>
</td></tr>
<tr><td><code id="GevRisk_+3A_...">...</code></td>
<td>

<p>arguments passed to the plot function.
</p>
</td></tr>    
</table>


<h3>Details</h3>

<p><b>Parameter Estimation:</b>
<br /><br />
<code>gevFit</code> and <code>gumbelFit</code> estimate the parameters either 
by the probability weighted moment method, <code>method="pwm"</code> or 
by maximum log likelihood estimation <code>method="mle"</code>. The 
summary method produces diagnostic plots for fitted GEV or Gumbel 
models.
<br />
</p>
<p><b>Methods:</b>
<br /><br />
<code>print.gev</code>, <code>plot.gev</code> and <code>summary.gev</code> are
print, plot, and summary methods for a fitted object of class 
<code>gev</code>. Concerning the summary method, the data are 
converted to unit exponentially distributed residuals under null 
hypothesis that GEV fits. Two diagnostics for iid exponential data 
are offered. The plot method provides two different residual plots 
for assessing the fitted GEV model. Two diagnostics for 
iid exponential data are offered. 
<br />
</p>
<p><b>Return Level Plot:</b>
<br /><br />
<code>gevrlevelPlot</code> calculates and plots the k-block return level 
and 95% confidence interval based on a GEV model for block maxima, 
where <code>k</code> is specified by the user. The k-block return level 
is that level exceeded once every <code>k</code> blocks, on average. The 
GEV likelihood is reparameterized in terms of the unknown return 
level and profile likelihood arguments are used to construct a 
confidence interval. 
<br />
</p>
<p><b>Hill Plot:</b>
<br /><br />
The function <code>hillPlot</code> investigates the shape parameter and 
plots the Hill estimate of the tail index of heavy-tailed data, or 
of an associated quantile estimate. This plot is usually calculated 
from the alpha perspective. For a generalized Pareto analysis of 
heavy-tailed data using the <code>gpdFit</code> function, it helps to 
plot the Hill estimates for <code>xi</code>. 
<br />
</p>
<p><b>Shape Parameter Plot:</b>
<br /><br />
The function <code>shaparmPlot</code> investigates the shape parameter and 
plots for the upper and lower tails the shape parameter as a function 
of the taildepth. Three approaches are considered, the <em>Pickands</em> 
estimator, the <em>Hill</em> estimator, and the
<em>Decker-Einmal-deHaan</em> estimator.
</p>


<h3>Value</h3>

<p><code>gevSim</code>
<br />
returns a vector of data points from the simulated series.
<br />
</p>
<p><code>gevFit</code>
<br />
returns an object of class <code>gev</code> describing the fit.
<br />
</p>
<p><code>print.summary</code>
<br />
prints a report of the parameter fit.
<br />
</p>
<p><code>summary</code>
<br />
performs diagnostic analysis. The method provides two different 
residual plots for assessing the fitted GEV model.  
<br />
</p>
<p><code>gevrlevelPlot</code>
<br />
returns a vector containing the lower 95% bound of the confidence 
interval, the estimated return level and the upper 95% bound. 
<br />
</p>
<p><code>hillPlot</code>
<br />
displays a plot.
<br />
</p>
<p><code>shaparmPlot</code> 
<br />
returns a list with one or two entries, depending on the
selection of the input variable <code>both.tails</code>. The two 
entries <code>upper</code> and <code>lower</code> determine the position of 
the tail. Each of the two variables is again a list with entries 
<code>pickands</code>, <code>hill</code>, and <code>dehaan</code>. If one of the 
three methods will be discarded the printout will display zeroes.
</p>


<h3>Note</h3>

<p><b>GEV Parameter Estimation:</b>
<br /><br />
If method <code>"mle"</code> is selected the parameter fitting in <code>gevFit</code> 
is passed to the internal function <code>gev.mle</code> or <code>gumbel.mle</code>
depending on the value of <code>gumbel</code>, <code>FALSE</code> or <code>TRUE</code>.
On the other hand, if method <code>"pwm"</code> is selected the parameter 
fitting in <code>gevFit</code> is passed to the internal function 
<code>gev.pwm</code> or <code>gumbel.pwm</code> again depending on the value of 
<code>gumbel</code>, <code>FALSE</code> or <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for R's <code>evd</code> and <code>evir</code> package, and <br />
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Coles S. (2001);
<em>Introduction to Statistical Modelling of Extreme Values</em>,
Springer.
</p>
<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, 
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
## Load Data:
   # BMW Stock Data - negative returns
   library(timeSeries)
   x = -as.timeSeries(data(bmwRet))
   colnames(x)&lt;-"BMW"
   head(x)
   
## gevFit -
   # Fit GEV to monthly Block Maxima:
   fit = gevFit(x, block = "month")  
   print(fit)
   
## gevrlevelPlot -
   # Return Level Plot:
   gevrlevelPlot(fit)
</code></pre>

<hr>
<h2 id='GpdDistribution'>Generalized Pareto Distribution</h2><span id='topic+GpdDistribution'></span><span id='topic+dgpd'></span><span id='topic+pgpd'></span><span id='topic+qgpd'></span><span id='topic+rgpd'></span><span id='topic+gpdMoments'></span><span id='topic+gpdSlider'></span>

<h3>Description</h3>

<p>A collection and description of functions to compute
the generalized Pareto distribution. The 
functions compute density, distribution function, 
quantile function and generate random deviates 
for the GPD. In addition functions to 
compute the true moments and to display the distribution
and random variates changing parameters interactively 
are available.
<br />
</p>
<p>The GPD distribution functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>dgpd</code> </td><td style="text-align: left;"> Density of the GPD Distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>pgpd</code> </td><td style="text-align: left;"> Probability function of the GPD Distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>qgpd</code> </td><td style="text-align: left;"> Quantile function of the GPD Distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>rgpd</code> </td><td style="text-align: left;"> random variates from the GPD distribution, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gpdMoments</code> </td><td style="text-align: left;"> computes true mean and variance, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gpdSlider</code> </td><td style="text-align: left;"> displays density or rvs from a GPD.</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>dgpd(x, xi = 1, mu = 0, beta = 1, log = FALSE) 
pgpd(q, xi = 1, mu = 0, beta = 1, lower.tail = TRUE) 
qgpd(p, xi = 1, mu = 0, beta = 1, lower.tail = TRUE) 
rgpd(n, xi = 1, mu = 0, beta = 1)

gpdMoments(xi = 1, mu = 0, beta = 1)
gpdSlider(method = c("dist", "rvs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GpdDistribution_+3A_log">log</code></td>
<td>

<p>a logical, if <code>TRUE</code>, the log density is returned.
</p>
</td></tr>
<tr><td><code id="GpdDistribution_+3A_lower.tail">lower.tail</code></td>
<td>

<p>a logical, if <code>TRUE</code>, the default, then
probabilities are <code>P[X &lt;= x]</code>, otherwise, <code>P[X &gt; x]</code>.
</p>
</td></tr>
<tr><td><code id="GpdDistribution_+3A_method">method</code></td>
<td>

<p>[gpdSlider] - <br />        
a character string denoting what should be displayed. Either
the density and <code>"dist"</code> or random variates <code>"rvs"</code>.
</p>
</td></tr> 
<tr><td><code id="GpdDistribution_+3A_n">n</code></td>
<td>

<p>[rgpd][gpdSim\ - <br />
the number of observations to be generated.
</p>
</td></tr> 
<tr><td><code id="GpdDistribution_+3A_p">p</code></td>
<td>

<p>a vector of probability levels, the desired probability for the 
quantile estimate (e.g. 0.99 for the 99th percentile).
</p>
</td></tr> 
<tr><td><code id="GpdDistribution_+3A_q">q</code></td>
<td>

<p>[pgpd] - <br />
a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="GpdDistribution_+3A_x">x</code></td>
<td>

<p>[dgpd] - <br />
a numeric vector of quantiles.
</p>
</td></tr>
<tr><td><code id="GpdDistribution_+3A_xi">xi</code>, <code id="GpdDistribution_+3A_mu">mu</code>, <code id="GpdDistribution_+3A_beta">beta</code></td>
<td>

<p><code>xi</code> is the shape parameter, 
<code>mu</code> the location parameter,
and <code>beta</code> is the scale parameter.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All values are numeric vectors: <br />
<code>d*</code> returns the density, <br />
<code>p*</code> returns the probability, <br />
<code>q*</code> returns the quantiles, and <br />
<code>r*</code> generates random deviates.  
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for the functions from R's <code>evd</code> package, <br />
Alec Stephenson for the functions from R's <code>evir</code> package, <br />
Alexander McNeil for the EVIS functions underlying the <code>evir</code> package, <br />
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rgpd  -
   par(mfrow = c(2, 2), cex = 0.7)
   r = rgpd(n = 1000, xi = 1/4)
   plot(r, type = "l", col = "steelblue", main = "GPD Series")
   grid()
   
## dgpd -
   # Plot empirical density and compare with true density:
   # Omit values greater than 500 from plot
   hist(r, n = 50, probability = TRUE, xlab = "r", 
     col = "steelblue", border = "white",
     xlim = c(-1, 5), ylim = c(0, 1.1), main = "Density")
   box()
   x = seq(-5, 5, by = 0.01)
   lines(x, dgpd(x, xi = 1/4), col = "orange")
   
## pgpd -
   # Plot df and compare with true df:
   plot(sort(r), (1:length(r)/length(r)), 
     xlim = c(-3, 6), ylim = c(0, 1.1), pch = 19, 
     cex = 0.5, ylab = "p", xlab = "q", main = "Probability")
   grid()
   q = seq(-5, 5, by = 0.1)
   lines(q, pgpd(q, xi = 1/4), col = "steelblue")
   
## qgpd -
   # Compute quantiles, a test:
   qgpd(pgpd(seq(-1, 5, 0.25), xi = 1/4 ), xi = 1/4) 
</code></pre>

<hr>
<h2 id='GpdModelling'>GPD Distributions for Extreme Value Theory</h2><span id='topic+GpdModelling'></span><span id='topic+fGPDFIT'></span><span id='topic+fGPDFIT-class'></span><span id='topic+show+2CfGPDFIT-method'></span><span id='topic+gpdSim'></span><span id='topic+gpdFit'></span><span id='topic+plot.fGPDFIT'></span><span id='topic+summary.fGPDFIT'></span>

<h3>Description</h3>

<p>A collection and description to functions to fit and to simulate 
processes that are generated from the generalized Pareto distribution. 
Two approaches for parameter estimation are provided: Maximum 
likelihood estimation and the probability weighted moment method.
<br />
</p>
<p>The GPD modelling functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>gpdSim</code> </td><td style="text-align: left;"> generates data from the GPD, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gpdFit</code> </td><td style="text-align: left;"> fits empirical or simulated data to the distribution, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>print</code> </td><td style="text-align: left;"> print method for a fitted GPD object of class ..., </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>plot</code> </td><td style="text-align: left;"> plot method for a fitted GPD object, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>summary</code> </td><td style="text-align: left;"> summary method for a fitted GPD object. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>gpdSim(model = list(xi = 0.25, mu = 0, beta = 1), n = 1000,
    seed = NULL)
gpdFit(x, u = quantile(x, 0.95), type = c("mle", "pwm"), information = 
    c("observed", "expected"), title = NULL, description = NULL, ...)

## S4 method for signature 'fGPDFIT'
show(object)
## S3 method for class 'fGPDFIT'
plot(x, which = "ask", ...)
## S3 method for class 'fGPDFIT'
summary(object, doplot = TRUE, which = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GpdModelling_+3A_description">description</code></td>
<td>

<p>a character string which allows for a brief description.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_doplot">doplot</code></td>
<td>

<p>a logical. Should the results be plotted?
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_information">information</code></td>
<td>

<p>whether standard errors should be calculated with
<code>"observed"</code> or <code>"expected"</code> information. This only applies
to the maximum likelihood method; for the probability-weighted moments
method <code>"expected"</code> information is used if possible.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_model">model</code></td>
<td>

<p>[gpdSim] - <br />
a list with components <code>shape</code>, <code>location</code> and 
<code>scale</code> giving the parameters of the GPD distribution.
By default the shape parameter has the value 0.25, the
location is zero and the scale is one.</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_n">n</code></td>
<td>

<p>[rgpd][gpdSim\ - <br />
the number of observations to be generated.
</p>
</td></tr> 
<tr><td><code id="GpdModelling_+3A_object">object</code></td>
<td>

<p>[summary] - <br />
a fitted object of class <code>"gpdFit"</code>.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_seed">seed</code></td>
<td>

<p>[gpdSim] - <br />
an integer value to set the seed for the random number generator.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_title">title</code></td>
<td>

<p>a character string which allows for a project title.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_type">type</code></td>
<td>

<p>a character string selecting the desired estimation method, either
<code>"mle"</code> for the maximum likelihood method or <code>"pwm"</code> for 
the probability weighted moment method. By default, the first will 
be selected. Note, the function <code>gpd</code> uses <code>"ml"</code>.    
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_u">u</code></td>
<td>

<p>the threshold value.    
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_which">which</code></td>
<td>

<p>if <code>which</code> is set to <code>"ask"</code> the function will 
interactively ask which plot should be displayed. By default
this value is set to <code>FALSE</code> and then those plots will
be displayed for which the elements in the logical vector
<code>which</code> ar set to <code>TRUE</code>; by default all four
elements are set to <code>"all"</code>.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_x">x</code></td>
<td>

<p>[dgpd] - <br />
a numeric vector of quantiles.
<br />
[gpdFit] - <br />
the data vector. Note, there are two different names
for the first argument <code>x</code> and <code>data</code> depending 
which function name is used, either <code>gpdFit</code> or the 
EVIS synonym <code>gpd</code>.
<br />
[print][plot] - <br />
a fitted object of class <code>"gpdFit"</code>.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_xi">xi</code>, <code id="GpdModelling_+3A_mu">mu</code>, <code id="GpdModelling_+3A_beta">beta</code></td>
<td>

<p><code>xi</code> is the shape parameter, 
<code>mu</code> the location parameter,
and <code>beta</code> is the scale parameter.
</p>
</td></tr>
<tr><td><code id="GpdModelling_+3A_...">...</code></td>
<td>

<p>control parameters and plot parameters optionally passed to the 
optimization and/or plot function. Parameters for the optimization
function are passed to components of the <code>control</code> argument of
<code>optim</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Generalized Pareto Distribution:</b>
<br /><br />
Compute density, distribution function, quantile function and 
generates random variates for the Generalized Pareto Distribution.
</p>
<p><b>Simulation:</b>
<br /><br />
<code>gpdSim</code> simulates data from a Generalized Pareto 
distribution.
<br />
</p>
<p><b>Parameter Estimation:</b>
<br /><br />
<code>gpdFit</code> fits the model parameters either by the probability 
weighted moment method or the maxim log likelihood method. 
The function returns an object of class <code>"gpd"</code> 
representing the fit of a generalized Pareto model to excesses over 
a high threshold. The fitting functions use the probability weighted 
moment method, if method <code>method="pwm"</code> was selected, and the 
the general purpose optimization function <code>optim</code> when the 
maximum likelihood estimation, <code>method="mle"</code> or <code>method="ml"</code> 
is chosen.
<br />
</p>
<p><b>Methods:</b>
<br /><br />
<code>print.gpd</code>, <code>plot.gpd</code> and <code>summary.gpd</code> are print, 
plot, and summary methods for a fitted object of class <code>gpdFit</code>. 
The plot method provides four different plots for assessing fitted 
GPD model. 
<br />
</p>
<p><b>gpd* Functions:</b>
<br /><br />
<code>gpdqPlot</code> calculates quantile estimates and confidence intervals 
for high quantiles above the threshold in a GPD analysis, and adds a 
graphical representation to an existing plot. The GPD approximation in 
the tail is used to estimate quantile. The <code>"wald"</code> method uses 
the observed Fisher information matrix to calculate confidence interval. 
The <code>"likelihood"</code> method reparametrizes the likelihood in terms 
of the unknown quantile and uses profile likelihood arguments to 
construct a confidence interval. 
<br />
</p>
<p><code>gpdquantPlot</code> creates a plot showing how the estimate of a 
high quantile in the tail of a dataset based on the GPD approximation 
varies with threshold or number of extremes. For every model 
<code>gpdFit</code> is called. Evaluation may be slow. Confidence intervals 
by the Wald method may be fastest.
<br />
</p>
<p><code>gpdriskmeasures</code> makes a rapid calculation of point estimates 
of prescribed quantiles and expected shortfalls using the output of the
function <code>gpdFit</code>. This function simply calculates point estimates 
and (at present) makes no attempt to calculate confidence intervals for 
the risk measures. If confidence levels are required use <code>gpdqPlot</code> 
and <code>gpdsfallPlot</code> which interact with graphs of the tail of a loss
distribution and are much slower.  
<br />
</p>
<p><code>gpdsfallPlot</code> calculates expected shortfall estimates, in other
words tail conditional expectation and confidence intervals for high  
quantiles above the threshold in a GPD analysis. A graphical 
representation to an existing plot is added. Expected shortfall is 
the expected size of the loss, given that a particular quantile of the 
loss distribution is exceeded. The GPD approximation in the tail is used 
to estimate expected shortfall. The likelihood is reparametrized  in 
terms of the unknown expected shortfall and profile likelihood arguments 
are used to construct a confidence interval. 
<br />
</p>
<p><code>gpdshapePlot</code> creates a plot showing how the estimate of shape 
varies with threshold or number of extremes. For every model 
<code>gpdFit</code> is called. Evaluation may be slow.  
<br />
</p>
<p><code>gpdtailPlot</code> produces a plot of the tail of the underlying 
distribution of the data.
</p>


<h3>Value</h3>

<p><code>gpdSim</code>
<br />
returns a vector of datapoints from the simulated 
series.
</p>
<p><code>gpdFit</code> 
<br />
returns an object of class <code>"gpd"</code> describing the 
fit including parameter estimates and standard errors. 
</p>
<p><code>gpdQuantPlot</code>
<br />
returns invisible a table of results.
</p>
<p><code>gpdShapePlot</code>
<br />
returns invisible a table of results.
</p>
<p><code>gpdTailPlot</code>
<br />
returns invisible a list object containing 
details of the plot is returned invisibly. This object should be 
used as the first argument of <code>gpdqPlot</code> or <code>gpdsfallPlot</code> 
to add quantile estimates or expected shortfall estimates to the 
plot. 
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for the functions from R's <code>evd</code> package, <br />
Alec Stephenson for the functions from R's <code>evir</code> package, <br />
Alexander McNeil for the EVIS functions underlying the <code>evir</code> package, <br />
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, Springer. 
</p>
<p>Hosking J.R.M., Wallis J.R., (1987);
<em>Parameter and quantile estimation for the generalized
Pareto distribution</em>,   
Technometrics 29, 339&ndash;349.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## gpdSim  -
   x = gpdSim(model = list(xi = 0.25, mu = 0, beta = 1), n = 1000)
## gpdFit - 
   par(mfrow = c(2, 2), cex = 0.7)  
   fit = gpdFit(x, u = min(x), type = "pwm") 
   print(fit)
   summary(fit)   
</code></pre>

<hr>
<h2 id='gpdRisk'>GPD Distributions for Extreme Value Theory</h2><span id='topic+gpdRisk'></span><span id='topic+gpdQPlot'></span><span id='topic+gpdQuantPlot'></span><span id='topic+gpdSfallPlot'></span><span id='topic+gpdShapePlot'></span><span id='topic+gpdTailPlot'></span><span id='topic+gpdRiskMeasures'></span><span id='topic+tailPlot'></span><span id='topic+tailSlider'></span><span id='topic+tailRisk'></span>

<h3>Description</h3>

<p>A collection and description to functions to compute
tail risk under the GPD approach.
<br />
</p>
<p>The GPD modelling functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>gpdQPlot</code> </td><td style="text-align: left;"> estimation of high quantiles, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>gpdQuantPlot</code> </td><td style="text-align: left;"> variation of high quantiles with threshold, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>gpdRiskMeasures</code> </td><td style="text-align: left;"> prescribed quantiles and expected shortfalls, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>gpdSfallPlot</code> </td><td style="text-align: left;"> expected shortfall with confidence intervals, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>gpdShapePlot</code> </td><td style="text-align: left;"> variation of shape with threshold, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>gpdTailPlot</code> </td><td style="text-align: left;"> plot of the tail, </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>tailPlot</code> </td><td style="text-align: left;"> , </td>
</tr>
<tr>
 <td style="text-align: left;"> 
    <code>tailSlider</code> </td><td style="text-align: left;"> , </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>tailRisk</code> </td><td style="text-align: left;"> . </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>
gpdQPlot(x, p = 0.99, ci = 0.95, type = c("likelihood", "wald"),  
    like.num = 50)
gpdQuantPlot(x, p = 0.99, ci = 0.95, models = 30, start = 15, end = 500,
    doplot = TRUE, plottype = c("normal", "reverse"), labels = TRUE,
    ...) 
gpdSfallPlot(x, p = 0.99, ci = 0.95, like.num = 50)
gpdShapePlot(x, ci = 0.95, models = 30, start = 15, end = 500,
    doplot = TRUE, plottype = c("normal", "reverse"), labels = TRUE,
    ...) 
gpdTailPlot(object, plottype = c("xy", "x", "y", ""), doplot = TRUE, 
    extend = 1.5, labels = TRUE, ...)

gpdRiskMeasures(object, prob = c(0.99, 0.995, 0.999, 0.9995, 0.9999))

tailPlot(object, p = 0.99, ci = 0.95, nLLH = 25, extend = 1.5, grid =
    TRUE, labels = TRUE, ...) 
tailSlider(x)
tailRisk(object, prob = c(0.99, 0.995, 0.999, 0.9995, 0.9999), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpdRisk_+3A_ci">ci</code></td>
<td>

<p>the probability for asymptotic confidence band; for no 
confidence band set to zero.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_doplot">doplot</code></td>
<td>

<p>a logical. Should the results be plotted?
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_extend">extend</code></td>
<td>

<p>optional argument for plots 1 and 2 expressing how far x-axis 
should extend as a multiple of the largest data value. This 
argument must take values greater than 1 and is useful for
showing estimated quantiles beyond data.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_grid">grid</code></td>
<td>

<p>...
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_labels">labels</code></td>
<td>

<p>optional argument for plots 1 and 2  specifying whether or not
axes should be labelled.
</p>
</td></tr> 
<tr><td><code id="gpdRisk_+3A_like.num">like.num</code></td>
<td>

<p>the number of times to evaluate profile likelihood.
</p>
</td></tr> 
<tr><td><code id="gpdRisk_+3A_models">models</code></td>
<td>

<p>the number of consecutive gpd models to be fitted.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_nllh">nLLH</code></td>
<td>

<p>...
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_object">object</code></td>
<td>

<p>[summary] - <br />
a fitted object of class <code>"gpdFit"</code>.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_p">p</code></td>
<td>

<p>a vector of probability levels, the desired probability for the 
quantile estimate (e.g. 0.99 for the 99th percentile).
</p>
</td></tr> 
<tr><td><code id="gpdRisk_+3A_reverse">reverse</code></td>
<td>

<p>should plot be by increasing threshold (<code>TRUE</code>) or number 
of extremes (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_prob">prob</code></td>
<td>

<p>a numeric value.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_plottype">plottype</code></td>
<td>

<p>a character string.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_start">start</code>, <code id="gpdRisk_+3A_end">end</code></td>
<td>

<p>the lowest and maximum number of exceedances to be considered.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_type">type</code></td>
<td>

<p>a character string selecting the desired estimation method, either
<code>"mle"</code> for the maximum likelihood method or <code>"pwm"</code> for 
the probability weighted moment method. By default, the first will 
be selected. Note, the function <code>gpd</code> uses <code>"ml"</code>.    
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_x">x</code></td>
<td>

<p>[dgpd] - <br />
a numeric vector of quantiles.
<br />
[gpdFit] - <br />
the data vector. Note, there are two different names
for the first argument <code>x</code> and <code>data</code> depending 
which function name is used, either <code>gpdFit</code> or the 
EVIS synonym <code>gpd</code>.
<br />
[print][plot] - <br />
a fitted object of class <code>"gpdFit"</code>.
</p>
</td></tr>
<tr><td><code id="gpdRisk_+3A_...">...</code></td>
<td>

<p>control parameters and plot parameters optionally passed to the 
optimization and/or plot function. Parameters for the optimization
function are passed to components of the <code>control</code> argument of
<code>optim</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Generalized Pareto Distribution:</b>
<br /><br />
Compute density, distribution function, quantile function and 
generates random variates for the Generalized Pareto Distribution.
</p>
<p><b>Simulation:</b>
<br /><br />
<code>gpdSim</code> simulates data from a Generalized Pareto 
distribution.
<br />
</p>
<p><b>Parameter Estimation:</b>
<br /><br />
<code>gpdFit</code> fits the model parameters either by the probability 
weighted moment method or the maxim log likelihood method. 
The function returns an object of class <code>"gpd"</code> 
representing the fit of a generalized Pareto model to excesses over 
a high threshold. The fitting functions use the probability weighted 
moment method, if method <code>method="pwm"</code> was selected, and the 
the general purpose optimization function <code>optim</code> when the 
maximum likelihood estimation, <code>method="mle"</code> or <code>method="ml"</code> 
is chosen.
<br />
</p>
<p><b>Methods:</b>
<br /><br />
<code>print.gpd</code>, <code>plot.gpd</code> and <code>summary.gpd</code> are print, 
plot, and summary methods for a fitted object of class <code>gpdFit</code>. 
The plot method provides four different plots for assessing fitted 
GPD model. 
<br />
</p>
<p><b>gpd* Functions:</b>
<br /><br />
<code>gpdqPlot</code> calculates quantile estimates and confidence intervals 
for high quantiles above the threshold in a GPD analysis, and adds a 
graphical representation to an existing plot. The GPD approximation in 
the tail is used to estimate quantile. The <code>"wald"</code> method uses 
the observed Fisher information matrix to calculate confidence interval. 
The <code>"likelihood"</code> method reparametrizes the likelihood in terms 
of the unknown quantile and uses profile likelihood arguments to 
construct a confidence interval. 
<br />
</p>
<p><code>gpdquantPlot</code> creates a plot showing how the estimate of a 
high quantile in the tail of a dataset based on the GPD approximation 
varies with threshold or number of extremes. For every model 
<code>gpdFit</code> is called. Evaluation may be slow. Confidence intervals 
by the Wald method may be fastest.
<br />
</p>
<p><code>gpdriskmeasures</code> makes a rapid calculation of point estimates 
of prescribed quantiles and expected shortfalls using the output of the
function <code>gpdFit</code>. This function simply calculates point estimates 
and (at present) makes no attempt to calculate confidence intervals for 
the risk measures. If confidence levels are required use <code>gpdqPlot</code> 
and <code>gpdsfallPlot</code> which interact with graphs of the tail of a loss
distribution and are much slower.  
<br />
</p>
<p><code>gpdsfallPlot</code> calculates expected shortfall estimates, in other
words tail conditional expectation and confidence intervals for high  
quantiles above the threshold in a GPD analysis. A graphicalx
representation to an existing plot is added. Expected shortfall is 
the expected size of the loss, given that a particular quantile of the 
loss distribution is exceeded. The GPD approximation in the tail is used 
to estimate expected shortfall. The likelihood is reparametrized  in 
terms of the unknown expected shortfall and profile likelihood arguments 
are used to construct a confidence interval. 
<br />
</p>
<p><code>gpdshapePlot</code> creates a plot showing how the estimate of shape 
varies with threshold or number of extremes. For every model 
<code>gpdFit</code> is called. Evaluation may be slow.  
<br />
</p>
<p><code>gpdtailPlot</code> produces a plot of the tail of the underlying 
distribution of the data.
</p>


<h3>Value</h3>

<p><code>gpdSim</code>
<br />
returns a vector of datapoints from the simulated 
series.
</p>
<p><code>gpdFit</code> 
<br />
returns an object of class <code>"gpd"</code> describing the 
fit including parameter estimates and standard errors. 
</p>
<p><code>gpdQuantPlot</code>
<br />
returns invisible a table of results.
</p>
<p><code>gpdShapePlot</code>
<br />
returns invisible a table of results.
</p>
<p><code>gpdTailPlot</code>
<br />
returns invisible a list object containing 
details of the plot is returned invisibly. This object should be 
used as the first argument of <code>gpdqPlot</code> or <code>gpdsfallPlot</code> 
to add quantile estimates or expected shortfall estimates to the 
plot. 
</p>


<h3>Author(s)</h3>

<p>Alec Stephenson for the functions from R's <code>evd</code> package, <br /> 
Alec Stephenson for the functions from R's <code>evir</code> package, <br /> 
Alexander McNeil for the EVIS functions underlying the <code>evir</code>
package, <br /> 
Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>References</h3>

<p>Embrechts, P., Klueppelberg, C., Mikosch, T. (1997);
<em>Modelling Extremal Events</em>, Springer. 
</p>
<p>Hosking J.R.M., Wallis J.R., (1987);
<em>Parameter and quantile estimation for the generalized
Pareto distribution</em>,   
Technometrics 29, 339&ndash;349.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load Data:
   library(timeSeries)
   danish = as.timeSeries(data(danishClaims))

## Tail Plot:
   x = as.timeSeries(data(danishClaims))
   fit = gpdFit(x, u = 10)
   tailPlot(fit)

## Try Tail Slider:
   # tailSlider(x)   

## Tail Risk:
   tailRisk(fit)
</code></pre>

<hr>
<h2 id='TimeSeriesData'>Time Series Data Sets</h2><span id='topic+TimeSeriesData'></span><span id='topic+bmwRet'></span><span id='topic+danishClaims'></span>

<h3>Description</h3>

<p>Data sets used in the examples of the fExtremes packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmwRet
danishClaims
</code></pre>


<h3>Format</h3>

<p><code>bmwRet</code>. A data frame with 6146 observations on 2 variables. The first column contains dates (Tuesday 2nd January 1973 until Tuesday 23rd July 1996) and the second column contains the respective value of daily log returns on the BMW share price made on each of those dates.  These data are an irregular time series because there is no trading at weekends.
</p>
<p><code>danishClaims</code>. A data frame with 2167 observations on 2 variables.  The first column contains dates and the second column contains the respective value of a fire insurance claim in Denmark made on each of those dates. These data are an irregular time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(bmwRet)
head(danishClaims)
</code></pre>

<hr>
<h2 id='ValueAtRisk'>Value-at-Risk</h2><span id='topic+ValueAtRisk'></span><span id='topic+VaR'></span><span id='topic+CVaR'></span>

<h3>Description</h3>

<p>A collection and description of functions to compute
Value-at-Risk and conditional Value-at-Risk
<br />
</p>
<p>The functions are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>VaR</code> </td><td style="text-align: left;"> Computes Value-at-Risk, </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>CVaR</code> </td><td style="text-align: left;"> Computes conditional Value-at-Risk. </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>VaR(x, alpha = 0.05, type = "sample", tail = c("lower", "upper"))
CVaR(x, alpha = 0.05, type = "sample", tail = c("lower", "upper"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ValueAtRisk_+3A_x">x</code></td>
<td>

<p>an uni- or multivariate timeSeries object
</p>
</td></tr>
<tr><td><code id="ValueAtRisk_+3A_alpha">alpha</code></td>
<td>

<p>a numeric value, the confidence interval.
</p>
</td></tr>
<tr><td><code id="ValueAtRisk_+3A_type">type</code></td>
<td>

<p>a character string, the type to calculate the value-at-risk.
</p>
</td></tr>
<tr><td><code id="ValueAtRisk_+3A_tail">tail</code></td>
<td>

<p>a character string denoting which tail will be
considered, either <code>"lower"</code> or <code>"upper"</code>.
If <code>tail="lower"</code>, then alpha will be converted to
<code>alpha=1-alpha</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>VaR</code><br />
<code>CVaR</code><br />
<br />
returns a numeric vector or value with the (conditional) value-at-risk
for each time series column.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for this <span class="rlang"><b>R</b></span>-port.
</p>


<h3>See Also</h3>

<p><code>hillPlot</code>,
<code>gevFit</code>. 
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
