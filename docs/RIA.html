<!DOCTYPE html><html><head><title>Help for package RIA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RIA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DICOM_codes'><p>rda containing DICOM header codes to include in <em>RIA_image</em> object</p></a></li>
<li><a href='#load_dicom'><p>Loads DICOM images to RIA image format</p></a></li>
<li><a href='#load_nifti'><p>Loads NIfTI images to RIA image format</p></a></li>
<li><a href='#load_npy'><p>Loads npy files to RIA image format</p></a></li>
<li><a href='#load_nrrd'><p>Loads nrrd images to RIA image format</p></a></li>
<li><a href='#merge_RIA_images'><p>Merges multiple loaded images into one volume</p></a></li>
<li><a href='#Non_NRS'><p><em>RIA_image</em> object of a plaque without the napkin-ring sign</p></a></li>
<li><a href='#NRS'><p><em>RIA_image</em> object of a plaque with the napkin-ring sign</p></a></li>
<li><a href='#radiomics_all'><p>Calculates all radiomic statistics on supplied RIA_image</p></a></li>
<li><a href='#save_RIA'><p>Export radiomics calculations of RIA image to csv</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Radiomics Image Analysis Toolbox for Medial Images</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marton Kolossvary &lt;marton.kolossvary@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Radiomics image analysis toolbox for 2D and 3D radiological images. RIA supports DICOM, NIfTI,
             nrrd and npy (numpy array) file formats.
             RIA calculates first-order, gray level co-occurrence matrix, gray level run length matrix and
             geometry-based statistics. Almost all calculations are done using vectorized formulas to
             optimize run speeds. Calculation of several thousands of parameters only takes minutes
             on a single core of a conventional PC. Detailed methodology has been published: Kolossvary
             et al. Circ: Cardiovascular Imaging. 2017;10(12):e006843 &lt;<a href="https://doi.org/10.1161%2FCIRCIMAGING.117.006843">doi:10.1161/CIRCIMAGING.117.006843</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>oro.dicom (&ge; 0.5.0), oro.nifti (&ge; 0.9.1)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, nat (&ge; 1.8.11), reticulate(&ge; 1.20)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-03 18:10:57 UTC; mjk2</td>
</tr>
<tr>
<td>Author:</td>
<td>Marton Kolossvary [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 11:50:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='DICOM_codes'>rda containing DICOM header codes to include in <em>RIA_image</em> object</h2><span id='topic+DICOM_codes'></span>

<h3>Description</h3>

<p>rda data file containing Name, Group and Element codes of DICOM header info
to be included into <em>RIA_image</em> object by default when using <code><a href="#topic+load_dicom">load_dicom</a></code> function.
Can be edited to change defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DICOM_codes
</code></pre>


<h3>Format</h3>

<p>Each row is a DICOM header input
</p>


<h3>Value</h3>

<p>3 column data.frame
</p>


<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>

<hr>
<h2 id='load_dicom'>Loads DICOM images to RIA image format</h2><span id='topic+load_dicom'></span>

<h3>Description</h3>

<p>Loads DICOM images to a <em>RIA_image</em> object.
<em>RIA_image</em> is a  list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object, which has two potential slots.
<em>$orig</em> contains the original image after loading and is a 3D array of integers
created with <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.
<em>$modif</em> contains the image that has been modified using functions.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is list of DICOM header information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>

<p>Further attributes may also be added by RIA functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_dicom(
  filename,
  mask_filename = NULL,
  keep_mask_values = 1,
  switch_z = FALSE,
  crop_in = TRUE,
  replace_in = TRUE,
  center_in = TRUE,
  zero_value = NULL,
  min_to = -1024,
  header_add = NULL,
  header_exclude = NULL,
  verbose_in = TRUE,
  recursive_in = TRUE,
  exclude_in = "sql",
  mode_in = "integer",
  transpose_in = TRUE,
  pixelData_in = TRUE,
  mosaic_in = FALSE,
  mosaicXY_in = NULL,
  sequence_in = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_dicom_+3A_filename">filename</code></td>
<td>
<p>string, file path to directory containing <em>dcm</em> files.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_mask_filename">mask_filename</code></td>
<td>
<p>string vector, file path to optional directory containing <em>dcm</em> files
of mask image. If multiple are supplied, then those voxels are kept which have one of the values of <em>keep_mask_values</em>
in any of the supplied masks.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_keep_mask_values">keep_mask_values</code></td>
<td>
<p>integer vector or string, indicates which value or values of the mask image
to use as indicator to identify voxels wished to be processed. Usually 1-s indicate voxels
wished to be processed. However, one mask image might contain several segmentations, in which
case supplying several integers is allowed. Furthermore, if the same string is supplied to
<em>filename</em> and <em>mask_filename</em>, then the integers in <em>keep_mask_values</em> are used
to specify which voxel values to analyze. This way the provided image can be segmented to specific
components. For example, if you wish to analyze only the low-density non-calcified component
of coronary plaques, then <em>keep_mask_values</em> can specify this by setting it to: -100:30.
If  a single string is provided, then each element of the mask will be examined against the statement in the string.
For example, if <em>'&gt;0.5'</em> is provided i.e. the mask is probabilities after a DL algorithm, then all
voxels with values &gt;0.5 in the mask image will be kept. This can be a complex logical expression.
The data on which the expression is executed is called <em>data</em> or <em>data_mask</em>, depending on whether
you wish to filter the original image, that is the original image is supplied as a mask, or if you have
unique mask files respectively. Therefore for complex logical expressions you can define for example:
<em>'&gt;-100 &amp; data&lt;30'</em> to consider data values between -100 and 30, or <em>'&gt;0.5 &amp; data_mask&lt;0.75'</em>
to select voxels based-on mask values between 0.5 and 0.75 for example if they represent a probability mask.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_switch_z">switch_z</code></td>
<td>
<p>logical, indicating whether to change the orientation of the images in the Z axis. Some
software reverse the order of the manipulated image in the Z axis, and therefore the images of the mask
image need to be reversed.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_crop_in">crop_in</code></td>
<td>
<p>logical, indicating whether to crop <em>RIA_image</em> to smallest bounding box.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_replace_in">replace_in</code></td>
<td>
<p>logical, whether to replace smallest values indicated by <em>zero_value</em>,
which are considered to indicate no signal, to NA.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_center_in">center_in</code></td>
<td>
<p>logical, whether to shift data so smallest value
is equal to <em>min_to</em> input parameter.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_zero_value">zero_value</code></td>
<td>
<p>integer, indicating voxels values which are considered
not to have any information. If left empty,
then the smallest HU value in the image will be used, if <em>replace_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_min_to">min_to</code></td>
<td>
<p>integer, value to which data is shifted to if <em>center_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_header_add">header_add</code></td>
<td>
<p>dataframe, with three columns: Name, Group and Element containing the name,
the group and the element code of the DICOM fields wished to be added to the<em>RIA_header</em>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_header_exclude">header_exclude</code></td>
<td>
<p>dataframe, with three columns: Name, Group and Element containing the name,
the group and the element code of the DICOM fields wished to be excluded
from the default header elements present in <em>DICOM_codes</em> rda file.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_verbose_in">verbose_in</code></td>
<td>
<p>logical, indicating whether to print detailed information.
Most prints can also be suppresed using the <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> function.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_recursive_in">recursive_in</code></td>
<td>
<p><em>recursive</em> parameter input of <code><a href="oro.dicom.html#topic+readDICOM">readDICOM</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_exclude_in">exclude_in</code></td>
<td>
<p><em>exclude</em> parameter input of <code><a href="oro.dicom.html#topic+readDICOM">readDICOM</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_mode_in">mode_in</code></td>
<td>
<p><em>mode</em> parameter input of <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_transpose_in">transpose_in</code></td>
<td>
<p><em>transpose</em> parameter input of <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_pixeldata_in">pixelData_in</code></td>
<td>
<p><em>pixelData</em> parameter input of <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_mosaic_in">mosaic_in</code></td>
<td>
<p><em>mosaic</em> parameter input of <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_mosaicxy_in">mosaicXY_in</code></td>
<td>
<p><em>mosaicXY</em> parameter input of <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_sequence_in">sequence_in</code></td>
<td>
<p><em>sequence</em> parameter input of <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
<tr><td><code id="load_dicom_+3A_...">...</code></td>
<td>
<p>additional arguments to  <code><a href="oro.dicom.html#topic+readDICOM">readDICOM</a></code>,
<code><a href="oro.dicom.html#topic+readDICOMFile">readDICOMFile</a></code> and <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>load_dicom</em> is used to transform DICOM datasets into the RIA environment.
<em>RIA_image</em> object was developed to facilitate and simplify radiomics calculations by keeping
all necessary information in one place.
<br />
<br />
<em>RIA_data</em> stores the DICOM image that is converted to numerical 3D arrays using
<code><a href="oro.dicom.html#topic+readDICOM">readDICOM</a></code> and <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>.
The function stores the original loaded image in  <em>RIA_data$orig</em>,
while all modified images are stored in <em>RIA_data$modif</em>.
By default, the original image <em>RIA_data$orig</em> is untouched by functions
other than those operating in <em>load_dicom</em>. While other functions
operate on the <em>RIA_data$modif</em> image by default.
<br />
Due to memory concerns, there can only be one <em>RIA_data$orig</em> and <em>RIA_data$modif</em>
image present at one time in a <em>RIA_image</em>. Therefore, if image manipulations are performed,
then the <em>RIA_data$modif</em> will be overwritten. However, functions can save images
into new slots of <em>RIA_image</em>, for example discretized images can be saved to the <em>discretized</em> slot of <em>RIA_image</em>.
<br />
<em>load_dicom</em> not only loads the DICOM image based on parameters that can be set for
<code><a href="oro.dicom.html#topic+readDICOM">readDICOM</a></code> and <code><a href="oro.dicom.html#topic+create3D">create3D</a></code>, but also can perform
minimal manipulations on the image itself.
<br />
<em>crop_in</em> logical variable is used to indicate, whether to crop the image to the
smallest bounding box still containing all the information. If TRUE, then all X, Y and potentially
Z slices containing no information will be removed. This allows significant reduction of necessary
memory to store image data.
<br />
<em>zero_value</em> parameter is used to indicate HU values which contain no information. If left empty,
then the smallest value will be considered as indicating voxels without a signal.
<br />
<em>replace_in</em> logical can be used to change values that are considered to have no signal to NA.
This is necessary to receive proper statistical values later on.
<br />
<em>center_in</em> logical is used to indicate whether the values should be shifted.
Some vendors save HU values as positive integers to spare memory and minimalize file sizes.
Therefore, in some instances shift of the scale is needed. By default,
the values are shifted by -1024, but in other cases a different constant might be required,
which can be set using the <em>min_to</em> input.
<br />
<br />
<em>RIA_header</em> is a list containing the most basic patient and examination information
needed for further analysis. The default DICOM set is present in <em>DICOM_codes</em>,
which can be edited to anyones needs. But if we wish only to add of remove specific
DICOM header rows, then the <em>header_add</em> and <em>header_exclude</em> can be used.
<br />
<br />
<em>RIA_log</em> is a list of variables, which give an overview of what has been done with the image.
If the whole <em>RIA_image</em> is supplied to a function, the information regarding the manipulations
are written into the <em>$events</em> array in chronological order. Furthermore, some additional
information is also saved in the log, which might be needed for further analysis.
</p>


<h3>Value</h3>

<p>Returns a <em>RIA_image</em> object. <em>RIA_image</em> is a list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object containing the image in <em>$orig</em> slot.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is s list of DICOM information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>



<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 #Image will be croped to smallest bounding box, and smallest values will be changed to NA,
 while 1024 will be substracted from all other data points.
 RIA_image &lt;- load_dicom("/Users/Test/Documents/Radiomics/John_Smith/DICOM_folder/")
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='load_nifti'>Loads NIfTI images to RIA image format</h2><span id='topic+load_nifti'></span>

<h3>Description</h3>

<p>Loads NIfTI images to a <em>RIA_image</em> object.
<em>RIA_image</em> is a  list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object, which has two potential slots.
<em>$orig</em> contains the original image after loading
<em>$modif</em> contains the image that has been modified using functions.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is list of header information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>

<p>Further attributes may also be added by RIA functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_nifti(
  filename,
  image_dim = 3,
  mask_filename = NULL,
  keep_mask_values = 1,
  switch_z = FALSE,
  crop_in = TRUE,
  replace_in = TRUE,
  center_in = FALSE,
  zero_value = NULL,
  min_to = -1024,
  verbose_in = TRUE,
  reorient_in = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_nifti_+3A_filename">filename</code></td>
<td>
<p>string, file path to directory containing <em>NIfTI</em> file.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_image_dim">image_dim</code></td>
<td>
<p>integer, dimensions of the image.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_mask_filename">mask_filename</code></td>
<td>
<p>string vector, file path to optional directory containing <em>NIfTI</em> file
of mask image. If multiple are supplied, then those voxels are kept which have one of the values of <em>keep_mask_values</em>
in any of the supplied masks.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_keep_mask_values">keep_mask_values</code></td>
<td>
<p>integer vector or string, indicates which value or values of the mask image
to use as indicator to identify voxels wished to be processed. Usually 1-s indicate voxels
wished to be processed. However, one mask image might contain several segmentations, in which
case supplying several integers is allowed. Furthermore, if the same string is supplied to
<em>filename</em> and <em>mask_filename</em>, then the integers in <em>keep_mask_values</em> are used
to specify which voxel values to analyze. This way the provided image can be segmented to specific
components. For example, if you wish to analyze only the low-density non-calcified component
of coronary plaques, then <em>keep_mask_values</em> can specify this by setting it to: -100:30.
If  a single string is provided, then each element of the mask will be examined against the statement in the string.
For example, if <em>'&gt;0.5'</em> is provided i.e. the mask is probabilities after a DL algorithm, then all
voxels with values &gt;0.5 in the mask image will be kept. This can be a complex logical expression.
The data on which the expression is executed is called <em>data</em> or <em>data_mask</em>, depending on whether
you wish to filter the original image, that is the original image is supplied as a mask, or if you have
unique mask files respectively. Therefore for complex logical expressions you can define for example:
<em>'&gt;-100 &amp; data&lt;30'</em> to consider data values between -100 and 30, or <em>'&gt;0.5 &amp; data_mask&lt;0.75'</em>
to select voxels based-on mask values between 0.5 and 0.75 for example if they represent a probability mask.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_switch_z">switch_z</code></td>
<td>
<p>logical, indicating whether to change the orientation of the images in the Z axis. Some
software reverse the order of the manipulated image in the Z axis, and therefore the images of the mask
image need to be reversed.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_crop_in">crop_in</code></td>
<td>
<p>logical, indicating whether to crop <em>RIA_image</em> to smallest bounding box.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_replace_in">replace_in</code></td>
<td>
<p>logical, whether to replace smallest values indicated by <em>zero_value</em>,
which are considered to indicate no signal, to NA.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_center_in">center_in</code></td>
<td>
<p>logical, whether to shift data so smallest value
is equal to <em>min_to</em> input parameter.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_zero_value">zero_value</code></td>
<td>
<p>integer, indicating voxels values which are considered
not to have any information. If left empty,
then the smallest HU value in the image will be used, if <em>replace_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_min_to">min_to</code></td>
<td>
<p>integer, value to which data is shifted to if <em>center_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_verbose_in">verbose_in</code></td>
<td>
<p>logical, indicating whether to print detailed information.
Most prints can also be suppresed using the <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> function.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_reorient_in">reorient_in</code></td>
<td>
<p><em>reorient</em> parameter input of <code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>.</p>
</td></tr>
<tr><td><code id="load_nifti_+3A_...">...</code></td>
<td>
<p>additional arguments to  <code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>,
<code><a href="oro.nifti.html#topic+nifti_header">nifti_header</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>load_nifti</em> is used to transform NIfTI datasets into the RIA environment.
<em>RIA_image</em> object was developed to facilitate and simplify radiomics calculations by keeping
all necessary information in one place.
<br />
<br />
<em>RIA_data</em> stores the image that is converted to numerical 3D arrays using
<code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>.
The function stores the original loaded image in  <em>RIA_data$orig</em>,
while all modified images are stored in <em>RIA_data$modif</em>.
By default, the original image <em>RIA_data$orig</em> is untouched by functions
other than those operating in <em>load_nifti</em>. While other functions
operate on the <em>RIA_data$modif</em> image by default.
<br />
Due to memory concerns, there can only be one <em>RIA_data$orig</em> and <em>RIA_data$modif</em>
image present at one time in a <em>RIA_image</em>. Therefore, if image manipulations are performed,
then the <em>RIA_data$modif</em> will be overwritten. However, functions can save images
into new slots of <em>RIA_image</em>, for example discretized images can be saved to the <em>discretized</em> slot of <em>RIA_image</em>.
<br />
<em>load_nifti</em> not only loads the image based on parameters that can be set for
<code><a href="oro.nifti.html#topic+readNIfTI">readNIfTI</a></code>, but also can perform
minimal manipulations on the image itself.
<br />
<em>crop_in</em> logical variable is used to indicate, whether to crop the image to the
smallest bounding box still containing all the information. If TRUE, then all X, Y and potentially
Z slices containing no information will be removed. This allows significant reduction of necessary
memory to store image data.
<br />
<em>zero_value</em> parameter is used to indicate HU values which contain no information. If left empty,
then the smallest value will be considered as indicating voxels without a signal.
<br />
<em>replace_in</em> logical can be used to change values that are considered to have no signal to NA.
This is necessary to receive proper statistical values later on.
<br />
<em>center_in</em> logical is used to indicate whether the values should be shifted.
Some vendors save HU values as positive integers to spare memory and minimalize file sizes.
Therefore, in some instances shift of the scale is needed. By default,
the values are shifted by -1024, but in other cases a different constant might be required,
which can be set using the <em>min_to</em> input.
<br />
<br />
<em>RIA_header</em> is a list containing the most basic patient and examination information
present in the NIfTI file.
<br />
<br />
<em>RIA_log</em> is a list of variables, which give an overview of what has been done with the image.
If the whole <em>RIA_image</em> is supplied to a function, the information regarding the manipulations
are written into the <em>$events</em> array in chronological order. Furthermore, some additional
information is also saved in the log, which might be needed for further analysis.
</p>


<h3>Value</h3>

<p>Returns a <em>RIA_image</em> object. <em>RIA_image</em> is a list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object containing the image in <em>$orig</em> slot.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is s list of meta information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>



<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 #Image will be croped to smallest bounding box, and smallest values will be changed to NA,
 while 1024 will be substracted from all other data points.
 RIA_image &lt;- load_nifti("/Users/Test/Documents/Radiomics/John_Smith/NIfTI_folder/sample.nii")
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='load_npy'>Loads npy files to RIA image format</h2><span id='topic+load_npy'></span>

<h3>Description</h3>

<p>Loads numpy arrays from python to a <em>RIA_image</em> object using the <em>reticulate</em> package.
Requires <a href="https://www.python.org">python</a> and <a href="https://numpy.org">numpy</a> to be installed!
<em>RIA_image</em> is a list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object, which has two potential slots.
<em>$orig</em> contains the original image after loading
<em>$modif</em> contains the image that has been modified using functions.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is list of header information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>

<p>Further attributes may also be added by RIA functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_npy(
  filename,
  mask_filename = NULL,
  keep_mask_values = 1,
  switch_z = FALSE,
  crop_in = TRUE,
  replace_in = TRUE,
  center_in = FALSE,
  zero_value = NULL,
  min_to = -1024,
  PixelSpacing = 1,
  SpacingBetweenSlices = 1,
  verbose_in = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_npy_+3A_filename">filename</code></td>
<td>
<p>string, file path to <em>npy</em> file.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_mask_filename">mask_filename</code></td>
<td>
<p>string vector, file path to <em>npy</em> file
of mask image. If multiple are supplied, then those voxels are kept which have one of the values of <em>keep_mask_values</em>
in any of the supplied masks.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_keep_mask_values">keep_mask_values</code></td>
<td>
<p>integer vector or string, indicates which value or values of the mask image
to use as indicator to identify voxels wished to be processed. Usually 1-s indicate voxels
wished to be processed. However, one mask image might contain several segmentations, in which
case supplying several integers is allowed. Furthermore, if the same string is supplied to
<em>filename</em> and <em>mask_filename</em>, then the integers in <em>keep_mask_values</em> are used
to specify which voxel values to analyze. This way the provided image can be segmented to specific
components. For example, if you wish to analyze only the low-density non-calcified component
of coronary plaques, then <em>keep_mask_values</em> can specify this by setting it to: -100:30.
If a single string is provided, then each element of the mask will be examined against the statement in the string.
For example, if <em>'&gt;0.5'</em> is provided i.e. the mask is probabilities after a DL algorithm, then all
voxels with values &gt;0.5 in the mask image will be kept. This can be a complex logical expression.
The data on which the expression is executed is called <em>data</em> or <em>data_mask</em>, depending on whether
you wish to filter the original image, that is the original image is supplied as a mask, or if you have
unique mask files respectively. Therefore for complex logical expressions you can define for example:
<em>'&gt;-100 &amp; data&lt;30'</em> to consider data values between -100 and 30, or <em>'&gt;0.5 &amp; data_mask&lt;0.75'</em>
to select voxels based-on mask values between 0.5 and 0.75 for example if they represent a probability mask.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_switch_z">switch_z</code></td>
<td>
<p>logical, indicating whether to change the orientation of the images in the Z axis. Some
software reverse the order of the manipulated image in the Z axis, and therefore the images of the mask
image need to be reversed.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_crop_in">crop_in</code></td>
<td>
<p>logical, indicating whether to crop <em>RIA_image</em> to smallest bounding box.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_replace_in">replace_in</code></td>
<td>
<p>logical, whether to replace smallest values indicated by <em>zero_value</em>,
which are considered to indicate no signal, to NA.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_center_in">center_in</code></td>
<td>
<p>logical, whether to shift data so smallest value
is equal to <em>min_to</em> input parameter.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_zero_value">zero_value</code></td>
<td>
<p>integer, indicating voxels values which are considered
not to have any information. If left empty,
then the smallest HU value in the image will be used, if <em>replace_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_min_to">min_to</code></td>
<td>
<p>integer, value to which data is shifted to if <em>center_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_pixelspacing">PixelSpacing</code></td>
<td>
<p>numerical, Pixel spacing value of image.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_spacingbetweenslices">SpacingBetweenSlices</code></td>
<td>
<p>numerical, Spacing between the slices value of the image.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_verbose_in">verbose_in</code></td>
<td>
<p>logical, indicating whether to print detailed information.
Most prints can also be suppressed using the <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> function.</p>
</td></tr>
<tr><td><code id="load_npy_+3A_...">...</code></td>
<td>
<p>additional arguments to <em>numpy.load</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>load_npy</em> is used to transform numpy array datasets into the RIA environment.
<em>RIA_image</em> object was developed to facilitate and simplify radiomics calculations by keeping
all necessary information in one place.
<br />
<br />
<em>RIA_data</em> stores the numpy image that is converted to numerical 3D arrays using the reticulate package.
The function stores the original loaded image in  <em>RIA_data$orig</em>,
while all modified images are stored in <em>RIA_data$modif</em>.
By default, the original image <em>RIA_data$orig</em> is untouched by functions
other than those operating in <em>load_npy</em>. While other functions
operate on the <em>RIA_data$modif</em> image by default.
<br />
Due to memory concerns, there can only be one <em>RIA_data$orig</em> and <em>RIA_data$modif</em>
image present at one time in a <em>RIA_image</em>. Therefore, if image manipulations are performed,
then the <em>RIA_data$modif</em> will be overwritten. However, functions can save images
into new slots of <em>RIA_image</em>, for example discretized images can be saved to the <em>discretized</em> slot of <em>RIA_image</em>.
<br />
<em>load_npy</em> not only loads the image, but also can perform
minimal manipulations on the image itself.
<br />
<em>crop_in</em> logical variable is used to indicate, whether to crop the image to the
smallest bounding box still containing all the information. If TRUE, then all X, Y and potentially
Z slices containing no information will be removed. This allows significant reduction of necessary
memory to store image data.
<br />
<em>zero_value</em> parameter is used to indicate HU values which contain no information. If left empty,
then the smallest value will be considered as indicating voxels without a signal.
<br />
<em>replace_in</em> logical can be used to change values that are considered to have no signal to NA.
This is necessary to receive proper statistical values later on.
<br />
<em>center_in</em> logical is used to indicate whether the values should be shifted.
Some vendors save HU values as positive integers to spare memory and minimalize file sizes.
Therefore, in some instances shift of the scale is needed. By default,
the values are shifted by -1024, but in other cases a different constant might be required,
which can be set using the <em>min_to</em> input.
<br />
<br />
<em>RIA_header</em> is a list containing the most basic patient and examination information
present in the npy file. Data is limited to the pixel spacing and spacing between the slices information.
<br />
<br />
<em>RIA_log</em> is a list of variables, which give an overview of what has been done with the image.
If the whole <em>RIA_image</em> is supplied to a function, the information regarding the manipulations
are written into the <em>$events</em> array in chronological order. Furthermore, some additional
information is also saved in the log, which might be needed for further analysis.
</p>


<h3>Value</h3>

<p>Returns a <em>RIA_image</em> object. <em>RIA_image</em> is a list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object containing the image in <em>$orig</em> slot.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is s list of header information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>



<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 #Image will be croped to smallest bounding box, and smallest values will be changed to NA
 RIA_image &lt;- load_npy("/Users/Test/Documents/Radiomics/John_Smith/npy_folder/sample.npy")
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='load_nrrd'>Loads nrrd images to RIA image format</h2><span id='topic+load_nrrd'></span>

<h3>Description</h3>

<p>Loads nrrd images to a <em>RIA_image</em> object.
<em>RIA_image</em> is a  list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object, which has two potential slots.
<em>$orig</em> contains the original image after loading
<em>$modif</em> contains the image that has been modified using functions.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is list of header information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>

<p>Further attributes may also be added by RIA functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_nrrd(
  filename,
  mask_filename = NULL,
  keep_mask_values = 1,
  switch_z = FALSE,
  crop_in = TRUE,
  replace_in = TRUE,
  center_in = FALSE,
  zero_value = NULL,
  min_to = -1024,
  verbose_in = TRUE,
  origin_in = NULL,
  ReadByteAsRaw_in = "unsigned",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_nrrd_+3A_filename">filename</code></td>
<td>
<p>string, file path to directory containing <em>nrrd</em> file.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_mask_filename">mask_filename</code></td>
<td>
<p>string vector, file path to optional directory containing <em>nrrd</em> file
of mask image. If multiple are supplied, then those voxels are kept which have one of the values of <em>keep_mask_values</em>
in any of the supplied masks.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_keep_mask_values">keep_mask_values</code></td>
<td>
<p>integer vector or string, indicates which value or values of the mask image
to use as indicator to identify voxels wished to be processed. Usually 1-s indicate voxels
wished to be processed. However, one mask image might contain several segmentations, in which
case supplying several integers is allowed. Furthermore, if the same string is supplied to
<em>filename</em> and <em>mask_filename</em>, then the integers in <em>keep_mask_values</em> are used
to specify which voxel values to analyze. This way the provided image can be segmented to specific
components. For example, if you wish to analyze only the low-density non-calcified component
of coronary plaques, then <em>keep_mask_values</em> can specify this by setting it to: -100:30.
If  a single string is provided, then each element of the mask will be examined against the statement in the string.
For example, if <em>'&gt;0.5'</em> is provided i.e. the mask is probabilities after a DL algorithm, then all
voxels with values &gt;0.5 in the mask image will be kept. This can be a complex logical expression.
The data on which the expression is executed is called <em>data</em> or <em>data_mask</em>, depending on whether
you wish to filter the original image, that is the original image is supplied as a mask, or if you have
unique mask files respectively. Therefore for complex logical expressions you can define for example:
<em>'&gt;-100 &amp; data&lt;30'</em> to consider data values between -100 and 30, or <em>'&gt;0.5 &amp; data_mask&lt;0.75'</em>
to select voxels based-on mask values between 0.5 and 0.75 for example if they represent a probability mask.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_switch_z">switch_z</code></td>
<td>
<p>logical, indicating whether to change the orientation of the images in the Z axis. Some
software reverse the order of the manipulated image in the Z axis, and therefore the images of the mask
image need to be reversed.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_crop_in">crop_in</code></td>
<td>
<p>logical, indicating whether to crop <em>RIA_image</em> to smallest bounding box.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_replace_in">replace_in</code></td>
<td>
<p>logical, whether to replace smallest values indicated by <em>zero_value</em>,
which are considered to indicate no signal, to NA.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_center_in">center_in</code></td>
<td>
<p>logical, whether to shift data so smallest value
is equal to <em>min_to</em> input parameter.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_zero_value">zero_value</code></td>
<td>
<p>integer, indicating voxels values which are considered
not to have any information. If left empty,
then the smallest HU value in the image will be used, if <em>replace_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_min_to">min_to</code></td>
<td>
<p>integer, value to which data is shifted to if <em>center_in</em> is TRUE.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_verbose_in">verbose_in</code></td>
<td>
<p>logical, indicating whether to print detailed information.
Most prints can also be suppresed using the <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> function.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_origin_in">origin_in</code></td>
<td>
<p><em>origin</em> parameter input of <code><a href="nat.html#topic+read.nrrd">read.nrrd</a></code>.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_readbyteasraw_in">ReadByteAsRaw_in</code></td>
<td>
<p><em>origin</em> parameter input of <code><a href="nat.html#topic+read.nrrd">read.nrrd</a></code>.</p>
</td></tr>
<tr><td><code id="load_nrrd_+3A_...">...</code></td>
<td>
<p>additional arguments to  <code><a href="nat.html#topic+read.nrrd">read.nrrd</a></code>,
<code><a href="nat.html#topic+read.nrrd.header">read.nrrd.header</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>load_nrrd</em> is used to transform nrrd datasets into the RIA environment.
<em>RIA_image</em> object was developed to facilitate and simplify radiomics calculations by keeping
all necessary information in one place.
<br />
<br />
<em>RIA_data</em> stores the nrrd image that is converted to numerical 3D arrays using
<code><a href="nat.html#topic+read.nrrd">read.nrrd</a></code>.
The function stores the original loaded image in  <em>RIA_data$orig</em>,
while all modified images are stored in <em>RIA_data$modif</em>.
By default, the original image <em>RIA_data$orig</em> is untouched by functions
other than those operating in <em>load_nrrd</em>. While other functions
operate on the <em>RIA_data$modif</em> image by default.
<br />
Due to memory concerns, there can only be one <em>RIA_data$orig</em> and <em>RIA_data$modif</em>
image present at one time in a <em>RIA_image</em>. Therefore, if image manipulations are performed,
then the <em>RIA_data$modif</em> will be overwritten. However, functions can save images
into new slots of <em>RIA_image</em>, for example discretized images can be saved to the <em>discretized</em> slot of <em>RIA_image</em>.
<br />
<em>load_nrrd</em> not only loads the image based on parameters that can be set for
<code><a href="nat.html#topic+read.nrrd">read.nrrd</a></code>, but also can perform
minimal manipulations on the image itself.
<br />
<em>crop_in</em> logical variable is used to indicate, whether to crop the image to the
smallest bounding box still containing all the information. If TRUE, then all X, Y and potentially
Z slices containing no information will be removed. This allows significant reduction of necessary
memory to store image data.
<br />
<em>zero_value</em> parameter is used to indicate HU values which contain no information. If left empty,
then the smallest value will be considered as indicating voxels without a signal.
<br />
<em>replace_in</em> logical can be used to change values that are considered to have no signal to NA.
This is necessary to receive proper statistical values later on.
<br />
<em>center_in</em> logical is used to indicate whether the values should be shifted.
Some vendors save HU values as positive integers to spare memory and minimalize file sizes.
Therefore, in some instances shift of the scale is needed. By default,
the values are shifted by -1024, but in other cases a different constant might be required,
which can be set using the <em>min_to</em> input.
<br />
<br />
<em>RIA_header</em> is a list containing the most basic patient and examination information
present in the nrrd file.
<br />
<br />
<em>RIA_log</em> is a list of variables, which give an overview of what has been done with the image.
If the whole <em>RIA_image</em> is supplied to a function, the information regarding the manipulations
are written into the <em>$events</em> array in chronological order. Furthermore, some additional
information is also saved in the log, which might be needed for further analysis.
</p>


<h3>Value</h3>

<p>Returns a <em>RIA_image</em> object. <em>RIA_image</em> is a list with three mandatory attributes.
</p>

<ul>
<li> <p><b>RIA_data</b> is a <em>RIA_data</em> object containing the image in <em>$orig</em> slot.
</p>
</li>
<li> <p><b>RIA_header</b> is a <em>RIA_header</em> object, which is s list of nrrd information.
</p>
</li>
<li> <p><b>RIA_log</b> is a <em>RIA_log</em> object, which is a list updated by RIA functions
and acts as a log and possible input for some functions.
</p>
</li></ul>



<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 #Image will be croped to smallest bounding box, and smallest values will be changed to NA,
 while 1024 will be substracted from all other data points.
 RIA_image &lt;- load_nrrd("/Users/Test/Documents/Radiomics/John_Smith/nrrd_folder/sample.nrrd")
 
## End(Not run)
 
</code></pre>

<hr>
<h2 id='merge_RIA_images'>Merges multiple loaded images into one volume</h2><span id='topic+merge_RIA_images'></span>

<h3>Description</h3>

<p>Merges multiple <em>RIA_image</em> class objects loaded using any of the load functions.
All images need to have the same dimensions. Further, during loading the images should not be cropped
to assure that the orientation and position of the data is maintained. Data of the new combined image is updated sequentially,
using data from the <em>data$orig</em> slot, that is only parts of the image that do not have data
(which are converted to NA during the load process) are updated in the order of provided <em>RIA_images</em>. If multiple images
contain data in for the same element, the first value is used in the new image. Data in the <em>data$log</em> slot
is updated based on the new combined image, while data in the <em>data$header</em> slot is copied from the first provided image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_RIA_images(RIA_data_in, crop_in = TRUE, verbose_in = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_RIA_images_+3A_ria_data_in">RIA_data_in</code></td>
<td>
<p>List of Multiple <em>RIA_images</em>.</p>
</td></tr>
<tr><td><code id="merge_RIA_images_+3A_crop_in">crop_in</code></td>
<td>
<p>logical, indicating whether to crop the merged image to smallest bounding box.</p>
</td></tr>
<tr><td><code id="merge_RIA_images_+3A_verbose_in">verbose_in</code></td>
<td>
<p>logical indicating whether to print detailed information.
Most prints can also be suppressed using the <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>RIA_image</em> containing the merged volume with updated log and header data
</p>


<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Load multiple images and combine them
d1 &lt;- load_nifti(ABC_p1.nii.gz, crop_in = FALSE)
d2 &lt;- load_nifti(ABC_p2.nii.gz, crop_in = FALSE)
d  &lt;- merge_RIA(list(d1, d2))

## End(Not run)

</code></pre>

<hr>
<h2 id='Non_NRS'><em>RIA_image</em> object of a plaque without the napkin-ring sign</h2><span id='topic+Non_NRS'></span>

<h3>Description</h3>

<p>rda containing an example <em>RIA_image</em> object of a patients plaque
which does not show the napkin-ring sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRS
</code></pre>


<h3>Format</h3>

<p>RIA_image object
</p>


<h3>Value</h3>

<p>RIA_image object
</p>


<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>

<hr>
<h2 id='NRS'><em>RIA_image</em> object of a plaque with the napkin-ring sign</h2><span id='topic+NRS'></span>

<h3>Description</h3>

<p>rda containing an example <em>RIA_image</em> object of a patients plaque
which shows the napkin-ring sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NRS
</code></pre>


<h3>Format</h3>

<p>RIA_image object
</p>


<h3>Value</h3>

<p>RIA_image object
</p>


<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>

<hr>
<h2 id='radiomics_all'>Calculates all radiomic statistics on supplied RIA_image</h2><span id='topic+radiomics_all'></span>

<h3>Description</h3>

<p>Calculates specified radiomic statistics on <em>RIA_image</em>. Parameters of
radiomic functions may be set. By default the the images are discretized to 8, 16 and 32 bins
using equally sized and probable binning. First-order statistics are calculated on the
original image and if asked then on all discretizations. Symmetric GLCMs are calculated for all directions
at a distance of 1 for all discretizations. GLRLMs are also calculated for all
discretizations. Geometry-based statistics are calculated for the original image as well as all
discretizations is requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiomics_all(
  RIA_data_in,
  bins_in = c(8, 16, 32),
  equal_prob = "both",
  fo_discretized = FALSE,
  distance = c(1),
  statistic = "mean(X, na.rm = TRUE)",
  geometry_discretized = TRUE,
  verbose_in = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiomics_all_+3A_ria_data_in">RIA_data_in</code></td>
<td>
<p><em>RIA_image</em>.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_bins_in">bins_in</code></td>
<td>
<p>integer vector, number of bins specified.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_equal_prob">equal_prob</code></td>
<td>
<p>logical or string, indicating to cut data into bins with equal relative frequencies.
If FALSE, then equal interval bins will be used. If <em>&quot;both&quot;</em> is supplied, the both equally probable
and equal interval bins will be created.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_fo_discretized">fo_discretized</code></td>
<td>
<p>logical, indicating whether to calculate first-order statistics on 
discretized images.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_distance">distance</code></td>
<td>
<p>integer, distance between the voxels being compared.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_statistic">statistic</code></td>
<td>
<p>string, defining the statistic to be calculated on the array of GLCM statistics.
By default, statistic is set to <em>&quot;mean&quot;</em>, however any function may be provided. The proper
syntax is: function(X, attributes). The supplied string must contain a &quot;X&quot;, which will be replaced
with the array of the GLCM statistics value. Further attributes of the function may also be given.
For example, if you wish to calculate the median of all GLCMs calculated in different directions,
then it must be supplied as: <em>median(X, na.rm = TRUE)</em>.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_geometry_discretized">geometry_discretized</code></td>
<td>
<p>logical, indicating whether to calculate geometry-based statistics on 
discretized images.</p>
</td></tr>
<tr><td><code id="radiomics_all_+3A_verbose_in">verbose_in</code></td>
<td>
<p>logical, indicating whether to print detailed information.
Most prints can also be suppressed using the <code><a href="base.html#topic+suppressMessages">suppressMessages</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>RIA_image</em> containing the statistical information.
</p>


<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Discretize loaded image and then calculate all radiomic statistics
RIA_image &lt;- radiomics_all(RIA_image, equal_prob = "both", bins_in= c(32,64), distance = c(1:2))

## End(Not run)

</code></pre>

<hr>
<h2 id='save_RIA'>Export radiomics calculations of RIA image to csv</h2><span id='topic+save_RIA'></span>

<h3>Description</h3>

<p>Exports given slots of statistics from RIA_image. Names of slots have to be defined
which the user wishes to export using the <em>stats</em> parameter. Using the <em>group_name</em>
parameter the user can lable the cases with a group ID, for example &quot;Case&quot;, which can be
used as a grouping variable for further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_RIA(
  RIA_image,
  save_to = "C:/",
  save_name = "RIA_stat",
  group_name = "Case",
  stats = c("stat_fo", "stat_glcm_mean", "stat_glrlm_mean", "stat_geometry")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_RIA_+3A_ria_image">RIA_image</code></td>
<td>
<p><em>RIA_image</em> with calculated statistics.</p>
</td></tr>
<tr><td><code id="save_RIA_+3A_save_to">save_to</code></td>
<td>
<p>string, path of folder to save results to.</p>
</td></tr>
<tr><td><code id="save_RIA_+3A_save_name">save_name</code></td>
<td>
<p>string, path of folder to save results to.</p>
</td></tr>
<tr><td><code id="save_RIA_+3A_group_name">group_name</code></td>
<td>
<p>string, a ID defining which group the case belongs to.</p>
</td></tr>
<tr><td><code id="save_RIA_+3A_stats">stats</code></td>
<td>
<p>string vector, identifing which slots to export</p>
</td></tr>
</table>


<h3>References</h3>

<p>Márton KOLOSSVÁRY et al.
Radiomic Features Are Superior to Conventional Quantitative Computed Tomographic
Metrics to Identify Coronary Plaques With Napkin-Ring Sign
Circulation: Cardiovascular Imaging (2017).
DOI: 10.1161/circimaging.117.006843
<a href="https://pubmed.ncbi.nlm.nih.gov/29233836/">https://pubmed.ncbi.nlm.nih.gov/29233836/</a>
</p>
<p>Márton KOLOSSVÁRY et al.
Cardiac Computed Tomography Radiomics: A Comprehensive Review on Radiomic Techniques.
Journal of Thoracic Imaging (2018).
DOI: 10.1097/RTI.0000000000000268
<a href="https://pubmed.ncbi.nlm.nih.gov/28346329/">https://pubmed.ncbi.nlm.nih.gov/28346329/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
