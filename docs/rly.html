<!DOCTYPE html><html lang="en"><head><title>Help for package rly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rly-package'><p>rly: Tools to Create Formal Language Parsers</p></a></li>
<li><a href='#lex'><p>Build a lexer</p></a></li>
<li><a href='#Lexer'><p>Lexing Engine</p></a></li>
<li><a href='#LexToken'><p>Lex Token</p></a></li>
<li><a href='#LRParser'><p>The LR Parsing engine</p></a></li>
<li><a href='#NullLogger'><p>Null logger is used when no output should be generated.</p></a></li>
<li><a href='#RlyLogger'><p>Print log message to file or console.</p></a></li>
<li><a href='#yacc'><p>Build a parser</p></a></li>
<li><a href='#YaccProduction'><p>Object sent to grammar rule</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools to Create Formal Language Parser</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Marek Jagielski [aut, cre, cph],
  David M. Beazley [aut, cph],
  Yasutaka Tanaka [ctb],
  Henrico Witvliet [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marek Jagielski &lt;marek.jagielski@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R implementation of the common parsing tools 'lex' and 'yacc'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/systemincloud/rly">https://github.com/systemincloud/rly</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/systemincloud/rly/issues">https://github.com/systemincloud/rly/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, futile.logger</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'logger.R' 'lex.R' 'yacc.R' 'rly-package.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-08 12:42:43 UTC; lupus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-08 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rly-package'>rly: Tools to Create Formal Language Parsers</h2><span id='topic+rly'></span><span id='topic+rly-package'></span>

<h3>Description</h3>

<p>R implementation of the common parsing tools 'lex' and 'yacc'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marek Jagielski <a href="mailto:marek.jagielski@gmail.com">marek.jagielski@gmail.com</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> David M. Beazley [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Yasutaka Tanaka [contributor]
</p>
</li>
<li><p> Henrico Witvliet [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/systemincloud/rly">https://github.com/systemincloud/rly</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/systemincloud/rly/issues">https://github.com/systemincloud/rly/issues</a>
</p>
</li></ul>


<hr>
<h2 id='lex'>Build a lexer</h2><span id='topic+lex'></span>

<h3>Description</h3>

<p>Build all of the regular expression rules from definitions in the supplied module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lex(module = NA, args = list(), debug = FALSE, debuglog = NA,
  errorlog = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lex_+3A_module">module</code></td>
<td>
<p>R6 class containing lex rules</p>
</td></tr>
<tr><td><code id="lex_+3A_args">args</code></td>
<td>
<p>list of arguments that should be passed to constructor</p>
</td></tr>
<tr><td><code id="lex_+3A_debug">debug</code></td>
<td>
<p>on and off debug mode</p>
</td></tr>
<tr><td><code id="lex_+3A_debuglog">debuglog</code></td>
<td>
<p>custom logger for debug messages</p>
</td></tr>
<tr><td><code id="lex_+3A_errorlog">errorlog</code></td>
<td>
<p>custom logger for error messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lexer ready to use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOKENS = c('NAME', 'NUMBER')
LITERALS = c('=','+','-','*','/', '(',')')

Lexer &lt;- R6::R6Class("Lexer",
  public = list(
    tokens = TOKENS,
    literals = LITERALS,
    t_NAME = '[a-zA-Z_][a-zA-Z0-9_]*',
    t_NUMBER = function(re='\\d+', t) {
      t$value &lt;- strtoi(t$value)
      return(t)
    },
    t_ignore = " \t",
    t_newline = function(re='\\n+', t) {
       t$lexer$lineno &lt;- t$lexer$lineno + nchar(t$value)
       return(NULL)
    },
    t_error = function(t) {
      cat(sprintf("Illegal character '%s'", t$value[1]))
      t$lexer$skip(1)
      return(t)
    }
  )
)

lexer  &lt;- rly::lex(Lexer)
lexer$input("5 + 3")
print(lexer$token()$value)
# [1] 5
print(lexer$token()$value)
# [1] "+"
print(lexer$token()$value)
# [1] 3
</code></pre>

<hr>
<h2 id='Lexer'>Lexing Engine</h2><span id='topic+Lexer'></span>

<h3>Description</h3>


<p>The following Lexer class implements the lexer runtime. There are only
a few public methods and attributes:
</p>

<ul>
<li><p> input() - Store a new string in the lexer
</p>
</li>
<li><p> token() - Get the next token
</p>
</li>
<li><p> clone() - Clone the lexer
</p>
</li>
<li><p> lineno  - Current line number
</p>
</li>
<li><p> lexpos  - Current position in the input string
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>Lexer
</code></pre>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object</p>

<hr>
<h2 id='LexToken'>Lex Token</h2><span id='topic+LexToken'></span>

<h3>Description</h3>

<p>Token class.  This class is used to represent the tokens produced
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LexToken
</code></pre>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object</p>

<hr>
<h2 id='LRParser'>The LR Parsing engine</h2><span id='topic+LRParser'></span>

<h3>Description</h3>

<p>The LR Parsing engine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRParser
</code></pre>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object</p>

<hr>
<h2 id='NullLogger'>Null logger is used when no output should be generated.</h2><span id='topic+NullLogger'></span>

<h3>Description</h3>

<p>Does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NullLogger
</code></pre>


<h3>Format</h3>

<p>A <code><a href="R6.html#topic+R6Class">R6Class</a></code> object</p>


<h3>Examples</h3>

<pre><code class='language-R'>debuglog &lt;- NullLogger$new()
debuglog$info('This will not print')
</code></pre>

<hr>
<h2 id='RlyLogger'>Print log message to file or console.</h2><span id='topic+RlyLogger'></span>

<h3>Description</h3>

<p>This object is a stand-in for a logging object created by the
logging module. RLY will use this by default to create things
such as the parser.out file. If a user wants more detailed
information, they can create their own logging object and pass
it into RLY.
'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RlyLogger
</code></pre>


<h3>Format</h3>

<p>A <code><a href="R6.html#topic+R6Class">R6Class</a></code> object</p>


<h3>Examples</h3>

<pre><code class='language-R'>debuglog &lt;- rly::RlyLogger$new(".", "file.out")
debuglog$info('This is info message')

file.remove("file.out")
</code></pre>

<hr>
<h2 id='yacc'>Build a parser</h2><span id='topic+yacc'></span>

<h3>Description</h3>

<p>This function is entry point to the library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yacc(module = NA, args = list(), method = "LALR", debug = FALSE,
  start = NA, check_recursion = TRUE, debugfile = "parser.out",
  outputdir = NA, debuglog = NA, errorlog = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yacc_+3A_module">module</code></td>
<td>
<p>R6 class containing rules</p>
</td></tr>
<tr><td><code id="yacc_+3A_args">args</code></td>
<td>
<p>list of arguments that should be passed to constructor</p>
</td></tr>
<tr><td><code id="yacc_+3A_method">method</code></td>
<td>
<p>type of algorithm</p>
</td></tr>
<tr><td><code id="yacc_+3A_debug">debug</code></td>
<td>
<p>on and off debug mode</p>
</td></tr>
<tr><td><code id="yacc_+3A_start">start</code></td>
<td>
<p>provide custom start method</p>
</td></tr>
<tr><td><code id="yacc_+3A_check_recursion">check_recursion</code></td>
<td>
<p>should yacc look for recursions in rules</p>
</td></tr>
<tr><td><code id="yacc_+3A_debugfile">debugfile</code></td>
<td>
<p>the name of the custom debug output logs</p>
</td></tr>
<tr><td><code id="yacc_+3A_outputdir">outputdir</code></td>
<td>
<p>the dierectory of custom debug logs</p>
</td></tr>
<tr><td><code id="yacc_+3A_debuglog">debuglog</code></td>
<td>
<p>custom logger for debug messages</p>
</td></tr>
<tr><td><code id="yacc_+3A_errorlog">errorlog</code></td>
<td>
<p>custom logger for error messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parser ready to use
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOKENS = c('NAME', 'NUMBER')
LITERALS = c('=','+','-','*','/', '(',')')

Parser &lt;- R6::R6Class("Parser",
  public = list(
    tokens = TOKENS,
    literals = LITERALS,
    # Parsing rules
    precedence = list(c('left','+','-'),
                      c('left','*','/'),
                      c('right','UMINUS')),
    # dictionary of names
    names = new.env(hash=TRUE),
    p_statement_assign = function(doc='statement : NAME "=" expression', p) {
      self$names[[as.character(p$get(2))]] &lt;- p$get(4)
    },
    p_statement_expr = function(doc='statement : expression', p) {
      cat(p$get(2))
      cat('\n')
    },
    p_expression_binop = function(doc="expression : expression '+' expression
                                                  | expression '-' expression
                                                  | expression '*' expression
                                                  | expression '/' expression", p) {
      if(p$get(3) == '+') p$set(1, p$get(2) + p$get(4))
      else if(p$get(3) == '-') p$set(1, p$get(2) - p$get(4))
      else if(p$get(3) == '*') p$set(1, p$get(2) * p$get(4))
      else if(p$get(3) == '/') p$set(1, p$get(2) / p$get(4))
    },
    p_expression_uminus = function(doc="expression : '-' expression %prec UMINUS", p) {
      p$set(1, -p$get(3))
    },
    p_expression_group = function(doc="expression : '(' expression ')'", p) {
      p$set(1, p$get(3))
    },
    p_expression_number = function(doc='expression : NUMBER', p) {
      p$set(1, p$get(2))
    },
    p_expression_name = function(doc='expression : NAME', p) {
      p$set(1, self$names[[as.character(p$get(2))]])
    },
    p_error = function(p) {
      if(is.null(p)) cat("Syntax error at EOF")
      else           cat(sprintf("Syntax error at '%s'", p$value))
    }
  )
)

parser &lt;- rly::yacc(Parser)
</code></pre>

<hr>
<h2 id='YaccProduction'>Object sent to grammar rule</h2><span id='topic+YaccProduction'></span>

<h3>Description</h3>

<p>This class is a wrapper around the objects actually passed to each
grammar rule. Index lookup and assignment actually assign the
.value attribute of the underlying YaccSymbol object.
The lineno() method returns the line number of a given
item (or 0 if not defined).   The linespan() method returns
a tuple of (startline,endline) representing the range of lines
for a symbol.  The lexspan() method returns a tuple (lexpos,endlexpos)
representing the range of positional information for a symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YaccProduction
</code></pre>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
