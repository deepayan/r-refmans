<!DOCTYPE html><html><head><title>Help for package BFI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BFI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BFI-package'><p>Bayesian Federated Inference</p></a></li>
<li><a href='#b.diag'><p>Create a Block Diagonal Matrix</p></a></li>
<li><a href='#bfi'><p>Bayesian Federated Inference</p></a></li>
<li><a href='#BFI-internal'><p>Internal BFI Functions</p></a></li>
<li><a href='#hazards.fun'><p>Compute the estimated (baseline/cumulative) hazard and (baseline) survival functions</p></a></li>
<li><a href='#inv.prior.cov'><p>Creates an inverse covariance matrix for a Gaussian prior</p></a></li>
<li><a href='#MAP.estimation'><p>Maximum A Posteriori estimation</p></a></li>
<li><a href='#n.par'><p>The Number of Predictors, Coefficients, and Observations</p></a></li>
<li><a href='#Nurses'>
<p>Nurses' stress in different hospitals</p></a></li>
<li><a href='#summary.bfi'><p>Summarizing BFI Fits</p></a></li>
<li><a href='#surv.simulate'><p>Generate survival data with predefined censoring rates for proportional hazards models</p></a></li>
<li><a href='#trauma'>
<p>Trauma patients from different hospitals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Federated Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-04 07:10:10 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Hassan Pazira <a href="https://orcid.org/0000-0002-4266-6877"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Emanuele Massa <a href="https://orcid.org/0000-0001-5715-2572"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Marianne A. Jonker
    <a href="https://orcid.org/0000-0003-0134-8482"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hassan Pazira &lt;hassan.pazira@radboudumc.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The Bayesian Federated Inference ('BFI') method combines inference results obtained from local data sets in the separate centers. In this version of the package, the 'BFI' methodology is programmed for linear, logistic and survival regression models. For GLMs, see Jonker, Pazira and Coolen (2024) &lt;<a href="https://doi.org/10.1002%2Fsim.10072">doi:10.1002/sim.10072</a>&gt;; for survival models, see Pazira, Massa, Weijers, Coolen and Jonker (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2404.17464">doi:10.48550/arXiv.2404.17464</a>&gt;; and for heterogeneous populations, see Jonker, Pazira and Coolen (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2402.02898">doi:10.48550/arXiv.2402.02898</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hassanpazira.github.io/BFI/">https://hassanpazira.github.io/BFI/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, roxygen2, devtools, spelling, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-03 18:06:35 UTC; hassanpazira</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='BFI-package'>Bayesian Federated Inference</h2><span id='topic+BFI-package'></span>

<h3>Description</h3>

<p>The Bayesian Federated Inference method combines inference results from different (medical) centers without sharing the data. In this version of the package, the user can fit models specifying Gaussian, Binomial (Logistic) and Survival families.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> BFI</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2024-04-27</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)
</td>
</tr>

</table>

<p><code>MAP.estimation</code> and <code>bfi</code> are the main functions. All other functions are utility functions.
</p>
<p>Some examples are provided in the vignettes accompanying this package in order to show how the package can be applied to real data. The vignettes can be found on the package website at <a href="https://hassanpazira.github.io/BFI/">https://hassanpazira.github.io/BFI/</a> or within R once the package has been installed, e.g., via <code>vignette("BFI", package = "BFI")</code>.
</p>


<h3>Author(s)</h3>

<p>Hassan Pazira, Emanuele Massa, Marianne A. Jonker<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>References</h3>

<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024). <em>Bayesian federated inference for estimating statistical models based on non-shared multicenter data sets</em>, <em>Statistics in Medicine</em>, 43(12): 2421-2438. &lt;https://doi.org/10.1002/sim.10072&gt;
</p>
<p>Pazira H., Massa E., Weijers J.A.M., Coolen A.C.C. and Jonker M.A. (2024). <em>Bayesian Federated Inference for Survival Models</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2404.17464&gt;
</p>
<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024). <em>Bayesian Federated Inference for regression models with heterogeneous multi-center populations</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2402.02898&gt;
</p>

<hr>
<h2 id='b.diag'>Create a Block Diagonal Matrix</h2><span id='topic+b.diag'></span>

<h3>Description</h3>

<p>Construct a block diagonal matrix using multiple given block matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b.diag(..., fill = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b.diag_+3A_...">...</code></td>
<td>
<p>individual matrices or one list of matrices.</p>
</td></tr>
<tr><td><code id="b.diag_+3A_fill">fill</code></td>
<td>
<p>non-block-diagonal elements. Default is <code class="reqn">0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Avoid combining matrices and lists for the <code>...</code> argument.
</p>
<p><code>b.diag()</code> covers the arguments of type &quot;character&quot;.
</p>
<p>If a <em>sparse</em> matrix needed, run the following:
</p>
<p><code>library(Matrix); Matrix(b_diag, sparse = TRUE)</code>
</p>
<p>where <code>b_diag</code> is the matrix returned by <code>b.diag()</code>.
</p>


<h3>Value</h3>

<p><code>b.diag()</code> returns a block diagonal matrix obtained by combining the arguments.
</p>


<h3>Author(s)</h3>

<p>Hassan Pazira<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b.diag(1, matrix(1:3, 3,4), diag(3:2))

b.diag(matrix(1:6, 2), as.character(2))

lists &lt;- list(1, 2:3, diag(4:6), 7, cbind(8,9:12), 13:15)
b.diag(lists)
identical(b.diag(lists), b.diag(lapply(lists, as.matrix)))

b.diag(replicate(3, matrix(round(rnorm(9)), 3, 3), simplify=FALSE))

</code></pre>

<hr>
<h2 id='bfi'>Bayesian Federated Inference</h2><span id='topic+bfi'></span>

<h3>Description</h3>

<p><code>bfi</code> function can be used (on the central server) to combine inference results from separate datasets (without combining the data) to approximate what would have been inferred had the datasets been merged. This function can handle linear, logistic and survival regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfi(theta_hats = NULL,
    A_hats,
    Lambda,
    family = c("gaussian", "binomial", "survival"),
    stratified = FALSE,
    strat_par = NULL,
    center_spec = NULL,
    basehaz = c("weibul", "exp", "gomp", "poly", "pwexp"),
    theta_A_polys = NULL,
    q_ls,
    center_zero_sample = FALSE,
    which_cent_zeros,
    zero_sample_covs,
    refer_cats,
    zero_cats,
    lev_no_ref_zeros)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfi_+3A_theta_hats">theta_hats</code></td>
<td>
<p>a list of <code class="reqn">L</code> vectors of the maximum a posteriori (MAP) estimates of the model parameters in the <code class="reqn">L</code> centers. These vectors must have equal dimensions. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_a_hats">A_hats</code></td>
<td>
<p>a list of <code class="reqn">L</code> minus curvature matrices for <code class="reqn">L</code> centers. These matrices must have equal dimensions. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_family">family</code></td>
<td>
<p>a character string representing the family name used for the local centers. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="bfi_+3A_lambda">Lambda</code></td>
<td>
<p>a list of <code class="reqn">L+1</code> matrices. The <code class="reqn">k^{\th}</code> matrix is the chosen inverse variance-covariance matrix of the Gaussian distribution that is used as prior distribution in center <code class="reqn">k</code>, where <code class="reqn">k=1,2,\ldots,L</code>. The last matrix is the chosen variance-covariance matrix for the Gaussian prior of the (fictive) combined data set.
If <code>stratified = FALSE</code>, all <code class="reqn">L+1</code> matrices must have equal dimensions. While, if <code>stratified = TRUE</code>, the first <code class="reqn">L</code> matrices must have equal dimensions and the last matrix should have a different (greater) dimention than the others. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_stratified">stratified</code></td>
<td>
<p>logical flag for performing the stratified analysis. If <code>stratified = TRUE</code>, the parameter(s) selected in the <code>strat_par</code> argument are allowed to be different across centers, except when the argument <code>center_spec</code> is not <code>NULL</code>. Default is <code>stratified = FALSE</code>. See &lsquo;Details&rsquo; and &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_strat_par">strat_par</code></td>
<td>
<p>a one- or two-element integer vector for indicating the stratification parameter(s). The values <code class="reqn">1</code> and/or <code class="reqn">2</code> are/is used to indicate that the &ldquo;intercept&rdquo; and/or &ldquo;sigma2&rdquo; are allowed to vary, respectively. This argument is used only when <code>stratified = TRUE</code> and <code>center_spec = NULL</code>. Default is <code>strat_par = NULL</code>, but if <code>stratified = TRUE</code>, <code>strat_par</code> can not be <code>NULL</code> unless there is a center specific variable. For the <code>binomial</code> family the length of the vector should be at most one which refers to &ldquo;intercept&rdquo;, and the value of this element should be <code class="reqn">1</code>. For <code>gaussian</code> family this vector can be <code class="reqn">1</code> for indicating the &ldquo;intercept&rdquo; only, <code class="reqn">2</code> for indicating the &ldquo;sigma2&rdquo; only, and c(<code class="reqn">1</code>, <code class="reqn">2</code>) for both &ldquo;intercept&rdquo; and &ldquo;sigma2&rdquo;. See &lsquo;Details&rsquo; and &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_center_spec">center_spec</code></td>
<td>
<p>a vector of <code class="reqn">L</code> elements for representing the center specific variable. This argument is used only when <code>stratified = TRUE</code> and <code>strat_par = NULL</code>. Each element represents a specific feature of the corresponding center. There must be only one specific value or attribute for each center. This vector could be a numeric, characteristic or factor vector. Note that, the order of the centers in the vector <code>center_spec</code> must be the same as in the list of the argument <code>theta_hats</code>.
The used data type in the argument <code>center_spec</code> must be categorical. Default is <code>center_spec = NULL</code>. See also &lsquo;Details&rsquo; and &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_basehaz">basehaz</code></td>
<td>
<p>a character string representing one of the available baseline hazard functions; <code>exponential</code> (<code>"exp"</code>), <code>Weibull</code> (<code>"weibul"</code>, the default), <code>Gompertz</code> (<code>"gomp"</code>), <code>exponentiated polynomial</code> (<code>"poly"</code>), and <code>piecewise exponential</code> (<code>"pwexp"</code>). It is only used when <code>family = "survival"</code>. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="bfi_+3A_theta_a_polys">theta_A_polys</code></td>
<td>
<p>a list with <code class="reqn">L</code> elements so that each element is the array <code>theta_A_ploy</code> (the output of the <code>MAP.estimation</code> function, <code>MAP.estimation()$theta_A_ploy</code>) for the corresponding center. This argument, <code>theta_A_polys</code>, is only used if <code>family = "survival"</code> and <code>basehaz = "poly"</code>. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_q_ls">q_ls</code></td>
<td>
<p>a vector with <code class="reqn">L</code> elements in which each element is the order (minus 1) of the exponentiated polynomial baseline hazard function for the corresponding center, i.e., each element is the value of <code>q_l</code> (the output of the <code>MAP.estimation</code> function, <code>MAP.estimation()$q_l</code>). This argument, <code>q_ls</code>, is only used if <code>family = "survival"</code> and <code>basehaz = "poly"</code>. It can also be a scalar which represents the maximum value of the <code>q_l</code>'s across the centers.</p>
</td></tr>
<tr><td><code id="bfi_+3A_center_zero_sample">center_zero_sample</code></td>
<td>
<p>logical flag indicating whether the center has a categorical covariate with no observations/individuals in one of the categories. Default is <code>center_zero_sample = FALSE</code>. For more detailes see &lsquo;References&rsquo;.</p>
</td></tr>
<tr><td><code id="bfi_+3A_which_cent_zeros">which_cent_zeros</code></td>
<td>
<p>an integer vector representing the center(s) which has one categorical covariate with no individuals in one of the categories. It is used if <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bfi_+3A_zero_sample_covs">zero_sample_covs</code></td>
<td>
<p>a vector in which each element is a character string representing the categorical covariate that has no samples/observations in one of its categories for the corresponding center. Each element of the vector can be obtained from the output of the <code>MAP.estimation</code> function for the corresponding center, <code>MAP.estimation()$zero_sample_cov</code>. It is used when <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bfi_+3A_refer_cats">refer_cats</code></td>
<td>
<p>a vector in which each element is a character string representing the reference category for the corresponding center. Each element of the vector can be obtained from the output of the <code>MAP.estimation</code> function for the corresponding center, <code>MAP.estimation()$refer_cat</code>. This vector is used when <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bfi_+3A_zero_cats">zero_cats</code></td>
<td>
<p>a vector in which each element is a character string representing the category with no samples/observations for the corresponding center. Each element of the vector can be obtained from the output of the <code>MAP.estimation</code> function for the corresponding center, i.e., <code>MAP.estimation()$zero_cat</code>. It is used when <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="bfi_+3A_lev_no_ref_zeros">lev_no_ref_zeros</code></td>
<td>
<p>a list in which the number of elements equals the length of the <code>which_cent_zeros</code> argument. Each element of the list is a vector containing the names of the levels of the categorical covariate that has no samples/observations in one of its categories for the corresponding center. However,  the name of the category with no samples and the name of the reference category are excluded from this vector. Each element of the list can be obtained from the output of the <code>MAP.estimation</code> function, i.e., <code>MAP.estimation()$lev_no_ref_zero</code>.
This argument is used if <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bfi</code> function implements the BFI approach described in the papers Jonker et. al. (2024a), Pazira et. al. (2024) and Jonker et. al. (2024b) given in the references.
The inference results gathered from different (<code class="reqn">L</code>) centers are combined, and the BFI estimates of the model parameters and curvature matrix evaluated at that point are returned.
</p>
<p>The inference result from each center must be obtained using the <code>MAP.estimation</code> function separately, and then all of these results (coming from different centers) should be compiled into a list to be used as an input of <code>bfi()</code>.
The models in the different centers should be defined in exactly the same way; among others, exactly the same covariates should be included in the models. The parameter vectors should be defined exactly the same, so that the <code class="reqn">L</code> vectors and matrices in the input lists <code>theta_hat</code>'s and <code>A_hat</code>'s are defined in the same way (e.g., the covariates need to be included in the models in the same order).
</p>
<p>Note that the order of the elements in the lists <code>theta_hats</code>, <code>A_hats</code> and <code>Lambda</code>, must be the same with respect to the centers, so that in every list the element at the <code class="reqn">\ell^{\th}</code> position is from the center <code class="reqn">\ell</code>. This should also be the case for the vector <code>center_spec</code>.
</p>
<p>If for the locations <code>intercept = FALSE</code>, the stratified analysis is not possible anymore for the <code>binomial</code> family.
</p>
<p>If <code>stratified = FALSE</code>, both <code>strat_par</code> and <code>center_spec</code> must be <code>NULL</code> (the defaults), while if <code>stratified = TRUE</code> only one of the two must be <code>NULL</code>.
</p>
<p>If <code>stratified = FALSE</code> and all the <code class="reqn">L+1</code> matrices in <code>Lambda</code> are equal, it is sufficient to give a (list of) one matrix only.
In both cases of the <code>stratified</code> argument (<code>TRUE</code> or <code>FALSE</code>), if only the first <code class="reqn">L</code> matrices are equal, the argument <code>Lambda</code> can be a list of two matrices, so that the fist matrix represents the chosen variance-covariance matrix for local centers and the second one is the chosen matrix for the combined data set.
The last matrix of the list in the argument <code>Lambda</code> can be built by the function <code>inv.prior.cov()</code>.
</p>
<p>If the data type used in the argument <code>center_spec</code> is continuous, one can use <code>stratified = TRUE</code> and <code>center_spec = NULL</code>, and set <code>strat_par</code> not to <code>NULL</code> (i.e., to <code class="reqn">1</code>, <code class="reqn">2</code> or both <code class="reqn">(1, 2)</code>). Indeed, in this case, the stratification parameter(s) given in the argument <code>strat_par</code> are assumed to be different across the centers.
</p>
<p>When <code>family = 'survival'</code> and <code>basehaz = 'poly'</code>, the arguments <code>theta_hats</code> and <code>A_hats</code> should not be provided. Instead, the <code>theta_A_polys</code> and <code>q_ls</code> arguments should be defined using the local information, specifically <code>MAP.estimation()$theta_A_poly</code> and <code>MAP.estimation()$q_l</code>, respectively. See the last example in &lsquo;Examples&rsquo;.
</p>


<h3>Value</h3>

<p><code>bfi</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>theta_hat</code></td>
<td>
<p>the vector of estimates obtained by combining the inference results from the <code class="reqn">L</code> centers with the <code>'BFI'</code> methodology. If an intercept was fitted in every center and <code>stratified = FALSE</code>, there is only one general &ldquo;intercept&rdquo; in this vector, while if <code>stratified = TRUE</code> and <code>strat_par = 1</code>, there are <code class="reqn">L</code> different intercepts in the model, for each center one;</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>minus the curvature (or Hessian) matrix obtained by the <code>'BFI'</code> method for the combined model. If <code>stratified = TRUE</code>, the dimension of the matrix is always greater than when <code>stratified = FALSE</code>;</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the vector of standard deviation of the estimates in <code>theta_hat</code> obtained from the matrix in <code>A_hat</code>, i.e., the vector equals <code>sqrt(diag(solve(A_hat)))</code> which equals the square root of the elements at the diagonal of the inverse of the <code>A_hat</code> matrix.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code>family</code> object used;</p>
</td></tr>
<tr><td><code>basehaz</code></td>
<td>
<p>the baseline hazard function used;</p>
</td></tr>
<tr><td><code>stratified</code></td>
<td>
<p>whether a stratified analysis was done or not.;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hassan Pazira and Marianne Jonker <br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>References</h3>

<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024a). <em>Bayesian federated inference for estimating statistical models based on non-shared multicenter data sets</em>, <em>Statistics in Medicine</em>, 43(12): 2421-2438. &lt;https://doi.org/10.1002/sim.10072&gt;
</p>
<p>Pazira H., Massa E., Weijers J.A.M., Coolen A.C.C. and Jonker M.A. (2024). <em>Bayesian Federated Inference for Survival Models</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2404.17464&gt;
</p>
<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024b). <em>Bayesian Federated Inference for regression models with heterogeneous multi-center populations</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2402.02898&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAP.estimation">MAP.estimation</a></code> and <code><a href="#topic+inv.prior.cov">inv.prior.cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################################
##  Example 1:  y ~ Binomial  (L = 2 centers)  ##
#################################################

# Setting a seed for reproducibility
set.seed(112358)

#------------------------------------#
# Data Simulation for Local Center 1 #
#------------------------------------#
n1 &lt;- 30                                           # sample size of center 1
X1 &lt;- data.frame(x1=rnorm(n1),                     # continuous variable
                 x2=sample(0:2, n1, replace=TRUE)) # categorical variable
# make dummy variables
X1x2_1 &lt;- ifelse(X1$x2 == '1', 1, 0)
X1x2_2 &lt;- ifelse(X1$x2 == '2', 1, 0)
X1$x2  &lt;- as.factor(X1$x2)
# regression coefficients
beta &lt;- 1:4  # beta[1] is the intercept
# linear predictor:
eta1   &lt;- beta[1] + X1$x1 * beta[2] + X1x2_1 * beta[3] + X1x2_2 * beta[4]
# inverse of the link function ( g^{-1}(\eta) = \mu ):
mu1    &lt;- binomial()$linkinv(eta1)
y1     &lt;- rbinom(n1, 1, mu1)

#------------------------------------#
# Data Simulation for Local Center 2 #
#------------------------------------#
n2 &lt;- 50                                           # sample size of center 2
X2 &lt;- data.frame(x1=rnorm(n2),                     # continuous variable
                 x2=sample(0:2, n2, replace=TRUE)) # categorical variable
# make dummy variables:
X2x2_1 &lt;- ifelse(X2$x2 == '1', 1, 0)
X2x2_2 &lt;- ifelse(X2$x2 == '2', 1, 0)
X2$x2  &lt;- as.factor(X2$x2)
# linear predictor:
eta2   &lt;- beta[1] + X2$x1 * beta[2] + X2x2_1 * beta[3] + X2x2_2 * beta[4]
# inverse of the link function:
mu2    &lt;- binomial()$linkinv(eta2)
y2     &lt;- rbinom(n2, 1, mu2)

#---------------------------#
# MAP Estimates at Center 1 #
#---------------------------#
# Assume the same inverse covariance matrix (Lambda) for both centers:
Lambda     &lt;- inv.prior.cov(X1, lambda = 0.01, family = 'binomial')
fit1       &lt;- MAP.estimation(y1, X1, family = 'binomial', Lambda)
theta_hat1 &lt;- fit1$theta_hat # intercept and coefficient estimates
A_hat1     &lt;- fit1$A_hat     # minus the curvature matrix

#---------------------------#
# MAP Estimates at Center 2 #
#---------------------------#
fit2       &lt;- MAP.estimation(y2, X2, family='binomial', Lambda)
theta_hat2 &lt;- fit2$theta_hat
A_hat2     &lt;- fit2$A_hat

#-----------------------#
# BFI at Central Center #
#-----------------------#
theta_hats &lt;- list(theta_hat1, theta_hat2)
A_hats     &lt;- list(A_hat1, A_hat2)
bfi        &lt;- bfi(theta_hats, A_hats, Lambda, family='binomial')
class(bfi)
summary(bfi, cur_mat=TRUE)

###---------------------###
### Stratified Analysis ###
###---------------------###

# By running the following line an error appears because
# when stratified = TRUE, both 'strat_par' and 'center_spec' can not be NULL:
Just4check1 &lt;- try(bfi(theta_hats, A_hats, Lambda, family = 'binomial',
                   stratified = TRUE), TRUE)
class(Just4check1) # By default, both 'strat_par' and 'center_spec' are NULL!

# By running the following line an error appears because when stratified = TRUE,
# last matrix in 'Lambda' should not have the same dim. as the other local matrices:
Just4check2 &lt;- try(bfi(theta_hats, A_hats, Lambda, stratified = TRUE,
                   strat_par = 1), TRUE)
class(Just4check2) # All matices in Lambda have the same dimension!

# Stratified analysis when 'intercept' varies across two centers:
newLam &lt;- inv.prior.cov(X1, lambda=c(0.1, 0.3), family = 'binomial',
                        stratified = TRUE, strat_par = 1)
bfi &lt;- bfi(theta_hats, A_hats, list(Lambda, newLam), family = 'binomial',
           stratified=TRUE, strat_par=1)
summary(bfi, cur_mat=TRUE)


#################################################
##  Example 2:  y ~ Gaussian  (L = 3 centers)  ##
#################################################

# Setting a seed for reproducibility
set.seed(112358)

p     &lt;- 3                     # number of coefficients without 'intercept'
theta &lt;- c(1, rep(2, p), 1.5)  # reg. coef.s (theta[1] is 'intercept') &amp; 'sigma2' = 1.5

#------------------------------------#
# Data Simulation for Local Center 1 #
#------------------------------------#
n1   &lt;- 30                                       # sample size of center 1
X1   &lt;- data.frame(matrix(rnorm(n1 * p), n1, p)) # continuous variables
# linear predictor:
eta1 &lt;- theta[1] + as.matrix(X1) 
# inverse of the link function ( g^{-1}(\eta) = \mu ):
mu1  &lt;- gaussian()$linkinv(eta1)
y1   &lt;- rnorm(n1, mu1, sd = sqrt(theta[5]))

#------------------------------------#
# Data Simulation for Local Center 2 #
#------------------------------------#
n2   &lt;- 40                                       # sample size of center 2
X2   &lt;- data.frame(matrix(rnorm(n2 * p), n2, p)) # continuous variables
# linear predictor:
eta2 &lt;- theta[1] + as.matrix(X2) 
# inverse of the link function:
mu2  &lt;- gaussian()$linkinv(eta2)
y2   &lt;- rnorm(n2, mu2, sd = sqrt(theta[5]))

#------------------------------------#
# Data Simulation for Local Center 3 #
#------------------------------------#
n3   &lt;- 50                                       # sample size of center 3
X3   &lt;- data.frame(matrix(rnorm(n3 * p), n3, p)) # continuous variables
# linear predictor:
eta3 &lt;- theta[1] + as.matrix(X3) 
# inverse of the link function:
mu3  &lt;- gaussian()$linkinv(eta3)
y3   &lt;- rnorm(n3, mu3, sd = sqrt(theta[5]))

#---------------------------#
# Inverse Covariance Matrix #
#---------------------------#
# Creating the inverse covariance matrix for the Gaussian prior distribution:
Lambda &lt;- inv.prior.cov(X1, lambda = 0.05, family='gaussian') # the same for both centers

#---------------------------#
# MAP Estimates at Center 1 #
#---------------------------#
fit1       &lt;- MAP.estimation(y1, X1, family = 'gaussian', Lambda)
theta_hat1 &lt;- fit1$theta_hat # intercept and coefficient estimates
A_hat1     &lt;- fit1$A_hat     # minus the curvature matrix

#---------------------------#
# MAP Estimates at Center 2 #
#---------------------------#
fit2       &lt;- MAP.estimation(y2, X2, family = 'gaussian', Lambda)
theta_hat2 &lt;- fit2$theta_hat
A_hat2     &lt;- fit2$A_hat

#---------------------------#
# MAP Estimates at Center 3 #
#---------------------------#
fit3       &lt;- MAP.estimation(y3, X3, family = 'gaussian', Lambda)
theta_hat3 &lt;- fit3$theta_hat
A_hat3     &lt;- fit3$A_hat

#-----------------------#
# BFI at Central Center #
#-----------------------#
A_hats     &lt;- list(A_hat1, A_hat2, A_hat3)
theta_hats &lt;- list(theta_hat1, theta_hat2, theta_hat3)
bfi        &lt;- bfi(theta_hats, A_hats, Lambda, family = 'gaussian')
summary(bfi, cur_mat=TRUE)

###---------------------###
### Stratified Analysis ###
###---------------------###

# Stratified analysis when 'intercept' varies across two centers:
newLam1 &lt;- inv.prior.cov(X1, lambda = c(0.1,0.3), family = 'gaussian',
                         stratified = TRUE, strat_par = 1, L=3)
# 'newLam1' is used the prior for combined data and
# 'Lambda' is used the prior for locals
list_newLam1 &lt;- list(Lambda, newLam1)
bfi1 &lt;- bfi(theta_hats, A_hats, list_newLam1, family = 'gaussian',
            stratified = TRUE, strat_par = 1)
summary(bfi1, cur_mat = TRUE)

# Stratified analysis when 'sigma2' varies across two centers:
newLam2 &lt;- inv.prior.cov(X1, lambda = c(0.1,0.3), family = 'gaussian',
                         stratified = TRUE, strat_par = 2, L = 3)
# 'newLam2' is used the prior for combined data and 'Lambda' is used the prior for locals
list_newLam2 &lt;- list(Lambda, newLam2)
bfi2 &lt;- bfi(theta_hats, A_hats, list_newLam2, family = 'gaussian',
            stratified = TRUE, strat_par=2)
summary(bfi2, cur_mat = TRUE)

# Stratified analysis when 'intercept' and 'sigma2' vary across 2 centers:
newLam3 &lt;- inv.prior.cov(X1, lambda = c(0.1,0.2,0.3), family = 'gaussian',
                         stratified = TRUE, strat_par = c(1, 2), L = 3)
# 'newLam3' is used the prior for combined data and 'Lambda' is used the prior for locals
list_newLam3 &lt;- list(Lambda, newLam3)
bfi3 &lt;- bfi(theta_hats, A_hats, list_newLam3, family = 'gaussian',
            stratified = TRUE, strat_par = 1:2)
summary(bfi3, cur_mat = TRUE)

###----------------------------###
### Center Specific Covariates ###
###----------------------------###

# Assume the first and third centers have the same center-specific covariate value
# of '3', while this value for the second center is '1', i.e., center_spec = c(3,1,3)
newLam4 &lt;- inv.prior.cov(X1, lambda=c(0.1, 0.2, 0.3), family='gaussian',
                         stratified=TRUE, center_spec = c(3,1,3), L=3)
# 'newLam4' is used the prior for combined data and 'Lambda' is used the prior for locals
l_newLam4 &lt;- list(Lambda, newLam4)
bfi4 &lt;- bfi(theta_hats, A_hats, l_newLam4, family = 'gaussian',
            stratified = TRUE, center_spec = c(3,1,3))
summary(bfi4, cur_mat = TRUE)


####################################################
##  Example 3:  Survival family  (L = 2 centers)  ##
####################################################

# Setting a seed for reproducibility
set.seed(112358)

p &lt;- 3
theta &lt;- c(1:4, 5, 6)  # regression coefficients (1:4) &amp; omega's (5:6)

#---------------------------------------------#
# Simulating Survival data for Local Center 1 #
#---------------------------------------------#
n1 &lt;- 30
X1 &lt;- data.frame(matrix(rnorm(n1 * p), n1, p)) # continuous (normal) variables
# Simulating survival data ('time' and 'status') from 'Weibull' with
# a predefined censoring rate of 0.3:
y1 &lt;- surv.simulate(Z = list(X1), beta = theta[1:p], a = theta[5], b = theta[6],
                   u1 = 0.1, cen_rate = 0.3, gen_data_from = "weibul")$D[[1]][, 1:2]
Lambda &lt;- inv.prior.cov(X1, lambda = c(0.1, 1), family = "survival", basehaz ="poly")
fit1 &lt;- MAP.estimation(y1, X1, family = 'survival', Lambda = Lambda, basehaz = "poly")
theta_hat1 &lt;- fit1$theta_hat  # coefficient estimates
A_hat1     &lt;- fit1$A_hat      # minus the curvature matrix
summary(fit1, cur_mat=TRUE)

#---------------------------------------------#
# Simulating Survival data for Local Center 2 #
#---------------------------------------------#
n2 &lt;- 30
X2 &lt;- data.frame(matrix(rnorm(n2 * p), n2, p)) # continuous (normal) variables
# Survival simulated data from 'Weibull' with a predefined censoring rate of 0.3:
y2 &lt;- surv.simulate(Z = list(X2), beta = theta[1:p], a = theta[5], b = theta[6], u1 = 0.1,
                    cen_rate = 0.3, gen_data_from = "weibul")$D[[1]][, 1:2]
fit2 &lt;- MAP.estimation(y2, X2, family = 'survival', Lambda = Lambda, basehaz = "poly")
theta_hat2 &lt;- fit2$theta_hat
A_hat2 &lt;- fit2$A_hat
summary(fit2, cur_mat=TRUE)

#-----------------------#
# BFI at Central Center #
#-----------------------#
# When family = 'survival' and basehaz = "poly", only 'theta_A_polys'
# should be defined instead of 'theta_hats' and 'A_hats':
theta_A_hats &lt;- list(fit1$theta_A_poly, fit2$theta_A_poly)
qls &lt;- c(fit1$q_l, fit2$q_l)
bfi &lt;- bfi(Lambda = Lambda, family = 'survival', theta_A_polys = theta_A_hats,
           basehaz = "poly", q_ls = qls)
summary(bfi, cur_mat=TRUE)

</code></pre>

<hr>
<h2 id='BFI-internal'>Internal BFI Functions</h2><span id='topic+A.l.maker'></span><span id='topic+negloglik.theta'></span><span id='topic+model.maker'></span><span id='topic+optim.survival'></span><span id='topic+ql.LRT'></span><span id='topic+lambda.poly'></span><span id='topic+i.basis'></span>

<h3>Description</h3>

<p>Internal BFI functions.</p>


<h3>Details</h3>

<p>These functions are not intended for use by users.</p>


<h3>Value</h3>

<p><code>A.l.maker()</code> returns a curvature matrix for each local.
</p>
<p><code>negloglik.theta()</code> returns the negative log-likelihood of regression coefficients and error variance, which can be utilized for optimization purposes.
</p>
<p><code>model.maker()</code> returns the outcome and design matrix, incorporating dummy variables when categorical covariates are present, e.g., by expanding factors to a set of dummy variables and expanding interactions similarly.
</p>
<p><code>optim.survival()</code> is a general-purpose optimization algorithm based on the &ldquo;L-BFGS-B&rdquo; method, and returns a vector of estimates for the coefficients and baseline hazard parameters.
</p>
<p><code>ql.LRT()</code> returns an optimal order/degree of the exponentiated polynomial model, obtained by the likelihood ratio test, for the 'cox' family.
</p>
<p><code>lambda.poly()</code> returns the baseline hazard function for the exponentiated polynomial form.
</p>
<p><code>i.basis()</code> creates the integral of the output of basis when <code>ibasis = TRUE</code>. This is also an indicator function between the <code class="reqn">k^{th}</code> and <code class="reqn">(k+1)^{th}</code> time points when <code>ibasis = FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Hassan Pazira<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>

<hr>
<h2 id='hazards.fun'>Compute the estimated (baseline/cumulative) hazard and (baseline) survival functions</h2><span id='topic+hazards.fun'></span>

<h3>Description</h3>

<p>For a given vector of times, <code>hazards.fun</code> computes the estimated baseline hazard, cumulative baseline hazard, hazard, baseline survival, and survival functions. It can be used for prediction on a new sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hazards.fun(time,
            z = NULL,
            p,
            theta_hat,
            basehaz = c("weibul", "exp", "gomp", "poly", "pwexp"),
            q_max,
            timax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazards.fun_+3A_time">time</code></td>
<td>
<p>the vector containing the time values for which the hazard rate is computed. If the argument <code>z</code> is not <code>NULL</code>, then the length of the argument <code>time</code> should be the number of columns of <code>z</code>, which is <code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code id="hazards.fun_+3A_z">z</code></td>
<td>
<p>a new observation vector of length <code class="reqn">p</code>. If <code>z = NULL</code> (the default), then the relative risk (<code class="reqn">\boldsymbol{z}^{\top} \boldsymbol{\beta}</code>) is considered a vector of 1 with length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="hazards.fun_+3A_p">p</code></td>
<td>
<p>the number of coefficients. It is taken equal to the number of elements of the argument <code>z</code>, if <code>z</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hazards.fun_+3A_theta_hat">theta_hat</code></td>
<td>
<p>a vector contains the values of the estimated parameters. The first <code class="reqn">p</code> values represent the coefficient parameters (<code class="reqn">\boldsymbol{\beta}</code>), while the remaining values pertain to the parameters of the baseline hazard function  (<code class="reqn">\boldsymbol{\omega}</code>).</p>
</td></tr>
<tr><td><code id="hazards.fun_+3A_basehaz">basehaz</code></td>
<td>
<p>a character string representing one of the available baseline hazard functions; <code>exponential</code> (<code>"exp"</code>), <code>Weibull</code> (<code>"weibul"</code>, the default), <code>Gompertz</code> (<code>"gomp"</code>), <code>exponentiated polynomial</code> (<code>"poly"</code>), and <code>piecewise exponential</code> (<code>"pwexp"</code>). Can be abbreviated.</p>
</td></tr>
<tr><td><code id="hazards.fun_+3A_q_max">q_max</code></td>
<td>
<p>a value represents the order of the exponentiated polynomial baseline hazard function. This argument should only be used when <code>basehaz = "poly"</code>. In the case of multiple centers, the maximum value of the orders should be used. <code>ql.LRT()</code> can be used for obtaining of the order of each center.</p>
</td></tr>
<tr><td><code id="hazards.fun_+3A_timax">timax</code></td>
<td>
<p>a value represents the minimum (or maximum) value of the maximum times observed in the different centers. This argument should only be used when <code>basehaz = "pwexp"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hazards.fun</code> computes the estimated baseline hazard, cumulative baseline hazard, hazard, baseline survival, and survival functions at different time points specified in the argument <code>time</code>.
</p>
<p>The function <code>hazards.fun()</code> can be used for prediction purposes with new sample. The arguments <code>time</code> and <code>z</code> should be provided for the new data.
</p>


<h3>Value</h3>

<p><code>hazards.fun</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>bhazard</code></td>
<td>
<p>the vector of estimates of the baseline hazard function at the time points given by the argument <code>time</code>;</p>
</td></tr>
<tr><td><code>cbhazard</code></td>
<td>
<p>the vector of estimates of the cumulative baseline hazard function at the time points specified in the argument <code>time</code>;</p>
</td></tr>
<tr><td><code>bsurvival</code></td>
<td>
<p>the vector of estimates of the baseline survival function at the time points given by the argument <code>time</code>;</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>the vector of estimates of the hazard function at the time points given by the argument <code>time</code>;</p>
</td></tr>
<tr><td><code>chazard</code></td>
<td>
<p>the vector of estimates of the cumulative hazard function at the time points specified in the argument <code>time</code>;</p>
</td></tr>
<tr><td><code>survival</code></td>
<td>
<p>the vector of estimates of the survival function at the time points given by the argument <code>time</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hassan Pazira<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>References</h3>

<p>Pazira H., Massa E., Weijers J.A.M., Coolen A.C.C. and Jonker M.A. (2024). <em>Bayesian Federated Inference for Survival Models</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2404.17464&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAP.estimation">MAP.estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setting a seed for reproducibility
set.seed(1123)

##-------------------------
## Simulating Survival data
##-------------------------

n &lt;- 40
p &lt;- 7
Original_data &lt;- data.frame(matrix(rnorm((n+1) * p), (n+1), p))
X &lt;- Original_data[1:n,]
X_new &lt;- Original_data[(n+1),]
# Simulating survival data from Exponential distribution
# with a predefined censoring rate of 0.2:
Orig_y &lt;- surv.simulate(Z = Original_data, beta = rep(1,p), a = exp(1),
                        cen_rate = 0.2, gen_data_from = "exp")$D[[1]][,1:2]
y &lt;- Orig_y[1:n,]
y_new &lt;- Orig_y[(n+1),]
time_points &lt;- seq(0, max(y$time), length.out=20)

#------------------------
# Weibull baseline hazard
#------------------------

Lambda &lt;- inv.prior.cov(X, lambda = c(0.5, 1), family = 'survival', basehaz = 'weibul')
fit_weib &lt;- MAP.estimation(y, X, family = 'survival', Lambda = Lambda,
                           basehaz = "weibul")
# reltive risk is 1:
hazards.fun(time = time_points, p = p, theta_hat = fit_weib$theta_hat,
            basehaz = "weibul")

#-------------------------
# Gompertz baseline hazard
#-------------------------
fit_gomp &lt;- MAP.estimation(y, X, family = 'survival', Lambda = Lambda,
                           basehaz = "gomp")
# different time points
hazards.fun(time=1:max(y*2), p = p, theta_hat = fit_gomp$theta_hat,
            basehaz = "gomp")


##----------------------------
## Prediction for a new sample
##----------------------------

## Exponentiated polynomial (poly) baseline hazard:
Lambda &lt;- inv.prior.cov(X, lambda = c(0.5, 1), family = 'survival', basehaz = "poly")
fit_poly &lt;- MAP.estimation(y, X, family = 'survival', Lambda = Lambda,
                           basehaz = "poly")
hazards.fun(time = y_new$time, z = X_new, theta_hat = fit_poly$theta_hat,
            basehaz = "poly", q_max = fit_poly$q_l)

## Piecewise Exponential (pwexp) baseline hazard:
Lambda &lt;- inv.prior.cov(X, lambda = c(0.5, 1), family = 'survival', basehaz = "pwexp")
fit_pw &lt;- MAP.estimation(y, X, family='survival', Lambda=Lambda, basehaz="pwexp",
                         min_max_times = max(y))
hazards.fun(time = y_new$time, z = X_new, theta_hat = fit_pw$theta_hat,
            basehaz = "pwexp", timax = max(y))

</code></pre>

<hr>
<h2 id='inv.prior.cov'>Creates an inverse covariance matrix for a Gaussian prior</h2><span id='topic+inv.prior.cov'></span>

<h3>Description</h3>

<p><code>inv.prior.cov</code> constructs a diagonal inverse covariance matrix for the Gaussian prior distribution based on the design matrix of covariates. This construction accounts for the number of regression parameters, especially when dealing with categorical covariates. For a linear model, it also includes an additional row and column to represent the variance of the measurement error. In the case of a survival model, it considers the parameters of the baseline hazard function as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.prior.cov(X,
              lambda = 1,
              L = 2,
              family = c("gaussian", "binomial", "survival"),
              intercept = TRUE,
              stratified = FALSE,
              strat_par = NULL,
              center_spec = NULL,
              basehaz = c("weibul", "exp", "gomp", "poly", "pwexp"),
              max_order = 2,
              n_intervals = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv.prior.cov_+3A_x">X</code></td>
<td>
<p>design matrix of dimension <code class="reqn">n \times p</code>, where <code class="reqn">n</code> is the number of samples observed, and <code class="reqn">p</code> is the number of predictors/variables so excluding the intercept.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_lambda">lambda</code></td>
<td>
<p>the vector used as the diagonal of the (inverse covariance) matrix that will be created by <code>inv.prior.cov()</code>. The length of the vector depends on the number of columns of <code>X</code>, type of the covariates (continuous/dichotomous or categorical), <code>family</code>, whether an <code>intercept</code> is included in the model, and whether <code>stratified</code> analysis is desired. When <code>stratified = FALSE</code>, <code>lambda</code> could be a single positive number (if all values in the vector are equal), a vector of two elements (the first is used for regression parameters including &ldquo;intercept&rdquo; and the second for the &ldquo;sigma2&rdquo; in the gaussian family or for the baseline hazard parameters in the survival case), or a vector of length equal to the number of model parameters. However, the length of <code>lambda</code> is different when <code>stratified = TRUE</code>, see &lsquo;Details&rsquo; for more information. Default is <code>lambda = 1</code>.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_l">L</code></td>
<td>
<p>the number of centers. This argument is used only when <code>stratified = TRUE</code>. Default is <code>L = 2</code>. See &lsquo;Details&rsquo; and &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_family">family</code></td>
<td>
<p>a description of the error distribution. This is a character string naming a family of the model. In the current version of the package, the family of model can be <code>"gaussian"</code> (with <code>identity</code> link function), <code>"binomial"</code> (with <code>logit</code> link function), or <code>"survival"</code>. Can be abbreviated. By default the <code>gaussian</code> family is used. In case of a linear regression model, <code>family = "gaussian"</code>, there is an extra model parameter for the variance of measurement error. While in the case of survival model, <code>family = "survival"</code>, the number of the model parameters depend on the choice of baseline hazard functions, see &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_intercept">intercept</code></td>
<td>
<p>logical flag for having an intercept. It does not used when <code>family = "survival"</code>. By changing the <code>intercept</code> the dimension of the inverse covariance matrix changes. If <code>intercept = TRUE</code> (the default), the output matrix created by <code>inv.prior.cov()</code> has one row and one column related to <code>intercept</code>, while if <code>intercept = FALSE</code>, the resulting matrix does not have the row and column called <code>intercept</code>.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_stratified">stratified</code></td>
<td>
<p>logical flag for performing the stratified analysis. If <code>stratified = TRUE</code>, the parameter(s) selected in the <code>strat_par</code> argument are allowed to be different across centers. This argument should only be used when designing the inverse covariance matrix for the (fictive) combined data, i.e., the last matrix for the <code>Lambda</code> argument in <code>bfi()</code>. If <code>inv.prior.cov()</code> is used for the analysis in the local centers (to built the <code class="reqn">L</code> first matrices for the <code>Lambda</code> argument in <code>bfi()</code>), this argument should be <code>FALSE</code>, even if the BFI analysis is stratified. It does not used when <code>family = "survival"</code>. Default is <code>stratified = FALSE</code>. See &lsquo;Details&rsquo; and &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_strat_par">strat_par</code></td>
<td>
<p>a one- or two-element integer vector for indicating the stratification parameter(s). The values <code class="reqn">1</code> and/or <code class="reqn">2</code> are/is used to indicate that the &ldquo;intercept&rdquo; and/or &ldquo;sigma2&rdquo; are allowed to vary, respectively. This argument is used only when <code>stratified = TRUE</code>. Default is <code>strat_par = NULL</code>, but if <code>stratified = TRUE</code>, <code>strat_par</code> can not be <code>NULL</code>. For the <code>binomial</code> family the length of the vector should be one which refers to &ldquo;intercept&rdquo;, and the value of this element should be <code class="reqn">1</code>. For <code>gaussian</code> this vector can be <code class="reqn">1</code> for indicating the &ldquo;intercept&rdquo; only, <code class="reqn">2</code> for indicating the &ldquo;sigma2&rdquo; only, and c(<code class="reqn">1</code>, <code class="reqn">2</code>) for both &ldquo;intercept&rdquo; and &ldquo;sigma2&rdquo;. See &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_center_spec">center_spec</code></td>
<td>
<p>a vector of <code class="reqn">L</code> elements for representing the center specific variable. This argument is used only when <code>stratified = TRUE</code> and <code>strat_par = NULL</code>. Each element represents a specific feature of the corresponding center. There must be only one specific value or attribute for each center. This vector could be a numeric, characteristic or factor vector. Note that, the order of the centers in the vector <code>center_spec</code> must be the same as in the list of the argument <code>theta_hats</code> in the function <code>bfi()</code>.
The used data type in the argument <code>center_spec</code> must be categorical. Default is <code>center_spec = NULL</code>. See also &lsquo;Details&rsquo; and &lsquo;Examples&rsquo;.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_basehaz">basehaz</code></td>
<td>
<p>a character string representing one of the available baseline hazard functions; <code>exponential</code> (<code>"exp"</code>), <code>Weibull</code> (<code>"weibul"</code>, the default), <code>Gompertz</code> (<code>"gomp"</code>), <code>exponentiated polynomial</code> (<code>"poly"</code>), and <code>piecewise constant exponential</code> (<code>"pwexp"</code>). Can be abbreviated. It is only used when <code>family = "survival"</code>.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_max_order">max_order</code></td>
<td>
<p>an integer representing the maximum value of <code>q_l</code>, which is the order/degree minus 1 of the exponentiated polynomial baseline hazard function. This argument is only used when <code>family = "survival"</code> and <code>basehaz = "poly"</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="inv.prior.cov_+3A_n_intervals">n_intervals</code></td>
<td>
<p>an integer representing the number of intervals in the piecewise exponential baseline hazard function. This argument is only used when <code>family = "survival"</code> and <code>basehaz = "pwexp"</code>. Default is 4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inv.prior.cov</code> creates a diagonal matrix with the vector <code>lambda</code> as its diagonal. The argument <code>stratified = TRUE</code> should only be used to construct a matrix for the prior density in case of stratification in the fictive combined data. Never be used for the construction of the matrix for analysis in the centers.
</p>
<p>When <code>stratified = FALSE</code>, the length of the vector <code>lambda</code> depends on the covariate matrix <code>X</code>, <code>family</code>, <code>basehaz</code>, and whether an &ldquo;intercept&rdquo; is included in the model. For example, if the design matrix <code>X</code> has <code>p</code> columns with continuous or dichotomous covariates, <code>family = gaussian</code>, and <code>intercept = TRUE</code>, then <code>lambda</code> should have <code class="reqn">p+2</code> elements. In this case, if in <code>X</code> there is a categorical covariate with <code class="reqn">q&gt;2</code> categories, then the length of <code>lambda</code> increases with <code class="reqn">q-2</code>.
</p>
<p>All values of <code>lambda</code> should be non-negative as they represent the inverse of the variance of the Gaussian prior. This argument is considered as the inverse of the variance of the prior distribution for: <code class="reqn">(\beta_0, \boldsymbol{\beta})</code> if <code>family = "binomial"</code> and <code>intercept = TRUE</code>; <code class="reqn">(\beta_0, \boldsymbol{\beta},\sigma^2)</code> if <code>family = "gaussian"</code> and <code>intercept = TRUE</code>; and <code class="reqn">( \boldsymbol{\beta},\boldsymbol{\omega})</code> if <code>family = "survival"</code>.
</p>
<p>If all values in the vector <code>lambda</code> equal, one value is enough to be given as entry.
If <code>lambda</code> is a scalar, the function <code>inv.prior.cov</code> sets each value at the diagonal equal to <code>lambda</code>.
When <code>lambda</code> is two dimensional: if <code>family = "binomial"</code>, the first and second values are used for the inverse of the variance of the prior distribution for the intercept (<code class="reqn">\beta_0</code>) and regression parameters (<code class="reqn">\boldsymbol{\beta}</code>), respectively;
If <code>family = "gaussian"</code>, the first and second values are used for the inverse of the variance of the prior distribution for the regression parameters including the intercept (<code class="reqn">\beta_0, \boldsymbol{\beta}</code>) and variance of the measurement error (<code class="reqn"> \sigma^2</code>), respectively;
If <code>family = "survival"</code>, the first and second values are used for the inverse of the variance of the prior distribution for the regression parameters (<code class="reqn">\boldsymbol{\beta}</code>) and baseline hazard parameters (<code class="reqn"> \omega</code>), respectively.
</p>
<p>If <code>stratified = TRUE</code> the length of the vector <code>lambda</code> should be equal to the number of parameters in the combined model.
</p>
<p>If <code>intercept = FALSE</code>, for the <code>binomial</code> family the stratified analysis is not possible therefore <code>stratified</code> can not be <code>TRUE</code>.
</p>
<p>If <code>stratified = FALSE</code>, both <code>strat_par</code> and <code>center_spec</code> must be <code>NULL</code> (the defaults), while if <code>stratified = TRUE</code> only one of the two must be <code>NULL</code>.
</p>
<p>The output of <code>inv.prior.cov()</code> can be used in the main functions <code>MAP.estimation()</code> and <code>bfi()</code>.
</p>


<h3>Value</h3>

<p><code>inv.prior.cov</code> returns a diagonal matrix. The dimension of the matrix depends on the number of columns of <code>X</code>, type of the covariates (continuous/dichotomous or categorical), <code>intercept</code>, <code>family</code>, and <code>basehaz</code>.
</p>


<h3>Author(s)</h3>

<p>Hassan Pazira and Marianne Jonker <br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>References</h3>

<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024). <em>Bayesian federated inference for estimating statistical models based on non-shared multicenter data sets</em>, <em>Statistics in Medicine</em>, 43(12): 2421-2438. &lt;https://doi.org/10.1002/sim.10072&gt;
</p>
<p>Pazira H., Massa E., Weijers J.A.M., Coolen A.C.C. and Jonker M.A. (2024). <em>Bayesian Federated Inference for Survival Models</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2404.17464&gt;
</p>
<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024b). <em>Bayesian Federated Inference for regression models with heterogeneous multi-center populations</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2402.02898&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAP.estimation">MAP.estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------
# Data Simulation
#----------------
X &lt;- data.frame(x1=rnorm(50),                     # standard normal variable
                x2=sample(0:2, 50, replace=TRUE), # categorical variable
                x3=sample(0:1, 50, replace=TRUE)) # dichotomous variable
X$x2 &lt;- as.factor(X$x2)
X$x3 &lt;- as.factor(X$x3)

# The (inverse) variance value (lambda=0.05) is assumed to be
# the same for Gaussian prior of all parameters (for non-stratified)

#-------------------------------------------------
# Inverse Covariance Matrix for the Gaussian prior
#-------------------------------------------------
# y ~ Binomial with 'intercept'
inv.prior.cov(X, lambda = 0.05, family = 'binomial')
# returns a 5-by-5 matrix

# y ~ Binomial without 'intercept'
inv.prior.cov(X, lambda = 0.05, family = "binomial", intercept = FALSE)
# a 4-by-4 matrix

# y ~ Gaussian with 'intercept'
inv.prior.cov(X, lambda = 0.05, family = 'gaussian')
# returns a 6-by-6 matrix

# Survival family with 'weibul' baseline hazard
inv.prior.cov(X, lambda = c(0.05, 0.1), family = 'survival')
# returns a 6-by-6 matrix

# Survival family with 'pwexp' baseline hazard (4 intervals)
inv.prior.cov(X, lambda = 0.05, family = 'survival', basehaz = "pwexp")
# returns a 8-by-8 matrix

# Survival family with 'poly' baseline hazard
inv.prior.cov(X, lambda = c(0.05, 0.1), family = 'survival', basehaz = "poly")
# returns a 7-by-7 matrix

#--------------------
# Stratified analysis
#--------------------
# y ~ Binomial when 'intercept' varies across 3 centers:
inv.prior.cov(X, lambda = c(.2, 1), family = 'binomial', stratified = TRUE,
              strat_par = 1, L = 3)

# y ~ Gaussian when 'intercept' and 'sigma2' vary across 2 centers; y ~ Gaussian
inv.prior.cov(X, lambda = c(1, 2, 3), family = "gaussian", stratified = TRUE,
              strat_par = c(1, 2))

# y ~ Gaussian when 'sigma2' varies across 2 centers (with 'intercept')
inv.prior.cov(X, lambda = c(1, 2, 3), family='gaussian', stratified = TRUE,
              strat_par = 2)

# y ~ Gaussian when 'sigma2' varies across 2 centers (without 'intercept')
inv.prior.cov(X, lambda = c(2, 3), family = "gaussian", intercept = FALSE,
              stratified=TRUE, strat_par = 2)

#--------------------------
# Center specific covariate
#--------------------------
# center specific covariate has K = 2 categories across 4 centers; y ~ Binomial
inv.prior.cov(X, lambda = c(0.1:2), family = 'binomial', stratified = TRUE,
              center_spec = c("Iran","Netherlands","Netherlands","Iran"), L=4)

# center specific covariate has K = 3 categories across 5 centers; y ~ Gaussian
inv.prior.cov(X, lambda = c(0.5:3), family = 'gaussian', stratified = TRUE,
              center_spec = c("Medium","Big","Small","Big","Small"), L = 5)

# center specific covariate has K = 4 categories across 5 centers; y ~ Gaussian
inv.prior.cov(X, lambda = 1, family = 'gaussian', stratified = TRUE,
              center_spec = c(3,1:4), L=5)

</code></pre>

<hr>
<h2 id='MAP.estimation'>Maximum A Posteriori estimation</h2><span id='topic+MAP.estimation'></span>

<h3>Description</h3>

<p><code>MAP.estimation</code> function is used (in local centers) to compute Maximum A Posterior (MAP) estimators of the parameters for Generalized Linear Models (GLM) and Survival models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAP.estimation(y,
               X,
               family = c("gaussian", "binomial", "survival"),
               Lambda,
               intercept = TRUE,
               initial = NULL,
               basehaz = c("weibul", "exp", "gomp", "poly", "pwexp"),
               alpha = 0.1,
               max_order = 2,
               n_intervals = 4,
               min_max_times,
               center_zero_sample = FALSE,
               zero_sample_cov,
               refer_cat,
               zero_cat,
               control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAP.estimation_+3A_y">y</code></td>
<td>
<p>response vector. If the &ldquo;<code>binomial</code>&rdquo; family is used, this argument is a vector with entries 0 (failure) or 1 (success). Alternatively, for this family, the response can be a matrix where the first column is the number of &ldquo;successes&rdquo; and the second column is the number of &ldquo;failures&rdquo;. For the &ldquo;<code>survival</code>&rdquo; family, the response is a matrix where the first column is the survival time, named &ldquo;time&rdquo;, and the second column is the censoring indicator, named &ldquo;status&rdquo;, with 0 indicating censoring time and 1 indicating event time.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_x">X</code></td>
<td>
<p>design matrix of dimension <code class="reqn">n \times p</code>, where <code class="reqn">p</code> is the number of covariates or predictors. Note that the order of the covariates must be the same across the centers; otherwise, the output estimates of bfi() will be incorrect.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_family">family</code></td>
<td>
<p>a description of the error distribution. This is a character string naming a family of the model. In the current version of the package, the family of model can be <code>"gaussian"</code> (with <code>identity</code> link function), <code>"binomial"</code> (with <code>logit</code> link function), or <code>"survival"</code>. Can be abbreviated. By default the <code>gaussian</code> family is used. In case of a linear regression model, <code>family = "gaussian"</code>, there is an extra model parameter for the variance of measurement error. While in the case of survival model, <code>family = "survival"</code>, the number of the model parameters depend on the choice of baseline hazard functions, see &lsquo;Details&rsquo; for more information.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_lambda">Lambda</code></td>
<td>
<p>the inverse variance-covariance matrix of the Gaussian distribution that is used as prior distribution for the model parameters. The dimension of the matrix depends on the number of columns of <code>X</code>, type of the covariates (continuous / dichotomous or categorical), <code>family</code>, and whether an <code>intercept</code> is included (if applicable). However, <code>Lambda</code> can be easily created by <code>inv.prior.cov()</code>. See <code><a href="#topic+inv.prior.cov">inv.prior.cov</a></code> for more information.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_intercept">intercept</code></td>
<td>
<p>logical flag for fitting an intercept. If <code>intercept=TRUE</code> (the default), the intercept is fitted, i.e., it is included in the model, and if <code>intercept=FALSE</code> it is set to zero, i.e., it's not in the model. This argument is not used if <code>family = "survival"</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_initial">initial</code></td>
<td>
<p>a vector specifying initial values for the parameters to be optimized over. The length of <code>initial</code> is equal to the number of model parameters and thus, is equal to the number of rows or columns of <code>Lambda</code>. Since the <code>'L-BFGS-B'</code> method is used in the algorithm, these values should always be finite. Default is a vector of zeros, except for the <code>survival</code> family with the <code>poly</code> function, where it is a vector with the first <code class="reqn">p</code> elements as zeros for coefficients (<code class="reqn">\boldsymbol{\beta}</code>) and -0.5 for the remaining parameters (<code class="reqn">\boldsymbol{\omega}</code>). For the <code>gaussian</code> family, the last element of the <code>initial</code> vector could also be considered negative, because the Gaussian prior was applied to <code class="reqn">log(\sigma^2)</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_basehaz">basehaz</code></td>
<td>
<p>a character string representing one of the available baseline hazard functions; <code>exponential</code> (<code>"exp"</code>), <code>Weibull</code> (<code>"weibul"</code>, the default), <code>Gompertz</code> (<code>"gomp"</code>), <code>exponentiated polynomial</code> (<code>"poly"</code>), and <code>piecewise constant exponential</code> (<code>"pwexp"</code>). Can be abbreviated. It is only used when <code>family = "survival"</code>. If local sample size is large and the shape of the baseline hazard function is completely unknown, the &ldquo;exponentiated polynomial&rdquo; and &ldquo;piecewise exponential&rdquo; hazard functions would be preferred above the lower dimensional alternatives. However, if the local samples size is low, one should be careful using the &ldquo;piecewise exponential&rdquo; hazard function with many intervals.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_alpha">alpha</code></td>
<td>
<p>a significance level used in the chi-squared distribution (with one degree of freedom and 1-<code class="reqn">\alpha</code> representing the upper quantile) to conduct a likelihood ratio test for obtaining the order of the exponentiated polynomial baseline hazard function. It is only used when <code>family = "survival"</code> and <code>basehaz = "poly"</code>. Default is 0.1. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_max_order">max_order</code></td>
<td>
<p>an integer representing the maximum value of <code>q_l</code>, which is the order/degree minus 1 of the exponentiated polynomial baseline hazard function. This argument is only used when <code>family = "survival"</code> and <code>basehaz = "poly"</code>. Default is 2.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_n_intervals">n_intervals</code></td>
<td>
<p>an integer representing the number of intervals in the piecewise exponential baseline hazard function. This argument is only used when <code>family = "survival"</code> and <code>basehaz = "pwexp"</code>. Default is 4.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_min_max_times">min_max_times</code></td>
<td>
<p>a scalar representing the minimum of the maximum event times observed in the centers. The value of this argument should be defined by the central server (which has access to the maximum event times of all the centers) and is only used when <code>family = "survival"</code> and <code>basehaz = "pwexp"</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_center_zero_sample">center_zero_sample</code></td>
<td>
<p>logical flag indicating whether the center has a categorical covariate with no observations/individuals in one of the categories. Default is <code>center_zero_sample = FALSE</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_zero_sample_cov">zero_sample_cov</code></td>
<td>
<p>either a character string or an integer representing the categorical covariate that has no samples/observations in one of its categories. This covariate should have at least two categories, one of which is the reference. It is used when <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_refer_cat">refer_cat</code></td>
<td>
<p>a character string representing the reference category. The category with no observations (the argument <code>zero_cat</code>) cannot be used as the reference in the argument <code>refer_cat</code>. It is used when <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_zero_cat">zero_cat</code></td>
<td>
<p>a character string representing the category with no samples/observations. It is used when <code>center_zero_sample = TRUE</code>.</p>
</td></tr>
<tr><td><code id="MAP.estimation_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MAP.estimation</code> function finds the Maximum A Posteriori (MAP) estimates of the model parameters by maximizing the log-posterior density with respect to the parameters, i.e., the estimates equal the values for which the log-posterior density is maximal (the posterior mode).
In other words, <code>MAP.estimation()</code> optimizes the log-posterior density with respect to the parameter vector to obtain its MAP estimates.
In addition to the model parameters (i.e., coefficients (<code class="reqn">\boldsymbol{\beta}</code>) and variance error (<code class="reqn">\sigma^2_e</code>) for <code>gaussian</code> or the parameters of the baseline hazard (<code class="reqn">\boldsymbol{\omega}</code>) for <code>survival</code>), the curvature matrix (Hessian of the log-posterior) is estimated around the mode.
</p>
<p>The <code>MAP.estimation</code> function returns an object of class '<code>bfi</code>'. Therefore, <code>summary()</code> can be used for the object returned by <code>MAP.estimation()</code>.
</p>
<p>For the case where <code>family = "survival"</code> and <code>basehaz = "poly"</code>, we assume that in all centers the <code class="reqn">q_\ell</code>'s are equal.
However, the order of the estimated polynomials may vary across the centers so that each center can have different number of parameters, say <code class="reqn">q_\ell</code>+1.
After obtaining the estimates within the local centers (by using <code>MAP.estimation()</code>) and having all estimates in the central server, we choose the order of the polynomial approximation for the combined data to be the maximum of the orders of the local polynomial functions, i.e., <code class="reqn">\max \{q_1, \ldots, q_L \}</code>, to approximate the global baseline hazard (exponentiated polynomial) function more accurately. This is because the higher-order polynomial approximation can capture more complex features and details in the combined data. Using the higher-order approximation ensures that we account for the higher-order moments and features present in the data while maintaining accuracy.
As a result, all potential cases are stored in the <code>theta_A_poly</code> argument to be used in <code>bfi()</code> by the central server.
For further information on the <code>survival</code> family, refer to the 'References' section.
</p>
<p>To solve unconstrained and bound-constrained optimization problems, the <code>MAP.estimation</code> function utilizes an optimization algorithm called Limited-memory Broyden-Fletcher-Goldfarb-Shanno with Bound Constraints (L-BFGS-B), Byrd et. al. (1995).
The L-BFGS-B algorithm is a limited-memory &ldquo;quasi-Newton&rdquo; method that iteratively updates the parameter estimates by approximating the inverse Hessian matrix using gradient information from the history of previous iterations. This approach allows the algorithm to approximate the curvature of the posterior distribution and efficiently search for the optimal solution, which makes it computationally efficient for problems with a large number of variables.
</p>
<p>By default, the algorithm uses a relative change in the objective function as the convergence criterion. When the change in the objective function between iterations falls below a certain threshold ('<code>factr</code>') the algorithm is considered to have converged.
The convergence can be checked with the argument <code>convergence</code> in the output. See &lsquo;Value&rsquo;.
</p>
<p>In case of convergence issue, it may be necessary to investigate and adjust optimization parameters to facilitate convergence. It can be done using the <code>initial</code> and <code>control</code> arguments. By the argument <code>initial</code> the initial points of the interative optimization algorithm can be changed, and the argument <code>control</code> is a list that can supply any of the following components:
</p>

<dl>
<dt><code>maxit</code>:</dt><dd><p>is the maximum number of iterations. Default is 150;</p>
</dd>
<dt><code>factr</code>:</dt><dd><p>controls the convergence of the <code>'L-BFGS-B'</code> method. Convergence occurs when the reduction in the objective is within this factor of the machine tolerance. Default for <code>factr</code> is 1e7, which gives a tolerance of about 1e-9. The exact tolerance can be checked by multiplying this value by <code>.Machine$double.eps</code>;</p>
</dd>
<dt><code>pgtol</code>:</dt><dd><p>helps to control the convergence of the <code>'L-BFGS-B'</code> method. It is a tolerance on the projected gradient in the current search direction, i.e., the iteration will stop when the maximum component of the projected gradient is less than or equal to <code>pgtol</code>, where <code>pgtol</code><code class="reqn">\geq 0</code>. Default is zero, when the check is suppressed;</p>
</dd>
<dt><code>trace</code>:</dt><dd><p>is a non-negative integer. If positive, tracing information on the progress of the optimization is produced. Higher values may produce more tracing information: for the method <code>'L-BFGS-B'</code> there are six levels of tracing. To understand exactly what these do see the source code of <code>optim</code> function in the <span class="pkg"><a href="stats.html#topic+stats">stats</a></span> package;</p>
</dd>
<dt><code>REPORT</code>:</dt><dd><p>is the frequency of reports for the <code>'L-BFGS-B'</code> method if <code>'control$trace'</code> is positive. Default is every 10 iterations;</p>
</dd>
<dt><code>lmm</code>:</dt><dd><p>is an integer giving the number of <code>BFGS</code> updates retained in the <code>'L-BFGS-B'</code> method. Default is 5.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>MAP.estimation</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>theta_hat</code></td>
<td>
<p>the vector corresponding to the maximum a posteriori (MAP) estimates of the parameters. For the <code>gaussian</code> family, the last element of this vector is <code class="reqn">\sigma^2</code>;</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>minus the curvature (or Hessian) matrix around the point <code>theta_hat</code>. The dimension of the matrix is the same as the argument <code>Lambda</code>;</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the vector of standard deviation of the MAP estimates in <code>theta_hat</code>, that is <code>sqrt(diag(solve(A_hat)))</code>;</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>the inverse variance-covariance matrix of the Gaussian distribution that is used as prior distribution for the parameters. It's exactly the same as the argument <code>Lambda</code>;</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula applied;</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>the names of the model parameters;</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>sample size;</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>the number of coefficients;</p>
</td></tr>
<tr><td><code>q_l</code></td>
<td>
<p>the order/degree minus 1 of the exponentiated polynomial baseline hazard function determined for the current center by the likelihood ratio test. This output argument, <code>q_l</code>, is only shown when <code>family = "survival"</code> and <code>basehaz = "poly"</code>, and will be used in the function <code>bfi()</code>;</p>
</td></tr>
<tr><td><code>theta_A_poly</code></td>
<td>
<p>an array where the first component is a matrix with columns representing the MAP estimates of the parameters for different <code>q_l</code>'s, i.e., <code>q_l</code>, <code>q_l</code>+1, ..., <code>max_order</code>. The other components are minus the curvature matrices for different <code>q_l</code>'s, i.e., <code>q_l</code>, <code>q_l</code>+1, ..., <code>max_order</code>. Therefore, the first non-NA curvature matrix is equal to the output argument <code>A_hat</code>. This output argument, <code>theta_A_poly</code>, is only shown if <code>family = "survival"</code> and <code>basehaz = "poly"</code>, and will be used in the function <code>bfi()</code>;</p>
</td></tr>
<tr><td><code>lev_no_ref_zer</code></td>
<td>
<p>a vector containing the names of the levels of the categorical covariate that has no samples/observations in one of its categories. The name of the category with no samples and the name of the reference category are excluded from this vector. This argument is shown when <code>family = "survival"</code> and <code>basehaz = "poly"</code>, and will be used in the function <code>bfi()</code>;</p>
</td></tr>
<tr><td><code>zero_sample_cov</code></td>
<td>
<p>the categorical covariate that has no samples/observations in one of its categories. It is shown when <code>center_zero_sample = TRUE</code>, and can be used in the function <code>bfi()</code>;</p>
</td></tr>
<tr><td><code>refer_cat</code></td>
<td>
<p>the reference category. It is shown when <code>center_zero_sample = TRUE</code>, and can be used in the function <code>bfi()</code>;</p>
</td></tr>
<tr><td><code>zero_cat</code></td>
<td>
<p>the category with no samples/observations. It is shown when <code>center_zero_sample = TRUE</code>, and can be used in the function <code>bfi()</code>;</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of minus the log-likelihood posterior density evaluated at <code>theta_hat</code>;</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code>family</code> used;</p>
</td></tr>
<tr><td><code>basehaz</code></td>
<td>
<p>the baseline hazard function used;</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>logical flag used to fit an intercept if <code>TRUE</code>, or set to zero if <code>FALSE</code>;</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>an integer value used to encode the warnings and the errors related to the algorithm used to fit the model. The values returned are:
</p>

<dl>
<dt>0</dt><dd><p>algorithm has converged;</p>
</dd>
<dt>1</dt><dd><p>maximum number of iterations ('<code>maxit</code>') has been reached;</p>
</dd>
<dt>2</dt><dd><p>Warning from the 'L-BFGS-B' method. See the message after this value;</p>
</dd>
</dl>

</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the list of control parameters used to compute the MAP estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hassan Pazira and Marianne Jonker <br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>References</h3>

<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024). <em>Bayesian federated inference for estimating statistical models based on non-shared multicenter data sets</em>, <em>Statistics in Medicine</em>, 43(12): 2421-2438. &lt;https://doi.org/10.1002/sim.10072&gt;
</p>
<p>Pazira H., Massa E., Weijers J.A.M., Coolen A.C.C. and Jonker M.A. (2024). <em>Bayesian Federated Inference for Survival Models</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2404.17464&gt;
</p>
<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024b). <em>Bayesian Federated Inference for regression models with heterogeneous multi-center populations</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2402.02898&gt;
</p>
<p>Byrd R.H., Lu P., Nocedal J. and Zhu C. (1995). <em>A limited memory algorithm for bound constrained optimization</em>. SIAM Journal on Scientific Computing, 16, 1190-1208. &lt;https://doi.org/10.1137/0916069&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfi">bfi</a></code>, <code><a href="#topic+inv.prior.cov">inv.prior.cov</a></code> and <code><a href="#topic+summary.bfi">summary.bfi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###--------------###
### y ~ Gaussian ###
###--------------###

# Setting a seed for reproducibility
set.seed(11235)

# model parameters: coefficients and sigma2 = 1.5
theta &lt;- c(1, 2, 2, 2, 1.5)

#----------------
# Data Simulation
#----------------
n   &lt;- 30   # sample size
p   &lt;- 3    # number of coefficients without intercept
X   &lt;- data.frame(matrix(rnorm(n * p), n, p)) # continuous variables
# linear predictor:
eta &lt;- theta[1] + theta[2] * X$X1 + theta[3] * X$X2 + theta[4] * X$X3
# inverse of the link function ( g^{-1}(\eta) = \mu ):
mu  &lt;- gaussian()$linkinv(eta)
y   &lt;- rnorm(n, mu, sd = sqrt(theta[5]))

# Load the BFI package
library(BFI)

#-----------------------------------------------
# MAP estimations for theta and curvature matrix
#-----------------------------------------------
# MAP estimates with 'intercept'
Lambda &lt;- inv.prior.cov(X, lambda = c(0.1, 1), family = "gaussian")
(fit &lt;- MAP.estimation(y, X, family = "gaussian", Lambda))
class(fit)
summary(fit, cur_mat = TRUE)

# MAP estimates without 'intercept'
Lambda &lt;- inv.prior.cov(X, lambda = c(0.1, 1), family = 'gaussian', intercept = FALSE)
(fit1 &lt;- MAP.estimation(y, X, family = 'gaussian', Lambda, intercept = FALSE))
summary(fit1, cur_mat = TRUE)


###-----------------###
### Survival family ###
###-----------------###

# Setting a seed for reproducibility
set.seed(112358)

#-------------------------
# Simulating Survival data
#-------------------------
n    &lt;- 40
beta &lt;- 1:4
p    &lt;- length(beta)
X    &lt;- data.frame(matrix(rnorm(n * p), n, p)) # continuous (normal) variables

## Simulating survival data from Weibull with a predefined censoring rate of 0.3
y &lt;- surv.simulate(Z = list(X), beta = beta, a = 5, b = exp(1.8), u1 = 0.1,
                   cen_rate = 0.3, gen_data_from = "weibul")$D[[1]][, 1:2]

##
## MAP estimations with "weibul" function
##
Lambda &lt;- inv.prior.cov(X, lambda = c(0.1, 1), family = 'survival', basehaz = "weibul")
fit2 &lt;- MAP.estimation(y, X, family = 'survival', Lambda = Lambda, basehaz = "weibul")
fit2
fit2$theta_hat

##
## MAP estimations with "poly" function
##
Lambda &lt;- inv.prior.cov(X, lambda = c(0.1, 1), family = 'survival', basehaz = 'poly')
fit3 &lt;- MAP.estimation(y, X, family = "survival", Lambda = Lambda, basehaz = "poly")
# Degree of the exponentiated polynomial baseline hazard
fit3$q_l + 1
# theta_hat for (beta_1, ..., beta_p, omega_0, ..., omega_{q_l})
fit3$theta_A_poly[,,1][,fit3$q_l+1] # equal to fit3$theta_hat
# A_hat
fit3$theta_A_poly[,,fit3$q_l+2] # equal to fit3$A_hat
summary(fit3, cur_mat = TRUE)

##
## MAP estimations with "pwexp" function with 3 intervals
##
# Assume we have 4 centers
Lambda &lt;- inv.prior.cov(X, lambda = c(0.1, 1), family = 'survival',
                        basehaz = 'pwexp', n_intervals = 3)
# For this baseline hazard ("pwexp"), we need to know
# maximum survival times of the 3 other centers:
max_times &lt;- c(max(rexp(30)), max(rexp(50)), max(rexp(70)))
# Minimum of the maximum values of the survival times of all 4 centers is:
min_max_times &lt;- min(max(y$time), max_times)
fit4 &lt;- MAP.estimation(y, X, family = "survival", Lambda = Lambda, basehaz = "pwexp",
                       n_intervals = 3, min_max_times=max(y$time))
summary(fit4, cur_mat = TRUE)

</code></pre>

<hr>
<h2 id='n.par'>The Number of Predictors, Coefficients, and Observations</h2><span id='topic+n.par'></span>

<h3>Description</h3>

<p><code>n.par</code> returns the number of regression parameters, covariates and observations present in X based on the selected family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.par(X, family = c("gaussian", "binomial", "survival"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.par_+3A_x">X</code></td>
<td>
<p>design matrix of dimension <code class="reqn">n \times p</code>, where <code class="reqn">n</code> is the number of samples observed, and <code class="reqn">p</code> is the number of predictors/covariables. It could be a matrix or a list of matrices.</p>
</td></tr>
<tr><td><code id="n.par_+3A_family">family</code></td>
<td>
<p>a description of the error distribution used to specify the model. This should be a character string, either &ldquo;<code>gaussian</code>&rdquo;, &ldquo;<code>binomial</code>&rdquo;, or &ldquo;<code>survival</code>&rdquo;. Can be abbreviated. By default the <code>gaussian</code> family is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>orig.names</code> and <code>covar.names</code> are the same if the all covariates in <code>X</code> are continuous. However, if there are at least one categorical variable in <code>X</code> with more than two categories, they are different.
</p>


<h3>Value</h3>

<p><code>n.par</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>n.reg.par</code></td>
<td>
<p>the number of regression parameters;</p>
</td></tr>
<tr><td><code>n.covar</code></td>
<td>
<p>the number of covariates;</p>
</td></tr>
<tr><td><code>n.sample</code></td>
<td>
<p>the number of samples/observations;</p>
</td></tr>
<tr><td><code>orig.names</code></td>
<td>
<p>the original names of the variables (without including the names of dummy variables);</p>
</td></tr>
<tr><td><code>covar.names</code></td>
<td>
<p>the names of the variables (together with the names of any dummy variables, if applicable).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hassan Pazira<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--------------------
# family = "gaussian"
#--------------------

X0 &lt;- data.frame(x1 = rnorm(50),                     # standard normal variable
                 x2 = sample(0:2, 50, replace=TRUE), # categorical variable
                 x3 = sample(0:1, 50, replace=TRUE)) # dichotomous variable
n.par(X0) # without dummy variables
X0$x2 &lt;- as.factor(X0$x2)
X0$x3 &lt;- as.factor(X0$x3)
n.par(X0)  # with dummy variables

X1 &lt;- data.frame(Intercept = rep(1,30),
                 x1 = rnorm(30),                     # continuous variable
                 x2 = sample(0:2, 30, replace=TRUE)) # categorical variable
n.par(X1) # without dummy variables
X1$x2  &lt;- as.factor(X1$x2)
n.par(X1) # without dummy variables

# a list of two data sets:
X01 &lt;- list(X0, X1)
n.par(X01)

</code></pre>

<hr>
<h2 id='Nurses'>
Nurses' stress in different hospitals
</h2><span id='topic+Nurses'></span>

<h3>Description</h3>

<p>This dataset comprises three-level simulated data extracted for a hypothetical study investigating stress levels within hospital settings.
The dataset focuses on nurses working in specific wards within various hospitals.
It includes several variables, such as nurse age (measured in years), nurse experience (measured in years), nurse gender (<code>0</code> for <code>male</code>, <code>1</code> for <code>female</code>), ward type (<code>0</code> for <code>general care</code>, <code>1</code> for <code>special care</code>), and hospital size (<code>0</code> for <code>small</code>, <code>1</code> for <code>medium</code>, <code>2</code> for <code>large</code>).
The dataset in the package is obtained from the original dataset by leaving out some of the unused columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Nurses)</code></pre>


<h3>Source</h3>

<p>https://multilevel-analysis.sites.uu.nl/datasets/</p>


<h3>References</h3>

<p>Hox, J., Moerbeek, M., and van de Schoot, R. (2010). <em>Multilevel Analysis: Techniques and Applications</em>, Second Edition (2nd ed.). <em>Routledge</em>. &lt;https://doi.org/10.4324/9780203852279&gt;
</p>

<hr>
<h2 id='summary.bfi'>Summarizing BFI Fits</h2><span id='topic+summary'></span><span id='topic+summary.bfi'></span>

<h3>Description</h3>

<p>Summary method for an object with class 'bfi' created by the <code>MAP.estimation</code> and <code>bfi</code> functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bfi'
summary(object,
        cur_mat = FALSE,
        digits = max(3, getOption("digits") - 3),
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bfi_+3A_object">object</code></td>
<td>
<p>fitted <code>bfi</code> object.</p>
</td></tr>
<tr><td><code id="summary.bfi_+3A_cur_mat">cur_mat</code></td>
<td>
<p>logical; if <code>TRUE</code>, minus the curvature matrix around the estimated parameters is returned and printed. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.bfi_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout.</p>
</td></tr>
<tr><td><code id="summary.bfi_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.bfi()</code> gives information about the MAP estimates of parameters of the model. It can be used for the <code>bfi</code> objects built by the <code>MAP.estimation</code> and <code>bfi</code> functions.
</p>
<p>The output of the summary method shows the details of the model, i.e. formula, family and link function used to specify the generalized linear model, followed by information about the estimates, standard deviations and credible intervals.
Information about the log-likelihood posterior and convergence status are also provided.
</p>
<p>By default, <code>summary.bfi</code> function does not return (minus) the curvature matrix, but the user can use <code>cur_mat = TRUE</code> to print it.
</p>


<h3>Value</h3>

<p><code>summary.bfi</code> returns an object of class <code>summary.bfi</code>, a list with the following components:
</p>
<table>
<tr><td><code>theta_hat</code></td>
<td>
<p>the component from <code>object</code>. The last element of this vector is the estimate of the dispersion parameter (sigma2) if <code>family = "gaussian"</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> and <code><a href="#topic+bfi">bfi</a></code> functions.</p>
</td></tr>
<tr><td><code>A_hat</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> and <code><a href="#topic+bfi">bfi</a></code> functions.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the component from <code>object</code>. If <code>family = "gaussian"</code>, the last element of this vector is the square root of the estimated dispersion. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> and <code><a href="#topic+bfi">bfi</a></code> functions.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+MAP.estimation">MAP.estimation</a></code> function.</p>
</td></tr>
<tr><td><code>stratified</code></td>
<td>
<p>the component from <code>object</code>. See the <code><a href="#topic+bfi">bfi</a></code> function.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated regression coefficients, i.e., without the estimate <code>sigma2</code>.</p>
</td></tr>
<tr><td><code>logLikPost</code></td>
<td>
<p>the value of the log-likelihood posterior density evaluated at estimates (<code>theta_hat</code>).</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function only for GLMs, not for the survival family. By default the <code>gaussian</code> family with <code>identity</code> link function and the <code>binomial</code> family with <code>logit</code> link function are used.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated variance of the random error, i.e., <code>sigma2</code>. The <code>dispersion</code> is taken as <code>1</code> for the <code>binomial</code> family.</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>a 95<code>%</code> credible interval of the MAP estimates of the parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hassan Pazira<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAP.estimation">MAP.estimation</a></code> and <code><a href="#topic+bfi">bfi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------
# y ~ Gaussian
#-------------
# model assumption:
theta &lt;- c(1, 2, 3, 4, 1.5)  # coefficients and sigma2 = 1.5

#----------------
# Data Simulation
#----------------
n      &lt;- 40
X      &lt;- data.frame(x1=rnorm(n),                     # continuous variable
                     x2=sample(1:3, n, replace=TRUE)) # categorical variable
Xx2_1  &lt;- ifelse(X$x2 == '2', 1, 0)
Xx2_2  &lt;- ifelse(X$x2 == '3', 1, 0)
X$x2   &lt;- as.factor(X$x2)
eta    &lt;- theta[1] + theta[2] * X$x1 + theta[3] * Xx2_1 + theta[4] * Xx2_2
mu     &lt;- gaussian()$linkinv(eta)
y      &lt;- rnorm(n, mu, sd = sqrt(theta[5]))

#----------------
# MAP estimations
#----------------
Lambda &lt;- inv.prior.cov(X, lambda = c(0.1, 0.5), family = "gaussian")
fit    &lt;- MAP.estimation(y, X, family = "gaussian", Lambda)
class(fit)

#-------------------------
# Summary of MAP estimates
#-------------------------
summary(fit)
sumfit &lt;- summary(fit, cur_mat = TRUE)
sumfit$estimate
sumfit$logLikPost
sumfit$dispersion
sumfit$CI
class(sumfit)

</code></pre>

<hr>
<h2 id='surv.simulate'>Generate survival data with predefined censoring rates for proportional hazards models</h2><span id='topic+surv.simulate'></span>

<h3>Description</h3>

<p><code>surv.simulate</code> simulates one or multiple (right-censored) survival datasets for proportional hazards models by simultaneously incorporating a baseline hazard function from three different survival distributions (exponential, Weibull and Gompertz), a random censoring time generated from a uniform distribution with an known/unknown upper limit, and a set of baseline covariates.
When the upper limit of the uniform censoring time distribution is unknown, <code>surv.simulate</code> can be used separately to obtain the upper limit with a predefined censoring rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.simulate(L = 1, Z, beta, a, b, u1 = 0, u2, cen_rate,
              gen_data_from = c("exp", "weibul", "gomp"),
              only_u2 = FALSE, n.rep = 100, Trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.simulate_+3A_l">L</code></td>
<td>
<p>the number of datasets to be generated. Default is <code>L = 1</code>.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_z">Z</code></td>
<td>
<p>a list of <code>L</code> design matrices of dimension <code class="reqn">n_\ell \times p</code>, where <code class="reqn">n_\ell</code> is the number of samples observed for the <code class="reqn">\ell^{\text{th}}</code> dataset and <code class="reqn">p</code> is the number of covariables. When <code>L = 1</code>, <code>Z</code> can be a matrix.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_beta">beta</code></td>
<td>
<p>the vector of the (true) coefficients values, with a length of <code class="reqn">p</code> (the number of covariates).</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_a">a</code></td>
<td>
<p>scale parameter, which should be non-negative. See &lsquo;Details&rsquo; for the form of the cumulative hazard that can be used.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_b">b</code></td>
<td>
<p>shape/location parameter, which should be non-negative. It is not used when <code>gen_data_from = </code>&ldquo;exp&rdquo;. See &lsquo;Details&rsquo; for the form of the cumulative hazard that can be used.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_u1">u1</code></td>
<td>
<p>a known non-negative lower limit of the uniform distribution for generating random censoring time. Default is <code>u1 = 0</code>. If <code>cen_rate</code> is not equal to 0, then <code>u1</code> does not need to be defined.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_u2">u2</code></td>
<td>
<p>an non-negative upper limit of the uniform random censoring time distribution. The upper limit can be unknown (<code>u2 = NULL</code>, the default), or predefined. When this argument is assumed to be unknown, <code>u2 = NULL</code>, it is calculated by the algorithm within <code>surv.simulate()</code>. However, if the argument <code>u2</code> is known, the censoring rate cannot be predefined (meaning there is no control over it) and is calculated based on the generated dataset. See &lsquo;Details&rsquo; and &lsquo;References&rsquo;.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_cen_rate">cen_rate</code></td>
<td>
<p>a value representing the proportion of observations in the simulated survival data that are censored. The range of this argument is from 0 to 1. When the upper limit is known, <code>cen_rate</code> can nor be predefined. If there is no censoring (<code>cen_rate = 0</code>), the lower (<code>u1</code>) and upper (<code>u2</code>) limits of the uniform distribution do not need to be specified.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_gen_data_from">gen_data_from</code></td>
<td>
<p>a description of the distribution from which the time to event is generated. This is a character string and can be <code>exponential</code> (&ldquo;exp&rdquo;), <code>Weibull</code> (&ldquo;weibul&rdquo;), or <code>Gompertz</code> (&ldquo;gomp&rdquo;). Can be abbreviated. By default, the <code>exponential</code> distribution is used.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_only_u2">only_u2</code></td>
<td>
<p>logical flag for calculating only the upper limit of the uniform censoring time distribution. If <code>only_u2 = TRUE</code>, the dataset(s) are not generated. If <code>only_u2 = TRUE</code>, the arguments <code>Z</code> and <code>u2</code> do not need to be specified, and <code>cen_rate</code> should not be set to <code class="reqn">0</code>. Default is <code>only_u2 = FALSE</code>.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_n.rep">n.rep</code></td>
<td>
<p>a scalar specifying the number of iterations. This argument is exclusively used in the case of the <code>Gompertz</code> distribution. Default is 100.</p>
</td></tr>
<tr><td><code id="surv.simulate_+3A_trace">Trace</code></td>
<td>
<p>logical flag indicating whether the output of the desired <code>u2</code> and the censoring proportion for different datasets should be produced for each iteration. It works <code>gen_data_from = </code>&ldquo;gomp&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>surv.simulate</code> function generates <code class="reqn">L</code> simulated right-censored survival datasets from exponential, Weibull, or Gompertz distributions, incorporating the covariates, <code>Z</code>, distributed according to a multivariate <code>normal</code> distribution, with censoring time generated from a uniform distribution <code>Uniform(u1, u2)</code>, where <code>u1</code> is known but <code>u2</code> can be either known or unknown.
</p>
<p><code>surv.simulate()</code> can also be used to calculate the unknown upper limit of the uniform distribution, <code>u2</code>, with a predefined censoring rate. To do this, set <code>u2 = NULL</code> and <code>only_u2 = TRUE</code>. In this case, the datasets are not generated; only <code>u2</code> is.
</p>
<p><code>surv.simulate()</code> uses a root-finding algorithm to select the censoring parameter that achieves predefined censoring rates in the simulated survival data.
</p>
<p>When <code>gen_data_from = </code>&ldquo;exp&rdquo;:
</p>

<ul>
<li><p> the cumulative baseline hazard function is considered as <code class="reqn">\Lambda_0=a t</code>,
</p>
</li>
<li><p> the event time for the <code class="reqn">\ell^{\text{th}}</code> dataset, <code class="reqn">T_\ell</code>, is computed by <code class="reqn"> - log(u) \ exp(- Z_\ell \boldsymbol{\beta}) / a</code>, where <code class="reqn">u</code> follows a standard uniform distribution;
</p>
</li></ul>

<p>For <code>gen_data_from = </code>&ldquo;weibul&rdquo;:
</p>

<ul>
<li><p> the cumulative hazard function is as <code class="reqn">\Lambda_0=a t ^ b</code>,
</p>
</li>
<li><p> the event time is computed by <code class="reqn">T_\ell= (- log(u) \ exp(- Z_\ell \boldsymbol{\beta}) / a)^{1/b}</code>, where <code class="reqn">u</code> follows a standard uniform distribution;
</p>
</li></ul>

<p>For <code>gen_data_from = </code>&ldquo;gomp&rdquo;:
</p>

<ul>
<li><p> the cumulative hazard function is as <code class="reqn">\Lambda_0=a (exp(b t) - 1) / b</code>,
</p>
</li>
<li><p> the event time is computed by <code class="reqn">T_\ell= \log(1- log(u) \ exp(- Z_\ell \boldsymbol{\beta}) b / a) / b</code>, where <code class="reqn">u</code> follows a standard uniform distribution;
</p>
</li></ul>

<p>Finally the survival time is obtained by <code class="reqn">\tilde{T}_\ell=\min\{T_\ell , C_\ell \}</code>.
</p>
<p>The function will be updated for <code>gen_data_from = </code>&ldquo;gomp&rdquo;.
</p>


<h3>Value</h3>

<p><code>surv.simulate</code> returns a list containing the following components:
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>a list of <code class="reqn">L</code> data frames, with dimension <code class="reqn">n_\ell \times (p+2)</code>. The first and second columns, named <code>time</code> and <code>status</code>, contain the simulated survival time and the censoring indicator, respectively, where <code class="reqn">0</code> means censored and <code class="reqn">1</code> means uncensored;</p>
</td></tr>
<tr><td><code>censor_propor</code></td>
<td>
<p>the vector of censoring proportions in the simulated datasets <code>D</code>, containing <code class="reqn">L</code> elements;</p>
</td></tr>
<tr><td><code>u1</code></td>
<td>
<p>the lower limit of the uniform distribution used to generate random censoring times with a predefined censoring rate. Sometimes this output is less than the value entered by the user, as it is adjusted to achieve the desired amount of censoring rate;</p>
</td></tr>
<tr><td><code>u2</code></td>
<td>
<p>the upper limit of the uniform distribution used to generate random censoring times. If <code>u2 = NULL</code>, this output will be the estimated upper limit necessary to achieve the desired censoring rate across the <code class="reqn">L</code> datasets.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hassan Pazira<br />
Maintainer: Hassan Pazira <a href="mailto:hassan.pazira@radboudumc.nl">hassan.pazira@radboudumc.nl</a>
</p>


<h3>References</h3>

<p>Pazira H., Massa E., Weijers J.A.M., Coolen A.C.C. and Jonker M.A. (2024). <em>Bayesian Federated Inference for Survival Models</em>, <em>arXiv</em>. &lt;https://arxiv.org/abs/2404.17464&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MAP.estimation">MAP.estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setting a seed for reproducibility
set.seed(1123)

#-------------------------
# Simulating Survival data
#-------------------------
N    &lt;- c(7, 10, 13) # the sample sizes of 3 datasets
beta &lt;- 1:4
p    &lt;- length(beta)
L    &lt;- 3

# Define a function to generate multivariate normal samples
mvrnorm_new &lt;- function(n, mu, Sigma) {
    pp &lt;- length(mu)
    e &lt;- matrix(rnorm(n * pp), nrow = n)
    return(crossprod(t(e), chol(Sigma)) + matrix(mu, n, pp, byrow = TRUE))
}
Z &lt;- list()
for (z in seq_len(L)) {
    Z[[z]] &lt;- mvrnorm_new(n = N[z], mu = rep(0, p),
                          Sigma = diag(rep(1, p),p))
    colnames(Z[[z]]) &lt;- paste0("Z_",seq_len(ncol(Z[[z]])))
}

# One simulated dataset from exponential distribution with no censoring:
surv_data &lt;- surv.simulate(Z = Z[[1]], beta = beta, a = exp(-.9),
                           cen_rate = 0, gen_data_from = "exp")
surv_data
surv_data$D[[1]][,1:2] # The simulated survival data

# Calculate only 'u2' with a predefined censoring rate of 0.4:
u2_new &lt;- surv.simulate(Z = Z[1:2], beta = beta, a = exp(-.9),
                        b = exp(1.8), u1 = 0.1, only_u2 = TRUE,
                        cen_rate = 0.4, gen_data_from = "weibul")$u2
u2_new

# Two simulated datasets with a known 'u2':
# Using 'u2_new' to help control over censoring rate (was chosen 0.4)
surv.simulate(Z = Z[1:2], beta = beta, a = exp(-.9), b = exp(1.8),
              u1 = 0.05, u2 = u2_new, gen_data_from = "weibul")

# Three simulated datasets from 'weibul' with an unknown 'u2':
surv.simulate(Z = Z, beta = beta, a = exp(-1), b = exp(1),
               u1 = 0.01, cen_rate = 0.3, gen_data_from = "weibul")

# Two simulated datasets from 'gomp' with unknown 'u2' and censoring rate of 0.3:
surv.simulate(Z = Z[2:3], beta = beta, a = exp(1), b = exp(2), u1 = 0.1,
              cen_rate = 0.3, gen_data_from = "gomp", Trace = TRUE)

</code></pre>

<hr>
<h2 id='trauma'>
Trauma patients from different hospitals
</h2><span id='topic+trauma'></span>

<h3>Description</h3>

<p>This data set consists of data of 371 trauma patients from three hospitals.
The binary variable <code>mortality</code> is used as an outcome, and variables <code>age</code>, <code>sex</code>, the Injury Severity Score (<code>ISS</code>, ranging from 1 (low) to 75 (high)) and the Glasgow Coma Scale (<code>GCS</code>, which expresses the level of consciousness, ranging from 3 (low) to 15 (high)) are used as covariates.
There are three types of hospitals: peripheral hospital without a neuro-surgical unit (<code>Status = 1</code>), peripheral hospital with a neuro-surgical unit (<code>Status = 2</code>), and academic medical center (<code>Status = 3</code>). Originally, the data come from a multi center study collected with a different aim. For educational purposes minor changes have been made, see the references below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(trauma)</code></pre>


<h3>References</h3>

<p>Jonker M.A., Pazira H. and Coolen A.C.C. (2024). <em>Bayesian federated inference for estimating statistical models based on non-shared multicenter data sets</em>, <em>Statistics in Medicine</em>, 43(12): 2421-2438. &lt;https://doi.org/10.1002/sim.10072&gt;
</p>
<p>Draaisma J.M.Th, de Haan A.F.J., Goris R.J.A. (1989). <em>Preventable Trauma Deaths in the Netherlands - A prospective Multicentre Study</em>, The journal of Trauma, Vol. 29(11), 1552-1557.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
