<!DOCTYPE html><html><head><title>Help for package BlockCov</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BlockCov}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BlockCov'><p><code>BlockCov</code> package</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#cv_bl'><p>Title</p></a></li>
<li><a href='#est_up'><p>Title</p></a></li>
<li><a href='#PA'><p>Title</p></a></li>
<li><a href='#Sigma_estimation'><p>This function computes an estimator of the covariance matrix and the square root of its inverse and permutes its rows and columns if it is necessary to make the block structure appear.</p></a></li>
<li><a href='#Simu_Sigma'><p>This function generates a block structured symmetric positive definite matrix to test the BlockCov methodology.</p></a></li>
<li><a href='#slope_change'><p>This function fits to a numerical vector sorted in the non decreasing order two simple linear regressions and returns the index corresponding to the estimated change between the two regression models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Large Block Covariance Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>M. Perrot-Dock\`es, C. Lévy-Leduc</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marie Perrot-Dockès &lt;marie.perrocks@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of large covariance matrices having a block structure up to a permutation of their columns and rows 
    from a small number of samples with respect to the dimension of the matrix.
 The method is described in the paper Perrot-Dockès et al. (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1806.10093">doi:10.48550/arXiv.1806.10093</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, stats, Rdpack, BBmisc, dplyr, tibble, magrittr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-13 18:32:17 UTC; perrot-dockes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-13 22:55:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='BlockCov'><code>BlockCov</code> package</h2><span id='topic+BlockCov'></span><span id='topic+BlockCov-package'></span>

<h3>Description</h3>

<p>Estimation of Large Block Covariance Matrices
</p>


<h3>Details</h3>

<p>See the README on
<a href="https://cran.r-project.org/package=BlockCov/vignettes/Vignettes.pdf">CRAN</a>
<a href="https://github.com/Marie-PerrotDockes/BlockCov#readme">GitHub</a>
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='cv_bl'>Title</h2><span id='topic+cv_bl'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_bl(E, v_ord, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_bl_+3A_e">E</code></td>
<td>
<p>the observation matrix such that each of its row has a block structure correlation matrix Sigma to estimate up to a permutation of its columns and rows.</p>
</td></tr>
<tr><td><code id="cv_bl_+3A_v_ord">v_ord</code></td>
<td>
<p>the absolute value of the upper  triangular part matrix <code class="reqn">\Gamma</code> (including its diagonal) order in
increasing order</p>
</td></tr>
<tr><td><code id="cv_bl_+3A_n">N</code></td>
<td>
<p>number of replication in the &quot;cross-validation&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to get the treshold one must do rev(v_ord)[cv_bl(E, v_ord, N=N)]
</p>


<h3>Value</h3>

<p>the number of non null values selected for the estimation of the covariance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30
q &lt;- 100
Sigma &lt;- Simu_Sigma(q = q, diag = FALSE, equal = TRUE)
Matrix::image(Sigma)
E &lt;- matrix(rnorm(n * q), ncol = q) %*% chol(as.matrix(Sigma))
k &lt;- 5
v_up &lt;- est_up(E, k = k)
a_vup &lt;- abs(v_up)
ord_vup &lt;- order(a_vup)
v_ord &lt;- a_vup[ord_vup]
N &lt;- 10
nb_nn0 &lt;- cv_bl(E, v_ord, N=N)
tresh &lt;- rev(v_ord)[nb_nn0]
</code></pre>

<hr>
<h2 id='est_up'>Title</h2><span id='topic+est_up'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_up(E, k = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_up_+3A_e">E</code></td>
<td>
<p>the observation matrix such that each of its row has a block structure correlation matrix Sigma wich has a low rank once its diagonal is removed.</p>
</td></tr>
<tr><td><code id="est_up_+3A_k">k</code></td>
<td>
<p>the rank of the correlation matrix of <code>E</code> once its diagonal has been removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an approximation of the correlation matrix of <code>E</code> with its diagonal removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30
q &lt;- 100
Sigma &lt;- Simu_Sigma(q = q, diag = FALSE, equal = TRUE)
Matrix::image(Sigma)
E &lt;- matrix(rnorm(n * q), ncol = q) %*% chol(as.matrix(Sigma))
k &lt;- 5
v_up &lt;- est_up(E, k = k)
</code></pre>

<hr>
<h2 id='PA'>Title</h2><span id='topic+PA'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PA(E, times = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PA_+3A_e">E</code></td>
<td>
<p>the observation matrix such that each of its row has a block structure correlation matrix Sigma wich has a low rank once its diagonal is removed.</p>
</td></tr>
<tr><td><code id="PA_+3A_times">times</code></td>
<td>
<p>number of random sampling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean of the eigen values of the <code>times</code> sampled matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30
q &lt;- 100
Sigma &lt;- Simu_Sigma(q = q, diag = FALSE, equal = TRUE)
Matrix::image(Sigma)
E &lt;- matrix(rnorm(n * q), ncol = q) %*% chol(as.matrix(Sigma))
random_eigen &lt;- PA(E, times = 10)
</code></pre>

<hr>
<h2 id='Sigma_estimation'>This function computes an estimator of the covariance matrix and the square root of its inverse and permutes its rows and columns if it is necessary to make the block structure appear.</h2><span id='topic+Sigma_estimation'></span>

<h3>Description</h3>

<p>This function computes an estimator of the covariance matrix and the square root of its inverse and permutes its rows and columns if it is necessary to make the block structure appear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sigma_estimation(E, k = NULL, nb_nn0 = NULL, big = FALSE,
  reorder = FALSE, inv_12 = FALSE, method_k = "Cattell",
  times = 10, method_0 = "Elbow", N = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sigma_estimation_+3A_e">E</code></td>
<td>
<p>the observation matrix such that each of its row has a block structure correlation matrix Sigma to estimate up to a permutation of its columns and rows.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_k">k</code></td>
<td>
<p>numerical or NULL, the rank for the low rank approximation. If NULL the rank is computed using the slope_change function applied on the eigenvalues of the low rank part of Sigma. Default to NULL.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_nb_nn0">nb_nn0</code></td>
<td>
<p>numerical or NULL, corresponds to the number of non null values to keep in the estimation of the covariance matrix.
If NULL the number of non null values is computed using the slope_change function to the Frobenius norm of the difference between the empirical correlation matrix and its estimation with nb_nn0 non null values. Default to NULL.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_big">big</code></td>
<td>
<p>logical, default to FALSE. If the dataset is too big the empirical correlation is calculated by crossprod(E) * 1 / n to fasten the computation</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_reorder">reorder</code></td>
<td>
<p>logical, default to FALSE. Whether or not the columns of E are permuted. If TRUE a hierarchical clustering is first performed and the columns are permuted according to it.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_inv_12">inv_12</code></td>
<td>
<p>logical, default to FALSE Whether or not computing the square root of the inverse of the covariance matrix.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_method_k">method_k</code></td>
<td>
<p>character if &quot;Cattell&quot; (the default) then the Cattell criterion (Cattell 1966) is performed on the singular values of the covariance matrix.
to estimate the number of rank use in the low rank approximation, while &quot;PA&quot; use the parrallel analysis (Horn 1965)
wich can be more accurate if the number of rows of E is not to small but which is much slower.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_times">times</code></td>
<td>
<p>numeric the number of resampling done for the &quot;PA&quot; method, ignored if metod_k is different from &quot;PA&quot;.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_method_0">method_0</code></td>
<td>
<p>character if &quot;Elbow&quot; (the default) then the Elbow criterion (see Perrot-Dockès et al. (2018) for details) is performed
to estimate the number of rank use in the low rank approximation, while &quot;BL&quot; use the approach proposed in
Bickel and Levina (2008) based on cross-validation
wich can be more accurate if the number of rows of E is not to small but which is much slower.</p>
</td></tr>
<tr><td><code id="Sigma_estimation_+3A_n">N</code></td>
<td>
<p>numeric the number of fold used for the &quot;BL&quot; method. Ignored if method_0 is different from &quot;BL&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the elements
</p>
<table>
<tr><td><code>Sigma_est</code></td>
<td>
<p>estimator of the covariance matrix</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>rank of the low rank part of the covariance matrix</p>
</td></tr>
<tr><td><code>nb_nn0</code></td>
<td>
<p>number of non null values of the upper triangular part of the covariance matrix</p>
</td></tr>
<tr><td><code>S_inv_12</code></td>
<td>
<p>square root of the inverse of the estimated covariance matrix</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>permutation to apply to the rows and the columns of the covariance to make the block structure appear</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bickel PJ, Levina E (2008).
&ldquo;Covariance regularization by thresholding.&rdquo;
<em>Ann. Statist.</em>, <b>36</b>(6), 2577&ndash;2604.
doi: <a href="http://doi.org/10.1214/08-AOS600">10.1214/08-AOS600</a>, <a href="https://doi.org/10.1214/08-AOS600">https://doi.org/10.1214/08-AOS600</a>.<br /><br /> Cattell RB (1966).
&ldquo;The scree test for the number of factors.&rdquo;
<em>Multivariate behavioral research</em>, <b>1</b>(2), 245-276.<br /><br /> Horn JL (1965).
&ldquo;A rationale and test for the number of factors in factor analysis.&rdquo;
<em>Psychometrika</em>, <b>30</b>(2), 179&ndash;185.
ISSN 1860-0980, doi: <a href="http://doi.org/10.1007/BF02289447">10.1007/BF02289447</a>, <a href="https://doi.org/10.1007/BF02289447">https://doi.org/10.1007/BF02289447</a>.<br /><br /> Perrot-Dockès M, Lévy-Leduc C, Rajjou L (2018).
&ldquo;Estimation of large block structured covariance matrices: Application to &quot;multi-omic&quot; approaches to study seed quality.&rdquo;
arXiv:1806.10093.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30
q &lt;- 100
Sigma &lt;- Simu_Sigma(q = q, diag = FALSE, equal = TRUE)
Matrix::image(Sigma)
E &lt;- matrix(rnorm(n * q), ncol = q) %*% chol(as.matrix(Sigma))
res &lt;- Sigma_estimation(E, inv_12 = TRUE)
Matrix::image(res$Sigma_est)
Matrix::image(res$S_inv_12)
</code></pre>

<hr>
<h2 id='Simu_Sigma'>This function generates a block structured symmetric positive definite matrix to test the BlockCov methodology.</h2><span id='topic+Simu_Sigma'></span>

<h3>Description</h3>

<p>This function generates a block structured symmetric positive definite matrix to test the BlockCov methodology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Simu_Sigma(q, diag = TRUE, equal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simu_Sigma_+3A_q">q</code></td>
<td>
<p>integer corresponding to the size of the covariance matrix.</p>
</td></tr>
<tr><td><code id="Simu_Sigma_+3A_diag">diag</code></td>
<td>
<p>logical, whether or not the covariance matrix is block-diagonal.</p>
</td></tr>
<tr><td><code id="Simu_Sigma_+3A_equal">equal</code></td>
<td>
<p>logical, whether or not the values in the blocks are equal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sigma a correlation matrix to test the BlockCov methodology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- Simu_Sigma(q = 100, diag = FALSE, equal = TRUE)
Matrix::image(Sigma)
</code></pre>

<hr>
<h2 id='slope_change'>This function fits to a numerical vector sorted in the non decreasing order two simple linear regressions and returns the index corresponding to the estimated change between the two regression models.</h2><span id='topic+slope_change'></span>

<h3>Description</h3>

<p>This function fits to a numerical vector sorted in the non decreasing order two simple linear regressions and returns the index corresponding to the estimated change between the two regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope_change(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slope_change_+3A_y">Y</code></td>
<td>
<p>numerical vector sorted in the non decreasing order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>K the index corresponding to the estimated change between the two linear regression models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 30
q &lt;- 100
Sigma &lt;- Simu_Sigma(q = q, diag = FALSE, equal = TRUE)
Matrix::image(Sigma)
E &lt;- matrix(rnorm(n * q), ncol = q) %*% chol(as.matrix(Sigma))
corE &lt;- cor(as.matrix(E))
vec_up_emp &lt;- corE[upper.tri(corE)]
G &lt;- matrix(0, ncol = (q - 1), nrow = (q - 1))
G[upper.tri(G, diag = TRUE)] &lt;- vec_up_emp
G[lower.tri(G)] &lt;- t(as.matrix(G))[lower.tri(t(as.matrix(G)))]
res_svd &lt;- svd(G)
vp &lt;- res_svd$d
slope_change(vp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
