<!DOCTYPE html><html><head><title>Help for package modelbased</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {modelbased}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.uniroot.all'><p>Copied from rootSolve package</p></a></li>
<li><a href='#describe_nonlinear'><p>Describe the smooth term (for GAMs) or non-linear predictors</p></a></li>
<li><a href='#estimate_contrasts'><p>Estimate Marginal Contrasts</p></a></li>
<li><a href='#estimate_expectation'><p>Model-based response estimates and uncertainty</p></a></li>
<li><a href='#estimate_grouplevel'><p>Group-specific parameters of mixed models random effects</p></a></li>
<li><a href='#estimate_means'><p>Estimate Marginal Means (Model-based average at each factor level)</p></a></li>
<li><a href='#estimate_slopes'><p>Estimate Marginal Effects</p></a></li>
<li><a href='#find_inversions'><p>Find points of inversion</p></a></li>
<li><a href='#get_emcontrasts'><p>Easy 'emmeans' and 'emtrends'</p></a></li>
<li><a href='#get_marginaleffects'><p>Easy marginaleffects</p></a></li>
<li><a href='#modelbased-package'><p>modelbased: Estimation of Model-Based Predictions, Contrasts and Means</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#smoothing'><p>Smoothing a vector or a time series</p></a></li>
<li><a href='#visualisation_matrix'><p>Create a reference grid</p></a></li>
<li><a href='#visualisation_recipe.estimate_grouplevel'><p>Visualisation Recipe for 'modelbased' Objects</p></a></li>
<li><a href='#zero_crossings'><p>Find zero crossings of a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of Model-Based Predictions, Contrasts and Means</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominique Makowski &lt;dom.makowski@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a general interface for model-based estimations
    for a wide variety of models (see list of supported models using the
    function 'insight::supported_models()'), used in the computation of
    marginal means, contrast analysis and predictions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://easystats.github.io/modelbased/">https://easystats.github.io/modelbased/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/easystats/modelbased/issues">https://github.com/easystats/modelbased/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bayestestR (&ge; 0.13.1), datawizard (&ge; 0.9.1), effectsize (&ge;
0.8.6), insight (&ge; 0.19.8), parameters (&ge; 0.21.3),
performance (&ge; 0.10.8), graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brms, correlation, emmeans (&ge; 1.8.3), gamm4, gganimate,
ggplot2, glmmTMB, knitr, lme4, logspline, marginaleffects,
mgcv, patchwork, poorman, report, rmarkdown, rstanarm, rtdists,
see (&ge; 0.7.4), testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rstudio/bslib, r-lib/pkgdown,
easystats/easystatstemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-14 21:18:08 UTC; domma</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominique Makowski
    <a href="https://orcid.org/0000-0001-5375-9967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]
    (@Dom_Makowski),
  Daniel LÃ¼decke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (@strengejacke),
  Mattan S. Ben-Shachar
    <a href="https://orcid.org/0000-0002-4287-4801"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (@mattansb),
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (@patilindrajeets)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.uniroot.all'>Copied from rootSolve package</h2><span id='topic+.uniroot.all'></span>

<h3>Description</h3>

<p>Copied from rootSolve package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.uniroot.all(
  f,
  interval,
  lower = min(interval),
  upper = max(interval),
  tol = .Machine$double.eps^0.2,
  maxiter = 1000,
  n = 100,
  ...
)
</code></pre>

<hr>
<h2 id='describe_nonlinear'>Describe the smooth term (for GAMs) or non-linear predictors</h2><span id='topic+describe_nonlinear'></span><span id='topic+describe_nonlinear.data.frame'></span><span id='topic+estimate_smooth'></span>

<h3>Description</h3>

<p>This function summarises the smooth term trend in terms of linear segments.
Using the approximate derivative, it separates a non-linear vector into
quasi-linear segments (in which the trend is either positive or negative).
Each of this segment its characterized by its beginning, end, size (in
proportion, relative to the total size) trend (the linear regression
coefficient) and linearity (the R2 of the linear regression).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_nonlinear(data, ...)

## S3 method for class 'data.frame'
describe_nonlinear(data, x = NULL, y = NULL, ...)

estimate_smooth(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_nonlinear_+3A_data">data</code></td>
<td>
<p>The data containing the link, as for instance obtained by
<code><a href="#topic+estimate_relation">estimate_relation()</a></code>.</p>
</td></tr>
<tr><td><code id="describe_nonlinear_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to or from.</p>
</td></tr>
<tr><td><code id="describe_nonlinear_+3A_x">x</code>, <code id="describe_nonlinear_+3A_y">y</code></td>
<td>
<p>The name of the responses variable (<code>y</code>) predicting variable
(<code>x</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of linear description of non-linear terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create data
data &lt;- data.frame(x = rnorm(200))
data$y &lt;- data$x^2 + rnorm(200, 0, 0.5)

model &lt;&lt;- lm(y ~ poly(x, 2), data = data)
link_data &lt;- estimate_relation(model, length = 100)

describe_nonlinear(link_data, x = "x")
</code></pre>

<hr>
<h2 id='estimate_contrasts'>Estimate Marginal Contrasts</h2><span id='topic+estimate_contrasts'></span>

<h3>Description</h3>

<p>Run a contrast analysis by estimating the differences between each level of a
factor. See also other related functions such as <code><a href="#topic+estimate_means">estimate_means()</a></code>
and <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_contrasts(
  model,
  contrast = NULL,
  at = NULL,
  fixed = NULL,
  transform = "none",
  ci = 0.95,
  p_adjust = "holm",
  method = "pairwise",
  adjust = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_contrasts_+3A_model">model</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_contrast">contrast</code></td>
<td>
<p>A character vector indicating the name of the variable(s)
for which to compute the contrasts.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_at">at</code></td>
<td>
<p>The predictor variable(s) <em>at</em> which to evaluate the desired effect
/ mean / contrasts. Other predictors of the model that are not included
here will be collapsed and &quot;averaged&quot; over (the effect will be estimated
across them).</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_fixed">fixed</code></td>
<td>
<p>A character vector indicating the names of the predictors to be
&quot;fixed&quot; (i.e., maintained), so that the estimation is made at these values.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_transform">transform</code></td>
<td>
<p>Is passed to the <code>type</code> argument in
<code>emmeans::emmeans()</code>. See
<a href="https://CRAN.R-project.org/package=emmeans/vignettes/transformations.html">this vignette</a>.
Can be <code>"none"</code> (default for contrasts), <code>"response"</code>
(default for means), <code>"mu"</code>, <code>"unlink"</code>, <code>"log"</code>.
<code>"none"</code> will leave the values on scale of the linear predictors.
<code>"response"</code> will transform them on scale of the response variable.
Thus for a logistic model, <code>"none"</code> will give estimations expressed in
log-odds (probabilities on logit scale) and <code>"response"</code> in terms of
probabilities.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_ci">ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_p_adjust">p_adjust</code></td>
<td>
<p>The p-values adjustment method for frequentist multiple
comparisons. Can be one of &quot;holm&quot; (default), &quot;tukey&quot;, &quot;hochberg&quot;, &quot;hommel&quot;,
&quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot; or &quot;none&quot;. See the p-value adjustment
section in the <code>emmeans::test</code> documentation.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_method">method</code></td>
<td>
<p>Contrast method. See same argument in <a href="emmeans.html#topic+contrast">emmeans::contrast</a>.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_adjust">adjust</code></td>
<td>
<p>Deprecated in favour of <code>p_adjust</code>.</p>
</td></tr>
<tr><td><code id="estimate_contrasts_+3A_...">...</code></td>
<td>
<p>Other arguments passed for instance to <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <strong>Details</strong> section below, and don't forget to also check out the
<a href="https://easystats.github.io/modelbased/articles/estimate_slopes.html">Vignettes</a>
and <a href="https://easystats.github.io/modelbased/index.html#features">README examples</a> for
various examples, tutorials and use cases.
</p>
<p>The <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>, <code><a href="#topic+estimate_means">estimate_means()</a></code> and <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>
functions are forming a group, as they are all based on <em>marginal</em>
estimations (estimations based on a model). All three are also built on the
<span class="pkg">emmeans</span> package, so reading its documentation (for instance for
<code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> and <code><a href="emmeans.html#topic+emtrends">emmeans::emtrends()</a></code>) is recommended to understand
the idea behind these types of procedures.
</p>

<ul>
<li><p> Model-based <strong>predictions</strong> is the basis for all that follows. Indeed,
the first thing to understand is how models can be used to make predictions
(see <code><a href="#topic+estimate_link">estimate_link()</a></code>). This corresponds to the predicted response (or
&quot;outcome variable&quot;) given specific predictor values of the predictors (i.e.,
given a specific data configuration). This is why the concept of <code><a href="#topic+visualisation_matrix">reference grid()</a></code> is so important for direct predictions.
</p>
</li>
<li> <p><strong>Marginal &quot;means&quot;</strong>, obtained via <code><a href="#topic+estimate_means">estimate_means()</a></code>, are an extension
of such predictions, allowing to &quot;average&quot; (collapse) some of the predictors,
to obtain the average response value at a specific predictors configuration.
This is typically used when some of the predictors of interest are factors.
Indeed, the parameters of the model will usually give you the intercept value
and then the &quot;effect&quot; of each factor level (how different it is from the
intercept). Marginal means can be used to directly give you the mean value of
the response variable at all the levels of a factor. Moreover, it can also be
used to control, or average over predictors, which is useful in the case of
multiple predictors with or without interactions.
</p>
</li>
<li> <p><strong>Marginal contrasts</strong>, obtained via <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>, are
themselves at extension of marginal means, in that they allow to investigate
the difference (i.e., the contrast) between the marginal means. This is,
again, often used to get all pairwise differences between all levels of a
factor. It works also for continuous predictors, for instance one could also
be interested in whether the difference at two extremes of a continuous
predictor is significant.
</p>
</li>
<li><p> Finally, <strong>marginal effects</strong>, obtained via <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>, are
different in that their focus is not values on the response variable, but the
model's parameters. The idea is to assess the effect of a predictor at a
specific configuration of the other predictors. This is relevant in the case
of interactions or non-linear relationships, when the effect of a predictor
variable changes depending on the other predictors. Moreover, these effects
can also be &quot;averaged&quot; over other predictors, to get for instance the
&quot;general trend&quot; of a predictor over different factor levels.
</p>
</li></ul>

<p><strong>Example:</strong> Let's imagine the following model <code>lm(y ~ condition * x)</code> where
<code>condition</code> is a factor with 3 levels A, B and C and <code>x</code> a continuous
variable (like age for example). One idea is to see how this model performs,
and compare the actual response y to the one predicted by the model (using
<code><a href="#topic+estimate_response">estimate_response()</a></code>). Another idea is evaluate the average mean at each of
the condition's levels (using <code><a href="#topic+estimate_means">estimate_means()</a></code>), which can be useful to
visualize them. Another possibility is to evaluate the difference between
these levels (using <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>). Finally, one could also estimate
the effect of x averaged over all conditions, or instead within each
condition (<code>using [estimate_slopes]</code>).
</p>


<h3>Value</h3>

<p>A data frame of estimated contrasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage
model &lt;- lm(Sepal.Width ~ Species, data = iris)
estimate_contrasts(model)

# Dealing with interactions
model &lt;- lm(Sepal.Width ~ Species * Petal.Width, data = iris)

# By default: selects first factor
estimate_contrasts(model)

# Can also run contrasts between points of numeric
estimate_contrasts(model, contrast = "Petal.Width", length = 4)

# Or both
estimate_contrasts(model, contrast = c("Species", "Petal.Width"), length = 2)

# Or with custom specifications
estimate_contrasts(model, contrast = c("Species", "Petal.Width=c(1, 2)"))

# Can fixate the numeric at a specific value
estimate_contrasts(model, fixed = "Petal.Width")

# Or modulate it
estimate_contrasts(model, at = "Petal.Width", length = 4)

# Standardized differences
estimated &lt;- estimate_contrasts(lm(Sepal.Width ~ Species, data = iris))
standardize(estimated)


# Other models (mixed, Bayesian, ...)
data &lt;- iris
data$Petal.Length_factor &lt;- ifelse(data$Petal.Length &lt; 4.2, "A", "B")

model &lt;- lme4::lmer(Sepal.Width ~ Species + (1 | Petal.Length_factor), data = data)
estimate_contrasts(model)


library(rstanarm)


data &lt;- mtcars
data$cyl &lt;- as.factor(data$cyl)
data$am &lt;- as.factor(data$am)

model &lt;- stan_glm(mpg ~ cyl * am, data = data, refresh = 0)
estimate_contrasts(model)
estimate_contrasts(model, fixed = "am")

model &lt;- stan_glm(mpg ~ cyl * wt, data = data, refresh = 0)
estimate_contrasts(model)
estimate_contrasts(model, fixed = "wt")
estimate_contrasts(model, at = "wt", length = 4)

model &lt;- stan_glm(Sepal.Width ~ Species + Petal.Width + Petal.Length, data = iris, refresh = 0)
estimate_contrasts(model, at = "Petal.Length", test = "bf")


</code></pre>

<hr>
<h2 id='estimate_expectation'>Model-based response estimates and uncertainty</h2><span id='topic+estimate_expectation'></span><span id='topic+estimate_response'></span><span id='topic+estimate_link'></span><span id='topic+estimate_prediction'></span><span id='topic+estimate_relation'></span>

<h3>Description</h3>

<p>After fitting a model, it is useful generate model-based estimates of the
response variables for different combinations of predictor values. Such
estimates can be used to make inferences about relationships between
variables and to make predictions about individual cases.
</p>
<p>Model-based response estimates and uncertainty can be generated for both the
conditional average response values (the regression line or expectation) and
for predictions about individual cases. See below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_expectation(
  model,
  data = NULL,
  ci = 0.95,
  keep_iterations = FALSE,
  ...
)

estimate_response(...)

estimate_link(model, data = "grid", ci = 0.95, keep_iterations = FALSE, ...)

estimate_prediction(
  model,
  data = NULL,
  ci = 0.95,
  keep_iterations = FALSE,
  ...
)

estimate_relation(
  model,
  data = "grid",
  ci = 0.95,
  keep_iterations = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_expectation_+3A_model">model</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="estimate_expectation_+3A_data">data</code></td>
<td>
<p>A data frame with model's predictors to estimate the response. If
<code>NULL</code>, the model's data is used. If &quot;grid&quot;, the model matrix is obtained
(through <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>).</p>
</td></tr>
<tr><td><code id="estimate_expectation_+3A_ci">ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="estimate_expectation_+3A_keep_iterations">keep_iterations</code></td>
<td>
<p>If <code>TRUE</code>, will keep all iterations (draws) of
bootstrapped or Bayesian models. They will be added as additional columns
named <code style="white-space: pre;">&#8288;iter_1, iter_2, ...&#8288;</code>. You can reshape them to a long format by
running <code><a href="bayestestR.html#topic+reshape_iterations">reshape_iterations()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_expectation_+3A_...">...</code></td>
<td>
<p>You can add all the additional control arguments from
<code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code> (used when <code>data = "grid"</code>) and
<code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of predicted values and uncertainty intervals, with
class <code>"estimate_predicted"</code>. Methods for <code><a href="#topic+visualisation_recipe.estimate_predicted">visualisation_recipe()</a></code>
and <code><a href="#topic+visualisation_recipe.estimate_predicted">plot()</a></code> are available.
</p>


<h3>Expected (average) values</h3>

<p>The most important way that various types of response estimates differ is in
terms of what quantity is being estimated and the meaning of the uncertainty
intervals. The major choices are <strong>expected values</strong> for uncertainty in the
regression line and <strong>predicted values</strong> for uncertainty in the individual
case predictions.
</p>
<p><strong>Expected values</strong> refer to the fitted regression line - the estimated
<em>average</em> response value (i.e., the &quot;expectation&quot;) for individuals with
specific predictor values. For example, in a linear model <em>y</em> = 2 + 3<em>x</em> +
4<em>z</em> + <em>e</em>, the estimated average <em>y</em> for individuals with <em>x</em> = 1 and <em>z</em> =
2 is 11.
</p>
<p>For expected values, uncertainty intervals refer to uncertainty in the
estimated <strong>conditional average</strong> (where might the true regression line
actually fall)? Uncertainty intervals for expected values are also called
&quot;confidence intervals&quot;.
</p>
<p>Expected values and their uncertainty intervals are useful for describing the
relationship between variables and for describing how precisely a model has
been estimated.
</p>
<p>For generalized linear models, expected values are reported on one of two scales:
</p>

<ul>
<li><p> The <strong>link scale</strong> refers to scale of the fitted regression line, after
transformation by the link function. For example, for a logistic regression
(logit binomial) model, the link scale gives expected log-odds. For a
log-link Poisson model, the link scale gives the expected log-count.
</p>
</li>
<li><p> The <strong>response scale</strong> refers to the original scale of the response
variable (i.e., without any link function transformation). Expected values
on the link scale are back-transformed to the original response variable
metric (e.g., expected probabilities for binomial models, expected counts
for Poisson models).
</p>
</li></ul>



<h3>Individual case predictions</h3>

<p>In contrast to expected values, <strong>predicted values</strong> refer to predictions for
<strong>individual cases</strong>. Predicted values are also called &quot;posterior
predictions&quot; or &quot;posterior predictive draws&quot;.
</p>
<p>For predicted values, uncertainty intervals refer to uncertainty in the
<strong>individual response values for each case</strong> (where might any single case
actually fall)? Uncertainty intervals for predicted values are also called
&quot;prediction intervals&quot; or &quot;posterior predictive intervals&quot;.
</p>
<p>Predicted values and their uncertainty intervals are useful for forecasting
the range of values that might be observed in new data, for making decisions
about individual cases, and for checking if model predictions are reasonable
(&quot;posterior predictive checks&quot;).
</p>
<p>Predicted values and intervals are always on the scale of the original
response variable (not the link scale).
</p>


<h3>Functions for estimating predicted values and uncertainty</h3>

<p><em>modelbased</em> provides 4 functions for generating model-based response
estimates and their uncertainty:
</p>

<ul>
<li> <p><strong><code>estimate_expectation()</code></strong>:
</p>

<ul>
<li><p> Generates <strong>expected values</strong> (conditional average) on the <strong>response scale</strong>.
</p>
</li>
<li><p> The uncertainty interval is a <em>confidence interval</em>.
</p>
</li>
<li><p> By default, values are computed using the data used to fit the model.
</p>
</li></ul>

</li>
<li> <p><strong><code>estimate_link()</code></strong>:
</p>

<ul>
<li><p> Generates <strong>expected values</strong> (conditional average) on the <strong>link scale</strong>.
</p>
</li>
<li><p> The uncertainty interval is a <em>confidence interval</em>.
</p>
</li>
<li><p> By default, values are computed using a reference grid spanning the
observed range of predictor values (see <code><a href="#topic+visualisation_matrix">visualisation_matrix()</a></code>).
</p>
</li></ul>

</li>
<li> <p><strong><code>estimate_prediction()</code></strong>:
</p>

<ul>
<li><p> Generates <strong>predicted values</strong> (for individual cases) on the <strong>response scale</strong>.
</p>
</li>
<li><p> The uncertainty interval is a <em>prediction interval</em>.
</p>
</li>
<li><p> By default, values are computed using the data used to fit the model.
</p>
</li></ul>

</li>
<li> <p><strong><code>estimate_relation()</code></strong>:
</p>

<ul>
<li><p> Like <code>estimate_expectation()</code>.
</p>
</li>
<li><p> Useful for visualizing a model.
</p>
</li>
<li><p> Generates <strong>expected values</strong> (conditional average) on the <strong>response scale</strong>.
</p>
</li>
<li><p> The uncertainty interval is a <em>confidence interval</em>.
</p>
</li>
<li><p> By default, values are computed using a reference grid spanning the
observed range of predictor values (see <code><a href="#topic+visualisation_matrix">visualisation_matrix()</a></code>).
</p>
</li></ul>

</li></ul>

<p><code>estimate_response()</code> is a deprecated alias for <code>estimate_expectation()</code>.
</p>


<h3>Data for predictions</h3>

<p>If the <code>data = NULL</code>, values are estimated using the data used to fit the
model. If <code>data = "grid"</code>, values are computed using a reference grid
spanning the observed range of predictor values with
<code><a href="#topic+visualisation_matrix">visualisation_matrix()</a></code>. This can be useful for model visualization. The
number of predictor values used for each variable can be controlled with the
<code>length</code> argument. <code>data</code> can also be a data frame containing columns with
names matching the model frame (see <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>). This can be used
to generate model predictions for specific combinations of predictor values.
</p>


<h3>Note</h3>

<p>These functions are built on top of <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code> and correspond
to different specifications of its parameters. It may be useful to read its
<a href="https://easystats.github.io/insight/reference/get_predicted.html">documentation</a>,
in particular the description of the <code>predict</code> argument for additional
details on the difference between expected vs. predicted values and link vs.
response scales.
</p>
<p>Additional control parameters can be used to control results from
<code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code> (when <code>data = "grid"</code>) and from
<code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code> (the function used internally to compute
predictions).
</p>
<p>For plotting, check the examples in <code><a href="#topic+visualisation_recipe">visualisation_recipe()</a></code>. Also check out
the <a href="https://easystats.github.io/modelbased/articles/">Vignettes</a> and <a href="https://easystats.github.io/modelbased/index.html#features">README examples</a> for
various examples, tutorials and usecases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modelbased)

# Linear Models
model &lt;- lm(mpg ~ wt, data = mtcars)

# Get predicted and prediction interval (see insight::get_predicted)
estimate_response(model)

# Get expected values with confidence interval
pred &lt;- estimate_relation(model)
pred

# Visualisation (see visualisation_recipe())
if (require("see")) {
  plot(pred)
}

# Standardize predictions
pred &lt;- estimate_relation(lm(mpg ~ wt + am, data = mtcars))
z &lt;- standardize(pred, include_response = FALSE)
z
unstandardize(z, include_response = FALSE)

# Logistic Models
model &lt;- glm(vs ~ wt, data = mtcars, family = "binomial")
estimate_response(model)
estimate_relation(model)

# Mixed models
if (require("lme4")) {
  model &lt;- lmer(mpg ~ wt + (1 | gear), data = mtcars)
  estimate_response(model)
  estimate_relation(model)
}

# Bayesian models

if (require("rstanarm")) {
  model &lt;- rstanarm::stan_glm(mpg ~ wt, data = mtcars, refresh = 0, iter = 200)
  estimate_response(model)
  estimate_relation(model)
}

</code></pre>

<hr>
<h2 id='estimate_grouplevel'>Group-specific parameters of mixed models random effects</h2><span id='topic+estimate_grouplevel'></span><span id='topic+reshape_grouplevel'></span>

<h3>Description</h3>

<p>Extract random parameters of each individual group in the context of mixed
models. Can be reshaped to be of the same dimensions as the original data,
which can be useful to add the random effects to the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_grouplevel(model, type = "random", ...)

reshape_grouplevel(x, indices = "all", group = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_grouplevel_+3A_model">model</code></td>
<td>
<p>A mixed model with random effects.</p>
</td></tr>
<tr><td><code id="estimate_grouplevel_+3A_type">type</code></td>
<td>
<p>If <code>"random"</code> (default), the coefficients are the ones
estimated natively by the model (as they are returned by, for instance,
<code>lme4::ranef()</code>). They correspond to the deviation of each individual
group from their fixed effect. As such, a coefficient close to 0 means that
the participants' effect is the same as the population-level effect (in
other words, it is &quot;in the norm&quot;). If &quot;total&quot;, it will return the sum of
the random effect and its corresponding fixed effects. These are known as
BLUPs (Best Linear Unbiased Predictions). This argument can be used to
reproduce the results given by <code>lme4::ranef()</code> and <code>coef()</code> (see
<code>?coef.merMod</code>). Note that BLUPs currently don't have uncertainty
indices (such as SE and CI), as these are not computable.</p>
</td></tr>
<tr><td><code id="estimate_grouplevel_+3A_...">...</code></td>
<td>
<p>Other arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="estimate_grouplevel_+3A_x">x</code></td>
<td>
<p>The output of <code>estimate_grouplevel()</code>.</p>
</td></tr>
<tr><td><code id="estimate_grouplevel_+3A_indices">indices</code></td>
<td>
<p>A list containing the indices to extract (e.g., &quot;Coefficient&quot;).</p>
</td></tr>
<tr><td><code id="estimate_grouplevel_+3A_group">group</code></td>
<td>
<p>A list containing the random factors to select.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># lme4 model
if (require("lme4") &amp;&amp; require("see")) {
  model &lt;- lmer(mpg ~ hp + (1 | carb), data = mtcars)
  random &lt;- estimate_grouplevel(model)
  random

  # Visualize random effects
  plot(random)

  # Show group-specific effects
  estimate_grouplevel(model, deviation = FALSE)

  # Reshape to wide data so that it matches the original dataframe...
  reshaped &lt;- reshape_grouplevel(random, indices = c("Coefficient", "SE"))

  # ... and can be easily combined
  alldata &lt;- cbind(mtcars, reshaped)

  # Use summary() to remove duplicated rows
  summary(reshaped)

  # Compute BLUPs
  estimate_grouplevel(model, type = "total")
}

# Bayesian models

if (require("rstanarm")) {
  model &lt;- rstanarm::stan_lmer(mpg ~ hp + (1 | carb) + (1 | gear), data = mtcars, refresh = 0)
  # Broken estimate_grouplevel(model)
}

</code></pre>

<hr>
<h2 id='estimate_means'>Estimate Marginal Means (Model-based average at each factor level)</h2><span id='topic+estimate_means'></span>

<h3>Description</h3>

<p>Estimate average value of response variable at each factor levels. For
plotting, check the examples in <code><a href="#topic+visualisation_recipe">visualisation_recipe()</a></code>. See also
other related functions such as <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code> and
<code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_means(
  model,
  at = "auto",
  fixed = NULL,
  transform = "response",
  ci = 0.95,
  backend = "emmeans",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_means_+3A_model">model</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="estimate_means_+3A_at">at</code></td>
<td>
<p>The predictor variable(s) <em>at</em> which to evaluate the desired effect
/ mean / contrasts. Other predictors of the model that are not included
here will be collapsed and &quot;averaged&quot; over (the effect will be estimated
across them).</p>
</td></tr>
<tr><td><code id="estimate_means_+3A_fixed">fixed</code></td>
<td>
<p>A character vector indicating the names of the predictors to be
&quot;fixed&quot; (i.e., maintained), so that the estimation is made at these values.</p>
</td></tr>
<tr><td><code id="estimate_means_+3A_transform">transform</code></td>
<td>
<p>Is passed to the <code>type</code> argument in
<code>emmeans::emmeans()</code>. See
<a href="https://CRAN.R-project.org/package=emmeans/vignettes/transformations.html">this vignette</a>.
Can be <code>"none"</code> (default for contrasts), <code>"response"</code>
(default for means), <code>"mu"</code>, <code>"unlink"</code>, <code>"log"</code>.
<code>"none"</code> will leave the values on scale of the linear predictors.
<code>"response"</code> will transform them on scale of the response variable.
Thus for a logistic model, <code>"none"</code> will give estimations expressed in
log-odds (probabilities on logit scale) and <code>"response"</code> in terms of
probabilities.</p>
</td></tr>
<tr><td><code id="estimate_means_+3A_ci">ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="estimate_means_+3A_backend">backend</code></td>
<td>
<p>Whether to use 'emmeans' or 'marginaleffects' as a backend.
The latter is experimental and some features might not work.</p>
</td></tr>
<tr><td><code id="estimate_means_+3A_...">...</code></td>
<td>
<p>Other arguments passed for instance to <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <strong>Details</strong> section below, and don't forget to also check out the
<a href="https://easystats.github.io/modelbased/articles/estimate_slopes.html">Vignettes</a>
and <a href="https://easystats.github.io/modelbased/index.html#features">README examples</a> for
various examples, tutorials and use cases.
</p>
<p>The <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>, <code><a href="#topic+estimate_means">estimate_means()</a></code> and <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>
functions are forming a group, as they are all based on <em>marginal</em>
estimations (estimations based on a model). All three are also built on the
<span class="pkg">emmeans</span> package, so reading its documentation (for instance for
<code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> and <code><a href="emmeans.html#topic+emtrends">emmeans::emtrends()</a></code>) is recommended to understand
the idea behind these types of procedures.
</p>

<ul>
<li><p> Model-based <strong>predictions</strong> is the basis for all that follows. Indeed,
the first thing to understand is how models can be used to make predictions
(see <code><a href="#topic+estimate_link">estimate_link()</a></code>). This corresponds to the predicted response (or
&quot;outcome variable&quot;) given specific predictor values of the predictors (i.e.,
given a specific data configuration). This is why the concept of <code><a href="#topic+visualisation_matrix">reference grid()</a></code> is so important for direct predictions.
</p>
</li>
<li> <p><strong>Marginal &quot;means&quot;</strong>, obtained via <code><a href="#topic+estimate_means">estimate_means()</a></code>, are an extension
of such predictions, allowing to &quot;average&quot; (collapse) some of the predictors,
to obtain the average response value at a specific predictors configuration.
This is typically used when some of the predictors of interest are factors.
Indeed, the parameters of the model will usually give you the intercept value
and then the &quot;effect&quot; of each factor level (how different it is from the
intercept). Marginal means can be used to directly give you the mean value of
the response variable at all the levels of a factor. Moreover, it can also be
used to control, or average over predictors, which is useful in the case of
multiple predictors with or without interactions.
</p>
</li>
<li> <p><strong>Marginal contrasts</strong>, obtained via <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>, are
themselves at extension of marginal means, in that they allow to investigate
the difference (i.e., the contrast) between the marginal means. This is,
again, often used to get all pairwise differences between all levels of a
factor. It works also for continuous predictors, for instance one could also
be interested in whether the difference at two extremes of a continuous
predictor is significant.
</p>
</li>
<li><p> Finally, <strong>marginal effects</strong>, obtained via <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>, are
different in that their focus is not values on the response variable, but the
model's parameters. The idea is to assess the effect of a predictor at a
specific configuration of the other predictors. This is relevant in the case
of interactions or non-linear relationships, when the effect of a predictor
variable changes depending on the other predictors. Moreover, these effects
can also be &quot;averaged&quot; over other predictors, to get for instance the
&quot;general trend&quot; of a predictor over different factor levels.
</p>
</li></ul>

<p><strong>Example:</strong> Let's imagine the following model <code>lm(y ~ condition * x)</code> where
<code>condition</code> is a factor with 3 levels A, B and C and <code>x</code> a continuous
variable (like age for example). One idea is to see how this model performs,
and compare the actual response y to the one predicted by the model (using
<code><a href="#topic+estimate_response">estimate_response()</a></code>). Another idea is evaluate the average mean at each of
the condition's levels (using <code><a href="#topic+estimate_means">estimate_means()</a></code>), which can be useful to
visualize them. Another possibility is to evaluate the difference between
these levels (using <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>). Finally, one could also estimate
the effect of x averaged over all conditions, or instead within each
condition (<code>using [estimate_slopes]</code>).
</p>


<h3>Value</h3>

<p>A data frame of estimated marginal means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(modelbased)

# Frequentist models
# -------------------
model &lt;- lm(Petal.Length ~ Sepal.Width * Species, data = iris)

estimate_means(model)
estimate_means(model, fixed = "Sepal.Width")
estimate_means(model, at = c("Species", "Sepal.Width"), length = 2)
estimate_means(model, at = "Species=c('versicolor', 'setosa')")
estimate_means(model, at = "Sepal.Width=c(2, 4)")
estimate_means(model, at = c("Species", "Sepal.Width=0"))
estimate_means(model, at = "Sepal.Width", length = 5)
estimate_means(model, at = "Sepal.Width=c(2, 4)")

# Methods that can be applied to it:
means &lt;- estimate_means(model, fixed = "Sepal.Width")


plot(means) # which runs visualisation_recipe()

standardize(means)



data &lt;- iris
data$Petal.Length_factor &lt;- ifelse(data$Petal.Length &lt; 4.2, "A", "B")

model &lt;- lmer(Petal.Length ~ Sepal.Width + Species + (1 | Petal.Length_factor), data = data)
estimate_means(model)
estimate_means(model, at = "Sepal.Width", length = 3)


</code></pre>

<hr>
<h2 id='estimate_slopes'>Estimate Marginal Effects</h2><span id='topic+estimate_slopes'></span>

<h3>Description</h3>

<p>Estimate the slopes (i.e., the coefficient) of a predictor over or within
different factor levels, or alongside a numeric variable . In other words, to
assess the effect of a predictor <em>at</em> specific configurations data. Other
related functions based on marginal estimations includes
<code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code> and <code><a href="#topic+estimate_means">estimate_means()</a></code>.
<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_slopes(model, trend = NULL, at = NULL, ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_slopes_+3A_model">model</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="estimate_slopes_+3A_trend">trend</code></td>
<td>
<p>A character indicating the name of the variable
for which to compute the slopes.</p>
</td></tr>
<tr><td><code id="estimate_slopes_+3A_at">at</code></td>
<td>
<p>The predictor variable(s) <em>at</em> which to evaluate the desired effect
/ mean / contrasts. Other predictors of the model that are not included
here will be collapsed and &quot;averaged&quot; over (the effect will be estimated
across them).</p>
</td></tr>
<tr><td><code id="estimate_slopes_+3A_ci">ci</code></td>
<td>
<p>Confidence Interval (CI) level. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="estimate_slopes_+3A_...">...</code></td>
<td>
<p>Other arguments passed for instance to <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <strong>Details</strong> section below, and don't forget to also check out the
<a href="https://easystats.github.io/modelbased/articles/estimate_slopes.html">Vignettes</a>
and <a href="https://easystats.github.io/modelbased/index.html#features">README examples</a> for
various examples, tutorials and use cases.
</p>
<p>The <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>, <code><a href="#topic+estimate_means">estimate_means()</a></code> and <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>
functions are forming a group, as they are all based on <em>marginal</em>
estimations (estimations based on a model). All three are also built on the
<span class="pkg">emmeans</span> package, so reading its documentation (for instance for
<code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code> and <code><a href="emmeans.html#topic+emtrends">emmeans::emtrends()</a></code>) is recommended to understand
the idea behind these types of procedures.
</p>

<ul>
<li><p> Model-based <strong>predictions</strong> is the basis for all that follows. Indeed,
the first thing to understand is how models can be used to make predictions
(see <code><a href="#topic+estimate_link">estimate_link()</a></code>). This corresponds to the predicted response (or
&quot;outcome variable&quot;) given specific predictor values of the predictors (i.e.,
given a specific data configuration). This is why the concept of <code><a href="#topic+visualisation_matrix">reference grid()</a></code> is so important for direct predictions.
</p>
</li>
<li> <p><strong>Marginal &quot;means&quot;</strong>, obtained via <code><a href="#topic+estimate_means">estimate_means()</a></code>, are an extension
of such predictions, allowing to &quot;average&quot; (collapse) some of the predictors,
to obtain the average response value at a specific predictors configuration.
This is typically used when some of the predictors of interest are factors.
Indeed, the parameters of the model will usually give you the intercept value
and then the &quot;effect&quot; of each factor level (how different it is from the
intercept). Marginal means can be used to directly give you the mean value of
the response variable at all the levels of a factor. Moreover, it can also be
used to control, or average over predictors, which is useful in the case of
multiple predictors with or without interactions.
</p>
</li>
<li> <p><strong>Marginal contrasts</strong>, obtained via <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>, are
themselves at extension of marginal means, in that they allow to investigate
the difference (i.e., the contrast) between the marginal means. This is,
again, often used to get all pairwise differences between all levels of a
factor. It works also for continuous predictors, for instance one could also
be interested in whether the difference at two extremes of a continuous
predictor is significant.
</p>
</li>
<li><p> Finally, <strong>marginal effects</strong>, obtained via <code><a href="#topic+estimate_slopes">estimate_slopes()</a></code>, are
different in that their focus is not values on the response variable, but the
model's parameters. The idea is to assess the effect of a predictor at a
specific configuration of the other predictors. This is relevant in the case
of interactions or non-linear relationships, when the effect of a predictor
variable changes depending on the other predictors. Moreover, these effects
can also be &quot;averaged&quot; over other predictors, to get for instance the
&quot;general trend&quot; of a predictor over different factor levels.
</p>
</li></ul>

<p><strong>Example:</strong> Let's imagine the following model <code>lm(y ~ condition * x)</code> where
<code>condition</code> is a factor with 3 levels A, B and C and <code>x</code> a continuous
variable (like age for example). One idea is to see how this model performs,
and compare the actual response y to the one predicted by the model (using
<code><a href="#topic+estimate_response">estimate_response()</a></code>). Another idea is evaluate the average mean at each of
the condition's levels (using <code><a href="#topic+estimate_means">estimate_means()</a></code>), which can be useful to
visualize them. Another possibility is to evaluate the difference between
these levels (using <code><a href="#topic+estimate_contrasts">estimate_contrasts()</a></code>). Finally, one could also estimate
the effect of x averaged over all conditions, or instead within each
condition (<code>using [estimate_slopes]</code>).
</p>


<h3>Value</h3>

<p>A data.frame of class <code>estimate_slopes</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get an idea of the data
ggplot(iris, aes(x = Petal.Length, y = Sepal.Width)) +
  geom_point(aes(color = Species)) +
  geom_smooth(color = "black", se = FALSE) +
  geom_smooth(aes(color = Species), linetype = "dotted", se = FALSE) +
  geom_smooth(aes(color = Species), method = "lm", se = FALSE)

# Model it
model &lt;- lm(Sepal.Width ~ Species * Petal.Length, data = iris)
# Compute the marginal effect of Petal.Length at each level of Species
slopes &lt;- estimate_slopes(model, trend = "Petal.Length", at = "Species")
slopes

# Plot it
plot(slopes)

standardize(slopes)


model &lt;- mgcv::gam(Sepal.Width ~ s(Petal.Length), data = iris)
slopes &lt;- estimate_slopes(model, at = "Petal.Length", length = 50)
summary(slopes)
plot(slopes)

model &lt;- mgcv::gam(Sepal.Width ~ s(Petal.Length, by = Species), data = iris)
slopes &lt;- estimate_slopes(model,
  trend = "Petal.Length",
  at = c("Petal.Length", "Species"), length = 20
)
summary(slopes)
plot(slopes)

</code></pre>

<hr>
<h2 id='find_inversions'>Find points of inversion</h2><span id='topic+find_inversions'></span>

<h3>Description</h3>

<p>Find points of inversion of a curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_inversions(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_inversions_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of inversion points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(seq(0, 4 * pi, length.out = 100))
plot(x, type = "b")
find_inversions(x)
</code></pre>

<hr>
<h2 id='get_emcontrasts'>Easy 'emmeans' and 'emtrends'</h2><span id='topic+get_emcontrasts'></span><span id='topic+model_emcontrasts'></span><span id='topic+get_emmeans'></span><span id='topic+model_emmeans'></span><span id='topic+get_emtrends'></span><span id='topic+model_emtrends'></span>

<h3>Description</h3>

<p>The <code>get_emmeans()</code> function is a wrapper to facilitate the usage of
<code>emmeans::emmeans()</code> and <code>emmeans::emtrends()</code>, providing a somewhat simpler
and intuitive API to find the specifications and variables of interest. It is
meanly made to for the developers to facilitate the organization and
debugging, and end-users should rather use the <code style="white-space: pre;">&#8288;estimate_*()&#8288;</code> series of
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_emcontrasts(
  model,
  contrast = NULL,
  at = NULL,
  fixed = NULL,
  transform = "none",
  method = "pairwise",
  ...
)

model_emcontrasts(
  model,
  contrast = NULL,
  at = NULL,
  fixed = NULL,
  transform = "none",
  method = "pairwise",
  ...
)

get_emmeans(
  model,
  at = "auto",
  fixed = NULL,
  transform = "response",
  levels = NULL,
  modulate = NULL,
  ...
)

model_emmeans(
  model,
  at = "auto",
  fixed = NULL,
  transform = "response",
  levels = NULL,
  modulate = NULL,
  ...
)

get_emtrends(
  model,
  trend = NULL,
  at = NULL,
  fixed = NULL,
  levels = NULL,
  modulate = NULL,
  ...
)

model_emtrends(
  model,
  trend = NULL,
  at = NULL,
  fixed = NULL,
  levels = NULL,
  modulate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_emcontrasts_+3A_model">model</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_contrast">contrast</code></td>
<td>
<p>A character vector indicating the name of the variable(s)
for which to compute the contrasts.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_at">at</code></td>
<td>
<p>The predictor variable(s) <em>at</em> which to evaluate the desired effect
/ mean / contrasts. Other predictors of the model that are not included
here will be collapsed and &quot;averaged&quot; over (the effect will be estimated
across them).</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_fixed">fixed</code></td>
<td>
<p>A character vector indicating the names of the predictors to be
&quot;fixed&quot; (i.e., maintained), so that the estimation is made at these values.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_transform">transform</code></td>
<td>
<p>Is passed to the <code>type</code> argument in
<code>emmeans::emmeans()</code>. See
<a href="https://CRAN.R-project.org/package=emmeans/vignettes/transformations.html">this vignette</a>.
Can be <code>"none"</code> (default for contrasts), <code>"response"</code>
(default for means), <code>"mu"</code>, <code>"unlink"</code>, <code>"log"</code>.
<code>"none"</code> will leave the values on scale of the linear predictors.
<code>"response"</code> will transform them on scale of the response variable.
Thus for a logistic model, <code>"none"</code> will give estimations expressed in
log-odds (probabilities on logit scale) and <code>"response"</code> in terms of
probabilities.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_method">method</code></td>
<td>
<p>Contrast method. See same argument in <a href="emmeans.html#topic+contrast">emmeans::contrast</a>.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_...">...</code></td>
<td>
<p>Other arguments passed for instance to <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_levels">levels</code>, <code id="get_emcontrasts_+3A_modulate">modulate</code></td>
<td>
<p>Deprecated, use <code>at</code> instead.</p>
</td></tr>
<tr><td><code id="get_emcontrasts_+3A_trend">trend</code></td>
<td>
<p>A character indicating the name of the variable
for which to compute the slopes.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("emmeans", quietly = TRUE)) {
  # Basic usage
  model &lt;- lm(Sepal.Width ~ Species, data = iris)
  get_emcontrasts(model)

  # Dealing with interactions
  model &lt;- lm(Sepal.Width ~ Species * Petal.Width, data = iris)
  # By default: selects first factor
  get_emcontrasts(model)
  # Can also run contrasts between points of numeric
  get_emcontrasts(model, contrast = "Petal.Width", length = 3)
  # Or both
  get_emcontrasts(model, contrast = c("Species", "Petal.Width"), length = 2)
  # Or with custom specifications
  estimate_contrasts(model, contrast = c("Species", "Petal.Width=c(1, 2)"))
  # Can fixate the numeric at a specific value
  get_emcontrasts(model, fixed = "Petal.Width")
  # Or modulate it
  get_emcontrasts(model, at = "Petal.Width", length = 4)
}
model &lt;- lm(Sepal.Length ~ Species + Petal.Width, data = iris)

if (require("emmeans", quietly = TRUE)) {
  # By default, 'at' is set to "Species"
  get_emmeans(model)

  # Overall mean (close to 'mean(iris$Sepal.Length)')
  get_emmeans(model, at = NULL)

  # One can estimate marginal means at several values of a 'modulate' variable
  get_emmeans(model, at = "Petal.Width", length = 3)

  # Interactions
  model &lt;- lm(Sepal.Width ~ Species * Petal.Length, data = iris)

  get_emmeans(model)
  get_emmeans(model, at = c("Species", "Petal.Length"), length = 2)
  get_emmeans(model, at = c("Species", "Petal.Length = c(1, 3, 5)"), length = 2)
}
if (require("emmeans")) {
  model &lt;- lm(Sepal.Width ~ Species * Petal.Length, data = iris)

  get_emtrends(model)
  get_emtrends(model, at = "Species")
  get_emtrends(model, at = "Petal.Length")
  get_emtrends(model, at = c("Species", "Petal.Length"))

  model &lt;- lm(Petal.Length ~ poly(Sepal.Width, 4), data = iris)
  get_emtrends(model)
  get_emtrends(model, at = "Sepal.Width")
}
</code></pre>

<hr>
<h2 id='get_marginaleffects'>Easy marginaleffects</h2><span id='topic+get_marginaleffects'></span>

<h3>Description</h3>

<p>Modelbased-like API to create <span class="pkg">marginaleffects</span> objects. This is
Work-in-progress.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_marginaleffects(model, trend = NULL, at = NULL, fixed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_marginaleffects_+3A_model">model</code></td>
<td>
<p>A statistical model.</p>
</td></tr>
<tr><td><code id="get_marginaleffects_+3A_trend">trend</code></td>
<td>
<p>A character indicating the name of the variable
for which to compute the slopes.</p>
</td></tr>
<tr><td><code id="get_marginaleffects_+3A_at">at</code></td>
<td>
<p>The predictor variable(s) <em>at</em> which to evaluate the desired effect
/ mean / contrasts. Other predictors of the model that are not included
here will be collapsed and &quot;averaged&quot; over (the effect will be estimated
across them).</p>
</td></tr>
<tr><td><code id="get_marginaleffects_+3A_fixed">fixed</code></td>
<td>
<p>A character vector indicating the names of the predictors to be
&quot;fixed&quot; (i.e., maintained), so that the estimation is made at these values.</p>
</td></tr>
<tr><td><code id="get_marginaleffects_+3A_...">...</code></td>
<td>
<p>Other arguments passed for instance to <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("marginaleffects")) {
  model &lt;- lm(Sepal.Width ~ Species * Petal.Length, data = iris)

  get_marginaleffects(model, trend = "Petal.Length", at = "Species")
  get_marginaleffects(model, trend = "Petal.Length", at = "Petal.Length")
  get_marginaleffects(model, trend = "Petal.Length", at = c("Species", "Petal.Length"))
}
</code></pre>

<hr>
<h2 id='modelbased-package'>modelbased: Estimation of Model-Based Predictions, Contrasts and Means</h2><span id='topic+modelbased-package'></span><span id='topic+modelbased'></span>

<h3>Description</h3>

<p><code>modelbased</code> is a package helping with model-based estimations, to
easily compute of marginal means, contrast analysis and model predictions.
</p>


<h3>Details</h3>

<p><code>modelbased</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dominique Makowski <a href="mailto:dom.makowski@gmail.com">dom.makowski@gmail.com</a> (<a href="https://orcid.org/0000-0001-5375-9967">ORCID</a>) (@Dom_Makowski)
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel LÃ¼decke <a href="mailto:d.luedecke@uke.de">d.luedecke@uke.de</a> (<a href="https://orcid.org/0000-0002-8895-3206">ORCID</a>) (@strengejacke)
</p>
</li>
<li><p> Mattan S. Ben-Shachar <a href="mailto:matanshm@post.bgu.ac.il">matanshm@post.bgu.ac.il</a> (<a href="https://orcid.org/0000-0002-4287-4801">ORCID</a>) (@mattansb)
</p>
</li>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://easystats.github.io/modelbased/">https://easystats.github.io/modelbased/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/easystats/modelbased/issues">https://github.com/easystats/modelbased/issues</a>
</p>
</li></ul>


<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+visualisation_recipe'></span><span id='topic+standardize'></span><span id='topic+unstandardize'></span><span id='topic+print_md'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>datawizard</dt><dd><p><code><a href="datawizard.html#topic+standardize">standardize</a></code>, <code><a href="datawizard.html#topic+standardize">unstandardize</a></code>, <code><a href="datawizard.html#topic+visualisation_recipe">visualisation_recipe</a></code></p>
</dd>
<dt>insight</dt><dd><p><code><a href="insight.html#topic+display">print_md</a></code></p>
</dd>
</dl>

<hr>
<h2 id='smoothing'>Smoothing a vector or a time series</h2><span id='topic+smoothing'></span>

<h3>Description</h3>

<p>Smoothing a vector or a time series. For data.frames, the function will
smooth all numeric variables stratified by factor levels (i.e., will smooth
within each factor level combination).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothing(x, method = "loess", strength = 0.25, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothing_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_method">method</code></td>
<td>
<p>Can be <a href="stats.html#topic+loess">&quot;loess&quot;</a> (default) or
<a href="stats.html#topic+smooth">&quot;smooth&quot;</a>. A loess smoothing can be slow.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_strength">strength</code></td>
<td>
<p>This argument only applies when <code>method = "loess"</code>.
Degree of smoothing passed to <code>span</code> (see <code><a href="stats.html#topic+loess">loess()</a></code>).</p>
</td></tr>
<tr><td><code id="smoothing_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A smoothed vector or data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(seq(0, 4 * pi, length.out = 100)) + rnorm(100, 0, 0.2)
plot(x, type = "l")
lines(smoothing(x, method = "smooth"), type = "l", col = "blue")
lines(smoothing(x, method = "loess"), type = "l", col = "red")

x &lt;- sin(seq(0, 4 * pi, length.out = 10000)) + rnorm(10000, 0, 0.2)
plot(x, type = "l")
lines(smoothing(x, method = "smooth"), type = "l", col = "blue")
lines(smoothing(x, method = "loess"), type = "l", col = "red")
</code></pre>

<hr>
<h2 id='visualisation_matrix'>Create a reference grid</h2><span id='topic+visualisation_matrix'></span><span id='topic+visualisation_matrix.data.frame'></span><span id='topic+visualisation_matrix.numeric'></span><span id='topic+visualisation_matrix.factor'></span>

<h3>Description</h3>

<p>This function is an alias (another name) for the <code><a href="insight.html#topic+get_datagrid">insight::get_datagrid()</a></code>
function. Same arguments apply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualisation_matrix(x, ...)

## S3 method for class 'data.frame'
visualisation_matrix(
  x,
  at = "all",
  target = NULL,
  factors = "reference",
  numerics = "mean",
  preserve_range = FALSE,
  reference = x,
  ...
)

## S3 method for class 'numeric'
visualisation_matrix(x, ...)

## S3 method for class 'factor'
visualisation_matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualisation_matrix_+3A_x">x</code></td>
<td>
<p>An object from which to construct the reference grid.</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods (for instance, <code>length</code>
or <code>range</code> to control the spread of numeric variables.).</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_at">at</code></td>
<td>
<p>Indicates the <em>focal predictors</em> (variables) for the reference grid
and at which values focal predictors should be represented. If not specified
otherwise, representative values for numeric variables or predictors are
evenly distributed from the minimum to the maximum, with a total number of
<code>length</code> values covering that range (see 'Examples'). Possible options for
<code>at</code> are:
</p>

<ul>
<li> <p><code>"all"</code>, which will include all variables or predictors.
</p>
</li>
<li><p> a character vector of one or more variable or predictor names, like
<code>c("Species", "Sepal.Width")</code>, which will create a grid of all combinations
of unique values. For factors, will use all levels, for numeric variables,
will use a range of length <code>length</code> (evenly spread from minimum to maximum)
and for character vectors, will use all unique values.
</p>
</li>
<li><p> a list of named elements, indicating focal predictors and their representative
values, e.g. <code>at = list(Sepal.Length = c(2, 4), Species = "setosa")</code>.
</p>
</li>
<li><p> a string with assignments, e.g. <code>at = "Sepal.Length = 2"</code> or
<code>at = c("Sepal.Length = 2", "Species = 'setosa'")</code> - note the usage of single
and double quotes to assign strings within strings.
</p>
</li></ul>

<p>There is a special handling of assignments with <em>brackets</em>, i.e. values
defined inside <code>[</code> and <code style="white-space: pre;">&#8288;]&#8288;</code>.For <strong>numeric</strong> variables, the value(s) inside
the brackets should either be
</p>

<ul>
<li><p> two values, indicating minimum and maximum (e.g. <code>at = "Sepal.Length = [0, 5]"</code>),
for which a range of length <code>length</code> (evenly spread from given minimum to
maximum) is created.
</p>
</li>
<li><p> more than two numeric values <code>at = "Sepal.Length = [2,3,4,5]"</code>, in which
case these values are used as representative values.
</p>
</li>
<li><p> a &quot;token&quot; that creates pre-defined representative values:
</p>

<ul>
<li><p> for mean and -/+ 1 SD around the mean: <code>"x = [sd]"</code>
</p>
</li>
<li><p> for median and -/+ 1 MAD around the median: <code>"x = [mad]"</code>
</p>
</li>
<li><p> for Tukey's five number summary (minimum, lower-hinge, median, upper-hinge, maximum): <code>"x = [fivenum]"</code>
</p>
</li>
<li><p> for terciles, including minimum and maximum: <code>"x = [terciles]"</code>
</p>
</li>
<li><p> for terciles, excluding minimum and maximum: <code>"x = [terciles2]"</code>
</p>
</li>
<li><p> for quartiles, including minimum and maximum: <code>"x = [quartiles]"</code>
</p>
</li>
<li><p> for quartiles, excluding minimum and maximum: <code>"x = [quartiles2]"</code>
</p>
</li>
<li><p> for minimum and maximum value: <code>"x = [minmax]"</code>
</p>
</li>
<li><p> for 0 and the maximum value: <code>"x = [zeromax]"</code>
</p>
</li></ul>

</li></ul>

<p>For <strong>factor</strong> variables, the value(s) inside the brackets should indicate
one or more factor levels, like <code>at = "Species = [setosa, versicolor]"</code>.
<strong>Note</strong>: the <code>length</code> argument will be ignored when using brackets-tokens.
</p>
<p>The remaining variables not specified in <code>at</code> will be fixed (see also arguments
<code>factors</code> and <code>numerics</code>).</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_target">target</code></td>
<td>
<p>Deprecated name. Please use <code>at</code> instead.</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_factors">factors</code></td>
<td>
<p>Type of summary for factors. Can be <code>"reference"</code> (set at the
reference level), <code>"mode"</code> (set at the most common level) or <code>"all"</code> to
keep all levels.</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_numerics">numerics</code></td>
<td>
<p>Type of summary for numeric values. Can be <code>"all"</code> (will
duplicate the grid for all unique values), any function (<code>"mean"</code>,
<code>"median"</code>, ...) or a value (e.g., <code>numerics = 0</code>).</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_preserve_range">preserve_range</code></td>
<td>
<p>In the case of combinations between numeric variables
and factors, setting <code>preserve_range = TRUE</code> will drop the observations
where the value of the numeric variable is originally not present in the
range of its factor level. This leads to an unbalanced grid. Also, if you
want the minimum and the maximum to closely match the actual ranges, you
should increase the <code>length</code> argument.</p>
</td></tr>
<tr><td><code id="visualisation_matrix_+3A_reference">reference</code></td>
<td>
<p>The reference vector from which to compute the mean and SD.
Used when standardizing or unstandardizing the grid using <code>effectsize::standardize</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reference grid data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(modelbased)

# Add one row to change the "mode" of Species
data &lt;- rbind(iris, iris[149, ], make.row.names = FALSE)

# Single variable is of interest; all others are "fixed"
visualisation_matrix(data, at = "Sepal.Length")
visualisation_matrix(data, at = "Sepal.Length", length = 3)
visualisation_matrix(data, at = "Sepal.Length", range = "ci", ci = 0.90)
visualisation_matrix(data, at = "Sepal.Length", factors = "mode")

# Multiple variables are of interest, creating a combination
visualisation_matrix(data, at = c("Sepal.Length", "Species"), length = 3)
visualisation_matrix(data, at = c(1, 3), length = 3)
visualisation_matrix(data, at = c("Sepal.Length", "Species"), preserve_range = TRUE)
visualisation_matrix(data, at = c("Sepal.Length", "Species"), numerics = 0)
visualisation_matrix(data, at = c("Sepal.Length = 3", "Species"))
visualisation_matrix(data, at = c("Sepal.Length = c(3, 1)", "Species = 'setosa'"))

# with list-style at-argument
visualisation_matrix(data, at = list(Sepal.Length = c(1, 3), Species = "setosa"))

# Standardize
vizdata &lt;- visualisation_matrix(data, at = "Sepal.Length")
standardize(vizdata)
</code></pre>

<hr>
<h2 id='visualisation_recipe.estimate_grouplevel'>Visualisation Recipe for 'modelbased' Objects</h2><span id='topic+visualisation_recipe.estimate_grouplevel'></span><span id='topic+visualisation_recipe.estimate_means'></span><span id='topic+visualisation_recipe.estimate_predicted'></span><span id='topic+visualisation_recipe.estimate_slopes'></span>

<h3>Description</h3>

<p>Visualisation Recipe for 'modelbased' Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate_grouplevel'
visualisation_recipe(
  x,
  hline = NULL,
  pointrange = NULL,
  facet_wrap = NULL,
  labs = NULL,
  ...
)

## S3 method for class 'estimate_means'
visualisation_recipe(
  x,
  show_data = "jitter",
  point = NULL,
  jitter = point,
  boxplot = NULL,
  violin = NULL,
  line = NULL,
  pointrange = NULL,
  labs = NULL,
  ...
)

## S3 method for class 'estimate_predicted'
visualisation_recipe(
  x,
  show_data = "points",
  point = NULL,
  density_2d = NULL,
  line = NULL,
  ribbon = NULL,
  labs = NULL,
  ...
)

## S3 method for class 'estimate_slopes'
visualisation_recipe(
  x,
  hline = NULL,
  line = NULL,
  pointrange = NULL,
  ribbon = NULL,
  labs = NULL,
  facet_wrap = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualisation_recipe.estimate_grouplevel_+3A_x">x</code></td>
<td>
<p>A modelbased object.</p>
</td></tr>
<tr><td><code id="visualisation_recipe.estimate_grouplevel_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other functions.</p>
</td></tr>
<tr><td><code id="visualisation_recipe.estimate_grouplevel_+3A_show_data">show_data</code></td>
<td>
<p>Display the &quot;raw&quot; data as a background to the model-based
estimation. Can be set to <code>"none"</code> to remove it. When input is the result
of <code>estimate_means</code>, <code>show_data</code> can be &quot;points&quot; (the jittered observation
points), &quot;boxplot&quot;, &quot;violin&quot; a combination of them (see examples). When
input is the result of <code>estimate_response</code> or <code>estimate_relation</code>,
<code>show_data</code> can be &quot;points&quot; (the points of the original data corresponding
to the x and y axes), &quot;density_2d&quot;, &quot;density_2d_filled&quot;,
&quot;density_2d_polygon&quot; or &quot;density_2d_raster&quot;.</p>
</td></tr>
<tr><td><code id="visualisation_recipe.estimate_grouplevel_+3A_point">point</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_jitter">jitter</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_boxplot">boxplot</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_violin">violin</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_pointrange">pointrange</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_density_2d">density_2d</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_line">line</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_hline">hline</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_ribbon">ribbon</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_labs">labs</code>, <code id="visualisation_recipe.estimate_grouplevel_+3A_facet_wrap">facet_wrap</code></td>
<td>
<p>Additional
aesthetics and parameters for the geoms (see customization example).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># ==============================================
# estimate_grouplevel
# ==============================================
if (require("see") &amp;&amp; require("lme4")) {
  data &lt;- lme4::sleepstudy
  data &lt;- rbind(data, data)
  data$Newfactor &lt;- rep(c("A", "B", "C", "D"))

  # 1 random intercept
  model &lt;- lmer(Reaction ~ Days + (1 | Subject), data = data)
  x &lt;- estimate_grouplevel(model)
  layers &lt;- visualisation_recipe(x)
  layers
  plot(layers)
}

if (require("see") &amp;&amp; require("lme4")) {
  # 2 random intercepts
  model &lt;- lmer(Reaction ~ Days + (1 | Subject) + (1 | Newfactor), data = data)
  x &lt;- estimate_grouplevel(model)
  plot(visualisation_recipe(x))


  model &lt;- lmer(Reaction ~ Days + (1 + Days | Subject) + (1 | Newfactor), data = data)
  x &lt;- estimate_grouplevel(model)
  plot(visualisation_recipe(x))
}


# Simple Model ---------------
x &lt;- estimate_means(lm(Sepal.Width ~ Species, data = iris))
layers &lt;- visualisation_recipe(x)
layers
plot(layers)

# Customize aesthetics
layers &lt;- visualisation_recipe(x,
  jitter = list(width = 0.03, color = "red"),
  line = list(linetype = "dashed")
)
plot(layers)

# Customize raw data
plot(visualisation_recipe(x, show_data = c("violin", "boxplot", "jitter")))

# Two levels ---------------
data &lt;- mtcars
data$cyl &lt;- as.factor(data$cyl)
data$new_factor &lt;- as.factor(rep(c("A", "B"), length.out = nrow(mtcars)))

model &lt;- lm(mpg ~ new_factor * cyl * wt, data = data)
x &lt;- estimate_means(model, at = c("new_factor", "cyl"))
plot(visualisation_recipe(x))

# Modulations --------------
x &lt;- estimate_means(model, at = c("new_factor", "wt"))
plot(visualisation_recipe(x))

# x &lt;- estimate_means(model, at = c("new_factor", "cyl", "wt"))
# plot(visualisation_recipe(x))  # TODO: broken

#'   # GLMs ---------------------
data &lt;- data.frame(vs = mtcars$vs, cyl = as.factor(mtcars$cyl))
x &lt;- estimate_means(glm(vs ~ cyl, data = data, family = "binomial"))
plot(visualisation_recipe(x))


# ==============================================
# estimate_relation, estimate_response, ...
# ==============================================
if (require("ggplot2")) {
  # Simple Model ---------------
  x &lt;- estimate_relation(lm(mpg ~ wt, data = mtcars))
  layers &lt;- visualisation_recipe(x)
  layers
  plot(layers)
}

if (require("ggplot2")) {
  # Customize aesthetics ----------

  layers &lt;- visualisation_recipe(x,
    point = list(color = "red", alpha = 0.6, size = 3),
    line = list(color = "blue", size = 3),
    ribbon = list(fill = "green", alpha = 0.7),
    labs = list(subtitle = "Oh yeah!")
  )
  layers
  plot(layers)

  # Customize raw data -------------

  plot(visualisation_recipe(x, show_data = "none"))
  plot(visualisation_recipe(x, show_data = c("density_2d", "points")))
  plot(visualisation_recipe(x, show_data = "density_2d_filled"))
  plot(visualisation_recipe(x, show_data = "density_2d_polygon"))
  plot(visualisation_recipe(x, show_data = "density_2d_raster")) +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))

  # Single predictors examples -----------

  plot(estimate_relation(lm(Sepal.Length ~ Sepal.Width, data = iris)))
  plot(estimate_relation(lm(Sepal.Length ~ Species, data = iris)))

  # 2-ways interaction ------------

  # Numeric * numeric
  x &lt;- estimate_relation(lm(mpg ~ wt * qsec, data = mtcars))
  layers &lt;- visualisation_recipe(x)
  plot(layers)

  # Numeric * factor
  x &lt;- estimate_relation(lm(Sepal.Width ~ Sepal.Length * Species, data = iris))
  layers &lt;- visualisation_recipe(x)
  plot(layers)

  # Factor * numeric
  x &lt;- estimate_relation(lm(Sepal.Width ~ Species * Sepal.Length, data = iris))
  layers &lt;- visualisation_recipe(x)
  plot(layers)

  # 3-ways interaction ------------

  data &lt;- mtcars
  data$vs &lt;- as.factor(data$vs)
  data$cyl &lt;- as.factor(data$cyl)
  data$new_factor &lt;- as.factor(rep(c("A", "B"), length.out = nrow(mtcars)))

  # Numeric * numeric * numeric
  x &lt;- estimate_relation(lm(mpg ~ wt * qsec * hp, data = data), length = c(5, 3, 20))
  layers &lt;- visualisation_recipe(x)
  plot(layers)

  # Numeric * numeric * factor
  x &lt;- estimate_relation(lm(mpg ~ wt * am * vs, data = data))
  layers &lt;- visualisation_recipe(x)
  plot(layers)

  # Numeric * factor * factor
  x &lt;- estimate_relation(lm(mpg ~ wt * cyl * new_factor, data = data))
  layers &lt;- visualisation_recipe(x)
  plot(layers)

  # Factor * numeric * numeric
  x &lt;- estimate_relation(lm(mpg ~ cyl * qsec * hp, data = data))
  layers &lt;- visualisation_recipe(x)
  plot(layers) +
    scale_size_continuous(range = c(0.2, 1))

  # GLMs ---------------------
  x &lt;- estimate_relation(glm(vs ~ mpg, data = mtcars, family = "binomial"))
  plot(visualisation_recipe(x))
  plot(visualisation_recipe(x, show_data = "jitter", point = list(height = 0.03)))

  # Multiple CIs ---------------------
  plot(estimate_relation(lm(mpg ~ disp, data = mtcars),
    ci = c(.50, .80, .95)
  ))
  plot(estimate_relation(lm(Sepal.Length ~ Species, data = iris),
    ci = c(0.5, 0.7, 0.95)
  ))
}

# Bayesian models ---------------------
if (require("ggplot2") &amp;&amp; require("rstanarm")) {
  model &lt;- rstanarm::stan_glm(mpg ~ wt, data = mtcars, refresh = 0)

  # Plot individual draws instead of regular ribbon
  x &lt;- estimate_relation(model, keep_iterations = 100)
  layers &lt;- visualisation_recipe(x, ribbon = list(color = "red"))
  plot(layers)

  model &lt;- rstanarm::stan_glm(Sepal.Width ~ Species * Sepal.Length, data = iris, refresh = 0)
  plot(estimate_relation(model, keep_iterations = 100))
}

# ==============================================
# estimate_slopes
# ==============================================
if (require("ggplot2")) {
  model &lt;- lm(Sepal.Width ~ Species * Petal.Length, data = iris)
  x &lt;- estimate_slopes(model, trend = "Petal.Length", at = "Species")

  layers &lt;- visualisation_recipe(x)
  layers
  plot(layers)

  model &lt;- lm(Petal.Length ~ poly(Sepal.Width, 4), data = iris)
  x &lt;- estimate_slopes(model, at = "Sepal.Width", length = 20)
  plot(visualisation_recipe(x))

  model &lt;- lm(Petal.Length ~ Species * poly(Sepal.Width, 3), data = iris)
  x &lt;- estimate_slopes(model, at = c("Sepal.Width", "Species"))
  plot(visualisation_recipe(x))
}

# TODO: fails with latest emmeans (1.8.0)
if (require("mgcv")) {
  data &lt;- iris
  data$Petal.Length &lt;- data$Petal.Length^2

  model &lt;- mgcv::gam(Sepal.Width ~ t2(Petal.Width, Petal.Length), data = data)
  x &lt;- estimate_slopes(model, at = c("Petal.Width", "Petal.Length"), length = 20)
  plot(visualisation_recipe(x))

  model &lt;- mgcv::gam(Sepal.Width ~ t2(Petal.Width, Petal.Length, by = Species), data = data)
  x &lt;- estimate_slopes(model, at = c("Petal.Width", "Petal.Length", "Species"), length = 10)
  plot(visualisation_recipe(x))
}

</code></pre>

<hr>
<h2 id='zero_crossings'>Find zero crossings of a vector</h2><span id='topic+zero_crossings'></span>

<h3>Description</h3>

<p>Find zero crossings of a vector, i.e., indices when the numeric variable
crosses 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_crossings(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_crossings_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of zero crossings.
</p>


<h3>See Also</h3>

<p>Based on the <code>uniroot.all</code> function from the rootSolve package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sin(seq(0, 4 * pi, length.out = 100))
plot(x)
zero_crossings(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
