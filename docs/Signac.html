<!DOCTYPE html><html><head><title>Help for package Signac</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Signac}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Signac-package'><p>Signac: Analysis of Single-Cell Chromatin Data</p></a></li>
<li><a href='#AccessiblePeaks'><p>Accessible peaks</p></a></li>
<li><a href='#AddChromatinModule'><p>Add chromatin module</p></a></li>
<li><a href='#AddMotifs'><p>Add DNA sequence motif information</p></a></li>
<li><a href='#AggregateTiles'><p>Quantify aggregated genome tiles</p></a></li>
<li><a href='#AlleleFreq'><p>Compute allele frequencies per cell</p></a></li>
<li><a href='#Annotation'><p>Annotation</p></a></li>
<li><a href='#AnnotationPlot'><p>Plot gene annotations</p></a></li>
<li><a href='#as.ChromatinAssay'><p>Convert objects to a ChromatinAssay</p></a></li>
<li><a href='#atac_small'><p>A small example scATAC-seq dataset</p></a></li>
<li><a href='#AverageCounts'><p>Average Counts</p></a></li>
<li><a href='#BigwigTrack'><p>Plot data from BigWig files</p></a></li>
<li><a href='#BinarizeCounts'><p>Binarize counts</p></a></li>
<li><a href='#blacklist_ce10'><p>Genomic blacklist regions for C. elegans ce10 (0-based)</p></a></li>
<li><a href='#blacklist_ce11'><p>Genomic blacklist regions for C. elegans ce11 (0-based)</p></a></li>
<li><a href='#blacklist_dm3'><p>Genomic blacklist regions for Drosophila dm3 (0-based)</p></a></li>
<li><a href='#blacklist_dm6'><p>Genomic blacklist regions for Drosophila dm6 (0-based)</p></a></li>
<li><a href='#blacklist_hg19'><p>Genomic blacklist regions for Human hg19 (0-based)</p></a></li>
<li><a href='#blacklist_hg38'><p>Genomic blacklist regions for Human GRCh38</p></a></li>
<li><a href='#blacklist_hg38_unified'><p>Unified genomic blacklist regions for Human GRCh38</p></a></li>
<li><a href='#blacklist_mm10'><p>Genomic blacklist regions for Mouse mm10 (0-based)</p></a></li>
<li><a href='#CallPeaks'><p>Call peaks</p></a></li>
<li><a href='#Cells.Fragment'><p>Set and get cell barcode information for a <code>Fragment</code> object</p></a></li>
<li><a href='#Cells+26lt+3B-'><p>Set and get cell barcode information for a Fragment object</p></a></li>
<li><a href='#CellsPerGroup'><p>Cells per group</p></a></li>
<li><a href='#ChromatinAssay-class'><p>The ChromatinAssay class</p></a></li>
<li><a href='#ClosestFeature'><p>Closest Feature</p></a></li>
<li><a href='#ClusterClonotypes'><p>Find relationships between clonotypes</p></a></li>
<li><a href='#CombineTracks'><p>Combine genome region plots</p></a></li>
<li><a href='#ConnectionsToLinks'><p>Cicero connections to links</p></a></li>
<li><a href='#ConvertMotifID'><p>Convert between motif name and motif ID</p></a></li>
<li><a href='#corSparse'><p>Sparse matrix correlation</p></a></li>
<li><a href='#CountFragments'><p>Count fragments</p></a></li>
<li><a href='#CountsInRegion'><p>Counts in region</p></a></li>
<li><a href='#coverage+2CChromatinAssay-method'><p>Coverage of a ChromatinAssay object</p></a></li>
<li><a href='#CoverageBrowser'><p>Genome browser</p></a></li>
<li><a href='#CoveragePlot'><p>Plot Tn5 insertion frequency over a region</p></a></li>
<li><a href='#CreateChromatinAssay'><p>Create ChromatinAssay object</p></a></li>
<li><a href='#CreateFragmentObject'><p>Create a Fragment object</p></a></li>
<li><a href='#CreateMotifMatrix'><p>Create motif matrix</p></a></li>
<li><a href='#CreateMotifObject'><p>Create motif object</p></a></li>
<li><a href='#DensityScatter'><p>Scatterplot colored by point density</p></a></li>
<li><a href='#DepthCor'><p>Plot sequencing depth correlation</p></a></li>
<li><a href='#DownsampleFeatures'><p>Downsample Features</p></a></li>
<li><a href='#ExpressionPlot'><p>Plot gene expression</p></a></li>
<li><a href='#Extend'><p>Extend</p></a></li>
<li><a href='#FeatureMatrix'><p>Feature Matrix</p></a></li>
<li><a href='#FilterCells'><p>Filter cells from fragment file</p></a></li>
<li><a href='#FindClonotypes'><p>Find clonotypes</p></a></li>
<li><a href='#FindMotifs'><p>FindMotifs</p></a></li>
<li><a href='#findOverlaps-methods'><p>Find overlapping ranges for ChromatinAssay objects</p></a></li>
<li><a href='#FindTopFeatures'><p>Find most frequently observed features</p></a></li>
<li><a href='#Footprint'><p>Transcription factor footprinting analysis</p></a></li>
<li><a href='#FractionCountsInRegion'><p>Fraction of counts in a genomic region</p></a></li>
<li><a href='#Fragment-class'><p>The Fragment class</p></a></li>
<li><a href='#FragmentHistogram'><p>Plot fragment length histogram</p></a></li>
<li><a href='#Fragments'><p>Get the Fragment objects</p></a></li>
<li><a href='#FRiP'><p>Calculate fraction of reads in peaks per cell</p></a></li>
<li><a href='#GeneActivity'><p>Create gene activity matrix</p></a></li>
<li><a href='#GenomeBinMatrix'><p>Genome bin matrix</p></a></li>
<li><a href='#GetCellsInRegion'><p>Get cells in a region</p></a></li>
<li><a href='#GetFootprintData'><p>Get footprinting data</p></a></li>
<li><a href='#GetFragmentData'><p>Get Fragment object data</p></a></li>
<li><a href='#GetGRangesFromEnsDb'><p>Extract genomic ranges from EnsDb object</p></a></li>
<li><a href='#GetIntersectingFeatures'><p>Find intersecting regions between two objects</p></a></li>
<li><a href='#GetLinkedGenes'><p>Get genes linked to peaks</p></a></li>
<li><a href='#GetLinkedPeaks'><p>Get peaks linked to genes</p></a></li>
<li><a href='#GetMotifData'><p>Retrieve a motif matrix</p></a></li>
<li><a href='#GetTSSPositions'><p>Find transcriptional start sites</p></a></li>
<li><a href='#granges-methods'><p>Access genomic ranges for ChromatinAssay objects</p></a></li>
<li><a href='#GRangesToString'><p>GRanges to String</p></a></li>
<li><a href='#head.Fragment'><p>Return the first rows of a fragment file</p></a></li>
<li><a href='#IdentifyVariants'><p>Identify mitochondrial variants</p></a></li>
<li><a href='#InsertionBias'><p>Compute Tn5 insertion bias</p></a></li>
<li><a href='#inter-range-methods'><p>Inter-range transformations for ChromatinAssay objects</p></a></li>
<li><a href='#IntersectMatrix'><p>Intersect genomic coordinates with matrix rows</p></a></li>
<li><a href='#Jaccard'><p>Calculate the Jaccard index between two matrices</p></a></li>
<li><a href='#LinkPeaks'><p>Link peaks to genes</p></a></li>
<li><a href='#LinkPlot'><p>Plot linked genomic elements</p></a></li>
<li><a href='#Links'><p>Get or set links information</p></a></li>
<li><a href='#LookupGeneCoords'><p>Get gene coordinates</p></a></li>
<li><a href='#MatchRegionStats'><p>Match DNA sequence characteristics</p></a></li>
<li><a href='#Motif-class'><p>The Motif class</p></a></li>
<li><a href='#MotifCounts'><p>Count fragments surrounding motif sites</p></a></li>
<li><a href='#MotifPlot'><p>Plot DNA sequence motif</p></a></li>
<li><a href='#Motifs'><p>Get or set a motif information</p></a></li>
<li><a href='#nearest-methods'><p>Find the nearest range neighbors for ChromatinAssay objects</p></a></li>
<li><a href='#NucleosomeSignal'><p>NucleosomeSignal</p></a></li>
<li><a href='#PeakPlot'><p>Plot peaks in a genomic region</p></a></li>
<li><a href='#PlotFootprint'><p>Plot motif footprinting results</p></a></li>
<li><a href='#ReadMGATK'><p>Read MGATK output</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#RegionHeatmap'><p>Region heatmap</p></a></li>
<li><a href='#RegionMatrix'><p>Region enrichment analysis</p></a></li>
<li><a href='#RegionPlot'><p>Region plot</p></a></li>
<li><a href='#RegionStats'><p>Compute base composition information for genomic ranges</p></a></li>
<li><a href='#RunChromVAR'><p>Run chromVAR</p></a></li>
<li><a href='#RunSVD'><p>Run singular value decomposition</p></a></li>
<li><a href='#RunTFIDF'><p>Compute the term-frequency inverse-document-frequency</p></a></li>
<li><a href='#seqinfo-methods'><p>Access and modify sequence information for ChromatinAssay objects</p></a></li>
<li><a href='#SetMotifData'><p>Set motif data</p></a></li>
<li><a href='#SplitFragments'><p>Split fragment file by cell identities</p></a></li>
<li><a href='#StringToGRanges'><p>String to GRanges</p></a></li>
<li><a href='#subset.Fragment'><p>Subset a Fragment object</p></a></li>
<li><a href='#subset.Motif'><p>Subset a Motif object</p></a></li>
<li><a href='#SubsetMatrix'><p>Subset matrix rows and columns</p></a></li>
<li><a href='#theme_browser'><p>Genome browser theme</p></a></li>
<li><a href='#TilePlot'><p>Plot integration sites per cell</p></a></li>
<li><a href='#TSSEnrichment'><p>Compute TSS enrichment score per cell</p></a></li>
<li><a href='#TSSPlot'><p>Plot signal enrichment around TSSs</p></a></li>
<li><a href='#UnifyPeaks'><p>Unify genomic ranges</p></a></li>
<li><a href='#UpdatePath'><p>Update the file path for a Fragment object</p></a></li>
<li><a href='#ValidateCells'><p>Validate cells present in fragment file</p></a></li>
<li><a href='#ValidateFragments'><p>Validate Fragment object</p></a></li>
<li><a href='#ValidateHash'><p>Validate hashes for Fragment object</p></a></li>
<li><a href='#VariantPlot'><p>Plot strand concordance vs. VMR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Analysis of Single-Cell Chromatin Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.13.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-02</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for the analysis and exploration of single-cell chromatin data.
    The 'Signac' package contains functions for quantifying single-cell chromatin data,
    computing per-cell quality control metrics, dimension reduction
    and normalization, visualization, and DNA sequence motif analysis.
    Reference: Stuart et al. (2021) &lt;<a href="https://doi.org/10.1038%2Fs41592-021-01282-5">doi:10.1038/s41592-021-01282-5</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/stuart-lab/signac">https://github.com/stuart-lab/signac</a>, <a href="https://stuartlab.org/signac">https://stuartlab.org/signac</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stuart-lab/signac/issues">https://github.com/stuart-lab/signac/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>GenomeInfoDb (&ge; 1.29.3), GenomicRanges, IRanges, Matrix,
Rsamtools, S4Vectors, SeuratObject (&ge; 4.0.0), data.table,
dplyr (&ge; 1.0.0), future, future.apply, ggplot2, rlang, irlba,
pbapply, tidyr, patchwork, stats, utils, BiocGenerics, stringi,
fastmatch, RcppRoll, scales, Rcpp, grid, tidyselect, vctrs,
lifecycle</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'data.R' 'differential_accessibility.R'
'generics.R' 'dimension_reduction.R' 'footprinting.R'
'fragments.R' 'genomeinfodb-methods.R' 'granges-methods.R'
'heatmaps.R' 'iranges-methods.R' 'links.R' 'mito.R' 'motifs.R'
'objects.R' 'peaks.R' 'preprocessing.R' 'quantification.R'
'region-enrichment.R' 'utilities.R' 'visualization.R' 'zzz.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Seurat (&ge; 4.0.6), ggforce, ggrepel, ggseqlogo, testthat (&ge;
2.1.0), chromVAR, SummarizedExperiment, TFBSTools, motifmatchr,
BSgenome, shiny, miniUI, rtracklayer, biovizBase, Biostrings,
lsa, MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 01:36:21 UTC; stuartt</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Stuart <a href="https://orcid.org/0000-0002-3044-0897"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Avi Srivastava <a href="https://orcid.org/0000-0001-9798-2079"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Paul Hoffman <a href="https://orcid.org/0000-0002-7693-8957"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Rahul Satija <a href="https://orcid.org/0000-0001-9448-8833"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Stuart &lt;stuartt@gis.a-star.edu.sg&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 02:42:57 UTC</td>
</tr>
</table>
<hr>
<h2 id='Signac-package'>Signac: Analysis of Single-Cell Chromatin Data</h2><span id='topic+Signac'></span><span id='topic+Signac-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A framework for the analysis and exploration of single-cell chromatin data. The 'Signac' package contains functions for quantifying single-cell chromatin data, computing per-cell quality control metrics, dimension reduction and normalization, visualization, and DNA sequence motif analysis. Reference: Stuart et al. (2021) <a href="https://doi.org/10.1038/s41592-021-01282-5">doi:10.1038/s41592-021-01282-5</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tim Stuart <a href="mailto:stuartt@gis.a-star.edu.sg">stuartt@gis.a-star.edu.sg</a> (<a href="https://orcid.org/0000-0002-3044-0897">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Avi Srivastava <a href="mailto:asrivastava@nygenome.org">asrivastava@nygenome.org</a> (<a href="https://orcid.org/0000-0001-9798-2079">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Paul Hoffman <a href="mailto:phoffman@nygenome.org">phoffman@nygenome.org</a> (<a href="https://orcid.org/0000-0002-7693-8957">ORCID</a>) [contributor]
</p>
</li>
<li><p> Rahul Satija <a href="mailto:rsatija@nygenome.org">rsatija@nygenome.org</a> (<a href="https://orcid.org/0000-0001-9448-8833">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/stuart-lab/signac">https://github.com/stuart-lab/signac</a>
</p>
</li>
<li> <p><a href="https://stuartlab.org/signac">https://stuartlab.org/signac</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/stuart-lab/signac/issues">https://github.com/stuart-lab/signac/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AccessiblePeaks'>Accessible peaks</h2><span id='topic+AccessiblePeaks'></span>

<h3>Description</h3>

<p>Find accessible peaks in a set of cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AccessiblePeaks(
  object,
  assay = NULL,
  idents = NULL,
  cells = NULL,
  min.cells = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AccessiblePeaks_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="AccessiblePeaks_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="AccessiblePeaks_+3A_idents">idents</code></td>
<td>
<p>A set of identity classes to find accessible peaks for</p>
</td></tr>
<tr><td><code id="AccessiblePeaks_+3A_cells">cells</code></td>
<td>
<p>A vector of cells to find accessible peaks for</p>
</td></tr>
<tr><td><code id="AccessiblePeaks_+3A_min.cells">min.cells</code></td>
<td>
<p>Minimum number of cells with the peak accessible (&gt;0 counts)
for the peak to be called accessible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of peak names
</p>

<hr>
<h2 id='AddChromatinModule'>Add chromatin module</h2><span id='topic+AddChromatinModule'></span>

<h3>Description</h3>

<p>Compute chromVAR deviations for groups of peaks. The goal of this function is
similar to that of <code><a href="Seurat.html#topic+AddModuleScore">AddModuleScore</a></code> except that it is
designed for single-cell chromatin data. The chromVAR deviations for each
group of peaks will be added to the object metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddChromatinModule(object, features, genome, assay = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddChromatinModule_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="AddChromatinModule_+3A_features">features</code></td>
<td>
<p>A named list of features to include in each module. The name
of each element in the list will be used to name the modules computed, which
will be stored in the object metadata.</p>
</td></tr>
<tr><td><code id="AddChromatinModule_+3A_genome">genome</code></td>
<td>
<p>A BSgenome object</p>
</td></tr>
<tr><td><code id="AddChromatinModule_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay.</p>
</td></tr>
<tr><td><code id="AddChromatinModule_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="AddChromatinModule_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>RunChromVAR</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object
</p>

<hr>
<h2 id='AddMotifs'>Add DNA sequence motif information</h2><span id='topic+AddMotifs'></span><span id='topic+AddMotifs.default'></span><span id='topic+AddMotifs.ChromatinAssay'></span><span id='topic+AddMotifs.Assay'></span><span id='topic+AddMotifs.StdAssay'></span><span id='topic+AddMotifs.Seurat'></span>

<h3>Description</h3>

<p>Construct a <code><a href="#topic+Motif">Motif</a></code> object containing DNA sequence motif
information and add it to an existing Seurat object or ChromatinAssay.
If running on a Seurat object, <code>AddMotifs</code> will also run
<code><a href="#topic+RegionStats">RegionStats</a></code> to compute the GC content of each peak and store
the results in the feature metadata. PFMs or PWMs are matched to the genome
sequence using the <code><a href="motifmatchr.html#topic+matchMotifs">matchMotifs</a></code> function with
default parameters to construct a matrix of motif positions in genomic
regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddMotifs(object, ...)

## Default S3 method:
AddMotifs(object, genome, pfm, verbose = TRUE, ...)

## S3 method for class 'ChromatinAssay'
AddMotifs(object, genome, pfm, verbose = TRUE, ...)

## S3 method for class 'Assay'
AddMotifs(object, genome, pfm, verbose = TRUE, ...)

## S3 method for class 'StdAssay'
AddMotifs(object, genome, pfm, verbose = TRUE, ...)

## S3 method for class 'Seurat'
AddMotifs(object, genome, pfm, assay = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddMotifs_+3A_object">object</code></td>
<td>
<p>A Seurat object or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="AddMotifs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="AddMotifs_+3A_genome">genome</code></td>
<td>
<p>A <code>BSgenome</code>, <code>DNAStringSet</code>, <code>FaFile</code>, or
string stating the genome build recognized by <code>getBSgenome</code>.</p>
</td></tr>
<tr><td><code id="AddMotifs_+3A_pfm">pfm</code></td>
<td>
<p>A <code>PFMatrixList</code> or <code>PWMatrixList</code> object containing
position weight/frequency matrices to use</p>
</td></tr>
<tr><td><code id="AddMotifs_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="AddMotifs_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When running on a <code>ChromatinAssay</code> or <code>Seurat</code> object,
returns a modified version of the input object. When running on a matrix,
returns a <code>Motif</code> object.
</p>


<h3>See Also</h3>

<p><span class="pkg">motifmatchr</span>
</p>

<hr>
<h2 id='AggregateTiles'>Quantify aggregated genome tiles</h2><span id='topic+AggregateTiles'></span><span id='topic+AggregateTiles.Seurat'></span><span id='topic+AggregateTiles.ChromatinAssay'></span><span id='topic+AggregateTiles.default'></span>

<h3>Description</h3>

<p>Quantifies fragment counts per cell in fixed-size genome bins across the
whole genome, then removes bins with less than a desired minimum number of
counts in the bin, then merges adjacent tiles into a single region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AggregateTiles(object, ...)

## S3 method for class 'Seurat'
AggregateTiles(
  object,
  genome,
  assay = NULL,
  new.assay.name = "tiles",
  min_counts = 5,
  binsize = 5000,
  verbose = TRUE,
  ...
)

## S3 method for class 'ChromatinAssay'
AggregateTiles(
  object,
  genome,
  min_counts = 5,
  binsize = 5000,
  verbose = TRUE,
  ...
)

## Default S3 method:
AggregateTiles(
  object,
  genome,
  cells = NULL,
  min_counts = 5,
  binsize = 5000,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AggregateTiles_+3A_object">object</code></td>
<td>
<p>A Seurat object or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_genome">genome</code></td>
<td>
<p>genome A vector of chromosome sizes for the genome. This is
used to construct the genome bin coordinates. The can be obtained by calling
seqlengths on a BSgenome-class object.</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_new.assay.name">new.assay.name</code></td>
<td>
<p>Name of new assay to create containing aggregated
genome tiles</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_min_counts">min_counts</code></td>
<td>
<p>Minimum number of counts for a tile to be retained prior to
aggregation</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_binsize">binsize</code></td>
<td>
<p>Size of the genome bins (tiles) in base pairs</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="AggregateTiles_+3A_cells">cells</code></td>
<td>
<p>Cells to include</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When running on a Seurat object, returns the Seurat object with a new
<code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> added.
</p>
<p>When running on a <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code>, returns a new
<code>ChromatinAssay</code> containing the aggregated genome tiles.
</p>
<p>When running on a fragment file, returns a sparse region x cell
matrix.
</p>

<hr>
<h2 id='AlleleFreq'>Compute allele frequencies per cell</h2><span id='topic+AlleleFreq'></span><span id='topic+AlleleFreq.default'></span><span id='topic+AlleleFreq.Assay'></span><span id='topic+AlleleFreq.StdAssay'></span><span id='topic+AlleleFreq.Seurat'></span>

<h3>Description</h3>

<p>Collapses allele counts for each strand and normalize by the total number of
counts at each nucleotide position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlleleFreq(object, ...)

## Default S3 method:
AlleleFreq(object, variants, ...)

## S3 method for class 'Assay'
AlleleFreq(object, variants, ...)

## S3 method for class 'StdAssay'
AlleleFreq(object, variants, ...)

## S3 method for class 'Seurat'
AlleleFreq(object, variants, assay = NULL, new.assay.name = "alleles", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlleleFreq_+3A_object">object</code></td>
<td>
<p>A Seurat object, Assay, or matrix</p>
</td></tr>
<tr><td><code id="AlleleFreq_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="AlleleFreq_+3A_variants">variants</code></td>
<td>
<p>A character vector of informative variants to keep. For
example, <code>c("627G&gt;A","709G&gt;A","1045G&gt;A","1793G&gt;A")</code>.</p>
</td></tr>
<tr><td><code id="AlleleFreq_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="AlleleFreq_+3A_new.assay.name">new.assay.name</code></td>
<td>
<p>Name of new assay to store variant data in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object with a new assay
containing the allele frequencies for the informative variants.
</p>

<hr>
<h2 id='Annotation'>Annotation</h2><span id='topic+Annotation'></span><span id='topic+Annotation+3C-'></span><span id='topic+Annotation.ChromatinAssay'></span><span id='topic+Annotation.Seurat'></span><span id='topic+Annotation+3C-.ChromatinAssay'></span><span id='topic+Annotation+3C-.Seurat'></span>

<h3>Description</h3>

<p>Get the annotation from a ChromatinAssay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Annotation(object, ...)

Annotation(object, ...) &lt;- value

## S3 method for class 'ChromatinAssay'
Annotation(object, ...)

## S3 method for class 'Seurat'
Annotation(object, ...)

## S3 replacement method for class 'ChromatinAssay'
Annotation(object, ...) &lt;- value

## S3 replacement method for class 'Seurat'
Annotation(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Annotation_+3A_object">object</code></td>
<td>
<p>A Seurat object or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="Annotation_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Annotation_+3A_value">value</code></td>
<td>
<p>A value to set. Can be NULL, to remove the current annotation
information, or a <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object. If a
<code>GRanges</code> object is supplied and the genome information is stored in the
assay, the genome of the new annotations must match the genome of the assay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object
if the annotation data is present, otherwise returns NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Annotation(atac_small[["peaks"]])


Annotation(atac_small)

genes &lt;- Annotation(atac_small)
Annotation(atac_small[["peaks"]]) &lt;- genes
genes &lt;- Annotation(atac_small)
Annotation(atac_small) &lt;- genes
</code></pre>

<hr>
<h2 id='AnnotationPlot'>Plot gene annotations</h2><span id='topic+AnnotationPlot'></span>

<h3>Description</h3>

<p>Display gene annotations in a given region of the genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnnotationPlot(
  object,
  region,
  assay = NULL,
  mode = "gene",
  sep = c("-", "-"),
  extend.upstream = 0,
  extend.downstream = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnnotationPlot_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="AnnotationPlot_+3A_region">region</code></td>
<td>
<p>A genomic region to plot</p>
</td></tr>
<tr><td><code id="AnnotationPlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay.</p>
</td></tr>
<tr><td><code id="AnnotationPlot_+3A_mode">mode</code></td>
<td>
<p>Display mode. Choose either &quot;gene&quot; or &quot;transcript&quot; to determine
whether genes or transcripts are plotted.</p>
</td></tr>
<tr><td><code id="AnnotationPlot_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates. First
element is used to separate the chromosome from the coordinates, second
element is used to separate the start from end coordinate.</p>
</td></tr>
<tr><td><code id="AnnotationPlot_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend the region upstream.</p>
</td></tr>
<tr><td><code id="AnnotationPlot_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend the region downstream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
AnnotationPlot(object = atac_small, region = c("chr1-29554-39554"))

</code></pre>

<hr>
<h2 id='as.ChromatinAssay'>Convert objects to a ChromatinAssay</h2><span id='topic+as.ChromatinAssay'></span><span id='topic+as.ChromatinAssay.Assay'></span>

<h3>Description</h3>

<p>Convert objects to a ChromatinAssay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ChromatinAssay(x, ...)

## S3 method for class 'Assay'
as.ChromatinAssay(
  x,
  ranges = NULL,
  seqinfo = NULL,
  annotation = NULL,
  motifs = NULL,
  fragments = NULL,
  bias = NULL,
  positionEnrichment = NULL,
  sep = c("-", "-"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ChromatinAssay_+3A_x">x</code></td>
<td>
<p>An object to convert to class <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code></p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_ranges">ranges</code></td>
<td>
<p>A GRanges object</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_seqinfo">seqinfo</code></td>
<td>
<p>A <code><a href="GenomeInfoDb.html#topic+Seqinfo">Seqinfo</a></code> object containing basic
information about the genome used. Alternatively, the name of a UCSC genome
can be provided and the sequence information will be downloaded from UCSC.</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_annotation">annotation</code></td>
<td>
<p>Genomic annotation</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_motifs">motifs</code></td>
<td>
<p>A <code><a href="#topic+Motif">Motif</a></code> object</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_fragments">fragments</code></td>
<td>
<p>A list of <code><a href="#topic+Fragment">Fragment</a></code> objects</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_bias">bias</code></td>
<td>
<p>Tn5 integration bias matrix</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_positionenrichment">positionEnrichment</code></td>
<td>
<p>A named list of position enrichment matrices.</p>
</td></tr>
<tr><td><code id="as.ChromatinAssay_+3A_sep">sep</code></td>
<td>
<p>Characters used to separate the chromosome, start, and end
coordinates in the row names of the data matrix</p>
</td></tr>
</table>

<hr>
<h2 id='atac_small'>A small example scATAC-seq dataset</h2><span id='topic+atac_small'></span>

<h3>Description</h3>

<p>A subsetted version of 10x Genomics 10k human (hg19) PBMC scATAC-seq dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atac_small
</code></pre>


<h3>Format</h3>

<p>A Seurat object with the following assays
</p>

<dl>
<dt>peaks</dt><dd><p>A peak x cell dataset</p>
</dd>
<dt>bins</dt><dd><p>A 5 kb genome bin x cell dataset</p>
</dd>
<dt>RNA</dt><dd><p>A gene x cell dataset</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://support.10xgenomics.com/single-cell-atac/datasets/1.1.0/atac_v1_pbmc_10k">https://support.10xgenomics.com/single-cell-atac/datasets/1.1.0/atac_v1_pbmc_10k</a>
</p>

<hr>
<h2 id='AverageCounts'>Average Counts</h2><span id='topic+AverageCounts'></span>

<h3>Description</h3>

<p>Compute the mean counts per group of cells for a given assay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AverageCounts(object, assay = NULL, group.by = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AverageCounts_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="AverageCounts_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default is the active assay</p>
</td></tr>
<tr><td><code id="AverageCounts_+3A_group.by">group.by</code></td>
<td>
<p>Grouping variable to use. Default is the active identities</p>
</td></tr>
<tr><td><code id="AverageCounts_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AverageCounts(atac_small)
</code></pre>

<hr>
<h2 id='BigwigTrack'>Plot data from BigWig files</h2><span id='topic+BigwigTrack'></span>

<h3>Description</h3>

<p>Create coverage tracks, heatmaps, or line plots from bigwig files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BigwigTrack(
  region,
  bigwig,
  smooth = 200,
  extend.upstream = 0,
  extend.downstream = 0,
  type = "coverage",
  y_label = "bigWig",
  bigwig.scale = "common",
  ymax = NULL,
  max.downsample = 3000,
  downsample.rate = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BigwigTrack_+3A_region">region</code></td>
<td>
<p>GRanges object specifying region to plot</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_bigwig">bigwig</code></td>
<td>
<p>List of bigwig file paths. List should be named, and the name
of each element in the list of files will be displayed alongside the track
in the final plot.</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_smooth">smooth</code></td>
<td>
<p>Number of bases to smooth data over (rolling mean). If NULL,
do not apply smoothing.</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend the region upstream.</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend the region downstream.</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_type">type</code></td>
<td>
<p>Plot type. Can be one of &quot;line&quot;, &quot;heatmap&quot;, or &quot;coverage&quot;</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_y_label">y_label</code></td>
<td>
<p>Y-axis label</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_bigwig.scale">bigwig.scale</code></td>
<td>
<p>Scaling to apply to data from different bigwig files.
Can be:
</p>

<ul>
<li><p>common: plot each bigwig on a common scale (default)
</p>
</li>
<li><p>separate: plot each bigwig on a separate scale ranging from zero to the
maximum value for that bigwig file within the plotted region
</p>
</li></ul>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_ymax">ymax</code></td>
<td>
<p>Maximum value for Y axis. Can be one of:
</p>

<ul>
<li><p>NULL: set to the highest value among all the tracks (default)
</p>
</li>
<li><p>qXX: clip the maximum value to the XX quantile (for example, q95 will
set the maximum value to 95% of the maximum value in the data). This can help
remove the effect of extreme values that may otherwise distort the scale.
</p>
</li>
<li><p>numeric: manually define a Y-axis limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_max.downsample">max.downsample</code></td>
<td>
<p>Minimum number of positions kept when downsampling.
Downsampling rate is adaptive to the window size, but this parameter will set
the minimum possible number of positions to include so that plots do not
become too sparse when the window size is small.</p>
</td></tr>
<tr><td><code id="BigwigTrack_+3A_downsample.rate">downsample.rate</code></td>
<td>
<p>Fraction of positions to retain when downsampling.
Retaining more positions can give a higher-resolution plot but can make the
number of points large, resulting in larger file sizes when saving the plot
and a longer period of time needed to draw the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function does not work on windows.
</p>


<h3>Value</h3>

<p>Returns a ggplot object
</p>

<hr>
<h2 id='BinarizeCounts'>Binarize counts</h2><span id='topic+BinarizeCounts'></span><span id='topic+BinarizeCounts.default'></span><span id='topic+BinarizeCounts.Assay'></span><span id='topic+BinarizeCounts.Seurat'></span>

<h3>Description</h3>

<p>Set counts &gt;1 to 1 in a count matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinarizeCounts(object, ...)

## Default S3 method:
BinarizeCounts(object, assay = NULL, verbose = TRUE, ...)

## S3 method for class 'Assay'
BinarizeCounts(object, assay = NULL, verbose = TRUE, ...)

## S3 method for class 'Seurat'
BinarizeCounts(object, assay = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinarizeCounts_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="BinarizeCounts_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="BinarizeCounts_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Can be a list of assays,
and binarization will be applied to each.</p>
</td></tr>
<tr><td><code id="BinarizeCounts_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(data = sample(0:3, size = 25, replace = TRUE), ncol = 5)
BinarizeCounts(x)
BinarizeCounts(atac_small[['peaks']])
BinarizeCounts(atac_small)
</code></pre>

<hr>
<h2 id='blacklist_ce10'>Genomic blacklist regions for C. elegans ce10 (0-based)</h2><span id='topic+blacklist_ce10'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for C. elegans ce10 (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_ce10
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_ce11'>Genomic blacklist regions for C. elegans ce11 (0-based)</h2><span id='topic+blacklist_ce11'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for C. elegans ce11 (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_ce11
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_dm3'>Genomic blacklist regions for Drosophila dm3 (0-based)</h2><span id='topic+blacklist_dm3'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for Drosophila dm3 (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_dm3
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_dm6'>Genomic blacklist regions for Drosophila dm6 (0-based)</h2><span id='topic+blacklist_dm6'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for Drosophila dm6 (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_dm6
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_hg19'>Genomic blacklist regions for Human hg19 (0-based)</h2><span id='topic+blacklist_hg19'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for Human hg19 (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_hg19
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_hg38'>Genomic blacklist regions for Human GRCh38</h2><span id='topic+blacklist_hg38'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for Human GRCh38
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_hg38
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_hg38_unified'>Unified genomic blacklist regions for Human GRCh38</h2><span id='topic+blacklist_hg38_unified'></span>

<h3>Description</h3>

<p>Manually curated genomic blacklist regions for the hg38 genome by Anshul
Kundaje and Anna Shcherbina. See
<a href="https://www.encodeproject.org/files/ENCFF356LFX/">https://www.encodeproject.org/files/ENCFF356LFX/</a> for a description of
how this blacklist was curated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_hg38_unified
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Author(s)</h3>

<p>Anshul Kundaje
</p>
<p>Anna Shcherbina
</p>


<h3>Source</h3>

<p><a href="https://www.encodeproject.org/files/ENCFF356LFX/">https://www.encodeproject.org/files/ENCFF356LFX/</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='blacklist_mm10'>Genomic blacklist regions for Mouse mm10 (0-based)</h2><span id='topic+blacklist_mm10'></span>

<h3>Description</h3>

<p>Genomic blacklist regions for Mouse mm10 (0-based)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blacklist_mm10
</code></pre>


<h3>Format</h3>

<p>A GRanges object
</p>


<h3>Source</h3>

<p><a href="https://github.com/Boyle-Lab/Blacklist">https://github.com/Boyle-Lab/Blacklist</a>
</p>
<p><a href="https://doi.org/10.1038/s41598-019-45839-z">doi:10.1038/s41598-019-45839-z</a>
</p>

<hr>
<h2 id='CallPeaks'>Call peaks</h2><span id='topic+CallPeaks'></span><span id='topic+CallPeaks.Seurat'></span><span id='topic+CallPeaks.ChromatinAssay'></span><span id='topic+CallPeaks.Fragment'></span><span id='topic+CallPeaks.default'></span>

<h3>Description</h3>

<p>Call peaks using MACS. Fragment files linked to the specified assay will be
used to call peaks. If multiple fragment files are present, all will be used
in a single MACS invocation. Returns the <code>.narrowPeak</code> MACS output as a
<code>GRanges</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CallPeaks(object, ...)

## S3 method for class 'Seurat'
CallPeaks(
  object,
  assay = NULL,
  group.by = NULL,
  idents = NULL,
  macs2.path = NULL,
  broad = FALSE,
  format = "BED",
  outdir = tempdir(),
  fragment.tempdir = tempdir(),
  combine.peaks = TRUE,
  effective.genome.size = 2.7e+09,
  extsize = 200,
  shift = -extsize/2,
  additional.args = NULL,
  name = Project(object),
  cleanup = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'ChromatinAssay'
CallPeaks(
  object,
  macs2.path = NULL,
  outdir = tempdir(),
  broad = FALSE,
  format = "BED",
  effective.genome.size = 2.7e+09,
  extsize = 200,
  shift = -extsize/2,
  additional.args = NULL,
  name = "macs2",
  cleanup = TRUE,
  verbose = TRUE,
  ...
)

## S3 method for class 'Fragment'
CallPeaks(
  object,
  macs2.path = NULL,
  outdir = tempdir(),
  broad = FALSE,
  format = "BED",
  effective.genome.size = 2.7e+09,
  extsize = 200,
  shift = -extsize/2,
  additional.args = NULL,
  name = "macs2",
  cleanup = TRUE,
  verbose = TRUE,
  ...
)

## Default S3 method:
CallPeaks(
  object,
  macs2.path = NULL,
  outdir = tempdir(),
  broad = FALSE,
  format = "BED",
  effective.genome.size = 2.7e+09,
  extsize = 200,
  shift = -extsize/2,
  additional.args = NULL,
  name = "macs2",
  cleanup = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CallPeaks_+3A_object">object</code></td>
<td>
<p>A Seurat object, ChromatinAssay object, Fragment object, or the
path to fragment file/s.</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_group.by">group.by</code></td>
<td>
<p>Grouping variable to use. If set, peaks will be called
independently on each group of cells and then combined. Note that to call
peaks using subsets of cells we first split the fragment file/s used, so
using a grouping variable will require extra time to split the files and
perform multiple MACS peak calls, and will store additional files on-disk
that may be large. Note that we store split fragment files in the temp
directory (<code><a href="base.html#topic+tempdir">tempdir</a></code>) by default, and if the program is
interrupted before completing these temporary files will not be removed. If
NULL, peaks are called using all cells together (pseudobulk).</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_idents">idents</code></td>
<td>
<p>List of identities to include if grouping cells (only valid if
also setting the <code>group.by</code> parameter). If NULL, peaks will be called
for all cell identities.</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_macs2.path">macs2.path</code></td>
<td>
<p>Path to MACS program. If NULL, try to find MACS
automatically.</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_broad">broad</code></td>
<td>
<p>Call broad peaks (<code>--broad</code> parameter for MACS)</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_format">format</code></td>
<td>
<p>File format to use. Should be either &quot;BED&quot; or &quot;BEDPE&quot; (see 
MACS documentation).</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_outdir">outdir</code></td>
<td>
<p>Path for output files</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_fragment.tempdir">fragment.tempdir</code></td>
<td>
<p>Path to write temporary fragment files. Only used if
<code>group.by</code> is not NULL.</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_combine.peaks">combine.peaks</code></td>
<td>
<p>Controls whether peak calls from different groups of
cells are combined using <code>GenomicRanges::reduce</code> when calling peaks for
different groups of cells (<code>group.by</code> parameter). If FALSE, a list of
<code>GRanges</code> object will be returned. Note that metadata fields such as the
p-value, q-value, and fold-change information for each peak will be lost if
combining peaks.</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_effective.genome.size">effective.genome.size</code></td>
<td>
<p>Effective genome size parameter for MACS
(<code>-g</code>). Default is the human effective genome size (2.7e9).</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_extsize">extsize</code></td>
<td>
<p><code>extsize</code> parameter for MACS. Only relevant if 
format=&quot;BED&quot;</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_shift">shift</code></td>
<td>
<p><code>shift</code> parameter for MACS. Only relevant if format=&quot;BED&quot;</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_additional.args">additional.args</code></td>
<td>
<p>Additional arguments passed to MACS. This should be a
single character string</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_name">name</code></td>
<td>
<p>Name for output MACS files. This will also be placed in the
<code>name</code> field in the GRanges output.</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_cleanup">cleanup</code></td>
<td>
<p>Remove MACS output files</p>
</td></tr>
<tr><td><code id="CallPeaks_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://macs3-project.github.io/MACS/">https://macs3-project.github.io/MACS/</a> for MACS documentation.
</p>
<p>If you call peaks using MACS2 please cite:
<a href="https://doi.org/10.1186/gb-2008-9-9-r137">doi:10.1186/gb-2008-9-9-r137</a>
</p>


<h3>Value</h3>

<p>Returns a <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object
</p>

<hr>
<h2 id='Cells.Fragment'>Set and get cell barcode information for a <code><a href="#topic+Fragment">Fragment</a></code> object</h2><span id='topic+Cells.Fragment'></span><span id='topic+Cells+3C-.Fragment'></span>

<h3>Description</h3>

<p>This returns the names of cells in the object that are contained in the
fragment file. These cell barcodes may not match the barcodes present in the
fragment file. The <code><a href="#topic+Fragment">Fragment</a></code> object contains an internal mapping
of the cell names in the <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object to the cell
names in the fragment file, so that cell names can be changed in the
assay without needing to change the cell names on disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Fragment'
Cells(x, ...)

## S3 replacement method for class 'Fragment'
Cells(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cells.Fragment_+3A_x">x</code></td>
<td>
<p>A Fragment object</p>
</td></tr>
<tr><td><code id="Cells.Fragment_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Cells.Fragment_+3A_value">value</code></td>
<td>
<p>A vector of cell names to store in the <code><a href="#topic+Fragment">Fragment</a></code>
object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To access the cell names that are stored in the fragment file itself, use
<code>GetFragmentData(object = x, name = "cells")</code>.
</p>

<hr>
<h2 id='Cells+26lt+3B-'>Set and get cell barcode information for a Fragment object</h2><span id='topic+Cells+3C-'></span>

<h3>Description</h3>

<p>Set and get cell barcode information for a Fragment object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cells(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cells+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="Cells+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Cells+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A character vector of cell barcodes</p>
</td></tr>
</table>

<hr>
<h2 id='CellsPerGroup'>Cells per group</h2><span id='topic+CellsPerGroup'></span>

<h3>Description</h3>

<p>Count the number of cells in each group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CellsPerGroup(object, group.by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CellsPerGroup_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="CellsPerGroup_+3A_group.by">group.by</code></td>
<td>
<p>A grouping variable. Default is the active identities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CellsPerGroup(atac_small)
</code></pre>

<hr>
<h2 id='ChromatinAssay-class'>The ChromatinAssay class</h2><span id='topic+ChromatinAssay-class'></span><span id='topic+ChromatinAssay'></span>

<h3>Description</h3>

<p>The ChromatinAssay object is an extended <code><a href="SeuratObject.html#topic+Assay">Assay</a></code>
for the storage and analysis of single-cell chromatin data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ranges</code></dt><dd><p>A <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object describing the
genomic location of features in the object</p>
</dd>
<dt><code>motifs</code></dt><dd><p>A <code><a href="#topic+Motif">Motif</a></code> object</p>
</dd>
<dt><code>fragments</code></dt><dd><p>A list of <code><a href="#topic+Fragment">Fragment</a></code> objects.</p>
</dd>
<dt><code>seqinfo</code></dt><dd><p>A <code><a href="GenomeInfoDb.html#topic+Seqinfo">Seqinfo</a></code> object containing basic
information about the genome sequence used.</p>
</dd>
<dt><code>annotation</code></dt><dd><p>A  <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object containing
genomic annotations. This should be a GRanges object with the following 
columns:
</p>

<ul>
<li><p>tx_id: Transcript ID
</p>
</li>
<li><p>gene_name: Gene name
</p>
</li>
<li><p>gene_id: Gene ID
</p>
</li>
<li><p>gene_biotype: Gene biotype (e.g. &quot;protein_coding&quot;, &quot;lincRNA&quot;)
</p>
</li>
<li><p>type: Annotation type (e.g. &quot;exon&quot;, &quot;gap&quot;)
</p>
</li></ul>
</dd>
<dt><code>bias</code></dt><dd><p>A vector containing Tn5 integration bias information
(frequency of Tn5 integration at different kmers)</p>
</dd>
<dt><code>positionEnrichment</code></dt><dd><p>A named list of matrices containing positional
enrichment scores for Tn5 integration (for example, enrichment at the TSS)</p>
</dd>
<dt><code>links</code></dt><dd><p>A <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object describing linked
genomic positions, such as co-accessible sites or enhancer-gene regulatory
relationships. This should be a <code>GRanges</code> object, where the start and
end coordinates are the two linked genomic positions, and must contain a
&quot;score&quot; metadata column.</p>
</dd>
</dl>

<hr>
<h2 id='ClosestFeature'>Closest Feature</h2><span id='topic+ClosestFeature'></span>

<h3>Description</h3>

<p>Find the closest feature to a given set of genomic regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClosestFeature(object, regions, annotation = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClosestFeature_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="ClosestFeature_+3A_regions">regions</code></td>
<td>
<p>A set of genomic regions to query</p>
</td></tr>
<tr><td><code id="ClosestFeature_+3A_annotation">annotation</code></td>
<td>
<p>A GRanges object containing annotation information. If
NULL, use the annotations stored in the object.</p>
</td></tr>
<tr><td><code id="ClosestFeature_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+StringToGRanges">StringToGRanges</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with the name of each region, the closest feature
in the annotation, and the distance to the feature.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ClosestFeature(
  object = atac_small,
  regions = head(granges(atac_small))
)

</code></pre>

<hr>
<h2 id='ClusterClonotypes'>Find relationships between clonotypes</h2><span id='topic+ClusterClonotypes'></span>

<h3>Description</h3>

<p>Perform hierarchical clustering on clonotype data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterClonotypes(object, assay = NULL, group.by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusterClonotypes_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="ClusterClonotypes_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="ClusterClonotypes_+3A_group.by">group.by</code></td>
<td>
<p>Grouping variable for cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing two objects of class
<code><a href="stats.html#topic+hclust">hclust</a></code>, one for the cell clustering and one for the
feature (allele) clustering
</p>

<hr>
<h2 id='CombineTracks'>Combine genome region plots</h2><span id='topic+CombineTracks'></span>

<h3>Description</h3>

<p>This can be used to combine coverage plots, peak region plots, gene
annotation plots, and linked element plots. The different tracks are stacked
on top of each other and the x-axis combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CombineTracks(plotlist, expression.plot = NULL, heights = NULL, widths = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CombineTracks_+3A_plotlist">plotlist</code></td>
<td>
<p>A list of plots to combine. Must be from the same genomic
region.</p>
</td></tr>
<tr><td><code id="CombineTracks_+3A_expression.plot">expression.plot</code></td>
<td>
<p>Plot containing gene expression information. If
supplied, this will be placed to the left of the coverage tracks and aligned
with each track</p>
</td></tr>
<tr><td><code id="CombineTracks_+3A_heights">heights</code></td>
<td>
<p>Relative heights for each plot. If NULL, the first plot will
be 8x the height of the other tracks.</p>
</td></tr>
<tr><td><code id="CombineTracks_+3A_widths">widths</code></td>
<td>
<p>Relative widths for each plot. Only required if adding a gene
expression panel. If NULL, main plots will be 8x the width of the gene
expression panel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a patchworked ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- PeakPlot(atac_small, region = "chr1-29554-39554")
p2 &lt;- AnnotationPlot(atac_small, region = "chr1-29554-39554")
CombineTracks(plotlist = list(p1, p2), heights = c(1, 1))

</code></pre>

<hr>
<h2 id='ConnectionsToLinks'>Cicero connections to links</h2><span id='topic+ConnectionsToLinks'></span>

<h3>Description</h3>

<p>Convert the output of Cicero connections to a set of genomic ranges where
the start and end coordinates of the range are the midpoints of the linked
elements. Only elements on the same chromosome are included in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConnectionsToLinks(conns, ccans = NULL, threshold = 0, sep = c("-", "-"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConnectionsToLinks_+3A_conns">conns</code></td>
<td>
<p>A dataframe containing co-accessible elements. This would
usually be the output of <code>run_cicero</code> or
<code>assemble_connections</code>. Specifically, this should be a
dataframe where the first column contains the genomic coordinates of the
first element in the linked pair of elements, with chromosome, start, end
coordinates separated by &quot;-&quot; characters. The second column should be the
second element in the linked pair, formatted in the same way as the first
column. A third column should contain the co-accessibility scores.</p>
</td></tr>
<tr><td><code id="ConnectionsToLinks_+3A_ccans">ccans</code></td>
<td>
<p>This is optional, but if supplied should be a dataframe
containing the cis-co-accessibility network (CCAN) information generated
by <code>generate_ccans</code>. Specifically, this should be a
dataframe containing the name of the peak in the first column, and the
CCAN that it belongs to in the second column.</p>
</td></tr>
<tr><td><code id="ConnectionsToLinks_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for retaining a coaccessible site. Links with
a value less than or equal to this threshold will be discarded.</p>
</td></tr>
<tr><td><code id="ConnectionsToLinks_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates.
First element is used to separate the chromosome from the coordinates, second
element is used to separate the start from end coordinate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the Cicero package for more information:
<a href="https://bioconductor.org/packages/cicero/">https://bioconductor.org/packages/cicero/</a>
</p>


<h3>Value</h3>

<p>Returns a <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object
</p>

<hr>
<h2 id='ConvertMotifID'>Convert between motif name and motif ID</h2><span id='topic+ConvertMotifID'></span><span id='topic+ConvertMotifID.default'></span><span id='topic+ConvertMotifID.Motif'></span><span id='topic+ConvertMotifID.ChromatinAssay'></span><span id='topic+ConvertMotifID.Assay'></span><span id='topic+ConvertMotifID.StdAssay'></span><span id='topic+ConvertMotifID.Seurat'></span>

<h3>Description</h3>

<p>Converts from motif name to motif ID or vice versa. To convert common names
to IDs, use the <code>name</code> parameter. To convert IDs to common names, use
the <code>id</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvertMotifID(object, ...)

## Default S3 method:
ConvertMotifID(object, name, id, ...)

## S3 method for class 'Motif'
ConvertMotifID(object, ...)

## S3 method for class 'ChromatinAssay'
ConvertMotifID(object, ...)

## S3 method for class 'Assay'
ConvertMotifID(object, ...)

## S3 method for class 'StdAssay'
ConvertMotifID(object, ...)

## S3 method for class 'Seurat'
ConvertMotifID(object, assay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConvertMotifID_+3A_object">object</code></td>
<td>
<p>A Seurat, ChromatinAssay, or Motif object</p>
</td></tr>
<tr><td><code id="ConvertMotifID_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="ConvertMotifID_+3A_name">name</code></td>
<td>
<p>A vector of motif names</p>
</td></tr>
<tr><td><code id="ConvertMotifID_+3A_id">id</code></td>
<td>
<p>A vector of motif IDs. Only one of <code>name</code> and <code>id</code> should
be supplied</p>
</td></tr>
<tr><td><code id="ConvertMotifID_+3A_assay">assay</code></td>
<td>
<p>For <code>Seurat</code> object. Name of assay to use.
If NULL, use the default assay</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector with the same length and order as the
input. Any names or IDs that were not found will be stored as <code>NA</code>.
</p>

<hr>
<h2 id='corSparse'>Sparse matrix correlation</h2><span id='topic+corSparse'></span>

<h3>Description</h3>

<p>Compute the Pearson correlation matrix between
columns of two sparse matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corSparse(X, Y = NULL, cov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corSparse_+3A_x">X</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="corSparse_+3A_y">Y</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="corSparse_+3A_cov">cov</code></td>
<td>
<p>return covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally from 
<a href="https://stackoverflow.com/questions/5888287/running-cor-or-any-variant-over-a-sparse-matrix-in-r">https://stackoverflow.com/questions/5888287/running-cor-or-any-variant-over-a-sparse-matrix-in-r</a>
and the qlcMatrix package.
</p>


<h3>Author(s)</h3>

<p>Michael Cysouw, Karsten Looschen
</p>

<hr>
<h2 id='CountFragments'>Count fragments</h2><span id='topic+CountFragments'></span>

<h3>Description</h3>

<p>Count total fragments per cell barcode present in a fragment file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountFragments(fragments, cells = NULL, max_lines = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountFragments_+3A_fragments">fragments</code></td>
<td>
<p>Path to a fragment file. If a list of fragment files is
provided, the total fragments for each cell barcode across all files will be
returned</p>
</td></tr>
<tr><td><code id="CountFragments_+3A_cells">cells</code></td>
<td>
<p>Cells to include. If NULL, include all cells</p>
</td></tr>
<tr><td><code id="CountFragments_+3A_max_lines">max_lines</code></td>
<td>
<p>Maximum number of lines to read from the fragment file. If
NULL, read all lines in the file.</p>
</td></tr>
<tr><td><code id="CountFragments_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with the following columns:
</p>

<ul>
<li><p>CB: the cell barcode
</p>
</li>
<li><p>frequency_count: total number of fragments sequenced for the cell
</p>
</li>
<li><p>mononucleosome: total number of fragments with length between 147 bp and 294 bp
</p>
</li>
<li><p>nucleosome_free: total number of fragments with length &lt;147 bp
</p>
</li>
<li><p>reads_count: total number of reads sequenced for the cell
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
counts &lt;- CountFragments(fragments = fpath)
</code></pre>

<hr>
<h2 id='CountsInRegion'>Counts in region</h2><span id='topic+CountsInRegion'></span>

<h3>Description</h3>

<p>Count reads per cell overlapping a given set of regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountsInRegion(object, assay, regions, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountsInRegion_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="CountsInRegion_+3A_assay">assay</code></td>
<td>
<p>Name of a chromatin assay in the object to use</p>
</td></tr>
<tr><td><code id="CountsInRegion_+3A_regions">regions</code></td>
<td>
<p>A GRanges object</p>
</td></tr>
<tr><td><code id="CountsInRegion_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="IRanges.html#topic+findOverlaps">findOverlaps</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CountsInRegion(
  object = atac_small,
  assay = 'bins',
  regions = blacklist_hg19
)

</code></pre>

<hr>
<h2 id='coverage+2CChromatinAssay-method'>Coverage of a ChromatinAssay object</h2><span id='topic+coverage+2CChromatinAssay-method'></span><span id='topic+coverage'></span><span id='topic+coverage+2CSeurat-method'></span>

<h3>Description</h3>

<p>This is the <code>coverage</code> method for <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ChromatinAssay'
coverage(
  x,
  shift = 0L,
  width = NULL,
  weight = 1L,
  method = c("auto", "sort", "hash")
)

## S4 method for signature 'Seurat'
coverage(
  x,
  shift = 0L,
  width = NULL,
  weight = 1L,
  method = c("auto", "sort", "hash")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage+2B2CChromatinAssay-method_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object</p>
</td></tr>
<tr><td><code id="coverage+2B2CChromatinAssay-method_+3A_shift">shift</code></td>
<td>
<p>How much each range should be shifted before coverage is
computed. See <code><a href="IRanges.html#topic+coverage">coverage</a></code> in the <span class="pkg">IRanges</span> package.</p>
</td></tr>
<tr><td><code id="coverage+2B2CChromatinAssay-method_+3A_width">width</code></td>
<td>
<p>Specifies the length of the returned coverage vectors.
See <code><a href="IRanges.html#topic+coverage">coverage</a></code> in the <span class="pkg">IRanges</span> package.</p>
</td></tr>
<tr><td><code id="coverage+2B2CChromatinAssay-method_+3A_weight">weight</code></td>
<td>
<p>Assigns weight to each range in <code>x</code>.
See <code><a href="IRanges.html#topic+coverage">coverage</a></code> in the <span class="pkg">IRanges</span> package.</p>
</td></tr>
<tr><td><code id="coverage+2B2CChromatinAssay-method_+3A_method">method</code></td>
<td>
<p>See <code><a href="IRanges.html#topic+coverage">coverage</a></code> in the <span class="pkg">IRanges</span>
package</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>coverage(ChromatinAssay)</code>: method for ChromatinAssay objects
</p>
</li>
<li> <p><code>coverage(Seurat)</code>: method for Seurat objects
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li><p><a href="IRanges.html#topic+coverage-methods">coverage-methods</a> in the <span class="pkg">IRanges</span> package.
</p>
</li>
<li><p><a href="GenomicRanges.html#topic+coverage-methods">coverage-methods</a> in the <span class="pkg">GenomicRanges</span>
package
</p>
</li>
<li><p><a href="#topic+ChromatinAssay-class">ChromatinAssay-class</a>
</p>
</li></ul>


<hr>
<h2 id='CoverageBrowser'>Genome browser</h2><span id='topic+CoverageBrowser'></span>

<h3>Description</h3>

<p>Interactive version of the <code><a href="#topic+CoveragePlot">CoveragePlot</a></code> function. Allows
altering the genome position interactively. The current view at any time can
be saved to a list of <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> objects using the &quot;Save
plot&quot; button, and this list of plots will be returned after ending the
browser by pressing the &quot;Done&quot; button.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoverageBrowser(object, region, assay = NULL, sep = c("-", "-"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoverageBrowser_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="CoverageBrowser_+3A_region">region</code></td>
<td>
<p>A set of genomic coordinates</p>
</td></tr>
<tr><td><code id="CoverageBrowser_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="CoverageBrowser_+3A_sep">sep</code></td>
<td>
<p>Separators for genomic coordinates if region supplied as a string
rather than GRanges object</p>
</td></tr>
<tr><td><code id="CoverageBrowser_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+CoveragePlot">CoveragePlot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of ggplot objects
</p>

<hr>
<h2 id='CoveragePlot'>Plot Tn5 insertion frequency over a region</h2><span id='topic+CoveragePlot'></span>

<h3>Description</h3>

<p>Plot frequency of Tn5 insertion events for different groups of cells within
given regions of the genome. Tracks are normalized using a per-group scaling
factor computed as the number of cells in the group multiplied by the mean
sequencing depth for that group of cells. This accounts for differences in
number of cells and potential differences in sequencing depth between groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoveragePlot(
  object,
  region,
  features = NULL,
  assay = NULL,
  split.assays = FALSE,
  assay.scale = "common",
  show.bulk = FALSE,
  expression.assay = "RNA",
  expression.slot = "data",
  annotation = TRUE,
  peaks = TRUE,
  peaks.group.by = NULL,
  ranges = NULL,
  ranges.group.by = NULL,
  ranges.title = "Ranges",
  region.highlight = NULL,
  links = TRUE,
  tile = FALSE,
  tile.size = 100,
  tile.cells = 100,
  bigwig = NULL,
  bigwig.type = "coverage",
  bigwig.scale = "common",
  heights = NULL,
  group.by = NULL,
  split.by = NULL,
  window = 100,
  extend.upstream = 0,
  extend.downstream = 0,
  scale.factor = NULL,
  ymax = NULL,
  cells = NULL,
  idents = NULL,
  sep = c("-", "-"),
  max.downsample = 3000,
  downsample.rate = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoveragePlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_region">region</code></td>
<td>
<p>A set of genomic coordinates to show. Can be a GRanges object,
a string encoding a genomic position, a gene name, or a vector of strings
describing the genomic coordinates or gene names to plot. If a gene name is
supplied, annotations must be present in the assay.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_features">features</code></td>
<td>
<p>A vector of features present in another assay to plot
alongside accessibility tracks (for example, gene names).</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_assay">assay</code></td>
<td>
<p>Name of the assay to plot. If a list of assays is provided,
data from each assay will be shown overlaid on each track. The first assay in
the list will define the assay used for gene annotations, links, and peaks
(if shown). The order of assays given defines the plotting order.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_split.assays">split.assays</code></td>
<td>
<p>When plotting data from multiple assays, display each
assay as a separate track. If FALSE, data from different assays are overlaid
on a single track with transparancy applied.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_assay.scale">assay.scale</code></td>
<td>
<p>Scaling to apply to data from different assays. Can be:
</p>

<ul>
<li><p>common: plot all assays on a common scale (default)
</p>
</li>
<li><p>separate: plot each assay on a separate scale ranging from zero to the
maximum value for that assay within the plotted region
</p>
</li></ul>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_show.bulk">show.bulk</code></td>
<td>
<p>Include coverage track for all cells combined (pseudo-bulk).
Note that this will plot the combined accessibility for all cells included in
the plot (rather than all cells in the object).</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_expression.assay">expression.assay</code></td>
<td>
<p>Name of the assay containing expression data to plot
alongside accessibility tracks. Only needed if supplying <code>features</code>
argument.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_expression.slot">expression.slot</code></td>
<td>
<p>Name of slot to pull expression data from. Only needed
if supplying the <code>features</code> argument.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_annotation">annotation</code></td>
<td>
<p>Display gene annotations. Set to TRUE or FALSE to control
whether genes models are displayed, or choose &quot;transcript&quot; to display all
transcript isoforms, or &quot;gene&quot; to display gene models only (same as setting
TRUE).</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_peaks">peaks</code></td>
<td>
<p>Display peaks</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_peaks.group.by">peaks.group.by</code></td>
<td>
<p>Grouping variable to color peaks by. Must be a variable
present in the feature metadata. If NULL, do not color peaks by any variable.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_ranges">ranges</code></td>
<td>
<p>Additional genomic ranges to plot</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_ranges.group.by">ranges.group.by</code></td>
<td>
<p>Grouping variable to color ranges by. Must be a
variable present in the metadata stored in the <code>ranges</code> genomic ranges.
If NULL, do not color by any variable.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_ranges.title">ranges.title</code></td>
<td>
<p>Y-axis title for ranges track. Only relevant if
<code>ranges</code> parameter is set.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_region.highlight">region.highlight</code></td>
<td>
<p>Region to highlight on the plot. Should be a GRanges
object containing the coordinates to highlight. By default, regions will be
highlighted in grey. To change the color of the highlighting, include a
metadata column in the GRanges object named &quot;color&quot; containing the color to
use for each region.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_links">links</code></td>
<td>
<p>Display links. This can be a TRUE/FALSE value which will 
determine whether a links track is displayed, and if TRUE links for all genes
in the plotted region will be shown. Alternatively, a character vector can be
provided, giving a list of gene names to plot links for. If this is provided,
only links for those genes will be displayed in the plot.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_tile">tile</code></td>
<td>
<p>Display per-cell fragment information in sliding windows. If
plotting multi-assay data, only the first assay is shown in the tile plot.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_tile.size">tile.size</code></td>
<td>
<p>Size of the sliding window for per-cell fragment tile plot</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_tile.cells">tile.cells</code></td>
<td>
<p>Number of cells to display fragment information for in tile
plot.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_bigwig">bigwig</code></td>
<td>
<p>List of bigWig file paths to plot data from. Files can be
remotely hosted. The name of each element in the list will determine the
y-axis label given to the track.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_bigwig.type">bigwig.type</code></td>
<td>
<p>Type of track to use for bigWig files (&quot;line&quot;, &quot;heatmap&quot;,
or &quot;coverage&quot;). Should either be a single value, or a list of values giving
the type for each individual track in the provided list of bigwig files.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_bigwig.scale">bigwig.scale</code></td>
<td>
<p>Same as <code>assay.scale</code> parameter, except for bigWig
files when plotted with <code>bigwig.type="coverage"</code></p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_heights">heights</code></td>
<td>
<p>Relative heights for each track (accessibility, gene
annotations, peaks, links).</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of one or more metadata columns to group (color) the
cells by. Default is the current cell identities</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_split.by">split.by</code></td>
<td>
<p>A metadata variable to split the tracks by. For example,
grouping by &quot;celltype&quot; and splitting by &quot;batch&quot; will create separate tracks
for each combination of celltype and batch.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_window">window</code></td>
<td>
<p>Smoothing window size</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend the region upstream.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend the region downstream.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Scaling factor for track height. If NULL (default),
use the median group scaling factor determined by total number of fragments
sequences in each group.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_ymax">ymax</code></td>
<td>
<p>Maximum value for Y axis. Can be one of:
</p>

<ul>
<li><p>NULL: set to the highest value among all the tracks (default)
</p>
</li>
<li><p>qXX: clip the maximum value to the XX quantile (for example, q95 will
set the maximum value to 95% of the maximum value in the data). This can help
remove the effect of extreme values that may otherwise distort the scale.
</p>
</li>
<li><p>numeric: manually define a Y-axis limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_cells">cells</code></td>
<td>
<p>Which cells to plot. Default all cells</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_idents">idents</code></td>
<td>
<p>Which identities to include in the plot. Default is all
identities.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates. First
element is used to separate the chromosome from the coordinates, second
element is used to separate the start from end coordinate.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_max.downsample">max.downsample</code></td>
<td>
<p>Minimum number of positions kept when downsampling.
Downsampling rate is adaptive to the window size, but this parameter will set
the minimum possible number of positions to include so that plots do not
become too sparse when the window size is small.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_downsample.rate">downsample.rate</code></td>
<td>
<p>Fraction of positions to retain when downsampling.
Retaining more positions can give a higher-resolution plot but can make the
number of points large, resulting in larger file sizes when saving the plot
and a longer period of time needed to draw the plot.</p>
</td></tr>
<tr><td><code id="CoveragePlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="patchwork.html#topic+wrap_plots">wrap_plots</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional information can be layered on the coverage plot by setting several
different options in the CoveragePlot function. This includes showing:
</p>

<ul>
<li><p>gene annotations
</p>
</li>
<li><p>peak positions
</p>
</li>
<li><p>additional genomic ranges
</p>
</li>
<li><p>additional data stored in a bigWig file, which may be hosted remotely
</p>
</li>
<li><p>gene or protein expression data alongside coverage tracks
</p>
</li>
<li><p>peak-gene links
</p>
</li>
<li><p>the position of individual sequenced fragments as a heatmap
</p>
</li>
<li><p>data for multiple chromatin assays simultaneously
</p>
</li>
<li><p>a pseudobulk for all cells combined
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code><a href="patchwork.html#topic+patchwork">patchwork</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  validate.fragments = FALSE
)
Fragments(atac_small) &lt;- fragments

# Basic coverage plot
CoveragePlot(object = atac_small, region = c("chr1-713500-714500"))

# Show additional ranges
ranges.show &lt;- StringToGRanges("chr1-713750-714000")
CoveragePlot(object = atac_small, region = c("chr1-713500-714500"), ranges = ranges.show)

# Highlight region
CoveragePlot(object = atac_small, region = c("chr1-713500-714500"), region.highlight = ranges.show)

# Change highlight color
ranges.show$color &lt;- "orange"
CoveragePlot(object = atac_small, region = c("chr1-713500-714500"), region.highlight = ranges.show)

# Show expression data
CoveragePlot(object = atac_small, region = c("chr1-713500-714500"), features = "ELK1")

</code></pre>

<hr>
<h2 id='CreateChromatinAssay'>Create ChromatinAssay object</h2><span id='topic+CreateChromatinAssay'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object from a count matrix or
normalized data matrix. The expected format of the input matrix is features x
cells. A set of genomic ranges must be supplied along with the matrix, with
the length of the ranges equal to the number of rows in the matrix. If a set
of genomic ranges are not supplied, they will be extracted from the
row names of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateChromatinAssay(
  counts,
  data,
  min.cells = 0,
  min.features = 0,
  max.cells = NULL,
  ranges = NULL,
  motifs = NULL,
  fragments = NULL,
  genome = NULL,
  annotation = NULL,
  bias = NULL,
  positionEnrichment = NULL,
  sep = c("-", "-"),
  validate.fragments = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateChromatinAssay_+3A_counts">counts</code></td>
<td>
<p>Unnormalized data (raw counts)</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_data">data</code></td>
<td>
<p>Normalized data; if provided, do not pass counts</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_min.cells">min.cells</code></td>
<td>
<p>Include features detected in at least this many cells.
Will subset the counts matrix as well.
To reintroduce excluded features, create a new object with a lower cutoff.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_min.features">min.features</code></td>
<td>
<p>Include cells where at least this many features are
detected.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_max.cells">max.cells</code></td>
<td>
<p>Include features detected in less than this many cells.
Will subset the counts matrix as well.
To reintroduce excluded features, create a new object with a higher cutoff.
This can be useful for chromatin assays where certain artefactual loci
accumulate reads in all cells. A percentage cutoff can also be set using
'q' followed by the percentage of cells, for example 'q90' will discard
features detected in 90 percent of cells.
If NULL (default), do not apply any maximum value.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_ranges">ranges</code></td>
<td>
<p>A set of <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> corresponding to
the rows of the input matrix</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_motifs">motifs</code></td>
<td>
<p>A Motif object (not required)</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_fragments">fragments</code></td>
<td>
<p>Path to a tabix-indexed fragments file for the data
contained in the input matrix. If multiple fragment files are required,
you can add additional <code><a href="#topic+Fragment">Fragment</a></code> object to the assay after it is
created using the <code><a href="#topic+CreateFragmentObject">CreateFragmentObject</a></code> and
<code><a href="#topic+Fragments">Fragments</a></code> functions. Alternatively, a list of
<code><a href="#topic+Fragment">Fragment</a></code> objects can be provided.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_genome">genome</code></td>
<td>
<p>A <code><a href="GenomeInfoDb.html#topic+Seqinfo">Seqinfo</a></code> object containing basic
information about the genome used. Alternatively, the name of a UCSC genome
can be provided and the sequence information will be downloaded from UCSC.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_annotation">annotation</code></td>
<td>
<p>A set of <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> containing
annotations for the genome used</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_bias">bias</code></td>
<td>
<p>A Tn5 integration bias matrix</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_positionenrichment">positionEnrichment</code></td>
<td>
<p>A named list of matrices containing positional
signal enrichment information for each cell. Should be a cell x position
matrix, centered on an element of interest (for example, TSS sites).</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates.
First element is used to separate the chromosome from the coordinates,
second element is used to separate the start from end coordinate. Only
used if <code>ranges</code> is NULL.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_validate.fragments">validate.fragments</code></td>
<td>
<p>Check that cells in the assay are present in the
fragment file.</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="CreateChromatinAssay_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+CreateFragmentObject">CreateFragmentObject</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='CreateFragmentObject'>Create a Fragment object</h2><span id='topic+CreateFragmentObject'></span>

<h3>Description</h3>

<p>Create a <code>Fragment</code> object to store fragment file information.
This object stores a 32-bit MD5 hash of the fragment file and the fragment
file index so that any changes to the files on-disk can be detected. A check
is also performed to ensure that the expected cells are present in the
fragment file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateFragmentObject(
  path,
  cells = NULL,
  validate.fragments = TRUE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateFragmentObject_+3A_path">path</code></td>
<td>
<p>A path to the fragment file. The file should contain a tabix
index in the same directory.</p>
</td></tr>
<tr><td><code id="CreateFragmentObject_+3A_cells">cells</code></td>
<td>
<p>A named character vector containing cell barcodes contained in
the fragment file. This does not need to be all cells in the fragment file,
but there should be no cells in the vector that are not present in the
fragment file. A search of the file will be performed until at least one
fragment from each cell is found. If NULL, don't check for expected cells.
</p>
<p>Each element of the vector should be a cell barcode that appears in the
fragment file, and the name of each element should be the corresponding cell
name in the object.</p>
</td></tr>
<tr><td><code id="CreateFragmentObject_+3A_validate.fragments">validate.fragments</code></td>
<td>
<p>Check that expected cells are present in the
fragment file.</p>
</td></tr>
<tr><td><code id="CreateFragmentObject_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="CreateFragmentObject_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>ValidateCells</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
cells &lt;- colnames(x = atac_small)
names(x = cells) &lt;- paste0("test_", cells)
frags &lt;- CreateFragmentObject(path = fpath, cells = cells, verbose = FALSE, tolerance = 0.5)
</code></pre>

<hr>
<h2 id='CreateMotifMatrix'>Create motif matrix</h2><span id='topic+CreateMotifMatrix'></span>

<h3>Description</h3>

<p>Create a motif x feature matrix from a set of genomic ranges,
the genome, and a set of position weight matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateMotifMatrix(
  features,
  pwm,
  genome,
  score = FALSE,
  use.counts = FALSE,
  sep = c("-", "-"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateMotifMatrix_+3A_features">features</code></td>
<td>
<p>A GRanges object containing a set of genomic features</p>
</td></tr>
<tr><td><code id="CreateMotifMatrix_+3A_pwm">pwm</code></td>
<td>
<p>A <code><a href="TFBSTools.html#topic+PFMatrixList">PFMatrixList</a></code> or
<code><a href="TFBSTools.html#topic+PWMatrixList">PWMatrixList</a></code>
object containing position weight/frequency matrices to use</p>
</td></tr>
<tr><td><code id="CreateMotifMatrix_+3A_genome">genome</code></td>
<td>
<p>Any object compatible with the <code>genome</code> argument
in <code><a href="motifmatchr.html#topic+matchMotifs">matchMotifs</a></code></p>
</td></tr>
<tr><td><code id="CreateMotifMatrix_+3A_score">score</code></td>
<td>
<p>Record the motif match score, rather than presence/absence
(default FALSE)</p>
</td></tr>
<tr><td><code id="CreateMotifMatrix_+3A_use.counts">use.counts</code></td>
<td>
<p>Record motif counts per region. If FALSE (default),
record presence/absence of motif. Only applicable if <code>score=FALSE</code>.</p>
</td></tr>
<tr><td><code id="CreateMotifMatrix_+3A_sep">sep</code></td>
<td>
<p>A length-2 character vector containing the separators to be used
when constructing matrix rownames from the GRanges</p>
</td></tr>
<tr><td><code id="CreateMotifMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="motifmatchr.html#topic+matchMotifs">matchMotifs</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires that motifmatchr is installed
<a href="https://www.bioconductor.org/packages/motifmatchr/">https://www.bioconductor.org/packages/motifmatchr/</a>.
</p>


<h3>Value</h3>

<p>Returns a sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(JASPAR2018)
library(TFBSTools)
library(BSgenome.Hsapiens.UCSC.hg19)

pwm &lt;- getMatrixSet(
  x = JASPAR2018,
  opts = list(species = 9606, all_versions = FALSE)
)
motif.matrix &lt;- CreateMotifMatrix(
  features = granges(atac_small),
  pwm = pwm,
  genome = BSgenome.Hsapiens.UCSC.hg19
)

## End(Not run)
</code></pre>

<hr>
<h2 id='CreateMotifObject'>Create motif object</h2><span id='topic+CreateMotifObject'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+Motif-class">Motif-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateMotifObject(
  data = NULL,
  pwm = NULL,
  motif.names = NULL,
  positions = NULL,
  meta.data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateMotifObject_+3A_data">data</code></td>
<td>
<p>A motif x region matrix</p>
</td></tr>
<tr><td><code id="CreateMotifObject_+3A_pwm">pwm</code></td>
<td>
<p>A named list of position weight matrices or position frequency
matrices matching the motif names in <code>data</code>.
Can be of class PFMatrixList.</p>
</td></tr>
<tr><td><code id="CreateMotifObject_+3A_motif.names">motif.names</code></td>
<td>
<p>A named list of motif names. List element names
must match the names given in <code>pwm</code>. If NULL, use the names from the
list of position weight or position frequency matrices. This can be used to
set a alternative common name for the motif. If a PFMatrixList is passed to
<code>pwm</code>, it will pull the motif name from the PFMatrixList.</p>
</td></tr>
<tr><td><code id="CreateMotifObject_+3A_positions">positions</code></td>
<td>
<p>A <code><a href="GenomicRanges.html#topic+GRangesList">GRangesList</a></code> object containing
exact positions of each motif.</p>
</td></tr>
<tr><td><code id="CreateMotifObject_+3A_meta.data">meta.data</code></td>
<td>
<p>A data.frame containing metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+Motif">Motif</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>motif.matrix &lt;- matrix(
  data = sample(c(0,1),
    size = 100,
    replace = TRUE),
  ncol = 5
)
motif &lt;- CreateMotifObject(data = motif.matrix)
</code></pre>

<hr>
<h2 id='DensityScatter'>Scatterplot colored by point density</h2><span id='topic+DensityScatter'></span>

<h3>Description</h3>

<p>Create a scatterplot using variables in the object metadata
and color cells by the density of points in the x-y space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DensityScatter(object, x, y, log_x = FALSE, log_y = FALSE, quantiles = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DensityScatter_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="DensityScatter_+3A_x">x</code></td>
<td>
<p>Name of metadata variable to plot on x axis</p>
</td></tr>
<tr><td><code id="DensityScatter_+3A_y">y</code></td>
<td>
<p>Name of metadata variable to plot on y axis</p>
</td></tr>
<tr><td><code id="DensityScatter_+3A_log_x">log_x</code></td>
<td>
<p>log10 transform x values</p>
</td></tr>
<tr><td><code id="DensityScatter_+3A_log_y">log_y</code></td>
<td>
<p>log10 transform y values</p>
</td></tr>
<tr><td><code id="DensityScatter_+3A_quantiles">quantiles</code></td>
<td>
<p>Vector of quantiles to display
for x and y data distribution. Must be integer values
between 0 and 100.
TRUE can be passed as a shorthand way to set
<code>c(5, 10, 90, 95)</code>. If FALSE or NULL, no quantile
information is displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object
</p>

<hr>
<h2 id='DepthCor'>Plot sequencing depth correlation</h2><span id='topic+DepthCor'></span>

<h3>Description</h3>

<p>Compute the correlation between total counts and each reduced
dimension component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DepthCor(object, assay = NULL, reduction = "lsi", n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DepthCor_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="DepthCor_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use for sequencing depth. If NULL, use the
default assay.</p>
</td></tr>
<tr><td><code id="DepthCor_+3A_reduction">reduction</code></td>
<td>
<p>Name of a dimension reduction stored in the
input object</p>
</td></tr>
<tr><td><code id="DepthCor_+3A_n">n</code></td>
<td>
<p>Number of components to use. If <code>NULL</code>, use all components.</p>
</td></tr>
<tr><td><code id="DepthCor_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+cor">cor</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
DepthCor(object = atac_small)

</code></pre>

<hr>
<h2 id='DownsampleFeatures'>Downsample Features</h2><span id='topic+DownsampleFeatures'></span>

<h3>Description</h3>

<p>Randomly downsample features and assign to VariableFeatures for the object.
This will select n features at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DownsampleFeatures(object, assay = NULL, n = 20000, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DownsampleFeatures_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="DownsampleFeatures_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default is the active assay.</p>
</td></tr>
<tr><td><code id="DownsampleFeatures_+3A_n">n</code></td>
<td>
<p>Number of features to retain (default 20000).</p>
</td></tr>
<tr><td><code id="DownsampleFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object with
<code><a href="SeuratObject.html#topic+VariableFeatures">VariableFeatures</a></code> set to the randomly sampled features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DownsampleFeatures(atac_small, n = 10)
</code></pre>

<hr>
<h2 id='ExpressionPlot'>Plot gene expression</h2><span id='topic+ExpressionPlot'></span>

<h3>Description</h3>

<p>Display gene expression values for different groups of cells and different
genes. Genes will be arranged on the x-axis and different groups stacked on
the y-axis, with expression value distribution for each group shown as a
violin plot. This is designed to work alongside a genomic coverage track,
and the plot will be able to be aligned with coverage tracks for the same
groups of cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpressionPlot(
  object,
  features,
  assay = NULL,
  group.by = NULL,
  idents = NULL,
  slot = "data"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpressionPlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="ExpressionPlot_+3A_features">features</code></td>
<td>
<p>A list of features to plot</p>
</td></tr>
<tr><td><code id="ExpressionPlot_+3A_assay">assay</code></td>
<td>
<p>Name of the assay storing expression information</p>
</td></tr>
<tr><td><code id="ExpressionPlot_+3A_group.by">group.by</code></td>
<td>
<p>A grouping variable to group cells by. If NULL, use the
current cell identities</p>
</td></tr>
<tr><td><code id="ExpressionPlot_+3A_idents">idents</code></td>
<td>
<p>A list of identities to include in the plot. If NULL, include
all identities</p>
</td></tr>
<tr><td><code id="ExpressionPlot_+3A_slot">slot</code></td>
<td>
<p>Which slot to pull expression data from</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ExpressionPlot(atac_small, features = "TSPAN6", assay = "RNA")

</code></pre>

<hr>
<h2 id='Extend'>Extend</h2><span id='topic+Extend'></span>

<h3>Description</h3>

<p>Resize GenomicRanges upstream and or downstream.
From <a href="https://support.bioconductor.org/p/78652/">https://support.bioconductor.org/p/78652/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Extend(x, upstream = 0, downstream = 0, from.midpoint = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extend_+3A_x">x</code></td>
<td>
<p>A range</p>
</td></tr>
<tr><td><code id="Extend_+3A_upstream">upstream</code></td>
<td>
<p>Length to extend upstream</p>
</td></tr>
<tr><td><code id="Extend_+3A_downstream">downstream</code></td>
<td>
<p>Length to extend downstream</p>
</td></tr>
<tr><td><code id="Extend_+3A_from.midpoint">from.midpoint</code></td>
<td>
<p>Count bases from region midpoint,
rather than the 5' or 3' end for upstream and downstream
respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Extend(x = blacklist_hg19, upstream = 100, downstream = 100)
</code></pre>

<hr>
<h2 id='FeatureMatrix'>Feature Matrix</h2><span id='topic+FeatureMatrix'></span>

<h3>Description</h3>

<p>Construct a feature x cell matrix from a genomic fragments file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FeatureMatrix(
  fragments,
  features,
  cells = NULL,
  process_n = 2000,
  sep = c("-", "-"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FeatureMatrix_+3A_fragments">fragments</code></td>
<td>
<p>A list of <code><a href="#topic+Fragment">Fragment</a></code> objects. Note that if
setting the <code>cells</code> parameter, the requested cells should be present in
the supplied <code>Fragment</code> objects. However, if the cells information in
the fragment object is not set (<code>Cells(fragments)</code> is <code>NULL</code>), then
the fragment object will still be searched.</p>
</td></tr>
<tr><td><code id="FeatureMatrix_+3A_features">features</code></td>
<td>
<p>A GRanges object containing a set of genomic intervals.
These will form the rows of the matrix, with each entry recording the number
of unique reads falling in the genomic region for each cell.</p>
</td></tr>
<tr><td><code id="FeatureMatrix_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to include. If NULL, include all cells found
in the fragments file</p>
</td></tr>
<tr><td><code id="FeatureMatrix_+3A_process_n">process_n</code></td>
<td>
<p>Number of regions to load into memory at a time, per thread.
Processing more regions at once can be faster but uses more memory.</p>
</td></tr>
<tr><td><code id="FeatureMatrix_+3A_sep">sep</code></td>
<td>
<p>Vector of separators to use for genomic string. First element is
used to separate chromosome and coordinates, second separator is used to
separate start and end coordinates.</p>
</td></tr>
<tr><td><code id="FeatureMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(fpath)
FeatureMatrix(
  fragments = fragments,
  features = granges(atac_small)
)
</code></pre>

<hr>
<h2 id='FilterCells'>Filter cells from fragment file</h2><span id='topic+FilterCells'></span>

<h3>Description</h3>

<p>Remove all fragments that are not from an allowed set of cell barcodes from
the fragment file. This will create a new file on disk that only contains
fragments from cells specified in the <code>cells</code> argument. The output file
is block gzip-compressed and indexed, ready for use with Signac functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterCells(
  fragments,
  cells,
  outfile = NULL,
  buffer_length = 256L,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterCells_+3A_fragments">fragments</code></td>
<td>
<p>Path to a fragment file</p>
</td></tr>
<tr><td><code id="FilterCells_+3A_cells">cells</code></td>
<td>
<p>A vector of cells to keep</p>
</td></tr>
<tr><td><code id="FilterCells_+3A_outfile">outfile</code></td>
<td>
<p>Name for output file</p>
</td></tr>
<tr><td><code id="FilterCells_+3A_buffer_length">buffer_length</code></td>
<td>
<p>Size of buffer to be read from the fragment file. This
must be longer than the longest line in the file.</p>
</td></tr>
<tr><td><code id="FilterCells_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
tmpf &lt;- tempfile(fileext = ".gz")
FilterCells(
  fragments = fpath,
  cells = head(colnames(atac_small)),
  outfile = tmpf
)
file.remove(tmpf)
</code></pre>

<hr>
<h2 id='FindClonotypes'>Find clonotypes</h2><span id='topic+FindClonotypes'></span>

<h3>Description</h3>

<p>Identify groups of related cells from allele frequency data. This will
cluster the cells based on their allele frequencies, reorder the factor
levels for the cluster identities by hierarchical clustering the collapsed
(pseudobulk) cluster allele frequencies, and set the variable features for
the allele frequency assay to the order of features defined by hierarchical
clustering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindClonotypes(
  object,
  assay = NULL,
  features = NULL,
  metric = "cosine",
  resolution = 1,
  k = 10,
  algorithm = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindClonotypes_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FindClonotypes_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="FindClonotypes_+3A_features">features</code></td>
<td>
<p>Features to include when constructing neighbor graph</p>
</td></tr>
<tr><td><code id="FindClonotypes_+3A_metric">metric</code></td>
<td>
<p>Distance metric to use</p>
</td></tr>
<tr><td><code id="FindClonotypes_+3A_resolution">resolution</code></td>
<td>
<p>Clustering resolution to use. See
<code><a href="Seurat.html#topic+FindClusters">FindClusters</a></code></p>
</td></tr>
<tr><td><code id="FindClonotypes_+3A_k">k</code></td>
<td>
<p>Passed to <code>k.param</code> argument in
<code><a href="Seurat.html#topic+FindNeighbors">FindNeighbors</a></code></p>
</td></tr>
<tr><td><code id="FindClonotypes_+3A_algorithm">algorithm</code></td>
<td>
<p>Community detection algorithm to use. See
<code><a href="Seurat.html#topic+FindClusters">FindClusters</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>

<hr>
<h2 id='FindMotifs'>FindMotifs</h2><span id='topic+FindMotifs'></span>

<h3>Description</h3>

<p>Find motifs over-represented in a given set of genomic features.
Computes the number of features containing the motif (observed) and
compares this to the total number of features containing the
motif (background) using the hypergeometric test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindMotifs(
  object,
  features,
  background = 40000,
  assay = NULL,
  verbose = TRUE,
  p.adjust.method = "BH",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindMotifs_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FindMotifs_+3A_features">features</code></td>
<td>
<p>A vector of features to test for enrichments over background</p>
</td></tr>
<tr><td><code id="FindMotifs_+3A_background">background</code></td>
<td>
<p>Either a vector of features to use as the background set,
or a number specify the number of features to randomly select as a background
set. If a number is provided, regions will be selected to match the sequence
characteristics of the query features. To match the sequence characteristics,
these characteristics must be stored in the feature metadata for the assay.
This can be added using the
<code><a href="#topic+RegionStats">RegionStats</a></code> function. If NULL, use all features in the assay.</p>
</td></tr>
<tr><td><code id="FindMotifs_+3A_assay">assay</code></td>
<td>
<p>Which assay to use. Default is the active assay</p>
</td></tr>
<tr><td><code id="FindMotifs_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="FindMotifs_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Multiple testing correction method to be applied.
Passed to <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.</p>
</td></tr>
<tr><td><code id="FindMotifs_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+MatchRegionStats">MatchRegionStats</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>de.motif &lt;- head(rownames(atac_small))
bg.peaks &lt;- tail(rownames(atac_small))
FindMotifs(
  object = atac_small,
  features = de.motif,
  background = bg.peaks
)
</code></pre>

<hr>
<h2 id='findOverlaps-methods'>Find overlapping ranges for ChromatinAssay objects</h2><span id='topic+findOverlaps-methods'></span><span id='topic+findOverlaps'></span><span id='topic+findOverlaps+2CVector+2CChromatinAssay-method'></span><span id='topic+findOverlaps+2CChromatinAssay+2CVector-method'></span><span id='topic+findOverlaps+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+findOverlaps+2CVector+2CSeurat-method'></span><span id='topic+findOverlaps+2CSeurat+2CVector-method'></span><span id='topic+findOverlaps+2CSeurat+2CSeurat-method'></span><span id='topic+countOverlaps+2CVector+2CChromatinAssay-method'></span><span id='topic+countOverlaps'></span><span id='topic+countOverlaps+2CChromatinAssay+2CVector-method'></span><span id='topic+countOverlaps+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+countOverlaps+2CSeurat+2CVector-method'></span><span id='topic+countOverlaps+2CVector+2CSeurat-method'></span><span id='topic+countOverlaps+2CSeurat+2CSeurat-method'></span>

<h3>Description</h3>

<p>The <code>findOverlaps, countOverlaps</code> methods are available for
<code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> objects. This allows finding overlaps between
genomic ranges and the ranges stored in the ChromatinAssay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Vector,ChromatinAssay'
findOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  select = c("all", "first", "last", "arbitrary"),
  ignore.strand = FALSE
)

## S4 method for signature 'ChromatinAssay,Vector'
findOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  select = c("all", "first", "last", "arbitrary"),
  ignore.strand = FALSE
)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
findOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  select = c("all", "first", "last", "arbitrary"),
  ignore.strand = FALSE
)

## S4 method for signature 'Vector,Seurat'
findOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  select = c("all", "first", "last", "arbitrary"),
  ignore.strand = FALSE
)

## S4 method for signature 'Seurat,Vector'
findOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  select = c("all", "first", "last", "arbitrary"),
  ignore.strand = FALSE
)

## S4 method for signature 'Seurat,Seurat'
findOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  select = c("all", "first", "last", "arbitrary"),
  ignore.strand = FALSE
)

## S4 method for signature 'Vector,ChromatinAssay'
countOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE
)

## S4 method for signature 'ChromatinAssay,Vector'
countOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE
)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
countOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE
)

## S4 method for signature 'Seurat,Vector'
countOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE
)

## S4 method for signature 'Vector,Seurat'
countOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE
)

## S4 method for signature 'Seurat,Seurat'
countOverlaps(
  query,
  subject,
  maxgap = -1L,
  minoverlap = 0L,
  type = c("any", "start", "end", "within", "equal"),
  ignore.strand = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOverlaps-methods_+3A_query">query</code>, <code id="findOverlaps-methods_+3A_subject">subject</code></td>
<td>
<p>A <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object</p>
</td></tr>
<tr><td><code id="findOverlaps-methods_+3A_maxgap">maxgap</code>, <code id="findOverlaps-methods_+3A_minoverlap">minoverlap</code>, <code id="findOverlaps-methods_+3A_type">type</code>, <code id="findOverlaps-methods_+3A_select">select</code>, <code id="findOverlaps-methods_+3A_ignore.strand">ignore.strand</code></td>
<td>
<p>See
<code>?<a href="GenomicRanges.html#topic+findOverlaps">findOverlaps</a></code> in the <span class="pkg">GenomicRanges</span> and
<span class="pkg">IRanges</span> packages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a ChromatinAssay is set as the default assay in a
<code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object, you can also call <code>findOverlaps</code>
directly on the Seurat object.
</p>


<h3>Value</h3>

<p>See <code><a href="GenomicRanges.html#topic+findOverlaps">findOverlaps</a></code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>findOverlaps(query = ChromatinAssay, subject = Vector)</code>: method for ChromatinAssay, Vector
</p>
</li>
<li> <p><code>findOverlaps(query = ChromatinAssay, subject = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>findOverlaps(query = Vector, subject = Seurat)</code>: method for Vector, Seurat
</p>
</li>
<li> <p><code>findOverlaps(query = Seurat, subject = Vector)</code>: method for Seurat, Vector
</p>
</li>
<li> <p><code>findOverlaps(query = Seurat, subject = Seurat)</code>: method for Seurat, Seurat
</p>
</li>
<li> <p><code>countOverlaps(query = Vector, subject = ChromatinAssay)</code>: method for Vector, ChromatinAssay
</p>
</li>
<li> <p><code>countOverlaps(query = ChromatinAssay, subject = Vector)</code>: method for ChromatinAssay, Vector
</p>
</li>
<li> <p><code>countOverlaps(query = ChromatinAssay, subject = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>countOverlaps(query = Seurat, subject = Vector)</code>: method for Seurat, Vector
</p>
</li>
<li> <p><code>countOverlaps(query = Vector, subject = Seurat)</code>: method for Vector, Seurat
</p>
</li>
<li> <p><code>countOverlaps(query = Seurat, subject = Seurat)</code>: method for Seurat, Seurat
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li><p><a href="IRanges.html#topic+findOverlaps-methods">findOverlaps-methods</a> in the <span class="pkg">IRanges</span> package.
</p>
</li>
<li><p><a href="GenomicRanges.html#topic+findOverlaps-methods">findOverlaps-methods</a> in the <span class="pkg">GenomicRanges</span>
package
</p>
</li>
<li><p><a href="#topic+ChromatinAssay-class">ChromatinAssay-class</a>
</p>
</li></ul>


<hr>
<h2 id='FindTopFeatures'>Find most frequently observed features</h2><span id='topic+FindTopFeatures'></span><span id='topic+FindTopFeatures.default'></span><span id='topic+FindTopFeatures.Assay'></span><span id='topic+FindTopFeatures.StdAssay'></span><span id='topic+FindTopFeatures.Seurat'></span>

<h3>Description</h3>

<p>Find top features for a given assay based on total number of counts for the
feature. Can specify a minimum cell count, or a lower percentile
bound to determine the set of variable features. Running this function will
store the total counts and percentile rank for each feature in the feature
metadata for the assay. To only compute the feature metadata, without
changing the variable features for the assay, set <code>min.cutoff=NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindTopFeatures(object, ...)

## Default S3 method:
FindTopFeatures(object, assay = NULL, min.cutoff = "q5", verbose = TRUE, ...)

## S3 method for class 'Assay'
FindTopFeatures(object, assay = NULL, min.cutoff = "q5", verbose = TRUE, ...)

## S3 method for class 'StdAssay'
FindTopFeatures(object, assay = NULL, min.cutoff = "q5", verbose = TRUE, ...)

## S3 method for class 'Seurat'
FindTopFeatures(object, assay = NULL, min.cutoff = "q5", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindTopFeatures_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FindTopFeatures_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="FindTopFeatures_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="FindTopFeatures_+3A_min.cutoff">min.cutoff</code></td>
<td>
<p>Cutoff for feature to be included in the VariableFeatures
for the object. This can be a percentile specified as 'q' followed by the
minimum percentile, for example 'q5' to set the top 95% most common features
as the VariableFeatures for the object. Alternatively, this can be an integer
specifying the minimum number of counts for the feature
to be included in the set of VariableFeatures. For example, setting to 10
will include features with &gt;10 total counts in the set of VariableFeatures. If NULL,
include all features in VariableFeatures. If NA, VariableFeatures will not be
altered, and only the feature metadata will be updated with the total counts
and percentile rank for each feature.</p>
</td></tr>
<tr><td><code id="FindTopFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FindTopFeatures(object = atac_small[['peaks']]['data'])
FindTopFeatures(object = atac_small[['peaks']])
FindTopFeatures(object = atac_small[['peaks']])
FindTopFeatures(atac_small)
</code></pre>

<hr>
<h2 id='Footprint'>Transcription factor footprinting analysis</h2><span id='topic+Footprint'></span><span id='topic+Footprint.ChromatinAssay'></span><span id='topic+Footprint.Seurat'></span>

<h3>Description</h3>

<p>Compute the normalized observed/expected Tn5 insertion frequency
for each position surrounding a set of motif instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Footprint(object, ...)

## S3 method for class 'ChromatinAssay'
Footprint(
  object,
  genome,
  motif.name = NULL,
  key = motif.name,
  regions = NULL,
  assay = NULL,
  upstream = 250,
  downstream = 250,
  compute.expected = TRUE,
  in.peaks = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
Footprint(
  object,
  genome,
  regions = NULL,
  motif.name = NULL,
  assay = NULL,
  upstream = 250,
  downstream = 250,
  in.peaks = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Footprint_+3A_object">object</code></td>
<td>
<p>A Seurat or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="Footprint_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Footprint_+3A_genome">genome</code></td>
<td>
<p>A <code>BSgenome</code> object or any other object supported by
<code>getSeq</code>. Do <code>showMethods("getSeq")</code> to get the list of all
supported object types.</p>
</td></tr>
<tr><td><code id="Footprint_+3A_motif.name">motif.name</code></td>
<td>
<p>Name of a motif stored in the assay to footprint. If not
supplied, must supply a set of regions.</p>
</td></tr>
<tr><td><code id="Footprint_+3A_key">key</code></td>
<td>
<p>Key to store positional enrichment information under.</p>
</td></tr>
<tr><td><code id="Footprint_+3A_regions">regions</code></td>
<td>
<p>A set of genomic ranges containing the motif instances. These
should all be the same width.</p>
</td></tr>
<tr><td><code id="Footprint_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="Footprint_+3A_upstream">upstream</code></td>
<td>
<p>Number of bases to extend upstream</p>
</td></tr>
<tr><td><code id="Footprint_+3A_downstream">downstream</code></td>
<td>
<p>Number of bases to extend downstream</p>
</td></tr>
<tr><td><code id="Footprint_+3A_compute.expected">compute.expected</code></td>
<td>
<p>Find the expected number of insertions at each
position given the local DNA sequence context and the insertion bias of Tn5</p>
</td></tr>
<tr><td><code id="Footprint_+3A_in.peaks">in.peaks</code></td>
<td>
<p>Restrict motifs to those that fall in peaks</p>
</td></tr>
<tr><td><code id="Footprint_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>

<hr>
<h2 id='FractionCountsInRegion'>Fraction of counts in a genomic region</h2><span id='topic+FractionCountsInRegion'></span>

<h3>Description</h3>

<p>Find the fraction of counts per cell that overlap a given set of genomic
ranges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FractionCountsInRegion(object, regions, assay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FractionCountsInRegion_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FractionCountsInRegion_+3A_regions">regions</code></td>
<td>
<p>A GRanges object containing a set of genomic regions</p>
</td></tr>
<tr><td><code id="FractionCountsInRegion_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="FractionCountsInRegion_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+CountsInRegion">CountsInRegion</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
FractionCountsInRegion(
  object = atac_small,
  assay = 'bins',
  regions = blacklist_hg19
)

## End(Not run)
</code></pre>

<hr>
<h2 id='Fragment-class'>The Fragment class</h2><span id='topic+Fragment-class'></span><span id='topic+Fragment'></span>

<h3>Description</h3>

<p>The Fragment class is designed to hold information needed for working with
fragment files.
</p>


<h3>Slots</h3>


<dl>
<dt><code>path</code></dt><dd><p>Path to the fragment file on disk.
See <a href="https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/fragments">https://support.10xgenomics.com/single-cell-atac/software/pipelines/latest/output/fragments</a></p>
</dd>
<dt><code>hash</code></dt><dd><p>A vector of two md5sums: first element is the md5sum of the
fragment file, the second element is the md5sum of the index.</p>
</dd>
<dt><code>cells</code></dt><dd><p>A named vector of cells where each element is the cell barcode
as it appears in the fragment file, and the name of each element is the
corresponding cell barcode as stored in the ChromatinAssay object.</p>
</dd>
</dl>

<hr>
<h2 id='FragmentHistogram'>Plot fragment length histogram</h2><span id='topic+FragmentHistogram'></span>

<h3>Description</h3>

<p>Plot the frequency that fragments of different lengths are present for
different groups of cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FragmentHistogram(
  object,
  assay = NULL,
  region = "chr1-1-2000000",
  group.by = NULL,
  cells = NULL,
  log.scale = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FragmentHistogram_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FragmentHistogram_+3A_assay">assay</code></td>
<td>
<p>Which assay to use. Default is the active assay.</p>
</td></tr>
<tr><td><code id="FragmentHistogram_+3A_region">region</code></td>
<td>
<p>Genomic range to use. Default is fist two megabases of
chromosome 1. Can be a GRanges object, a string, or a vector
of strings.</p>
</td></tr>
<tr><td><code id="FragmentHistogram_+3A_group.by">group.by</code></td>
<td>
<p>Name of one or more metadata columns to group (color) the
cells by. Default is the current cell identities</p>
</td></tr>
<tr><td><code id="FragmentHistogram_+3A_cells">cells</code></td>
<td>
<p>Which cells to plot. Default all cells</p>
</td></tr>
<tr><td><code id="FragmentHistogram_+3A_log.scale">log.scale</code></td>
<td>
<p>Display Y-axis on log scale. Default is FALSE.</p>
</td></tr>
<tr><td><code id="FragmentHistogram_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
Fragments(atac_small) &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  validate.fragments = FALSE
)
FragmentHistogram(object = atac_small, region = "chr1-10245-780007")

</code></pre>

<hr>
<h2 id='Fragments'>Get the Fragment objects</h2><span id='topic+Fragments'></span><span id='topic+Fragments+3C-'></span><span id='topic+Fragments.ChromatinAssay'></span><span id='topic+Fragments.Seurat'></span><span id='topic+Fragments+3C-.ChromatinAssay'></span><span id='topic+Fragments+3C-.Seurat'></span>

<h3>Description</h3>

<p>Get the Fragment objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fragments(object, ...)

Fragments(object, ...) &lt;- value

## S3 method for class 'ChromatinAssay'
Fragments(object, ...)

## S3 method for class 'Seurat'
Fragments(object, ...)

## S3 replacement method for class 'ChromatinAssay'
Fragments(object, ...) &lt;- value

## S3 replacement method for class 'Seurat'
Fragments(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fragments_+3A_object">object</code></td>
<td>
<p>A Seurat object or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="Fragments_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Fragments_+3A_value">value</code></td>
<td>
<p>A <code><a href="#topic+Fragment">Fragment</a></code> object or list of Fragment objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of <code><a href="#topic+Fragment">Fragment</a></code> objects. If there are
no Fragment objects present, returns an empty list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Fragments(atac_small[["peaks"]])
Fragments(atac_small)
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  validate.fragments = FALSE
)
Fragments(atac_small[["bins"]]) &lt;- fragments
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  validate.fragments = FALSE
)
Fragments(atac_small) &lt;- fragments
</code></pre>

<hr>
<h2 id='FRiP'>Calculate fraction of reads in peaks per cell</h2><span id='topic+FRiP'></span>

<h3>Description</h3>

<p>Calculate fraction of reads in peaks per cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FRiP(object, assay, total.fragments, col.name = "FRiP", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FRiP_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="FRiP_+3A_assay">assay</code></td>
<td>
<p>Name of the assay containing a peak x cell matrix</p>
</td></tr>
<tr><td><code id="FRiP_+3A_total.fragments">total.fragments</code></td>
<td>
<p>Name of a metadata column containing the total number
of sequenced fragments for each cell. This can be computed using the
<code><a href="#topic+CountFragments">CountFragments</a></code> function.</p>
</td></tr>
<tr><td><code id="FRiP_+3A_col.name">col.name</code></td>
<td>
<p>Name of column in metadata to store the FRiP information.</p>
</td></tr>
<tr><td><code id="FRiP_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FRiP(object = atac_small, assay = 'peaks', total.fragments = "fragments")
</code></pre>

<hr>
<h2 id='GeneActivity'>Create gene activity matrix</h2><span id='topic+GeneActivity'></span>

<h3>Description</h3>

<p>Compute counts per cell in gene body and promoter region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneActivity(
  object,
  assay = NULL,
  features = NULL,
  extend.upstream = 2000,
  extend.downstream = 0,
  biotypes = "protein_coding",
  max.width = 5e+05,
  process_n = 2000,
  gene.id = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneActivity_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_features">features</code></td>
<td>
<p>Genes to include. If NULL, use all protein-coding genes in
the annotations stored in the object</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend upstream of the TSS</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend downstream of the TTS</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_biotypes">biotypes</code></td>
<td>
<p>Gene biotypes to include. If NULL, use all biotypes in the
gene annotation.</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_max.width">max.width</code></td>
<td>
<p>Maximum allowed gene width for a gene to be quantified.
Setting this parameter can avoid quantifying extremely long transcripts that
can add a relatively long amount of time. If NULL, do not filter genes based
on width.</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_process_n">process_n</code></td>
<td>
<p>Number of regions to load into memory at a time, per thread.
Processing more regions at once can be faster but uses more memory.</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_gene.id">gene.id</code></td>
<td>
<p>Record gene IDs in output matrix rather than gene name.</p>
</td></tr>
<tr><td><code id="GeneActivity_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  validate.fragments = FALSE
)
Fragments(atac_small) &lt;- fragments
GeneActivity(atac_small)
</code></pre>

<hr>
<h2 id='GenomeBinMatrix'>Genome bin matrix</h2><span id='topic+GenomeBinMatrix'></span>

<h3>Description</h3>

<p>Construct a bin x cell matrix from a fragments file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenomeBinMatrix(
  fragments,
  genome,
  cells = NULL,
  binsize = 5000,
  process_n = 2000,
  sep = c("-", "-"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenomeBinMatrix_+3A_fragments">fragments</code></td>
<td>
<p>Path to tabix-indexed fragments file or a list of
<code><a href="#topic+Fragment">Fragment</a></code> objects</p>
</td></tr>
<tr><td><code id="GenomeBinMatrix_+3A_genome">genome</code></td>
<td>
<p>A vector of chromosome sizes for the genome. This is used to
construct the genome bin coordinates. The can be obtained by calling
<code><a href="GenomeInfoDb.html#topic+seqlengths">seqlengths</a></code> on a
<code><a href="BSgenome.html#topic+BSgenome-class">BSgenome-class</a></code> object.</p>
</td></tr>
<tr><td><code id="GenomeBinMatrix_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to include. If NULL, include all cells found
in the fragments file</p>
</td></tr>
<tr><td><code id="GenomeBinMatrix_+3A_binsize">binsize</code></td>
<td>
<p>Size of the genome bins to use</p>
</td></tr>
<tr><td><code id="GenomeBinMatrix_+3A_process_n">process_n</code></td>
<td>
<p>Number of regions to load into memory at a time, per thread.
Processing more regions at once can be faster but uses more memory.</p>
</td></tr>
<tr><td><code id="GenomeBinMatrix_+3A_sep">sep</code></td>
<td>
<p>Vector of separators to use for genomic string. First element is
used to separate chromosome and coordinates, second separator is used to
separate start and end coordinates.</p>
</td></tr>
<tr><td><code id="GenomeBinMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function bins the genome and calls <code><a href="#topic+FeatureMatrix">FeatureMatrix</a></code> to
construct a bin x cell matrix.
</p>


<h3>Value</h3>

<p>Returns a sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
genome &lt;- 780007
names(genome) &lt;- 'chr1'
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(fpath)
GenomeBinMatrix(
  fragments = fragments,
  genome = genome,
  binsize = 1000
)

</code></pre>

<hr>
<h2 id='GetCellsInRegion'>Get cells in a region</h2><span id='topic+GetCellsInRegion'></span>

<h3>Description</h3>

<p>Extract cell names containing reads mapped within a given genomic region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetCellsInRegion(tabix, region, cells = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetCellsInRegion_+3A_tabix">tabix</code></td>
<td>
<p>Tabix object</p>
</td></tr>
<tr><td><code id="GetCellsInRegion_+3A_region">region</code></td>
<td>
<p>A string giving the region to extract from the fragments file</p>
</td></tr>
<tr><td><code id="GetCellsInRegion_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to include in output. If NULL, include all cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
GetCellsInRegion(tabix = fpath, region = "chr1-10245-762629")
</code></pre>

<hr>
<h2 id='GetFootprintData'>Get footprinting data</h2><span id='topic+GetFootprintData'></span>

<h3>Description</h3>

<p>Extract footprint data for a set of transcription factors or metafeatures.
This function will pull accessibility data for a given feature (eg, a TF),
and perform background normalization for each identity class. This is the
data that's used to create TF footprinting plots with the
<code>PlotFootprint</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetFootprintData(
  object,
  features,
  assay = NULL,
  group.by = NULL,
  idents = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetFootprintData_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="GetFootprintData_+3A_features">features</code></td>
<td>
<p>A vector of features to extract data for</p>
</td></tr>
<tr><td><code id="GetFootprintData_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="GetFootprintData_+3A_group.by">group.by</code></td>
<td>
<p>A grouping variable</p>
</td></tr>
<tr><td><code id="GetFootprintData_+3A_idents">idents</code></td>
<td>
<p>Set of identities to group cells by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame with the following columns:
</p>

<ul>
<li><p>group: Cell group (determined by group.by parameter
</p>
</li>
<li><p>position: Position relative to motif center
</p>
</li>
<li><p>count: Normalized Tn5 insertion counts at each position
</p>
</li>
<li><p>norm.value: Normalized Tn5 insertion counts at each position (same as count)
</p>
</li>
<li><p>feature: Name of the footprinted motif
</p>
</li>
<li><p>class: observed or expected
</p>
</li></ul>


<hr>
<h2 id='GetFragmentData'>Get Fragment object data</h2><span id='topic+GetFragmentData'></span>

<h3>Description</h3>

<p>Extract data from a <code><a href="#topic+Fragment-class">Fragment-class</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetFragmentData(object, slot = "path")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetFragmentData_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Fragment">Fragment</a></code> object</p>
</td></tr>
<tr><td><code id="GetFragmentData_+3A_slot">slot</code></td>
<td>
<p>Information to pull from object (path, hash, cells, prefix, suffix)</p>
</td></tr>
</table>

<hr>
<h2 id='GetGRangesFromEnsDb'>Extract genomic ranges from EnsDb object</h2><span id='topic+GetGRangesFromEnsDb'></span>

<h3>Description</h3>

<p>Pulls the transcript information for all chromosomes from an EnsDb object.
This wraps <code><a href="biovizBase.html#topic+crunch">crunch</a></code> and applies the extractor
function to all chromosomes present in the EnsDb object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetGRangesFromEnsDb(
  ensdb,
  standard.chromosomes = TRUE,
  biotypes = c("protein_coding", "lincRNA", "rRNA", "processed_transcript"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetGRangesFromEnsDb_+3A_ensdb">ensdb</code></td>
<td>
<p>An EnsDb object</p>
</td></tr>
<tr><td><code id="GetGRangesFromEnsDb_+3A_standard.chromosomes">standard.chromosomes</code></td>
<td>
<p>Keep only standard chromosomes</p>
</td></tr>
<tr><td><code id="GetGRangesFromEnsDb_+3A_biotypes">biotypes</code></td>
<td>
<p>Biotypes to keep</p>
</td></tr>
<tr><td><code id="GetGRangesFromEnsDb_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>

<hr>
<h2 id='GetIntersectingFeatures'>Find intersecting regions between two objects</h2><span id='topic+GetIntersectingFeatures'></span>

<h3>Description</h3>

<p>Intersects the regions stored in the rownames of two objects and
returns a vector containing the names of rows that intersect
for each object. The order of the row names return corresponds
to the intersecting regions, i.e. the nth feature of the first vector
will intersect the nth feature in the second vector. A distance
parameter can be given, in which case features within the given
distance will be called as intersecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetIntersectingFeatures(
  object.1,
  object.2,
  assay.1 = NULL,
  assay.2 = NULL,
  distance = 0,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetIntersectingFeatures_+3A_object.1">object.1</code></td>
<td>
<p>The first Seurat object</p>
</td></tr>
<tr><td><code id="GetIntersectingFeatures_+3A_object.2">object.2</code></td>
<td>
<p>The second Seurat object</p>
</td></tr>
<tr><td><code id="GetIntersectingFeatures_+3A_assay.1">assay.1</code></td>
<td>
<p>Name of the assay to use in the first object. If NULL, use
the default assay</p>
</td></tr>
<tr><td><code id="GetIntersectingFeatures_+3A_assay.2">assay.2</code></td>
<td>
<p>Name of the assay to use in the second object. If NULL, use
the default assay</p>
</td></tr>
<tr><td><code id="GetIntersectingFeatures_+3A_distance">distance</code></td>
<td>
<p>Maximum distance between regions allowed for an intersection
to be recorded. Default is 0.</p>
</td></tr>
<tr><td><code id="GetIntersectingFeatures_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of two character vectors containing the row names
in each object that overlap each other.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetIntersectingFeatures(
  object.1 = atac_small,
  object.2 = atac_small,
  assay.1 = 'peaks',
  assay.2 = 'bins'
)
</code></pre>

<hr>
<h2 id='GetLinkedGenes'>Get genes linked to peaks</h2><span id='topic+GetLinkedGenes'></span>

<h3>Description</h3>

<p>Retrieve peak-gene links for a given set of genes. Links must be first
obtained by running the <code>LinkPeaks</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLinkedGenes(object, features, assay = NULL, min.abs.score = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLinkedGenes_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="GetLinkedGenes_+3A_features">features</code></td>
<td>
<p>A list of peaks to find linked genes for</p>
</td></tr>
<tr><td><code id="GetLinkedGenes_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay</p>
</td></tr>
<tr><td><code id="GetLinkedGenes_+3A_min.abs.score">min.abs.score</code></td>
<td>
<p>Minimum absolute value of the link score for a link to
be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to obtain the stored results from running the
<code>LinkPeaks</code> function. Alternatively, custom peak-gene linkage methods
can be used as long as they store the gene name, peak name, and a peak-gene
score information as metadata columns named &quot;gene,&quot; &quot;peak,&quot; and &quot;score&quot;
respectively.
</p>


<h3>See Also</h3>

<p>GetLinkedPeaks
</p>

<hr>
<h2 id='GetLinkedPeaks'>Get peaks linked to genes</h2><span id='topic+GetLinkedPeaks'></span>

<h3>Description</h3>

<p>Retrieve peak-gene links for a given set of genes. Links must be first
obtained by running the <code>LinkPeaks</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetLinkedPeaks(object, features, assay = NULL, min.abs.score = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetLinkedPeaks_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="GetLinkedPeaks_+3A_features">features</code></td>
<td>
<p>A list of genes to find linked peaks for</p>
</td></tr>
<tr><td><code id="GetLinkedPeaks_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay</p>
</td></tr>
<tr><td><code id="GetLinkedPeaks_+3A_min.abs.score">min.abs.score</code></td>
<td>
<p>Minimum absolute value of the link score for a link to
be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is designed to obtain the stored results from running the
<code>LinkPeaks</code> function. Alternatively, custom peak-gene linkage methods
can be used as long as they store the gene name, peak name, and a peak-gene
score information as metadata columns named &quot;gene,&quot; &quot;peak,&quot; and &quot;score&quot;
respectively.
</p>


<h3>See Also</h3>

<p>GetLinkedGenes
</p>

<hr>
<h2 id='GetMotifData'>Retrieve a motif matrix</h2><span id='topic+GetMotifData'></span><span id='topic+GetMotifData.Motif'></span><span id='topic+GetMotifData.ChromatinAssay'></span><span id='topic+GetMotifData.Seurat'></span>

<h3>Description</h3>

<p>Get motif matrix for given assay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMotifData(object, ...)

## S3 method for class 'Motif'
GetMotifData(object, slot = "data", ...)

## S3 method for class 'ChromatinAssay'
GetMotifData(object, slot = "data", ...)

## S3 method for class 'Seurat'
GetMotifData(object, assay = NULL, slot = "data", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetMotifData_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="GetMotifData_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="GetMotifData_+3A_slot">slot</code></td>
<td>
<p>Information to pull from object (data, pwm, meta.data)</p>
</td></tr>
<tr><td><code id="GetMotifData_+3A_assay">assay</code></td>
<td>
<p>Which assay to use. Default is the current active assay</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>motif.obj &lt;- SeuratObject::GetAssayData(
  object = atac_small[['peaks']], slot = "motifs"
)
GetMotifData(object = motif.obj)
GetMotifData(object = atac_small)
</code></pre>

<hr>
<h2 id='GetTSSPositions'>Find transcriptional start sites</h2><span id='topic+GetTSSPositions'></span>

<h3>Description</h3>

<p>Get the TSS positions from a set of genomic ranges containing gene positions.
Ranges can contain exons, introns, UTRs, etc, rather than the whole
transcript. Only protein coding gene biotypes are included in output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTSSPositions(ranges, biotypes = "protein_coding")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetTSSPositions_+3A_ranges">ranges</code></td>
<td>
<p>A GRanges object containing gene annotations.</p>
</td></tr>
<tr><td><code id="GetTSSPositions_+3A_biotypes">biotypes</code></td>
<td>
<p>Gene biotypes to include. If NULL, use all biotypes in the
supplied gene annotation.</p>
</td></tr>
</table>

<hr>
<h2 id='granges-methods'>Access genomic ranges for ChromatinAssay objects</h2><span id='topic+granges-methods'></span><span id='topic+granges'></span><span id='topic+granges+2CChromatinAssay-method'></span><span id='topic+granges+2CSeurat-method'></span>

<h3>Description</h3>

<p>Methods for accessing <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object
information stored in a <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ChromatinAssay'
granges(x, use.names = TRUE, use.mcols = FALSE, ...)

## S4 method for signature 'Seurat'
granges(x, use.names = TRUE, use.mcols = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="granges-methods_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object</p>
</td></tr>
<tr><td><code id="granges-methods_+3A_use.names">use.names</code></td>
<td>
<p>Whether the names on the genomic ranges should be
propagated to the returned object.</p>
</td></tr>
<tr><td><code id="granges-methods_+3A_use.mcols">use.mcols</code></td>
<td>
<p>Not supported for <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> objects</p>
</td></tr>
<tr><td><code id="granges-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>granges(Seurat)</code>: method for Seurat objects
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li><p><a href="GenomicRanges.html#topic+granges">granges</a> in the <span class="pkg">GenomicRanges</span> package.
</p>
</li>
<li><p><a href="#topic+ChromatinAssay-class">ChromatinAssay-class</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>granges(atac_small)
</code></pre>

<hr>
<h2 id='GRangesToString'>GRanges to String</h2><span id='topic+GRangesToString'></span>

<h3>Description</h3>

<p>Convert GRanges object to a vector of strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRangesToString(grange, sep = c("-", "-"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRangesToString_+3A_grange">grange</code></td>
<td>
<p>A GRanges object</p>
</td></tr>
<tr><td><code id="GRangesToString_+3A_sep">sep</code></td>
<td>
<p>Vector of separators to use for genomic string. First element is
used to separate chromosome and coordinates, second separator is used to
separate start and end coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GRangesToString(grange = blacklist_hg19)
</code></pre>

<hr>
<h2 id='head.Fragment'>Return the first rows of a fragment file</h2><span id='topic+head.Fragment'></span>

<h3>Description</h3>

<p>Returns the first <code>n</code> rows of a fragment file. This allows the content
of a fragment file to be inspected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Fragment'
head(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.Fragment_+3A_x">x</code></td>
<td>
<p>a <code>Fragment</code> object</p>
</td></tr>
<tr><td><code id="head.Fragment_+3A_n">n</code></td>
<td>
<p>an integer specifying the number of rows to return from the fragment
file</p>
</td></tr>
<tr><td><code id="head.Fragment_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="utils.html#topic+read.table">read.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first <code>n</code> rows of a fragment file as a <code>data.frame</code>
with the following columns: chrom, start, end, barcode, readCount.
</p>

<hr>
<h2 id='IdentifyVariants'>Identify mitochondrial variants</h2><span id='topic+IdentifyVariants'></span><span id='topic+IdentifyVariants.default'></span><span id='topic+IdentifyVariants.Assay'></span><span id='topic+IdentifyVariants.StdAssay'></span><span id='topic+IdentifyVariants.Seurat'></span>

<h3>Description</h3>

<p>Identify mitochondrial variants present in single cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdentifyVariants(object, ...)

## Default S3 method:
IdentifyVariants(
  object,
  refallele,
  stabilize_variance = TRUE,
  low_coverage_threshold = 10,
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
IdentifyVariants(object, refallele, ...)

## S3 method for class 'StdAssay'
IdentifyVariants(object, refallele, ...)

## S3 method for class 'Seurat'
IdentifyVariants(object, refallele, assay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IdentifyVariants_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="IdentifyVariants_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="IdentifyVariants_+3A_refallele">refallele</code></td>
<td>
<p>A dataframe containing reference alleles for the
mitochondrial genome.</p>
</td></tr>
<tr><td><code id="IdentifyVariants_+3A_stabilize_variance">stabilize_variance</code></td>
<td>
<p>Stabilize variance</p>
</td></tr>
<tr><td><code id="IdentifyVariants_+3A_low_coverage_threshold">low_coverage_threshold</code></td>
<td>
<p>Low coverage threshold</p>
</td></tr>
<tr><td><code id="IdentifyVariants_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="IdentifyVariants_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data.dir &lt;- "path/to/data/directory"
mgatk &lt;- ReadMGATK(dir = data.dir)
variant.df &lt;- IdentifyVariants(
  object = mgatk$counts,
  refallele = mgatk$refallele
)

## End(Not run)
</code></pre>

<hr>
<h2 id='InsertionBias'>Compute Tn5 insertion bias</h2><span id='topic+InsertionBias'></span><span id='topic+InsertionBias.ChromatinAssay'></span><span id='topic+InsertionBias.Seurat'></span>

<h3>Description</h3>

<p>Counts the Tn5 insertion frequency for each DNA hexamer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InsertionBias(object, ...)

## S3 method for class 'ChromatinAssay'
InsertionBias(object, genome, region = "chr1-1-249250621", verbose = TRUE, ...)

## S3 method for class 'Seurat'
InsertionBias(
  object,
  genome,
  assay = NULL,
  region = "chr1-1-249250621",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InsertionBias_+3A_object">object</code></td>
<td>
<p>A Seurat or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="InsertionBias_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+StringToGRanges">StringToGRanges</a></code></p>
</td></tr>
<tr><td><code id="InsertionBias_+3A_genome">genome</code></td>
<td>
<p>A <code>BSgenome</code> object or any other object supported by
<code>getSeq</code>. Do <code>showMethods("getSeq")</code> to get the list of all
supported object types.</p>
</td></tr>
<tr><td><code id="InsertionBias_+3A_region">region</code></td>
<td>
<p>Genomic region to use when assessing bias.</p>
</td></tr>
<tr><td><code id="InsertionBias_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="InsertionBias_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Seurat object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(BSgenome.Mmusculus.UCSC.mm10)

region.use &lt;- GRanges(
  seqnames = c('chr1', 'chr2'),
  IRanges(start = c(1,1), end = c(195471971, 182113224))
)

InsertionBias(
 object = atac_small,
 genome = BSgenome.Mmusculus.UCSC.mm10,
 region = region.use
)

## End(Not run)
</code></pre>

<hr>
<h2 id='inter-range-methods'>Inter-range transformations for ChromatinAssay objects</h2><span id='topic+inter-range-methods'></span><span id='topic+range'></span><span id='topic+range+2CChromatinAssay-method'></span><span id='topic+range+2CSeurat-method'></span><span id='topic+reduce+2CChromatinAssay-method'></span><span id='topic+reduce'></span><span id='topic+reduce+2CSeurat-method'></span><span id='topic+gaps+2CChromatinAssay-method'></span><span id='topic+gaps'></span><span id='topic+gaps+2CSeurat-method'></span><span id='topic+disjoin+2CChromatinAssay-method'></span><span id='topic+disjoin'></span><span id='topic+disjoin+2CSeurat-method'></span><span id='topic+isDisjoint+2CChromatinAssay-method'></span><span id='topic+isDisjoint'></span><span id='topic+isDisjoint+2CSeurat-method'></span><span id='topic+disjointBins+2CChromatinAssay-method'></span><span id='topic+disjointBins'></span><span id='topic+disjointBins+2CSeurat-method'></span>

<h3>Description</h3>

<p>The <code>range, reduce, gaps, disjoin, isDisjoint, disjointBins</code> methods
are available for <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ChromatinAssay'
range(x, ..., with.revmap = FALSE, na.rm = FALSE)

## S4 method for signature 'Seurat'
range(x, ..., with.revmap = FALSE, na.rm = FALSE)

## S4 method for signature 'ChromatinAssay'
reduce(x, drop.empty.ranges = FALSE, ...)

## S4 method for signature 'Seurat'
reduce(x, drop.empty.ranges = FALSE, ...)

## S4 method for signature 'ChromatinAssay'
gaps(x, start = NA, end = NA)

## S4 method for signature 'Seurat'
gaps(x, start = NA, end = NA)

## S4 method for signature 'ChromatinAssay'
disjoin(x, ...)

## S4 method for signature 'Seurat'
disjoin(x, ...)

## S4 method for signature 'ChromatinAssay'
isDisjoint(x, ...)

## S4 method for signature 'Seurat'
isDisjoint(x, ...)

## S4 method for signature 'ChromatinAssay'
disjointBins(x, ...)

## S4 method for signature 'Seurat'
disjointBins(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter-range-methods_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object</p>
</td></tr>
<tr><td><code id="inter-range-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="inter-range-methods_+3A_with.revmap">with.revmap</code></td>
<td>
<p>See <code><a href="IRanges.html#topic+inter-range-methods">inter-range-methods</a></code> in the
<span class="pkg">IRanges</span> packages</p>
</td></tr>
<tr><td><code id="inter-range-methods_+3A_na.rm">na.rm</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="inter-range-methods_+3A_drop.empty.ranges">drop.empty.ranges</code></td>
<td>
<p>See <code>?IRanges{inter-range-methods}</code></p>
</td></tr>
<tr><td><code id="inter-range-methods_+3A_start">start</code>, <code id="inter-range-methods_+3A_end">end</code></td>
<td>
<p>See <code>?IRanges{inter-range-methods}</code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>range(Seurat)</code>: method for Seurat objects
</p>
</li>
<li> <p><code>reduce(ChromatinAssay)</code>: method for ChromatinAssay objects
</p>
</li>
<li> <p><code>reduce(Seurat)</code>: method for Seurat objects
</p>
</li>
<li> <p><code>gaps(ChromatinAssay)</code>: method for ChromatinAssay objects
</p>
</li>
<li> <p><code>gaps(Seurat)</code>: method for Seurat objects
</p>
</li>
<li> <p><code>disjoin(ChromatinAssay)</code>: method for ChromatinAssay objects
</p>
</li>
<li> <p><code>disjoin(Seurat)</code>: method for Seurat objects
</p>
</li>
<li> <p><code>isDisjoint(ChromatinAssay)</code>: method for ChromatinAssay objects
</p>
</li>
<li> <p><code>isDisjoint(Seurat)</code>: method for Seurat objects
</p>
</li>
<li> <p><code>disjointBins(ChromatinAssay)</code>: method for ChromatinAssay objects
</p>
</li>
<li> <p><code>disjointBins(Seurat)</code>: method for Seurat objects
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li><p><a href="IRanges.html#topic+inter-range-methods">inter-range-methods</a> in the <span class="pkg">IRanges</span> package.
</p>
</li>
<li><p><a href="GenomicRanges.html#topic+inter-range-methods">inter-range-methods</a> in the <span class="pkg">GenomicRanges</span>
package
</p>
</li>
<li><p><a href="#topic+ChromatinAssay-class">ChromatinAssay-class</a>
</p>
</li></ul>


<hr>
<h2 id='IntersectMatrix'>Intersect genomic coordinates with matrix rows</h2><span id='topic+IntersectMatrix'></span>

<h3>Description</h3>

<p>Remove or retain matrix rows that intersect given genomic regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntersectMatrix(
  matrix,
  regions,
  invert = FALSE,
  sep = c("-", "-"),
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntersectMatrix_+3A_matrix">matrix</code></td>
<td>
<p>A matrix with genomic regions in the rows</p>
</td></tr>
<tr><td><code id="IntersectMatrix_+3A_regions">regions</code></td>
<td>
<p>A set of genomic regions to intersect with regions in the
matrix. Either a vector of strings encoding the genomic coordinates, or a
GRanges object.</p>
</td></tr>
<tr><td><code id="IntersectMatrix_+3A_invert">invert</code></td>
<td>
<p>Discard rows intersecting the genomic regions supplied, rather
than retain.</p>
</td></tr>
<tr><td><code id="IntersectMatrix_+3A_sep">sep</code></td>
<td>
<p>A length-2 character vector containing the separators to be used
for extracting genomic coordinates from a string. The first element will be
used to separate the chromosome name from coordinates, and the second element
used to separate start and end coordinates.</p>
</td></tr>
<tr><td><code id="IntersectMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="IntersectMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="IRanges.html#topic+findOverlaps">findOverlaps</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a sparse matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>counts &lt;- matrix(data = rep(0, 12), ncol = 2)
rownames(counts) &lt;- c("chr1-565107-565550","chr1-569174-569639",
"chr1-713460-714823","chr1-752422-753038",
"chr1-762106-763359","chr1-779589-780271")
IntersectMatrix(matrix = counts, regions = blacklist_hg19)
</code></pre>

<hr>
<h2 id='Jaccard'>Calculate the Jaccard index between two matrices</h2><span id='topic+Jaccard'></span>

<h3>Description</h3>

<p>Finds the Jaccard similarity between rows of the two matrices. Note that
the matrices must be binary, and any rows with zero total counts will result
in an NaN entry that could cause problems in downstream analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jaccard(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Jaccard_+3A_x">x</code></td>
<td>
<p>The first matrix</p>
</td></tr>
<tr><td><code id="Jaccard_+3A_y">y</code></td>
<td>
<p>The second matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will calculate the raw Jaccard index, without normalizing for the
expected similarity between cells due to differences in sequencing depth.
</p>


<h3>Value</h3>

<p>Returns a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(data = sample(c(0, 1), size = 25, replace = TRUE), ncol = 5)
Jaccard(x = x, y = x)
</code></pre>

<hr>
<h2 id='LinkPeaks'>Link peaks to genes</h2><span id='topic+LinkPeaks'></span>

<h3>Description</h3>

<p>Find peaks that are correlated with the expression of nearby genes.
For each gene, this function computes the correlation coefficient between
the gene expression and accessibility of each peak within a given distance
from the gene TSS, and computes an expected correlation coefficient for each
peak given the GC content, accessibility, and length of the peak. The expected
coefficient values for the peak are then used to compute a z-score and p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinkPeaks(
  object,
  peak.assay,
  expression.assay,
  peak.slot = "counts",
  expression.slot = "data",
  method = "pearson",
  gene.coords = NULL,
  distance = 5e+05,
  min.distance = NULL,
  min.cells = 10,
  genes.use = NULL,
  n_sample = 200,
  pvalue_cutoff = 0.05,
  score_cutoff = 0.05,
  gene.id = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinkPeaks_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_peak.assay">peak.assay</code></td>
<td>
<p>Name of assay containing peak information</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_expression.assay">expression.assay</code></td>
<td>
<p>Name of assay containing gene expression information</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_peak.slot">peak.slot</code></td>
<td>
<p>Name of slot to pull chromatin data from</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_expression.slot">expression.slot</code></td>
<td>
<p>Name of slot to pull expression data from</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_method">method</code></td>
<td>
<p>Correlation method to use. One of &quot;pearson&quot; or &quot;spearman&quot;</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_gene.coords">gene.coords</code></td>
<td>
<p>GRanges object containing coordinates of genes in the
expression assay. If NULL, extract from gene annotations stored in the assay.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_distance">distance</code></td>
<td>
<p>Distance threshold for peaks to include in regression model</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_min.distance">min.distance</code></td>
<td>
<p>Minimum distance between peak and TSS to include in
regression model. If NULL (default), no minimum distance is used.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_min.cells">min.cells</code></td>
<td>
<p>Minimum number of cells positive for the peak and gene
needed to include in the results.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_genes.use">genes.use</code></td>
<td>
<p>Genes to test. If NULL, determine from expression assay.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_n_sample">n_sample</code></td>
<td>
<p>Number of peaks to sample at random when computing the null
distribution.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_pvalue_cutoff">pvalue_cutoff</code></td>
<td>
<p>Minimum p-value required to retain a link. Links with a
p-value equal or greater than this value will be removed from the output.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_score_cutoff">score_cutoff</code></td>
<td>
<p>Minimum absolute value correlation coefficient for a link
to be retained</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_gene.id">gene.id</code></td>
<td>
<p>Set to TRUE if genes in the expression assay are named
using gene IDs rather than gene names.</p>
</td></tr>
<tr><td><code id="LinkPeaks_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was inspired by the method originally described by SHARE-seq
(Sai Ma et al. 2020, Cell). Please consider citing the original SHARE-seq
work if using this function: <a href="https://doi.org/10.1016/j.cell.2020.09.056">doi:10.1016/j.cell.2020.09.056</a>
</p>


<h3>Value</h3>

<p>Returns a Seurat object with the <code>Links</code> information set. This is
a <code><a href="GenomicRanges.html#topic+granges">granges</a></code> object accessible via the <code><a href="#topic+Links">Links</a></code>
function, with the following information:
</p>

<ul>
<li><p>score: the correlation coefficient between the accessibility of the
peak and expression of the gene
</p>
</li>
<li><p>zscore: the z-score of the correlation coefficient, computed based on
the distribution of correlation coefficients from a set of background peaks
</p>
</li>
<li><p>pvalue: the p-value associated with the z-score for the link
</p>
</li>
<li><p>gene: name of the linked gene
</p>
</li>
<li><p>peak: name of the linked peak
</p>
</li></ul>


<hr>
<h2 id='LinkPlot'>Plot linked genomic elements</h2><span id='topic+LinkPlot'></span>

<h3>Description</h3>

<p>Display links between pairs of genomic elements within a given region of the
genome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinkPlot(
  object,
  region,
  assay = NULL,
  min.cutoff = 0,
  sep = c("-", "-"),
  extend.upstream = 0,
  extend.downstream = 0,
  scale.linewidth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LinkPlot_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_region">region</code></td>
<td>
<p>A genomic region to plot</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay.</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_min.cutoff">min.cutoff</code></td>
<td>
<p>Minimum absolute score for link to be plotted.</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates. First
element is used to separate the chromosome from the coordinates, second
element is used to separate the start from end coordinate.</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend the region upstream.</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend the region downstream.</p>
</td></tr>
<tr><td><code id="LinkPlot_+3A_scale.linewidth">scale.linewidth</code></td>
<td>
<p>Scale thickness of the line according to link score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>

<hr>
<h2 id='Links'>Get or set links information</h2><span id='topic+Links'></span><span id='topic+Links+3C-'></span><span id='topic+Links.ChromatinAssay'></span><span id='topic+Links.Seurat'></span><span id='topic+Links+3C-.ChromatinAssay'></span><span id='topic+Links+3C-.Seurat'></span>

<h3>Description</h3>

<p>Get or set the genomic link information for a Seurat object or ChromatinAssay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Links(object, ...)

Links(object, ...) &lt;- value

## S3 method for class 'ChromatinAssay'
Links(object, ...)

## S3 method for class 'Seurat'
Links(object, ...)

## S3 replacement method for class 'ChromatinAssay'
Links(object, ...) &lt;- value

## S3 replacement method for class 'Seurat'
Links(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Links_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="Links_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Links_+3A_value">value</code></td>
<td>
<p>A <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Links(atac_small[["peaks"]])
Links(atac_small)
links &lt;- Links(atac_small)
Links(atac_small[["peaks"]]) &lt;- links
links &lt;- Links(atac_small)
Links(atac_small) &lt;- links
</code></pre>

<hr>
<h2 id='LookupGeneCoords'>Get gene coordinates</h2><span id='topic+LookupGeneCoords'></span>

<h3>Description</h3>

<p>Extract the coordinates of the longest transcript for a gene stored in the
annotations within an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LookupGeneCoords(object, gene, assay = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LookupGeneCoords_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="LookupGeneCoords_+3A_gene">gene</code></td>
<td>
<p>Name of a gene to extract</p>
</td></tr>
<tr><td><code id="LookupGeneCoords_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>LookupGeneCoords(atac_small, gene = "MIR1302-10")
</code></pre>

<hr>
<h2 id='MatchRegionStats'>Match DNA sequence characteristics</h2><span id='topic+MatchRegionStats'></span>

<h3>Description</h3>

<p>Return a vector if genomic regions that match the distribution of a set of
query regions for any given set of characteristics, specified in the input
<code>meta.feature</code> dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchRegionStats(
  meta.feature,
  query.feature,
  features.match = c("GC.percent"),
  n = 10000,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatchRegionStats_+3A_meta.feature">meta.feature</code></td>
<td>
<p>A dataframe containing DNA sequence information for
features to choose from</p>
</td></tr>
<tr><td><code id="MatchRegionStats_+3A_query.feature">query.feature</code></td>
<td>
<p>A dataframe containing DNA sequence information for
features to match.</p>
</td></tr>
<tr><td><code id="MatchRegionStats_+3A_features.match">features.match</code></td>
<td>
<p>Which features of the query to match when selecting a
set of regions. A vector of column names present in the feature metadata can
be supplied to match multiple characteristics at once. Default is GC content.</p>
</td></tr>
<tr><td><code id="MatchRegionStats_+3A_n">n</code></td>
<td>
<p>Number of regions to select, with characteristics matching the query</p>
</td></tr>
<tr><td><code id="MatchRegionStats_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="MatchRegionStats_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each requested feature to match, a density
distribution is estimated using the <code><a href="stats.html#topic+density">density</a></code> function,
and a set of weights for each feature in the dataset estimated based on the
density distribution. If multiple features are to be matched (for example,
GC content and overall accessibility), a joint density distribution is then
computed by multiplying the individual feature weights. A set of features
with characteristics matching the query regions is then selected using the
<code><a href="base.html#topic+sample">sample</a></code> function, with the probability of randomly
selecting each feature equal to the joint density distribution weight.
</p>


<h3>Value</h3>

<p>Returns a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metafeatures &lt;- SeuratObject::GetAssayData(
  object = atac_small[['peaks']], slot = 'meta.features'
)
query.feature &lt;- metafeatures[1:10, ]
features.choose &lt;- metafeatures[11:nrow(metafeatures), ]
MatchRegionStats(
  meta.feature = features.choose,
  query.feature = query.feature,
  features.match = "percentile",
  n = 10
)
</code></pre>

<hr>
<h2 id='Motif-class'>The Motif class</h2><span id='topic+Motif-class'></span><span id='topic+Motif'></span>

<h3>Description</h3>

<p>The Motif class is designed to store DNA sequence motif information,
including motif PWMs or PFMs, motif positions, and metadata.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>A sparse, binary, feature x motif matrix. Columns
correspond to motif IDs, rows correspond to genomic features
(peaks or bins). Entries in the matrix should be 1 if the
genomic feature contains the motif, and 0 otherwise.</p>
</dd>
<dt><code>pwm</code></dt><dd><p>A named list of position weight matrices</p>
</dd>
<dt><code>motif.names</code></dt><dd><p>A list containing the name of each motif</p>
</dd>
<dt><code>positions</code></dt><dd><p>A <code><a href="GenomicRanges.html#topic+GRangesList">GRangesList</a></code> object containing
exact positions of each motif.</p>
</dd>
<dt><code>meta.data</code></dt><dd><p>A dataframe for storage of additional
information related to each motif. This could include the
names of proteins that bind the motif.</p>
</dd>
</dl>

<hr>
<h2 id='MotifCounts'>Count fragments surrounding motif sites</h2><span id='topic+MotifCounts'></span>

<h3>Description</h3>

<p>Count the number of sequenced DNA fragments in a region surrounding each 
instance of a given DNA sequence motif.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MotifCounts(
  object,
  motifs,
  flanking.region = 1000,
  assay = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MotifCounts_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="MotifCounts_+3A_motifs">motifs</code></td>
<td>
<p>A list of DNA sequence motif names. One matrix will be generated
for each motif</p>
</td></tr>
<tr><td><code id="MotifCounts_+3A_flanking.region">flanking.region</code></td>
<td>
<p>Amount of sequence to include surrounding the motif
itself</p>
</td></tr>
<tr><td><code id="MotifCounts_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Must be a ChromatinAssay</p>
</td></tr>
<tr><td><code id="MotifCounts_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="MotifCounts_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+FeatureMatrix">FeatureMatrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of sparse matrices
</p>

<hr>
<h2 id='MotifPlot'>Plot DNA sequence motif</h2><span id='topic+MotifPlot'></span>

<h3>Description</h3>

<p>Plot position weight matrix or position frequency matrix for different DNA
sequence motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MotifPlot(object, motifs, assay = NULL, use.names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MotifPlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="MotifPlot_+3A_motifs">motifs</code></td>
<td>
<p>A list of motif IDs or motif names to plot</p>
</td></tr>
<tr><td><code id="MotifPlot_+3A_assay">assay</code></td>
<td>
<p>Name of the assay to use</p>
</td></tr>
<tr><td><code id="MotifPlot_+3A_use.names">use.names</code></td>
<td>
<p>Use motif names stored in the motif object</p>
</td></tr>
<tr><td><code id="MotifPlot_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="ggseqlogo.html#topic+ggseqlogo">ggseqlogo</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
motif.obj &lt;- Motifs(atac_small)
MotifPlot(atac_small, motifs = head(colnames(motif.obj)))

</code></pre>

<hr>
<h2 id='Motifs'>Get or set a motif information</h2><span id='topic+Motifs'></span><span id='topic+Motifs+3C-'></span><span id='topic+Motifs.ChromatinAssay'></span><span id='topic+Motifs.Seurat'></span><span id='topic+Motifs+3C-.ChromatinAssay'></span><span id='topic+Motifs+3C-.Seurat'></span>

<h3>Description</h3>

<p>Get or set the Motif object for a Seurat object or ChromatinAssay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Motifs(object, ...)

Motifs(object, ...) &lt;- value

## S3 method for class 'ChromatinAssay'
Motifs(object, ...)

## S3 method for class 'Seurat'
Motifs(object, ...)

## S3 replacement method for class 'ChromatinAssay'
Motifs(object, ...) &lt;- value

## S3 replacement method for class 'Seurat'
Motifs(object, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Motifs_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="Motifs_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="Motifs_+3A_value">value</code></td>
<td>
<p>A <code><a href="#topic+Motif">Motif</a></code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Motifs(atac_small[["peaks"]])
Motifs(atac_small)
motifs &lt;- Motifs(atac_small)
Motifs(atac_small[["peaks"]]) &lt;- motifs
motifs &lt;- Motifs(atac_small)
Motifs(atac_small) &lt;- motifs
</code></pre>

<hr>
<h2 id='nearest-methods'>Find the nearest range neighbors for ChromatinAssay objects</h2><span id='topic+nearest-methods'></span><span id='topic+precede'></span><span id='topic+precede+2CANY+2CChromatinAssay-method'></span><span id='topic+precede+2CChromatinAssay+2CANY-method'></span><span id='topic+precede+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+precede+2CANY+2CSeurat-method'></span><span id='topic+precede+2CSeurat+2CANY-method'></span><span id='topic+precede+2CSeurat+2CSeurat-method'></span><span id='topic+follow+2CANY+2CChromatinAssay-method'></span><span id='topic+follow'></span><span id='topic+follow+2CChromatinAssay+2CANY-method'></span><span id='topic+follow+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+follow+2CANY+2CSeurat-method'></span><span id='topic+follow+2CSeurat+2CANY-method'></span><span id='topic+follow+2CSeurat+2CSeurat-method'></span><span id='topic+nearest+2CANY+2CChromatinAssay-method'></span><span id='topic+nearest'></span><span id='topic+nearest+2CChromatinAssay+2CANY-method'></span><span id='topic+nearest+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+nearest+2CANY+2CSeurat-method'></span><span id='topic+nearest+2CSeurat+2CANY-method'></span><span id='topic+nearest+2CSeurat+2CSeurat-method'></span><span id='topic+distance+2CANY+2CChromatinAssay-method'></span><span id='topic+distance'></span><span id='topic+distance+2CChromatinAssay+2CANY-method'></span><span id='topic+distance+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+distance+2CANY+2CSeurat-method'></span><span id='topic+distance+2CSeurat+2CANY-method'></span><span id='topic+distance+2CSeurat+2CSeurat-method'></span><span id='topic+distanceToNearest+2CANY+2CChromatinAssay-method'></span><span id='topic+distanceToNearest'></span><span id='topic+distanceToNearest+2CChromatinAssay+2CANY-method'></span><span id='topic+distanceToNearest+2CChromatinAssay+2CChromatinAssay-method'></span><span id='topic+distanceToNearest+2CANY+2CSeurat-method'></span><span id='topic+distanceToNearest+2CSeurat+2CANY-method'></span><span id='topic+distanceToNearest+2CSeurat+2CSeurat-method'></span>

<h3>Description</h3>

<p>The <code>precede, follow, nearest, distance, distanceToNearest</code> methods
are available for <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,ChromatinAssay'
precede(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ChromatinAssay,ANY'
precede(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
precede(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ANY,Seurat'
precede(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'Seurat,ANY'
precede(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'Seurat,Seurat'
precede(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ANY,ChromatinAssay'
follow(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ChromatinAssay,ANY'
follow(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
follow(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ANY,Seurat'
follow(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'Seurat,ANY'
follow(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'Seurat,Seurat'
follow(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ANY,ChromatinAssay'
nearest(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ChromatinAssay,ANY'
nearest(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
nearest(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ANY,Seurat'
nearest(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'Seurat,ANY'
nearest(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'Seurat,Seurat'
nearest(x, subject, select = c("arbitrary", "all"), ignore.strand = FALSE)

## S4 method for signature 'ANY,ChromatinAssay'
distance(x, y, ignore.strand = FALSE, ...)

## S4 method for signature 'ChromatinAssay,ANY'
distance(x, y, ignore.strand = FALSE, ...)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
distance(x, y, ignore.strand = FALSE, ...)

## S4 method for signature 'ANY,Seurat'
distance(x, y, ignore.strand = FALSE, ...)

## S4 method for signature 'Seurat,ANY'
distance(x, y, ignore.strand = FALSE, ...)

## S4 method for signature 'Seurat,Seurat'
distance(x, y, ignore.strand = FALSE, ...)

## S4 method for signature 'ANY,ChromatinAssay'
distanceToNearest(x, subject, ignore.strand = FALSE, ...)

## S4 method for signature 'ChromatinAssay,ANY'
distanceToNearest(x, subject, ignore.strand = FALSE, ...)

## S4 method for signature 'ChromatinAssay,ChromatinAssay'
distanceToNearest(x, subject, ignore.strand = FALSE, ...)

## S4 method for signature 'ANY,Seurat'
distanceToNearest(x, subject, ignore.strand = FALSE, ...)

## S4 method for signature 'Seurat,ANY'
distanceToNearest(x, subject, ignore.strand = FALSE, ...)

## S4 method for signature 'Seurat,Seurat'
distanceToNearest(x, subject, ignore.strand = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest-methods_+3A_x">x</code></td>
<td>
<p>A query <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object</p>
</td></tr>
<tr><td><code id="nearest-methods_+3A_subject">subject</code></td>
<td>
<p>The subject <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> or
<code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object. If missing, <code>x</code> is used as the
subject.</p>
</td></tr>
<tr><td><code id="nearest-methods_+3A_select">select</code></td>
<td>
<p>Logic for handling ties.
See <code><a href="GenomicRanges.html#topic+nearest-methods">nearest-methods</a></code> in the <span class="pkg">GenomicRanges</span>
package.</p>
</td></tr>
<tr><td><code id="nearest-methods_+3A_ignore.strand">ignore.strand</code></td>
<td>
<p>Logical argument controlling whether strand information
should be ignored.</p>
</td></tr>
<tr><td><code id="nearest-methods_+3A_y">y</code></td>
<td>
<p>For the <code>distance</code> method, a
<code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object or a <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code>
object</p>
</td></tr>
<tr><td><code id="nearest-methods_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>precede(x = ChromatinAssay, subject = ANY)</code>: method for ChromatinAssay, ANY
</p>
</li>
<li> <p><code>precede(x = ChromatinAssay, subject = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>precede(x = ANY, subject = Seurat)</code>: method for ANY, Seurat
</p>
</li>
<li> <p><code>precede(x = Seurat, subject = ANY)</code>: method for Seurat, ANY
</p>
</li>
<li> <p><code>precede(x = Seurat, subject = Seurat)</code>: method for Seurat, Seurat
</p>
</li>
<li> <p><code>follow(x = ANY, subject = ChromatinAssay)</code>: method for ANY, ChromatinAssay
</p>
</li>
<li> <p><code>follow(x = ChromatinAssay, subject = ANY)</code>: method for ChromatinAssay, ANY
</p>
</li>
<li> <p><code>follow(x = ChromatinAssay, subject = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>follow(x = ANY, subject = Seurat)</code>: method for ANY, Seurat
</p>
</li>
<li> <p><code>follow(x = Seurat, subject = ANY)</code>: method for Seurat, ANY
</p>
</li>
<li> <p><code>follow(x = Seurat, subject = Seurat)</code>: method for Seurat, Seurat
</p>
</li>
<li> <p><code>nearest(x = ANY, subject = ChromatinAssay)</code>: method for ANY, ChromatinAssay
</p>
</li>
<li> <p><code>nearest(x = ChromatinAssay, subject = ANY)</code>: method for ChromatinAssay, ANY
</p>
</li>
<li> <p><code>nearest(x = ChromatinAssay, subject = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>nearest(x = ANY, subject = Seurat)</code>: method for ANY, Seurat
</p>
</li>
<li> <p><code>nearest(x = Seurat, subject = ANY)</code>: method for Seurat, ANY
</p>
</li>
<li> <p><code>nearest(x = Seurat, subject = Seurat)</code>: method for Seurat, Seurat
</p>
</li>
<li> <p><code>distance(x = ANY, y = ChromatinAssay)</code>: method for ANY, ChromatinAssay
</p>
</li>
<li> <p><code>distance(x = ChromatinAssay, y = ANY)</code>: method for ChromatinAssay, ANY
</p>
</li>
<li> <p><code>distance(x = ChromatinAssay, y = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>distance(x = ANY, y = Seurat)</code>: method for ANY, Seurat
</p>
</li>
<li> <p><code>distance(x = Seurat, y = ANY)</code>: method for Seurat, ANY
</p>
</li>
<li> <p><code>distance(x = Seurat, y = Seurat)</code>: method for Seurat, Seurat
</p>
</li>
<li> <p><code>distanceToNearest(x = ANY, subject = ChromatinAssay)</code>: method for ANY, ChromatinAssay
</p>
</li>
<li> <p><code>distanceToNearest(x = ChromatinAssay, subject = ANY)</code>: method for ChromatinAssay, ANY
</p>
</li>
<li> <p><code>distanceToNearest(x = ChromatinAssay, subject = ChromatinAssay)</code>: method for ChromatinAssay, ChromatinAssay
</p>
</li>
<li> <p><code>distanceToNearest(x = ANY, subject = Seurat)</code>: method for ANY, Seurat
</p>
</li>
<li> <p><code>distanceToNearest(x = Seurat, subject = ANY)</code>: method for Seurat, ANY
</p>
</li>
<li> <p><code>distanceToNearest(x = Seurat, subject = Seurat)</code>: method for Seurat, Seurat
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li><p><a href="IRanges.html#topic+nearest-methods">nearest-methods</a> in the <span class="pkg">IRanges</span> package.
</p>
</li>
<li><p><a href="GenomicRanges.html#topic+nearest-methods">nearest-methods</a> in the <span class="pkg">GenomicRanges</span>
package
</p>
</li>
<li><p><a href="#topic+ChromatinAssay-class">ChromatinAssay-class</a>
</p>
</li></ul>


<hr>
<h2 id='NucleosomeSignal'>NucleosomeSignal</h2><span id='topic+NucleosomeSignal'></span>

<h3>Description</h3>

<p>Calculate the strength of the nucleosome signal per cell.
Computes the ratio of fragments between 147 bp and 294 bp (mononucleosome) to
fragments &lt; 147 bp (nucleosome-free)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NucleosomeSignal(
  object,
  assay = NULL,
  n = ncol(object) * 5000,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NucleosomeSignal_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="NucleosomeSignal_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Only required if a fragment path is not
provided. If NULL, use the active assay.</p>
</td></tr>
<tr><td><code id="NucleosomeSignal_+3A_n">n</code></td>
<td>
<p>Number of lines to read from the fragment file. If NULL, read all
lines. Default scales with the number of cells in the object.</p>
</td></tr>
<tr><td><code id="NucleosomeSignal_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="NucleosomeSignal_+3A_...">...</code></td>
<td>
<p>Arguments passed to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object with
added metadata for the ratio of mononucleosomal to nucleosome-free fragments
per cell, and the percentile rank of each ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
Fragments(atac_small) &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  tolerance = 0.5
)
NucleosomeSignal(object = atac_small)
</code></pre>

<hr>
<h2 id='PeakPlot'>Plot peaks in a genomic region</h2><span id='topic+PeakPlot'></span>

<h3>Description</h3>

<p>Display the genomic ranges in a <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object that fall
in a given genomic region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakPlot(
  object,
  region,
  assay = NULL,
  peaks = NULL,
  group.by = NULL,
  color = "dimgrey",
  sep = c("-", "-"),
  extend.upstream = 0,
  extend.downstream = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakPlot_+3A_object">object</code></td>
<td>
<p>A <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_region">region</code></td>
<td>
<p>A genomic region to plot</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay.</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_peaks">peaks</code></td>
<td>
<p>A GRanges object containing peak coordinates. If NULL, use
coordinates stored in the Seurat object.</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of variable in feature metadata (if using ranges in the
Seurat object) or genomic ranges metadata (if using supplied ranges) to color
ranges by. If NULL, do not color by any metadata variable.</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_color">color</code></td>
<td>
<p>Color to use. If <code>group.by</code> is not NULL, this can be a
custom color scale (see examples).</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates. First
element is used to separate the chromosome from the coordinates, second
element is used to separate the start from end coordinate.</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend the region upstream.</p>
</td></tr>
<tr><td><code id="PeakPlot_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend the region downstream.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# plot peaks in assay
PeakPlot(atac_small, region = "chr1-710000-715000")

# manually set color
PeakPlot(atac_small, region = "chr1-710000-715000", color = "red")

# color by a variable in the feature metadata
PeakPlot(atac_small, region = "chr1-710000-715000", group.by = "count")

</code></pre>

<hr>
<h2 id='PlotFootprint'>Plot motif footprinting results</h2><span id='topic+PlotFootprint'></span>

<h3>Description</h3>

<p>Plot motif footprinting results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotFootprint(
  object,
  features,
  assay = NULL,
  group.by = NULL,
  split.by = NULL,
  idents = NULL,
  label = TRUE,
  repel = TRUE,
  show.expected = TRUE,
  normalization = "subtract",
  label.top = 3,
  label.idents = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotFootprint_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_features">features</code></td>
<td>
<p>A vector of features to plot</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_group.by">group.by</code></td>
<td>
<p>A grouping variable</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_split.by">split.by</code></td>
<td>
<p>A metadata variable to split the plot by. For example,
grouping by &quot;celltype&quot; and splitting by &quot;batch&quot; will create separate plots
for each celltype and batch.</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_idents">idents</code></td>
<td>
<p>Set of identities to include in the plot</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_label">label</code></td>
<td>
<p>TRUE/FALSE value to control whether groups are labeled.</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_repel">repel</code></td>
<td>
<p>Repel labels from each other</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_show.expected">show.expected</code></td>
<td>
<p>Plot the expected Tn5 integration frequency below the
main footprint plot</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_normalization">normalization</code></td>
<td>
<p>Method to normalize for Tn5 DNA sequence bias. Options
are &quot;subtract&quot;, &quot;divide&quot;, or NULL to perform no bias correction.</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_label.top">label.top</code></td>
<td>
<p>Number of groups to label based on highest accessibility
in motif flanking region.</p>
</td></tr>
<tr><td><code id="PlotFootprint_+3A_label.idents">label.idents</code></td>
<td>
<p>Vector of identities to label. If supplied,
<code>label.top</code> will be ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='ReadMGATK'>Read MGATK output</h2><span id='topic+ReadMGATK'></span>

<h3>Description</h3>

<p>Read output files from MGATK (<a href="https://github.com/caleblareau/mgatk">https://github.com/caleblareau/mgatk</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadMGATK(dir, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadMGATK_+3A_dir">dir</code></td>
<td>
<p>Path to directory containing MGATK output files</p>
</td></tr>
<tr><td><code id="ReadMGATK_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing a sparse matrix (counts) and two dataframes
(depth and refallele).
</p>
<p>The sparse matrix contains read counts for each base at each position
and strand.
</p>
<p>The depth dataframe contains the total depth for each cell.
The refallele dataframe contains the reference genome allele at each
position.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data.dir &lt;- system.file("extdata", "test_mgatk", package="Signac")
mgatk &lt;- ReadMGATK(dir = data.dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+Cells'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>SeuratObject</dt><dd><p><code><a href="SeuratObject.html#topic+Cells">Cells</a></code></p>
</dd>
</dl>

<hr>
<h2 id='RegionHeatmap'>Region heatmap</h2><span id='topic+RegionHeatmap'></span>

<h3>Description</h3>

<p>Plot fragment counts within a set of regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionHeatmap(
  object,
  key,
  assay = NULL,
  idents = NULL,
  normalize = TRUE,
  upstream = 3000,
  downstream = 3000,
  max.cutoff = "q95",
  cols = NULL,
  min.counts = 1,
  window = (upstream + downstream)/30,
  order = TRUE,
  nrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionHeatmap_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_key">key</code></td>
<td>
<p>Name of key to pull data from. Stores the results from
<code><a href="#topic+RegionMatrix">RegionMatrix</a></code></p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If a list or vector of assay names is
given, data will be plotted from each assay. Note that all assays must
contain <code>RegionMatrix</code> results with the same key. Sorting will be 
defined by the first assay in the list</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_idents">idents</code></td>
<td>
<p>Cell identities to include. Note that cells cannot be
regrouped, this will require re-running <code>RegionMatrix</code> to generate a 
new set of matrices</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_normalize">normalize</code></td>
<td>
<p>Normalize by number of cells in each group</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_upstream">upstream</code></td>
<td>
<p>Number of bases to include upstream of region. If NULL, use
all bases that were included in the <code>RegionMatrix</code> function call. Note
that this value cannot be larger than the value for <code>upstream</code> given in
the original <code>RegionMatrix</code> function call. If NULL, use parameters that
were given in the <code>RegionMatrix</code> function call</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_downstream">downstream</code></td>
<td>
<p>Number of bases to include downstream of region. See
documentation for <code>upstream</code></p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_max.cutoff">max.cutoff</code></td>
<td>
<p>Maximum cutoff value. Data above this value will be clipped
to the maximum value. A quantile maximum can be specified in the form of 
&quot;q##&quot; where &quot;##&quot; is the quantile (eg, &quot;q90&quot; for 90th quantile). If NULL, no
cutoff will be set</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_cols">cols</code></td>
<td>
<p>Vector of colors to use as the maximum value of the color scale.
One color must be supplied for each assay. If NULL, the default ggplot2
colors are used.</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_min.counts">min.counts</code></td>
<td>
<p>Minimum total counts to display region in plot</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_window">window</code></td>
<td>
<p>Smoothing window to apply</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_order">order</code></td>
<td>
<p>Order regions by the total number of fragments in the region
across all included identities</p>
</td></tr>
<tr><td><code id="RegionHeatmap_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows to use when creating plot. If NULL, chosen
automatically by ggplot2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object
</p>


<h3>See Also</h3>

<p>RegionMatrix
</p>

<hr>
<h2 id='RegionMatrix'>Region enrichment analysis</h2><span id='topic+RegionMatrix'></span><span id='topic+RegionMatrix.Seurat'></span><span id='topic+RegionMatrix.ChromatinAssay'></span><span id='topic+RegionMatrix.default'></span>

<h3>Description</h3>

<p>Count fragments within a set of regions for different groups of
cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionMatrix(object, ...)

## S3 method for class 'Seurat'
RegionMatrix(
  object,
  regions,
  key,
  assay = NULL,
  group.by = NULL,
  idents = NULL,
  upstream = 3000,
  downstream = 3000,
  verbose = TRUE,
  ...
)

## S3 method for class 'ChromatinAssay'
RegionMatrix(
  object,
  regions,
  key,
  assay = NULL,
  group.by = NULL,
  idents = NULL,
  upstream = 3000,
  downstream = 3000,
  verbose = TRUE,
  ...
)

## Default S3 method:
RegionMatrix(
  object,
  regions,
  key,
  assay = NULL,
  group.by = NULL,
  idents = NULL,
  upstream = 3000,
  downstream = 3000,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionMatrix_+3A_object">object</code></td>
<td>
<p>A Seurat or ChromatinAssay object</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_regions">regions</code></td>
<td>
<p>A <code><a href="GenomicRanges.html#topic+GRanges">GRanges</a></code> object containing the
set of genomic ranges to quantify</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_key">key</code></td>
<td>
<p>Name to store resulting matrices under</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If NULL, use the default assay</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_group.by">group.by</code></td>
<td>
<p>Grouping variable to use when aggregating data across cells.
If NULL, use the active cell identities</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_idents">idents</code></td>
<td>
<p>Cell identities to include. If NULL, include all identities</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_upstream">upstream</code></td>
<td>
<p>Number of bases to extend regions upstream</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_downstream">downstream</code></td>
<td>
<p>Number of bases to extend regions downstream</p>
</td></tr>
<tr><td><code id="RegionMatrix_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>

<hr>
<h2 id='RegionPlot'>Region plot</h2><span id='topic+RegionPlot'></span>

<h3>Description</h3>

<p>Plot fragment counts within a set of regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionPlot(
  object,
  key,
  assay = NULL,
  idents = NULL,
  normalize = TRUE,
  upstream = NULL,
  downstream = NULL,
  window = (upstream + downstream)/500,
  nrow = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionPlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_key">key</code></td>
<td>
<p>Name of key to pull data from. Stores the results from
<code><a href="#topic+RegionMatrix">RegionMatrix</a></code></p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. If a list or vector of assay names is
given, data will be plotted from each assay. Note that all assays must
contain <code>RegionMatrix</code> results with the same key. Sorting will be 
defined by the first assay in the list</p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_idents">idents</code></td>
<td>
<p>Cell identities to include. Note that cells cannot be
regrouped, this will require re-running <code>RegionMatrix</code> to generate a 
new set of matrices</p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_normalize">normalize</code></td>
<td>
<p>Normalize by number of cells in each group</p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_upstream">upstream</code></td>
<td>
<p>Number of bases to include upstream of region. If NULL, use
all bases that were included in the <code>RegionMatrix</code> function call. Note
that this value cannot be larger than the value for <code>upstream</code> given in
the original <code>RegionMatrix</code> function call. If NULL, use parameters that
were given in the <code>RegionMatrix</code> function call</p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_downstream">downstream</code></td>
<td>
<p>Number of bases to include downstream of region. See
documentation for <code>upstream</code></p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_window">window</code></td>
<td>
<p>Smoothing window to apply</p>
</td></tr>
<tr><td><code id="RegionPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows to use when creating plot. If NULL, chosen
automatically by ggplot2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 object
</p>


<h3>See Also</h3>

<p>RegionMatrix
</p>

<hr>
<h2 id='RegionStats'>Compute base composition information for genomic ranges</h2><span id='topic+RegionStats'></span><span id='topic+RegionStats.default'></span><span id='topic+RegionStats.ChromatinAssay'></span><span id='topic+RegionStats.Seurat'></span>

<h3>Description</h3>

<p>Compute the GC content, region lengths, and dinucleotide base frequencies
for regions in the assay and add to the feature metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegionStats(object, ...)

## Default S3 method:
RegionStats(object, genome, verbose = TRUE, ...)

## S3 method for class 'ChromatinAssay'
RegionStats(object, genome, verbose = TRUE, ...)

## S3 method for class 'Seurat'
RegionStats(object, genome, assay = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegionStats_+3A_object">object</code></td>
<td>
<p>A Seurat object, Assay object, or set of genomic ranges</p>
</td></tr>
<tr><td><code id="RegionStats_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="RegionStats_+3A_genome">genome</code></td>
<td>
<p>A <code>BSgenome</code> object or any other object supported by
<code>getSeq</code>. Do <code>showMethods("getSeq")</code> to get the list of all
supported object types.</p>
</td></tr>
<tr><td><code id="RegionStats_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="RegionStats_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(BSgenome.Hsapiens.UCSC.hg19)
RegionStats(
  object = rownames(atac_small),
  genome = BSgenome.Hsapiens.UCSC.hg19
)

## End(Not run)
## Not run: 
library(BSgenome.Hsapiens.UCSC.hg19)
RegionStats(
  object = atac_small[['peaks']],
  genome = BSgenome.Hsapiens.UCSC.hg19
)

## End(Not run)
## Not run: 
library(BSgenome.Hsapiens.UCSC.hg19)
RegionStats(
  object = atac_small,
  assay = 'bins',
  genome = BSgenome.Hsapiens.UCSC.hg19
)

## End(Not run)
</code></pre>

<hr>
<h2 id='RunChromVAR'>Run chromVAR</h2><span id='topic+RunChromVAR'></span><span id='topic+RunChromVAR.ChromatinAssay'></span><span id='topic+RunChromVAR.Seurat'></span>

<h3>Description</h3>

<p>Wrapper to run <code><a href="chromVAR.html#topic+chromVAR">chromVAR</a></code> on an assay with a motif
object present. Will return a new Seurat assay with the motif activities
(the deviations in chromatin accessibility across the set of regions) as
a new assay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunChromVAR(object, ...)

## S3 method for class 'ChromatinAssay'
RunChromVAR(object, genome, motif.matrix = NULL, verbose = TRUE, ...)

## S3 method for class 'Seurat'
RunChromVAR(
  object,
  genome,
  motif.matrix = NULL,
  assay = NULL,
  new.assay.name = "chromvar",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunChromVAR_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="RunChromVAR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="chromVAR.html#topic+getBackgroundPeaks">getBackgroundPeaks</a></code></p>
</td></tr>
<tr><td><code id="RunChromVAR_+3A_genome">genome</code></td>
<td>
<p>A <code>BSgenome</code> object or string stating the genome build
recognized by <code>getBSgenome</code>.</p>
</td></tr>
<tr><td><code id="RunChromVAR_+3A_motif.matrix">motif.matrix</code></td>
<td>
<p>A peak x motif matrix. If NULL, pull the peak x motif
matrix from a Motif object stored in the assay.</p>
</td></tr>
<tr><td><code id="RunChromVAR_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="RunChromVAR_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="RunChromVAR_+3A_new.assay.name">new.assay.name</code></td>
<td>
<p>Name of new assay used to store the chromVAR results.
Default is &quot;chromvar&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the chromVAR documentation for more information:
<a href="https://greenleaflab.github.io/chromVAR/index.html">https://greenleaflab.github.io/chromVAR/index.html</a>
</p>
<p>See the chromVAR paper: <a href="https://www.nature.com/articles/nmeth.4401">https://www.nature.com/articles/nmeth.4401</a>
</p>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object with a new assay
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(BSgenome.Hsapiens.UCSC.hg19)
RunChromVAR(object = atac_small[["peaks"]], genome = BSgenome.Hsapiens.UCSC.hg19)

## End(Not run)
## Not run: 
library(BSgenome.Hsapiens.UCSC.hg19)
RunChromVAR(object = atac_small, genome = BSgenome.Hsapiens.UCSC.hg19)

## End(Not run)
</code></pre>

<hr>
<h2 id='RunSVD'>Run singular value decomposition</h2><span id='topic+RunSVD'></span><span id='topic+RunSVD.default'></span><span id='topic+RunSVD.Assay'></span><span id='topic+RunSVD.StdAssay'></span><span id='topic+RunSVD.Seurat'></span>

<h3>Description</h3>

<p>Run partial singular value decomposition using <code><a href="irlba.html#topic+irlba">irlba</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunSVD(object, ...)

## Default S3 method:
RunSVD(
  object,
  assay = NULL,
  n = 50,
  scale.embeddings = TRUE,
  reduction.key = "LSI_",
  scale.max = NULL,
  verbose = TRUE,
  irlba.work = n * 3,
  tol = 1e-05,
  ...
)

## S3 method for class 'Assay'
RunSVD(
  object,
  assay = NULL,
  features = NULL,
  n = 50,
  reduction.key = "LSI_",
  scale.max = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'StdAssay'
RunSVD(
  object,
  assay = NULL,
  features = NULL,
  n = 50,
  reduction.key = "LSI_",
  scale.max = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
RunSVD(
  object,
  assay = NULL,
  features = NULL,
  n = 50,
  reduction.key = "LSI_",
  reduction.name = "lsi",
  scale.max = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunSVD_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_assay">assay</code></td>
<td>
<p>Which assay to use. If NULL, use the default assay</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_n">n</code></td>
<td>
<p>Number of singular values to compute</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_scale.embeddings">scale.embeddings</code></td>
<td>
<p>Scale cell embeddings within each component to
mean 0 and SD 1 (default TRUE).</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_reduction.key">reduction.key</code></td>
<td>
<p>Key for dimension reduction object</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_scale.max">scale.max</code></td>
<td>
<p>Clipping value for cell embeddings.
Default (NULL) is no clipping.</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_verbose">verbose</code></td>
<td>
<p>Print messages</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_irlba.work">irlba.work</code></td>
<td>
<p>work parameter for <code><a href="irlba.html#topic+irlba">irlba</a></code>.
Working subspace dimension, larger values can speed convergence at the
cost of more memory use.</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_tol">tol</code></td>
<td>
<p>Tolerance (tol) parameter for <code><a href="irlba.html#topic+irlba">irlba</a></code>. Larger
values speed up convergence due to greater amount of allowed error.</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_features">features</code></td>
<td>
<p>Which features to use. If NULL, use variable features</p>
</td></tr>
<tr><td><code id="RunSVD_+3A_reduction.name">reduction.name</code></td>
<td>
<p>Name for stored dimension reduction object.
Default 'svd'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(data = rnorm(100), ncol = 10)
RunSVD(x)
## Not run: 
RunSVD(atac_small[['peaks']])

## End(Not run)
## Not run: 
RunSVD(atac_small[['peaks']])

## End(Not run)
## Not run: 
RunSVD(atac_small)

## End(Not run)
</code></pre>

<hr>
<h2 id='RunTFIDF'>Compute the term-frequency inverse-document-frequency</h2><span id='topic+RunTFIDF'></span><span id='topic+RunTFIDF.default'></span><span id='topic+RunTFIDF.Assay'></span><span id='topic+RunTFIDF.StdAssay'></span><span id='topic+RunTFIDF.Seurat'></span>

<h3>Description</h3>

<p>Run term frequency inverse document frequency (TF-IDF) normalization on a
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunTFIDF(object, ...)

## Default S3 method:
RunTFIDF(
  object,
  assay = NULL,
  method = 1,
  scale.factor = 10000,
  idf = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'Assay'
RunTFIDF(
  object,
  assay = NULL,
  method = 1,
  scale.factor = 10000,
  idf = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'StdAssay'
RunTFIDF(
  object,
  assay = NULL,
  method = 1,
  scale.factor = 10000,
  idf = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'Seurat'
RunTFIDF(
  object,
  assay = NULL,
  method = 1,
  scale.factor = 10000,
  idf = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunTFIDF_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="RunTFIDF_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="RunTFIDF_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="RunTFIDF_+3A_method">method</code></td>
<td>
<p>Which TF-IDF implementation to use. Choice of:
</p>

<ul>
<li><p>1: The TF-IDF implementation used by Stuart &amp; Butler et al. 2019
(<a href="https://doi.org/10.1101/460147">doi:10.1101/460147</a>). This computes
<code class="reqn">\log(TF \times IDF)</code>.
</p>
</li>
<li><p>2: The TF-IDF implementation used by Cusanovich &amp; Hill
et al. 2018 (<a href="https://doi.org/10.1016/j.cell.2018.06.052">doi:10.1016/j.cell.2018.06.052</a>). This
computes <code class="reqn">TF \times (\log(IDF))</code>.
</p>
</li>
<li><p>3: The log-TF method used by Andrew Hill.
This computes <code class="reqn">\log(TF) \times \log(IDF)</code>.
</p>
</li>
<li><p>4: The 10x Genomics method (no TF normalization). This computes
<code class="reqn">IDF</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="RunTFIDF_+3A_scale.factor">scale.factor</code></td>
<td>
<p>Which scale factor to use. Default is 10000.</p>
</td></tr>
<tr><td><code id="RunTFIDF_+3A_idf">idf</code></td>
<td>
<p>A precomputed IDF vector to use. If NULL, compute based on the
input data matrix.</p>
</td></tr>
<tr><td><code id="RunTFIDF_+3A_verbose">verbose</code></td>
<td>
<p>Print progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four different TF-IDF methods are implemented. We recommend using method 1
(the default).
</p>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Latent_semantic_analysis#Latent_semantic_indexing">https://en.wikipedia.org/wiki/Latent_semantic_analysis#Latent_semantic_indexing</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(data = rbinom(n = 25, size = 5, prob = 0.2), nrow = 5)
RunTFIDF(object = mat)
RunTFIDF(atac_small[['peaks']])
RunTFIDF(atac_small[['peaks']])
RunTFIDF(object = atac_small)
</code></pre>

<hr>
<h2 id='seqinfo-methods'>Access and modify sequence information for ChromatinAssay objects</h2><span id='topic+seqinfo-methods'></span><span id='topic+seqinfo'></span><span id='topic+seqinfo+2CChromatinAssay-method'></span><span id='topic+seqinfo+3C-+2CChromatinAssay-method'></span><span id='topic+seqlevels+2CChromatinAssay-method'></span><span id='topic+seqlevels'></span><span id='topic+seqlevels+3C-+2CChromatinAssay-method'></span><span id='topic+seqnames+2CChromatinAssay-method'></span><span id='topic+seqnames'></span><span id='topic+seqnames+3C-+2CChromatinAssay-method'></span><span id='topic+seqlengths+2CChromatinAssay-method'></span><span id='topic+seqlengths'></span><span id='topic+seqlengths+3C-+2CChromatinAssay-method'></span><span id='topic+genome+2CChromatinAssay-method'></span><span id='topic+genome'></span><span id='topic+genome+3C-+2CChromatinAssay-method'></span><span id='topic+isCircular+2CChromatinAssay-method'></span><span id='topic+isCircular'></span><span id='topic+isCircular+3C-+2CChromatinAssay-method'></span><span id='topic+seqinfo+2CSeurat-method'></span><span id='topic+seqinfo+3C-+2CSeurat-method'></span><span id='topic+seqlevels+2CSeurat-method'></span><span id='topic+seqlevels+3C-+2CSeurat-method'></span><span id='topic+seqnames+2CSeurat-method'></span><span id='topic+seqnames+3C-+2CSeurat-method'></span><span id='topic+seqlengths+2CSeurat-method'></span><span id='topic+seqlengths+3C-+2CSeurat-method'></span><span id='topic+genome+2CSeurat-method'></span><span id='topic+genome+3C-+2CSeurat-method'></span><span id='topic+isCircular+2CSeurat-method'></span><span id='topic+isCircular+3C-+2CSeurat-method'></span>

<h3>Description</h3>

<p>Methods for accessing and modifying
<code><a href="GenomeInfoDb.html#topic+Seqinfo">Seqinfo</a></code> object information stored in a
<code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ChromatinAssay'
seqinfo(x)

## S4 replacement method for signature 'ChromatinAssay'
seqinfo(x) &lt;- value

## S4 method for signature 'ChromatinAssay'
seqlevels(x)

## S4 replacement method for signature 'ChromatinAssay'
seqlevels(x) &lt;- value

## S4 method for signature 'ChromatinAssay'
seqnames(x)

## S4 replacement method for signature 'ChromatinAssay'
seqnames(x) &lt;- value

## S4 method for signature 'ChromatinAssay'
seqlengths(x)

## S4 replacement method for signature 'ChromatinAssay'
seqlengths(x) &lt;- value

## S4 method for signature 'ChromatinAssay'
genome(x)

## S4 replacement method for signature 'ChromatinAssay'
genome(x) &lt;- value

## S4 method for signature 'ChromatinAssay'
isCircular(x)

## S4 replacement method for signature 'ChromatinAssay'
isCircular(x) &lt;- value

## S4 method for signature 'Seurat'
seqinfo(x)

## S4 replacement method for signature 'Seurat'
seqinfo(x) &lt;- value

## S4 method for signature 'Seurat'
seqlevels(x)

## S4 replacement method for signature 'Seurat'
seqlevels(x) &lt;- value

## S4 method for signature 'Seurat'
seqnames(x)

## S4 replacement method for signature 'Seurat'
seqnames(x) &lt;- value

## S4 method for signature 'Seurat'
seqlengths(x)

## S4 replacement method for signature 'Seurat'
seqlengths(x) &lt;- value

## S4 method for signature 'Seurat'
genome(x)

## S4 replacement method for signature 'Seurat'
genome(x) &lt;- value

## S4 method for signature 'Seurat'
isCircular(x)

## S4 replacement method for signature 'Seurat'
isCircular(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqinfo-methods_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code> object</p>
</td></tr>
<tr><td><code id="seqinfo-methods_+3A_value">value</code></td>
<td>
<p>A <code><a href="GenomeInfoDb.html#topic+Seqinfo">Seqinfo</a></code> object or name of a UCSC
genome to store in the <code><a href="#topic+ChromatinAssay">ChromatinAssay</a></code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>seqinfo(ChromatinAssay) &lt;- value</code>: set method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqlevels(ChromatinAssay)</code>: get method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqlevels(ChromatinAssay) &lt;- value</code>: set method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqnames(ChromatinAssay)</code>: get method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqnames(ChromatinAssay) &lt;- value</code>: set method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqlengths(ChromatinAssay)</code>: get method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqlengths(ChromatinAssay) &lt;- value</code>: set method for ChromatinAssay objects
</p>
</li>
<li> <p><code>genome(ChromatinAssay)</code>: get method for ChromatinAssay objects
</p>
</li>
<li> <p><code>genome(ChromatinAssay) &lt;- value</code>: set method for ChromatinAssay objects
</p>
</li>
<li> <p><code>isCircular(ChromatinAssay)</code>: get method for ChromatinAssay objects
</p>
</li>
<li> <p><code>isCircular(ChromatinAssay) &lt;- value</code>: set method for ChromatinAssay objects
</p>
</li>
<li> <p><code>seqinfo(Seurat)</code>: get method for Seurat objects
</p>
</li>
<li> <p><code>seqinfo(Seurat) &lt;- value</code>: set method for Seurat objects
</p>
</li>
<li> <p><code>seqlevels(Seurat)</code>: get method for Seurat objects
</p>
</li>
<li> <p><code>seqlevels(Seurat) &lt;- value</code>: set method for Seurat objects
</p>
</li>
<li> <p><code>seqnames(Seurat)</code>: get method for Seurat objects
</p>
</li>
<li> <p><code>seqnames(Seurat) &lt;- value</code>: set method for Seurat objects
</p>
</li>
<li> <p><code>seqlengths(Seurat)</code>: get method for Seurat objects
</p>
</li>
<li> <p><code>seqlengths(Seurat) &lt;- value</code>: set method for Seurat objects
</p>
</li>
<li> <p><code>genome(Seurat)</code>: get method for Seurat objects
</p>
</li>
<li> <p><code>genome(Seurat) &lt;- value</code>: set method for Seurat objects
</p>
</li>
<li> <p><code>isCircular(Seurat)</code>: get method for Seurat objects
</p>
</li>
<li> <p><code>isCircular(Seurat) &lt;- value</code>: set method for Seurat objects
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li><p><a href="GenomeInfoDb.html#topic+seqinfo">seqinfo</a> in the <span class="pkg">GenomeInfoDb</span> package.
</p>
</li>
<li><p><a href="#topic+ChromatinAssay-class">ChromatinAssay-class</a>
</p>
</li></ul>


<hr>
<h2 id='SetMotifData'>Set motif data</h2><span id='topic+SetMotifData'></span><span id='topic+SetMotifData.Motif'></span><span id='topic+SetMotifData.ChromatinAssay'></span><span id='topic+SetMotifData.Seurat'></span>

<h3>Description</h3>

<p>Set motif matrix for given assay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetMotifData(object, ...)

## S3 method for class 'Motif'
SetMotifData(object, slot, new.data, ...)

## S3 method for class 'ChromatinAssay'
SetMotifData(object, slot, new.data, ...)

## S3 method for class 'Seurat'
SetMotifData(object, assay = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SetMotifData_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="SetMotifData_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="SetMotifData_+3A_slot">slot</code></td>
<td>
<p>Name of slot to use</p>
</td></tr>
<tr><td><code id="SetMotifData_+3A_new.data">new.data</code></td>
<td>
<p>motif matrix to add. Should be matrix or sparse matrix class</p>
</td></tr>
<tr><td><code id="SetMotifData_+3A_assay">assay</code></td>
<td>
<p>Name of assay whose data should be set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>motif.obj &lt;- SeuratObject::GetAssayData(
  object = atac_small[['peaks']], slot = "motifs"
)
SetMotifData(object = motif.obj, slot = 'data', new.data = matrix(1:2))
SetMotifData(
  object = atac_small[['peaks']], slot = 'data', new.data = matrix(1:2)
)
motif.matrix &lt;- GetMotifData(object = atac_small)
SetMotifData(
object = atac_small, assay = 'peaks', slot = 'data', new.data = motif.matrix
)
</code></pre>

<hr>
<h2 id='SplitFragments'>Split fragment file by cell identities</h2><span id='topic+SplitFragments'></span>

<h3>Description</h3>

<p>Splits a fragment file into separate files for each group of cells. If
splitting multiple fragment files containing common cell types, fragments
originating from different files will be appended to the same file for one
group of cell identities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplitFragments(
  object,
  assay = NULL,
  group.by = NULL,
  idents = NULL,
  outdir = getwd(),
  file.suffix = "",
  append = TRUE,
  buffer_length = 256L,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplitFragments_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_group.by">group.by</code></td>
<td>
<p>Name of grouping variable to group cells by</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_idents">idents</code></td>
<td>
<p>List of identities to include</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_outdir">outdir</code></td>
<td>
<p>Directory to write output files</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_file.suffix">file.suffix</code></td>
<td>
<p>Suffix to add to all file names (before file extension).
If splitting multiple fragment files without the <code>append</code> option set to
TRUE, an additional numeric suffix will be added to each file (eg, .1, .2).</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_append">append</code></td>
<td>
<p>If splitting multiple fragment files, append cells from the
same group (eg cluster) to the same file. Note that this can cause the output
file to be unsorted.</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_buffer_length">buffer_length</code></td>
<td>
<p>Size of buffer to be read from the fragment file. This
must be longer than the longest line in the file.</p>
</td></tr>
<tr><td><code id="SplitFragments_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>

<hr>
<h2 id='StringToGRanges'>String to GRanges</h2><span id='topic+StringToGRanges'></span>

<h3>Description</h3>

<p>Convert a genomic coordinate string to a GRanges object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StringToGRanges(regions, sep = c("-", "-"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StringToGRanges_+3A_regions">regions</code></td>
<td>
<p>Vector of genomic region strings</p>
</td></tr>
<tr><td><code id="StringToGRanges_+3A_sep">sep</code></td>
<td>
<p>Vector of separators to use for genomic string. First element is
used to separate chromosome and coordinates, second separator is used to
separate start and end coordinates.</p>
</td></tr>
<tr><td><code id="StringToGRanges_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="GenomicRanges.html#topic+makeGRangesFromDataFrame">makeGRangesFromDataFrame</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a GRanges object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regions &lt;- c('chr1-1-10', 'chr2-12-3121')
StringToGRanges(regions = regions)
</code></pre>

<hr>
<h2 id='subset.Fragment'>Subset a Fragment object</h2><span id='topic+subset.Fragment'></span>

<h3>Description</h3>

<p>Returns a subset of a <code><a href="#topic+Fragment-class">Fragment-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Fragment'
subset(x, cells = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.Fragment_+3A_x">x</code></td>
<td>
<p>A Fragment object</p>
</td></tr>
<tr><td><code id="subset.Fragment_+3A_cells">cells</code></td>
<td>
<p>Vector of cells to retain</p>
</td></tr>
<tr><td><code id="subset.Fragment_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a subsetted <code><a href="#topic+Fragment">Fragment</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
cells &lt;- colnames(x = atac_small)
names(x = cells) &lt;- paste0("test_", cells)
frags &lt;- CreateFragmentObject(path = fpath, cells = cells, verbose = FALSE, tolerance = 0.5)
subset(frags, head(names(cells)))
</code></pre>

<hr>
<h2 id='subset.Motif'>Subset a Motif object</h2><span id='topic+subset.Motif'></span><span id='topic++5B.Motif'></span>

<h3>Description</h3>

<p>Returns a subset of a <code><a href="#topic+Motif-class">Motif-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Motif'
subset(x, features = NULL, motifs = NULL, ...)

## S3 method for class 'Motif'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.Motif_+3A_x">x</code></td>
<td>
<p>A Motif object</p>
</td></tr>
<tr><td><code id="subset.Motif_+3A_features">features</code></td>
<td>
<p>Which features to retain</p>
</td></tr>
<tr><td><code id="subset.Motif_+3A_motifs">motifs</code></td>
<td>
<p>Which motifs to retain</p>
</td></tr>
<tr><td><code id="subset.Motif_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
<tr><td><code id="subset.Motif_+3A_i">i</code></td>
<td>
<p>Which columns to retain</p>
</td></tr>
<tr><td><code id="subset.Motif_+3A_j">j</code></td>
<td>
<p>Which rows to retain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a subsetted <code><a href="#topic+Motif">Motif</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+subset">subset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>motif.obj &lt;- SeuratObject::GetAssayData(
  object = atac_small[['peaks']], slot = "motifs"
)
subset(x = motif.obj, features = head(rownames(motif.obj), 10))
motif.obj &lt;- SeuratObject::GetAssayData(
  object = atac_small, assay = 'peaks', slot = 'motifs'
)
motif.obj[1:10,1:10]
</code></pre>

<hr>
<h2 id='SubsetMatrix'>Subset matrix rows and columns</h2><span id='topic+SubsetMatrix'></span>

<h3>Description</h3>

<p>Subset the rows and columns of a matrix by removing
rows and columns with less than the specified number of
non-zero elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubsetMatrix(
  mat,
  min.rows = 1,
  min.cols = 1,
  max.row.val = 10,
  max.col.val = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SubsetMatrix_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="SubsetMatrix_+3A_min.rows">min.rows</code></td>
<td>
<p>Minimum number of non-zero elements for
the row to be retained</p>
</td></tr>
<tr><td><code id="SubsetMatrix_+3A_min.cols">min.cols</code></td>
<td>
<p>Minimum number of non-zero elements for
the column to be retained</p>
</td></tr>
<tr><td><code id="SubsetMatrix_+3A_max.row.val">max.row.val</code></td>
<td>
<p>Maximum allowed value in a row for the
row to be retained. If NULL, don't set any limit.</p>
</td></tr>
<tr><td><code id="SubsetMatrix_+3A_max.col.val">max.col.val</code></td>
<td>
<p>Maximum allowed value in a column for
the column to be retained. If NULL, don't set any limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SubsetMatrix(mat = volcano)
</code></pre>

<hr>
<h2 id='theme_browser'>Genome browser theme</h2><span id='topic+theme_browser'></span>

<h3>Description</h3>

<p>Theme applied to panels in the <code><a href="#topic+CoveragePlot">CoveragePlot</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_browser(..., legend = TRUE, axis.text.y = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_browser_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="theme_browser_+3A_legend">legend</code></td>
<td>
<p>Display plot legend</p>
</td></tr>
<tr><td><code id="theme_browser_+3A_axis.text.y">axis.text.y</code></td>
<td>
<p>Display y-axis text</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
PeakPlot(atac_small, region = "chr1-710000-715000") + theme_browser()

</code></pre>

<hr>
<h2 id='TilePlot'>Plot integration sites per cell</h2><span id='topic+TilePlot'></span>

<h3>Description</h3>

<p>Plots the presence/absence of Tn5 integration sites for each cell
within a genomic region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TilePlot(
  object,
  region,
  sep = c("-", "-"),
  tile.size = 100,
  tile.cells = 100,
  extend.upstream = 0,
  extend.downstream = 0,
  assay = NULL,
  cells = NULL,
  group.by = NULL,
  order.by = "total",
  idents = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TilePlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_region">region</code></td>
<td>
<p>A set of genomic coordinates to show. Can be a GRanges object,
a string encoding a genomic position, a gene name, or a vector of strings
describing the genomic coordinates or gene names to plot. If a gene name is
supplied, annotations must be present in the assay.</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_sep">sep</code></td>
<td>
<p>Separators to use for strings encoding genomic coordinates. First
element is used to separate the chromosome from the coordinates, second
element is used to separate the start from end coordinate.</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_tile.size">tile.size</code></td>
<td>
<p>Size of the sliding window for per-cell fragment tile plot</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_tile.cells">tile.cells</code></td>
<td>
<p>Number of cells to display fragment information for in tile
plot.</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_extend.upstream">extend.upstream</code></td>
<td>
<p>Number of bases to extend the region upstream.</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_extend.downstream">extend.downstream</code></td>
<td>
<p>Number of bases to extend the region downstream.</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_cells">cells</code></td>
<td>
<p>Which cells to plot. Default all cells</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_group.by">group.by</code></td>
<td>
<p>Name of grouping variable to group cells by. If NULL, use the
current cell identities</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_order.by">order.by</code></td>
<td>
<p>Option for determining how cells are chosen from each group.
Options are &quot;total&quot; or &quot;random&quot;. &quot;total&quot; will select the top cells based on
total number of fragments in the region, &quot;random&quot; will select randomly.</p>
</td></tr>
<tr><td><code id="TilePlot_+3A_idents">idents</code></td>
<td>
<p>List of cell identities to include in the plot. If NULL, use
all identities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
fragments &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  validate.fragments = FALSE
)
Fragments(atac_small) &lt;- fragments
TilePlot(object = atac_small, region = c("chr1-713500-714500"))

</code></pre>

<hr>
<h2 id='TSSEnrichment'>Compute TSS enrichment score per cell</h2><span id='topic+TSSEnrichment'></span>

<h3>Description</h3>

<p>Compute the transcription start site (TSS) enrichment score for each cell,
as defined by ENCODE:
<a href="https://www.encodeproject.org/data-standards/terms/">https://www.encodeproject.org/data-standards/terms/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSSEnrichment(
  object,
  tss.positions = NULL,
  n = NULL,
  fast = TRUE,
  assay = NULL,
  cells = NULL,
  process_n = 2000,
  verbose = TRUE,
  region_extension = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSSEnrichment_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_tss.positions">tss.positions</code></td>
<td>
<p>A GRanges object containing the TSS positions. If NULL,
use the genomic annotations stored in the assay.</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_n">n</code></td>
<td>
<p>Number of TSS positions to use. This will select the first _n_
TSSs from the set. If NULL, use all TSSs (slower).</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_fast">fast</code></td>
<td>
<p>Just compute the TSS enrichment score, without storing the
base-resolution matrix of integration counts at each site. This reduces the
memory required to store the object but does not allow plotting the
accessibility profile at the TSS.</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_cells">cells</code></td>
<td>
<p>A vector of cells to include. If NULL (default), use all cells
in the object</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_process_n">process_n</code></td>
<td>
<p>Number of regions to process at a time if using <code>fast</code>
option.</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="TSSEnrichment_+3A_region_extension">region_extension</code></td>
<td>
<p>Distance extended upstream and downstream from TSS
in which to calculate enrichment and background.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The computed score will be added to the object metadata as &quot;TSS.enrichment&quot;.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="SeuratObject.html#topic+Seurat">Seurat</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fpath &lt;- system.file("extdata", "fragments.tsv.gz", package="Signac")
Fragments(atac_small) &lt;- CreateFragmentObject(
  path = fpath,
  cells = colnames(atac_small),
  tolerance = 0.5
)
TSSEnrichment(object = atac_small)

## End(Not run)
</code></pre>

<hr>
<h2 id='TSSPlot'>Plot signal enrichment around TSSs</h2><span id='topic+TSSPlot'></span>

<h3>Description</h3>

<p>Plot the normalized TSS enrichment score at each position relative to the
TSS. Requires that <code><a href="#topic+TSSEnrichment">TSSEnrichment</a></code> has already been run on the
assay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSSPlot(object, assay = NULL, group.by = NULL, idents = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSSPlot_+3A_object">object</code></td>
<td>
<p>A Seurat object</p>
</td></tr>
<tr><td><code id="TSSPlot_+3A_assay">assay</code></td>
<td>
<p>Name of the assay to use. Should have the TSS enrichment
information for each cell
already computed by running <code><a href="#topic+TSSEnrichment">TSSEnrichment</a></code></p>
</td></tr>
<tr><td><code id="TSSPlot_+3A_group.by">group.by</code></td>
<td>
<p>Set of identities to group cells by</p>
</td></tr>
<tr><td><code id="TSSPlot_+3A_idents">idents</code></td>
<td>
<p>Set of identities to include in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object
</p>

<hr>
<h2 id='UnifyPeaks'>Unify genomic ranges</h2><span id='topic+UnifyPeaks'></span>

<h3>Description</h3>

<p>Create a unified set of non-overlapping genomic ranges
from multiple Seurat objects containing single-cell
chromatin data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnifyPeaks(object.list, mode = "reduce")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnifyPeaks_+3A_object.list">object.list</code></td>
<td>
<p>A list of Seurat objects or ChromatinAssay objects</p>
</td></tr>
<tr><td><code id="UnifyPeaks_+3A_mode">mode</code></td>
<td>
<p>Function to use when combining genomic ranges. Can be &quot;reduce&quot;
(default) or &quot;disjoin&quot;.
See <code><a href="GenomicRanges.html#topic+reduce">reduce</a></code>
and <code><a href="GenomicRanges.html#topic+disjoin">disjoin</a></code>
for more information on these functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a GRanges object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UnifyPeaks(object.list = list(atac_small, atac_small))
</code></pre>

<hr>
<h2 id='UpdatePath'>Update the file path for a Fragment object</h2><span id='topic+UpdatePath'></span>

<h3>Description</h3>

<p>Change the path to a fragment file store in a <code><a href="#topic+Fragment">Fragment</a></code>
object. Path must be to the same file that was used to create the fragment
object. An MD5 hash will be computed using the new path and compared to the
hash stored in the Fragment object to verify that the files are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UpdatePath(object, new.path, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UpdatePath_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Fragment">Fragment</a></code> object</p>
</td></tr>
<tr><td><code id="UpdatePath_+3A_new.path">new.path</code></td>
<td>
<p>Path to the fragment file</p>
</td></tr>
<tr><td><code id="UpdatePath_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>

<hr>
<h2 id='ValidateCells'>Validate cells present in fragment file</h2><span id='topic+ValidateCells'></span>

<h3>Description</h3>

<p>Search for a fragment from each cell that should exist in the fragment file.
Will iterate through chunks of the fragment file until at least one fragment
from each cell barcode requested is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ValidateCells(
  object,
  cells = NULL,
  tolerance = 0.5,
  max.lines = 5e+07,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ValidateCells_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Fragment">Fragment</a></code> object</p>
</td></tr>
<tr><td><code id="ValidateCells_+3A_cells">cells</code></td>
<td>
<p>A character vector containing cell barcodes to search for.
If NULL, use the cells stored in the Fragment object.</p>
</td></tr>
<tr><td><code id="ValidateCells_+3A_tolerance">tolerance</code></td>
<td>
<p>Fraction of input cells that can be unseen before returning
TRUE. For example, <code>tolerance = 0.01</code> will return TRUE when 99
have observed fragments in the file. This can be useful if there are cells
present that have much fewer total counts, and would require extensive
searching before a fragment from those cells are found.</p>
</td></tr>
<tr><td><code id="ValidateCells_+3A_max.lines">max.lines</code></td>
<td>
<p>Maximum number of lines to read in without finding the
required number of cells before returning FALSE. Setting this value avoids
having to search the whole file if it becomes clear that the expected cells
are not present. Setting this value to NULL will enable an exhaustive search
of the entire file.</p>
</td></tr>
<tr><td><code id="ValidateCells_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>

<hr>
<h2 id='ValidateFragments'>Validate Fragment object</h2><span id='topic+ValidateFragments'></span>

<h3>Description</h3>

<p>Verify that the cells listed in the object exist in the fragment file
and that the fragment file or index have not changed since creating the
fragment object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ValidateFragments(object, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ValidateFragments_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Fragment">Fragment</a></code> object</p>
</td></tr>
<tr><td><code id="ValidateFragments_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
<tr><td><code id="ValidateFragments_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="#topic+ValidateCells">ValidateCells</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='ValidateHash'>Validate hashes for Fragment object</h2><span id='topic+ValidateHash'></span>

<h3>Description</h3>

<p>Validate hashes for Fragment object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ValidateHash(object, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ValidateHash_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Fragment">Fragment</a></code> object</p>
</td></tr>
<tr><td><code id="ValidateHash_+3A_verbose">verbose</code></td>
<td>
<p>Display messages</p>
</td></tr>
</table>

<hr>
<h2 id='VariantPlot'>Plot strand concordance vs. VMR</h2><span id='topic+VariantPlot'></span>

<h3>Description</h3>

<p>Plot the Pearson correlation between allele frequencies on each strand
versus the log10 mean-variance ratio for the allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VariantPlot(
  variants,
  min.cells = 2,
  concordance.threshold = 0.65,
  vmr.threshold = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VariantPlot_+3A_variants">variants</code></td>
<td>
<p>A dataframe containing variant information. This should be
computed using <code><a href="#topic+IdentifyVariants">IdentifyVariants</a></code></p>
</td></tr>
<tr><td><code id="VariantPlot_+3A_min.cells">min.cells</code></td>
<td>
<p>Minimum number of high-confidence cells detected with the
variant for the variant to be displayed.</p>
</td></tr>
<tr><td><code id="VariantPlot_+3A_concordance.threshold">concordance.threshold</code></td>
<td>
<p>Strand concordance threshold</p>
</td></tr>
<tr><td><code id="VariantPlot_+3A_vmr.threshold">vmr.threshold</code></td>
<td>
<p>Mean-variance ratio threshold</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
