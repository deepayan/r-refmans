<!DOCTYPE html><html><head><title>Help for package clhs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clhs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clhs-package'><p>Conditioned Latin Hypercube Sampling</p></a></li>
<li><a href='#clhs'><p>Conditioned Latin Hypercube Sampling</p></a></li>
<li><a href='#cLHS_result'><p>Conditioned Latin Hypercube Sampling result</p></a></li>
<li><a href='#CppLHS'><p>This is the internal Cpp function used to run the metropolis hasting algorithm if use.cpp = T.</p>
In general, it shouldn't be used as a stand alone function, because some preprocessing is done in R</a></li>
<li><a href='#plot.cLHS_result'><p>Plot cLHS results</p></a></li>
<li><a href='#similarity_buffer'><p>Gower similarity analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conditioned Latin Hypercube Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre Roudier &lt;roudierp@landcareresearch.co.nz&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pierreroudier/clhs/">https://github.com/pierreroudier/clhs/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pierreroudier/clhs/issues">https://github.com/pierreroudier/clhs/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Conditioned Latin hypercube sampling, as published by Minasny and McBratney (2006) &lt;<a href="https://doi.org/10.1016%2Fj.cageo.2005.12.009">doi:10.1016/j.cageo.2005.12.009</a>&gt;. This method proposes to stratify sampling in presence of ancillary data. An extension of this method, which propose to associate a cost to each individual and take it into account during the optimisation process, is also proposed (Roudier et al., 2012, &lt;<a href="https://doi.org/10.1201%2Fb12728">doi:10.1201/b12728</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, grid, ggplot2, sp, sf, raster, reshape2, plyr,
cluster, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'clhs-internal.R' 'clhs-data.frame.R'
'clhs-package.R' 'clhs-raster.R' 'utils.R' 'clhs.R' 'clhs-sf.R'
'clhs-sp.R' 'plot.R' 'similarity.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-14 01:51:12 UTC; roudierp</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre Roudier [aut, cre],
  Colby Brugnard [ctb],
  Dylan Beaudette [ctb],
  Benjamin Louis [ctb],
  Kiri Daust [ctb],
  David Clifford [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-14 04:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='clhs-package'>Conditioned Latin Hypercube Sampling</h2><span id='topic+clhs-package'></span>

<h3>Description</h3>

<p>This package implements the conditioned Latin hypercube sampling, as
published by Minasny and McBratney (2006) and the DLHS variant method 
(Minasny and McBratney, 2010).. This method proposes to stratify sampling in 
presence of ancillary data.
</p>


<h3>Details</h3>

<p>An extension of this method, which propose to associate a cost to each
individual and take it into account during the optimisation process, is also
proposed (Roudier et al., 2012).
</p>


<h3>Author(s)</h3>

<p>Pierre Roudier
</p>


<h3>References</h3>

<p>* For the initial cLHS method:
</p>
<p>Minasny, B. and McBratney, A.B. 2006. A conditioned Latin hypercube method
for sampling in the presence of ancillary information. Computers and
Geosciences, 32:1378-1388.
</p>
<p>*For the DLHS variant method:
</p>
<p>Minasny, B. and A. B. McBratney, A.B.. 2010. Conditioned Latin Hypercube 
Sampling for Calibrating Soil Sensor Data to Soil Properties. In: Proximal 
Soil Sensing, Progress in Soil Science, pages 111-119. 
</p>
<p>* For the cost-constrained implementation:
</p>
<p>Roudier, P., Beaudette, D.E. and Hewitt, A.E. 2012. A conditioned Latin
hypercube sampling algorithm incorporating operational constraints. In:
Digital Soil Assessments and Beyond. Proceedings of the 5th Global Workshop
on Digital Soil Mapping, Sydney, Australia.
</p>
<p>* For the similarity buffer prediction:
</p>
<p>Brungard, C. and Johanson, J. 2015. The gate's locked! I can't get to the exact 
sampling spot... can I sample nearby? Pedometron, 37:8&ndash;10.
</p>


<h3>See Also</h3>

<p><code>sample</code>
</p>

<hr>
<h2 id='clhs'>Conditioned Latin Hypercube Sampling</h2><span id='topic+clhs'></span><span id='topic+clhs.data.frame'></span><span id='topic+clhs.sf'></span><span id='topic+clhs.SpatialPointsDataFrame'></span><span id='topic+clhs.Raster'></span>

<h3>Description</h3>

<p>Implementation of the conditioned Latin hypercube sampling, as published by
Minasny and McBratney (2006) and the DLHS variant method (Minasny and 
McBratney, 2010). These methods propose to stratify sampling in
presence of ancillary data. An extension of this method, which propose to
associate a cost to each individual and take it into account during the
optimisation process, is also proposed (Roudier et al., 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clhs(
  x,
  size,
  must.include,
  can.include,
  cost,
  iter,
  use.cpp,
  temp,
  tdecrease,
  weights,
  eta,
  obj.limit,
  length.cycle,
  simple,
  progress,
  track,
  use.coords,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clhs_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>, <code>SpatialPointsDataFrame</code>, <code>sf</code>, or <code>Raster</code>
object.</p>
</td></tr>
<tr><td><code id="clhs_+3A_size">size</code></td>
<td>
<p>A non-negative integer giving the total number of items to select</p>
</td></tr>
<tr><td><code id="clhs_+3A_must.include">must.include</code></td>
<td>
<p>A numeric vector giving the indices of the rows from <code>x</code> that must be 
included in the selected items. For the cost-constrained cLHS method, cost of 
these mandatory samples is set to 0. If NULL (default), all data are randomly 
chosen according to the classic cLHS method. If <code>must.include</code> is not NULL,
argument <code>size</code> must include the total size of the final sample i.e. the
size of mandatory samples given by <code>must.include</code> plus the size of the randomly
chosen samples to pick.</p>
</td></tr>
<tr><td><code id="clhs_+3A_can.include">can.include</code></td>
<td>
<p>A numeric vector giving indices of the rows from <code>x</code> 
that are allowed to be sampled from. The algorithm will use all of <code>x</code> as the reference
distribution, but will only select samples from possible.sample. The option is only available in the
C++ version; if <code>use.cpp == FALSE</code>, this parameter will be ignored.</p>
</td></tr>
<tr><td><code id="clhs_+3A_cost">cost</code></td>
<td>
<p>A character giving the name or an integer giving the index of
the attribute in <code>x</code> that gives a cost that can be use to constrain the
cLHS sampling. If NULL (default), the cost-constrained implementation is not
used.</p>
</td></tr>
<tr><td><code id="clhs_+3A_iter">iter</code></td>
<td>
<p>A positive number, giving the number of iterations for the
Metropolis-Hastings annealing process. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="clhs_+3A_use.cpp">use.cpp</code></td>
<td>
<p>TRUE or FALSE. If set to TRUE, annealing process uses C++ code.
This is ~ 150 times faster than the R version, but is less stable and currently 
doesn't accept track or obj.limit parameters. Default to TRUE.</p>
</td></tr>
<tr><td><code id="clhs_+3A_temp">temp</code></td>
<td>
<p>The initial temperature at which the simulated annealing
begins. Defaults to 1.</p>
</td></tr>
<tr><td><code id="clhs_+3A_tdecrease">tdecrease</code></td>
<td>
<p>A number between 0 and 1, giving the rate at which
temperature decreases in the simulated annealing process. Defaults to 0.95.</p>
</td></tr>
<tr><td><code id="clhs_+3A_weights">weights</code></td>
<td>
<p>A list a length 3, giving the relative weights for
continuous data, categorical data, and correlation between variables.
Defaults to <code>list(numeric = 1, factor = 1, correlation = 1)</code>.</p>
</td></tr>
<tr><td><code id="clhs_+3A_eta">eta</code></td>
<td>
<p>Either a number equal 1 to perform a classic cLHS or a constrained 
cLHS or a matrix to perform a cLHS that samples more on the edge of the
distibutions (DLHS, see details)</p>
</td></tr>
<tr><td><code id="clhs_+3A_obj.limit">obj.limit</code></td>
<td>
<p>The minimal value at which the optimisation is stopped.
Defaults to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="clhs_+3A_length.cycle">length.cycle</code></td>
<td>
<p>The duration (number of iterations) of the
isotemperature steps. Defaults to 10.</p>
</td></tr>
<tr><td><code id="clhs_+3A_simple">simple</code></td>
<td>
<p>TRUE or FALSE. If set to TRUE, only the indices of the
selected samples are returned, as a numeric vector. If set to FALSE, a
cLHS_result object is returned (takes more memory but allows to make use of
cLHS_results methods such as <code>plot.cLHS_result</code>).</p>
</td></tr>
<tr><td><code id="clhs_+3A_progress">progress</code></td>
<td>
<p>TRUE or FALSE, displays a progress bar.</p>
</td></tr>
<tr><td><code id="clhs_+3A_track">track</code></td>
<td>
<p>A character giving the name or an integer giving the index
of the attribute in <code>x</code> that gives a cost associated with each
individual. However, this method will only track the cost - the sampling
process will not be constrained by this attribute. If NULL (default), this
option is not used.</p>
</td></tr>
<tr><td><code id="clhs_+3A_use.coords">use.coords</code></td>
<td>
<p>Logical, if TRUE the spatial coordinates of supported spatial objects (either a 'SpatialPointsDataFrame' object if using 'sp', or a 'sf' object if using 'sf') are included in the Latin hypercube calculations. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="clhs_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>clhs</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the DLHS method, the original paper defines parameter <code>b</code> as the importance 
of the edge of the distributions. A matrix <code>eta</code> (size N x K, where N is the size of 
the final sample and K the number of continuous variables) is defined, to 
compute the objective function of the algorithm, where each column equal the 
vector (b, 1, ..., 1, b) in order to give the edge of the distribution a 
probability b times higher to be sampled. In our function, instead of define 
the <code>b</code> parameter, users can defined their own <code>eta</code> matrix so that they 
can give more complex probability design of sampling each strata of the 
distribution instead of just be able to give more importance to both edges of 
the distribution.
</p>


<h3>Value</h3>

<p>* If the <code>simple</code> option is set to TRUE (default behaviour): A
numeric vector containing the indices of the selected samples is returned
</p>
<p>* If the <code>simple</code> option is set to FALSE: An object of class
<code>cLHS_result</code>, with the following elements: </p>
<table>
<tr><td><code>index_samples</code></td>
<td>
<p>a
vector giving the indices of the chosen samples.</p>
</td></tr> <tr><td><code>sampled_data</code></td>
<td>
<p>the
sampled data.frame.</p>
</td></tr> <tr><td><code>obj</code></td>
<td>
<p>a vector giving the evolution of the
objective function throughout the Metropolis-Hastings iterations.</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>a vector giving the evolution of the cost function throughout
the Metropolis-Hastings iterations (if available).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre Roudier
</p>


<h3>References</h3>

<p>*For the initial cLHS method:
</p>
<p>Minasny, B. and McBratney, A.B. 2006. A conditioned Latin hypercube method
for sampling in the presence of ancillary information. Computers and
Geosciences, 32:1378-1388.
</p>
<p>*For the DLHS method:
</p>
<p>Minasny, B. and A. B. McBratney, A.B.. 2010. Conditioned Latin Hypercube 
Sampling for Calibrating Soil Sensor Data to Soil Properties. In: Proximal 
Soil Sensing, Progress in Soil Science, pages 111-119.
</p>
<p>*For the cost-constrained implementation:
</p>
<p>Roudier, P., Beaudette, D.E. and Hewitt, A.E. 2012. A conditioned Latin
hypercube sampling algorithm incorporating operational constraints. In:
Digital Soil Assessments and Beyond. Proceedings of the 5th Global Workshop
on Digital Soil Mapping, Sydney, Australia.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cLHS_result">plot.cLHS_result</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  a = runif(1000), 
  b = rnorm(1000), 
  c = sample(LETTERS[1:5], size = 1000, replace = TRUE)
)

# Returning the indices of the sampled points
res &lt;- clhs(df, size = 50, progress = FALSE, simple = TRUE)
str(res)

# Returning a cLHS_result object for plotting using C++
res &lt;- clhs(df, size = 50, use.cpp = TRUE, iter = 5000, progress = FALSE, simple = FALSE)
str(res)
plot(res)

# Method DLHS with a linear increase of the strata weight (i.e. probability to be sampled)
# from 1 for the middle starta to 3 for the edge of the distribution
linear_increase &lt;- 1+(2/24)*0:24
eta &lt;- matrix(c(rev(linear_increase), linear_increase), ncol = 2, nrow = 50)
set.seed(1)
res &lt;- clhs(df, size = 50, iter = 100, eta = eta, progress = FALSE, simple = FALSE)
str(res)
plot(res)  

</code></pre>

<hr>
<h2 id='cLHS_result'>Conditioned Latin Hypercube Sampling result</h2><span id='topic+cLHS_result'></span>

<h3>Description</h3>

<p>A S3 class describing a cLHS result.
</p>


<h3>Value</h3>

<p>An object of class <code>cLHS_result</code> contains the following slots:
</p>
<table>
<tr><td><code>index_samples</code></td>
<td>
<p>a vector giving the indices of the chosen samples.</p>
</td></tr>
<tr><td><code>sampled_data</code></td>
<td>
<p>the sampled data.frame.</p>
</td></tr> <tr><td><code>obj</code></td>
<td>
<p>a vector giving the
evolution of the objective function throughout the Metropolis-Hastings
iterations.</p>
</td></tr> <tr><td><code>cost</code></td>
<td>
<p>a vector giving the evolution of the cost function
throughout the Meropolis-Hastings iterations, if available, otherwise NULL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pierre Roudier
</p>


<h3>See Also</h3>

<p><code>clhs</code>
</p>

<hr>
<h2 id='CppLHS'>This is the internal Cpp function used to run the metropolis hasting algorithm if use.cpp = T. 
In general, it shouldn't be used as a stand alone function, because some preprocessing is done in R</h2><span id='topic+CppLHS'></span>

<h3>Description</h3>

<p>This is the internal Cpp function used to run the metropolis hasting algorithm if use.cpp = T. 
In general, it shouldn't be used as a stand alone function, because some preprocessing is done in R
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="CppLHS_+3A_xa">xA</code></td>
<td>
<p>matrix of data - must be numeric (factors are converted to numeric in R)</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_cost">cost</code></td>
<td>
<p>cost vector (0 if no cost)</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_strata">strata</code></td>
<td>
<p>matrix of continuous strata</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_include">include</code></td>
<td>
<p>matrix of included data</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_idx">idx</code></td>
<td>
<p>integer vector of rows from which sampling is allowed</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_factors">factors</code></td>
<td>
<p>boolean factor flag</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_i_fact">i_fact</code></td>
<td>
<p>indices of factors in xA</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_nsample">nsample</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_cost_mode">cost_mode</code></td>
<td>
<p>bool cost flag</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_iter">iter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_wcont">wCont</code></td>
<td>
<p>continuous weight</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_wfact">wFact</code></td>
<td>
<p>factor weights</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_wcorr">wCorr</code></td>
<td>
<p>correlation weights</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_etamat">etaMat</code></td>
<td>
<p>eta matrix - either all 1, or user input</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_temperature">temperature</code></td>
<td>
<p>initial temperature</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_tdecrease">tdecrease</code></td>
<td>
<p>temperature decrease every length_cycle iterations</p>
</td></tr>
<tr><td><code id="CppLHS_+3A_length_cycle">length_cycle</code></td>
<td>
<p>number of iterations between temperature decrease</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with sampled data, indices, objective values, cost value, and final continuous weights for each sample
</p>

<hr>
<h2 id='plot.cLHS_result'>Plot cLHS results</h2><span id='topic+plot.cLHS_result'></span>

<h3>Description</h3>

<p>Produces a plot illustrating the result of a cLHS sampling procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cLHS_result'
plot(x, modes = "obj", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cLHS_result_+3A_x">x</code></td>
<td>
<p>Object of class &ldquo;cLHS_result&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.cLHS_result_+3A_modes">modes</code></td>
<td>
<p>A character vector describing the plot to produce (see Details)</p>
</td></tr>
<tr><td><code id="plot.cLHS_result_+3A_...">...</code></td>
<td>
<p>Other ggplot2 plotting parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subplots to be included in the final illustration are controlled by the
<code>mode</code> option: - <code>"obj"</code> adds the evolution of the objective
function over the iterations - <code>"cost"</code> adds the evolution of the cost
function over the iterations (if available in <code>x</code>) - <code>"hist"</code> adds
the comparison of the distributions of each variables in both the original
object and the sampled result using histogram plots (for continuous
variables). - <code>"dens"</code> adds the comparison of the distributions of each
variables in both the original object and the sampled result using density
plots (for continuous variables). - <code>"box"</code> adds the comparison of the
distributions of each variables in both the original object and the sampled
result using boxplots (for continuous variables).
</p>


<h3>Author(s)</h3>

<p>Pierre Roudier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clhs">clhs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  a = runif(1000), 
  b = rnorm(1000), 
  c = sample(LETTERS[1:5], size = 1000, replace = TRUE)
)

res &lt;- clhs(df, size = 50, iter = 1000, use.cpp = FALSE, progress = FALSE, simple = FALSE)

# You can plot only the objective function
plot(res, mode = "obj")

# Or you can compare the distribution in the original object 
# and in the sampled result
plot(res, mode = c("obj", "box"))

	
</code></pre>

<hr>
<h2 id='similarity_buffer'>Gower similarity analysis</h2><span id='topic+similarity_buffer'></span>

<h3>Description</h3>

<p>Calculates Gower's similarity index for every pixel within an given radius buffer of each sampling point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity_buffer(
  covs,
  pts,
  buffer,
  fac = NA,
  metric = "gower",
  stand = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_buffer_+3A_covs">covs</code></td>
<td>
<p>raster stack of environmental covariates</p>
</td></tr>
<tr><td><code id="similarity_buffer_+3A_pts">pts</code></td>
<td>
<p>sampling points, object of class SpatialPointsDataframe</p>
</td></tr>
<tr><td><code id="similarity_buffer_+3A_buffer">buffer</code></td>
<td>
<p>Radius of the disk around each point that similarity will be calculated</p>
</td></tr>
<tr><td><code id="similarity_buffer_+3A_fac">fac</code></td>
<td>
<p>numeric, can be &gt; 1, (e.g., fac = c(2,3)). Raster layer(s) which are categorical variables. Set to NA if no factor is present</p>
</td></tr>
<tr><td><code id="similarity_buffer_+3A_metric">metric</code></td>
<td>
<p>character string specifying the similarity metric to be used. The currently available options are &quot;euclidean&quot;, &quot;manhattan&quot; and &quot;gower&quot; (the default).  See <code>daisy</code> from the <code>cluster</code> package for more details</p>
</td></tr>
<tr><td><code id="similarity_buffer_+3A_stand">stand</code></td>
<td>
<p>logical flag: if TRUE, then the measurements in x are standardized before calculating the dissimilarities.</p>
</td></tr>
<tr><td><code id="similarity_buffer_+3A_...">...</code></td>
<td>
<p>passed to plyr::llply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a RasterStack
</p>


<h3>Author(s)</h3>

<p>Colby Brungard
</p>


<h3>References</h3>

<p>Brungard, C. and Johanson, J. 2015. The gate's locked! I can't get to the exact 
sampling spot... can I sample nearby? Pedometron, 37:8&ndash;10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(raster)
library(sp)

data(meuse.grid)
coordinates(meuse.grid) = ~x+y
proj4string(meuse.grid) &lt;- CRS("+init=epsg:28992")
gridded(meuse.grid) = TRUE
ms &lt;- stack(meuse.grid)

suppressWarnings(RNGversion("3.5.0"))
set.seed(1)
pts &lt;- clhs(ms, size = 3, iter = 100, progress = FALSE, simple = FALSE)
gw &lt;- similarity_buffer(ms, pts$sampled_data, buffer = 500)
plot(gw)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
