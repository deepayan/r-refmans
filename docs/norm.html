<!DOCTYPE html><html><head><title>Help for package norm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {norm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.code.to.na'>
<p>Changes missing value code to NA</p></a></li>
<li><a href='#.na.to.snglcode'>
<p>Changes NA's to single precision missing value code</p></a></li>
<li><a href='#da.norm'>
<p>Data augmentation for incomplete multivariate normal data</p></a></li>
<li><a href='#em.norm'>
<p>EM algorithm for incomplete normal data</p></a></li>
<li><a href='#getparam.norm'>
<p>Extract normal parameters from packed storage</p></a></li>
<li><a href='#imp.norm'>
<p>Impute missing multivariate normal data</p></a></li>
<li><a href='#loglik.norm'>
<p>Observed-data loglikelihood for normal data</p></a></li>
<li><a href='#logpost.norm'>
<p>Observed-data log-posterior for normal data</p></a></li>
<li><a href='#makeparam.norm'>
<p>Convert normal parameters to packed storage</p></a></li>
<li><a href='#mda.norm'>
<p>Monotone data augmentation for incomplete multivariate normal data</p></a></li>
<li><a href='#mdata'>
<p>Dataset with missing values to illustrate use of package norm</p></a></li>
<li><a href='#mi.inference'>
<p>Multiple imputation inference</p></a></li>
<li><a href='#ninvwish'>
<p>Random normal-inverted Wishart variate</p></a></li>
<li><a href='#prelim.norm'>
<p>Preliminary manipulations for a matrix of incomplete</p>
continuous data.</a></li>
<li><a href='#rngseed'>
<p>Initialize random number generator seed</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0-11.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Multivariate Normal Datasets with Missing Values</td>
</tr>
<tr>
<td>Author:</td>
<td>Ported to R by Alvaro A. Novo &lt;alvaro@novo-online.net&gt;.
    Original by Joseph L. Schafer &lt;jls@stat.psu.edu&gt;. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Fox &lt;jfox@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An integrated set of functions for the analysis of 
  multivariate normal datasets with missing values, including implementation of
  the EM algorithm, data augmentation, and multiple imputation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>norm</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>15</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2023-06-18 14:31:55</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-18 23:20:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-18 14:45:10 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='.code.to.na'>
Changes missing value code to NA
</h2><span id='topic+.code.to.na'></span>

<h3>Description</h3>

<p>Changes missing value code to NA. It's called from
<em>'prelim.norm'</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.code.to.na(x, mvcode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".code.to.na_+3A_x">x</code></td>
<td>
<p>data object.
</p>
</td></tr>
<tr><td><code id=".code.to.na_+3A_mvcode">mvcode</code></td>
<td>
<p>internal input of 'prelim.norm'.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Initial data object with missing values code changed to NA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code>
</p>

<hr>
<h2 id='.na.to.snglcode'>
Changes NA's to single precision missing value code
</h2><span id='topic+.na.to.snglcode'></span>

<h3>Description</h3>

<p>Changes NA's to single precision missing value code
It's called internally by other functions in the package, e.g., 
<em>'prelim.norm'</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.na.to.snglcode(x, mvcode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".na.to.snglcode_+3A_x">x</code></td>
<td>
<p>data object.
</p>
</td></tr>
<tr><td><code id=".na.to.snglcode_+3A_mvcode">mvcode</code></td>
<td>
<p>internal input of 'prelim.norm'.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Initial data object with missing values code precision changed to
sinlge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code>
</p>

<hr>
<h2 id='da.norm'>
Data augmentation for incomplete multivariate normal data
</h2><span id='topic+da.norm'></span>

<h3>Description</h3>

<p>Data augmentation under a normal-inverted Wishart prior. If no prior
is specified by the user, the usual &quot;noninformative&quot; prior for the
multivariate normal distribution is used. This function simulates one
or more iterations of a single Markov chain. Each iteration consists
of a random imputation of the missing data given the observed data and
the current parameter value (I-step), followed by a draw from the
posterior distribution of the parameter given the observed data and
the imputed data (P-step).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>da.norm(s, start, prior, steps=1, showits=FALSE, return.ymis=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="da.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix produced by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="da.norm_+3A_start">start</code></td>
<td>

<p>starting value of the parameter.  This is a parameter vector in packed
storage, such as one created by the function <code>makeparam.norm</code>. One
obvious choice for a starting value is an ML estimate or posterior
mode produced by <code>em.norm.</code>
</p>
</td></tr>
<tr><td><code id="da.norm_+3A_prior">prior</code></td>
<td>

<p>optional prior distribution. This is a list containing the
hyperparameters of a normal-inverted Wishart distribution. In order,
the elements of the list are: tau (a scalar), m (a scalar), mu0 (a
vector of length <code>ncol(x)</code>, where <code>x</code> is the original matrix of
incomplete data), and lambdainv (a matrix of dimension
<code>c(ncol(x),ncol(x))</code>). The elements of mu0 and lambdainv apply to the
data after transformation, i.e. after the columns have been centered
and scaled to have mean zero and variance one. If no prior is
supplied, the default is the usual noninformative prior for a
multivariate normal model: tau=0, m=-1, mu0=arbitrary, and lambdainv =
matrix of zeros.
</p>
</td></tr>
<tr><td><code id="da.norm_+3A_steps">steps</code></td>
<td>

<p>number of data augmentation iterations to be simulated.
</p>
</td></tr>
<tr><td><code id="da.norm_+3A_showits">showits</code></td>
<td>

<p>if <code>TRUE</code>, reports the iterations so the user can monitor the progress
of the algorithm.
</p>
</td></tr>
<tr><td><code id="da.norm_+3A_return.ymis">return.ymis</code></td>
<td>

<p>if <code>TRUE</code>, returns the output of the last I-step (imputed values of
missing data) in addition to the output of the last P-step. These
imputed values are useful for forming Rao-Blackwellized estimates of
posterior summaries.
</p>
</td></tr></table>


<h3>Value</h3>

<p>if <code>return.ymis=FALSE</code>, returns a parameter vector, the result of the last
P-step. If the value of <code>steps</code> was large enough to guarantee
approximate stationarity, then this parameter can be regarded as a
proper draw from the observed-data posterior, independent of <code>start</code>.
If <code>return.ymis=TRUE</code>, then this function returns a list of the following
two components:
</p>
<table>
<tr><td><code>parameter</code></td>
<td>

<p>a parameter vector, the result of the last P-step
</p>
</td></tr>
<tr><td><code>ymis</code></td>
<td>

<p>a vector of missing values, the result of the last I-step.  The length
of this vector is <code>sum(is.na(x))</code>, where x is the original data
matrix. The storage order is the same as that of <code>x[is.na(x)]</code>.
</p>
</td></tr></table>


<h3>WARNING</h3>

<p>Before this function may be used, the random number generator seed
must be initialized with <code>rngseed</code> at least once in the current S
session.
</p>


<h3>References</h3>

<p>See Chapter 5 of Schafer (1996).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rngseed">rngseed</a></code>, <code><a href="#topic+em.norm">em.norm</a></code>, <code><a href="#topic+prelim.norm">prelim.norm</a></code>, and <code><a href="#topic+getparam.norm">getparam.norm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s  &lt;-  prelim.norm(mdata)
thetahat &lt;- em.norm(s)   #find the MLE for a starting value
rngseed(1234567)   #set random number generator seed
theta &lt;- da.norm(s,thetahat,steps=20,showits=TRUE)  # take 20 steps
getparam.norm(s,theta) # look at result
</code></pre>

<hr>
<h2 id='em.norm'>
EM algorithm for incomplete normal data
</h2><span id='topic+em.norm'></span>

<h3>Description</h3>

<p>Performs maximum-likelihood estimation on the matrix of incomplete
data using the EM algorithm. Can also be used to find a posterior mode
under a normal-inverted Wishart prior supplied by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>em.norm(s, start, showits=TRUE, maxits=1000, criterion=0.0001, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix produced by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="em.norm_+3A_start">start</code></td>
<td>

<p>optional starting value of the parameter. This is a parameter vector
in packed storage, such as one created by the function
<code>makeparam.norm</code>. If no starting value is supplied, <code>em.norm</code> chooses
its own starting value.
</p>
</td></tr>
<tr><td><code id="em.norm_+3A_showits">showits</code></td>
<td>

<p>if <code>TRUE</code>, reports the iterations of EM so the user can monitor the
progress of the algorithm.
</p>
</td></tr>
<tr><td><code id="em.norm_+3A_maxits">maxits</code></td>
<td>

<p>maximum number of iterations performed. The algorithm will stop if the
parameter still has not converged after this many iterations.
</p>
</td></tr>
<tr><td><code id="em.norm_+3A_criterion">criterion</code></td>
<td>

<p>convergence criterion. The algorithm stops when
the maximum relative difference in all of the estimated means,
variances, or covariances from one iteration to the next
is less than or equal to this value.
</p>
</td></tr>
<tr><td><code id="em.norm_+3A_prior">prior</code></td>
<td>

<p>optional prior distribution. This is a list containing the
hyperparameters of a normal-inverted Wishart distribution. In order,
the elements of the list are: tau (a scalar), m (a scalar), mu0 (a
vector of length ncol(x)), and lambdainv (a matrix of dimension
c(ncol(x),ncol(x))). The elements of mu0 ans lambdainv apply to 
the data after transformation, i.e. after the columns have been
centered and scaled to have mean zero and variance one. If no prior is
supplied, the default is a uniform prior, which results in 
maximum-likelihood estimation.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The default starting value takes all means on the transformed scale to
be equal to zero, and covariance matrix on the transformed scale equal
to the identity. All important computations are carried out in double
precision, using the sweep operator.
</p>


<h3>Value</h3>

<p>a vector representing the maximum-likelihood estimates of the normal
parameters. This vector contains means, variances, and covariances on
the transformed scale in packed storage.  The parameter can be
transformed back to the original scale and put into a more
understandable format by the function <code>getparam.norm</code>.
</p>


<h3>References</h3>

<p>See Section 5.3 of Schafer (1994).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code>, <code><a href="#topic+getparam.norm">getparam.norm</a></code>, and <code><a href="#topic+makeparam.norm">makeparam.norm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
thetahat &lt;- em.norm(s)   #compute mle
getparam.norm(s,thetahat,corr=TRUE)$r #look at estimated correlations
</code></pre>

<hr>
<h2 id='getparam.norm'>
Extract normal parameters from packed storage
</h2><span id='topic+getparam.norm'></span>

<h3>Description</h3>

<p>Takes a parameter vector, such as one produced by em.norm or da.norm,
and returns a list of parameters on the original scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getparam.norm(s, theta, corr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getparam.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix created by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="getparam.norm_+3A_theta">theta</code></td>
<td>

<p>vector of normal parameters expressed on transformed scale in packed
storage, such as one produced by the function <code>em.norm</code>.
</p>
</td></tr>
<tr><td><code id="getparam.norm_+3A_corr">corr</code></td>
<td>

<p>if <code>TRUE</code>, computes means, standard deviations, and a correlation
matrix. If <code>FALSE</code>, computes means and a covariance matrix.
</p>
</td></tr></table>


<h3>Value</h3>

<p>if <code>corr=FALSE</code>, a list containing the components <code>mu</code> and <code>sigma</code>; if
<code>corr=TRUE</code>, a list containing the components <code>mu</code>, <code>sdv</code>, and <code>r</code>.  The
components are:
</p>
<table>
<tr><td><code>mu</code></td>
<td>

<p>vector of means. Elements are in the same order and on the same scale
as the columns of the original data matrix, and with names
corresponding to the column names of the original data matrix.
</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>

<p>matrix of variances and covariances.
</p>
</td></tr>
<tr><td><code>sdv</code></td>
<td>

<p>vector of standard deviations.
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>

<p>matrix of correlations.
</p>
</td></tr></table>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code> and <code><a href="#topic+makeparam.norm">makeparam.norm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
thetahat &lt;- em.norm(s)   #compute MLE
getparam.norm(s,thetahat,corr=TRUE)$r #look at estimated correlations
</code></pre>

<hr>
<h2 id='imp.norm'>
Impute missing multivariate normal data
</h2><span id='topic+imp.norm'></span>

<h3>Description</h3>

<p>Draws missing elements of a data matrix under the multivariate normal
model and a user-supplied parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imp.norm(s, theta, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imp.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix <code>x</code> created by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="imp.norm_+3A_theta">theta</code></td>
<td>

<p>value of the normal parameter under which the missing data are to be
randomly imputed. This is a parameter vector in packed storage, such
as one created by <code>em.norm</code> or <code>da.norm</code>.
</p>
</td></tr>
<tr><td><code id="imp.norm_+3A_x">x</code></td>
<td>

<p>the original data matrix used to create the summary list <code>s</code>. If this
argument is not supplied, then the data matrix returned by this
function may disagree slightly with the observed values in <code>x</code> due to
rounding errors.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This function simply performs one I-step of data augmentation.
</p>


<h3>Value</h3>

<p>a matrix of the same form as <code>x</code>, but with all missing values filled in
with simulated values drawn from their predictive distribution given
the observed data and the specified parameter.
</p>


<h3>WARNING</h3>

<p>Before this function may be used, the random number generator seed
must be initialized with <code>rngseed</code> at least once in the current S
session.
</p>


<h3>References</h3>

<p>See Section 5.4.1 of Schafer (1996).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code>, <code><a href="#topic+makeparam.norm">makeparam.norm</a></code>, and <code><a href="#topic+rngseed">rngseed</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
thetahat &lt;- em.norm(s)   #find the mle
rngseed(1234567)   #set random number generator seed
ximp &lt;- imp.norm(s,thetahat,mdata)  #impute missing data under the MLE
</code></pre>

<hr>
<h2 id='loglik.norm'>
Observed-data loglikelihood for normal data
</h2><span id='topic+loglik.norm'></span>

<h3>Description</h3>

<p>Evaluates the observed-data loglikelihood function at a user-supplied
value of the parameter. This function is useful for monitoring the
progress of EM and data augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.norm(s, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix created by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="loglik.norm_+3A_theta">theta</code></td>
<td>

<p>vector of normal parameters expressed on transformed scale in packed
storage, such as one produced by the function <code>em.norm</code>.
</p>
</td></tr></table>


<h3>Value</h3>

<p>value of the observed-data loglikelihood 
</p>


<h3>References</h3>

<p>See Section 5.3.5 of Schafer (1996)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code> and <code><a href="#topic+logpost.norm">logpost.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
thetahat &lt;- em.norm(s)   #compute MLE
loglik.norm(s,thetahat)  #loglikelihood at the MLE
</code></pre>

<hr>
<h2 id='logpost.norm'>
Observed-data log-posterior for normal data
</h2><span id='topic+logpost.norm'></span>

<h3>Description</h3>

<p>Evaluates the log of the observed-data posterior density at a
user-supplied value of the parameter. Assumes a normal-inverted
Wishart prior. This function is useful for monitoring the progress of
EM and data augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logpost.norm(s, theta, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logpost.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix created by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="logpost.norm_+3A_theta">theta</code></td>
<td>

<p>vector of normal parameters expressed on transformed scale in packed
storage, such as one produced by the function <code>em.norm</code>.
</p>
</td></tr>
<tr><td><code id="logpost.norm_+3A_prior">prior</code></td>
<td>

<p>optional prior distribution. This is a list containing the
hyperparameters of a normal-inverted Wishart distribution. In order,
the elements of the list are: tau (a scalar), m (a scalar), mu0 (a
vector of length <code>ncol(x)</code>, where <code>x</code> is the original matrix of
incomplete data), and lambdainv (a matrix of dimension
<code>c(ncol(x),ncol(x))</code>). The elements of mu0 and lambdainv apply to the
data after transformation, i.e. after the columns have been centered
and scaled to have mean zero and variance one. If no prior is
supplied, the default is the usual noninformative prior for a
multivariate normal model: tau=0, m=-1, mu0=arbitrary, and lambdainv =
matrix of zeros.
</p>
</td></tr></table>


<h3>Value</h3>

<p>value of the observed-data log-posterior density
</p>


<h3>References</h3>

<p>See Section 5.3.5 of Schafer (1996)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code> and <code><a href="#topic+loglik.norm">loglik.norm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
prior &lt;- list(0,.5,rep(0,ncol(mdata)),
   .5*diag(rep(1,ncol(mdata)))) #ridge prior with .5 df
thetahat &lt;- em.norm(s,prior=prior)   #compute posterior mode
logpost.norm(s,thetahat,prior)  #log-posterior at mode
</code></pre>

<hr>
<h2 id='makeparam.norm'>
Convert normal parameters to packed storage
</h2><span id='topic+makeparam.norm'></span>

<h3>Description</h3>

<p>Does the opposite of <code>getparam.norm</code>.
Converts a list of user-specified parameters to a parameter vector
suitable for input to functions such as <code>da.norm</code> and <code>em.norm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeparam.norm(s, thetalist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeparam.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix created
by the function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="makeparam.norm_+3A_thetalist">thetalist</code></td>
<td>

<p>list of normal parameters of the same form as one produced by
<code>getparam.norm</code>. If the list has two components, the first must be the
vector of means and the second must be the covariance matrix,
where means and covariances are expressed on the scale of the original
data. If the list has three components, the first must be the vector
of means, the second must be the vector of standard deviations, and
the third must be the correlation matrix.
</p>
</td></tr></table>


<h3>Value</h3>

<p>normal parameter in packed storage, suitable for use as a starting
value for <code>em.norm</code>, <code>mda.norm</code>, or <code>mdamet.norm</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prelim.norm">prelim.norm</a></code> and <code><a href="#topic+getparam.norm">getparam.norm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
thetahat &lt;- em.norm(s)   #compute mle
thetahat &lt;- getparam.norm(s,thetahat,corr=TRUE)   #extract parameters
thetahat$r   #look at mle correlations
thetahat$r[1,2] &lt;- .5   #tweak a parameter
thetahat &lt;- makeparam.norm(s,thetahat)   #convert to packed storage
thetahat &lt;- em.norm(s,thetahat) #run EM again from new starting value
</code></pre>

<hr>
<h2 id='mda.norm'>
Monotone data augmentation for incomplete multivariate normal data
</h2><span id='topic+mda.norm'></span>

<h3>Description</h3>

<p>Monotone data augmentation under the usual noninformative prior, as
described in Chapter 6 of Schafer (1996).  This function simulates one
or more iterations of a single Markov chain. One iteration consists of
a random imputation of the missing data given the observed data and
the current parameter value (I-step), followed by a draw from the
posterior distribution of the parameter given the observed data and
the imputed data (P-step). The I-step imputes only enough data to
complete a monotone pattern, which typically makes this algorithm
converge more quickly than <code>da.norm</code>, particularly when the observed
data are nearly monotone. The order of the variables in the original
data matrix determines the monotone pattern to be completed. For fast
convergence, it helps to order the variables according to their rates
of missingness, with the most observed (least missing) variable on the
left and the least observed variable on the right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mda.norm(s, theta, steps=1, showits=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mda.norm_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix produced by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="mda.norm_+3A_theta">theta</code></td>
<td>

<p>starting value of the parameter.  This is a parameter vector in packed
storage, such as one created by the function <code>makeparam.norm</code>. One
obvious choice for a starting value is an ML estimate or posterior
mode produced by <code>em.norm.</code>
</p>
</td></tr>
<tr><td><code id="mda.norm_+3A_steps">steps</code></td>
<td>

<p>number of monotone data augmentation iterations to be simulated.
</p>
</td></tr>
<tr><td><code id="mda.norm_+3A_showits">showits</code></td>
<td>

<p>if <code>TRUE</code>, reports the iterations so the user can monitor the progress
of the algorithm.
</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a parameter vector, the result of the last P-step. If the
value of <code>steps</code> was large enough to guarantee approximate
stationarity, then this parameter can be regarded as a proper draw
from the observed-data posterior, independent of <code>start</code>.
</p>


<h3>WARNING</h3>

<p>Before this function may be used, the random number generator seed
must be initialized with <code>rngseed</code> at least once in the current S
session.
</p>


<h3>References</h3>

<p>Chapter 6 of Schafer (1996).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rngseed">rngseed</a></code>, <code><a href="#topic+em.norm">em.norm</a></code>, <code><a href="#topic+prelim.norm">prelim.norm</a></code>, and <code><a href="#topic+getparam.norm">getparam.norm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)
thetahat &lt;- em.norm(s)   #find the MLE for a starting value
rngseed(1234567)   #set random number generator seed
theta &lt;- mda.norm(s,thetahat,steps=20,showits=TRUE)  # take 20 steps
getparam.norm(s,theta) # look at result
</code></pre>

<hr>
<h2 id='mdata'>
Dataset with missing values to illustrate use of package norm
</h2><span id='topic+mdata'></span>

<h3>Description</h3>

<p>Household survey with missing values. See Schafer~(1997).
</p>


<h3>References</h3>

<p>Schafer, J.L.(1997) <em>Analysis of Incomplete Multivariate Data</em>,
Chapman &amp; Hall, London. ISBN: 0412040611
</p>

<hr>
<h2 id='mi.inference'>
Multiple imputation inference
</h2><span id='topic+mi.inference'></span>

<h3>Description</h3>

<p>Combines estimates and standard errors from m complete-data analyses
performed on m imputed datasets to produce a single inference.  Uses
the technique described by Rubin (1987) for multiple
imputation inference for a scalar estimand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi.inference(est, std.err, confidence=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi.inference_+3A_est">est</code></td>
<td>

<p>a list of $m$ (at least 2) vectors representing estimates (e.g.,
vectors of estimated regression coefficients) from complete-data
analyses performed on $m$ imputed datasets.
</p>
</td></tr>
<tr><td><code id="mi.inference_+3A_std.err">std.err</code></td>
<td>

<p>a list of $m$ vectors containing standard errors from the
complete-data analyses corresponding to the estimates in <code>est</code>.
</p>
</td></tr>
<tr><td><code id="mi.inference_+3A_confidence">confidence</code></td>
<td>

<p>desired coverage of interval estimates.
</p>
</td></tr></table>


<h3>Value</h3>

<p>a list with the following components, each of which is a vector of the
same length as the components of <code>est</code> and <code>std.err</code>:
</p>
<table>
<tr><td><code>est</code></td>
<td>

<p>the average of the complete-data estimates.
</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>

<p>standard errors incorporating both the between and the
within-imputation uncertainty (the square root of the &quot;total
variance&quot;).
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>degrees of freedom associated with the t reference distribution used
for interval estimates.
</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>

<p>P-values for the two-tailed hypothesis tests that the estimated
quantities are equal to zero.
</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>

<p>lower limits of the (100*confidence)% interval estimates.
</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>

<p>upper limits of the (100*confidence)% interval estimates.
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>

<p>estimated relative increases in variance due to nonresponse.
</p>
</td></tr>
<tr><td><code>fminf</code></td>
<td>

<p>estimated fractions of missing information.
</p>
</td></tr></table>


<h3>METHOD</h3>

<p>Uses the method described on pp. 76-77 of Rubin (1987) for combining
the complete-data estimates from $m$ imputed datasets
for a scalar estimand. Significance levels and interval estimates are
approximately valid for each one-dimensional estimand, not for all of
them jointly.
</p>


<h3>References</h3>

<p>See Rubin (1987) or Schafer (1996), Chapter 4.
</p>

<hr>
<h2 id='ninvwish'>
Random normal-inverted Wishart variate
</h2><span id='topic+ninvwish'></span>

<h3>Description</h3>

<p>Simulates a value from a normal-inverted Wishart distribution. This
function may be useful for obtaining starting values of the
parameters of a  multivariate normal distribution for multiple
chains of data augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ninvwish(s, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ninvwish_+3A_s">s</code></td>
<td>

<p>summary list of an incomplete normal data matrix produced by the
function <code>prelim.norm</code>.
</p>
</td></tr>
<tr><td><code id="ninvwish_+3A_params">params</code></td>
<td>

<p>list of parameters of a normal-inverted Wishart distribution. In
order, the elements of the list are: tau (a scalar), m (a scalar), mu0
(a vector of length ncol(x)), and lambdainv (a matrix of dimension
c(ncol(x),ncol(x))). When using this function to create starting
values for data augmentation, mu0 and lambdainv should be chosen in
relation to the data matrix after the columns have been centered and
scaled to have mean zero and variance one.
</p>
</td></tr></table>


<h3>Value</h3>

<p>a vector in packed storage representing the simulated normal-inverted
Wishart variate. This vector has the same form as parameter vectors
produced by functions such as <code>em.norm</code> and <code>da.norm</code>, and may be
used directly as a starting value for these functions. This vector can
also be put into a more understandable format by <code>getparam.norm</code>.
</p>


<h3>WARNING</h3>

<p>Before this function may be used, the random number generator seed
must be initialized with <code>rngseed</code> at least once in the current S
session.
</p>


<h3>References</h3>

<p>See Section 5.4.2 of Schafer (1996).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rngseed">rngseed</a></code>, <code><a href="#topic+getparam.norm">getparam.norm</a></code>, <code><a href="#topic+em.norm">em.norm</a></code> and <code><a href="#topic+da.norm">da.norm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)   #do preliminary manipulations
params &lt;- list(1,.5,rep(0,ncol(mdata)), .5*diag(rep(1,ncol(mdata)))) # gives widely dispersed values
rngseed(1234567)
start &lt;- ninvwish(s,params)  # draw a variate
thetahat &lt;- em.norm(s,start=start) # run EM from this starting value
</code></pre>

<hr>
<h2 id='prelim.norm'>
Preliminary manipulations for a matrix of incomplete 
continuous data.
</h2><span id='topic+prelim.norm'></span>

<h3>Description</h3>

<p>Sorts rows of x by missingness patterns, and centers/scales
columns of x. Calculates various bookkeeping quantities needed
for input to other functions, such as <code>em.norm</code> and <code>da.norm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prelim.norm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prelim.norm_+3A_x">x</code></td>
<td>

<p>data matrix containing missing values. The rows of x 
correspond to observational units, and the columns to variables. 
Missing values are denoted by <code>NA</code>.
</p>
</td></tr></table>


<h3>Value</h3>

<p>a list of thirteen components that summarize various features of x
after the data have been centered, scaled, and sorted by missingness
patterns. Components that might be of interest to the user include:
</p>
<table>
<tr><td><code>nmis</code></td>
<td>

<p>a vector of length ncol(x) containing the number of missing
values for each variable in x. This vector has names that correspond
to the column names of x, if any.
</p>
</td></tr>
<tr><td><code>r</code></td>
<td>

<p>matrix of response indicators showing the missing data patterns 
in x.  Dimension is (S,p) where S is the number of distinct 
missingness patterns in the rows of x, and p is the number of 
columns in x. Observed values are indicated by 1 and missing 
values by 0. The row names give the number of observations in
each pattern, and the column names correspond to the column names of
x.
</p>
</td></tr></table>


<h3>References</h3>

<p>See Section 5.3.1 of Schafer (1996).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mdata)
s &lt;- prelim.norm(mdata)  #do preliminary manipulations 
s$nmis[s$co] #look at nmis 
s$r #look at missing data patterns
</code></pre>

<hr>
<h2 id='rngseed'>
Initialize random number generator seed
</h2><span id='topic+rngseed'></span>

<h3>Description</h3>

<p>Initializes the seed value for the internal random-number generator
used in missing-data programs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rngseed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rngseed_+3A_seed">seed</code></td>
<td>

<p>a positive number &gt; = 1, preferably a large integer.
</p>
</td></tr></table>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>NOTE</h3>

<p>The random number generator seed must be set at least once
by this function before the simulation or imputation functions
in this package (<code>da.norm</code>, etc.) can be used.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
