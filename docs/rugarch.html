<!DOCTYPE html><html><head><title>Help for package rugarch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rugarch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARFIMA-class'><p>class: High Level ARFIMA class</p></a></li>
<li><a href='#arfimacv'>
<p>ARFIMAX time series cross validation</p></a></li>
<li><a href='#ARFIMAdistribution-class'><p>class: ARFIMA Parameter Distribution Class</p></a></li>
<li><a href='#arfimadistribution-methods'><p>function: ARFIMA Parameter Distribution via Simulation</p></a></li>
<li><a href='#ARFIMAfilter-class'><p>class: ARFIMA Filter Class</p></a></li>
<li><a href='#arfimafilter-methods'><p>function: ARFIMA Filtering</p></a></li>
<li><a href='#ARFIMAfit-class'><p>class: ARFIMA Fit Class</p></a></li>
<li><a href='#arfimafit-methods'><p>function: ARFIMA Fit</p></a></li>
<li><a href='#ARFIMAforecast-class'><p>class: ARFIMA Forecast Class</p></a></li>
<li><a href='#arfimaforecast-methods'><p>function: ARFIMA Forecasting</p></a></li>
<li><a href='#ARFIMAmultifilter-class'><p>class: ARFIMA Multiple Filter Class</p></a></li>
<li><a href='#ARFIMAmultifit-class'><p>class: ARFIMA Multiple Fit Class</p></a></li>
<li><a href='#ARFIMAmultiforecast-class'><p>class: ARFIMA Multiple Forecast Class</p></a></li>
<li><a href='#ARFIMAmultispec-class'><p>class: ARFIMA Multiple Specification Class</p></a></li>
<li><a href='#ARFIMApath-class'><p>class: ARFIMA Path Simulation Class</p></a></li>
<li><a href='#arfimapath-methods'><p>function: ARFIMA Path Simulation</p></a></li>
<li><a href='#ARFIMAroll-class'><p>class: ARFIMA Rolling Forecast Class</p></a></li>
<li><a href='#arfimaroll-methods'><p>function: ARFIMA Rolling Density Forecast and Backtesting</p></a></li>
<li><a href='#ARFIMAsim-class'><p>class: ARFIMA Simulation Class</p></a></li>
<li><a href='#arfimasim-methods'><p>function: ARFIMA Simulation</p></a></li>
<li><a href='#ARFIMAspec-class'><p>class: ARFIMA Specification Class</p></a></li>
<li><a href='#arfimaspec-methods'><p>function: ARFIMA Specification</p></a></li>
<li><a href='#autoarfima'>
<p>Automatic Model Selection for ARFIMA models</p></a></li>
<li><a href='#BerkowitzTest'>
<p>Berkowitz Density Forecast Likelihood Ratio Test</p></a></li>
<li><a href='#DACTest'>
<p>Directional Accuracy Test</p></a></li>
<li><a href='#DateTimeUtilities'>
<p>A small set of utilities to work with some time and date classes.</p></a></li>
<li><a href='#dji30ret'><p>data: Dow Jones 30 Constituents Closing Value Log Return</p></a></li>
<li><a href='#dmbp'><p>data: Deutschemark/British pound Exchange Rate</p></a></li>
<li><a href='#ESTest'>
<p>Expected Shortfall Test.</p></a></li>
<li><a href='#GARCHboot-class'><p>class: GARCH Bootstrap Class</p></a></li>
<li><a href='#GARCHdistribution-class'><p>class: GARCH Parameter Distribution Class</p></a></li>
<li><a href='#GARCHfilter-class'><p>class: GARCH Filter Class</p></a></li>
<li><a href='#GARCHfit-class'><p>class: GARCH Fit Class</p></a></li>
<li><a href='#GARCHforecast-class'><p>class: GARCH Forecast Class</p></a></li>
<li><a href='#GARCHpath-class'><p>class: GARCH Path Simulation Class</p></a></li>
<li><a href='#GARCHroll-class'><p>class: GARCH Roll Class</p></a></li>
<li><a href='#GARCHsim-class'><p>class: GARCH Simulation Class</p></a></li>
<li><a href='#GARCHspec-class'><p>class: GARCH Spec Class</p></a></li>
<li><a href='#GARCHtests-class'><p>class: GARCH Tests Class</p></a></li>
<li><a href='#ghyptransform'><p>Distribution: Generalized Hyperbolic Transformation and Scaling</p></a></li>
<li><a href='#GMMTest'>
<p>The GMM Orthogonality Test of Hansen</p></a></li>
<li><a href='#HLTest'>
<p>The Non-Parametric Density Test of Hong and Li</p></a></li>
<li><a href='#mcsTest'>
<p>Model Confidence Set Test</p></a></li>
<li><a href='#multifilter-methods'><p>function: Univariate GARCH and ARFIMA Multiple Filtering</p></a></li>
<li><a href='#multifit-methods'><p>function: Univariate GARCH and ARFIMA Multiple Fitting</p></a></li>
<li><a href='#multiforecast-methods'><p>function: Univariate GARCH and ARFIMA Multiple Forecasting</p></a></li>
<li><a href='#multispec-methods'><p>function: Univariate multiple GARCH Specification</p></a></li>
<li><a href='#qnig'>
<p>Functions exported for use in rmgarch</p></a></li>
<li><a href='#rGARCH-class'><p>class: rGARCH Class</p></a></li>
<li><a href='#rgarchdist'><p>Distribution: rugarch distribution functions</p></a></li>
<li><a href='#rugarch-package'><p>The rugarch package</p></a></li>
<li><a href='#sp500ret'><p>data: Standard and Poors 500 Closing Value Log Return</p></a></li>
<li><a href='#spyreal'><p>data: SPDR Standard and Poors 500 Open-Close Daily Return and Realized Kernel Volatility</p></a></li>
<li><a href='#ugarchbench'>
<p>Benchmark: The Benchmark Test Suite</p></a></li>
<li><a href='#uGARCHboot-class'><p>class: Univariate GARCH Bootstrap Class</p></a></li>
<li><a href='#ugarchboot-methods'><p>function: Univariate GARCH Forecast via Bootstrap</p></a></li>
<li><a href='#uGARCHdistribution-class'><p>class: Univariate GARCH Parameter Distribution Class</p></a></li>
<li><a href='#ugarchdistribution-methods'><p>function: Univariate GARCH Parameter Distribution via Simulation</p></a></li>
<li><a href='#uGARCHfilter-class'><p>class: Univariate GARCH Filter Class</p></a></li>
<li><a href='#ugarchfilter-methods'><p>function: Univariate GARCH Filtering</p></a></li>
<li><a href='#uGARCHfit-class'><p>class: Univariate GARCH Fit Class</p></a></li>
<li><a href='#ugarchfit-methods'><p>function: Univariate GARCH Fitting</p></a></li>
<li><a href='#uGARCHforecast-class'><p>class: Univariate GARCH Forecast Class</p></a></li>
<li><a href='#ugarchforecast-methods'><p>function: Univariate GARCH Forecasting</p></a></li>
<li><a href='#uGARCHmultifilter-class'><p>class: Univariate GARCH Multiple Filter Class</p></a></li>
<li><a href='#uGARCHmultifit-class'><p>class: Univariate GARCH Multiple Fit Class</p></a></li>
<li><a href='#uGARCHmultiforecast-class'><p>class: Univariate GARCH Multiple Forecast Class</p></a></li>
<li><a href='#uGARCHmultispec-class'><p>class: Univariate GARCH Multiple Specification Class</p></a></li>
<li><a href='#uGARCHpath-class'><p>class: Univariate GARCH Path Simulation Class</p></a></li>
<li><a href='#ugarchpath-methods'><p>function: Univariate GARCH Path Simulation</p></a></li>
<li><a href='#uGARCHroll-class'><p>class: Univariate GARCH Rolling Forecast Class</p></a></li>
<li><a href='#ugarchroll-methods'><p>function: Univariate GARCH Rolling Density Forecast and Backtesting</p></a></li>
<li><a href='#uGARCHsim-class'><p>class: Univariate GARCH Simulation Class</p></a></li>
<li><a href='#ugarchsim-methods'><p>function: Univariate GARCH Simulation</p></a></li>
<li><a href='#uGARCHspec-class'><p>class: Univariate GARCH Specification Class</p></a></li>
<li><a href='#ugarchspec-methods'><p>function: Univariate GARCH Specification</p></a></li>
<li><a href='#VaRDurTest'>
<p>VaR Duration Test</p></a></li>
<li><a href='#VaRloss'>
<p>Value at Risk loss function of Gonzalez-Rivera, Lee, and Mishra (2004)</p></a></li>
<li><a href='#VaRplot'>
<p>Value at Risk Exceedances plot</p></a></li>
<li><a href='#VaRTest'>
<p>Value at Risk Exceedances Test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Univariate GARCH Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexios Galanos &lt;alexios@4dscape.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods, parallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.10.6), RcppArmadillo (&ge; 0.2.34)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsolnp, ks, numDeriv, spd, xts, zoo, chron, SkewHyperbolic,
Rcpp,graphics, stats, grDevices, utils, nloptr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>ARFIMA, in-mean, external regressors and various GARCH flavors, with methods for fit, forecast, simulation, inference and plotting.</td>
</tr>
<tr>
<td>Collate:</td>
<td>rugarch-imports.R rugarch-cwrappers.R rugarch-solvers.R
rugarch-lossfn.R rugarch-distributions.R rugarch-kappa.R
rugarch-helperfn.R rugarch-numderiv.R rugarch-series.R
rugarch-startpars.R rugarch-tests.R rugarch-armafor.R
rugarch-graphs.R rugarch-classes.R rugarch-sgarch.R
rugarch-figarch.R rugarch-csgarch.R rugarch-fgarch.R
rugarch-egarch.R rugarch-gjrgarch.R rugarch-aparch.R
rugarch-igarch.R rugarch-mcsgarch.R rugarch-realgarch.R
rugarch-multi.R rugarch-plots.R rugarch-rolling.R
rugarch-uncertainty.R rugarch-bootstrap.R rugarch-methods.R
rugarch-benchmarks.R arfima-classes.R arfima-multi.R
arfima-main.R arfima-methods.R rugarch-cv.R zzz.R</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.unstarched.net">http://www.unstarched.net</a>, <a href="https://github.com/alexiosg/rugarch">https://github.com/alexiosg/rugarch</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-19 20:08:57 UTC; alexios</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexios Galanos [aut, cre],
  Tobias Kley [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 02:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARFIMA-class'>class: High Level ARFIMA class</h2><span id='topic+ARFIMA-class'></span>

<h3>Description</h3>

<p>The virtual parent class of the ARFIMA subset.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;ARFIMA&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Alexios Ghalanos </p>

<hr>
<h2 id='arfimacv'>
ARFIMAX time series cross validation
</h2><span id='topic+arfimacv'></span>

<h3>Description</h3>

<p>Implements a cross validation method for ARFIMAX models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimacv(data, indexin, indexout, ar.max = 2, ma.max = 2, 
criterion = c("rmse","mae","berkowitzp"),berkowitz.significance = 0.05, 
arfima = FALSE, include.mean = NULL, distribution.model = "norm",
cluster = NULL, external.regressors = NULL, solver = "solnp", 
solver.control=list(), fit.control=list(), return.best=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimacv_+3A_data">data</code></td>
<td>

<p>A univariate xts vector.
</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_indexin">indexin</code></td>
<td>

<p>A list of the training set indices
</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_indexout">indexout</code></td>
<td>

<p>A list of the testing set indices, the same list length as that of indexin. This should be a numeric index
of points immediately after those in the equivalent indexin slot and contiguous (for time series cross validation).
</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_ar.max">ar.max</code></td>
<td>

<p>Maximum AR order to test for.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_ma.max">ma.max</code></td>
<td>

<p>Maximum MA order to test for.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_criterion">criterion</code></td>
<td>

<p>The cv criterion on which the forecasts will be tested against the realized values. Currently &ldquo;rmse&rdquo;,
&ldquo;mae&rdquo; and experimentally &ldquo;berkowitzp&rdquo; are implemented. The latter is the Berkowitz test p-value
(maximized) and should not be used if your indexout set is very small.
</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_berkowitz.significance">berkowitz.significance</code></td>
<td>

<p>The significance level at which the Berkowitz test is evaluated at (this has no value at the moment since
we are only looking at the p-values, but may be used in futures to instead aggregate across pass-fail).
</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_arfima">arfima</code></td>
<td>

<p>Can be TRUE, FALSE or NULL in which case it is tested.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_include.mean">include.mean</code></td>
<td>

<p>Can be TRUE, FALSE or NULL in which case it is tested.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation.
</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_external.regressors">external.regressors</code></td>
<td>
<p>An xts matrix object containing the pre-lagged external regressors to 
include in the mean equation with the same indices as those of the data supplied.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_distribution.model">distribution.model</code></td>
<td>

<p>The distribution density to use for the innovations (defaults to Normal).</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_solver">solver</code></td>
<td>
<p>One of either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo;, &ldquo;gosolnp&rdquo;
or &ldquo;nloptr&rdquo;.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine.</p>
</td></tr>
<tr><td><code id="arfimacv_+3A_return.best">return.best</code></td>
<td>

<p>On completion of the cross-validation, should the best model be re-estimated on the complete dataset
and returned (defaults to TRUE).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates all possible combinations of the ARFIMAX model for all the training and testing
sets supplied. For the ARMA orders, the orders are evaluated fully (e.g. for ar.max=2, all possible combinations
are evaluated including AR(0,0), AR(0,1), AR(0,2), AR(1,0), AR(2,0) AR(1,2), AR(2,1), and AR(2,2)). For each training
set in indexin, all model combinations are evaluated and the 1-ahead rolling forecast for the indexout testing set 
is produced and compared to the realized values under the 3 criteria listed. Once all training/testing is done on all
model combinations, the criteria are averaged across all the sets for each combination and the results returned.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>bestmodel</code></td>
<td>
<p> The best model based on the criterion chosen is re-estimated on the complete data set and returned.</p>
</td></tr>
<tr><td><code>cv_matrix</code></td>
<td>
<p> The model combinations and their average criteria statistics across the training/testing sets.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Use a cluster...this is an expensive computation, particularly for large ar.max and ma.max orders. The indexin and indexout
lists are left to the user to decide how to implement.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(xts)
require(parallel)
data(sp500ret)
spx = as.xts(sp500ret)
nn = nrow(spx)
nx = nn-round(0.9*nn,0)
if(nx
h = (nx/50)-1
indexin = lapply(1:h, function(j){ tail(seq(1,(nn-nx)+j*50, by=1),250) })
indexout = lapply(indexin, function(x){ (tail(x,1)+1):(tail(x,1)+50) })
cl = makePSOCKcluster(5)
mod = arfimacv(spx, indexin, indexout, ar.max = 2, ma.max = 2, 
criterion = c("rmse","mae","berkowitzp")[1],
berkowitz.significance = 0.05, arfima = FALSE, include.mean = NULL, 
distribution.model = "norm", cluster = cl, external.regressors = NULL, 
solver = "solnp")
stopCluster(cl)

## End(Not run)
</code></pre>

<hr>
<h2 id='ARFIMAdistribution-class'>class: ARFIMA Parameter Distribution Class</h2><span id='topic+ARFIMAdistribution-class'></span><span id='topic+as.data.frame+2CARFIMAdistribution-method'></span><span id='topic+show+2CARFIMAdistribution-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA Parameter Distribution, objects of which are created by 
calling function <code><a href="#topic+arfimadistribution">arfimadistribution</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dist</code>:</dt><dd><p>Object of class <code>"vector"</code> Details of fitted 
parameters.</p>
</dd>
<dt><code>truecoef</code>:</dt><dd><p>Object of class <code>"matrix"</code> The actual 
coefficients.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"list"</code> The model specification.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "ARFIMAdistribution")</code>: extracts 
various values from object (see note). </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAdistribution")</code>: parameter 
distribution summary. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>as.data.frame</code> function takes optionally 2 additional arguments, 
namely <code>window</code> which indicates the particular distribution window number 
for which data is required (is usually just 1 unless the recursive option was 
used), and <code>which</code> indicating the type of data required. Valid values for 
the latter are &ldquo;rmse&rdquo; for the root mean squared error between simulation 
fit and actual parameters, &ldquo;stats&rdquo; for various statistics computed for 
the simulations such as log likelihood, persistence, unconditional variance and 
mean, &ldquo;coef&rdquo; for the estimated coefficients (i.e. the parameter 
distribution and is the default choice), and &ldquo;coefse&rdquo; for the estimated 
robust standard errors of the coefficients (i.e. the parameter standard error 
distribution).</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='arfimadistribution-methods'>function: ARFIMA Parameter Distribution via Simulation</h2><span id='topic+arfimadistribution-methods'></span><span id='topic+arfimadistribution+2CANY-method'></span><span id='topic+arfimadistribution+2CARFIMAfit-method'></span><span id='topic+arfimadistribution+2CARFIMAspec-method'></span><span id='topic+arfimadistribution'></span>

<h3>Description</h3>

<p>Method for simulating and estimating the parameter distribution from an ARFIMA 
models as well as the simulation based consistency of the estimators given the 
data size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimadistribution(fitORspec, n.sim = 2000, n.start = 1, m.sim = 100, 
recursive = FALSE, recursive.length = 6000, recursive.window = 1000, 
prereturns = NA, preresiduals = NA, rseed = NA, 
custom.dist = list(name = NA,  distfit = NA, type = "z"), mexsimdata = NULL, 
fit.control = list(), solver = "solnp", solver.control = list(), 
cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimadistribution-methods_+3A_fitorspec">fitORspec</code></td>
<td>
<p> Either an ARFIMA fit object of class 
<code><a href="#topic+ARFIMAfit-class">ARFIMAfit</a></code> or alternatively an ARFIMA specification object 
of class <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code> with valid parameters supplied via the 
<code>fixed.pars</code> argument in the specification.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_n.sim">n.sim</code></td>
<td>
<p> The simulation horizon.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_n.start">n.start</code></td>
<td>
<p> The burn-in sample.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_m.sim">m.sim</code></td>
<td>
<p> The number of simulations.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_recursive">recursive</code></td>
<td>
<p> Whether to perform a recursive simulation on an expanding 
window.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_recursive.length">recursive.length</code></td>
<td>
<p> If <code>recursive</code> is TRUE, this indicates the final 
length of the simulation horizon, with starting length <code>n.sim</code>.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_recursive.window">recursive.window</code></td>
<td>
<p> If <code>recursive</code> is TRUE, this indicates the 
increment to the expanding window. Together with <code>recursive.length</code>, it 
determines the total number of separate and increasing length windows which will 
be simulated and fitted.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_prereturns">prereturns</code></td>
<td>
<p> Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_preresiduals">preresiduals</code></td>
<td>
<p> Allows the starting residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_rseed">rseed</code></td>
<td>
<p> Optional seeding value(s) for the random number generator.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_custom.dist">custom.dist</code></td>
<td>
<p> Optional density with fitted object from which to simulate.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>
<p> Matrix of simulated external regressor-in-mean data. If the 
fit object contains external regressors in the mean equation, this must be 
provided.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_solver">solver</code></td>
<td>
<p>One of either &ldquo;nlminb&rdquo; or &ldquo;solnp&rdquo;. </p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine (as in the 
<code>arfimafit</code> method).</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation.
</p>
</td></tr>
<tr><td><code id="arfimadistribution-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method facilitates the simulation and evaluation of the uncertainty of 
ARFIMA model parameters. The recursive option also allows the evaluation of the 
simulation based consistency (in terms of sqrt(N) ) of the parameters as the 
length (n.sim) of the data increases, in the sense of the root mean square error 
(rmse) of the difference  between the simulated and true (hypothesized) 
parameters.<br />
This is an expensive function, particularly if using the <code>recursive</code> 
option, both on memory and CPU resources, performing many re-fits of the 
simulated data in order to generate the parameter distribution.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMAdistribution-class">ARFIMAdistribution</a></code> object containing details of the 
ARFIMA simulated parameters distribution.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAfilter-class'>class: ARFIMA Filter Class</h2><span id='topic+ARFIMAfilter-class'></span><span id='topic+coef+2CARFIMAfilter-method'></span><span id='topic+fitted+2CARFIMAfilter-method'></span><span id='topic+infocriteria+2CARFIMAfilter-method'></span><span id='topic+likelihood+2CARFIMAfilter-method'></span><span id='topic+residuals+2CARFIMAfilter-method'></span><span id='topic+show+2CARFIMAfilter-method'></span><span id='topic+uncmean+2CARFIMAfilter-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA filter.</p>


<h3>Slots</h3>


<dl>
<dt><code>filter</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code>  </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Extracts the coefficients.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Extracts the filtered values.</p>
</dd>
<dt>infocriteria</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Calculates and returns various information criteria.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Extracts the likelihood. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Filter summary.</p>
</dd>
<dt>uncmean</dt><dd><p><code>signature(object = "ARFIMAfilter")</code>: 
Calculates and returns the unconditional mean. Takes additional arguments 
&lsquo;method&rsquo; with option for &ldquo;analytical&rdquo; or &ldquo;simulation&rdquo;, 
&lsquo;n.sim&rsquo; for the number of simulations (if that method was chosen, and 
defaults to 100000) and &lsquo;rseed&rsquo; for the simulation random generator 
initialization seed. Note that the simulation method is only available for 
a fitted object or specification with fixed parameters, and not for the 
filtered object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ARFIMAfilter")
</code></pre>

<hr>
<h2 id='arfimafilter-methods'>function: ARFIMA Filtering</h2><span id='topic+arfimafilter-methods'></span><span id='topic+arfimafilter+2CANY-method'></span><span id='topic+arfimafilter+2CARFIMAspec-method'></span><span id='topic+arfimafilter'></span>

<h3>Description</h3>

<p>Method for filtering an ARFIMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimafilter(spec, data, out.sample = 0, n.old=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimafilter-methods_+3A_data">data</code></td>
<td>
<p> A univariate data object. Can be a numeric vector, matrix, 
data.frame, zoo, xts, timeSeries, ts or irts object.</p>
</td></tr>
<tr><td><code id="arfimafilter-methods_+3A_spec">spec</code></td>
<td>
<p> An ARFIMA spec object of class <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code> 
with the fixed.pars argument having the model parameters on which the filtering 
is to take place.</p>
</td></tr>
<tr><td><code id="arfimafilter-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods before 
the last to keep for out of sample forecasting (as in <code><a href="#topic+arfimafit">arfimafit</a></code> 
function).</p>
</td></tr>
<tr><td><code id="arfimafilter-methods_+3A_n.old">n.old</code></td>
<td>
<p> For comparison with ARFIMA models using the out.sample argument,
this is the length of the original dataset (see details).</p>
</td></tr>
<tr><td><code id="arfimafilter-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The n.old argument is optional and indicates the length of the original data
(in cases when this represents a dataseries augmented by newer data). The reason
for using this is so that the old and new datasets agree since the original 
recursion uses the sum of the residuals to start the recursion and therefore is 
influenced by new data. For a small augmentation the values converge after x 
periods, but it is sometimes preferable to have this option so that there is no 
forward looking information contaminating the study.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMAfilter-class">ARFIMAfilter</a></code> object containing details of the ARFIMA 
filter.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAfit-class'>class: ARFIMA Fit Class</h2><span id='topic+ARFIMAfit-class'></span><span id='topic+coef+2CARFIMAfit-method'></span><span id='topic+fitted+2CARFIMAfit-method'></span><span id='topic+getspec+2CARFIMAfit-method'></span><span id='topic+infocriteria+2CARFIMAfit-method'></span><span id='topic+likelihood+2CARFIMAfit-method'></span><span id='topic+residuals+2CARFIMAfit-method'></span><span id='topic+getspec+2CARFIMAfit-method'></span><span id='topic+reduce+2CARFIMAfit-method'></span><span id='topic+show+2CARFIMAfit-method'></span><span id='topic+uncmean+2CARFIMAfit-method'></span><span id='topic+convergence+2CARFIMAfit-method'></span><span id='topic+vcov+2CARFIMAfit-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA fit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Extracts the coefficients.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Extracts the fitted values.</p>
</dd>
<dt>infocriteria</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Calculates and returns various information criteria.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Extracts the likelihood.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Fit summary.</p>
</dd>
<dt>uncmean</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Calculates and returns the unconditional mean. Takes additional arguments 
&lsquo;method&rsquo; with option for &ldquo;analytical&rdquo; or &ldquo;simulation&rdquo;, 
&lsquo;n.sim&rsquo; for the number of simulations (if that method was chosen, 
and defaults to 100000) and &lsquo;rseed&rsquo; for the simulation random 
generator initialization seed.</p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Extracts the covariance matrix of the parameters. Additional logical option of 
&lsquo;robust&rsquo; indicates whether to extract the robust based covariance matrix. </p>
</dd>
<dt>convergence</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Returns the solver convergence code for the fitted object (zero denotes
convergence). </p>
</dd>
<dt>reduce</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Zeros parameters (fixing to zero in rugarch is equivalent to eliminating them 
in estimation) with p-values (optional argument &ldquo;pvalue&rdquo;) greater 
than 0.1 (default), and re-estimates the model. Additional arguments are passed
to <code><a href="#topic+arfimafit">arfimafit</a></code>.An additional option &ldquo;use.robust&rdquo; (default TRUE) 
asks whether to use the robust calculated p-values.</p>
</dd>
<dt>getspec</dt><dd><p><code>signature(object = "ARFIMAfit")</code>: 
Extracts and returns the ARFIMA specification from a fitted object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("ARFIMAfit")
</code></pre>

<hr>
<h2 id='arfimafit-methods'>function: ARFIMA Fit</h2><span id='topic+arfimafit-methods'></span><span id='topic+arfimafit+2CANY-method'></span><span id='topic+arfimafit+2CARFIMAspec-method'></span><span id='topic+arfimafit'></span>

<h3>Description</h3>

<p>Method for fitting an ARFIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimafit(spec, data, out.sample = 0, solver = "solnp", solver.control = list(), 
fit.control = list(fixed.se = 0, scale = 0), numderiv.control = list(grad.eps=1e-4, 
grad.d=0.0001, grad.zero.tol=sqrt(.Machine$double.eps/7e-7), hess.eps=1e-4, hess.d=0.1, 
hess.zero.tol=sqrt(.Machine$double.eps/7e-7), r=4, v=2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimafit-methods_+3A_data">data</code></td>
<td>
<p> A univariate data object. Can be a numeric vector, matrix, 
data.frame, zoo, xts, timeSeries, ts or irts object.</p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_spec">spec</code></td>
<td>
<p> An ARFIMA spec object of class <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code>.</p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> A positive integer indicating the number of periods before 
the last to keep for out of sample forecasting (see details).</p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_solver">solver</code></td>
<td>
<p>One of either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo;, &ldquo;gosolnp&rdquo;
or &ldquo;nloptr&rdquo;.</p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine. The 
fixed.se argument controls whether standard errors should be calculated for 
those parameters which were fixed (through the fixed.pars argument of the 
<code><a href="#topic+arfimaspec">arfimaspec</a> function). The scale parameter controls whether the
data should be scaled before being submitted to the optimizer.</code></p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_numderiv.control">numderiv.control</code></td>
<td>
<p>Control arguments passed to the numerical routines for the
calculation of the standard errors. See the documentation in the numDeriv package
for further details. The arguments which start with &lsquo;hess&rsquo; are passed to
the hessian routine while those with &lsquo;grad&rsquo; to the jacobian routine.</p>
</td></tr>
<tr><td><code id="arfimafit-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ARFIMA optimization routine first calculates a set of feasible starting 
points which are used to initiate the ARFIMA Maximum Likelihood recursion. The 
main part of the likelihood calculation is performed in C-code for speed.<br />
The out.sample option is provided in order to carry out forecast performance 
testing against actual data. A minimum of 5 data points are required for these 
tests. If the out.sample option is positive, then the routine will fit only 
N - out.sample (where N is the total data length) data points, leaving 
out.sample points for forecasting and testing using the forecast performance 
measures. In the <code><a href="#topic+arfimaforecast">arfimaforecast</a></code> routine the 
n.ahead may also  be greater than the out.sample number resulting in a 
combination of out of sample data points matched against actual data and some 
without, which the forecast performance tests will ignore.<br />
The &ldquo;gosolnp&rdquo; solver allows for the initialization of multiple restarts 
of the solnp solver with randomly generated parameters (see documentation in 
the Rsolnp-package for details of the strategy used). The solver.control list 
then accepts the following additional (to the solnp) arguments: &ldquo;n.restarts&rdquo; 
is the number of solver restarts required (defaults to 1), &ldquo;parallel&rdquo; (logical), 
&ldquo;pkg&rdquo; (either snowfall or multicore) and &ldquo;cores&rdquo; (the number of cores 
or workers to use) for use of parallel functionality, &ldquo;rseed&rdquo; is the seed to initialize 
the random number generator, and &ldquo;n.sim&rdquo; is the number of simulated 
parameter vectors to generate per n.restarts.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMAfit-class">ARFIMAfit</a></code> object containing details of the ARFIMA fit.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAforecast-class'>class: ARFIMA Forecast Class</h2><span id='topic+ARFIMAforecast-class'></span><span id='topic+fitted+2CARFIMAforecast-method'></span><span id='topic+show+2CARFIMAforecast-method'></span><span id='topic+fpm+2CARFIMAforecast-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA forecast.
</p>


<h3>Slots</h3>


<dl>
<dt><code>forecast</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(x = "ARFIMAforecast")</code>: 
The n.ahead by n.roll+1 matrix of conditional mean forecasts. The column 
names are the T[0] dates.</p>
</dd>
<dt>fpm</dt><dd><p><code>signature(object = "ARFIMAforecast")</code>: 
Forecast performance measures.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAforecast")</code>: 
Forecast summary returning the 0-roll frame only.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Since versions 1.01-3, the <code>fitted</code> method has been introduced
which extracts the n.ahead by (n.roll+1) matrix of conditional mean forecasts, 
with column names the T[0] time index. This is unlike the old <code>data.frame</code> 
which returned the T+1 etc dates. This method is the default extractor in 
rugarch package for the conditional mean (whether from an estimated, filtered, 
forecast or simulated object) and the other method, namely <code>as.data.frame</code> 
is now deprecated with the exception of a few classes where it is still used
(<code><a href="#topic+ARFIMAdistribution-class">ARFIMAdistribution</a></code> and <code><a href="#topic+ARFIMAroll-class">ARFIMAroll</a></code>).<br />
The fpm method returns the Mean Squared Error (MSE), Mean Absolute Error (MAE), 
Directional Accuracy (DAC) and number of points used for the calculation (N), of 
forecast versus realized returns, if the extra <code>summary</code> option is set 
to TRUE (default). This is a 4 x (n.roll+1) matrix, with row headings the T[0]
time index, and requires at least 5 points to calculate the summary measures else
will return NA. When n.ahead&gt;1, this method calculates the measures on the 
n.ahead&gt;1 unconditional forecast, but if n.ahead=1 with n.roll&gt;4, it will 
calculate the measures on the rolling forecast instead. Finally, when summary
is set to FALSE, the method will return a list of length n.roll+1 of xts objects
with the loss functions (Squared Error and Absolute Error and Directional Hits).
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='arfimaforecast-methods'>function: ARFIMA Forecasting</h2><span id='topic+arfimaforecast-methods'></span><span id='topic+arfimaforecast+2CANY-method'></span><span id='topic+arfimaforecast+2CARFIMAfit-method'></span><span id='topic+arfimaforecast+2CARFIMAspec-method'></span><span id='topic+arfimaforecast'></span>

<h3>Description</h3>

<p>Method for forecasting from an ARFIMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimaforecast(fitORspec, data = NULL, n.ahead = 10, n.roll = 0, out.sample = 0, 
external.forecasts = list(mregfor = NULL), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimaforecast-methods_+3A_fitorspec">fitORspec</code></td>
<td>
<p> Either an ARFIMA fit object of class 
<code><a href="#topic+ARFIMAfit-class">ARFIMAfit</a></code> or alternatively an ARFIMA specification object 
of class <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code> with valid parameters supplied via the 
<code>fixed.pars</code> argument in the specification.</p>
</td></tr>
<tr><td><code id="arfimaforecast-methods_+3A_data">data</code></td>
<td>
<p> Required if a specification rather than a fit object is supplied.</p>
</td></tr>
<tr><td><code id="arfimaforecast-methods_+3A_n.ahead">n.ahead</code></td>
<td>
<p> The forecast horizon.</p>
</td></tr>
<tr><td><code id="arfimaforecast-methods_+3A_n.roll">n.roll</code></td>
<td>
<p> The no. of rolling forecasts to create beyond the first one (see 
details).</p>
</td></tr>
<tr><td><code id="arfimaforecast-methods_+3A_out.sample">out.sample</code></td>
<td>
<p> Optional. If a specification object is supplied, indicates 
how many data points to keep for out of sample testing.</p>
</td></tr>
<tr><td><code id="arfimaforecast-methods_+3A_external.forecasts">external.forecasts</code></td>
<td>
<p> A list with a matrix of forecasts for the external 
regressors in the mean.</p>
</td></tr>
<tr><td><code id="arfimaforecast-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecast function has two dispatch methods allowing the user to call it with 
either a fitted object (in which case the data argument is ignored), or a 
specification object (in which case the data is required) with the parameters 
entered via the <code>set.fixed&lt;-</code> methods on an <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code> 
object.<br />
One step ahead forecasts are based on the value of the previous data, while 
n-step ahead (n&gt;1) are based on the unconditional mean of the model.<br />
The ability to roll the forecast 1 step at a time is implemented with the 
<code>n.roll</code> argument which controls how many times to roll the n.ahead 
forecast. The default argument of n.roll = 0 denotes no rolling beyond the first 
forecast and returns the standard n.ahead forecast. Critically, since n.roll 
depends on data being available from which to base the rolling forecast, the 
<code><a href="#topic+arfimafit">arfimafit</a></code> function needs to be called with the argument 
<code>out.sample</code> being at least as large as the n.roll argument, or in the case 
of a specification being used instead of a fit object, the <code>out.sample</code>
argument directly in the forecast function.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMAforecast-class">ARFIMAforecast</a></code> object containing details of the ARFIMA 
forecast. See the class for details on the returned object and methods for 
accessing it and performing some tests.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAmultifilter-class'>class: ARFIMA Multiple Filter Class</h2><span id='topic+ARFIMAmultifilter-class'></span><span id='topic+coef+2CARFIMAmultifilter-method'></span><span id='topic+fitted+2CARFIMAmultifilter-method'></span><span id='topic+likelihood+2CARFIMAmultifilter-method'></span><span id='topic+residuals+2CARFIMAmultifilter-method'></span><span id='topic+show+2CARFIMAmultifilter-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA Multiple filter.</p>


<h3>Slots</h3>


<dl>
<dt><code>filter</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>desc</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "ARFIMAmultifilter")</code>:
Extracts the fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "ARFIMAmultifilter")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "ARFIMAmultifilter")</code>:
Extracts the coefficients.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "ARFIMAmultifilter")</code>:
Extracts the likelihood. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAmultifilter")</code>: Filter summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAmultifit-class'>class: ARFIMA Multiple Fit Class</h2><span id='topic+ARFIMAmultifit-class'></span><span id='topic+coef+2CARFIMAmultifit-method'></span><span id='topic+fitted+2CARFIMAmultifit-method'></span><span id='topic+likelihood+2CARFIMAmultifit-method'></span><span id='topic+residuals+2CARFIMAmultifit-method'></span><span id='topic+show+2CARFIMAmultifit-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA Multiple fit.</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>desc</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "ARFIMAmultifit")</code>: 
Extracts the coefficients. </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "ARFIMAmultifit")</code>: 
Extracts the likelihood. </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "ARFIMAmultifit")</code>: 
Extracts the fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "ARFIMAmultifit")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAmultifit")</code>: 
Fit summary.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAmultiforecast-class'>class: ARFIMA Multiple Forecast Class</h2><span id='topic+ARFIMAmultiforecast-class'></span><span id='topic+fitted+2CARFIMAmultiforecast-method'></span><span id='topic+show+2CARFIMAmultiforecast-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA Multiple forecast.</p>


<h3>Slots</h3>


<dl>
<dt><code>forecast</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>desc</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(x = "ARFIMAmultiforecast")</code>: 
Extracts the conditional mean forecast from the object, and returns an
array of the n.ahead by (n.roll+1) by n.assets.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAmultiforecast")</code>: forecast summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAmultispec-class'>class: ARFIMA Multiple Specification Class</h2><span id='topic+ARFIMAmultispec-class'></span><span id='topic+show+2CARFIMAmultispec-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA Multiple specification.</p>


<h3>Slots</h3>


<dl>
<dt><code>spec</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAmultispec")</code>: specification summary.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMApath-class'>class: ARFIMA Path Simulation Class</h2><span id='topic+ARFIMApath-class'></span><span id='topic+fitted+2CARFIMApath-method'></span><span id='topic+show+2CARFIMApath-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA Path simulation.</p>


<h3>Slots</h3>


<dl>
<dt><code>path</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>seed</code>:</dt><dd><p>Object of class <code>"integer"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(x = "ARFIMApath")</code>: 
Extracts the simulated path values as a matrix of dimension n.sim by m.sim.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMApath")</code>: path simulation summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='arfimapath-methods'>function: ARFIMA Path Simulation</h2><span id='topic+arfimapath-methods'></span><span id='topic+arfimapath+2CANY-method'></span><span id='topic+arfimapath+2CARFIMAspec-method'></span><span id='topic+arfimapath'></span>

<h3>Description</h3>

<p>Method for simulating the path of an ARFIMA model. This is a convenience 
function which does not require a fitted object (see note below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimapath(spec, n.sim = 1000, n.start = 0, m.sim = 1, prereturns = NA, 
	preresiduals = NA, rseed = NA, 
	custom.dist=list(name = NA, distfit = NA, type = "z"), mexsimdata=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimapath-methods_+3A_spec">spec</code></td>
<td>
<p> An ARFIMA object of class <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code> with
the required parameters of the model supplied via the fixed.pars list argument.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_n.sim">n.sim</code></td>
<td>
<p> The simulation horizon.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_n.start">n.start</code></td>
<td>
<p> The burn-in sample.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_m.sim">m.sim</code></td>
<td>
<p> The number of simulations.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_prereturns">prereturns</code></td>
<td>
<p> Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_preresiduals">preresiduals</code></td>
<td>
<p> Allows the starting residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_rseed">rseed</code></td>
<td>
<p> Optional seeding value(s) for the random number generator.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_custom.dist">custom.dist</code></td>
<td>
<p> Optional density with fitted object from which to simulate. 
The &ldquo;type&rdquo; argument denotes whether the standardized innovations are 
passed (&ldquo;z&rdquo;) else the innovations (anything other than &ldquo;z&rdquo;).</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>
<p> Matrix of simulated external regressor-in-mean data. If the 
fit object contains external regressors in the mean equation, this must be 
provided.</p>
</td></tr>
<tr><td><code id="arfimapath-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience method to allow path simulation of ARFIMA models without
the need to supply a fit object as in the <code><a href="#topic+arfimasim">arfimasim</a></code> method. 
Instead, an arfima spec object is required with the model parameters supplied 
via the <code>setfixed&lt;-</code> argument to the spec.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMApath-class">ARFIMApath</a></code> object containing details of the ARFIMA path 
simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAroll-class'>class: ARFIMA Rolling Forecast Class</h2><span id='topic+ARFIMAroll-class'></span><span id='topic+as.data.frame+2CARFIMAroll-method'></span><span id='topic+report+2CARFIMAroll-method'></span><span id='topic+fpm+2CARFIMAroll-method'></span><span id='topic+coef+2CARFIMAroll-method'></span><span id='topic+resume+2CARFIMAroll-method'></span><span id='topic+show+2CARFIMAroll-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA rolling forecast.</p>


<h3>Slots</h3>


<dl>
<dt><code>forecast</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "ARFIMAroll")</code>: extracts various 
values from object (see note). </p>
</dd>
<dt>resume</dt><dd><p><code>signature(object = "ARFIMAroll")</code>:
Resumes a rolling backtest which has non-converged windows using 
alternative solver and control parameters.</p>
</dd>
<dt>fpm</dt><dd><p><code>signature(object = "ARFIMAroll")</code>: 
Forecast performance measures.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "ARFIMAroll")</code>: 
Extracts the list of coefficients for each estimated window in the 
rolling backtest.</p>
</dd>
<dt>report</dt><dd><p><code>signature(object = "ARFIMAroll")</code>: roll backtest reports 
(see note).</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAroll")</code>:
Summary.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>as.data.frame</code> extractor method allows the extraction of either the
conditional forecast density or the VaR. It takes additional argument
<code>which</code> with valid values either &ldquo;density&rdquo; or &ldquo;VaR&rdquo;.<br />
The <code>coef</code> method will return a list of the coefficients and their robust 
standard errors (assuming the keep.coef argument was set to TRUE in the 
ugarchroll function), and the ending date of each estimation window.<br />
The <code>report</code> method takes the following additional arguments:<br />
1.<em>type</em> for the report type. Valid values are &ldquo;VaR&rdquo; for the VaR
report based on the unconditional and conditional coverage tests for exceedances 
(discussed below) and &ldquo;fpm&rdquo; for forecast performance measures.<br />
2.<em>VaR.alpha</em> (for the VaR backtest report) is the tail probability and 
defaults to 0.01.<br />
3.<em>conf.level</em> the confidence level upon which the conditional coverage 
hypothesis test will be based on (defaults to 0.95).<br />
Kupiec's unconditional coverage test looks at whether the amount of expected 
versus actual exceedances given the tail probability of VaR actually occur as 
predicted, while the conditional coverage test of Christoffersen is a joint test 
of the unconditional coverage and the independence of the exceedances. Both the 
joint and the separate unconditional test are reported since it is always 
possible that the joint test passes while failing either the independence or 
unconditional coverage test.
The <code>fpm</code> method (separately from report) takes additional logical argument 
<em>summary</em>, which when TRUE will return the mean squared error (MSE), 
mean absolute error (MAE) and directional accuracy of the forecast versus 
realized returns. When FALSE, it will return a data.frame of the time series 
of squared (SE) errors, absolute errors (AE), directional hits (HITS), and a
VaR Loss function described in Gonzalez-Rivera, Lee, and Mishra (2004)
for each coverage level where it was calculated. This can then be compared, with
the VaR loss of competing models using such tests as the model confidence set 
(MCS) of Hansen, Lunde and Nason (2011).
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='arfimaroll-methods'>function: ARFIMA Rolling Density Forecast and Backtesting</h2><span id='topic+arfimaroll-methods'></span><span id='topic+arfimaroll+2CANY-method'></span><span id='topic+arfimaroll+2CARFIMAspec-method'></span><span id='topic+arfimaroll'></span>

<h3>Description</h3>

<p>Method for creating rolling density forecast from ARFIMA models with option
for refitting every n periods with parallel functionality.</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimaroll(spec, data, n.ahead = 1, forecast.length = 500, 
n.start = NULL, refit.every = 25, refit.window = c("recursive", "moving"), 
window.size = NULL, solver = "hybrid", fit.control = list(), 
solver.control = list(), calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.05), 
cluster = NULL, keep.coef = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimaroll-methods_+3A_spec">spec</code></td>
<td>

<p>A univariate ARFIMA specification object.</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_data">data</code></td>
<td>

<p>A univariate dataset, ideally with time based index.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The number of periods to forecast (only n.ahead=1 supported).
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_forecast.length">forecast.length</code></td>
<td>

<p>The length of the total forecast for which out of sample data 
from the dataset will be used for testing.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_n.start">n.start</code></td>
<td>

<p>Instead of forecast.length, this determines the starting point in the dataset
from which to initialize the rolling forecast.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_refit.every">refit.every</code></td>
<td>

<p>Determines every how many periods the model is re-estimated.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_refit.window">refit.window</code></td>
<td>

<p>Whether the refit is done on an expanding window including all the previous data 
or a moving window where all previous data is used for the first estimation 
and then moved by a length equal to refit.every (unless the window.size option 
is used instead).
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_window.size">window.size</code></td>
<td>

<p>If not NULL, determines the size of the moving window in the rolling estimation,
which also determines the first point used.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_solver">solver</code></td>
<td>

<p>The solver to use.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control parameters parameters passed to the fitting function.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control parameters passed to the solver.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_calculate.var">calculate.VaR</code></td>
<td>

<p>Whether to calculate forecast Value at Risk during the estimation.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_var.alpha">VaR.alpha</code></td>
<td>

<p>The Value at Risk tail level to calculate.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation
of the refits (remember to stop the cluster on completion).
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_keep.coef">keep.coef</code></td>
<td>

<p>Whether to return the list of coefficients and their robust standard errors.
</p>
</td></tr>
<tr><td><code id="arfimaroll-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for creating rolling forecasts of the conditional
ARFIMA density, and optionally calculating the Value at Risk at specified levels.
The argument <code>refit.every</code> determines every how many periods the model is
re-estimated. Given a dataset of length N, it is possible to choose either
how many periods from the end to use for out of sample forecasting (using the
forecast.length option), or the starting point for initializing the rolling
forecast (and using all the data after that for the out of sample forecast).
Only rolling 1-ahead forecasts are supported spanning the dataset, which should
be useful for backtesting models. Anything more complicated should be wrapped by 
the user by making use of the underlying functions in the package.
The function has 2 main methods for viewing the data, a standard plot method and
a report methods (see class <code><a href="#topic+ARFIMAroll-class">ARFIMAroll</a></code> for details on 
how to use these methods).
In case of no-convergence in some of all the windows, a new method called 
<code><a href="#topic+resume">resume</a></code> now allows to pass the returned (non-converged) object with
new solver and control parameters to be re-estimated (only the non-converged
windows are re-estimated).
Parallel functionality is now based entirely on the parallel package, and it is
up to the user to pass a cluster object, and then stop it once the routine is
completed.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ARFIMAroll-class">ARFIMAroll</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sp500ret)
spec = arfimaspec(distribution.model = "std")
mod = arfimaroll(spec, data = sp500ret, n.ahead = 1, 
n.start = 1000,  refit.every = 100, refit.window = "moving", 
solver = "hybrid", fit.control = list(),
calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.025, 0.05),
keep.coef = TRUE)
report(sp500.bktest, type="VaR", VaR.alpha = 0.01, conf.level = 0.95) 
report(sp500.bktest, type="fpm")

## End(Not run)</code></pre>

<hr>
<h2 id='ARFIMAsim-class'>class: ARFIMA Simulation Class</h2><span id='topic+ARFIMAsim-class'></span><span id='topic+fitted+2CARFIMAsim-method'></span><span id='topic+show+2CARFIMAsim-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA simulation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>simulation</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>seed</code>:</dt><dd><p>Object of class <code>"integer"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(x = "ARFIMAsim")</code>: extracts the simulated values 
as a matrix of dimension n.sim by m.sim.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAsim")</code>: simulation summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='arfimasim-methods'>function: ARFIMA Simulation</h2><span id='topic+arfimasim-methods'></span><span id='topic+arfimasim+2CANY-method'></span><span id='topic+arfimasim+2CARFIMAfit-method'></span><span id='topic+arfimasim'></span>

<h3>Description</h3>

<p>Method for simulation from ARFIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimasim(fit, n.sim = 1000, n.start = 0, m.sim = 1, startMethod = 
	c("unconditional", "sample"), prereturns = NA, preresiduals = NA, 
	rseed = NA, custom.dist = list(name = NA, distfit = NA, type = "z"), 
	mexsimdata = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimasim-methods_+3A_fit">fit</code></td>
<td>
<p> An ARFIMA fit object of class <code><a href="#topic+ARFIMAfit-class">ARFIMAfit</a></code>.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_n.sim">n.sim</code></td>
<td>
<p> The simulation horizon.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_n.start">n.start</code></td>
<td>
<p> The burn-in sample.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_m.sim">m.sim</code></td>
<td>
<p> The number of simulations.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_startmethod">startMethod</code></td>
<td>
<p> Starting values for the simulation.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_prereturns">prereturns</code></td>
<td>
<p> Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_preresiduals">preresiduals</code></td>
<td>
<p> Allows the starting residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_rseed">rseed</code></td>
<td>
<p> Optional seeding value(s) for the random number generator.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_custom.dist">custom.dist</code></td>
<td>
<p> Optional density with fitted object from which to simulate. 
The &ldquo;type&rdquo; argument denotes whether the standardized innovations are 
passed (&ldquo;z&rdquo;) else the innovations (anything other than &ldquo;z&rdquo;). 
See notes below for details. </p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>
<p> Matrix of simulated external regressor-in-mean data. If the 
fit object contains external regressors in the mean equation, this can be 
provided else will be ignored.</p>
</td></tr>
<tr><td><code id="arfimasim-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The custom.dist option allows for defining a custom density which exists in the
users workspace with methods for &ldquo;r&rdquo; (sampling, e.g. rnorm) and &ldquo;d&rdquo; 
(density e.g. dnorm). It must take a single fit object as its second argument.
Alternatively, custom.dist can take any name in the name slot (e.g.&ldquo;sample&rdquo;) 
and a matrix in the fit slot with dimensions equal to m.sim (columns) and 
n.sim (rows).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMAsim-class">ARFIMAsim</a></code> object containing details of the ARFIMA 
simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ARFIMAspec-class'>class: ARFIMA Specification Class</h2><span id='topic+ARFIMAspec-class'></span><span id='topic+show+2CARFIMAspec-method'></span><span id='topic+setfixed+3C-+2CARFIMAspec+2Cvector-method'></span><span id='topic+setstart+3C-+2CARFIMAspec+2Cvector-method'></span><span id='topic+setbounds+3C-+2CARFIMAspec+2Cvector-method'></span><span id='topic+uncmean+2CARFIMAspec-method'></span>

<h3>Description</h3>

<p>Class for the ARFIMA specification.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ARFIMA-class">ARFIMA</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;ARFIMA&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "ARFIMAspec")</code>: 
Specification summary.</p>
</dd>
<dt>setfixed&lt;-</dt><dd><p><code>signature(object = "ARFIMAspec", 
    value = "vector")</code>: 
Sets the fixed parameters (which must be supplied as a named list). </p>
</dd>
<dt>setstart&lt;-</dt><dd><p><code>signature(object = "ARFIMAspec", 
    value = "vector")</code>: 
Sets the starting parameters (which must be supplied as a named list). </p>
</dd>
<dt>setbounds&lt;-</dt><dd><p><code>signature(object = "ARFIMAspec", value = "vector")</code>: 
Sets the parameters lower and upper bounds, which must be supplied as a named 
list with each parameter being a numeric vector of length 2 i.e. 
&quot;ar1&quot;=c(-1,1)). If the vector is of length 1, then this is assumed to be 
the lower bound, and the upper bound will be set to its default value prior
to estimation.</p>
</dd>
<dt>uncmean</dt><dd><p><code>signature(object = "ARFIMAspec")</code>: 
Returns the unconditional mean of a specification which has been assigned 
fixed parameters.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='arfimaspec-methods'>function: ARFIMA Specification</h2><span id='topic+arfimaspec-methods'></span><span id='topic+arfimaspec+2CANY-method'></span><span id='topic+arfimaspec'></span>

<h3>Description</h3>

<p>Method for creating an ARFIMA specification object prior to fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arfimaspec(mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, 
    arfima = FALSE, external.regressors = NULL), distribution.model = "norm", 
    start.pars = list(), fixed.pars = list(), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arfimaspec-methods_+3A_mean.model">mean.model</code></td>
<td>

<p>List containing the mean model specification:<br />
<code>armaOrder</code> The autoregressive (ar) and moving average (ma) orders (if any).<br />
<code>include.mean</code> Whether to include the mean.<br />
<code>arfima</code> Whether to include arfima (0&lt;d&lt;0.5).<br />
<code>external.regressors</code> A matrix object containing the external regressors to 
include in the mean equation with as many rows as will be included in the
data (which is passed in the fit function).
</p>
</td></tr>
<tr><td><code id="arfimaspec-methods_+3A_distribution.model">distribution.model</code></td>
<td>

<p>The distribution density to use for the innovations. Valid choices are 
&ldquo;norm&rdquo; for the normal distibution, &ldquo;snorm&rdquo; for the skew-normal 
distribution, &ldquo;std&rdquo; for the student-t, &ldquo;sstd&rdquo; for the skew-student-t, 
&ldquo;ged&rdquo; for the generalized error distribution, &ldquo;sged&rdquo; for the 
skew-generalized error distribution, &ldquo;nig&rdquo; for the normal inverse 
gaussian distribution, &ldquo;ghyp&rdquo; for the Generalized  Hyperbolic, and &ldquo;jsu&rdquo; 
for Johnson's SU distribution. Note that some of the distributions are taken from the 
fBasics package and implenented locally here for convenience. The &ldquo;jsu&rdquo; distribution 
is the reparametrized version from the &ldquo;gamlss&rdquo; package.</p>
</td></tr>
<tr><td><code id="arfimaspec-methods_+3A_start.pars">start.pars</code></td>
<td>

<p>List of staring parameters for the optimization routine. 
These are not usually required unless the optimization has problems converging.</p>
</td></tr>
<tr><td><code id="arfimaspec-methods_+3A_fixed.pars">fixed.pars</code></td>
<td>

<p>List of parameters which are to be kept fixed during the optimization. It is 
possible that you designate all parameters as fixed so as to quickly recover just 
the results of some previous work or published work. The optional argument
&ldquo;fixed.se&rdquo; in the <code><a href="#topic+arfimafit">arfimafit</a></code> function indicates whether to
calculate standard errors for those parameters fixed during the post optimization
stage.</p>
</td></tr>
<tr><td><code id="arfimaspec-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specification allows for flexibility in ARFIMA modelling.<br />
In order to understand which parameters can be entered in the start.pars and 
fixed.pars optional arguments, the list below exposes the names used for the
parameters:(note that when a parameter is followed by a number, this represents 
the order of the model. Just increment the number for higher orders):<br />
<em><b>Mean Model</b></em>:<br />
</p>

<table>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> constant	</td><td style="text-align: left;"> <code>mu</code></td>
</tr>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> AR term	</td><td style="text-align: left;"> <code>ar1</code></td>
</tr>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> MA term	</td><td style="text-align: left;"> <code>ma1</code></td>
</tr>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> exogenous regressors	</td><td style="text-align: left;"> <code>mxreg1</code></td>
</tr>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> arfima	</td><td style="text-align: left;"> <code>arfima</code></td>
</tr>
<tr>
 <td style="text-align: right;">
       </td>
</tr>

</table>

<p><em><b>Distribution Model</b></em>:<br />
</p>

<table>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> dlambda </td><td style="text-align: left;"> <code>dlambda (for GHYP distribution)</code></td>
</tr>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> skew	</td><td style="text-align: left;"> <code>skew</code></td>
</tr>
<tr>
 <td style="text-align: right;">
         </td><td style="text-align: left;"> shape	</td><td style="text-align: left;"> <code>shape</code></td>
</tr>
<tr>
 <td style="text-align: right;">
       </td>
</tr>

</table>



<h3>Value</h3>

<p>A <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code> object containing details of the ARFIMA specification.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='autoarfima'>
Automatic Model Selection for ARFIMA models
</h2><span id='topic+autoarfima'></span>

<h3>Description</h3>

<p>Select best fitting ARFIMA models based on information criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoarfima(data, ar.max = 2, ma.max = 2, criterion = c("AIC","BIC","SIC","HQIC"),
method = c("partial", "full"), arfima = FALSE, include.mean = NULL, 
distribution.model = "norm", cluster = NULL, external.regressors = NULL, 
solver = "solnp", solver.control=list(), fit.control=list(), return.all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoarfima_+3A_data">data</code></td>
<td>
<p> A univariate data object. Can be a numeric vector, matrix, 
data.frame, zoo, xts, timeSeries, ts or irts object.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_ar.max">ar.max</code></td>
<td>

<p>Maximum AR order to test for.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_ma.max">ma.max</code></td>
<td>

<p>Maximum MA order to test for.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_criterion">criterion</code></td>
<td>

<p>Information Criterion to use for selecting the best model.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_method">method</code></td>
<td>

<p>The partial method tests combinations of consecutive orders of AR and 
MA i.e. 1:2, 1:3 etc, while the full method tests all possible combinations
within the consecutive orders thus enumerating the complete combination space
of the MA and AR orders.
.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_arfima">arfima</code></td>
<td>

<p>Can be TRUE, FALSE or NULL in which case it is tested.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_include.mean">include.mean</code></td>
<td>

<p>Can be TRUE, FALSE or NULL in which case it is tested.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation.
</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_external.regressors">external.regressors</code></td>
<td>
<p>A matrix object containing the external regressors to 
include in the mean equation with as many rows as will be included in the
data (which is passed in the fit function).</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_distribution.model">distribution.model</code></td>
<td>

<p>The distribution density to use for the innovations (defaults to Normal).</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_solver">solver</code></td>
<td>
<p>One of either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo;, &ldquo;gosolnp&rdquo;
or &ldquo;nloptr&rdquo;.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_solver.control">solver.control</code></td>
<td>
<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_fit.control">fit.control</code></td>
<td>
<p>Control arguments passed to the fitting routine.</p>
</td></tr>
<tr><td><code id="autoarfima_+3A_return.all">return.all</code></td>
<td>
<p>Whether to return all the fitted models or only the best one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p> Either the best fitted model or all the fitted models if the 
option &lsquo;return.all&rsquo; was selected.</p>
</td></tr>
<tr><td><code>rank.matrix</code></td>
<td>
<p> Either a sorted matrix of the models and their information
criterion, else an unsorted matrix of the models and their information criterion
if the option &lsquo;return.all&rsquo; was selected.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sp500ret)
fit = autoarfima(data = sp500ret[1:1000,], ar.max = 2, ma.max = 2, 
criterion = "AIC", method = "full")

## End(Not run)</code></pre>

<hr>
<h2 id='BerkowitzTest'>
Berkowitz Density Forecast Likelihood Ratio Test
</h2><span id='topic+BerkowitzTest'></span>

<h3>Description</h3>

<p>Implements the Berkowitz Density Forecast Likelihood Ratio Test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BerkowitzTest(data, lags = 1, significance = 0.05, tail.test = FALSE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BerkowitzTest_+3A_data">data</code></td>
<td>

<p>A univariate vector of standard normal transformed values (see details 
and example).
</p>
</td></tr>
<tr><td><code id="BerkowitzTest_+3A_lags">lags</code></td>
<td>

<p>The number of autoregressive lags (positive and greater than 0).
</p>
</td></tr>
<tr><td><code id="BerkowitzTest_+3A_significance">significance</code></td>
<td>

<p>The level of significance at which the Null Hypothesis is evaluated.
</p>
</td></tr>
<tr><td><code id="BerkowitzTest_+3A_tail.test">tail.test</code></td>
<td>

<p>Whether to use the tail test of Berkowitz using a censored likelihood.
</p>
</td></tr>
<tr><td><code id="BerkowitzTest_+3A_alpha">alpha</code></td>
<td>

<p>The quantile level for the tail.test cuttoff.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See not below.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>uLL</code></td>
<td>
<p> The unconditional Log-Likelihood of the maximized values.</p>
</td></tr>
<tr><td><code>rLL</code></td>
<td>
<p> The restricted Log-Likelihood with zero mean, unit variance and 
zero coefficients in the autoregressive lags.</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p>The Likelihood Ratio Test Statistic.</p>
</td></tr>
<tr><td><code>LRp</code></td>
<td>
<p>The LR test statistic p-value (distributed chisq with 2+lags 
d.o.f).</p>
</td></tr>
<tr><td><code>H0</code></td>
<td>
<p>The Null Hypothesis.</p>
</td></tr> 
<tr><td><code>Test</code></td>
<td>
<p> The test of the Null Hypothesis at the requested level of 
significance.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>The estimated mean of the model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The estimated sd of the model.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>The estimated autoregressive coefficients of the model (not 
calculated when tail.test is used).</p>
</td></tr>
<tr><td><code>JB</code></td>
<td>
<p> The Jarque-Bera Test of Normality Statistic (not calculated when 
tail.test is used).</p>
</td></tr>
<tr><td><code>JBp</code></td>
<td>
<p> The Jarque-Beta Test Statistic p-value (not calculated when 
tail.test is used).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The data must first be transformed before being submitted to the function as 
described here. Given a forecast density (d*) at time t, transform the 
actual(observed) realizations of the data by applying the distribution function 
of the forecast density (p*). This will result in a set of uniform values 
(see Rosenblatt (1952)). Transform those value into standard normal variates by 
applying the standard normal quantile function (qnorm). The example below 
hopefully clarifies this. The function also returns the Jarque Bera Normality 
Test statistic as an additional check of the normality assumption which the test 
does not explicitly account for (see Dowd reference). When tail.test is used, 
the test of the tail at the &ldquo;alpha&rdquo; quantile level is performed using
a censored normal likelihood.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Berkowitz, J. 2001, Testing density forecasts, with applications to risk 
management, <em>Journal of Business and Economic Statistics</em>, 
<b>19(4)</b>, 465&ndash;474.<br />
Dowd, K. 2004, A modified Berkowitz back-test, <em>RISK Magazine</em>, 
<b>17(4)</b>, 86&ndash;87.<br />
Jarque, C.M. and Bera, A.K. 1987, A test for normality of observations and 
regression residuals, <em>International Statistical Review</em>, <b>55(2)</b>, 
163&ndash;172.<br />
Rosenblatt, M. 1952, Remarks on a multivariate transformation, <em>The Annals 
of Mathematical Statistics</em>, <b>23(3)</b>, 470&ndash;472.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#  A univariate GARCH model is used with rolling out of sample forecasts.
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(6,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "nig")
fit = ugarchfit(spec, data = dji30ret[, 1, drop = FALSE], out.sample = 1000)
pred = ugarchforecast(fit, n.ahead = 1, n.roll = 999)
dmatrix = cbind(as.numeric(fitted(pred)),as.numeric(sigma(pred)), 
rep(coef(fit)["skew"],1000), rep(coef(fit)["shape"],1000))
colnames(dmatrix) = c("mu", "sigma", "skew", "shape")
# Get Realized (Oberved) Data
obsx = tail(dji30ret[,1], 1000)
# Transform to Uniform
uvector = apply(cbind(obsx,dmatrix), 1, FUN = function(x) pdist("nig", q = x[1],
mu = x[2], sigma = x[3], skew = x[4], shape = x[5]))

# hist(uvector)
# transform to N(0,1)
nvector = qnorm(uvector)
test1 = BerkowitzTest(data = nvector, lags = 1, significance = 0.05)
test2 = BerkowitzTest(data = nvector, alpha = 0.05, significance = 0.05, 
tail.test=TRUE)
test3 = BerkowitzTest(data = nvector, alpha = 0.01, significance = 0.05, 
tail.test=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='DACTest'>
Directional Accuracy Test
</h2><span id='topic+DACTest'></span>

<h3>Description</h3>

<p>Implements the Directional Accuracy Test of Pesaran and Timmerman and Excess 
Profitability Test of Anatolyev and Gerko. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DACTest(forecast, actual, test = c("PT", "AG"), conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DACTest_+3A_forecast">forecast</code></td>
<td>

<p>A numeric vector of the forecasted values.</p>
</td></tr>
<tr><td><code id="DACTest_+3A_actual">actual</code></td>
<td>

<p>A numeric vector of the actual (realized) values.</p>
</td></tr>
<tr><td><code id="DACTest_+3A_test">test</code></td>
<td>

<p>Choice of Pesaran and Timmermann (&lsquo;PT&rsquo;) or Anatolyev and Gerko (&lsquo;AG&rsquo;) 
tests.</p>
</td></tr>
<tr><td><code id="DACTest_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level at which the Null Hypothesis is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the references for details on the tests. The Null is effectively that of 
independence, and distributed as N(0,1).
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>Test</code></td>
<td>
<p> The type of test performed.</p>
</td></tr>
<tr><td><code>Stat</code></td>
<td>
<p> The test statistic.</p>
</td></tr>
<tr><td><code>p-value</code></td>
<td>
<p>The p-value of the test statistic.</p>
</td></tr>
<tr><td><code>H0</code></td>
<td>
<p>The Null Hypothesis.</p>
</td></tr>
<tr><td><code>Decision</code></td>
<td>
<p>Whether to reject or not the Null given the conf.level.</p>
</td></tr> 
<tr><td><code>DirAcc</code></td>
<td>
<p> The directional accuracy of the forecast.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Anatolyev, S. and Gerko, A. 2005, A trading approach to testing for 
predictability, <em>Journal of Business and Economic Statistics</em>, <b>23(4)</b>, 
455&ndash;461.<br />
Pesaran, M.H. and Timmermann, A. 1992, A simple nonparametric test of predictive 
performance, <em>Journal of Business and Economic Statistics</em>, 
<b>10(4)</b>, 461&ndash;465.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(6,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "nig")
fit = ugarchfit(spec, data = dji30ret[, 1, drop = FALSE], out.sample = 1000)
pred = ugarchforecast(fit, n.ahead = 1, n.roll = 999)
# Get Realized (Oberved) Data
obsx = tail(dji30ret[,1], 1000)
forc = as.numeric(as.data.frame(pred,rollframe="all",align=FALSE,which="series"))
print(DACTest(forc, obsx, test = "PT", conf.level = 0.95))
print(DACTest(forc, obsx, test = "AG", conf.level = 0.95))

## End(Not run)</code></pre>

<hr>
<h2 id='DateTimeUtilities'>
A small set of utilities to work with some time and date classes.
</h2><span id='topic+move'></span><span id='topic+generatefwd'></span><span id='topic+ftseq'></span>

<h3>Description</h3>

<p>These utilities will likely be useful for working with the forecast objects
of the package which have a rather complex structure. In addition, the ftseq
function is of particular value in generating intraday regularly spaced time and 
date sequences within a specific interval of times (e.g. 09:30 to 16:00).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move(index, by=1)
generatefwd(T0, length.out = 1, by = "days")
ftseq(T0, length.out, by, interval, exclude.weekends = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DateTimeUtilities_+3A_index">index</code></td>
<td>

<p>A POSIXct, Date or numeric vector.</p>
</td></tr>
<tr><td><code id="DateTimeUtilities_+3A_t0">T0</code></td>
<td>

<p>A single POSIXct, Date or numeric value from which to generate forward values (
the returned vector will exclude this value). For the ftseq function, this 
must be a Date AND Time object of class POSIXct.</p>
</td></tr>
<tr><td><code id="DateTimeUtilities_+3A_by">by</code></td>
<td>

<p>For the move function, the length by which to shift the index forward, truncating
the first values and extending the last by this amount. For the generatefwd or 
ftseq function, either a character (see Date and Time classes for valid values), 
numeric or difftime object (see details).</p>
</td></tr>
<tr><td><code id="DateTimeUtilities_+3A_length.out">length.out</code></td>
<td>

<p>The length of the forward generated indices (excluding T0 which is not returned).
</p>
</td></tr>
<tr><td><code id="DateTimeUtilities_+3A_interval">interval</code></td>
<td>

<p>A character vector of the regularly sampled times which define the trading day 
(see example).
</p>
</td></tr>
<tr><td><code id="DateTimeUtilities_+3A_exclude.weekends">exclude.weekends</code></td>
<td>

<p>Whether to exclude the weeekends.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every object returned by one of the main methods in rugarch (including ugarchfit,
ugarchfilter, ugarchforecast and ugarchsim) has a model slot attached which in
turns hold details on the time index of the original dataset used (including a
difftime object). In addition, extractors for the forecast class, uGARCHforecast, 
will usually return a matrix with the (n.roll+1) columns having the T+0 dates, 
and the rows names represented as characters &lsquo;T+1,...,T+n&rsquo; indicating the 
forecast periods following the T+0 date.<br />
For the rolling forecast, it is a simple matter to shift the T+0 date by 1 to
obtain the actual forecast date. Because rolling forecasts are made using the
&lsquo;out.sample&rsquo; switch, this means that there is always an actual date 
attached to this forecast based on the realized out.sample data (with the 
exception of the case when n.roll=out.sample in which case the last forecast is 
completely out of the range of the dataset). One quick way of obtaining the actual 
T+1 rolling dates is to just pass the vector of T+0 dates to the move function 
as shown in the examples.<br />
For the n.ahead&gt;1 unconditional forecasts, there may or may not be
actual dates in the dataset covering the period, depending on whether out.sample
was used, n.roll was also used, and how these all come together to form a complex
object of moving and unconditional forecasts (making this the most complex of
forecast cases). One way to quickly generate a sequence of dates is to use the
generatefwd function with the T+0 starting date, the &lsquo;length&rsquo; as the 
n.ahead horizon and the &lsquo;by&rsquo; the difftime object from the model slot,
as shown in the examples.<br />
Note that for both the move and generatefwd functions, weekends are excluded in
order to try to return a more realistic value.<br />
Finally, when working with Date/Time objects remember to set your time zone
with <code>Sys.setenv(TZ=)</code>.
</p>


<h3>Value</h3>

<p>A vector of Date/Time/Numeric indices of the same class as used in the input.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sp500ret)
spec = ugarchspec()
fit = ugarchfit(spec, sp500ret, out.sample=10)
forc = ugarchforecast(fit, n.ahead = 25, n.roll = 10)
f = fitted(forc)
# this is a 25 x 11 matrix [n.ahead x (n.roll+1)]
# colnames: T+0 date index
T0 = as.POSIXct(colnames(f))
rollT1 = move(T0, by=1)
# rolling estimation
plot(xts(f["T+1",],rollT1))
# unconditional estimates:
par(mfrow=c(3,4))
for(i in 1:11){
# difftime is always in model$modeldata$period
D=generatefwd(T0[i], length.out = 25, by = forc@model$modeldata$period)
plot(xts(f[,i], D), main=paste("T+0:",as.character(T0[i]),sep=""), auto.grid=FALSE)
}
############################
## Intraday Sequency Example
############################
T0 = as.POSIXct("2001-01-01 16:00:00")
# remember to remove the backslash from the code below
interval = format(seq(as.POSIXct("2001-01-01 09:30:00"), as.POSIXct("2001-01-01 16:00:00"), 
by="min"), "%H:%M:%S")
by = "mins"
length.out=1000
R = ftseq(T0, length.out, by, interval)

## End(Not run)</code></pre>

<hr>
<h2 id='dji30ret'>data: Dow Jones 30 Constituents Closing Value Log Return</h2><span id='topic+dji30ret'></span>

<h3>Description</h3>

<p>Dow Jones 30 Constituents closing value log returns from 1987-03-16 to 
2009-02-03 from Yahoo Finance. Note that AIG was replaced by KFT (Kraft Foods) 
on September 22, 2008. This is not reflected in this data set as that would 
bring the starting date of the data to 2001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dji30ret)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 30x5521 observations.</p>


<h3>Source</h3>

<p>Yahoo Finance</p>

<hr>
<h2 id='dmbp'>data: Deutschemark/British pound Exchange Rate</h2><span id='topic+dmbp'></span>

<h3>Description</h3>

<p>The Bollerslev-Ghysel benchmark dataset. The variables in the data set are: <br />
<code>1.</code> The daily percentage nominal returns computed as 100 [ln(Pt) - ln(Pt-1)], 
where Pt is the bilateral Deutschemark/British pound rate constructed from the 
corresponding U.S. dollar rates.<br />
<code>2.</code> A dummy variable that takes the value of 1 on Mondays and other days 
following no trading in the Deutschemark or British pound/ U.S. dollar market 
during regular European trading hours and 0 otherwise.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dmbp)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 2x1974 observations.</p>


<h3>References</h3>

<p>Bollerslev, T. and Ghysels, E. 1996, Periodic Autoregressive Conditional 
Heteroscedasticity , <em>Journal of Business and Economic Statistics</em>, <b>14</b>,
139&ndash;151.</p>

<hr>
<h2 id='ESTest'>
Expected Shortfall Test.
</h2><span id='topic+ESTest'></span>

<h3>Description</h3>

<p>Implements the Expected Shortfall Test of McNeil and Frey. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESTest(alpha = 0.05, actual, ES, VaR, conf.level = 0.95, 
boot = FALSE, n.boot = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESTest_+3A_alpha">alpha</code></td>
<td>

<p>The quantile (coverage) used for the VaR.</p>
</td></tr>
<tr><td><code id="ESTest_+3A_actual">actual</code></td>
<td>

<p>A numeric vector of the actual (realized) values.</p>
</td></tr>
<tr><td><code id="ESTest_+3A_es">ES</code></td>
<td>

<p>The numeric vector of the Expected Shortfall (ES).
</p>
</td></tr>
<tr><td><code id="ESTest_+3A_var">VaR</code></td>
<td>

<p>The numeric vector of VaR.
</p>
</td></tr>
<tr><td><code id="ESTest_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level at which the Null Hypothesis is evaluated.</p>
</td></tr>
<tr><td><code id="ESTest_+3A_boot">boot</code></td>
<td>

<p>Whether to bootstrap the test.
</p>
</td></tr>
<tr><td><code id="ESTest_+3A_n.boot">n.boot</code></td>
<td>

<p>Number of bootstrap replications to use.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Null hypothesis is that the excess conditional shortfall (excess
of the actual series when VaR is violated), is i.i.d. and has zero mean. The 
test is a one sided t-test against the alternative that the excess shortfall has
mean greater than zero and thus that the conditional shortfall is systematically
underestimated. Using the bootstrap to obtain the p-value should alleviate any 
bias with respect to assumptions about the underlying distribution of the excess 
shortfall.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>expected.exceed</code></td>
<td>
<p> The expected number of exceedances 
(length actual x coverage).</p>
</td></tr>
<tr><td><code>actual.exceed</code></td>
<td>
<p> The actual number of exceedances.</p>
</td></tr>
<tr><td><code>H1</code></td>
<td>
<p>The Alternative Hypothesis of the one sided test (see details).</p>
</td></tr>
<tr><td><code>boot.p.value</code></td>
<td>
<p>The bootstrapped p-value (if used).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value.</p>
</td></tr> 
<tr><td><code>Decision</code></td>
<td>
<p>The one-sided test Decision on H0 given the
confidence level and p-value (not the bootstrapped).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>McNeil, A.J. and Frey, R. and Embrechts, P. (2000), Estimation of tail-related 
risk measures for heteroscedastic financial time series: an extreme value 
approach, <em>Journal of Empirical Finance</em>,<b>7</b>, 271&ndash;300.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "sstd")
fit = ugarchfit(spec, data = dji30ret[1:1000, 1, drop = FALSE])
spec2 = spec
setfixed(spec2)&lt;-as.list(coef(fit))
filt = ugarchfilter(spec2, dji30ret[1001:2500, 1, drop = FALSE], n.old = 1000)
actual = dji30ret[1001:2500,1]
# location+scale invariance allows to use [mu + sigma*q(p,0,1,skew,shape)]
VaR = fitted(filt) + sigma(filt)*qdist("sstd", p=0.05, mu = 0, sigma = 1, 
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
# calculate ES
f = function(x) qdist("sstd", p=x, mu = 0, sigma = 1, 
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
ES = fitted(filt) + sigma(filt)*integrate(f, 0, 0.05)$value/0.05
print(ESTest(0.05, actual, ES, VaR, boot = TRUE))

## End(Not run)</code></pre>

<hr>
<h2 id='GARCHboot-class'>class: GARCH Bootstrap Class</h2><span id='topic+GARCHboot-class'></span>

<h3>Description</h3>

<p>High Level GARCH bootstrap class to hold the univariate and multivariate boot
objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHboot&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHboot")
</code></pre>

<hr>
<h2 id='GARCHdistribution-class'>class: GARCH Parameter Distribution Class</h2><span id='topic+GARCHdistribution-class'></span>

<h3>Description</h3>

<p>High Level GARCH parameter distribution class to hold the univariate 
and multivariate boot objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHdistribution&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHdistribution")
</code></pre>

<hr>
<h2 id='GARCHfilter-class'>class: GARCH Filter Class</h2><span id='topic+GARCHfilter-class'></span>

<h3>Description</h3>

<p>High Level GARCH filter class to hold the univariate and multivariate filter
objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHfilter&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHfilter")
</code></pre>

<hr>
<h2 id='GARCHfit-class'>class: GARCH Fit Class</h2><span id='topic+GARCHfit-class'></span>

<h3>Description</h3>

<p>High Level GARCH fit class to hold the univariate and multivariate fits
objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHfit&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHfit")
</code></pre>

<hr>
<h2 id='GARCHforecast-class'>class: GARCH Forecast Class</h2><span id='topic+GARCHforecast-class'></span>

<h3>Description</h3>

<p>High Level GARCH forecast class to hold the univariate and multivariate 
forecast objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHforecast&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHforecast")
</code></pre>

<hr>
<h2 id='GARCHpath-class'>class: GARCH Path Simulation Class</h2><span id='topic+GARCHpath-class'></span>

<h3>Description</h3>

<p>High Level GARCH Path simulation class to hold the univariate and multivariate 
path simulation objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHpath&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHpath")
</code></pre>

<hr>
<h2 id='GARCHroll-class'>class: GARCH Roll Class</h2><span id='topic+GARCHroll-class'></span>

<h3>Description</h3>

<p>High Level GARCH roll class to hold the univariate and multivariate roll
objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHroll&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHroll")
</code></pre>

<hr>
<h2 id='GARCHsim-class'>class: GARCH Simulation Class</h2><span id='topic+GARCHsim-class'></span>

<h3>Description</h3>

<p>High Level GARCH simulation class to hold the univariate and multivariate 
simulation objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHsim&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHsim")
</code></pre>

<hr>
<h2 id='GARCHspec-class'>class: GARCH Spec Class</h2><span id='topic+GARCHspec-class'></span>

<h3>Description</h3>

<p>High Level GARCH spec class to hold the univariate and multivariate 
spec objects.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHspec&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHspec")
</code></pre>

<hr>
<h2 id='GARCHtests-class'>class: GARCH Tests Class</h2><span id='topic+GARCHtests-class'></span>

<h3>Description</h3>

<p>GARCH High level inference and other tests class.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;GARCHtests&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("GARCHtests")
</code></pre>

<hr>
<h2 id='ghyptransform'>Distribution: Generalized Hyperbolic Transformation and Scaling</h2><span id='topic+ghyptransform'></span>

<h3>Description</h3>

<p>The function scales the distributions from the (0, 1) zeta-rho GARCH 
parametrization to the alpha-beta parametrization and performs the appropriate
scaling to the parameters given the estimated sigma and mu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghyptransform(mu = 0, sigma = 1,  skew = 0, shape = 3, lambda = -0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghyptransform_+3A_mu">mu</code></td>
<td>

<p>Either the conditional time-varying (vector) or unconditional mean estimated 
from the GARCH process.</p>
</td></tr>
<tr><td><code id="ghyptransform_+3A_sigma">sigma</code></td>
<td>

<p>The conditional time-varying (vector) sigma estimated from the GARCH process.</p>
</td></tr>
<tr><td><code id="ghyptransform_+3A_skew">skew</code>, <code id="ghyptransform_+3A_shape">shape</code>, <code id="ghyptransform_+3A_lambda">lambda</code></td>
<td>

<p>The conditional non-time varying skewness (rho) and shape (zeta) parameters 
estimated from the GARCH process (zeta-rho), and the GHYP lambda parameter 
(&lsquo;dlambda&rsquo; in the estimation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GHYP transformation is taken from Rmetrics internal function and scaled as 
in Blaesild (see references).
</p>


<h3>Value</h3>

<p>A matrix of size nrows(sigma) x 4 of the scaled and transformed parameters to be
used in the alpha-beta parametrized GHYP distribution functions.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port of the nig transformation function.<br />
Alexios Ghalanos for rugarch implementation.<br />
</p>


<h3>References</h3>

<p>Blaesild, P. 1981, The two-dimensional hyperbolic distribution and related 
distributions, with an application to Johannsen's bean data, <em>Biometrika</em>,
<b>68</b>, 251&ndash;263.<br />
Eberlein, E. and Prauss, K. 2000, The Generalized Hyperbolic Model Financial 
Derivatives and Risk Measures, <em>Mathematical Finance Bachelier Congress</em>,
245&ndash;267.
</p>

<hr>
<h2 id='GMMTest'>
The GMM Orthogonality Test of Hansen
</h2><span id='topic+GMMTest'></span>

<h3>Description</h3>

<p>Implements the GMM Orthogonality Test of Hansen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GMMTest(z, lags = 1, skew=0, kurt=3, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GMMTest_+3A_z">z</code></td>
<td>

<p>A numeric vector the standardized residuals.</p>
</td></tr>
<tr><td><code id="GMMTest_+3A_lags">lags</code></td>
<td>

<p>The number of lags to test for.</p>
</td></tr>
<tr><td><code id="GMMTest_+3A_skew">skew</code></td>
<td>

<p>The skewness of the standardized residuals (derived from the estimated model). 
This can be either a scalar or numeric vector the same size as z.</p>
</td></tr>
<tr><td><code id="GMMTest_+3A_kurt">kurt</code></td>
<td>

<p>The kurtosis (not excess) of the standardized residuals (derived from the 
estimated model). This can be either a scalar or numeric vector the same size 
as z.</p>
</td></tr>
<tr><td><code id="GMMTest_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level at which the Null Hypothesis is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a mispecification test based on Hansen's GMM procedure. Under a correctly 
specified model, certain population moment conditions should be satisfied and 
hold in the sample using the standardized residuals. The moment conditions can 
be tested both individually using a t-test or jointly using a Wald test 
(the vignette gives more details). The test returns a matrix (moment.mat) 
containing the first 4 moments statistics, their standard errors and t-values 
(2-sided t-test with alternative hypothesis that the value is not equal to zero). 
The matrix of joint conditions (joint.mat) contains the t-values and critical 
values of &lsquo;Q2&rsquo;, &lsquo;Q3&rsquo; and &lsquo;Q4&rsquo; representing the 
autocorrelation, given the chosen lags in the second, third and fourth moments 
and distributed as chi-squared with n.lag d.o.f, and the joint test (&lsquo;J&rsquo;) 
for all moment conditions distributed chi-squared with 4+(n.lagx3) d.o.f.</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>joint.mat</code></td>
<td>
<p> The matrix of the joint tests.</p>
</td></tr>
<tr><td><code>moment.mat</code></td>
<td>
<p> The matrix of the individual moment tests.</p>
</td></tr>
<tr><td><code>H0</code></td>
<td>
<p> The Null Hypothesis.</p>
</td></tr>
<tr><td><code>Decision</code></td>
<td>
<p>Whether to reject or not the Null given the conf.level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Hansen, L. (1982), Large Sample Properties of Generalized Method of Moments 
Estimators, <em>Econometrica</em>, <b>50(4)</b>, 1029&ndash;1054.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "sstd")
fit = ugarchfit(spec, data = dji30ret[, 1, drop = FALSE])
z = residuals(fit)\/sigma(fit)
skew = dskewness("sstd",skew = coef(fit)["skew"], shape= coef(fit)["shape"])
# add back 3 since dkurtosis returns the excess kurtosis
kurt = 3+dkurtosis("sstd",skew = coef(fit)["skew"], shape= coef(fit)["shape"])
print(GMMTest(z, lags = 1, skew=skew, kurt=kurt))

## End(Not run)</code></pre>

<hr>
<h2 id='HLTest'>
The Non-Parametric Density Test of Hong and Li
</h2><span id='topic+HLTest'></span>

<h3>Description</h3>

<p>Implements the Non-Parametric Density Test of Hong and Li. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HLTest(PIT, lags = 4, kernel = "quartic", conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HLTest_+3A_pit">PIT</code></td>
<td>

<p>This represents the actual data transformed into a U(0,1) series by applying the
distribution function of the estimated model conditional on the parameters.</p>
</td></tr>
<tr><td><code id="HLTest_+3A_lags">lags</code></td>
<td>

<p>The number of lags to use for testing the joint hypothesis.</p>
</td></tr>
<tr><td><code id="HLTest_+3A_kernel">kernel</code></td>
<td>

<p>The kernel to use for the comparison against the PIT series (only the 
&lsquo;quartic&rsquo; currently implemented).</p>
</td></tr>
<tr><td><code id="HLTest_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level at which the Null Hypothesis is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A novel method to analyze how well a conditional density fits the underlying 
data is through the probability integral transformation (PIT) discussed in 
Rosenblatt (1952) and used in the <code><a href="#topic+BerkowitzTest">BerkowitzTest</a></code>. 
More recently, Hong and Li (2005) introduced a nonparametric portmanteau test, 
building on the work of Ait-Sahalia (1996), which tests the joint hypothesis of 
i.i.d and uniformity for a series of PIT transformed data. To achieve this, it 
tests for misspecification in the conditional moments of the model transformed 
standardized residuals, and is distributed as N(0, 1) under the Null of 
a correctly specified model. These moment tests are reported as &lsquo;M(1,1)&rsquo; 
to &lsquo;M(4,4)&rsquo; in the output, with &lsquo;M(1,2)&rsquo; related to ARCH-in-mean
effects, and &lsquo;M(2,1)&rsquo; to leverage, while &lsquo;W&rsquo; is the Portmanteu type 
test statistic for general misspecification (using p lags) and also distributed 
as N(0, 1) under the Null of a correctly specified model. Only upper tail critical 
values are used in this test. The interested reader is referred to the paper 
for more details.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> The individual moment and joint test statistics.</p>
</td></tr>
<tr><td><code>Decision</code></td>
<td>
<p>Whether to reject or not the Null given the conf.level.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Ait-Sahalia, Y. (1996), Testing continuous-time models of the spot interest 
rate, <em>Review of Financial Studies</em>, <b>9(2)</b>, 385&ndash;426.<br />
Berkowitz, J. (2001), Testing density forecasts, with applications to risk
management, <em>Journal of Business and Economic Statistics</em>, <b>19(4)</b>, 
465&ndash;474.<br />
Hong, Y., and Li, H.  (2005), Nonparametric specification testing for
continuous-time models with applications to term structure of interest
rates, <em>Review of Financial Studies</em>, <b>18(1)</b>, 37&ndash;84.<br />
Rosenblatt, M. (1952), Remarks on a multivariate transformation, <em>The
Annals of Mathematical Statistics</em>, <b>23(3)</b>, 470&ndash;472.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "sstd")
fit = ugarchfit(spec, data = dji30ret[, 1, drop = FALSE])
z = residuals(fit)/sigma(fit)
PIT = pdist("sstd",z, mu = 0, sigma = 1, skew = coef(fit)["skew"], 
shape=coef(fit)["shape"])
print(HLTest(PIT, lags=4))

## End(Not run)</code></pre>

<hr>
<h2 id='mcsTest'>
Model Confidence Set Test
</h2><span id='topic+mcsTest'></span>

<h3>Description</h3>

<p>Implements the Model Confidence Set Test procedure of Hansen, Lunde and 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcsTest(losses, alpha, nboot = 100, nblock = 1, boot = c("stationary", "block"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcsTest_+3A_losses">losses</code></td>
<td>

<p>A matrix of losses from competing models.</p>
</td></tr>
<tr><td><code id="mcsTest_+3A_alpha">alpha</code></td>
<td>

<p>The p-value used in the test.</p>
</td></tr>
<tr><td><code id="mcsTest_+3A_nboot">nboot</code></td>
<td>

<p>The number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="mcsTest_+3A_nblock">nblock</code></td>
<td>

<p>The block length to use in the bootstrap.
</p>
</td></tr>
<tr><td><code id="mcsTest_+3A_boot">boot</code></td>
<td>

<p>A choice of either the stationary or block boostrap.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates and returns the results of both the R (range) and SQ (semi-quadratic) statistics.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>includedR</code></td>
<td>
<p> The models included based on the R statistic.</p>
</td></tr>
<tr><td><code>pvalsR</code></td>
<td>
<p> The final p-values of each model under the R statistic.</p>
</td></tr>
<tr><td><code>excludedR</code></td>
<td>
<p>The excluded models based on the R statistic.</p>
</td></tr>
<tr><td><code>includedSQ</code></td>
<td>
<p> The models included based on the SQ statistic.</p>
</td></tr>
<tr><td><code>pvalsSQ</code></td>
<td>
<p> The final p-values of each model under the SQ statistic.</p>
</td></tr>
<tr><td><code>excludedSQ</code></td>
<td>
<p>The excluded models based on the SQ statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Hansen, P. R., Lunde, A., and Nason, J. M., 2011. The model confidence set. 
<em>Econometrica</em>, <b>79(2)</b>, 453&ndash;497.<br />
</p>

<hr>
<h2 id='multifilter-methods'>function: Univariate GARCH and ARFIMA Multiple Filtering</h2><span id='topic+multifilter'></span><span id='topic+multifilter-methods'></span><span id='topic+multifilter+2CANY-method'></span><span id='topic+multifilter+2CuGARCHmultifit-method'></span><span id='topic+multifilter+2CuGARCHmultispec-method'></span><span id='topic+multifilter+2CARFIMAmultifit-method'></span><span id='topic+multifilter+2CARFIMAmultispec-method'></span>

<h3>Description</h3>

<p>Method for multiple filtering of a variety of univariate GARCH and ARFIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multifilter(multifitORspec, data = NULL, out.sample = 0, n.old = NULL, 
rec.init = "all", cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multifilter-methods_+3A_multifitorspec">multifitORspec</code></td>
<td>

<p>Either a univariate GARCH or ARFIMA multiple fit object of class 
<code><a href="#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> and <code><a href="#topic+ARFIMAmultifit-class">ARFIMAmultifit</a></code>, or
alternatively a univariate GARCH or ARFIMA multiple specification object of 
class <code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code>  and <code><a href="#topic+ARFIMAmultispec-class">ARFIMAmultispec</a></code>
with valid parameters supplied via the <code>fixed.pars</code> argument in the 
individual specifications.</p>
</td></tr>
<tr><td><code id="multifilter-methods_+3A_data">data</code></td>
<td>

<p>Required if a multiple specification rather than a multiple fit object is 
supplied. A multivariate data object. Can be a matrix or data.frame object, 
no other class supported at present.</p>
</td></tr>
<tr><td><code id="multifilter-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>A positive integer indicating the number of periods before the last to keep for 
out of sample forecasting (as in <code><a href="#topic+ugarchfit">ugarchfit</a></code> function).</p>
</td></tr>
<tr><td><code id="multifilter-methods_+3A_n.old">n.old</code></td>
<td>

<p>For comparison with uGARCHfit or ARFIMAfit models using the out.sample argument,
this is the length of the original dataset (see details).</p>
</td></tr>
<tr><td><code id="multifilter-methods_+3A_rec.init">rec.init</code></td>
<td>

<p>Recursion initialization method (as in <code><a href="#topic+ugarchfit">ugarchfit</a></code> function), valid
only for GARCH models, and can be a vector of length equal to the number of 
assets being modelled.</p>
</td></tr>
<tr><td><code id="multifilter-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation.
</p>
</td></tr>
<tr><td><code id="multifilter-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHmultifilter-class">uGARCHmultifilter</a></code> object containing details of the multiple GARCH filter.
A <code><a href="#topic+ARFIMAmultifilter-class">ARFIMAmultifilter</a></code> object containing details of the multiple ARFIMA filter.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='multifit-methods'>function: Univariate GARCH and ARFIMA Multiple Fitting</h2><span id='topic+multifit'></span><span id='topic+multifit-methods'></span><span id='topic+multifit+2CANY-method'></span><span id='topic+multifit+2CuGARCHmultispec-method'></span><span id='topic+multifit+2CARFIMAmultispec-method'></span>

<h3>Description</h3>

<p>Method for multiple fitting a variety of univariate GARCH and ARFIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multifit(multispec, data, out.sample = 0, solver = "solnp", solver.control = list(), 
fit.control = list(stationarity = 1, fixed.se = 0, scale = 0, rec.init = "all"), 
cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multifit-methods_+3A_multispec">multispec</code></td>
<td>

<p>A multiple GARCH or ARFIMA spec object of class <code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code> 
and <code><a href="#topic+ARFIMAmultispec-class">ARFIMAmultispec</a></code>.</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>A positive integer indicating the number of periods before the last to keep for 
out of sample forecasting (see details).</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_data">data</code></td>
<td>

<p>A multivariate data object of class xts or coercible to such.</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_solver">solver</code></td>
<td>

<p>One of either &ldquo;nlminb&rdquo; or &ldquo;solnp&rdquo;.</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control arguments passed to the fitting routine. Stationarity (only for the 
GARCH case) explicitly imposes the variance stationarity constraint during 
optimization. The fixed.se argument controls whether standard errors should be 
calculated for those parameters which were fixed (through the fixed.pars 
argument of the <code><a href="#topic+ugarchspec">ugarchspec</a></code> or <code><a href="#topic+arfimaspec">arfimaspec</a></code> functions). 
The scale parameter controls whether the data should be scaled before being 
submitted to the optimizer, while the rec.init option controls the recursion
initialization method and only valid for GARCH models.</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation.
</p>
</td></tr>
<tr><td><code id="multifit-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> or <code><a href="#topic+ARFIMAmultifit-class">ARFIMAmultifit</a></code> 
object containing details of the GARCH or ARFIMA fits.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec()
mspec = multispec( replicate(spec, n = 4) )
fitlist = multifit(multispec = mspec, data = dji30ret[,1:4])

## End(Not run)</code></pre>

<hr>
<h2 id='multiforecast-methods'>function: Univariate GARCH and ARFIMA Multiple Forecasting</h2><span id='topic+multiforecast'></span><span id='topic+multiforecast-methods'></span><span id='topic+multiforecast+2CANY-method'></span><span id='topic+multiforecast+2CuGARCHmultifit-method'></span><span id='topic+multiforecast+2CuGARCHmultispec-method'></span><span id='topic+multiforecast+2CARFIMAmultifit-method'></span><span id='topic+multiforecast+2CARFIMAmultispec-method'></span>

<h3>Description</h3>

<p>Method for multiple forecasting from a variety of univariate GARCH and ARFIMA 
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiforecast(multifitORspec, data = NULL, n.ahead = 1, n.roll = 0, 
out.sample = 0, external.forecasts = list(mregfor = NULL, vregfor = NULL), 
cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiforecast-methods_+3A_multifitorspec">multifitORspec</code></td>
<td>

<p>Either a univariate GARCH or ARFIMA multiple fit object <code><a href="#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> 
and <code><a href="#topic+ARFIMAmultifit-class">ARFIMAmultifit</a></code>, or alternatively a univariate GARCH or 
ARFIMA multiple specification object of class <code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code> 
and <code><a href="#topic+ARFIMAmultispec-class">ARFIMAmultispec</a></code> with valid parameters supplied via the 
<code>setfixed&lt;-</code> function in the individual specifications.</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_data">data</code></td>
<td>

<p>Required if a multiple specification rather than a multiple fit object is 
supplied. A multivariate data object. Can be a matrix or data.frame object, no 
other class supported at present.</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The forecast horizon.</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_n.roll">n.roll</code></td>
<td>

<p>The no. of rolling forecasts to create beyond the first one.</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>Optional. If a specification object is supplied, indicates how many data points
to keep for out of sample testing. If this is not a vector equal to the column 
dimension of the data, then it will be replicated to that dimension, else it must 
be of same length as the data column dimension.</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_external.forecasts">external.forecasts</code></td>
<td>

<p>A list with forecasts for the external regressors in the mean and/or variance 
equations if specified.</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation
of the refits (remember to stop the cluster on completion).
</p>
</td></tr>
<tr><td><code id="multiforecast-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHmultiforecast-class">uGARCHmultiforecast</a></code> or <code><a href="#topic+ARFIMAmultiforecast-class">ARFIMAmultiforecast</a></code> 
object containing details of the multiple GARCH or ARFIMA forecasts. See the 
class for details.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='multispec-methods'>function: Univariate multiple GARCH Specification</h2><span id='topic+multispec'></span><span id='topic+multispec-methods'></span><span id='topic+multispec+2CANY-method'></span><span id='topic+multispec+2Cvector-method'></span>

<h3>Description</h3>

<p>Method for creating a univariate multiple GARCH or ARFIMA specification object 
prior to fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multispec( speclist )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multispec-methods_+3A_speclist">speclist</code></td>
<td>

<p>A list with as many univariate GARCH or ARFIMA specifications of class 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> and <code><a href="#topic+ARFIMAspec-class">ARFIMAspec</a></code>  as there 
will be columns in the data object passed to one of the other methods which uses 
a multiple specification object (fitting, filtering and forecasting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code> or <code><a href="#topic+ARFIMAmultispec-class">ARFIMAmultispec</a></code> 
object containing details of the multiple GARCH or ARFIMA specifications.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'># how to make a list with 2 uGARCHspec objects of the same type
spec = ugarchspec()
mspec = multispec( replicate(2, spec) )
# note that replicate(spec, 2) does not work...be careful about the order 
# else explicity name 'n' (i.e. n = 2)

# or simply combine disparate objects
spec1 = ugarchspec(distribution = "norm")
spec2 = ugarchspec(distribution = "std")
mspec = multispec( c( spec1, spec2 ) )
</code></pre>

<hr>
<h2 id='qnig'>
Functions exported for use in rmgarch
</h2><span id='topic+qnig'></span><span id='topic+qgh'></span>

<h3>Description</h3>

<p>Quantile for NIG and GH distributions in alpha, beta,
delta, mu and lambda parametrizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qnig(p, alpha = 1, beta = 0, delta = 1, mu = 0)
qgh(p, alpha = 1, beta = 0, delta = 1, mu = 0, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qnig_+3A_p">p</code></td>
<td>

<p>Probabilities
</p>
</td></tr>
<tr><td><code id="qnig_+3A_alpha">alpha</code></td>
<td>

<p>parameter in alpha, beta, delta, mu, lambda parametrization
of the gh distribution.
</p>
</td></tr>
<tr><td><code id="qnig_+3A_beta">beta</code></td>
<td>

<p>parameter in alpha, beta, delta, mu, lambda parametrization
of the gh distribution.
</p>
</td></tr>
<tr><td><code id="qnig_+3A_delta">delta</code></td>
<td>

<p>parameter in alpha, beta, delta, mu, lambda parametrization
of the gh distribution.
</p>
</td></tr>
<tr><td><code id="qnig_+3A_mu">mu</code></td>
<td>

<p>parameter in alpha, beta, delta, mu, lambda parametrization
of the gh distribution.
</p>
</td></tr>
<tr><td><code id="qnig_+3A_lambda">lambda</code></td>
<td>

<p>parameter in alpha, beta, delta, mu, lambda parametrization
of the gh distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For use internally by rmgarch.
</p>


<h3>Value</h3>

<p>A vector
</p>


<h3>Author(s)</h3>

<p>Alexios Galanos
</p>

<hr>
<h2 id='rGARCH-class'>class: rGARCH Class</h2><span id='topic+rGARCH-class'></span>

<h3>Description</h3>

<p>Highest Level Virtual Package Class to which all other classes belong.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;rGARCH&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("rGARCH")
</code></pre>

<hr>
<h2 id='rgarchdist'>Distribution: rugarch distribution functions</h2><span id='topic+rgarchdist'></span><span id='topic+ddist'></span><span id='topic+pdist'></span><span id='topic+qdist'></span><span id='topic+rdist'></span><span id='topic+fitdist'></span><span id='topic+dskewness'></span><span id='topic+dkurtosis'></span><span id='topic+distplot'></span><span id='topic+skdomain'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, random generation and fitting 
from the univariate distributions implemented in the rugarch package, with 
functions for skewness and excess kurtosis given density skew and shape 
parameters.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>rgarchdist</code> </td><td style="text-align: left;"> rugarch univariate distributions, </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code>fitdist</code> </td><td style="text-align: left;"> MLE parameter fit for the rugarch univariate distributions, </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>ddist(distribution = "norm", y, mu = 0, sigma = 1, lambda = -0.5, skew = 1, 
shape = 5)
pdist(distribution = "norm", q, mu = 0, sigma = 1, lambda = -0.5, skew = 1, 
shape = 5)
qdist(distribution = "norm", p, mu = 0, sigma = 1, lambda = -0.5, skew = 1, 
shape = 5)
rdist(distribution = "norm", n, mu = 0, sigma = 1, lambda = -0.5, skew = 1, 
shape = 5)
fitdist(distribution = "norm", x, control=list())
dskewness(distribution = "norm", skew = 1, shape = 5, lambda = -0.5)
dkurtosis(distribution = "norm", skew = 1, shape = 5, lambda = -0.5)
distplot(distribution = "snorm", skewbounds = NULL, shapebounds = NULL, 
		n.points = NULL)
skdomain(distribution = "nig", kurt.max = 30, n.points = 25, lambda = 1, 
plot = TRUE, legend = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgarchdist_+3A_distribution">distribution</code></td>
<td>

<p>The distribution name. Valid choices are &ldquo;norm&rdquo;, &ldquo;snorm&rdquo;, 
&ldquo;std&rdquo;, &ldquo;sstd&rdquo;, &ldquo;ged&rdquo;, &ldquo;sged&rdquo;, &ldquo;nig&rdquo;, 
&ldquo;jsu&rdquo;.</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_mu">mu</code>, <code id="rgarchdist_+3A_sigma">sigma</code>, <code id="rgarchdist_+3A_skew">skew</code>, <code id="rgarchdist_+3A_shape">shape</code></td>
<td>

<p>location, scale and skewness and shape parameters (see details).</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_lambda">lambda</code></td>
<td>

<p>The additional shape parameter  for the Generalized Hyperbolic and NIG 
distributions.</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_n">n</code></td>
<td>

<p>The number of observations.</p>
</td></tr> 
<tr><td><code id="rgarchdist_+3A_p">p</code></td>
<td>

<p>A numeric vector of probabilities.</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_y">y</code>, <code id="rgarchdist_+3A_q">q</code></td>
<td>

<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_x">x</code></td>
<td>

<p>A univariate dataset (for fitting routine).</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_control">control</code></td>
<td>

<p>Control parameters passed to the <code>solnp</code> solver.</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_skewbounds">skewbounds</code></td>
<td>

<p>The skewed distribution skew bounds for the plot. Leaving it NULL will use a good set of
defaults for display purposes.
</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_shapebounds">shapebounds</code></td>
<td>

<p>The shaped distribution shape bounds for the plot. Leaving it NULL will use a good set of
defaults for display purposes.
</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_n.points">n.points</code></td>
<td>

<p>The number of points between the lower and upper bounds of the skew and shape
parameters for which to evaluate the skewness and excess kurtosis. For the
skdomain function this determines the kurtosis interval (3-max.kurt) for which
to determine (using a solver) the maximum skewness.
</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_kurt.max">kurt.max</code></td>
<td>

<p>The maximum kurtosis for which to determine the bounds for the skewness-kurtosis
domain.
</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_plot">plot</code></td>
<td>

<p>Whether to plot the results.
</p>
</td></tr>
<tr><td><code id="rgarchdist_+3A_legend">legend</code></td>
<td>

<p>Whether to include a legend with the plot in the skdomain.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the &ldquo;nig&rdquo; and &ldquo;ghyp&rdquo; distributions, the shape, skew and lambda
are transformed from the &lsquo;zeta-rho&rsquo; to the &lsquo;alpha-beta&rsquo; 
parametrization and then scaled by the mean and standard deviation. The fitting 
routines use the <code>solnp</code> solver and minimize the negative of the 
log-likelihood.
The &ldquo;dskewness&rdquo; and &ldquo;dkurtosis&rdquo; functions take as inputs the 
distribution name, skew and shape parameters and return the skewneness and 
excess kurtosis of the distribution. The functions are not at present 
vectorized.
The distplot provides illustrative plots (or surfaces) of skewness and kurtosis 
for any of the distributions supported (with the exception of the GH which has
2 shape and 1 skew parameters and hence is impractical to represent).<br />
</p>


<h3>Value</h3>

<p><code>d*</code> returns the density,
<code>p*</code> returns the distribution function,
<code>q*</code> returns the quantile function, and
<code>r*</code> generates random deviates, <br />
all values are numeric vectors.
</p>
<p><code>fitdist</code> returns a list with the following components: 
<br />
</p>
<table>
<tr><td><code>par</code></td>
<td>

<p>The best set of parameters found. 
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>The likelihood values of the optimization (vector whose length represents 
the number of major iterations).
</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>

<p>An integer code. 0 indicates successful convergence.
</p>
</td></tr>
<tr><td><code>lagrange</code></td>
<td>

<p>The lagrange multiplier value at convergence.
</p>
</td></tr>
<tr><td><code>h</code></td>
<td>

<p>The hessian at the solution.
</p>
</td></tr>
<tr><td><code>xineq0</code></td>
<td>

<p>The value of the inequality constraint multiplier (NULL for the 
distribution fit problems).
</p>
</td></tr>
</table>
<p><code>dskewness</code> returns the skewness of the distribution. 
<code>dkurtosis</code> returns the excess kurtosis of the distribution.
<code>skdomain</code> returns the authorized domain of the distribution.
</p>


<h3>Author(s)</h3>

<p>Diethelm Wuertz for the Rmetrics <span class="rlang"><b>R</b></span>-port of the &ldquo;norm&rdquo;, &ldquo;snorm&rdquo;, 
&ldquo;std&rdquo;, &ldquo;sstd&rdquo;, &ldquo;ged&rdquo;, &ldquo;sged&rdquo; and &ldquo;nig&rdquo; 
distrbutions.<br />
Rigby, R. A. and Stasinopoulos D. M for the JSU distribution in the 
<code>gamlss</code> package.<br />
Alexios Ghalanos for rugarch implementation and higher moment distribution 
functions.
</p>


<h3>References</h3>

<p>Johnson, N. L. 1954, Systems of frequency curves derived from the first law of 
Laplace, <em>Trabajos de Estadistica</em>, <b>5</b>, 283&ndash;291.<br />
Barndorff-Nielsen, O. E. 1995, Normal inverse Gaussian processes and the 
modeling of stock returns, <em>mimeo: Univ.of Aarhus Denmark</em>.<br />
Fernandez C. and Steel, M.F.J. 1998, On Bayesian Modelling of Fat Tails and 
Skewness, <em>Journal of the American Statistical Association</em>, 359&ndash;371.<br />
</p>

<hr>
<h2 id='rugarch-package'>The rugarch package</h2><span id='topic+rugarch-package'></span><span id='topic+rugarch'></span>

<h3>Description</h3>

<p>The rugarch package aims to provide a flexible and rich univariate GARCH
modelling and testing environment. Modelling is a simple process of defining a
specification and fitting the data. Inference can be made from summary, various
tests and plot methods, while the forecasting, filtering and simulation methods
complete the modelling environment. Finally, specialized methods are implemented
for simulating parameter distributions and evaluating parameter consistency,
and a bootstrap forecast method which takes into account both parameter and
predictive distribution uncertainty.<br />
The testing environment is based on a rolling backtest function which considers
the more general context in which GARCH models are based, namely the conditional
time varying estimation of density parameters and the implication for their use
in analytical risk management measures.<br />
The mean equation allows for AR(FI)MA, arch-in-mean and external regressors,
while the variance equation implements a wide variety of univariate GARCH models
as well as the possibility of including external regressors. Finally, a set of
feature rich distributions are used for modelling innovations and documented in
the vignette.<br />
This package is part of what used to be the rgarch package, which was split
into univariate (rugarch) and multivariate (rmgarch) models for easier
maintenance and use, both of which are now hosted on CRAN (stable) and
bitbucket (development).
</p>


<h3>Details</h3>

<p>While the package has implemented some safeguards, both during pre-estimation
as well as the estimation phase, there is no guarantee of convergence in the
fitting procedure. As a result, the fit method allows the user to input starting
parameters as well as keep any parameters from the spec as fixed (including
the case of all parameters fixed).<br />
The functionality of the packages is contained in the main methods for defining
a specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>,
forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, simulation from fit object
<code><a href="#topic+ugarchsim">ugarchsim</a></code>, path simulation from specification object
<code><a href="#topic+ugarchpath">ugarchpath</a></code>, parameter distribution by simulation
<code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast <code><a href="#topic+ugarchboot">ugarchboot</a></code>
and rolling estimation and forecast <code><a href="#topic+ugarchroll">ugarchroll</a></code>. There are also
some functions which enable multiple fitting of assets in an easy to use wrapper
with the option of multicore functionality, namely <code><a href="#topic+multispec">multispec</a></code>,
<code><a href="#topic+multifit">multifit</a></code>, <code><a href="#topic+multifilter">multifilter</a></code> and <code><a href="#topic+multiforecast">multiforecast</a></code>.
Explanations on the available methods for the returned classes can be found in
the documentation for those classes.<br />
A separate subset of methods and classes has been included to calculate pure
ARFIMA models with constant variance. This subset includes similar functionality
as with the GARCH methods, with the exception that no plots are yet implemented,
and neither is a forecast based on the bootstrap. These may be added in the
future. While there are limited examples in the documentation on the ARFIMA
methods, the interested user can search the rugarch.tests folder of the source
installation for some tests using ARFIMA models as well as equivalence to the
base R arima methods (particularly replication of simulation). Finally, no
representation is made about the adequacy of ARFIMA models, particularly the
statistical properties of parameters when using distributions which go beyond
the Gaussian.<br />
The conditional distributions used in the package are also exposed for the
benefit of the user through the <code><a href="#topic+rgarchdist">rgarchdist</a></code> functions which contain
methods for density, distribution, quantile, sampling and fitting. Additionally,
<code><a href="#topic+ghyptransform">ghyptransform</a></code> function provides the necessary parameter
transformation and scaling methods for moving from the location scale invariant
&lsquo;rho-zeta&rsquo; parametrization with mean and standard deviation, to the
standard &lsquo;alpha-beta-delta-mu&rsquo; parametrization of the Generalized
Hyperbolic Distribution family.<br />
The type of data handled by the package is now completely based on the xts package,
and only data which can be coerced to such will be accepted by the package. For
the estimation and filter routines, some of the main extractors methods will
now also return xts objects.<br />
Some benchmarks (published and comparison with commercial package), are
available through the <code><a href="#topic+ugarchbench">ugarchbench</a></code> function. The &lsquo;inst&rsquo;
folder of the source distribution also contains various tests which can be
sourced and run by the user, also exposing some finer details of the
functionality of the package. The user should really consult the examples
supplied in this folder which are quite numerous and instructive with some
comments.<br />
Since version 1.0-14, all parallel estimation is carried out through a
user-supplied cluster object, created from the parallel package, meaning that
the user is now in control of managing the cluster lifecycle. This greatly
simplifies the parallel estimation process and adds a layer of flexibility to
the type of resources supported.<br />
Finally, the global extractor functions <code>sigma</code> and <code>fitted</code> will now
work with almost all returned classes and the return the conditional sigma and
mean values, whether these are from an estimated, filtered, forecast, or
simulated object (and their multi- function equivalents).
</p>


<h3>How to cite this package</h3>

<p>Whenever using this package, please cite as<br />
</p>
<pre>@Manual{Ghalanos_2014,
 author       = {Alexios Ghalanos},
 title        = {{rugarch}: Univariate GARCH models.},
 year         = {2014},
 note         = {R package version 1.4-0.},}</pre>


<h3>License</h3>

<p>The releases of this package is licensed under GPL version 3.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Baillie, R.T. and Bollerslev, T. and Mikkelsen,H.O. 1996, Fractionally
integrated generalized autoregressive conditional heteroskedasticity,
<em>Journal of Econometrics</em>, 3&ndash;30 .<br />
Berkowitz, J. 2001, Testing density forecasts, with applications to risk
management, <em>Journal of Business and Economic Statistics</em>, <b>19(4)</b>,
465&ndash;474.<br />
Bollerslev, T. 1986, Generalized Autoregressive Conditional Heteroskedasticity
1986, <em>Journal of Econometrics</em>, <b>31</b>, 307&ndash;327.<br />
Ding, Z., Granger, C.W.J. and Engle, R.F. 1993, A Long Memory Property of Stock
Market Returns and a New Model, <em>Journal of Empirical Finance</em>, <b>1</b>,
83&ndash;106.<br />
Engle, R.F. and Ng, V. K. 1993, Measuring and Testing the Impact of News on
Volatility, <em>Journal of Finance</em>, <b>48</b>, 1749&ndash;1778.<br />
Engle, R. F., and Sokalska, M. E. 2012, Forecasting intraday volatility in the
US equity market. Multiplicative component GARCH. <em>Journal of Financial
Econometrics</em>, <b>10(1)</b>, 54&ndash;83.<br />
Fisher, T. J., and Gallagher, C. M. 2012, New weighted portmanteau statistics
for time series goodness of fit testing, <em>Journal of the American Statistical
Association</em>, <b>107(498)</b>, 777&ndash;787.<br />
Glosten, L.R., Jagannathan, R. and Runkle, D.E. 1993, On the Relation between
the Expected Value and the Volatility of the Nominal Excess Return on Stocks,
<em>Journal of Finance</em>, <b>48(5)</b>, 1779&ndash;1801.<br />
Hansen, B.E. 1990, Langrange Multiplier Tests for Parameter Instability in
Non-Linear Models, <em>mimeo</em>.<br />
Hentschel, Ludger. 1995, All in the family Nesting symmetric and asymmetric
GARCH models, <em>Journal of Financial Economics</em>, <b>39(1)</b>, 71&ndash;104.<br />
Nelson, D.B. 1991, Conditional Heteroskedasticity in Asset Returns: A New
Approach, <em>Econometrica</em>, <b>59</b>, 347&ndash;370.<br />
Pascual, L., Romo, J. and Ruiz, E. 2004, Bootstrap predictive inference for
ARIMA processes, <em>Journal of Time Series Analysis</em>.<br />
Pascual, L., Romo, J. and Ruiz, E. 2006, Bootstrap prediction for returns and
volatilities in GARCH models, <em>Computational Statistics and Data Analysis</em>.<br />
Vlaar, P.J.G. and Palm, F.C. 1993, The Message in Weekly Exchange Rates in the
European Monetary System: Mean Reversion Conditional Heteroskedasticity and
Jumps, <em>Journal of Business and Economic Statistics</em>, <b>11</b>, 351&ndash;360.<br />
</p>

<hr>
<h2 id='sp500ret'>data: Standard and Poors 500 Closing Value Log Return</h2><span id='topic+sp500ret'></span>

<h3>Description</h3>

<p>The SP500 index closing value log return from 1987-03-10 to 2009-01-30 from
yahoo finance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sp500ret)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 1x5523 observations.</p>


<h3>Source</h3>

<p>Yahoo Finance</p>

<hr>
<h2 id='spyreal'>data: SPDR Standard and Poors 500 Open-Close Daily Return and Realized Kernel Volatility</h2><span id='topic+spyreal'></span>

<h3>Description</h3>

<p>The SPDR SP500 index open-close return and the realized kernel volatility for the period 
2002-01-02 to 2008-08-29 from the paper of Hansen, Huang and Shek (2011). Used for illustrating
the implementation of the Realized GARCH model in rugarch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spyreal)</code></pre>


<h3>Format</h3>

<p>An xts object.</p>


<h3>Source</h3>

<p>Journal of Applied Econometrics Data Archive</p>


<h3>References</h3>

<p>Hansen, P. R., Huang, Z., and Shek, H. H. (2012). Realized GARCH: a joint model for returns 
and realized measures of volatility. <em>Journal of Applied Econometrics</em>, <b>27(6)</b>, 
877&ndash;906.
</p>

<hr>
<h2 id='ugarchbench'>
Benchmark: The Benchmark Test Suite
</h2><span id='topic+ugarchbench'></span>

<h3>Description</h3>

<p>Function for running the rugarch benchmark suite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchbench( benchmark = c("commercial", "published") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchbench_+3A_benchmark">benchmark</code></td>
<td>
<p> The type of benchmark to run against (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, 2 benchmark suites are available. The &ldquo;commercial&rdquo; option runs
the standard GARCH, apARCH and gjrGARCH against a commercial based product and 
reports the results. The data for this bechmarks is &ldquo;AA&rdquo; in the dji30ret 
dataset. The &ldquo;published&rdquo; option is based on the published benchmark of 
Bollerslev and Ghysels for the standard and exponential GARCH models on the dmbp
data.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Source</h3>

<p>&lsquo;http://www.stanford.edu/~clint/bench/index.htm&rsquo;
</p>


<h3>References</h3>

<p>Brooks, C. 1997, GARCH Modelling in Finance: A review of the Software Options,
<em>Economic Journal</em>, <b>107(443)</b>, 1271&ndash;1276.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ugarchbench( benchmark = "published" )

## End(Not run)
</code></pre>

<hr>
<h2 id='uGARCHboot-class'>class: Univariate GARCH Bootstrap Class</h2><span id='topic+uGARCHboot-class'></span><span id='topic+as.data.frame+2CuGARCHboot-method'></span><span id='topic+plot+2CuGARCHboot+2Cmissing-method'></span><span id='topic+show+2CuGARCHboot-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Bootstrap based Forecasts.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHboot-class">GARCHboot</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHboot&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "uGARCHboot")</code>: 
extracts various values from object (see note).</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHboot", y = "missing")</code>: 
bootstrap forecast plots. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHboot")</code>: 
bootstrap forecast summary. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>as.data.frame</code> function takes optionally the arguments <code>which</code>, 
being either &ldquo;sigma&rdquo; or &ldquo;series&rdquo;, the argument <code>type</code>, 
with the options &ldquo;raw&rdquo; for the bootstrapped series, &ldquo;summary&rdquo; for 
summary statistics per n.ahead, and &ldquo;q&rdquo; for the quantiles of the n.ahead 
bootstrapped series, for which the option <code>qtile</code> is then required and 
takes a numeric vector of quantiles (e.g. c(0.05, 0.95) ).<br />
The plot method provides for a Parameter Density Plots (only valid for the 
&ldquo;full&rdquo; method), and the series and sigma forecast plots with quantile 
error lines from the bootstrapped n.ahead distribution. The plot option 
<code>which</code> relates to either a numeric choice (1:3), an interactive choice 
(&ldquo;ask&rdquo; which is the default) and an all plot choice (&ldquo;all&rdquo;) for 
which only plots 2 and 3 are included.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Pascual, L., Romo, J. and Ruiz, E. 2004, Bootstrap predictive inference for 
ARIMA processes, <em>Journal of Time Series Analysis</em>.<br />
Pascual, L., Romo, J. and Ruiz, E. 2006, Bootstrap prediction for returns and 
volatilities in GARCH models, <em>Computational Statistics and Data Analysis</em>.<br />
</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHforecast-class">uGARCHforecast</a></code>, <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> and 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.
</p>

<hr>
<h2 id='ugarchboot-methods'>function: Univariate GARCH Forecast via Bootstrap</h2><span id='topic+ugarchboot'></span><span id='topic+ugarchboot-methods'></span><span id='topic+ugarchboot+2CANY-method'></span><span id='topic+ugarchboot+2CuGARCHfit-method'></span><span id='topic+ugarchboot+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for forecasting the GARCH density based on a bootstrap procedures (see 
details and references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchboot(fitORspec, data = NULL, method = c("Partial", "Full"), 
sampling = c("raw", "kernel", "spd"), spd.options = list(upper = 0.9, 
lower = 0.1, type = "pwm", kernel = "normal"), n.ahead = 10, 
n.bootfit = 100, n.bootpred = 500, out.sample = 0, rseed = NA, solver = "solnp", 
solver.control = list(), fit.control = list(), 
external.forecasts = list(mregfor = NULL, vregfor = NULL), mexsimdata = NULL, 
vexsimdata = NULL, cluster = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchboot-methods_+3A_fitorspec">fitORspec</code></td>
<td>

<p>Either a univariate GARCH fit object of class <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> or
alternatively a univariate GARCH specification object of class <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> 
with valid parameters supplied via the <code>setfixed&lt;-</code> function in the 
specification.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_data">data</code></td>
<td>

<p>Required if a specification rather than a fit object is supplied.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_method">method</code></td>
<td>

<p>Either the full or partial bootstrap (see note).</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_sampling">sampling</code></td>
<td>

<p>Whether to sample from the raw residuals, the kernel-fitted distribution of the
residuals or the spd-fitted distribution of the residuals.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_spd.options">spd.options</code></td>
<td>

<p>If sampling is from the SPD distribution, this controls the options for fitting
this distribution to the residuals (see <code>spd</code> package for details).</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The forecast horizon.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_n.bootfit">n.bootfit</code></td>
<td>

<p>The number of simulation based re-fits used to generate the parameter 
distribution (i.e the parameter uncertainty). Not relevant for the &ldquo;Partial&rdquo; 
method. </p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_n.bootpred">n.bootpred</code></td>
<td>

<p>The number of bootstrap replications per parameter distribution per n.ahead 
forecasts used to generate the predictive density. If this is for the partial 
method, simply the number of random samples from the empirical distribution to 
generate per n.ahead.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>Optional. If a specification object is supplied, indicates how many data points
to keep for out of sample testing.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_rseed">rseed</code></td>
<td>

<p>A vector of seeds to initialize the random number generator for the resampling
with replacement method (if supplied should be equal to n.bootfit + n.bootpred).</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_solver">solver</code></td>
<td>

<p>One of either &ldquo;nlminb&rdquo; or &ldquo;solnp&rdquo;. </p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control arguments passed to the fitting routine (as in the <code>ugarchfit</code>
method).</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_external.forecasts">external.forecasts</code></td>
<td>

<p>A list with forecasts for the external regressors in the mean and/or variance 
equations if specified.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>

<p>List of matrices (size of list n.bootpred, with each matrix having n.ahead rows) of 
simulated external regressor-in-mean data. If the fit object contains 
external regressors in the mean equation, this must be provided else will be
assumed zero.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_vexsimdata">vexsimdata</code></td>
<td>

<p>List of matrices (size of list n.bootpred, with each matrix having n.ahead rows) of 
simulated external regressor-in-variance data. If the fit object contains 
external regressors in the mean equation, this must be provided else will be
assumed zero.</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation
of the refits (remember to stop the cluster on completion).
</p>
</td></tr>
<tr><td><code id="ugarchboot-methods_+3A_verbose">verbose</code></td>
<td>

<p>Whether to print out progress messages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two main sources of uncertainty about n.ahead forecasting from GARCH 
models, namely that arising from the form of the predictive density and due to 
parameter estimation. The bootstrap method considered here, is based on 
resampling innovations from the empirical distribution of the fitted GARCH model 
to generate future realizations of the series and sigma. The &ldquo;full&rdquo; method, 
based on the referenced paper by Pascual et al (2006), takes into account 
parameter uncertainty by building a simulated distribution of the parameters 
through simulation and refitting. This process, while more accurate, is very time 
consuming which is why choice of parallel computation via a cluster (as in the 
<code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code> is available and recommended). The 
&ldquo;partial&rdquo; method, only considers distribution uncertainty and while faster, 
will not generate prediction intervals for the sigma 1-ahead forecast for which 
only the parameter uncertainty is relevant in GARCH type models.<br />
If using external regressors, the routine requires both the forecast (of length
n.ahead as in the <code><a href="#topic+ugarchforecast">ugarchforecast</a></code> routine) and a list
of simulated forecasts as in the <code><a href="#topic+ugarchsim">ugarchsim</a></code> routine (else with be 
assumed zero). Finally, it is possible to resample based on 3 schemes, namely 
the &ldquo;raw&rdquo; innovations as in the original paper of Pascual et al (2006),
&ldquo;kernel&rdquo; fits a Gaussian kernel to the innovations from the <code>ks</code>
package in order to then generate random samples, and the &ldquo;spd&rdquo; fits
a semi-parametric distribution to the innovations based on the <code>spd</code> 
package in order to generate the random samples, for which an optional list 
(<code>spd.options</code>) may be further passed to the spd fitting routine.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHboot-class">uGARCHboot</a></code> object containing details of the GARCH 
bootstrapped forecast density.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Pascual, L., Romo, J. and Ruiz, E. 2004, Bootstrap predictive inference for 
ARIMA processes, <em>Journal of Time Series Analysis</em>.<br />
Pascual, L., Romo, J. and Ruiz, E. 2006, Bootstrap prediction for returns and 
volatilities in GARCH models, <em>Computational Statistics and Data Analysis</em>.<br />
</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>, 
filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>, forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, 
simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>, rolling forecast and estimation 
<code><a href="#topic+ugarchroll">ugarchroll</a></code>, parameter distribution and uncertainty 
<code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(variance.model=list(model="gjrGARCH", garchOrder=c(1,1)), 
		mean.model=list(armaOrder=c(1,1), arfima=FALSE, include.mean=TRUE, 
		archm = FALSE, archpow = 1), distribution.model="std")
ctrl = list(tol = 1e-7, delta = 1e-9)
fit = ugarchfit(data=dji30ret[, "BA", drop = FALSE], out.sample = 0, 
				spec = spec, solver = "solnp", solver.control = ctrl,
				fit.control = list(scale = 1))
bootpred = ugarchboot(fit, method = "Partial", n.ahead = 120, n.bootpred = 2000)
bootpred
# as.data.frame(bootpred, which = "sigma", type = "q", qtile = c(0.01, 0.05))

## End(Not run)</code></pre>

<hr>
<h2 id='uGARCHdistribution-class'>class: Univariate GARCH Parameter Distribution Class</h2><span id='topic+uGARCHdistribution-class'></span><span id='topic+as.data.frame+2CuGARCHdistribution-method'></span><span id='topic+plot+2CuGARCHdistribution+2Cmissing-method'></span><span id='topic+show+2CuGARCHdistribution-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Parameter Distribution.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHdistribution-class">GARCHdistribution</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHdistribution&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "uGARCHdistribution")</code>: 
Extracts various values from object (see note).</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHdistribution", y = "missing")</code>: 
Parameter Distribution Plots. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHdistribution")</code>: 
Parameter Distribution Summary. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>as.data.frame</code> function takes optionally 2 additional arguments, 
namely <code>window</code> which indicates the particular distribution window number 
for which data is required (is usually just 1 unless the recursive option was 
used), and <code>which</code> indicating the type of data required. Valid values for 
the latter are &ldquo;rmse&rdquo; for the root mean squared error between simulation 
fit and actual parameters, &ldquo;stats&rdquo; for various statistics computed for 
the simulations such as log likelihood, persistence, unconditional variance and 
mean, &ldquo;coef&rdquo; for the estimated coefficients (i.e. the parameter 
distribution and is the default choice), and &ldquo;coefse&rdquo; for the estimated 
robust standard errors of the coefficients (i.e. the parameter standard error 
distribution).<br />
The plot method offers 4 plot types, namely, Parameter Density Plots (take 
<code>window</code> as additional argument), Bivariate Plots (take <code>window</code> as 
additional argument), Stats and RMSE (only when recursive option used) Plots.
The standard option for <code>which</code> is used, allowing for a numeric arguments 
to one of the four plot types else interactive choice via &ldquo;ask&rdquo;.</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHforecast-class">uGARCHforecast</a></code>, <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> and 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sp500ret)
spec = ugarchspec(variance.model=list(model="gjrGARCH", garchOrder=c(1,1)), 
		mean.model=list(armaOrder=c(1,1), arfima=FALSE, include.mean=TRUE, 
		archm = FALSE, archpow = 1), distribution.model="std")
		
fit = ugarchfit(data=sp500ret[, 1, drop = FALSE], out.sample = 0, 
				spec = spec, solver = "solnp")
	
dist = ugarchdistribution(fit, n.sim = 2000, n.start = 50, m.sim = 5)

## End(Not run)</code></pre>

<hr>
<h2 id='ugarchdistribution-methods'>function: Univariate GARCH Parameter Distribution via Simulation</h2><span id='topic+ugarchdistribution'></span><span id='topic+ugarchdistribution-methods'></span><span id='topic+ugarchdistribution+2CANY-method'></span><span id='topic+ugarchdistribution+2CuGARCHfit-method'></span><span id='topic+ugarchdistribution+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for simulating and estimating the parameter distribution from a variety 
of univariate GARCH models as well as the simulation based consistency of the 
estimators given the data size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchdistribution(fitORspec, n.sim = 2000, n.start = 1, 
m.sim = 100,  recursive = FALSE, recursive.length = 6000, recursive.window = 1000,
presigma = NA, prereturns = NA, preresiduals = NA, rseed = NA,
custom.dist = list(name = NA, distfit = NA), mexsimdata = NULL, vexsimdata = NULL, 
fit.control = list(), solver = "solnp", solver.control = list(), cluster = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchdistribution-methods_+3A_fitorspec">fitORspec</code></td>
<td>

<p>Either a univariate GARCH fit object of class <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> or
alternatively a univariate GARCH specification object of class <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> 
with valid parameters supplied via the <code>setfixed&lt;-</code> function in the 
specification.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_n.sim">n.sim</code></td>
<td>

<p>The simulation horizon.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_n.start">n.start</code></td>
<td>

<p>The burn-in sample.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_m.sim">m.sim</code></td>
<td>

<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_recursive">recursive</code></td>
<td>

<p>Whether to perform a recursive simulation on an expanding window.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_recursive.length">recursive.length</code></td>
<td>

<p>If <code>recursive</code> is TRUE, this indicates the final length of the simulation 
horizon, with starting length <code>n.sim</code>.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_recursive.window">recursive.window</code></td>
<td>

<p>If <code>recursive</code> is TRUE, this indicates the increment to the expanding 
window. Together with <code>recursive.length</code>, it determines the total number
of separate and increasing length windows which will be simulated and fitted.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_presigma">presigma</code></td>
<td>

<p>Allows the starting sigma values to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_prereturns">prereturns</code></td>
<td>

<p>Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_preresiduals">preresiduals</code></td>
<td>

<p>Allows the starting residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_rseed">rseed</code></td>
<td>

<p>Optional seeding value(s) for the random number generator.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_custom.dist">custom.dist</code></td>
<td>

<p>Optional density with fitted object from which to simulate.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>

<p>Matrix of simulated external regressor-in-mean data. If the fit object contains 
external regressors in the mean equation, this must be provided.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_vexsimdata">vexsimdata</code></td>
<td>

<p>Matrix of simulated external regressor-in-variance data. If the fit object 
contains external regressors in the variance equation, this must be provided.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_solver">solver</code></td>
<td>

<p>One of either &ldquo;nlminb&rdquo; or &ldquo;solnp&rdquo;. </p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control arguments passed to the fitting routine (as in the <code>ugarchfit</code>
method).</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation
of the refits (remember to stop the cluster on completion).
</p>
</td></tr>
<tr><td><code id="ugarchdistribution-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method facilitates the simulation and evaluation of the uncertainty of 
GARCH model parameters. The recursive option also allows the evaluation of the 
simulation based consistency (in terms of sqrt(N) ) of the parameters as the 
length (n.sim) of the data increases, in the sense of the root mean square error 
(rmse) of the difference  between the simulated and true (hypothesized) 
parameters.<br />
This is a very expensive function, particularly if using the <code>recursive</code> 
option, both on memory and cpu resources, performing many re-fits of the 
simulated data in order to generate the parameter distribution and it is 
therefore suggested that, if available, the parallel functionality should be 
used (in a system with ideally many cores and at least 4GB of RAM for the 
recursion option...).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHdistribution-class">uGARCHdistribution</a></code> object containing details of the GARCH 
simulated parameters distribution.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>, 
filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>, forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, 
simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>, rolling forecast and estimation <code><a href="#topic+ugarchroll">ugarchroll</a></code>, 
bootstrap forecast <code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>

<hr>
<h2 id='uGARCHfilter-class'>class: Univariate GARCH Filter Class</h2><span id='topic+uGARCHfilter-class'></span><span id='topic+coef+2CuGARCHfilter-method'></span><span id='topic+fitted+2CuGARCHfilter-method'></span><span id='topic+likelihood+2CuGARCHfilter-method'></span><span id='topic+infocriteria+2CuGARCHfilter-method'></span><span id='topic+newsimpact+2CuGARCHfilter-method'></span><span id='topic+signbias+2CuGARCHfilter-method'></span><span id='topic+gof+2CuGARCHfilter+2Cnumeric-method'></span><span id='topic+persistence+2CuGARCHfilter+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+halflife+2CuGARCHfilter+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+plot+2CuGARCHfilter+2Cmissing-method'></span><span id='topic+residuals+2CuGARCHfilter-method'></span><span id='topic+sigma+2CuGARCHfilter-method'></span><span id='topic+uncmean+2CuGARCHfilter-method'></span><span id='topic+quantile+2CuGARCHfilter-method'></span><span id='topic+pit+2CuGARCHfilter-method'></span><span id='topic+uncvariance+2CuGARCHfilter+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+show+2CuGARCHfilter-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH filter.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHfilter-class">GARCHfilter</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHfilter&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "uGARCHfilter")</code>: 
Extracts the fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "uGARCHfilter")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "uGARCHfilter")</code>:
Extracts the conditional sigma values.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "uGARCHfilter")</code>:
Extracts the coefficients.</p>
</dd>
<dt>infocriteria</dt><dd><p><code>signature(object = "uGARCHfilter")</code>: 
Calculates and returns various information criteria. </p>
</dd>
<dt>newsimpact</dt><dd><p><code>signature(object = "uGARCHfilter")</code>:
Calculates and returns the news impact curve.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "uGARCHfilter")</code>:
Extracts the likelihood.</p>
</dd>
<dt>signbias</dt><dd><p><code>signature(object = "uGARCHfilter")</code>: 
Calculates and returns the sign bias test of Engle and Ng (1993). </p>
</dd>
<dt>gof</dt><dd><p><code>signature(object = "uGARCHfilter", groups = "numeric")</code>: 
Calculates and returns the adjusted goodness of fit statistic and p-values 
for the fitted distribution based on the Vlaar and Palm paper (1993). 
Groups is a numeric vector of bin sizes.</p>
</dd>
<dt>persistence</dt><dd><p><code>signature(object = "uGARCHfilter", pars = "missing", 
distribution = "missing", model = "missing", submodel = "missing")</code>: 
Calculates and returns the persistence of the garch filter model.</p>
</dd>
<dt>halflife</dt><dd><p><code>signature(object = "uGARCHfilter", pars = "missing", 
distribution = "missing", model = "missing")</code>: 
Calculates and returns the halflife of the garch fit variance given a 
<code><a href="#topic+uGARCHfilter-class">uGARCHfilter</a></code> object.</p>
</dd>
<dt>uncmean</dt><dd><p><code>signature(object = "uGARCHfilter")</code>:
Calculates and returns the unconditional mean of the conditional mean 
equation (constant, ARMAX, arch-in-mean). </p>
</dd>
<dt>uncvariance</dt><dd><p><code>signature(object = "uGARCHfilter", pars = "missing", 
	distribution = "missing", model = "missing", submodel = "missing")</code>: 
Calculates and  returns the long run unconditional variance of the garch 
filter given a <code><a href="#topic+uGARCHfilter-class">uGARCHfilter</a></code> object.</p>
</dd>
<dt>quantile</dt><dd><p><code>signature(x = "uGARCHfilter")</code>: 
Calculates and returns, given a vector of probabilities (additional argument 
&ldquo;probs&rdquo;), the conditional quantiles of the filtered object (x).</p>
</dd>
<dt>pit</dt><dd><p><code>signature(object = "uGARCHfilter")</code>: 
Calculates and returns the conditional probability integral transform given the
data and estimated density.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHfilter", y = "missing")</code>:
Filter plots</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHfilter")</code>: 
Filter summary.</p>
</dd>
</dl>


<h3>Note</h3>

<p>The <code><a href="#topic+uGARCHfilter-class">uGARCHfilter</a></code> class contains almost all the methods 
available with the <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> with the exception of those 
requiring the scores of the likelihood (i.e the optimization process) such as 
the nyblom test.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
ctrl = list(rho = 1, delta = 1e-8, outer.iter = 100, inner.iter = 650, 
tol = 1e-6)
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)), 
		mean.model = list(armaOrder = c(1,1), include.mean = TRUE), 
		distribution.model = "std")
sgarch.fit = ugarchfit(data = dji30ret[,"AA",drop=FALSE], spec = spec, 
		solver = "solnp", solver.control = ctrl)
		
spec = ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1,1)), 
		mean.model = list(armaOrder = c(1,1), include.mean = TRUE), 
		distribution.model = "std", fixed.pars = as.list(coef(sgarch.fit)))
sgarch.filter = ugarchfilter(data = dji30ret[,"AA",drop=FALSE], spec = spec)

c(likelihood(sgarch.filter), likelihood(sgarch.fit))
c(uncmean(sgarch.filter), uncmean(sgarch.fit))
c(uncvariance(sgarch.filter), uncvariance(sgarch.fit))

## End(Not run)</code></pre>

<hr>
<h2 id='ugarchfilter-methods'>function: Univariate GARCH Filtering</h2><span id='topic+ugarchfilter'></span><span id='topic+ugarchfilter-methods'></span><span id='topic+ugarchfilter+2CANY-method'></span><span id='topic+ugarchfilter+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for filtering a variety of univariate GARCH models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchfilter(spec, data, out.sample = 0, n.old=NULL, rec.init = 'all',
trunclag = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchfilter-methods_+3A_data">data</code></td>
<td>

<p>A univariate data object. Can be a numeric vector, matrix, data.frame, zoo, xts,
timeSeries, ts or irts object.</p>
</td></tr>
<tr><td><code id="ugarchfilter-methods_+3A_spec">spec</code></td>
<td>

<p>A univariate GARCH spec object of class <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> with the
fixed.pars argument having the model parameters on which the filtering is
to take place.</p>
</td></tr>
<tr><td><code id="ugarchfilter-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>A positive integer indicating the number of periods before the last to keep for
out of sample forecasting (as in <code><a href="#topic+ugarchfit">ugarchfit</a></code> function).</p>
</td></tr>
<tr><td><code id="ugarchfilter-methods_+3A_n.old">n.old</code></td>
<td>

<p>For comparison with uGARCHfit models using the out.sample argument, this is the
length of the original dataset (see details).</p>
</td></tr>
<tr><td><code id="ugarchfilter-methods_+3A_rec.init">rec.init</code></td>
<td>
<p> The recursion initialization method (see <code><a href="#topic+ugarchfit">ugarchfit</a></code>
for explanation).</p>
</td></tr>
<tr><td><code id="ugarchfilter-methods_+3A_trunclag">trunclag</code></td>
<td>
<p> The truncation lags for the binomial expansion in the FIGARCH model.</p>
</td></tr>
<tr><td><code id="ugarchfilter-methods_+3A_...">...</code></td>
<td>
<p> For the multiplicative component sGARCH model (mcsGARCH), the
additional argument &lsquo;DailyVar&rsquo; is required and should be an xts object of
the daily forecasted variance to use with the intraday data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The n.old argument is optional and indicates the length of the original data (in
cases when this represents a series augmented by newer data). The reason for
using this is so that the old and new datasets agree since the original
recursion uses the sum of the residuals to start the recursion and therefore is
influenced by new data. For a small augmentation the values converge after x
periods, but it is sometimes preferable to have this option so that there is no
forward looking information contaminating the study.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHfilter-class">uGARCHfilter</a></code> object containing details of the GARCH filter.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>,
forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>,
rolling forecast and estimation <code><a href="#topic+ugarchroll">ugarchroll</a></code>, parameter distribution
and uncertainty <code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast
<code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sp500ret)
ctrl = list(RHO = 1,DELTA = 1e-8,MAJIT = 100,MINIT = 650,TOL = 1e-6)
spec = ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
		mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
		distribution.model = "std")
egarch.fit = ugarchfit(data = sp500ret[,1,drop=FALSE], spec = spec,
		solver = "solnp", solver.control = ctrl)

spec = ugarchspec(variance.model = list(model = "eGARCH", garchOrder = c(1,1)),
		mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
		distribution.model = "std", fixed.pars = as.list(coef(egarch.fit)))
egarch.filter = ugarchfilter(data = sp500ret[,1,drop=FALSE], spec = spec)

## End(Not run)</code></pre>

<hr>
<h2 id='uGARCHfit-class'>class: Univariate GARCH Fit Class</h2><span id='topic+uGARCHfit-class'></span><span id='topic+residuals+2CuGARCHfit-method'></span><span id='topic+fitted+2CuGARCHfit-method'></span><span id='topic+vcov+2CuGARCHfit-method'></span><span id='topic+coef+2CuGARCHfit-method'></span><span id='topic+confint+2CuGARCHfit-method'></span><span id='topic+infocriteria+2CuGARCHfit-method'></span><span id='topic+infocriteria+2CANY-method'></span><span id='topic+infocriteria'></span><span id='topic+nyblom+2CuGARCHfit-method'></span><span id='topic+nyblom+2CANY-method'></span><span id='topic+nyblom'></span><span id='topic+getspec+2CuGARCHfit-method'></span><span id='topic+getspec+2CANY-method'></span><span id='topic+getspec'></span><span id='topic+signbias+2CuGARCHfit-method'></span><span id='topic+signbias+2CANY-method'></span><span id='topic+signbias-methods'></span><span id='topic+signbias'></span><span id='topic+sigma+2CuGARCHfit-method'></span><span id='topic+sigma+2CANY-method'></span><span id='topic+sigma'></span><span id='topic+gof+2CANY+2CANY-method'></span><span id='topic+gof+2CuGARCHfit+2Cnumeric-method'></span><span id='topic+gof'></span><span id='topic+quantile+2CuGARCHfit-method'></span><span id='topic+pit+2CuGARCHfit-method'></span><span id='topic+pit+2CANY-method'></span><span id='topic+pit'></span><span id='topic+likelihood+2CuGARCHfit-method'></span><span id='topic+likelihood+2CANY-method'></span><span id='topic+likelihood'></span><span id='topic+newsimpact+2CANY-method'></span><span id='topic+newsimpact+2CuGARCHfit-method'></span><span id='topic+newsimpact'></span><span id='topic+halflife+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+halflife+2Cmissing+2Cnumeric+2Ccharacter+2Ccharacter+2CANY-method'></span><span id='topic+halflife+2CuGARCHfit+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+halflife'></span><span id='topic+persistence+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+persistence+2Cmissing+2Cnumeric+2Ccharacter+2Ccharacter+2CANY-method'></span><span id='topic+persistence+2CuGARCHfit+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+persistence'></span><span id='topic+uncvariance+2CANY+2CANY+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+uncvariance+2Cmissing+2Cnumeric+2Ccharacter+2Ccharacter+2CANY+2CANY-method'></span><span id='topic+uncvariance+2CuGARCHfit+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+uncvariance'></span><span id='topic+uncmean+2CuGARCHfit-method'></span><span id='topic+uncmean+2CANY-method'></span><span id='topic+uncmean'></span><span id='topic+convergence+2CuGARCHfit-method'></span><span id='topic+convergence+2CANY-method'></span><span id='topic+convergence'></span><span id='topic+reduce+2CuGARCHfit-method'></span><span id='topic+reduce+2CANY-method'></span><span id='topic+reduce'></span><span id='topic+plot+2CuGARCHfit+2Cmissing-method'></span><span id='topic+show+2CuGARCHfit-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH fit.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code><a href="#topic+GARCHfit-class">GARCHfit</a></code>, directly.
Class <code><a href="#topic+rGARCH-class">rGARCH</a></code>, by class <code><a href="#topic+GARCHfit-class">GARCHfit</a></code>, distance 2.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fit</code>:</dt><dd><p>Object of class <code>"vector"</code>
Holds data on the fitted model.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code>
The model specification common to all objects.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts the coefficients. </p>
</dd>
<dt>cofint</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Similar to the stats S3 method <code><a href="stats.html#topic+confint">confint</a></code>, extracts coefficient 
confidence intervals taking additional optional arguments <code>parm</code> and 
<code>level</code>, as well as <code>robust</code> (default: FALSE) indicating whether
to use the robust covariance matrix for the calculations.</p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts the covariance matrix of the parameters. Additional logical option of 
&lsquo;robust&rsquo; indicates whether to extract the robust based covariance matrix. </p>
</dd>
<dt>infocriteria</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Calculates and returns various information criteria. </p>
</dd>
<dt>nyblom</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Calculates and returns the Hansen-Nyblom stability test (1990). </p>
</dd>
<dt>gof</dt><dd><p><code>signature(object = "uGARCHfit", groups = "numeric")</code>: 
Calculates and returns the adjusted goodness of fit statistic and p-values 
for the fitted distribution based on the Vlaar and Palm paper (1993). Groups is 
a numeric vector of bin sizes.</p>
</dd>
<dt>newsimpact</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Calculates and returns the news impact curve.</p>
</dd>
<dt>signbias</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Calculates and returns the sign bias test of Engle and Ng (1993). </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts the likelihood. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts the conditional sigma values.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts the fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>getspec</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Extracts and returns the GARCH specification from a fit object.</p>
</dd>
<dt>uncvariance</dt><dd><p><code>signature(object = "uGARCHfit", pars = "missing", 
distribution="missing", model = "missing", vexdata = "missing")</code>: 
Calculates and returns the long run unconditional variance of the GARCH fit 
given a <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> object.</p>
</dd>
<dt>uncvariance</dt><dd><p><code>signature(object = "missing", pars = "numeric", 
distribution = "character", model = "character", submodel = "ANY", 
vexdata = "ANY")</code>: 
Calculates and returns the long run unconditional variance of the GARCH fit 
given a named parameter vector as returned by the fit, a distribution model 
name and a GARCH model name with a submodel included if the model is of the 
nested type such as fGARCH and any external regressor data.</p>
</dd>
<dt>uncmean</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Calculates and returns the unconditional mean of the conditional mean equation 
(constant, ARMAX, arch-in-mean). </p>
</dd>
<dt>persistence</dt><dd><p><code>signature(object = "uGARCHfit", pars = "missing", 
distribution = "missing", model = "missing")</code>: 
Calculates and returns the persistence of the GARCH fit model given a 
<code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> object.</p>
</dd>
<dt>persistence</dt><dd><p><code>signature(object = "missing", pars = "numeric", 
distribution = "character", model = "character")</code>: 
Calculates and returns the persistence of the GARCH fit model given a named 
parameter vector as returned by the fit, a distribution model name and a 
GARCH model name with a submodel included if the model is of the nested type 
such as fGARCH.</p>
</dd>
<dt>halflife</dt><dd><p><code>signature(object = "uGARCHfit", pars = "missing", 
distribution = "missing", model = "missing")</code>: 
Calculates and returns the halflife of the GARCH fit variance given a 
<code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> object.</p>
</dd>
<dt>halflife</dt><dd><p><code>signature(object = "missing", pars = "numeric", 
distribution = "character", model = "character")</code>: 
Calculates and returns the halflife of the GARCH fit variance given a named 
parameter vector as returned by the fit, a distribution model name and a 
GARCH model name with a submodel included if the model is of the nested 
type such as fGARCH.</p>
</dd>
<dt>convergence</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Returns the solver convergence code for the fitted object (zero denotes
convergence). </p>
</dd>
<dt>quantile</dt><dd><p><code>signature(x = "uGARCHfit")</code>: 
Calculates and returns, given a vector of probabilities (additional argument 
&ldquo;probs&rdquo;), the conditional quantiles of the fitted object (x).</p>
</dd>
<dt>pit</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Calculates and returns the conditional probability integral transform given the
data and estimated density.</p>
</dd>
<dt>reduce</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Zeros parameters (fixing to zero in rugarch is equivalent to eliminating them 
in estimation) with p-values (optional argument &ldquo;pvalue&rdquo;) greater 
than 0.1 (default), and re-estimates the model. Additional arguments are passed
to <code><a href="#topic+ugarchfit">ugarchfit</a></code>.An additional option &ldquo;use.robust&rdquo; (default TRUE) 
asks whether to use the robust calculated p-values.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHfit", y = "missing")</code>: 
Fit plots. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHfit")</code>: 
Fit summary. </p>
</dd>
</dl>



<h3>Note</h3>

<p>Methods for coef, likelihood, fitted, sigma and residuals provide extractor 
functions for those values.<br />
Method for show gives detailed summary of GARCH fit with various tests.<br />
Method for plot provides for interactive choice of plots, option of choosing
a particular plot (option &ldquo;which&rdquo; equal to a valid plot number) or a 
grand plot including all subplots on one page (option &ldquo;which&rdquo;=&ldquo;all&rdquo;).<br />
The infocriteria method calculates and returns the information criteria 
(AIC, BIC etc) of the GARCH fit.<br />
The nyblom method calculates and returns the Hansen-Nyblom joint and individual 
coefficient stability test statistic and critical values.<br />
The gof methods calculates and returns the adjusted goodness of fit statistic 
and p-values for the fitted distribution. The groups parameter is a numeric
vector of grouped bin sizes for the test. See the references in the package 
introduction for the original paper by Vlaar and Palm explaining the test.<br />
The signbias methods calculates and returns the sign bias test of Engle and Ng 
(see the references in the package introduction).<br />
Methods for calculating and extracting persistence, unconditional variance and
half-life of the GARCH shocks exist and take either the GARCH fit object as a 
single value otherwise you may provide a named parameter vector (see 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> section for parameter names of the various GARCH 
models), a distribution name and the GARCH model (with submodel argument for the 
fGARCH model).<br />
Unconditional mean and variance of the model may be extracted by means of the
uncmean and uncvariance methods. The uncvariance may take either a fit object or
a named parameter list, distribution and GARCH model name. The uncmean will only
take a fit object due to the complexity of the calculation requiring much more
information than the uncoditional variance.<br />
The news impact method returns a list with the calculated values (zx, zy) and 
the expression (xexpr, yexpr) which can be used to illustrate the plot.</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHforecast-class">uGARCHforecast</a></code>, <code><a href="#topic+uGARCHsim-class">uGARCHsim</a></code> and 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Basic GARCH(1,1) Spec
data(dmbp)
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec)
fit
# object fit:
slotNames(fit)
# sublist fit@fit
names(fit@fit)
coef(fit)
infocriteria(fit)
likelihood(fit)
nyblom(fit)
signbias(fit)
head(sigma(fit))
head(residuals(fit))
head(fitted(fit))
gof(fit,c(20,30,40,50))
uncmean(fit)
uncvariance(fit)
#plot(fit,which="all")
# news impact example
spec = ugarchspec(variance.model=list(model="apARCH"))
fit = ugarchfit(data = dmbp[,1], spec = spec)
# note that newsimpact does not require the residuals (z) as it
# will discover the relevant range to plot against by using the min/max
# of the fitted residuals.
ni=newsimpact(z = NULL, fit)
#plot(ni$zx, ni$zy, ylab=ni$yexpr, xlab=ni$xexpr, type="l", main = "News Impact Curve")

## End(Not run)</code></pre>

<hr>
<h2 id='ugarchfit-methods'>function: Univariate GARCH Fitting</h2><span id='topic+ugarchfit'></span><span id='topic+ugarchfit-methods'></span><span id='topic+ugarchfit+2CANY-method'></span><span id='topic+ugarchfit+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for fitting a variety of univariate GARCH models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchfit(spec, data, out.sample = 0, solver = "solnp", solver.control = list(),
fit.control = list(stationarity = 1, fixed.se = 0, scale = 0, rec.init = 'all',
trunclag = 1000),
numderiv.control = list(grad.eps=1e-4, grad.d=0.0001,
grad.zero.tol=sqrt(.Machine$double.eps/7e-7), hess.eps=1e-4, hess.d=0.1,
hess.zero.tol=sqrt(.Machine$double.eps/7e-7), r=4, v=2),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchfit-methods_+3A_data">data</code></td>
<td>

<p>A univariate data object. Can be a numeric vector, matrix, data.frame, zoo, xts,
timeSeries, ts or irts object.</p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_spec">spec</code></td>
<td>

<p>A univariate GARCH spec object of class <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.</p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>A positive integer indicating the number of periods before the last to keep for
out of sample forecasting (see details).</p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_solver">solver</code></td>
<td>

<p>One of either &ldquo;nlminb&rdquo;, &ldquo;solnp&rdquo;, &ldquo;lbfgs&rdquo;,
&ldquo;gosolnp&rdquo;, &ldquo;nloptr&rdquo; or &ldquo;hybrid&rdquo; (see notes). </p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control arguments list passed to optimizer.</p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control arguments passed to the fitting routine. Stationarity explicitly imposes
the variance stationarity constraint during optimization. For the FIGARCH model
this imposes the positivity constraint. The fixed.se argument
controls whether standard errors should be calculated for those parameters which
were fixed (through the fixed.pars argument of the <code><a href="#topic+ugarchspec">ugarchspec</a></code>
function). The scale parameter controls whether the data should be scaled before
being submitted to the optimizer. The rec.init option determines the type of
initialization for the variance recursion. Valid options are &lsquo;all&rsquo; which
uses all the values for the unconditional variance calculation, an integer
greater than or equal to 1 denoting the number of data points to use for the
calculation, or a positive numeric value less than one which determines the
weighting for use in an exponential smoothing backcast. The <code>trunclag</code> is the
truncation lags for the binomial expansion in the FIGARCH model.</p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_numderiv.control">numderiv.control</code></td>
<td>
<p>Control arguments passed to the numerical routines for the
calculation of the standard errors. See the documentation in the numDeriv package
for further details. The arguments which start with &lsquo;hess&rsquo; are passed to
the hessian routine while those with &lsquo;grad&rsquo; to the jacobian routine.</p>
</td></tr>
<tr><td><code id="ugarchfit-methods_+3A_...">...</code></td>
<td>
<p> For the multiplicative component sGARCH model (mcsGARCH), the
additional argument &lsquo;DailyVar&rsquo; is required and should be an xts object of
the daily forecasted variance to use with the intraday data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GARCH optimization routine first calculates a set of feasible starting
points which are used to initiate the GARCH recursion. The main part of the
likelihood calculation is performed in C-code for speed.<br />
The out.sample option is provided in order to carry out forecast performance
testing against actual data. A minimum of 5 data points are required for these
tests. If the out.sample option is positive, then the routine will fit only
N - out.sample (where N is the total data length) data points, leaving
out.sample points for forecasting and testing using the forecast performance
measures. In the <code><a href="#topic+ugarchforecast">ugarchforecast</a></code> routine the n.ahead may also be
greater than the out.sample number resulting in a combination of out of sample
data points matched against actual data and some without, which the forecast
performance tests will ignore.<br />
The &ldquo;gosolnp&rdquo; solver allows for the initialization of multiple restarts
of the solnp solver with randomly generated parameters (see documentation in
the Rsolnp-package for details of the strategy used). The solver.control list
then accepts the following additional (to the solnp) arguments: &ldquo;n.restarts&rdquo;
is the number of solver restarts required (defaults to 1), &ldquo;parallel&rdquo;
(logical), &ldquo;pkg&rdquo; (either snowfall or multicore) and &ldquo;cores&rdquo;
(the number of cores or workers to use) for use of parallel functionality,
&ldquo;rseed&rdquo; is the seed to initialize the random number generator, and
&ldquo;n.sim&rdquo; is the number of simulated parameter vectors to generate per
n.restarts.<br />
The &ldquo;hybrid&rdquo; strategy solver first tries the &ldquo;solnp&rdquo; solver, in
failing to converge then tries then &ldquo;nlminb&rdquo;, the &ldquo;gosolnp&rdquo; and
finally the &ldquo;nloptr&rdquo; solvers. Solver control parameters can be passed for
all the solvers in the solver.control list as one long list which will be
filtered for each solver's specific options as and when that solver is called
during the hybrid strategy optimization. It is still possible that the Hessian
at the optimal found cannot be inverted, in which case a warning is printed and
there will not be any standard errors. In this case it is suggested that the
problem is re-run with different solver parameters. It is also possible that the
solution, while still &lsquo;almost&rsquo; optimal may be at a saddle-point very near
the global optimum in which case the Hessian may still be invertible but one
eigenvalue is negative. The uGARCHfit object has a value in the fit slot
called condH (object@fit$condH) which indicates the approximate number of decimal
places lost to roundoff/numerical estimation error. When this is NaN, this
indicates the case just described of one negative eigenvalue/saddlepoint (this
previously flagged a warning but is now silenced and it is upto to the user to
decide whether it is worth investigating further).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> object containing details of the GARCH fit.
</p>


<h3>Note</h3>

<p>The nloptr solver takes the following options in the solver.control list:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> ftol_rel </td><td style="text-align: left;"> function value relative tolerance </td><td style="text-align: left;"> default: 1e-8</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> xtol_rel </td><td style="text-align: left;"> parameter value relative tolerance </td><td style="text-align: left;"> default: 1e-6</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> maxeval </td><td style="text-align: left;"> maximum function evaluations </td><td style="text-align: left;"> default: 25000</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> print_level </td><td style="text-align: left;"> trace level </td><td style="text-align: left;"> default: 1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> solver </td><td style="text-align: left;"> the nloptr solver to use </td><td style="text-align: left;"> default: 1 (&lsquo;SBPLX&rsquo;).</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The solver option for nloptr has 10 different choices (1:10), which are
1:&lsquo;COBYLA&rsquo;, 2:&lsquo;BOBYQA&rsquo;, 3:&lsquo;PRAXIS&rsquo;, 4:&lsquo;NELDERMEAD&rsquo;,
5:&lsquo;SBPLX&rsquo;, 6:&lsquo;AUGLAG&rsquo;+&lsquo;COBYLA&rsquo;,
7:&lsquo;AUGLAG&rsquo;+&lsquo;BOBYQA&rsquo;, 8:&lsquo;AUGLAG&rsquo;+&lsquo;PRAXIS&rsquo;,
9:&lsquo;AUGLAG&rsquo;+&lsquo;NELDERMEAD&rsquo; and 10:&lsquo;AUGLAG&rsquo;+&lsquo;SBPLX&rsquo;.
As always, your mileage will vary and care should be taken on the choice of
solver, tuning parameters etc. If you do use this solver try 9 or 10 first.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>,filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>,
forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>,
rolling forecast and estimation <code><a href="#topic+ugarchroll">ugarchroll</a></code>, parameter distribution
and uncertainty <code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast
<code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic GARCH(1,1) Spec
data(dmbp)
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec)
fit
coef(fit)
head(sigma(fit))
#plot(fit,which="all")
# in order to use fpm (forecast performance measure function)
# you need to select a subsample of the data:
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec, out.sample=100)
forc = ugarchforecast(fit, n.ahead=100)
# this means that 100 data points are left from the end with which to
# make inference on the forecasts
fpm(forc)
</code></pre>

<hr>
<h2 id='uGARCHforecast-class'>class: Univariate GARCH Forecast Class</h2><span id='topic+uGARCHforecast-class'></span><span id='topic+sigma+2CuGARCHforecast-method'></span><span id='topic+fitted+2CuGARCHforecast-method'></span><span id='topic+plot+2CuGARCHforecast+2Cmissing-method'></span><span id='topic+show+2CuGARCHforecast-method'></span><span id='topic+fpm'></span><span id='topic+fpm+2CANY-method'></span><span id='topic+fpm+2CuGARCHforecast-method'></span><span id='topic+quantile+2CuGARCHforecast-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH forecast.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code><a href="#topic+GARCHforecast-class">GARCHforecast</a></code>, directly.
Class <code><a href="#topic+rGARCH-class">rGARCH</a></code>, by class <code><a href="#topic+GARCHforecast-class">GARCHforecast</a></code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>sigma</dt><dd><p><code>signature(x = "uGARCHforecast")</code>: The n.ahead by n.roll+1
matrix of conditional sigma forecasts. The column names are the T[0] dates.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(x = "uGARCHforecast")</code>: The n.ahead by n.roll+1
matrix of conditional mean forecasts. The column names are the T[0] dates.</p>
</dd>
<dt>quantile</dt><dd><p><code>signature(x = "uGARCHforecast")</code>: 
Calculates and returns, given a scalar for the probability (additional argument 
&ldquo;probs&rdquo;), the conditional quantile of the forecast object as an
n.ahead by n.roll+1 matrix (with the same type of headings as the sigma and
fitted methods).</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHforecast", y = "missing")</code>:
Forecast plots with <code>n.roll</code> optional argument indicating the rolling 
sequence to plot. </p>
</dd>
<dt>fpm</dt><dd><p><code>signature(object = "uGARCHforecast")</code>: 
Forecast performance measures.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHforecast")</code>: 
Forecast summary returning the 0-roll frame only.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Since versions 1.01-3, a <code>sigma</code> and <code>fitted</code> methods have been introduced
which extract the n.ahead by (n.roll+1) matrix of conditional sigma and mean 
forecasts respectively, with column names the T[0] time index. This is unlike the
old <code>data.frame</code> which returned the T+1 etc dates. These two methods are the
default extractors in rugarch (used on estimated, filtered, forecast and 
simulation class objects) and the other methods, namely <code>as.data.frame</code> 
is now deprecated with the exception of a few classes where it is still used
(<code><a href="#topic+uGARCHdistribution-class">uGARCHdistribution</a></code>, <code><a href="#topic+uGARCHboot-class">uGARCHboot</a></code> 
and <code><a href="#topic+uGARCHroll-class">uGARCHroll</a></code>).<br />
The plot method takes additional arguments <code>which</code> and <code>n.roll</code> 
indicating which roll frame to plot.<br />
The fpm method returns the Mean Squared Error (MSE), Mean Absolute Error (MAE), 
Directional Accuracy (DAC) and number of points used for the calculation (N), of 
forecast versus realized returns, if the extra <code>summary</code> option is set 
to TRUE (default). This is a 4 x (n.roll+1) matrix, with row headings the T[0]
time index, and requires at least 5 points to calculate the summary measures else
will return NA. When n.ahead&gt;1, this method calculates the measures on the 
n.ahead&gt;1 unconditional forecast, but if n.ahead=1 with n.roll&gt;4, it will 
calculate the measures on the rolling forecast instead. Finally, when summary
is set to FALSE, the method will return a list of length n.roll+1 of xts objects
with the loss functions (Squared Error and Absolute Error and Directional Hits).
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code>, <code><a href="#topic+uGARCHsim-class">uGARCHsim</a></code> and 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Basic GARCH(1,1) Spec
data(dmbp)
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec, out.sample = 100)
forc1 = ugarchforecast(fit, n.ahead=100, n.roll = 100)
forc
#plot(forc, which = "all")

## End(Not run)</code></pre>

<hr>
<h2 id='ugarchforecast-methods'>function: Univariate GARCH Forecasting</h2><span id='topic+ugarchforecast'></span><span id='topic+ugarchforecast-methods'></span><span id='topic+ugarchforecast+2CANY-method'></span><span id='topic+ugarchforecast+2CuGARCHfit-method'></span><span id='topic+ugarchforecast+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for forecasting from a variety of univariate GARCH models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchforecast(fitORspec, data = NULL, n.ahead = 10, n.roll = 0, out.sample = 0,
		external.forecasts = list(mregfor = NULL, vregfor = NULL),
		trunclag = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchforecast-methods_+3A_fitorspec">fitORspec</code></td>
<td>

<p>Either a univariate GARCH fit object of class <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> or
alternatively a univariate GARCH specification object of class
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> with valid fixed parameters.</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_data">data</code></td>
<td>

<p>Required if a specification rather than a fit object is supplied.</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The forecast horizon.</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_n.roll">n.roll</code></td>
<td>

<p>The no. of rolling forecasts to create beyond the first one (see details).</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_out.sample">out.sample</code></td>
<td>

<p>Optional. If a specification object is supplied, indicates how many data points
to keep for out of sample testing.</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_external.forecasts">external.forecasts</code></td>
<td>

<p>A list with forecasts for the external regressors in the mean and/or variance
equations if specified.</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_trunclag">trunclag</code></td>
<td>

<p>The truncation lag for the binomial expansion in the FIGARCH model. Only used
when the dispatch is based on a <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> object, otherwise
will be read from the already defined value in the fitted object.
</p>
</td></tr>
<tr><td><code id="ugarchforecast-methods_+3A_...">...</code></td>
<td>
<p>For the multiplicative component sGARCH model (mcsGARCH), the
additional argument &lsquo;DailyVar&rsquo; is required and should be an xts object of
the daily forecasted variance for the period under consideration to be used
with the intraday data.<br />
For the realized GARCH model (realGARCH), the additional argument
&lsquo;RealizedVol&rsquo;, an xts object, is required when using a specification
object for fitORspec. Additionally, the optional argument &lsquo;n.sim&rsquo; denotes
the number of simulations required for n.ahead&gt;1 forecast (see vignette for this
model's representation), whilst &lsquo;returnDistribution&rsquo; is a logical argument
(default TRUE) denoting whether to return the simulated distribution of the
sigma and realized forecast values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forecast function has two dispatch methods allowing the user to call it with
either a fitted object (in which case the data argument is ignored), or a
specification object (in which case the data is required) with fixed parameters.<br />
The forecast is based on the expected value of the innovations and hence the
density chosen. One step ahead forecasts are based on the value of the previous
data, while n-step ahead (n&gt;1) are based on the unconditional expectation of the
models.<br />
The ability to roll the forecast 1 step at a time is implemented with the
<code>n.roll</code> argument which controls how many times to roll the n.ahead
forecast. The default argument of n.roll = 0 denotes no rolling and returns the
standard n.ahead forecast. Critically, since n.roll depends on data being
available from which to base the rolling forecast, the <code><a href="#topic+ugarchfit">ugarchfit</a></code>
function needs to be called with the argument <code>out.sample</code> being at least
as large as the n.roll argument, or in the case of a specification being used
instead of a fit object, the <code>out.sample</code> argument directly in the forecast
function.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHforecast-class">uGARCHforecast</a></code> object containing details of the GARCH
forecast. See the class for details on the returned object and methods for
accessing it and performing some tests.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>,simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>,
rolling forecast and estimation <code><a href="#topic+ugarchroll">ugarchroll</a></code>, parameter distribution
and uncertainty <code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast
<code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Basic GARCH(1,1) Spec
data(dmbp)
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec)
forc = ugarchforecast(fit, n.ahead=20)
forc
head(sigma(forc))
head(fitted(forc))
#plot(forc,which="all")

## End(Not run)</code></pre>

<hr>
<h2 id='uGARCHmultifilter-class'>class: Univariate GARCH Multiple Filter Class</h2><span id='topic+uGARCHmultifilter-class'></span><span id='topic+coef+2CuGARCHmultifilter-method'></span><span id='topic+fitted+2CuGARCHmultifilter-method'></span><span id='topic+likelihood+2CuGARCHmultifilter-method'></span><span id='topic+residuals+2CuGARCHmultifilter-method'></span><span id='topic+sigma+2CuGARCHmultifilter-method'></span><span id='topic+show+2CuGARCHmultifilter-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Multiple filter.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHfilter-class">GARCHfilter</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHfilter&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>fitted</dt><dd><p><code>signature(object = "uGARCHmultifilter")</code>:
Extracts the fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "uGARCHmultifilter")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "uGARCHmultifilter")</code>:
Extracts the conditional sigma values.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "uGARCHmultifilter")</code>:
Extracts the coefficients.</p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "uGARCHmultifilter")</code>:
Extracts the likelihood. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHmultifilter")</code>: 
Filter summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHmultiforecast-class">uGARCHmultiforecast</a></code>, <code><a href="#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> 
and <code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code>.
</p>

<hr>
<h2 id='uGARCHmultifit-class'>class: Univariate GARCH Multiple Fit Class</h2><span id='topic+uGARCHmultifit-class'></span><span id='topic+residuals+2CuGARCHmultifit-method'></span><span id='topic+fitted+2CuGARCHmultifit-method'></span><span id='topic+coef+2CuGARCHmultifit-method'></span><span id='topic+show+2CuGARCHmultifit-method'></span><span id='topic+sigma+2CuGARCHmultifit-method'></span><span id='topic+likelihood+2CuGARCHmultifit-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Multiple fit.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code><a href="#topic+GARCHfit-class">GARCHfit</a></code>, directly.
Class <code><a href="#topic+rGARCH-class">rGARCH</a></code>, by class <code><a href="#topic+GARCHfit-class">GARCHfit</a></code>, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p><code>signature(object = "uGARCHmultifit")</code>: 
Extracts the coefficients. </p>
</dd>
<dt>likelihood</dt><dd><p><code>signature(object = "uGARCHmultifit")</code>: 
Extracts the likelihood. </p>
</dd>
<dt>sigma</dt><dd><p><code>signature(object = "uGARCHmultifit")</code>: 
Extracts the conditional sigma values.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "uGARCHmultifit")</code>: 
Extracts the fitted values.</p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "uGARCHmultifit")</code>: 
Extracts the residuals. Optional logical argument <code>standardize</code> 
(default is FALSE) allows to extract the standardized residuals.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHmultifit")</code>: 
Fit summary.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Methods for coef, likelihood, fitted, sigma and residuals provide extractor 
functions for those values.<br /></p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHmultiforecast-class">uGARCHmultiforecast</a></code>, <code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code> 
and <code><a href="#topic+uGARCHmultifilter-class">uGARCHmultifilter</a></code>.
</p>

<hr>
<h2 id='uGARCHmultiforecast-class'>class: Univariate GARCH Multiple Forecast Class</h2><span id='topic+uGARCHmultiforecast-class'></span><span id='topic+sigma+2CuGARCHmultiforecast-method'></span><span id='topic+fitted+2CuGARCHmultiforecast-method'></span><span id='topic+show+2CuGARCHmultiforecast-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Multiple forecast.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code><a href="#topic+GARCHforecast-class">GARCHforecast</a></code>, directly.
Class <code><a href="#topic+rGARCH-class">rGARCH</a></code>, by class <code><a href="#topic+GARCHforecast-class">GARCHforecast</a></code>, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>sigma</dt><dd><p><code>signature(x = "uGARCHmultiforecast")</code>: 
extracts the n.ahead by (n.roll+1) by n.assets array of conditional sigma 
forecasts.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(x = "uGARCHforecast")</code>: 
extracts the n.ahead by (n.roll+1) by n.assets array of conditional mean
forecasts.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHforecast")</code>: forecast summary.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHmultifilter-class">uGARCHmultifilter</a></code>, <code><a href="#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> and 
<code><a href="#topic+uGARCHmultispec-class">uGARCHmultispec</a></code>.
</p>

<hr>
<h2 id='uGARCHmultispec-class'>class: Univariate GARCH Multiple Specification Class</h2><span id='topic+show+2CuGARCHmultispec-method'></span><span id='topic+uGARCHmultispec-class'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Multiple specification.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHspec-class">GARCHspec</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHspec&quot;, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "uGARCHmultispec")</code>: specification summary. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHmultiforecast-class">uGARCHmultiforecast</a></code>, <code><a href="#topic+uGARCHmultifit-class">uGARCHmultifit</a></code> and <code><a href="#topic+uGARCHmultifilter-class">uGARCHmultifilter</a></code>.
</p>

<hr>
<h2 id='uGARCHpath-class'>class: Univariate GARCH Path Simulation Class</h2><span id='topic+uGARCHpath-class'></span><span id='topic+sigma+2CuGARCHpath-method'></span><span id='topic+fitted+2CuGARCHpath-method'></span><span id='topic+quantile+2CuGARCHpath-method'></span><span id='topic+plot+2CuGARCHpath+2Cmissing-method'></span><span id='topic+show+2CuGARCHpath-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH Path simulation.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+uGARCHpath-class">uGARCHpath</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHpath&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>sigma</dt><dd><p><code>signature(object = "uGARCHpath")</code>: 
Extracts the conditional sigma simulated values as a matrix of size n.sim x m.sim.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "uGARCHpath")</code>: 
Extracts the conditional mean simulated values as a matrix of size n.sim x m.sim.</p>
</dd>
<dt>quantile</dt><dd><p><code>signature(x = "uGARCHpath")</code>: 
Calculates and returns, given a scalar for the probability (additional argument 
&ldquo;probs&rdquo;), the conditional quantile of the simulated object as an
n.sim by m.sim matrix (with the same type of headings as the sigma and
fitted methods).</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHpath", y = "missing")</code>: path simulation plots. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHpath")</code>: path simulation summary. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>sigma</code> and <code>fitted</code> methods are used to extract the matrix of 
simulated conditional sigma and mean values. The <code>as.data.frame</code>
method is globally deprecated as an extractor method in rugarch with the 
exception of a few classes which still makes sense to use them.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHsim-class">uGARCHsim</a></code>, <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> and 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.
</p>

<hr>
<h2 id='ugarchpath-methods'>function: Univariate GARCH Path Simulation</h2><span id='topic+ugarchpath'></span><span id='topic+ugarchpath-methods'></span><span id='topic+ugarchpath+2CANY-method'></span><span id='topic+ugarchpath+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for simulating the path of a GARCH model from a variety of univariate
GARCH models. This is a convenience function which does not require a fitted
object (see note below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchpath(spec, n.sim=1000, n.start=0, m.sim=1, presigma=NA, prereturns=NA,
preresiduals=NA, rseed=NA, custom.dist=list(name=NA,distfit=NA), mexsimdata=NULL,
vexsimdata=NULL, trunclag=1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchpath-methods_+3A_spec">spec</code></td>
<td>

<p>A univariate GARCH spec object of class <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> with
the required parameters of the model supplied via the fixed.pars list argument
or <code><a href="#topic+setfixed+3C-">setfixed&lt;-</a></code> method.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_n.sim">n.sim</code></td>
<td>

<p>The simulation horizon.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_n.start">n.start</code></td>
<td>

<p>The burn-in sample.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_m.sim">m.sim</code></td>
<td>

<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_presigma">presigma</code></td>
<td>

<p>Allows the starting sigma values to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_prereturns">prereturns</code></td>
<td>

<p>Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_preresiduals">preresiduals</code></td>
<td>

<p>Allows the starting residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_rseed">rseed</code></td>
<td>

<p>Optional seeding value(s) for the random number generator. For m.sim&gt;1, it is
possible to provide either a single seed to initialize all values, or one seed
per separate simulation (i.e. m.sim seeds). However, in the latter case this may
result in some slight overhead depending on how large m.sim is.
It is now recommended not to provide a value (i.e., keep the default of
<code>rseed == NA</code>) and to call <code>set.seed</code> only once in the beginning of
the session, which will ensure reproducibility.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_custom.dist">custom.dist</code></td>
<td>
<p> Optional density with fitted object from which to simulate.
See notes below for details.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>

<p>List of matrices (size of list m.sim, with each matrix having n.sim rows) of
simulated external regressor-in-mean data. If the fit object contains
external regressors in the mean equation, this must be provided else will be
assumed zero.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_vexsimdata">vexsimdata</code></td>
<td>

<p>List of matrices (size of list m.sim, with each matrix having n.sim rows) of
simulated external regressor-in-variance data. If the fit object contains
external regressors in the variance equation, this must be provided else will be
assumed zero.</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_trunclag">trunclag</code></td>
<td>

<p>This is the truncation lags for the binomial expansion in the FIGARCH model
</p>
</td></tr>
<tr><td><code id="ugarchpath-methods_+3A_...">...</code></td>
<td>
<p> If the model is the &ldquo;csGARCH&rdquo;, then <code>preq</code> can be used
to denote the previous value of the permanent component of the variance model
(q, e.g. tail(fit@fit$q,1)) so that the ugarchpath method with all pre-values
included will evaluate to the same result as the ugarchsim method with method
equal to &ldquo;sample&rdquo; (assuming the same random seeding values are used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience method to allow path simulation of various GARCH models
without the need to supply a fit object as in the <code><a href="#topic+ugarchsim">ugarchsim</a></code> method.
Instead, a GARCH spec object is required with the fixed model parameters.
The mcsGARCH model is not supported for the path method-use <code><a href="#topic+ugarchsim">ugarchsim</a></code>
instead.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHpath-class">uGARCHpath</a></code> object containing details of the GARCH path
simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>,
filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>, forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>,
simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>, rolling forecast and estimation
<code><a href="#topic+ugarchroll">ugarchroll</a></code>, parameter distribution and uncertainty
<code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast <code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# create a basic sGARCH(1,1) spec:
spec=ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
		mean.model=list(armaOrder=c(0,0), include.mean=TRUE, garchInMean =
		FALSE, inMeanType = 2), distribution.model="sstd",
		fixed.pars=list(mu=0.001,omega=0.00001, alpha1=0.05, beta1=0.90,
		shape=4,skew=2))
# simulate the path
path.sgarch = ugarchpath(spec, n.sim=3000, n.start=1, m.sim=1)

## End(Not run)</code></pre>

<hr>
<h2 id='uGARCHroll-class'>class: Univariate GARCH Rolling Forecast Class</h2><span id='topic+uGARCHroll-class'></span><span id='topic+as.data.frame+2CuGARCHroll-method'></span><span id='topic+plot+2CuGARCHroll+2Cmissing-method'></span><span id='topic+report+2CuGARCHroll-method'></span><span id='topic+show+2CuGARCHroll-method'></span><span id='topic+report+2CANY-method'></span><span id='topic+report'></span><span id='topic+resume+2CANY-method'></span><span id='topic+resume'></span><span id='topic+resume+2CuGARCHroll-method'></span><span id='topic+fpm+2CuGARCHroll-method'></span><span id='topic+quantile+2CuGARCHroll-method'></span><span id='topic+pit+2CuGARCHroll-method'></span><span id='topic+convergence+2CuGARCHroll-method'></span><span id='topic+coef+2CuGARCHroll-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH rolling forecast.</p>


<h3>Slots</h3>


<dl>
<dt><code>forecast</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHroll-class">GARCHroll</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHroll&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>as.data.frame</dt><dd><p><code>signature(x = "uGARCHroll")</code>: 
Extracts various values from object (see note).</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHroll", y = "missing")</code>:
Roll result backtest plots (see note).</p>
</dd>
<dt>report</dt><dd><p><code>signature(object = "uGARCHroll")</code>:
Roll backtest reports (see note).</p>
</dd>
<dt>resume</dt><dd><p><code>signature(object = "uGARCHroll")</code>:
Resumes a rolling backtest which has non-converged windows using 
alternative solver and control parameters.</p>
</dd>
<dt>fpm</dt><dd><p><code>signature(object = "uGARCHroll")</code>: 
Forecast performance measures.</p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "uGARCHroll")</code>: 
Extracts the list of coefficients for each estimated window in the 
rolling backtest.</p>
</dd>
<dt>quantile</dt><dd><p><code>signature(x = "uGARCHroll")</code>: 
Calculates and returns, given a vector of probabilities (additional argument 
&ldquo;probs&rdquo;), the conditional quantiles of the rolling object as an
xts matrix.</p>
</dd>
<dt>pit</dt><dd><p><code>signature(object = "uGARCHroll")</code>: 
Calculates and returns the conditional probability integral transform given the 
realized data and forecast density.</p>
</dd>
<dt>convergence</dt><dd><p><code>signature(object = "uGARCHroll")</code>: 
Returns the convergence code for the estimation windows, with 0 indicating
that all have converged and 1 that there were non-converged windows. In 
the latter case the &lsquo;nonconverged&rsquo; attribute is also printed of those 
windows which failed to converge.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHroll")</code>:
Summary.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>as.data.frame</code> extractor method allows the extraction of either the
conditional forecast density or the VaR. It takes additional argument
<code>which</code> with valid values either &ldquo;density&rdquo; or &ldquo;VaR&rdquo;.<br />
The <code>coef</code> method will return a list of the coefficients and their robust 
standard errors (assuming the keep.coef argument was set to TRUE in the 
ugarchroll function), and the ending date of each estimation window.<br />
The <code>plot</code> method takes the following additional arguments:<br />
1.<em>which</em> allows for either a numeric value of 1:4, else will default to 
&ldquo;ask&rdquo; for interactive printing of the options in the command windows.
Additionally, the value of &ldquo;all&rdquo; wil create a 2x2 chart with all plots.<br />
2.<em>VaR.alpha</em> for the Value at Risk backtest plot, this is the tail 
probability and defaults to 0.01.<br />
3.<em>density.support</em> the support for the time varying density plot density, 
defaults to c(-0.15, 0.15) but you should change this to something more 
appropriate for your data and period under consideration.<br />
The <code>report</code> method takes the following additional arguments:<br />
1.<em>type</em> for the report type. Valid values are &ldquo;VaR&rdquo; for the VaR
report based on the unconditional and conditional coverage tests for exceedances 
(discussed below) and &ldquo;fpm&rdquo; for forecast performance measures.<br />
2.<em>VaR.alpha</em> (for the VaR backtest report) is the tail probability and 
defaults to 0.01.<br />
3.<em>conf.level</em> the confidence level upon which the conditional coverage 
hypothesis test will be based on (defaults to 0.95).<br />
Kupiec's unconditional coverage test looks at whether the amount of expected 
versus actual exceedances given the tail probability of VaR actually occur as 
predicted, while the conditional coverage test of Christoffersen is a joint test 
of the unconditional coverage and the independence of the exceedances. Both the 
joint and the separate unconditional test are reported since it is always 
possible that the joint test passes while failing either the independence or 
unconditional coverage test.
The <code>fpm</code> method (separately from report) takes additional logical argument 
<em>summary</em>, which when TRUE will return the mean squared error (MSE), 
mean absolute error (MAE) and directional accuracy of the forecast versus 
realized returns. When FALSE, it will return a data.frame of the time series 
of squared (SE) errors, absolute errors (AE), directional hits (HITS), and a
VaR Loss function described in Gonzalez-Rivera, Lee, and Mishra (2004)
for each coverage level where it was calculated. This can then be compared, with
the VaR loss of competing models using such tests as the model confidence set 
(MCS) of Hansen, Lunde and Nason (2011).
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='ugarchroll-methods'>function: Univariate GARCH Rolling Density Forecast and Backtesting</h2><span id='topic+ugarchroll'></span><span id='topic+ugarchroll-methods'></span><span id='topic+ugarchroll+2CANY-method'></span><span id='topic+ugarchroll+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Method for creating rolling density forecast from ARMA-GARCH models with option
for refitting every n periods with parallel functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchroll(spec, data, n.ahead = 1, forecast.length = 500, 
n.start = NULL, refit.every = 25, refit.window = c("recursive", "moving"), 
window.size = NULL, solver = "hybrid", fit.control = list(), 
solver.control = list(), calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.05), 
cluster = NULL, keep.coef = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchroll-methods_+3A_spec">spec</code></td>
<td>

<p>A univariate GARCH specification object.</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_data">data</code></td>
<td>

<p>A univariate dataset, ideally with time based index.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_n.ahead">n.ahead</code></td>
<td>

<p>The number of periods to forecast (only n.ahead=1 supported).
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_forecast.length">forecast.length</code></td>
<td>

<p>The length of the total forecast for which out of sample data 
from the dataset will be used for testing.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_n.start">n.start</code></td>
<td>

<p>Instead of forecast.length, this determines the starting point in the dataset
from which to initialize the rolling forecast.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_refit.every">refit.every</code></td>
<td>

<p>Determines every how many periods the model is re-estimated.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_refit.window">refit.window</code></td>
<td>

<p>Whether the refit is done on an expanding window including all the previous data 
or a moving window where all previous data is used for the first estimation 
and then moved by a length equal to refit.every (unless the window.size option 
is used instead).
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_window.size">window.size</code></td>
<td>

<p>If not NULL, determines the size of the moving window in the rolling estimation,
which also determines the first point used.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_solver">solver</code></td>
<td>

<p>The solver to use.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_fit.control">fit.control</code></td>
<td>

<p>Control parameters parameters passed to the fitting function.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_solver.control">solver.control</code></td>
<td>

<p>Control parameters passed to the solver.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_calculate.var">calculate.VaR</code></td>
<td>

<p>Whether to calculate forecast Value at Risk during the estimation.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_var.alpha">VaR.alpha</code></td>
<td>

<p>The Value at Risk tail level to calculate.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_cluster">cluster</code></td>
<td>

<p>A cluster object created by calling <code>makeCluster</code> from the parallel 
package. If it is not NULL, then this will be used for parallel estimation
of the refits (remember to stop the cluster on completion).
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_keep.coef">keep.coef</code></td>
<td>

<p>Whether to return the list of coefficients and their robust standard errors.
</p>
</td></tr>
<tr><td><code id="ugarchroll-methods_+3A_...">...</code></td>
<td>
<p> In the case of the realized GARCH (realGARCH) model, the &lsquo;realizedVol&rsquo; is
required (an xts object), and optionally the &lsquo;n.sim&rsquo; argument indicates the samples
to generate for the realized vol forecast (does not affect the 1-ahead sigma forecast).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function for creating rolling forecasts of the conditional
GARCH density, and optionally calculating the Value at Risk at specified levels.
The argument <code>refit.every</code> determines every how many periods the model is
re-estimated. Given a dataset of length N, it is possible to choose either
how many periods from the end to use for out of sample forecasting (using the
forecast.length option), or the starting point for initializing the rolling
forecast (and using all the data after that for the out of sample forecast).
Only rolling 1-ahead forecasts are supported spanning the dataset, which should
be useful for backtesting models. Anything more complicated should be wrapped by 
the user by making use of the underlying functions in the package.
The function has 2 main methods for viewing the data, a standard plot method and
a report methods (see class <code><a href="#topic+uGARCHroll-class">uGARCHroll</a></code> for details on 
how to use these methods).
In case of no-convergence in some of all the windows, a new method called 
<code><a href="#topic+resume">resume</a></code> now allows to pass the returned (non-converged) object with
new solver and control parameters to be re-estimated (only the non-converged
windows are re-estimated). Non-convergence here implies both a failure of the
solver to converge to a solution (global failure) OR a failure to invert the 
resulting Hessian (local failure). The <code>convergence</code> method can be used
on an object (aside from the printed warning) to print out the number of the
non-converged estimation windows.<br />
Parallel functionality is now based entirely on the parallel package, and it is
up to the user to pass a cluster object, and then stop it once the routine is
completed.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+uGARCHroll-class">uGARCHroll</a></code>.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>, 
filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>, forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, 
simulation <code><a href="#topic+ugarchsim">ugarchsim</a></code>, parameter distribution and uncertainty 
<code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast <code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sp500ret)
spec = ugarchspec(distribution.model = "std")
mod = ugarchroll(spec, data = sp500ret, n.ahead = 1, 
n.start = 1000,  refit.every = 500, refit.window = "recursive", 
solver = "hybrid", fit.control = list(),
calculate.VaR = TRUE, VaR.alpha = c(0.01, 0.025, 0.05),
keep.coef = TRUE)
report(mod, type="VaR", VaR.alpha = 0.01, conf.level = 0.95) 
report(mod, type="fpm")

## End(Not run)</code></pre>

<hr>
<h2 id='uGARCHsim-class'>class: Univariate GARCH Simulation Class</h2><span id='topic+uGARCHsim-class'></span><span id='topic+sigma+2CuGARCHsim-method'></span><span id='topic+fitted+2CuGARCHsim-method'></span><span id='topic+quantile+2CuGARCHsim-method'></span><span id='topic+plot+2CuGARCHsim+2Cmissing-method'></span><span id='topic+show+2CuGARCHsim-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH simulation.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHsim-class">GARCHsim</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHsim&quot;, distance 2.
</p>


<h3>Slots</h3>


<dl>
<dt><code>simulation</code>:</dt><dd><p>Object of class <code>"vector"</code>
Holds data on the simulation.</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code>
The model specification common to all objects.</p>
</dd>
<dt><code>seed</code>:</dt><dd><p>Object of class <code>"integer"</code>
The random seed used.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>sigma</dt><dd><p><code>signature(object = "uGARCHsim")</code>: 
Extracts the conditional sigma simulated values as a matrix of size n.sim x m.sim.</p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "uGARCHsim")</code>: 
Extracts the conditional mean simulated values as a matrix of size n.sim x m.sim.</p>
</dd>
<dt>quantile</dt><dd><p><code>signature(object = "uGARCHsim", probs="numeric")</code>: 
Calculates and returns, given a scalar for the probability (additional argument 
&ldquo;probs&rdquo;), the conditional quantile of the simulated object as an
n.sim by m.sim matrix (with the same type of headings as the sigma and
fitted methods).</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "uGARCHsim", y = "missing")</code>: 
Simulation plots. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "uGARCHsim")</code>: 
Simulation summary. </p>
</dd>
</dl>



<h3>Note</h3>

<p>The <code>sigma</code> and <code>fitted</code> methods are used to extract the matrix of 
simulated conditional sigma and mean values. The <code>as.data.frame</code>
method is globally deprecated as an extractor method in rugarch with the 
exception of a few classes which still makes sense to use them.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHforecast-class">uGARCHforecast</a></code>, <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> and 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Basic GARCH(1,1) Spec
data(dmbp)
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec)
sim = ugarchsim(fit,n.sim=1000, n.start=1, m.sim=1, startMethod="sample")
sim
head(sigma(sim))

## End(Not run)</code></pre>

<hr>
<h2 id='ugarchsim-methods'>function: Univariate GARCH Simulation</h2><span id='topic+ugarchsim'></span><span id='topic+ugarchsim-methods'></span><span id='topic+ugarchsim+2CANY-method'></span><span id='topic+ugarchsim+2CuGARCHfit-method'></span>

<h3>Description</h3>

<p>Method for simulation from a variety of univariate GARCH models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchsim(fit, n.sim = 1000, n.start = 0, m.sim = 1, 
startMethod = c("unconditional", "sample"), presigma = NA, prereturns = NA, 
preresiduals = NA, rseed = NA, custom.dist = list(name = NA, distfit = NA), 
mexsimdata = NULL, vexsimdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchsim-methods_+3A_fit">fit</code></td>
<td>

<p>A univariate GARCH fit object of class <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code>.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_n.sim">n.sim</code></td>
<td>

<p>The simulation horizon.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_n.start">n.start</code></td>
<td>

<p>The burn-in sample.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_m.sim">m.sim</code></td>
<td>

<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_startmethod">startMethod</code></td>
<td>

<p>Starting values for the simulation. Valid methods are &ldquo;unconditional&rdquo; for 
the expected values given the density, and &ldquo;sample&rdquo; for the ending values 
of the actual data from the fit object.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_presigma">presigma</code></td>
<td>

<p>Allows the starting sigma values to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_prereturns">prereturns</code></td>
<td>

<p>Allows the starting return data to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_preresiduals">preresiduals</code></td>
<td>

<p>Allows the starting residuals to be provided by the user.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_rseed">rseed</code></td>
<td>

<p>Optional seeding value(s) for the random number generator. For m.sim&gt;1, it is 
possible to provide either a single seed to initialize all values, or one seed 
per separate simulation (i.e. m.sim seeds). However, in the latter case this may 
result in some slight overhead depending on how large m.sim is.
It is now recommended not to provide a value (i.e., keep the default of
<code>rseed == NA</code>) and to call <code>set.seed</code> only once in the beginning of
the session, which will ensure reproducibility.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_custom.dist">custom.dist</code></td>
<td>

<p>Optional density with fitted object from which to simulate. See notes below for 
details.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_mexsimdata">mexsimdata</code></td>
<td>

<p>List of matrices (size of list m.sim, with each matrix having n.sim rows) of 
simulated external regressor-in-mean data. If the fit object contains 
external regressors in the mean equation, this must be provided else will be
assumed zero.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_vexsimdata">vexsimdata</code></td>
<td>

<p>List of matrices (size of list m.sim, with each matrix having n.sim rows) of 
simulated external regressor-in-variance data. If the fit object contains 
external regressors in the mean equation, this must be provided else will be
assumed zero.</p>
</td></tr>
<tr><td><code id="ugarchsim-methods_+3A_...">...</code></td>
<td>
<p>For the multiplicative component sGARCH model (mcsGARCH), the
additional argument &lsquo;DailyVar&rsquo; is required and should be an xts object 
of length floor(n.sim/increments-per-day) by m.sim of the the daily simulated 
variance to use with the intraday data. In the case of the realized GARCH (realGARCH)
model, the optional argument &lsquo;prerealized&rsquo; allows to pass starting values of the
realized volatility (should be of length q as was set in the &lsquo;garchOrder(q,p)&rsquo; 
in the specification)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The custom.dist option allows for defining a custom density which exists in the
users workspace with methods for &ldquo;r&rdquo; (sampling, e.g. rnorm) and &ldquo;d&rdquo; 
(density e.g. dnorm). It must take a single fit object as its second argument.
Alternatively, custom.dist can take any name in the name slot (e.g.&ldquo;sample&rdquo;) 
and a matrix in the fit slot with dimensions equal to m.sim (columns) and n.sim (rows).
It is understood that what is supplied are the standardized (0,1) innovations and
not the unstandardized residuals.
The usefulness of this becomes apparent when one is considering the copula-GARCH 
approach or the bootstrap method.<br />
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHsim-class">uGARCHsim</a></code> object containing details of the GARCH simulation.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>For specification <code><a href="#topic+ugarchspec">ugarchspec</a></code>, fitting <code><a href="#topic+ugarchfit">ugarchfit</a></code>, 
filtering <code><a href="#topic+ugarchfilter">ugarchfilter</a></code>, forecasting <code><a href="#topic+ugarchforecast">ugarchforecast</a></code>, 
rolling forecast and estimation <code><a href="#topic+ugarchroll">ugarchroll</a></code>, parameter distribution 
and uncertainty <code><a href="#topic+ugarchdistribution">ugarchdistribution</a></code>, bootstrap forecast
<code><a href="#topic+ugarchboot">ugarchboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Basic GARCH(1,1) Spec
data(dmbp)
spec = ugarchspec()
fit = ugarchfit(data = dmbp[,1], spec = spec)
sim = ugarchsim(fit,n.sim=1000, n.start=1, m.sim=1, startMethod="sample")
sim
head(sigma(sim))

## End(Not run)</code></pre>

<hr>
<h2 id='uGARCHspec-class'>class: Univariate GARCH Specification Class</h2><span id='topic+uGARCHspec-class'></span><span id='topic+uncmean+2CuGARCHspec-method'></span><span id='topic+uncvariance+2CuGARCHspec+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+setfixed+3C-'></span><span id='topic+setfixed+3C-+2CANY+2CANY-method'></span><span id='topic+setfixed+3C-+2CuGARCHspec+2Cvector-method'></span><span id='topic+setstart+3C-'></span><span id='topic+setstart+3C-+2CANY+2CANY-method'></span><span id='topic+setstart+3C-+2CuGARCHspec+2Cvector-method'></span><span id='topic+setbounds+3C-'></span><span id='topic+setbounds+3C-+2CANY+2CANY-method'></span><span id='topic+setbounds+3C-+2CuGARCHspec+2Cvector-method'></span><span id='topic+halflife+2CuGARCHspec+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+persistence+2CuGARCHspec+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span><span id='topic+show+2CuGARCHspec-method'></span>

<h3>Description</h3>

<p>Class for the univariate GARCH specification.</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+GARCHspec-class">GARCHspec</a>"</code>, directly.
Class <code>"<a href="#topic+rGARCH-class">rGARCH</a>"</code>, by class &quot;GARCHspec&quot;, distance 2.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"vector"</code>
The model specification common to all objects.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "uGARCHspec")</code>: 
Specification summary.</p>
</dd>
<dt>setfixed&lt;-</dt><dd><p><code>signature(object = "uGARCHspec", value = "vector")</code>: 
Sets the fixed parameters (which must be supplied as a named list). </p>
</dd>
<dt>setstart&lt;-</dt><dd><p><code>signature(object = "uGARCHspec", value = "vector")</code>: 
Sets the starting parameters (which must be supplied as a named list). </p>
</dd>
<dt>setbounds&lt;-</dt><dd><p><code>signature(object = "uGARCHspec", value = "vector")</code>: 
Sets the parameters lower and upper bounds, which must be supplied as a named 
list with each parameter being a numeric vector of length 2 i.e. 
&quot;alpha1&quot;=c(0,1)). If the vector is of length 1, then this is assumed to be 
the lower bound, and the upper bound will be set to its default value prior
to estimation. Some of the parameters in the fGARCH model are not allowed to 
take on custom bounds (since they determine the class of the model) nor the 
beta parameter(s) in the iGARCH model.</p>
</dd>
<dt>uncmean</dt><dd><p><code>signature(object = "uGARCHspec")</code>: 
Unconditional mean of model for a specification with fixed.pars list.</p>
</dd>
<dt>uncvariance</dt><dd><p><code>signature(object = "uGARCHspec")</code>: 
Unconditional variance of model for a  specification with fixed.pars list.</p>
</dd>
<dt>uncvariance</dt><dd><p><code>signature(object = "uGARCHspec", pars = "missing", 
    distribution = "missing", model = "missing", submodel = "missing", 
    vexdata = "missing")</code>:
Calculates and returns the long run unconditional variance of the GARCH fit 
given a <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code> object.</p>
</dd>
<dt>halflife</dt><dd><p><code>signature(object = "uGARCHspec", pars = "missing", 
	distribution = "missing", model = "missing")</code>: 
Calculates and returns the halflife of the GARCH fit variance given a 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> object with fixed parameters.</p>
</dd>
<dt>persistence</dt><dd><p><code>signature(object = "uGARCHfit", pars = "missing", 
	distribution = "missing", model = "missing")</code>: 
Calculates and returns the persistence of the GARCH fit model given a 
<code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> object with fixed parameters.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>See Also</h3>

<p>Classes <code><a href="#topic+uGARCHfit-class">uGARCHfit</a></code>, <code><a href="#topic+uGARCHsim-class">uGARCHsim</a></code> and 
<code><a href="#topic+uGARCHforecast-class">uGARCHforecast</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic GARCH(1,1) Spec
spec = ugarchspec()
spec
</code></pre>

<hr>
<h2 id='ugarchspec-methods'>function: Univariate GARCH Specification</h2><span id='topic+ugarchspec'></span><span id='topic+ugarchspec-methods'></span><span id='topic+ugarchspec+2CANY-method'></span>

<h3>Description</h3>

<p>Method for creating a univariate GARCH specification object prior to fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1), 
submodel = NULL, external.regressors = NULL, variance.targeting = FALSE), 
mean.model = list(armaOrder = c(1, 1), include.mean = TRUE, archm = FALSE, 
archpow = 1, arfima = FALSE, external.regressors = NULL, archex = FALSE), 
distribution.model = "norm", start.pars = list(), fixed.pars = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ugarchspec-methods_+3A_variance.model">variance.model</code></td>
<td>

<p>List containing the variance model specification:<br />
<code>model</code> Valid models (currently implemented) are &ldquo;sGARCH&rdquo;, 
&ldquo;fGARCH&rdquo;, &ldquo;eGARCH&rdquo;, &ldquo;gjrGARCH&rdquo;, &ldquo;apARCH&rdquo; and
&ldquo;iGARCH&rdquo; and &ldquo;csGARCH&rdquo;.<br />
<code>garchOrder</code> The ARCH (q) and GARCH (p) orders.<br />
<code>submodel</code> If the model is &ldquo;fGARCH&rdquo;, valid submodels are 
&ldquo;GARCH&rdquo;, &ldquo;TGARCH&rdquo;, &ldquo;AVGARCH&rdquo;, &ldquo;NGARCH&rdquo;, 
&ldquo;NAGARCH&rdquo;, &ldquo;APARCH&rdquo;,&ldquo;GJRGARCH&rdquo; and &ldquo;ALLGARCH&rdquo;.<br />
<code>external.regressors</code> A matrix object containing the external regressors to 
include in the variance equation with as many rows as will be included in the
data (which is passed in the fit function).
<code>variance.targeting</code> (Logical or Numeric) If logical, indicates whether to use 
variance targeting for the conditional variance intercept &ldquo;omega&rdquo;, else
if numeric, the value provided is used instead of the unconditional variance for 
the calculation of the intercept (in combination with the persistence value). 
Care should be taken if using the numeric option for apARCH and fGARCH models 
since the intercept is not the variance but sigma raised to the power of some 
positive value. Finally, if scaling is used (from the fit.control option 
in <code><a href="#topic+ugarchfit">ugarchfit</a></code>), the value provided is adjusted accordingly by the
routine.
</p>
</td></tr>
<tr><td><code id="ugarchspec-methods_+3A_mean.model">mean.model</code></td>
<td>

<p>List containing the mean model specification:<br />
<code>armaOrder</code> The autoregressive (ar) and moving average (ma) orders (if any).<br />
<code>include.mean</code> Whether to include the mean.<br />
<code>archm</code> Whether to include ARCH volatility in the mean regression.<br />
<code>archpow</code> Indicates whether to use st.deviation (1) or variance (2) in the 
ARCH in mean regression.<br />
<code>arfima</code> Whether to fractional differencing in the ARMA regression.<br />
<code>external.regressors</code> A matrix object containing the external regressors to 
include in the mean equation with as many rows as will be included in the data 
(which is passed in the fit function).<br />
<code>archex</code> (integer) Whether to multiply the last 'archex' external regressors
by the conditional standard deviation.
</p>
</td></tr>
<tr><td><code id="ugarchspec-methods_+3A_distribution.model">distribution.model</code></td>
<td>

<p>The conditional density to use for the innovations. Valid choices are 
&ldquo;norm&rdquo; for the normal distibution, &ldquo;snorm&rdquo; for the skew-normal 
distribution, &ldquo;std&rdquo; for the student-t, &ldquo;sstd&rdquo; for the skew-student, 
&ldquo;ged&rdquo; for the generalized error distribution, &ldquo;sged&rdquo; for the 
skew-generalized error distribution, &ldquo;nig&rdquo; for the normal inverse 
gaussian distribution, &ldquo;ghyp&rdquo; for the Generalized  Hyperbolic, and &ldquo;jsu&rdquo; 
for Johnson's SU distribution. Note that some of the distributions are taken 
from the fBasics package and implenented locally here for convenience. 
The &ldquo;jsu&rdquo; distribution is the reparametrized version from the 
&ldquo;gamlss&rdquo; package.</p>
</td></tr>
<tr><td><code id="ugarchspec-methods_+3A_start.pars">start.pars</code></td>
<td>

<p>List of staring parameters for the optimization routine. These are not usually 
required unless the optimization has problems converging.</p>
</td></tr>
<tr><td><code id="ugarchspec-methods_+3A_fixed.pars">fixed.pars</code></td>
<td>

<p>List of parameters which are to be kept fixed during the optimization. It is 
possible that you designate all parameters as fixed so as to quickly recover 
just the results of some previous work or published work. The optional argument
&ldquo;fixed.se&rdquo; in the <code><a href="#topic+ugarchfit">ugarchfit</a></code> function indicates whether to
calculate standard errors for those parameters fixed during the post 
optimization stage.</p>
</td></tr>
<tr><td><code id="ugarchspec-methods_+3A_...">...</code></td>
<td>
<p> . </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specification allows for a wide choice in univariate GARCH models, 
distributions, and mean equation modelling. For the &ldquo;fGARCH&rdquo; model, 
this represents Hentschel's omnibus model which subsumes many others.<br />
For the mean equation, ARFIMAX is fully supported in fitting, forecasting and 
simulation. There is also an option to multiply the external regressors by
the conditional standard deviation, which may be of use for example in 
calculating the  correlation coefficient in a CAPM type setting.<br />
The &ldquo;iGARCH&rdquo; implements the integrated GARCH model. For the &ldquo;EWMA&rdquo; 
model just set &ldquo;omega&rdquo; to zero in the fixed parameters list.<br />
The asymmetry term in the rugarch package, for all implemented models, follows 
the order of the arch parameter <code>alpha</code>.<br />
Variance targeting, referred to in Engle and Mezrich (1996), replaces the 
intercept &ldquo;omega&rdquo; in the variance equation by 1 minus the persistence 
multiplied by the unconditional variance which is calculated by its sample 
counterpart in the squared residuals during estimation. In the presence of 
external regressors in the variance equation, the sample average of the external 
regresssors is multiplied by their coefficient and subtracted from the 
variance target.<br />
In order to understand which parameters can be entered in the start.pars and 
fixed.pars optional arguments, the list below exposes the names used for the
parameters across the various models:(note that when a parameter is followed by 
a number, this represents the order of the model. Just increment the number 
for higher orders, with the exception of the component sGARCH permanent 
component parameters which are fixed to have a lag-1 autoregressive structure.):<br />
</p>

<ul>
<li><p><em><b>Mean Model</b></em><br />
</p>

<ul>
<li><p> constant: <code>mu</code><br />
</p>
</li>
<li><p> AR term:	<code>ar1</code><br />
</p>
</li>
<li><p> MA term:	<code>ma1</code><br />
</p>
</li>
<li><p> ARCH-in-mean: <code>archm</code><br />
</p>
</li>
<li><p> exogenous regressors: <code>mxreg1</code><br />
</p>
</li>
<li><p> arfima: <code>arfima</code><br />
</p>
</li></ul>

</li>
<li> <p><em><b>Distribution Model</b></em><br />
</p>

<ul>
<li><p> skew:     <code>skew</code><br />
</p>
</li>
<li><p> shape:    <code>shape</code><br />
</p>
</li>
<li><p> ghlambda: <code>lambda (for GHYP distribution)</code><br />  
</p>
</li></ul>

</li>
<li> <p><em><b>Variance Model (common specs)</b></em><br />
</p>

<ul>
<li><p> constant:   <code>omega</code><br />
</p>
</li>
<li><p> ARCH term:  <code>alpha1</code><br />
</p>
</li>
<li><p> GARCH term: <code>beta1</code><br />
</p>
</li>
<li><p> exogenous regressors: <code>vxreg1</code><br />
</p>
</li></ul>

</li>
<li> <p><em><b>Variance Model (GJR, EGARCH)</b></em><br />
</p>

<ul>
<li><p> assymetry term: <code>gamma1</code><br />
</p>
</li></ul>

</li>
<li> <p><em><b>Variance Model (APARCH)</b></em><br />
</p>

<ul>
<li><p> assymetry term: <code>gamma1</code><br />
</p>
</li>
<li><p> power term: <code>delta</code><br />
</p>
</li></ul>

</li>
<li> <p><em><b>Variance Model (FGARCH)</b></em><br />
</p>

<ul>
<li><p> assymetry term1 (rotation): <code>eta11</code><br />
</p>
</li>
<li><p> assymetry term2 (shift): <code>eta21</code><br />
</p>
</li>
<li><p> power term1(shock): <code>delta</code><br />
</p>
</li>
<li><p> power term2(variance): <code>lambda</code><br />
</p>
</li></ul>

</li>
<li> <p><em><b>Variance Model (csGARCH)</b></em><br />
</p>

<ul>
<li><p> permanent component autoregressive term (rho): <code>eta11</code><br />
</p>
</li>
<li><p> permanent component shock term (phi): <code>eta21</code><br />
</p>
</li>
<li><p> permanent component intercept:   <code>omega</code><br />
</p>
</li>
<li><p> transitory component ARCH term:  <code>alpha1</code><br />
</p>
</li>
<li><p> transitory component GARCH term: <code>beta1</code><br />
</p>
</li></ul>

</li></ul>

<p>The terms defined above are better explained in the vignette which provides each model's specification
and exact representation. For instance, in the eGARCH model, both alpha and gamma jointly determine the
assymetry, and relate to the magnitude and sign of the standardized innovations.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+uGARCHspec-class">uGARCHspec</a></code> object containing details of the GARCH 
specification.
</p>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>Examples</h3>

<pre><code class='language-R'># a standard specification
spec1 = ugarchspec()
spec1
# an example which keep the ar1 and ma1 coefficients fixed:
spec2 = ugarchspec(mean.model=list(armaOrder=c(2,2), 
fixed.pars=list(ar1=0.3,ma1=0.3)))
spec2
# an example of the EWMA Model
spec3 = ugarchspec(variance.model=list(model="iGARCH", garchOrder=c(1,1)), 
		mean.model=list(armaOrder=c(0,0), include.mean=TRUE),  
		distribution.model="norm", fixed.pars=list(omega=0))
</code></pre>

<hr>
<h2 id='VaRDurTest'>
VaR Duration Test
</h2><span id='topic+VaRDurTest'></span>

<h3>Description</h3>

<p>Implements the VaR Duration Test of Christoffersen and Pelletier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaRDurTest(alpha, actual, VaR, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VaRDurTest_+3A_alpha">alpha</code></td>
<td>

<p>The quantile (coverage) used for the VaR.</p>
</td></tr>
<tr><td><code id="VaRDurTest_+3A_actual">actual</code></td>
<td>

<p>A numeric vector of the actual (realized) values.</p>
</td></tr>
<tr><td><code id="VaRDurTest_+3A_var">VaR</code></td>
<td>
<p>The numeric vector of VaR.</p>
</td></tr>
<tr><td><code id="VaRDurTest_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level at which the Null Hypothesis is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The duration of time between VaR violations (no-hits) should ideally be 
independent and not cluster. Under the null hypothesis of a correctly specified 
risk model, the no-hit duration should have no memory. Since the only continuous
distribution which is memory free is the exponential, the test can conducted on
any distribution which embeds the exponential as a restricted case, and a 
likelihood ratio test then conducted to see whether the restriction holds. 
Following Christoffersen and Pelletier (2004), the Weibull distribution is used 
with parameter &lsquo;b=1&rsquo; representing the case of the exponential. A future
release will include the choice of using a bootstrap method to evaluate the 
p-value, and until then care should be taken when evaluating series of length
less than 1000 as a rule of thumb.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>b</code></td>
<td>
<p> The estimated Weibull parameter which when restricted to the value 
of 1 results in the Exponential distribution.</p>
</td></tr>
<tr><td><code>uLL</code></td>
<td>
<p> The unrestricted Log-Likelihood value.</p>
</td></tr>
<tr><td><code>rLL</code></td>
<td>
<p>The restricted Log-Likelihood value.</p>
</td></tr>
<tr><td><code>LRp</code></td>
<td>
<p>The Likelihood Ratio Test Statistic.</p>
</td></tr>
<tr><td><code>H0</code></td>
<td>
<p>The Null Hypothesis.</p>
</td></tr> 
<tr><td><code>Decision</code></td>
<td>
<p> The on H0 given the confidence level</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Christoffersen, P. and Pelletier, D. 2004, Backtesting value-at-risk: A 
duration-based approach, <em>Journal of Financial Econometrics</em>, <b>2(1)</b>,
84&ndash;108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "sstd")
fit = ugarchfit(spec, data = dji30ret[1:1000, 1, drop = FALSE])
spec2 = spec
setfixed(spec2)&lt;-as.list(coef(fit))
filt = ugarchfilter(spec2, dji30ret[1001:2500, 1, drop = FALSE], n.old = 1000)
actual = dji30ret[1001:2500,1]
# location+scale invariance allows to use [mu + sigma*q(p,0,1,skew,shape)]
VaR = fitted(filt) + sigma(filt)*qdist("sstd", p=0.05, mu = 0, sigma = 1, 
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
print(VaRDurTest(0.05, actual, VaR))

# Try with the Normal Distribution (it fails)
spec = ugarchspec(mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "norm")
fit = ugarchfit(spec, data = dji30ret[1:1000, 1, drop = FALSE])
spec2 = spec
setfixed(spec2)&lt;-as.list(coef(fit))
filt = ugarchfilter(spec2, dji30ret[1001:2500, 1, drop = FALSE], n.old = 1000)
actual = dji30ret[1001:2500,1]
# location+scale invariance allows to use [mu + sigma*q(p,0,1,skew,shape)]
VaR = fitted(filt) + sigma(filt)*qdist("norm", p=0.05, mu = 0, sigma = 1)
print(VaRDurTest(0.05, actual, VaR))

## End(Not run)</code></pre>

<hr>
<h2 id='VaRloss'>
Value at Risk loss function of Gonzalez-Rivera, Lee, and Mishra (2004)
</h2><span id='topic+VaRloss'></span>

<h3>Description</h3>

<p>Returns the VaR loss function described in  Gonzalez-Rivera, Lee, and 
Mishra (2004) which is an appropriate function on which to compare models using
such methods as the Model Confidence Set (MCS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaRloss(alpha, actual, VaR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VaRloss_+3A_alpha">alpha</code></td>
<td>

<p>The quantile (coverage) used for the VaR.</p>
</td></tr>
<tr><td><code id="VaRloss_+3A_actual">actual</code></td>
<td>

<p>A numeric vector of the actual (realized) values.</p>
</td></tr>
<tr><td><code id="VaRloss_+3A_var">VaR</code></td>
<td>

<p>The numeric vector of VaR.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Gonzalez-Rivera, G., Lee, T. H., and Mishra, S. 2004, Forecasting volatility: 
A reality check based on option pricing, utility function, value-at-risk, 
and predictive likelihood. <em>International Journal of Forecasting</em>, 
<b>20(4)</b>, 629&ndash;645.
</p>

<hr>
<h2 id='VaRplot'>
Value at Risk Exceedances plot
</h2><span id='topic+VaRplot'></span>

<h3>Description</h3>

<p>Plot the VaR at a given coverage rate against the realized returns for the same
period, highlighting the exceedances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaRplot(alpha, actual, VaR, title = paste("Daily Returns and Value-at-Risk 
Exceedances\n","(alpha=", alpha,")",sep=""), ylab = "Daily Log Returns", 
xlab = "Time")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VaRplot_+3A_alpha">alpha</code></td>
<td>

<p>The quantile (coverage) used for the VaR.</p>
</td></tr>
<tr><td><code id="VaRplot_+3A_actual">actual</code></td>
<td>

<p>An xts object of the realized returns.</p>
</td></tr>
<tr><td><code id="VaRplot_+3A_var">VaR</code></td>
<td>

<p>An xts object of the forecast VaR, at the given coverage rate p, with the same 
index as the actual.</p>
</td></tr>
<tr><td><code id="VaRplot_+3A_title">title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="VaRplot_+3A_xlab">xlab</code></td>
<td>
<p>Plot x-axis label.</p>
</td></tr>
<tr><td><code id="VaRplot_+3A_ylab">ylab</code></td>
<td>
<p>Plot y-axis label.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>

<hr>
<h2 id='VaRTest'>
Value at Risk Exceedances Test
</h2><span id='topic+VaRTest'></span>

<h3>Description</h3>

<p>Implements the unconditional and conditional coverage Value at Risk
Exceedances Test. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaRTest(alpha = 0.05, actual, VaR, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VaRTest_+3A_alpha">alpha</code></td>
<td>

<p>The quantile (coverage) used for the VaR.</p>
</td></tr>
<tr><td><code id="VaRTest_+3A_actual">actual</code></td>
<td>

<p>A numeric vector of the actual (realized) values.</p>
</td></tr>
<tr><td><code id="VaRTest_+3A_var">VaR</code></td>
<td>

<p>The numeric vector of VaR.
</p>
</td></tr>
<tr><td><code id="VaRTest_+3A_conf.level">conf.level</code></td>
<td>

<p>The confidence level at which the Null Hypothesis is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test implements both the unconditional (Kupiec) and conditional(Christoffersen)
coverage tests for the correct number of exceedances.
See the references for further details.
</p>


<h3>Value</h3>

<p>A list with the following items:<br />
</p>
<table>
<tr><td><code>expected.exceed</code></td>
<td>
<p> The expected number of exceedances 
(length actual x coverage).</p>
</td></tr>
<tr><td><code>actual.exceed</code></td>
<td>
<p> The actual number of exceedances.</p>
</td></tr>
<tr><td><code>uc.H0</code></td>
<td>
<p>The unconditional coverage test Null Hypothesis.</p>
</td></tr>
<tr><td><code>uc.LRstat</code></td>
<td>
<p>The unconditional coverage test Likelihood Ratio statistic.</p>
</td></tr>
<tr><td><code>uc.critical</code></td>
<td>
<p>The unconditional coverage test critical value.</p>
</td></tr> 
<tr><td><code>uc.LRp</code></td>
<td>
<p> The unconditional coverage test p-value.</p>
</td></tr>
<tr><td><code>uc.H0</code></td>
<td>
<p>The unconditional coverage test Null Hypothesis.</p>
</td></tr>
<tr><td><code>uc.Decision</code></td>
<td>
<p>The unconditional coverage test Decision on H0 given the
confidence level.</p>
</td></tr>
<tr><td><code>cc.H0</code></td>
<td>
<p>The conditional coverage test Null Hypothesis.</p>
</td></tr>
<tr><td><code>cc.LRstat</code></td>
<td>
<p>The conditional coverage test Likelihood Ratio statistic.</p>
</td></tr>
<tr><td><code>cc.critical</code></td>
<td>
<p>The conditional coverage test critical value.</p>
</td></tr> 
<tr><td><code>cc.LRp</code></td>
<td>
<p> The conditional coverage test p-value.</p>
</td></tr>
<tr><td><code>cc.H0</code></td>
<td>
<p>The conditional coverage test Null Hypothesis.</p>
</td></tr>
<tr><td><code>cc.Decision</code></td>
<td>
<p>The conditional coverage test Decision on H0 given the
confidence level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexios Ghalanos</p>


<h3>References</h3>

<p>Christoffersen, P. (1998), Evaluating Interval Forecasts, 
<em>International Economic Review</em>, <b>39</b>, 841&ndash;862.<br />
Christoffersen, P., Hahn,J. and Inoue, A. (2001), Testing and Comparing 
Value-at-Risk Measures, <em>Journal of Empirical Finance</em>, <b>8</b>, 325&ndash;342.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dji30ret)
spec = ugarchspec(mean.model = list(armaOrder = c(1,1), include.mean = TRUE),
variance.model = list(model = "gjrGARCH"), distribution.model = "sstd")
fit = ugarchfit(spec, data = dji30ret[1:1000, 1, drop = FALSE])
spec2 = spec
setfixed(spec2)&lt;-as.list(coef(fit))
filt = ugarchfilter(spec2, dji30ret[1001:2500, 1, drop = FALSE], n.old = 1000)
actual = dji30ret[1001:2500,1]
# location+scale invariance allows to use [mu + sigma*q(p,0,1,skew,shape)]
VaR = fitted(filt) + sigma(filt)*qdist("sstd", p=0.05, mu = 0, sigma = 1, 
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
print(VaRTest(0.05, as.numeric(actual), as.numeric(VaR)))

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
