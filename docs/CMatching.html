<!DOCTYPE html><html lang="en"><head><title>Help for package CMatching</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CMatching}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CMatching-package'>
<p>Matching Algorithms for Causal Inference with Clustered Data</p></a></li>
<li><a href='#CMatch'>
<p>Within and preferential-within cluster matching.</p></a></li>
<li><a href='#CMatchBalance'>
<p>Analyze covariate balance before and after matching.</p></a></li>
<li><a href='#MatchPW'>
<p>Preferential Within-cluster Matching</p></a></li>
<li><a href='#MatchW'>
<p>Within-cluster Matching</p></a></li>
<li><a href='#schools'>
<p>Schools data set (NELS-88)</p></a></li>
<li><a href='#summary.CMatch'>
<p>Summarizing output from MatchW and MatchPW functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matching Algorithms for Causal Inference with Clustered Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Massimo Cannas &lt;massimo.cannas@unica.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to perform matching algorithms for causal inference with clustered data, as described in B. Arpino and M. Cannas (2016) &lt;<a href="https://doi.org/10.1002%2Fsim.6880">doi:10.1002/sim.6880</a>&gt;. Pure within-cluster and preferential within-cluster matching are implemented. Both algorithms provide causal estimates with cluster-adjusted estimates of standard errors. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0), Matching</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats,lmtest,multiwayvcov,lme4</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-08 16:59:28 UTC; massimo</td>
</tr>
<tr>
<td>Author:</td>
<td>Massimo Cannas [aut, cre],
  Bruno Arpino [ctb],
  Elena Colicino [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-10 19:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='CMatching-package'>
Matching Algorithms for Causal Inference with Clustered Data
</h2><span id='topic+CMatching-package'></span><span id='topic+CMatching'></span>

<h3>Description</h3>

<p>Provides functions to perform matching algorithms for causal inference with clustered data, as described in B. Arpino and M. Cannas (2016) &lt;doi:10.1002/sim.6880&gt;. Pure within-cluster and preferential within-cluster matching are implemented. Both algorithms provide causal estimates with cluster-adjusted estimates of standard errors. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CMatching</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-02-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL version 3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Several strategies have been suggested for adapting propensity score matching to clustered data. Depending on researcher's belief about the strength of unobserved cluster level covariates it is possible to take into account clustering either in the estimation of the propensity score model (through the inclusion of fixed or random effects, e.g. Arpino and Mealli (2011)) and/or in the implementation of the matching algorithm (see, e.g. Rickles and Seltzer (2014); Arpino and Cannas (2016)). 
This package contains main function <code>CMatch</code> to adapt classic matching algorithms for causal inference to clustered data and a customized <code>summary</code> function to analyze the output. 
Depending on the <code>type</code> argument function <code>CMatch</code> calls either <code>MatchW</code> implementing a <em>pure</em> within-cluster matching or <code>MatchPW</code> implementing an approach which can be called <em>&quot;preferential&quot;</em> within-cluster matching. This approach first looks for matchable units within the same cluster and - if no match is found - continues the search in the remaining clusters. The functions also provide causal estimands with cluster-adjusted standard errors from fitting a multilevel model on matched data. <code>CMatch</code> returns an object of class &rdquo;<code>CMatch</code>&rdquo; which can be be summarized and used as input of the <code>CMatchBalance</code> function to examine how much the procedure resulted in improved covariate balance. 
Although <code>CMatch</code> has been designed for dealing with clustered data, these algorithms can be used to force a perfect balance or to improve the balance of categorical variables, respectively. In this case, the &quot;clusters&quot; correspond to the levels of the categorical variable(s). When used for this purpouse the user should ignore the standard error (if provided). Note that <code>Matchby</code> from package <code>Matching</code> can be used for the same purpouse. 
</p>


<h3>Author(s)</h3>

<p>Massimo Cannas [aut, cre],
  Bruno Arpino [ctb],
  Elena Colicino [ctb]. A special thanks to Thomas W. Yee for his help in updating to version 2.1.
</p>
<p>Maintainer: Massimo Cannas &lt;massimo.cannas@unica.it&gt;
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. (2011). Multivariate and Propensity Score Matching Software with Automated Balance Optimization. <em>Journal of Statistical Software, 42(7): 1-52.</em> http://www.jstatsoft.org/v42/i07/
</p>
<p>Arpino, B., and Cannas, M. (2016). Propensity score matching with clustered data. An application to the estimation of the impact of caesarean section on the Apgar score. <em>Statistics in Medicine, 35: 2074-2091</em>. doi: 10.1002/sim.6880.
</p>
<p>Rickles, J. H., and Seltzer, M. (2014). A Two-Stage Propensity Score Matching Strategy for Treatment Effect Estimation in a Multisite Observational Study. <em>Journal of Educational and Behavioral Statistics, 39(6), 612-636</em>. doi: 10.3102/1076998614559748
</p>
<p>Arpino, B. and Mealli, F. (2011). The specification of the propensity score in multilevel observational studies. <em>Computational Statistics &amp; Data Analysis</em>, 55(4), 1770-1780. doi: 10.1016/j.csda.2010.11.008 
</p>


<h3>See Also</h3>

<p><code><a href="Matching.html#topic+Match">Match</a></code>, <code><a href="Matching.html#topic+MatchBalance">MatchBalance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a paper and pencil example with a few units

id  &lt;- c(1,2,3,4,5, 6,7,8,9,10)
 x  &lt;- c( 1,1,1.1,1.1,1.4, 2,1,1,1.3, 1.3 )
 t  &lt;- c( 1,1,1,1,0, 0,0,0,0, 0 )
 g  &lt;- c(1,1,2,2,1,1,2,2,2, 2 ) # two groups of four and six units
toy &lt;- t(data.frame(id,g, t,x))

# reorder units by ascending group
 toyord &lt;-toy[,order(g)] 
 x &lt;-toyord["x",]
 t &lt;-toyord["t",]
 g &lt;- toyord["g",]

# pooled matching
pm &lt;- Match(Y=NULL, Tr=t, X=x, caliper=2,ties=FALSE,replace=FALSE)
# quick look at matched dataset (matched pairs are vertically aligned)
pm$index.treated
pm$index.control


# within matching 
wm &lt;- CMatch(type="within",Y=NULL, Tr=t, X=x, Group=g,caliper=2,ties=FALSE,replace=FALSE)
wm$index.treated
wm$index.control

# preferential-within matching
pwm &lt;- CMatch(type="pwithin",Y=NULL, Tr=t, X=x, Group=g, caliper=2,ties=FALSE,replace=FALSE)
pwm$index.treated
pwm$index.control
 </code></pre>

<hr>
<h2 id='CMatch'>
Within and preferential-within cluster matching. 
</h2><span id='topic+CMatch'></span>

<h3>Description</h3>

<p>This function implements multivariate and propensity score matching in clusters defined by the <code>Group</code> variable. It returns an object of class &rdquo;<code>CMatch</code>&rdquo; which can be be summarized and used as input of the <code>CMatchBalance</code> function to examine how much the procedure resulted in improved covariate balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMatch(type, Y = NULL, Tr, X, Group = NULL, estimand = "ATT", M = 1, 
exact = NULL, caliper = 0.25, weights = NULL, replace = TRUE, ties = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CMatch_+3A_type">type</code></td>
<td>

<p>The type of matching desired. &quot;within&quot; for a pure within-cluster matching and &quot;pwithin&quot; for matching preferentially within. The preferential approach first searches for matchable units within the same cluster. If no match was found the algorithm searches in other clusters.
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_y">Y</code></td>
<td>

<p>A vector containing the outcome of interest. 
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_tr">Tr</code></td>
<td>

<p>A vector indicating the treated and control units. 
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_x">X</code></td>
<td>

<p>A matrix of covariates we wish to match on. This matrix should contain all confounders or the propensity score or a combination of both.
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_group">Group</code></td>
<td>

<p>A vector describing the clustering structure (typically the cluster ID). This can be any numeric vector of the same length of <code>Tr</code> and <code>X</code>  containing integer numbers in ascending order otherwise an error message will be returned. Default is NULL, however if <code>Group</code> is missing, NULL or it contains only one value the output of the <code>Match</code> function is returned with a warning.   
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_estimand">estimand</code></td>
<td>

<p>The causal estimand desired, one of &quot;ATE&quot;, &quot;ATT&quot; and &quot;ATC&quot;, which stand for Average Treatment Effect, Average Treatment effect on the Treated and on the Controls, respectively. Default is &quot;ATT&quot;. 
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_m">M</code></td>
<td>

<p>The number of matches which are sought for each unit. Default is 1 (&quot;one-to-one matching&quot;).
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_exact">exact</code></td>
<td>

<p>An indicator for whether exact matching on the variables contained in <code>X</code> is desired. Default is FALSE. This option has precedence over the caliper option.
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_caliper">caliper</code></td>
<td>

<p>A maximum allowed distance for matching units. Units for which no match was found within caliper distance are discarded. Default is 0.25. The caliper is interpreted in standard deviation units of the <em>unclustered</em> data for each variable. For example, if caliper=0.25 all matches at distance bigger than 0.25 times the standard deviation for any of the variables in <code>X</code> are discarded. 
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_weights">weights</code></td>
<td>

<p>A vector of specific observation weights.
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_replace">replace</code></td>
<td>

<p>Matching can be with or without replacement depending on whether matches can be re-used or not. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_ties">ties</code></td>
<td>

<p>An indicator for dealing with multiple matches. If more than M matches are found for each unit the additional matches are a) wholly retained with equal weights if ties=TRUE; b) a random one is chosen if ties=FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="CMatch_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the <code>Match</code> function (not all of them can be used).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be a natural extension of the <code>Match</code> function to clustered data. It retains the main arguments of <code>Match</code> but it has additional output showing matching results cluster by cluster. 
It differs from wrapper <code>Matchby</code> in package <code>Matching</code> in the way standard errors are calculated and because the caliper is in standard deviation units of the covariates on the overall dataset (so the caliper is the same for all clusters). Moreover, observation weights are available. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>index.control</code></td>
<td>
<p>The index of control observations in the matched dataset.</p>
</td></tr>
<tr><td><code>index.treated</code></td>
<td>
<p>The index of control observations in the matched dataset.</p>
</td></tr>
<tr><td><code>index.dropped</code></td>
<td>
<p>The index of dropped observations due to the exact or caliper option. Note that these observations are treated if estimand is &quot;ATT&quot;, controls if &quot;ATC&quot;.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>The causal estimate. This is provided only if <code>Y</code> is not null. If estimand is &quot;ATT&quot; it is the (weighted) mean of <code>Y</code> in matched treated units minus the (weighted) mean of <code>Y</code> in matched controls. Equivalently, it is the weighted average of the within-cluster ATTs, with weights given by cluster sizes in the matched dataset.</p>
</td></tr> 
<tr><td><code>se</code></td>
<td>
<p>A model-based standard error for the causal estimand. This is a cluster robust estimator of the standard error for the linear model: <code>Y ~ constant+Tr</code>, run on the matched dataset (see <code><a href="multiwayvcov.html#topic+cluster.vcov">cluster.vcov</a></code> for details on how this estimator is obtained). Note that these standard errors differ from a weighted average of cluster specific standard errors provided by the <code>Matchby</code> function, which are generally larger. Estimating standard errors for causal parameters with clustered data is an active field of research and there is no perfect solution to date.</p>
</td></tr>   
<tr><td><code>mdata</code></td>
<td>
<p>A list containing the matched datasets produced by <code>CMatch</code>. Three datasets are included in this list: <code>Y</code>, <code>Tr</code> and <code>X</code>. The matched dataset for <code>Group</code> can be recovered by <code>rbind(Group[index.treated],Group[index.control])</code>.</p>
</td></tr>
<tr><td><code>orig.treated.nobs.by.group</code></td>
<td>
<p>The original number of treated observations by group in the dataset.</p>
</td></tr>
<tr><td><code>orig.control.nobs.by.group</code></td>
<td>
<p>The original number of control observations by group in the dataset.</p>
</td></tr>
<tr><td><code>orig.dropped.nobs.by.group</code></td>
<td>
<p>The number of dropped observations by group after within cluster matching.</p>
</td></tr>
<tr><td><code>orig.nobs</code></td>
<td>
<p>The original number of observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.wnobs</code></td>
<td>
<p>The original number of weighted observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.treated.nobs</code></td>
<td>
<p>The original number of treated observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.control.nobs</code></td>
<td>
<p>The original number of control observations in the dataset.</p>
</td></tr>
<tr><td><code>wnobs</code></td>
<td>
<p>the number of weighted observations in the matched dataset.</p>
</td></tr>
<tr><td><code>caliper</code></td>
<td>
<p>The caliper used.</p>
</td></tr>
<tr><td><code>intcaliper</code></td>
<td>
<p>The internal caliper used.</p>
</td></tr>
<tr><td><code>exact</code></td>
<td>
<p>The value of the exact argument.</p>
</td></tr>
<tr><td><code>ndrops.matches</code></td>
<td>
<p>The number of matches dropped either because of the caliper or exact option (or because of forcing the match within-clusters).</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>The estimand required.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function returns an object of class <code>CMatch</code>. The <code>CMatchBalance</code> function can be used to examine the covariate balance before and after matching (see the examples below).
</p>


<h3>Author(s)</h3>

<p>Massimo Cannas &lt;massimo.cannas@unica.it&gt;
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011. Multivariate and Propensity Score Matching Software with Automated Balance Optimization. <em>Journal of Statistical Software 42(7): 1-52.</em> http://www.jstatsoft.org/v42/i07/
</p>
<p>Arpino, B., and Cannas, M. (2016) Propensity score matching with clustered data. An application to the estimation of the impact of caesarean section on the Apgar score. <em>Statistics in Medicine, 35: 2074–2091</em>. doi: 10.1002/sim.6880.
</p>


<h3>See Also</h3>

<p>See also <code><a href="Matching.html#topic+Match">Match</a></code>, <code> <a href="Matching.html#topic+MatchBalance">MatchBalance</a></code>,<code><a href="multiwayvcov.html#topic+cluster.vcov">cluster.vcov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(schools)
	
# Kreft and De Leeuw, Introducing Multilevel Modeling, Sage (1988).   
# The data set is the subsample of NELS-88 data consisting of 10 handpicked schools
# from the 1003 schools in the full data set.
 
# Let us consider the following variables:

X&lt;-schools$ses  # (socio economic status) 
Y&lt;-schools$math #(mathematics score)
Tr&lt;-ifelse(schools$homework &gt; 1, 1 ,0)
Group&lt;-schools$schid #(school ID)

# When Group is missing/NULL or there is only one group, CMatch returns 
# the output of the Match function (with a warning).

# Multivariate Matching on covariates in X 
# default parameters: one-to-one matching on X with replacement with a caliper of 0.25

### Matching within schools
 mw &lt;- CMatch(type="within",Y=Y, Tr=Tr, X=X, Group=Group, caliper=0.1)
 
 # compare balance before and after matching
 bmw  &lt;- CMatchBalance(Tr~X, data=schools, match.out = mw)
 
 # calculate proportion of matched observations
  (mw$orig.treated.nobs-mw$ndrops)/mw$orig.treated.nobs 
  
 # check number of drops by school
 mw$orig.dropped.nobs.by.group
 
 # examine output
 mw           # complete output                 
 summary(mw)  # basic output statistics
 
### Match preferentially within school 
# i.e. first match within schools
# then tries to match remaining units between schools
 mpw &lt;- CMatch(type="pwithin",Y=schools$math, Tr=Tr, X=schools$ses, 
 Group=schools$schid, caliper=0.1)

# examine covariate balance
  bmpw&lt;- CMatchBalance(Tr~ses,data=schools,match.out = mpw)

# proportion of matched observations
  (mpw$orig.treated.nobs-mpw$ndrops) / mpw$orig.treated.nobs 
# check drops by school
  mpw$orig.dropped.nobs.by.group.after.pref.within
# proportion of matched observations after match-within only
 (mpw$orig.treated.nobs-sum(mpw$orig.dropped.nobs.by.group.after.within)) / mpw$orig.treated.nobs

# see complete output
   mpw
# or use summary method for main results
   summary(mpw) 

#### Propensity score matching

# estimate the ps model

mod &lt;- glm(Tr~ses+parented+public+sex+race+urban,
family=binomial(link="logit"),data=schools)
eps &lt;- fitted(mod)

# eg 1: within school propensity score matching
psmw &lt;- CMatch(type="within",Y=schools$math, Tr=Tr, X=eps, 
Group=schools$schid, caliper=0.1)

# eg 2: preferential within school propensity score matching
psmw &lt;- CMatch(type="pwithin",Y=schools$math, Tr=Tr, X=eps, Group=schools$schid, caliper=0.1)

# eg 3: propensity score matching using ps estimated from a logit model with dummies for hospitals

mod &lt;- glm(Tr ~ ses + parented + public + sex + race + urban 
+schid - 1,family=binomial(link="logit"),data=schools)
eps &lt;- fitted(mod)

dpsm &lt;- CMatch(type="within",Y=schools$math, Tr=Tr, X=eps, Group=NULL, caliper=0.1)
# this is equivalent to run Match with X=eps

# eg4: propensity score matching using ps estimated from multilevel logit model 
# (random intercept at the hospital level); see Arpino and Mealli

require(lme4)
mod &lt;- glmer(Tr ~ ses + parented + public + sex + race + urban + (1 | schid),
family=binomial(link="logit"), data=schools)
eps &lt;- fitted(mod)

mpsm &lt;- CMatch(type="within",Y=schools$math, Tr=Tr, X=eps, Group=NULL, caliper=0.1)
# note: equivalent to run Match with X=eps

 

</code></pre>

<hr>
<h2 id='CMatchBalance'>
Analyze covariate balance before and after matching.
</h2><span id='topic+CMatchBalance'></span><span id='topic+CMatchBalance.default'></span><span id='topic+CMatchBalance.CMatch'></span>

<h3>Description</h3>

<p>Generic function for analyzing covariate balance. If <code>match.out</code> is <code>NULL</code> only balance statistics for the unmatched data are returned otherwise both before and after matching balance are given. The function is a wrapper calling <code>MatchBalance</code>, possibly after coercing the class of <code>match.out</code>. See <code>MatchBalance</code> for more detailed description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMatchBalance(match.out, formula, data = NULL, ks = TRUE, 
nboots = 500, weights = NULL, digits = 5, paired = TRUE, print.level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CMatchBalance_+3A_match.out">match.out</code></td>
<td>

<p>A matched data set, i.e., the result of a call to <code>Match</code> or <code>CMatch</code>. 
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_formula">formula</code></td>
<td>

<p>This formula does not estimate a model. It is a compact way to describe which variables should be compared between the treated and control group. See <code>MatchBalance</code>. 
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_data">data</code></td>
<td>

<p>An optional data set for the variables indicated in the <code>formula</code> argument.
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_ks">ks</code></td>
<td>

<p>A flag for whether Kolmogorov-Smirnov tests should be calculated.
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_weights">weights</code></td>
<td>

<p>A vector of observation-specific weights.
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_nboots">nboots</code></td>
<td>

<p>The number of bootstrap replication to be used.
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_digits">digits</code></td>
<td>

<p>The number of digits to be displayed in the output
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_paired">paired</code></td>
<td>

<p>A flag for whether a paired t.test should be used for the matched data. An unpaired t.test is always used for unmatched data.
</p>
</td></tr>
<tr><td><code id="CMatchBalance_+3A_print.level">print.level</code></td>
<td>

<p>The amount of printing, taking values 0 (no printing), 1(summary) and 2 (dtailed results). Default to 1.
</p>
</td></tr>


</table>


<h3>Details</h3>

<p>The function is a wrapper of the <code>MatchBalance</code> function. If <code>match.out</code> is of class <code>Match</code> (or <code>NULL</code>) then it calls <code>MatchBalance</code>. If <code>match.out</code> is of class<code>CMatch</code> then it coerces the class to <code>Match</code> before calling <code>MatchBalance</code>. This function is meant to exploit <code>MatchBalance</code> for <code>CMatch</code> objects for which <code>MatchBalance</code> would not work. 
</p>


<h3>Value</h3>

<p>Balance statistics for the covariates specified in the <em>right</em> side of <code>formula</code> argument. Statistics are compared between the two groups specified by the binary variable in the <em>left</em> side of <code>formula</code>.
</p>


<h3>Author(s)</h3>

<p>Massimo Cannas &lt;massimo.cannas@unica.it&gt; and a special thanks to Thomas W. Yee for his help.
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011. Multivariate and Propensity Score Matching Software with Automated Balance Optimization. <em>Journal of Statistical Software 42(7): 1-52.</em> http://www.jstatsoft.org/v42/i07/
</p>


<h3>See Also</h3>

<p><code><a href="Matching.html#topic+MatchBalance">MatchBalance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(schools)
 
# Kreft and De Leeuw, Introducing Multilevel Modeling, Sage (1988).   
# The data set is the subsample of NELS-88 data consisting of 10 handpicked schools
# from the 1003 schools in the full data set.
 
# Let us consider the following variables:

X&lt;-schools$ses  # (socio economic status) 
Y&lt;-schools$math #(mathematics score)
Tr&lt;-ifelse(schools$homework &gt; 1, 1 ,0)
Group&lt;-schools$schid #(school ID)

# Multivariate Matching on covariates X 

### Matching within schools
 mw &lt;- CMatch(type="within",Y=Y, Tr=Tr, X=X, Group=Group, caliper=0.1)
 
 # Balance statistics for X variables(s) before and after matching within schools. 
 CMatchBalance(Tr~X,data=schools,match.out = mw)
 
 
### Match preferentially within school 
# i.e. first match within schools
# then tries to match remaining units between schools

 mpw &lt;- CMatch(type="pwithin",Y=schools$math, Tr=Tr, X=schools$ses, 
 Group=schools$schid, caliper=0.1)

# examine covariate balance of variable(s) X before and after preferential matching within schools
  CMatchBalance(Tr~X, data=schools, match.out = mpw)

</code></pre>

<hr>
<h2 id='MatchPW'>
Preferential Within-cluster Matching 
</h2><span id='topic+MatchPW'></span>

<h3>Description</h3>

<p>This function implements preferential within-cluster matching. In other words, units that do not match within clusters (as defined by the <code>Group</code> variable) can match between cluster in the second step. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchPW(Y = NULL, Tr, X, Group = NULL, estimand = "ATT", M = 1,
 exact = NULL, caliper = 0.25, replace = TRUE, ties = TRUE, weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatchPW_+3A_y">Y</code></td>
<td>

<p>A vector containing the outcome of interest. 
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_tr">Tr</code></td>
<td>

<p>A vector indicating the treated and control units. 
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_x">X</code></td>
<td>

<p>A matrix of covariates we wish to match on. This matrix should contain all confounders or the propensity score or a combination of both.
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_group">Group</code></td>
<td>

<p>A vector describing the clustering structure (typically the cluster ID). This can be any numeric vector of the same length of <code>Tr</code> and <code>X</code> containing integer numbers in ascending order otherwise an error message will be returned. Default is NULL, however if <code>Group</code> is missing, NULL or contains only one value the output of the <em>Match</em> function is returned with a warning.  
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_estimand">estimand</code></td>
<td>

<p>The causal estimand desired, one of &quot;ATE&quot;, &quot;ATT&quot; and &quot;ATC&quot;, which stand for Average Treatment Effect, Average Treatment effect on the Treated and on the Controls, respectively. Default is &quot;ATT&quot;. 
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_m">M</code></td>
<td>

<p>The number of matches which are sought for each unit. Default is 1 (&quot;one-to-one matching&quot;).
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_exact">exact</code></td>
<td>

<p>An indicator for whether exact matching on the variables contained in <code>X</code> is desired. Default is FALSE. This option has precedence over the caliper option.
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_caliper">caliper</code></td>
<td>

<p>A maximum allowed distance for matching units. Units for which no match was found within caliper distance are discarded. Default is 0.25. The caliper is interpreted in standard deviation units of the <em>unclustered</em> data for each variable. For example, if caliper=0.25 all matches at distance bigger than 0.25 times the standard deviation for any of the variables in <code>X</code> are discarded. The caliper is used for both within and between clusters matching.
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_replace">replace</code></td>
<td>

<p>Default is TRUE. From version 2.3 this parameter can be set to FALSE. Assuming ATT this means that controls matched within cannot be matched between (i.e. in the second step). However note that, even when replace is set to FALSE, controls can be re-used during match between.
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_ties">ties</code></td>
<td>

<p>An indicator for dealing with multiple matches. If more than M matches are found for each unit the additional matches are a) wholly retained with equal weights if ties=TRUE; b) a random one is chosen if ties=FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_weights">weights</code></td>
<td>

<p>A vector of observation specific weights.
</p>
</td></tr>
<tr><td><code id="MatchPW_+3A_...">...</code></td>
<td>

<p>Please note that all additional arguments of the <code>Match</code> function are not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs preferential within-cluster matching in the clusters defined by the variable <code>Group</code>. In the first phase matching within clusters is performed (see <code>MatchW</code>) and in the second the unmatched treated (or controls if estimand=&quot;ATC&quot;) are matched with all controls (treated) units. This can be helpful to avoid dropping many units in small clusters.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>index.control</code></td>
<td>
<p>The index of control observations in the matched dataset.</p>
</td></tr>
<tr><td><code>index.treated</code></td>
<td>
<p>The index of control observations in the matched dataset.</p>
</td></tr>
<tr><td><code>index.dropped</code></td>
<td>
<p>The index of dropped observations due to the exact or caliper option. Note that these observations are treated if estimand is &quot;ATT&quot;, controls if &quot;ATC&quot;.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>The causal estimate. This is provided only if <code>Y</code> is not null. If estimand is &quot;ATT&quot; it is the (weighted) mean of <code>Y</code> in matched treated minus the (weighted) mean of <code>Y</code> in matched controls. Equivalently it is the weighted average of the within-cluster ATTs, with weights given by cluster sizes in the matched dataset.</p>
</td></tr> 
<tr><td><code>se</code></td>
<td>
<p>A model-based standard error for the causal estimand. This is a cluster robust estimator of the standard error for the linear model: <code>y ~ constant+Tr</code>, run on the matched dataset (see <code><a href="multiwayvcov.html#topic+cluster.vcov">cluster.vcov</a></code> for details on how this estimator is obtained).</p>
</td></tr>
<tr><td><code>mdata</code></td>
<td>
<p>A list containing the matched datasets produced by <code>MatchPW</code>. Three datasets are included in this list: <code>Y</code>, <code>Tr</code> and <code>X</code>. The matched dataset for <code>Group</code> can be recovered by <code>rbind(Group[index.treated],Group[index.control])</code>.
</p>
</td></tr>
<tr><td><code>orig.treated.nobs.by.group</code></td>
<td>
<p>The original number of treated observations by group in the dataset.</p>
</td></tr>
<tr><td><code>orig.control.nobs.by.group</code></td>
<td>
<p>The original number of control observations by group in the dataset.</p>
</td></tr>
<tr><td><code>orig.dropped.nobs.by.group</code></td>
<td>
<p>The number of dropped observations by group after within cluster matching.</p>
</td></tr>
<tr><td><code>orig.dropped.nobs.by.group.after.pref.within</code></td>
<td>
<p>The number of dropped observations by group after preferential within group matching.</p>
</td></tr>
<tr><td><code>orig.nobs</code></td>
<td>
<p>The original number of observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.wnobs</code></td>
<td>
<p>The original number of weighted observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.treated.nobs</code></td>
<td>
<p>The original number of treated observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.control.nobs</code></td>
<td>
<p>The original number of control observations in the dataset.</p>
</td></tr>
<tr><td><code>wnobs</code></td>
<td>
<p>the number of weighted observations in the matched dataset.</p>
</td></tr>
<tr><td><code>caliper</code></td>
<td>
<p>The caliper used.</p>
</td></tr>
<tr><td><code>intcaliper</code></td>
<td>
<p>The internal caliper used.</p>
</td></tr>
<tr><td><code>exact</code></td>
<td>
<p>The value of the exact argument.</p>
</td></tr>
<tr><td><code>ndrops.matches</code></td>
<td>
<p>The number of matches dropped either because of the caliper or exact option.</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>The estimand required.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function returns an object of class <code>CMatch</code>. The <code>CMatchBalance</code> function can be used to examine the covariate balance before and after matching. See the examples below.
</p>


<h3>Author(s)</h3>

<p>Massimo Cannas &lt;massimo.cannas@unica.it&gt;
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011. Multivariate and Propensity Score Matching Software with Automated Balance Optimization. <em>Journal of Statistical Software, 42(7): 1-52.</em> http://www.jstatsoft.org/v42/i07/
</p>
<p>Arpino, B., and Cannas, M. (2016) Propensity score matching with clustered data. An application to the estimation of the impact of caesarean section on the Apgar score. <em>Statistics in Medicine, 35: 2074-2091</em> doi: 10.1002/sim.6880.
</p>


<h3>See Also</h3>

<p>See also <code><a href="Matching.html#topic+Match">Match</a></code>, <code> <a href="Matching.html#topic+MatchBalance">MatchBalance</a></code>,<code><a href="multiwayvcov.html#topic+cluster.vcov">cluster.vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(schools)
	
# Kreft and De Leeuw, Introducing Multilevel Modeling, Sage (1988).   
# The data set is the subsample of NELS-88 data consisting of 10 handpicked schools 
# from the 1003 schools in the full data set.

X&lt;-schools$ses  # (socio economic status) 
Y&lt;-schools$math #(mathematics score)
Tr&lt;-ifelse(schools$homework &gt; 1, 1 ,0)
Group&lt;-schools$schid #(school ID)
# Note that when Group is missing, NULL or there is only one Group, 
# MatchPW returns the same output of the Match function (with a warning).


# Matching math scores between group of students. X are confounders.


### Match preferentially within-school 
# first match students within schools
# then tries to match remaining students between schools
 mpw &lt;- MatchPW(Y=schools$math, Tr=Tr, X=schools$ses, Group=schools$schid, caliper=0.1)


# examine covariate balance
  bmpw&lt;- CMatchBalance(Tr~ses,data=schools,match.out=mpw)

# proportion of matched observations
  (mpw$orig.treated.nobs-mpw$ndrops) / mpw$orig.treated.nobs 
# check drops by school
  mpw$orig.ndrops.by.group  
  
# estimate the math score difference (default is ATT)
  mpw$estimand

# complete results
   mpw
# or use summary method for main results
   summary(mpw) 


#### Propensity score matching

# estimate the propensity score (eps)

mod &lt;- glm(Tr~ses+parented+public+sex+race+urban,
family=binomial(link="logit"),data=schools)
eps &lt;- fitted(mod)

# eg 1: preferential within-school propensity score matching
MatchPW(Y=schools$math, Tr=Tr, X=eps, Group=schools$schid, caliper=0.1)

# eg 2: standard propensity score matching using eps
# from a logit model with dummies for schools

mod &lt;- glm(Tr ~ ses + parented + public + sex + race + urban 
+schid - 1,family=binomial(link="logit"),data=schools)
eps &lt;- fitted(mod)

MatchPW(Y=schools$math, Tr=Tr, X=eps, caliper=0.1)

# eg3: standard propensity score matching using ps estimated from 
# multilevel logit model (random intercept at the school level)

require(lme4)
mod&lt;-glmer(Tr ~ ses + parented + public + sex + race + urban + (1|schid),
family=binomial(link="logit"), data=schools)
eps &lt;- fitted(mod)

MatchPW(Y=schools$math, Tr=Tr, X=eps, Group=NULL, caliper=0.1)

 
</code></pre>

<hr>
<h2 id='MatchW'>
Within-cluster Matching 
</h2><span id='topic+MatchW'></span>

<h3>Description</h3>

<p>This function implements multivariate and propensity score matching within clusters defined by the <code>Group</code> variable.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatchW(Y = NULL, Tr, X, Group = NULL, estimand = "ATT", M = 1, 
exact = NULL, caliper = 0.25, weights = NULL, replace = TRUE, ties = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MatchW_+3A_y">Y</code></td>
<td>

<p>A vector containing the outcome of interest. 
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_tr">Tr</code></td>
<td>

<p>A vector indicating the treated and control units. 
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_x">X</code></td>
<td>

<p>A matrix of covariates we wish to match on. This matrix should contain all confounders or the propensity score or a combination of both.
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_group">Group</code></td>
<td>

<p>A vector describing the clustering structure (typically the cluster ID). This can be any numeric vector of the same length of <code>Tr</code> and <code>X</code>  containing integer numbers in ascending order otherwise an error message will be returned. Default is NULL, however if <code>Group</code> is missing, NULL or it contains only one value the output of the <code>Match</code> function is returned with a warning.   
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_estimand">estimand</code></td>
<td>

<p>The causal estimand desired, one of &quot;ATE&quot;, &quot;ATT&quot; and &quot;ATC&quot;, which stand for Average Treatment Effect, Average Treatment effect on the Treated and on the Controls, respectively. Default is &quot;ATT&quot;. 
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_m">M</code></td>
<td>

<p>The number of matches which are sought for each unit. Default is 1 (&quot;one-to-one matching&quot;).
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_exact">exact</code></td>
<td>

<p>An indicator for whether exact matching on the variables contained in <code>X</code> is desired. Default is FALSE. This option has precedence over the caliper option.
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_caliper">caliper</code></td>
<td>

<p>A maximum allowed distance for matching units. Units for which no match was found within caliper distance are discarded. Default is 0.25. The caliper is interpreted in standard deviation units of the <em>unclustered</em> data for each variable. For example, if caliper=0.25 all matches at distance bigger than 0.25 times the standard deviation for any of the variables in <code>X</code> are discarded. 
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_weights">weights</code></td>
<td>

<p>A vector of specific observation weights.
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_replace">replace</code></td>
<td>

<p>Matching can be with or without replacement depending on whether matches can be re-used or not. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_ties">ties</code></td>
<td>

<p>An indicator for dealing with multiple matches. If more than M matches are found for each unit the additional matches are a) wholly retained with equal weights if ties=TRUE; b) a random one is chosen if ties=FALSE. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="MatchW_+3A_...">...</code></td>
<td>

<p>Note that additional arguments of the Match function are not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be a natural extension of the <code>Match</code> function to clustered data. It retains the main arguments of <code>Match</code> but it has additional output showing matching results cluster by cluster.
It differs from wrapper <code>Matchby</code> in package <code>Matching</code> in the way standard errors are calculated and because the caliper is in standard deviation units of the covariates on the overall dataset (so the caliper is the same for all clusters). Moreover, observation weights are available. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>index.control</code></td>
<td>
<p>The index of control observations in the matched dataset.</p>
</td></tr>
<tr><td><code>index.treated</code></td>
<td>
<p>The index of control observations in the matched dataset.</p>
</td></tr>
<tr><td><code>index.dropped</code></td>
<td>
<p>The index of dropped observations due to the exact or caliper option. Note that these observations are treated if estimand is &quot;ATT&quot;, controls if &quot;ATC&quot;.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>The causal estimate. This is provided only if <code>Y</code> is not null. If estimand is &quot;ATT&quot; it is the (weighted) mean of <code>Y</code> in matched treated units minus the (weighted) mean of <code>Y</code> in matched controls. Equivalently, it is the weighted average of the within-cluster ATTs, with weights given by cluster sizes in the matched dataset.</p>
</td></tr> 
<tr><td><code>se</code></td>
<td>
<p>A model-based standard error for the causal estimand. This is a cluster robust estimator of the standard error for the linear model: <code>Y ~ constant+Tr</code>, run on the matched dataset (see <code><a href="multiwayvcov.html#topic+cluster.vcov">cluster.vcov</a></code> for details on how this estimator is obtained). Note that these standard errors differ from a weighted average of cluster specific standard errors provided by the <code>Matchby</code> function, which are generally larger. Estimating standard errors for causal parameters with clustered data is an active field of research and there is no perfect solution to date.</p>
</td></tr>   
<tr><td><code>mdata</code></td>
<td>
<p>A list containing the matched datasets produced by <code>MatchPW</code>. Three datasets are included in this list: <code>Y</code>, <code>Tr</code> and <code>X</code>. The matched dataset for <code>Group</code> can be recovered by <code>rbind(Group[index.treated],Group[index.control])</code>.</p>
</td></tr>
<tr><td><code>orig.treated.nobs.by.group</code></td>
<td>
<p>The original number of treated observations by group in the dataset.</p>
</td></tr>
<tr><td><code>orig.control.nobs.by.group</code></td>
<td>
<p>The original number of control observations by group in the dataset.</p>
</td></tr>
<tr><td><code>orig.dropped.nobs.by.group</code></td>
<td>
<p>The number of dropped observations by group after within cluster matching.</p>
</td></tr>
<tr><td><code>orig.nobs</code></td>
<td>
<p>The original number of observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.wnobs</code></td>
<td>
<p>The original number of weighted observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.treated.nobs</code></td>
<td>
<p>The original number of treated observations in the dataset.</p>
</td></tr>
<tr><td><code>orig.control.nobs</code></td>
<td>
<p>The original number of control observations in the dataset.</p>
</td></tr>
<tr><td><code>wnobs</code></td>
<td>
<p>the number of weighted observations in the matched dataset.</p>
</td></tr>
<tr><td><code>caliper</code></td>
<td>
<p>The caliper used.</p>
</td></tr>
<tr><td><code>intcaliper</code></td>
<td>
<p>The internal caliper used.</p>
</td></tr>
<tr><td><code>exact</code></td>
<td>
<p>The value of the exact argument.</p>
</td></tr>
<tr><td><code>ndrops.matches</code></td>
<td>
<p>The number of matches dropped either because of the caliper or exact option (or because of forcing the match within-clusters).</p>
</td></tr>
<tr><td><code>estimand</code></td>
<td>
<p>The estimand required.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function returns an object of class <code>CMatch</code>. The <code>CMatchBalance</code> function can be used to examine the covariate balance before and after matching (see the examples below).
</p>


<h3>Author(s)</h3>

<p>Massimo Cannas &lt;massimo.cannas@unica.it&gt;
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011. Multivariate and Propensity Score Matching Software with Automated Balance Optimization. <em>Journal of Statistical Software 42(7): 1-52.</em> http://www.jstatsoft.org/v42/i07/
</p>
<p>Arpino, B., and Cannas, M. (2016) Propensity score matching with clustered data. An application to the estimation of the impact of caesarean section on the Apgar score. <em>Statistics in Medicine, 35: 2074–2091</em>. doi: 10.1002/sim.6880.
</p>


<h3>See Also</h3>

<p>See also See also <code><a href="Matching.html#topic+Match">Match</a></code>, <code> <a href="Matching.html#topic+MatchBalance">MatchBalance</a></code>,<code><a href="multiwayvcov.html#topic+cluster.vcov">cluster.vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(schools)
	
# Kreft and De Leeuw, Introducing Multilevel Modeling, Sage (1988).   
# The data set is the subsample of NELS-88 data consisting of 10 handpicked schools 
# from the 1003 schools in the full data set.
 
# Let us consider the following variables:

X&lt;-schools$ses 
Y&lt;-schools$math
Tr&lt;-ifelse(schools$homework&gt;1,1,0)
Group&lt;-schools$schid

# Note that when Group is missing / NULL or there is only one group the function MatchW returns
# the output of the Match function with a warning.

# Matching math scores between gropus of students. X are covariate(s) we wish to match on. 

### Matching within schools
 mw &lt;- MatchW(Y=Y, Tr=Tr, X=X, Group=Group, caliper=0.1)
 
 # compare balance before and after matching
   CMatchBalance(Tr~X,data=schools,match.out=mw)
 
 # find proportion of matched observations
  (mw$orig.treated.nobs-mw$ndrops)/mw$orig.treated.nobs 
  
 # check number of drops by school
 mw$orig.ndrops.by.group 
 
 # estimate the math score difference (default is ATT)
  mw$estimand
 
 # examine output
 mw                   # complete results                 
 summary(mw)          # main results
 
 
#### Propensity score matching

# estimate the propensity score (ps) model

mod &lt;- glm(Tr~ses+parented+public+sex+race+urban,
family=binomial(link="logit"),data=schools)
eps &lt;- fitted(mod)

# eg 1: within-school propensity score matching
psmw &lt;- MatchW(Y=schools$math, Tr=Tr, X=eps, Group=schools$schid, caliper=0.1)

# We can use other strategies for controlling unobserved cluster covariates
# by using different specifications of ps:

# eg 2: standard propensity score matching using ps estimated
# from a logit model with dummies for schools

mod &lt;- glm(Tr ~ ses + parented + public + sex + race + urban 
+schid - 1,family=binomial(link="logit"),data=schools)
eps &lt;- fitted(mod)



dpsm &lt;- MatchW(Y=schools$math, Tr=Tr, X=eps, caliper=0.1)
# this is equivalent to run Match with X=eps

# eg3: standard propensity score matching using ps estimated from 
# multilevel logit model (random intercept at the school level)

require(lme4)
mod&lt;-glmer(Tr ~ ses + parented + public + sex + race + urban + (1|schid),
family=binomial(link="logit"), data=schools)
eps &lt;- fitted(mod)

mpsm&lt;-MatchW(Y=schools$math, Tr=Tr, X=eps, Group=NULL, caliper=0.1)
# this is equivalent to run Match with X=eps
 

</code></pre>

<hr>
<h2 id='schools'>
Schools data set (NELS-88)
</h2><span id='topic+schools'></span>

<h3>Description</h3>

<p>Data set used by Kreft and De Leeuw in their book <em>Introducing Multilevel Modeling, Sage (1988)</em> to analyse the relationship between math score and time spent by students to do math homework.
The data set is a subsample of NELS-88 data consisting of 10 handpicked schools from the 1003 schools in the full data set. Students are nested within schools and information is available both at the school and student level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("schools")</code></pre>


<h3>Format</h3>

<p>A data frame with 260 observations on the following 19 variables.
</p>

<dl>
<dt><code>schid</code></dt><dd><p>School ID: a numeric vector identyfing each school.</p>
</dd>
<dt><code>stuid</code></dt><dd><p>The student ID.</p>
</dd>
<dt><code>ses</code></dt><dd><p>Socioeconomic status.</p>
</dd>
<dt><code>meanses</code></dt><dd><p>Mean ses for the school.</p>
</dd>
<dt><code>homework</code></dt><dd><p>The number of hours spent weekly doing homeworks.</p>
</dd>
<dt><code>white</code></dt><dd><p>A dummy for white race (=1) versus non-white (=0).</p>
</dd>
<dt><code>parented</code></dt><dd><p>Parents highest education level.</p>
</dd>
<dt><code>public</code></dt><dd><p>Public school: 1=public, 0=non public.</p>
</dd>
<dt><code>ratio</code></dt><dd><p>Student-teacher ratio.</p>
</dd>
<dt><code>percmin</code></dt><dd><p>Percent minority in school.</p>
</dd>
<dt><code>math</code></dt><dd><p>Math score</p>
</dd>
<dt><code>sex</code></dt><dd><p>Sex: 1=male, 2=female.</p>
</dd>
<dt><code>race</code></dt><dd><p>Race of student, 1=asian, 2=Hispanic, 3=Black, 4=White, 5=Native American.</p>
</dd>
<dt><code>sctype</code></dt><dd><p>Type of school: 1=public, 2=catholic, 3= Private other religion, 4=Private non-r.</p>
</dd>
<dt><code>cstr</code></dt><dd><p>Classroom environment structure: ordinal from 1=not accurate to 5=very much accurate.</p>
</dd>
<dt><code>scsize</code></dt><dd><p>School size: ordinal from 1=[1,199) to 7=[1200+).</p>
</dd>
<dt><code>urban</code></dt><dd><p>Urbanicity: 1=Urban, 2=Suburban, 3=Rural.</p>
</dd>
<dt><code>region</code></dt><dd><p>Geographic region of the school: NE=1,NC=2,South=3,West=4.</p>
</dd>
<dt><code>schnum</code></dt><dd><p>Standardized school ID.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data set is used in the example section to illustrate the use of functions <code>MatchW</code> and <code>MatchPW</code>. 
</p>


<h3>Source</h3>

<p>Ita G G Kreft, Jan De Leeuw 1988. Introducing Multilevel Modeling, Sage
National Education Longitudinal Study of 1988 (NELS:88): https://nces.ed.gov/surveys/nels88/
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+MatchW">MatchW</a></code>, <code> <a href="#topic+MatchPW">MatchPW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(schools)
 
# Kreft and De Leeuw, Introducing Multilevel Modeling, Sage (1988).   
# The data set is the subsample of NELS-88 data consisting of 10 handpicked schools
# from the 1003 schools in the full data set.
 
# To study the effect of the homeworks on the outcome math score, conditional on
# confounder(s) X and unobserved school features, we can define the following variables:

X&lt;-schools$ses 
# or define a vector for more than one confounder
X&lt;-as.matrix(schools[,c("ses","white","public")])
Y&lt;-schools$math
Tr&lt;-ifelse(schools$homework&gt;1,1,0)
Group&lt;-schools$schid

</code></pre>

<hr>
<h2 id='summary.CMatch'>
Summarizing output from MatchW and MatchPW functions
</h2><span id='topic+summary.CMatch'></span><span id='topic+print.summary.CMatch'></span>

<h3>Description</h3>

<p>Summary method for <code><a href="#topic+MatchW">MatchW</a></code> and <code><a href="#topic+MatchPW">MatchPW</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CMatch'
summary(object, ..., full = FALSE, digits = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.CMatch_+3A_object">object</code></td>
<td>

<p>An object of class &quot;<code>CMatch</code>&quot;.
</p>
</td></tr>
<tr><td><code id="summary.CMatch_+3A_...">...</code></td>
<td>

<p>Other options for the generic summary function.
</p>
</td></tr>
<tr><td><code id="summary.CMatch_+3A_full">full</code></td>
<td>

<p>A flag for whether the unadjusted estimates and naive standard errors should also be summarized.
</p>
</td></tr>
<tr><td><code id="summary.CMatch_+3A_digits">digits</code></td>
<td>

<p>The number of significant digits that should be displayed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>Group</code> contains only one value the output is the same of the summary method of package <code>Matching</code>. Otherwise the output shows also the distribution of treated, control and possibly drop units, <em>by group</em>.
</p>


<h3>Value</h3>

<p>A list giving a summary of the output from a &quot;<code>CMatch</code>&quot; object. The list includes the size of the original and the matched dataset, the number of treated and control observations in each group and the estimate (if <code>Y</code> is not <code>NULL</code>). 
</p>


<h3>Note</h3>

<p>Naive standard errors are not available when there is more than one group so the <code>full</code> parameter is ineffective in that case. 
</p>


<h3>Author(s)</h3>

<p>Massimo Cannas  &lt;massimo.cannas@unica.it&gt;
</p>


<h3>References</h3>

<p>Sekhon, Jasjeet S. 2011. Multivariate and Propensity Score Matching Software with Automated Balance Optimization. <em>Journal of Statistical Software 42(7): 1-52.</em> http://www.jstatsoft.org/v42/i07/
</p>
<p>Arpino, B., and Cannas, M. (2016) Propensity score matching with clustered data. An application to the estimation of the impact of caesarean section on the Apgar score. <em>Statistics in Medicine, 35: 2074–2091</em>. doi: 10.1002/sim.6880.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+CMatch">CMatch</a></code>, <code> <a href="#topic+CMatchBalance">CMatchBalance</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
