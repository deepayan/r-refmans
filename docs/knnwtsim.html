<!DOCTYPE html><html><head><title>Help for package knnwtsim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {knnwtsim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boston_911dispatch_weekly'><p>boston_911dispatch_weekly</p></a></li>
<li><a href='#boston_fire_incidents_monthly'><p>boston_fire_incidents_monthly</p></a></li>
<li><a href='#boston_fire_incidents_weekly'><p>boston_fire_incidents_weekly</p></a></li>
<li><a href='#knn.forecast'><p>KNN Forecast</p></a></li>
<li><a href='#knn.forecast.boot.intervals'><p>KNN Forecast Bootstrap Prediction Intervals</p></a></li>
<li><a href='#knn.forecast.randomsearch.tuning'><p>Tune <code>knn.forecast()</code> Hyperparameters with Random Search</p></a></li>
<li><a href='#NNreg'><p>Estimate a Single Point with K Nearest Neighbors Regression</p></a></li>
<li><a href='#SeasonalAbsDissimilarity'><p>Seasonal Absolute Dissimilarity</p></a></li>
<li><a href='#simulation_master_list'><p>simulation_master_list</p></a></li>
<li><a href='#SpMatrixCalc'><p>Calculate Seasonal Similarity Matrix</p></a></li>
<li><a href='#StMatrixCalc'><p>Calculate Temporal Similarity Matrix</p></a></li>
<li><a href='#SwMatrixCalc'><p>Calculate Weighted Similarity Matrix</p></a></li>
<li><a href='#SxMatrixCalc'><p>Calculate Similarity Matrix for Exogenous Predictors</p></a></li>
<li><a href='#TempAbsDissimilarity'><p>Temporal Absolute Dissimilarity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>K Nearest Neighbor Forecasting with a Tailored Similarity Metric</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Trupiano</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Trupiano &lt;matthew.trupiano.professional@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to implement K Nearest Neighbor forecasting using a weighted similarity metric tailored to the problem of forecasting univariate time series where recent observations, seasonal patterns, and exogenous predictors are all relevant in predicting future observations of the series in question. For more information on the formulation of this similarity metric please see Trupiano (2021) &lt;<a href="https://arxiv.org/abs/2112.06266">arXiv:2112.06266</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mtrupiano1/knnwtsim">https://github.com/mtrupiano1/knnwtsim</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mtrupiano1/knnwtsim/issues">https://github.com/mtrupiano1/knnwtsim/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-05 21:09:03 UTC; mtrup</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-05 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='boston_911dispatch_weekly'>boston_911dispatch_weekly</h2><span id='topic+boston_911dispatch_weekly'></span>

<h3>Description</h3>

<p>A dataset which contains the weekly count of 911 dispatches in the city of
Boston, MA, USA, for three City of Boston public safety agencies: Boston Police Department, Boston Fire Department,
and Boston Emergency Medical Services. In addition a number of holiday indicators, and dummy variables for months.
Data is present for weeks between 2010-10-31 and 2014-04-20. Derived by Matthew Trupiano
from a .csv file (911 Daily Dispatch Count By Agency (CSV)) hosted on <a href="https://data.boston.gov/">https://data.boston.gov/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boston_911dispatch_weekly
</code></pre>


<h3>Format</h3>

<p>A dataframe with 182 rows and 28 variables:
</p>

<dl>
<dt>week</dt><dd><p>first day of a given week (Sunday), date.</p>
</dd>
<dt>BPD</dt><dd><p>summarized count of 911 dispatches from the Sunday in the week variable to the Saturday before the next week for the Boston Police Department.</p>
</dd>
<dt>EMS</dt><dd><p>summarized count of 911 dispatches from the Sunday in the week variable to the Saturday before the next week for the Boston Emergency Medical Services.</p>
</dd>
<dt>BFD</dt><dd><p>summarized count of 911 dispatches from the Sunday in the week variable to the Saturday before the next week for the Boston Fire Department.</p>
</dd>
<dt>new.years.ind</dt><dd><p>1 if YYYY-01-01 or YYYY-12-31 occur during the week else 0.</p>
</dd>
<dt>christmas.ind</dt><dd><p>1 if YYYY-12-24 or YYYY-12-25 occur during the week else 0.</p>
</dd>
<dt>thanksgiving.ind</dt><dd><p>1 if the holiday Thanksgiving occurs during the week else 0.</p>
</dd>
<dt>veterans.ind</dt><dd><p>1 if YYYY-11-11 occurs during the week else 0.</p>
</dd>
<dt>indigenous.ind</dt><dd><p>1 if the holiday Indigenous Peoples Day occurs during the week else 0.</p>
</dd>
<dt>labor.ind</dt><dd><p>1 if the holiday Labor Day occurs during the week else 0.</p>
</dd>
<dt>july4.ind</dt><dd><p>1 if YYYY-07-04 occurs during the week else 0.</p>
</dd>
<dt>juneteenth.ind</dt><dd><p>1 if YYYY-06-19 occurs during the week and the week st is &gt;= '2020-06-01' else 0.</p>
</dd>
<dt>memorial.ind</dt><dd><p>1 if the holiday Memorial Day occurs during the week else 0.</p>
</dd>
<dt>patriots.ind</dt><dd><p>1 if the holiday Patriot's Day occurs during the week else 0.</p>
</dd>
<dt>st.patricks.ind</dt><dd><p>1 if YYYY-03-17 occurs during the week else 0.</p>
</dd>
<dt>presidents.ind</dt><dd><p>1 if the holiday President's Day occurs during the week else 0.</p>
</dd>
<dt>mlk.ind</dt><dd><p>1 if the holiday Martin Luther King Jr. Day occurs during the week else 0.</p>
</dd>
<dt>jan.ind</dt><dd><p>1 if week variable occurs in January else 0.</p>
</dd>
<dt>feb.ind</dt><dd><p>1 if week variable occurs in February else 0.</p>
</dd>
<dt>mar.ind</dt><dd><p>1 if week variable occurs in March else 0.</p>
</dd>
<dt>apr.ind</dt><dd><p>1 if week variable occurs in April else 0.</p>
</dd>
<dt>may.ind</dt><dd><p>1 if week variable occurs in May else 0.</p>
</dd>
<dt>jun.ind</dt><dd><p>1 if week variable occurs in June else 0.</p>
</dd>
<dt>jul.ind</dt><dd><p>1 if week variable occurs in July else 0.</p>
</dd>
<dt>aug.ind</dt><dd><p>1 if week variable occurs in August else 0.</p>
</dd>
<dt>sep.ind</dt><dd><p>1 if week variable occurs in September else 0.</p>
</dd>
<dt>oct.ind</dt><dd><p>1 if week variable occurs in October else 0.</p>
</dd>
<dt>nov.ind</dt><dd><p>1 if week variable occurs in November else 0.</p>
</dd>
<dt>dec.ind</dt><dd><p>1 if week variable occurs in December else 0.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://data.boston.gov/dataset/911-daily-dispatch-count-by-agency">https://data.boston.gov/dataset/911-daily-dispatch-count-by-agency</a>
</p>

<hr>
<h2 id='boston_fire_incidents_monthly'>boston_fire_incidents_monthly</h2><span id='topic+boston_fire_incidents_monthly'></span>

<h3>Description</h3>

<p>A dataset which contains the monthly count of fire incidents in the city of
Boston, MA, USA, as well as one indicator for the period where a
COVID-19 state of emergency was declared in Massachusetts.
Data is present for starting from 2017-01-01 to 2021-07-01. Derived by Matthew Trupiano
from a series of .csv files hosted on <a href="https://data.boston.gov/">https://data.boston.gov/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boston_fire_incidents_monthly
</code></pre>


<h3>Format</h3>

<p>A dataframe with 55 rows and 3 variables:
</p>

<dl>
<dt>week</dt><dd><p>first day of a given month, date.</p>
</dd>
<dt>incidents</dt><dd><p>summarized count of fire incidents in the month which starts the date of the corresponding month variable.</p>
</dd>
<dt>covid.soe.ind</dt><dd><p>1 if the month contains days between '2020-03-10' and '2021-06-15' when a state of emergency for COVID-19 was declared in Massachusetts else 0.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://data.boston.gov/dataset/fire-incident-reporting">https://data.boston.gov/dataset/fire-incident-reporting</a>
</p>

<hr>
<h2 id='boston_fire_incidents_weekly'>boston_fire_incidents_weekly</h2><span id='topic+boston_fire_incidents_weekly'></span>

<h3>Description</h3>

<p>A dataset which contains the weekly count of fire incidents in the city of
Boston, MA, USA, as well as a number of holiday indicators and one indicator
for the period where a COVID-19 state of emergency was declared in Massachusetts.
Data is present for weeks between 2017-01-01 and 2021-07-25. Derived by Matthew Trupiano
from a series of .csv files hosted on <a href="https://data.boston.gov/">https://data.boston.gov/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boston_fire_incidents_weekly
</code></pre>


<h3>Format</h3>

<p>A dataframe with 239 rows and 16 variables:
</p>

<dl>
<dt>week</dt><dd><p>first day of a given week (Sunday), date.</p>
</dd>
<dt>incidents</dt><dd><p>summarized count of fire incidents from the Sunday in the week variable to the Saturday before the next week.</p>
</dd>
<dt>new.years.ind</dt><dd><p>1 if YYYY-01-01 or YYYY-12-31 occur during the week else 0.</p>
</dd>
<dt>christmas.ind</dt><dd><p>1 if YYYY-12-24 or YYYY-12-25 occur during the week else 0.</p>
</dd>
<dt>thanksgiving.ind</dt><dd><p>1 if the holiday Thanksgiving occurs during the week else 0.</p>
</dd>
<dt>veterans.ind</dt><dd><p>1 if YYYY-11-11 occurs during the week else 0.</p>
</dd>
<dt>indigenous.ind</dt><dd><p>1 if the holiday Indigenous Peoples Day occurs during the week else 0.</p>
</dd>
<dt>labor.ind</dt><dd><p>1 if the holiday Labor Day occurs during the week else 0.</p>
</dd>
<dt>july4.ind</dt><dd><p>1 if YYYY-07-04 occurs during the week else 0.</p>
</dd>
<dt>juneteenth.ind</dt><dd><p>1 if YYYY-06-19 occurs during the week and the week st is &gt;= '2020-06-01' else 0.</p>
</dd>
<dt>memorial.ind</dt><dd><p>1 if the holiday Memorial Day occurs during the week else 0.</p>
</dd>
<dt>patriots.ind</dt><dd><p>1 if the holiday Patriot's Day occurs during the week else 0.</p>
</dd>
<dt>st.patricks.ind</dt><dd><p>1 if YYYY-03-17 occurs during the week else 0.</p>
</dd>
<dt>presidents.ind</dt><dd><p>1 if the holiday President's Day occurs during the week else 0.</p>
</dd>
<dt>mlk.ind</dt><dd><p>1 if the holiday Martin Luther King Jr. Day occurs during the week else 0.</p>
</dd>
<dt>covid.soe.ind</dt><dd><p>1 if the week contains days between '2020-03-10' and '2021-06-15' when a state of emergency for COVID-19 was declared in Massachusetts else 0.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://data.boston.gov/dataset/fire-incident-reporting">https://data.boston.gov/dataset/fire-incident-reporting</a>
</p>

<hr>
<h2 id='knn.forecast'>KNN Forecast</h2><span id='topic+knn.forecast'></span>

<h3>Description</h3>

<p>Provide an n x n similarity matrix as input, all points both observed and those to be
forecasted should be included. The <code>f.index.in</code> argument indicates which observations
to identify neighbors for, and removes them from consideration as eligible neighbors.
Once the matrix is subset down to only the columns in <code>f.index.in</code> and the rows excluding <code>f.index.in</code>, the
<code>NNreg()</code> function is applied over the columns, returning for each column the mean of those points in <code>y.in</code> identified as neighbors
based on the row index of the <code>k.in</code> most similar observations in the column. It is important that the index of the similarity matrix
and <code>y.in</code> accurately reflect the time order of the observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.forecast(Sim.Mat.in, f.index.in, k.in, y.in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn.forecast_+3A_sim.mat.in">Sim.Mat.in</code></td>
<td>
<p>numeric and symmetric matrix of similarities (recommend use of <code>S_w</code>, see <code>SwMatrixCalc()</code>).</p>
</td></tr>
<tr><td><code id="knn.forecast_+3A_f.index.in">f.index.in</code></td>
<td>
<p>numeric vector indicating the indices of <code>Sim.Mat.in</code> and <code>y.in</code> which correspond to the time order of the points to be forecast.</p>
</td></tr>
<tr><td><code id="knn.forecast_+3A_k.in">k.in</code></td>
<td>
<p>integer value indicating the the number of nearest neighbors to be considered in forecasting, must be <code>&gt;= 1</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast_+3A_y.in">y.in</code></td>
<td>
<p>numeric vector of the response series to be forecast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the same length as <code>f.index.in</code>, of forecasted observations.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+NNreg">NNreg()</a></code> for the function used to perform knn regression on a single
point.
</p>
</li>
<li> <p><code><a href="#topic+SwMatrixCalc">SwMatrixCalc()</a></code> for the function to calculate a matrix with the recommended similarity measure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>Sim.Mat &lt;- matrix(c(1, .5, .2, .5, 1, .7, .2, .7, 1),
  nrow = 3, ncol = 3, byrow = TRUE
)
y &lt;- c(2, 1, 5)
f.index &lt;- c(3)
k &lt;- 2
knn.forecast(Sim.Mat.in = Sim.Mat, f.index.in = f.index, y.in = y, k.in = k)
</code></pre>

<hr>
<h2 id='knn.forecast.boot.intervals'>KNN Forecast Bootstrap Prediction Intervals</h2><span id='topic+knn.forecast.boot.intervals'></span>

<h3>Description</h3>

<p>A function for forecasting using KNN regression with prediction intervals. The approach is based on the description of
&quot;Prediction intervals from bootstrapped residuals&quot; from chapter 5.5 of Hyndman R, Athanasopoulos G (2021) <a href="https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals">https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals</a>,
modified as needed for use with KNN regression. The algorithm starts by calculating a pool of forecast errors to later
sample from. If there are <code>n</code> points prior to the first observation indicated in <code>f.index.in</code> then there will be <code>n - k.in</code> errors generated by one-step ahead forecasts
starting with the point of the response series at the index <code>k.in + 1</code>. The first <code>k.in</code> points cannot be estimated because
a minimum of <code>k.in</code> eligible neighbors would be needed. The optional <code>burn.in</code> argument can be used to increase the number
of points from the start of the series that need to be available as neighbors before calculating errors for the pool. Next, <code>B</code>
possible paths the series could take are simulated using the pool of errors. Each path is simulated by calling <code>knn.forecast()</code>, estimating the first point in <code>f.index.in</code>, adding a sampled forecast error, then adding
this value to the end of the series. This process is then repeated for the next point in <code>f.index.in</code> until all have been estimated. The final output
interval estimates are calculated for each point in <code>f.index.in</code> by taking the appropriate percentiles of the corresponding simulations of that point.
The mean and medians are also calculated from these simulations. One important implication of this behavior is that the mean forecast output from this function can
differ from the point forecast produced by <code>knn.forecast()</code> alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.forecast.boot.intervals(
  Sim.Mat.in,
  f.index.in,
  k.in,
  y.in,
  burn.in = NULL,
  B = 200,
  return.simulations = FALSE,
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn.forecast.boot.intervals_+3A_sim.mat.in">Sim.Mat.in</code></td>
<td>
<p>numeric and symmetric matrix of similarities (recommend use of <code>S_w</code>, see <code>SwMatrixCalc()</code>).</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_f.index.in">f.index.in</code></td>
<td>
<p>numeric vector indicating the indices of <code>Sim.Mat.in</code> and <code>y.in</code> which correspond to the time order of the points to be forecast.</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_k.in">k.in</code></td>
<td>
<p>integer value indicating the the number of nearest neighbors to be considered in forecasting, must be <code>&gt;= 1</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_y.in">y.in</code></td>
<td>
<p>numeric vector of the response series to be forecast.</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_burn.in">burn.in</code></td>
<td>
<p>integer value which indicates how many points at the start of the series to set aside as eligible neighbors before calculating forecast errors to be re-sampled.</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_b">B</code></td>
<td>
<p>integer value representing the number of bootstrap replications, this will be the number of forecasts simulated and used to calculate outputs, must be <code>&gt;= 1</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_return.simulations">return.simulations</code></td>
<td>
<p>logical value indicating whether to return all simulated forecasts.</p>
</td></tr>
<tr><td><code id="knn.forecast.boot.intervals_+3A_level">level</code></td>
<td>
<p>numeric value over the range (0,1) indicating the confidence level for the prediction intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the following components:
</p>

<dl>
<dt>lb</dt><dd><p>numeric vector of the same length as <code>f.index.in</code>, with the estimated lower bound of the prediction interval.</p>
</dd>
<dt>ub</dt><dd><p>numeric vector of the same length as <code>f.index.in</code>, with the estimated upper bound of the prediction interval.</p>
</dd>
<dt>mean</dt><dd><p>numeric vector of the same length as <code>f.index.in</code>, with the mean of the <code>B</code> simulated paths for each forecasted point.</p>
</dd>
<dt>median</dt><dd><p>numeric vector of the same length as <code>f.index.in</code>, with the median of the <code>B</code> simulated paths for each forecasted point.</p>
</dd>
<dt>simulated.paths</dt><dd><p>numeric matrix where each of the <code>B</code> rows contains a simulated path for the points in <code>f.index.in</code>, only returned if <code>return.simulations = TRUE</code>.</p>
</dd>
</dl>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+knn.forecast">knn.forecast()</a></code> for the function called to perform knn regression.
</p>
</li>
<li> <p><code><a href="#topic+SwMatrixCalc">SwMatrixCalc()</a></code> for the function to calculate a matrix with the recommended similarity measure.
</p>
</li>
<li><p> Hyndman R, Athanasopoulos G (2021),&quot;Forecasting: Principles and Practice, 3rd ed&quot;, Chapter 5.5, <a href="https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals">https://otexts.com/fpp3/prediction-intervals.html#prediction-intervals-from-bootstrapped-residuals</a>.
For background on the algorithm this function is based on.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("simulation_master_list")
series.index &lt;- 15
ex.series &lt;- simulation_master_list[[series.index]]$series.lin.coef.chng.x

# Weights pre tuned by random search. In alpha, beta, gamma order
pre.tuned.wts &lt;- c(0.2148058, 0.2899638, 0.4952303)
pre.tuned.k &lt;- 5

df &lt;- data.frame(ex.series)
# Generate vector of time orders
df$t &lt;- c(1:nrow(df))

# Generate vector of periods
nperiods &lt;- simulation_master_list[[series.index]]$seasonal.periods
df$p &lt;- rep(1:nperiods, length.out = nrow(df))

# Pull corresponding exogenous predictor(s)
X &lt;- as.matrix(simulation_master_list[[series.index]]$x.chng)


# Calculate the weighted similarity matrix using Sw
Sw.ex &lt;- SwMatrixCalc(
  t.in = df$t,
  p.in = df$p, nPeriods.in = nperiods,
  X.in = X,
  weights = pre.tuned.wts
)

n &lt;- length(ex.series)
# Index we want to forecast
f.index &lt;- c((n - 5 + 1):length(ex.series))

interval.forecast &lt;- knn.forecast.boot.intervals(
  Sim.Mat.in = Sw.ex,
  f.index.in = f.index,
  y.in = ex.series,
  k.in = pre.tuned.k
)
</code></pre>

<hr>
<h2 id='knn.forecast.randomsearch.tuning'>Tune <code>knn.forecast()</code> Hyperparameters with Random Search</h2><span id='topic+knn.forecast.randomsearch.tuning'></span>

<h3>Description</h3>

<p>A simplistic automated hyperparameter tuning function which randomly
generates a grid of hyperparameter sets used to build corresponding <code>S_w</code> similarity matrices
which are used in <code>knn.forecast()</code> test against the last <code>test.h</code> points of <code>y.in</code> after
any <code>val.holdout.len</code> points are removed from the end of <code>y.in</code>. The best performing set of
parameters based on MAPE over over the forecast horizon of <code>test.h</code> points are returned as part of a list
alongside the 'optimum' weighted similarity matrix <code>Sw.opt</code>, the <code>Grid</code> of tested sets, and the MAPE
results. MAPE is the average of absolute percent errors for each point calculated as: <code>abs((test.actuals - test.forecast.i) / test.actuals) * 100</code>. Where <code>test.forecast.i</code>
and <code>test.actuals</code> are both numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn.forecast.randomsearch.tuning(
  grid.len = 100,
  St.in,
  Sp.in,
  Sx.in,
  y.in,
  test.h = 1,
  max.k = NULL,
  val.holdout.len = 0,
  min.k = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_grid.len">grid.len</code></td>
<td>
<p>integer value representing the number of hyperparameter sets to generate and test, must be <code>&gt;= 1</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_st.in">St.in</code></td>
<td>
<p>numeric and symmetric matrix of similarities, can be generated with <code>StMatrixCalc()</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_sp.in">Sp.in</code></td>
<td>
<p>numeric and symmetric matrix of similarities, can be generated with <code>SpMatrixCalc()</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_sx.in">Sx.in</code></td>
<td>
<p>numeric and symmetric matrix of similarities, can be generated with <code>SxMatrixCalc()</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_y.in">y.in</code></td>
<td>
<p>numeric vector of the response series to be forecast.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_test.h">test.h</code></td>
<td>
<p>integer value representing the number of points in the test forecast horizon, must be <code>&gt;= 1</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_max.k">max.k</code></td>
<td>
<p>integer value representing the maximum value of k, <code>knn.forecast()</code> should use, will be set to <code>min(floor((length(y.in)) * .4), length(y.in) - val.holdout.len - test.h)</code> if <code>NULL</code> or <code>NA</code> is passed. Note this <code>NA</code> behavior differs from <code>knnwtsim</code> version 0.1.0.
If a numeric value is passed it must be <code>&gt;= 1</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_val.holdout.len">val.holdout.len</code></td>
<td>
<p>integer value representing the number of observations at the end of the series to be removed in testing forecast if desired to leave a validation set after tuning, must be <code>&gt;= 0</code>.</p>
</td></tr>
<tr><td><code id="knn.forecast.randomsearch.tuning_+3A_min.k">min.k</code></td>
<td>
<p>integer value representing the minimum value of k, <code>knn.forecast()</code> should use, must be <code>&gt;= 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the following components:
</p>

<dl>
<dt>weight.opt</dt><dd><p>numeric vector of the 3 weights to generate <code>Sw.opt</code> in alpha, beta, gamma order which achieved the best performance in terms of MAPE.</p>
</dd>
<dt>k.opt</dt><dd><p>integer value of neighbors used in <code>knn.forecast()</code> which achieved the best performance in terms of MAPE.</p>
</dd>
<dt>Sw.opt</dt><dd><p>numeric matrix of similarities calculated using <code>S_w</code>, with the best performing set of hyperparameters.</p>
</dd>
<dt>Test.MAPE</dt><dd><p>numeric value of the MAPE result for the optimum hyperparamter set achieved on the test points.</p>
</dd>
<dt>MAPE.all</dt><dd><p>numeric vector of MAPE results, each observation corresponds to the row in <code>Grid</code> of the same index.</p>
</dd>
<dt>Grid</dt><dd><p>dataframe of all hyperparameter sets tested in the tuning.</p>
</dd>
</dl>



<h3>See Also</h3>


<ul>
<li><p> Trupiano (2021) arXiv:2112.06266 for information on the formulation of <code>S_w</code>.
</p>
</li>
<li> <p><code><a href="#topic+StMatrixCalc">StMatrixCalc()</a></code> for information on the calculation of <code>S_t</code>.
</p>
</li>
<li> <p><code><a href="#topic+SpMatrixCalc">SpMatrixCalc()</a></code> for information on the calculation of <code>S_p</code>.
</p>
</li>
<li> <p><code><a href="#topic+SxMatrixCalc">SxMatrixCalc()</a></code> for information on the calculation of <code>S_x</code>.
</p>
</li>
<li> <p><code><a href="#topic+knn.forecast">knn.forecast()</a></code> for the function called to perform knn regression.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("simulation_master_list")
series.index &lt;- 15
ex.series &lt;- simulation_master_list[[series.index]]$series.lin.coef.chng.x

df &lt;- data.frame(ex.series)
# Generate vector of time orders
df$t &lt;- c(1:nrow(df))
# Generate vector of periods
nperiods &lt;- simulation_master_list[[series.index]]$seasonal.periods
df$p &lt;- rep(1:nperiods, length.out = nrow(df))
# Pull corresponding exogenous predictor(s)
X &lt;- as.matrix(simulation_master_list[[series.index]]$x.chng)

St.ex &lt;- StMatrixCalc(df$t)
Sp.ex &lt;- SpMatrixCalc(df$p, nPeriods = nperiods)
Sx.ex &lt;- SxMatrixCalc(X)

tuning.test &lt;- knn.forecast.randomsearch.tuning(
  grid.len = 10,
  y.in = ex.series,
  St.in = St.ex,
  Sp.in = Sp.ex,
  Sx.in = Sx.ex,
  test.h = 3,
  max.k = 10,
  val.holdout.len = 3
)
</code></pre>

<hr>
<h2 id='NNreg'>Estimate a Single Point with K Nearest Neighbors Regression</h2><span id='topic+NNreg'></span>

<h3>Description</h3>

<p>Finds the index of the nearest neighbors for a single point given that point's
vector of similarities to all observations eligible to be considered as neighbors. The <code>k.in2</code>
neighbors are identified by their index in the similarity vector, and this index is used to
identify the neighbor points in <code>y.in2</code>. The function then returns the mean of the values
in <code>y.in2</code> identified as neighbors. It is suggested to call this function through <code>knn.forecast()</code>
for all points to be forecasted simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNreg(v, k.in2, y.in2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNreg_+3A_v">v</code></td>
<td>
<p>numeric vector of similarities used to identify nearest neighbors.</p>
</td></tr>
<tr><td><code id="NNreg_+3A_k.in2">k.in2</code></td>
<td>
<p>integer value indicating the the number of nearest neighbors to be considered.</p>
</td></tr>
<tr><td><code id="NNreg_+3A_y.in2">y.in2</code></td>
<td>
<p>numeric vector of the response series to be forecast.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the mean of the <code>k.in2</code> nearest neighbors in <code>y.in2</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+knn.forecast">knn.forecast()</a></code> the recommended user facing function to perform knn
regression for forecasting with <code>NNreg()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sim.Mat &lt;- matrix(c(1, .5, .2, .5, 1, .7, .2, .7, 1),
  nrow = 3, ncol = 3, byrow = TRUE
)
Sim.Mat.col &lt;- Sim.Mat[-(3), 3]
y &lt;- c(2, 1, 5)
k &lt;- 2
NNreg(v = Sim.Mat.col, k.in2 = 2, y.in2 = y)
</code></pre>

<hr>
<h2 id='SeasonalAbsDissimilarity'>Seasonal Absolute Dissimilarity</h2><span id='topic+SeasonalAbsDissimilarity'></span>

<h3>Description</h3>

<p>Calculate seasonal dissimilarity measure between the respective seasonal period
two points, given the number of periods in one full seasonal cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeasonalAbsDissimilarity(p1, p2, nPeriods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeasonalAbsDissimilarity_+3A_p1">p1</code></td>
<td>
<p>numeric value representing a seasonal period.</p>
</td></tr>
<tr><td><code id="SeasonalAbsDissimilarity_+3A_p2">p2</code></td>
<td>
<p>numeric value representing a seasonal period.</p>
</td></tr>
<tr><td><code id="SeasonalAbsDissimilarity_+3A_nperiods">nPeriods</code></td>
<td>
<p>numeric value representing the maximum value <code>p1</code> or <code>p2</code> can take on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the seasonal dissimilarity between <code>p1</code> and <code>p2</code>.
</p>


<h3>See Also</h3>

<p>Trupiano (2021) arXiv:2112.06266 for information on the formulation of this seasonal dissimilarity measure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SeasonalAbsDissimilarity(1, 4, 4)
</code></pre>

<hr>
<h2 id='simulation_master_list'>simulation_master_list</h2><span id='topic+simulation_master_list'></span>

<h3>Description</h3>

<p>A list of 20 lists. Each of the 20 lists contains 31 items including 4 simulated time series.
Each series contains an ARIMA component, a periodic component simulated using trig functions, a component determined by a functional relationship
to exogenous predictors which we will call the f(x) component, a constant, and finally additional noise generated from either a
Gaussian distribution with mean = 0, or Poisson distribution. The 4 series within a given sublist only differ based on the f(x) component of the series. One series, <code>series.mvnormx</code>, uses
a matrix <code>X</code> generated by <code>MASS::mvrnorm()</code> with corresponding coefficients for the f(x) component. All other
series use piece-wise functional relationships for the f(x) component of the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulation_master_list
</code></pre>


<h3>Format</h3>

<p>A list containing 20 sublists each with 31 items:
</p>

<dl>
<dt>series.len</dt><dd><p>the number of observations in the simulated time series</p>
</dd>
<dt>random.seed</dt><dd><p>the random seed used in <code>set.seed()</code> for all random components in the sublist.</p>
</dd>
<dt>arima.p</dt><dd><p>The AR order argument for <code>stats::arima.sim()</code>.</p>
</dd>
<dt>arima.d</dt><dd><p>The differencing order argument for <code>stats::arima.sim()</code>.</p>
</dd>
<dt>arima.q</dt><dd><p>The MA order argument for <code>stats::arima.sim()</code>.</p>
</dd>
<dt>ar.coefficients</dt><dd><p>Coefficients for the AR process in <code>stats::arima.sim()</code>,<code>NULL</code> if <code>arima.p=0</code>.</p>
</dd>
<dt>ma.coefficients</dt><dd><p>Coefficients for the MA process in <code>stats::arima.sim()</code>,<code>NULL</code> if <code>arima.q=0</code>.</p>
</dd>
<dt>seasonal.periods</dt><dd><p>The number of periods in a full cycle for the periodic component of the series.</p>
</dd>
<dt>sin.coef</dt><dd><p>Coefficient on the sin term of the periodic component of the series.</p>
</dd>
<dt>cos.coef</dt><dd><p>Coefficient on the cos term of the periodic component of the series.</p>
</dd>
<dt>X.cols</dt><dd><p>Number of predictors used to generate the f(x) component of <code>series.mvnormx</code>.</p>
</dd>
<dt>X.mu</dt><dd><p>The mean vector used in <code>MASS::mvrnorm()</code> to generate <code>X</code> for the f(x) component of <code>series.mvnormx</code>.</p>
</dd>
<dt>X.Sigma</dt><dd><p>The covariance matrix generated by <code>clusterGeneration::rcorrmatrix()</code> used in <code>MASS::mvrnorm()</code> to generate <code>X</code> for the f(x) component of <code>series.mvnormx</code>.</p>
</dd>
<dt>X</dt><dd><p>The matrix of <code>X.cols</code> predictors generated by <code>MASS::mvrnorm()</code> used to generate the f(x) component of <code>series.mvnormx</code>.</p>
</dd>
<dt>x.coef</dt><dd><p>The vector of <code>X.cols</code> coefficients corresponding to the predictors of <code>X</code> used to generate the f(x) component of <code>series.mvnormx</code>.</p>
</dd>
<dt>x.chng.mu</dt><dd><p>The mean value used in <code>stats::rnorm()</code> used to generate <code>x.chng</code>.</p>
</dd>
<dt>x.chng.sd</dt><dd><p>The standard deviation value used in <code>stats::rnorm()</code> used to generate <code>x.chng</code>.</p>
</dd>
<dt>x.chng.coef1</dt><dd><p>A coefficient for <code>x.chng</code> used in all piece-wise functional relationship, f(x), components, as the <code>coef</code> argument to <code>lin.to.sqrt()</code> and <code>quad.to.cubic</code>
and the <code>coef1</code> argument to <code> lin.coef.change </code>.</p>
</dd>
<dt>x.chng.coef2</dt><dd><p>A coefficient for <code>x.chng</code> used in the piece-wise functional relationship, f(x), component of <code>series.lin.coef.chng.x</code>, as the <code>coef2</code> argument to <code> lin.coef.change </code>.</p>
</dd>
<dt>x.chng.break.point</dt><dd><p>A value used in two piece-wise functional relationship, f(x), components, as the <code>break.point</code> argument to <code>quad.to.cubic</code> and <code> lin.coef.change </code>.</p>
</dd>
<dt>x.chng.break.point.sqrt</dt><dd><p>The <code>max()</code> of <code>x.chng.break.point</code> and some value &gt; 0. Used in the piece-wise functional relationship, f(x), component of <code>series.lin.to.sqrt.x</code> , as the <code>break.point</code> argument to <code>lin.to.sqrt</code>.</p>
</dd>
<dt>x.chng</dt><dd><p>A vector of observations of a single predictor used to generate the f(x) component of all series other than <code>series.mvnormx</code>.</p>
</dd>
<dt>type.noise</dt><dd><p>The family of probability distributions to to generate the additional noise component.</p>
</dd>
<dt>poisson.rate</dt><dd><p>The <code>lambda</code> argument of <code>stats::rpois()</code> used to generate additional noise, only actually used if <code>type.noise = 'poisson'</code>. </p>
</dd>
<dt>norma.sd</dt><dd><p>The <code>sd</code> argument of <code>stats::rnorm()</code> used to generate additional noise, only actually used if <code>type.noise = 'normal'</code>. </p>
</dd>
<dt>constant</dt><dd><p>A numeric value which is the constant component of the series.</p>
</dd>
<dt>series.mvnormx</dt><dd><p>A simulated time series generated from the sum of ARIMA, Periodic, f(x), noise, and constant components. In this case f(x) represents linear relationships to the columns of the matrix <code>X</code>.  </p>
</dd>
<dt>series.lin.to.sqrt.x</dt><dd><p>A simulated time series generated from the sum of ARIMA, Periodic, f(x), noise, and constant components. In this case f(x) represents a linear relationship to a single predictor <code>x.chng</code> which changes to a <code>sqrt(x.chng)</code>
relationship when <code>x.chng &gt; x.chng.break.point.sqrt</code>.</p>
</dd>
<dt>series.lin.coef.chng.x</dt><dd><p>A simulated time series generated from the sum of ARIMA, Periodic, f(x), noise, and constant components. In this case f(x) represents a linear relationship to a single predictor <code>x.chng</code> which changes coefficient when
<code>x.chng &gt; x.chng.break.point</code>.</p>
</dd>
<dt>series.quad.to.cubic.x</dt><dd><p>A simulated time series generated from the sum of ARIMA, Periodic, f(x), noise, and constant components. In this case f(x) represents a quadratic relationship to a single predictor <code>x.chng</code> which changes to a cubic relationship when
<code>x.chng &gt; x.chng.break.point</code>, in addition a coefficient changes sign at <code>x.chng.break.point</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Below we have the functional relationships used for the piece-wise series:
</p>
<p><code>lin.to.sqrt &lt;- function(x, break.point, coef){
 if (x &lt; break.point) {
  out &lt;- coef * x
} else {
  out &lt;- sqrt(x)
 }
return(out)
 }
</code>
</p>
<p><code>quad.to.cubic &lt;- function(x, break.point, coef){
 if (x &lt; break.point) {
  out &lt;- coef * (x ** 2)
} else {
  out &lt;- -coef * (x ** 3)
}
return(out)
}
</code>
</p>
<p><code> lin.coef.change &lt;- function(x, break.point, coef1, coef2){
if (x &lt; break.point) {
  out &lt;- coef1 * x
} else {
  out &lt;- coef2 * x
}
return(out)
}
</code>
</p>


<h3>Source</h3>

<p><a href="https://github.com/mtrupiano1/knnwtsim/blob/main/data-raw/simulation_master_list.R">https://github.com/mtrupiano1/knnwtsim/blob/main/data-raw/simulation_master_list.R</a>
</p>

<hr>
<h2 id='SpMatrixCalc'>Calculate Seasonal Similarity Matrix</h2><span id='topic+SpMatrixCalc'></span>

<h3>Description</h3>

<p>Generates and returns an n x n matrix by calculating the seasonal dissimilarity
for each possible pair of points in a vector
of seasonal periods, then converts dissimilarity matrix to a similarity matrix using 1 / (D_p + 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpMatrixCalc(v, nPeriods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpMatrixCalc_+3A_v">v</code></td>
<td>
<p>positive numeric vector with the seasonal periods corresponding to each point in the response series.</p>
</td></tr>
<tr><td><code id="SpMatrixCalc_+3A_nperiods">nPeriods</code></td>
<td>
<p>positive numeric value representing the maximum value <code>v</code> can take on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of seasonal similarities for the vector <code>v</code>.
</p>


<h3>See Also</h3>


<ul>
<li><p> Trupiano (2021) arXiv:2112.06266 for information on the formulation of this seasonal similarity measure.
</p>
</li>
<li> <p><code><a href="#topic+SeasonalAbsDissimilarity">SeasonalAbsDissimilarity()</a></code> for the function used to calculate seasonal dissimilarity.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>SpMatrixCalc(c(1, 2, 4), 4)
</code></pre>

<hr>
<h2 id='StMatrixCalc'>Calculate Temporal Similarity Matrix</h2><span id='topic+StMatrixCalc'></span>

<h3>Description</h3>

<p>Generates and returns an n x n matrix by calculating the absolute difference
for each possible pair of points in a vector of the time orders of each point in a series,
then converts dissimilarity matrix to a similarity matrix using 1 / (D_t + 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StMatrixCalc(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StMatrixCalc_+3A_v">v</code></td>
<td>
<p>numeric vector with the time order corresponding to each point in the response series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of temporal similarities for the vector <code>v</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TempAbsDissimilarity">TempAbsDissimilarity()</a></code> for the function used to calculate
absolute differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>StMatrixCalc(c(1, 2, 3))
</code></pre>

<hr>
<h2 id='SwMatrixCalc'>Calculate Weighted Similarity Matrix</h2><span id='topic+SwMatrixCalc'></span>

<h3>Description</h3>

<p>A wrapper function which calls each of <code>StMatrixCalc(v = t.in)</code>,
<code>SpMatrixCalc(v = p.in, nPeriods = nPeriods.in)</code>,
and <code>SxMatrixCalc(A = X.in, XdistMetric = XdistMetric.in)</code> to generate the three matrices of using the component measures of <code>S_w</code>. Then
generates the final weighted similarity matrix as the sum of each component matrix multiplied by its corresponding <code>weights</code>.
The first value in <code>weights</code> will be multiplied by <code>S_t</code>, the second <code>S_p</code>, and the third <code>S_x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SwMatrixCalc(
  t.in,
  p.in,
  nPeriods.in,
  X.in,
  XdistMetric.in = "euclidean",
  weights = c(1/3, 1/3, 1/3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SwMatrixCalc_+3A_t.in">t.in</code></td>
<td>
<p>numeric vector of time orders for points in the response series.</p>
</td></tr>
<tr><td><code id="SwMatrixCalc_+3A_p.in">p.in</code></td>
<td>
<p>numeric vector of period within a seasonal cycle (ex. 1 for January points in monthly data).</p>
</td></tr>
<tr><td><code id="SwMatrixCalc_+3A_nperiods.in">nPeriods.in</code></td>
<td>
<p>numeric scalar indicating the maximum value <code>p.in</code> could take on (ex. 12 for monthly data).</p>
</td></tr>
<tr><td><code id="SwMatrixCalc_+3A_x.in">X.in</code></td>
<td>
<p>numeric vector or matrix of exogenous predictors, where the rows correspond to points in the response series.</p>
</td></tr>
<tr><td><code id="SwMatrixCalc_+3A_xdistmetric.in">XdistMetric.in</code></td>
<td>
<p>character describing the method <code>stats::dist()</code> should use. This must be one of <code>"euclidean"</code>,
<code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, or <code>"minkowski"</code>.</p>
</td></tr>
<tr><td><code id="SwMatrixCalc_+3A_weights">weights</code></td>
<td>
<p>numeric vector where first value represents weight for <code>S_t</code>, second value the weight for <code>S_p</code>, and the third value the weight for <code>S_x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of similarities which is calculated using <code>S_w</code>.
</p>


<h3>See Also</h3>


<ul>
<li><p> Trupiano (2021) arXiv:2112.06266 for information on the formulation of <code>S_w</code>.
</p>
</li>
<li> <p><code><a href="#topic+StMatrixCalc">StMatrixCalc()</a></code> for information on the calculation of <code>S_t</code>.
</p>
</li>
<li> <p><code><a href="#topic+SpMatrixCalc">SpMatrixCalc()</a></code> for information on the calculation of <code>S_p</code>.
</p>
</li>
<li> <p><code><a href="#topic+SxMatrixCalc">SxMatrixCalc()</a></code> for information on the calculation of <code>S_x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c(1, 2, 3)
p &lt;- c(1, 2, 1)
X &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow = 3, ncol = 3, byrow = TRUE)
SwMatrixCalc(
  t.in = t,
  p.in = p, nPeriods.in = 2,
  X.in = X,
  weights = c(1 / 4, 1 / 4, 1 / 2)
)
</code></pre>

<hr>
<h2 id='SxMatrixCalc'>Calculate Similarity Matrix for Exogenous Predictors</h2><span id='topic+SxMatrixCalc'></span>

<h3>Description</h3>

<p>Largely a wrapper function for the <code>stats::dist()</code> function. First calculates
n x n distance matrix using specified method for an input matrix or vector using
<code>stats::dist()</code>. Then converts the distance matrix to similarity matrix using 1 / (D_x + 1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SxMatrixCalc(A, XdistMetric = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SxMatrixCalc_+3A_a">A</code></td>
<td>
<p>numeric matrix or numeric vector where the columns represents exogenous predictor variables and the rows correspond to the points in the response series.</p>
</td></tr>
<tr><td><code id="SxMatrixCalc_+3A_xdistmetric">XdistMetric</code></td>
<td>
<p>character describing the method <code>stats::dist()</code> should use.
This must be one of <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>, <code>"canberra"</code>, <code>"binary"</code>, or <code>"minkowski"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix of distances for <code>A</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(1, 1, 1, 2, 2, 2, 3, 3, 3), nrow = 3, ncol = 3, byrow = TRUE)
SxMatrixCalc(X)
</code></pre>

<hr>
<h2 id='TempAbsDissimilarity'>Temporal Absolute Dissimilarity</h2><span id='topic+TempAbsDissimilarity'></span>

<h3>Description</h3>

<p>Simply takes the absolute difference between two points, meaning points close
in time will have smaller dissimilarity. This is equivalent to Euclidean Distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TempAbsDissimilarity(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TempAbsDissimilarity_+3A_p1">p1</code></td>
<td>
<p>numeric value representing the time order of the point in the response series.</p>
</td></tr>
<tr><td><code id="TempAbsDissimilarity_+3A_p2">p2</code></td>
<td>
<p>numeric value representing the time order of the point in the response series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the absolute difference between <code>p1</code> and <code>p2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TempAbsDissimilarity(1, 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
