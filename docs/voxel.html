<!DOCTYPE html><html lang="en"><head><title>Help for package voxel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {voxel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anovagammVoxel'><p>Computes voxelwise analysis of variance (ANOVA) tables for a Generalized Additive Mixed Effects Model.</p></a></li>
<li><a href='#anovagamVoxel'><p>Computes voxelwise analysis of variance (ANOVA) tables for a Generalized Additive Model.</p></a></li>
<li><a href='#anovalmerVoxel'><p>Computes voxelwise analysis of variance (ANOVA) tables for a Linear Mixed Effects Model.</p></a></li>
<li><a href='#anovalmVoxel'><p>Computes voxelwise analysis of variance (ANOVA) tables for a Linear Model.</p></a></li>
<li><a href='#gamCluster'><p>Run a Generalized Additive Model on the mean intensity over a region of interest</p></a></li>
<li><a href='#gammCluster'><p>Run a Generalized Additive Mixed Effects Model on the mean intensity over a region of interest</p></a></li>
<li><a href='#gammNIfTI'><p>Wrapper to run a Generalized Additive Mixed Effects model on an Nifti and output a parametric map</p></a></li>
<li><a href='#gammVoxel'><p>Run a Generalized Additive Mixed Effects Model on all voxels of a NIfTI image within a mask.</p></a></li>
<li><a href='#gamNIfTI'><p>Wrapper to run a Generalized Additive model on a NIfTI image and output parametric maps</p></a></li>
<li><a href='#gamRandomise'><p>Generate FSL Randomise call for a GAM Model</p></a></li>
<li><a href='#gamVoxel'><p>Run a Generalized Additive Model on all voxels of a NIfTI image within a mask.</p></a></li>
<li><a href='#listFormula'><p>Create list of Formulas for each voxel</p></a></li>
<li><a href='#lmCluster'><p>Run a Linear Model on the mean intensity over a region of interest</p></a></li>
<li><a href='#lmerCluster'><p>Run a Linear Mixed Effects Model on the mean intensity over a region of interest</p></a></li>
<li><a href='#lmerNIfTI'><p>Run a Linear Mixed Effects Model on a NIfTI image and output a parametric maps</p></a></li>
<li><a href='#lmerVoxel'><p>Run a Linear Mixed Effects Model on all voxels of a NIfTI image within a mask.</p></a></li>
<li><a href='#lmNIfTI'><p>Wrapper to run a model on a NIfTI image and output parametric maps</p></a></li>
<li><a href='#lmVoxel'><p>Run a Linear Model on all voxels of a NIfTI image within a mask.</p></a></li>
<li><a href='#mergeNiftis'><p>Merge NIfTI Images across specified direction</p></a></li>
<li><a href='#parMap'><p>Create parametric maps</p></a></li>
<li><a href='#plotGAM'><p>GAM plotting using ggplot2</p></a></li>
<li><a href='#plotGAMM'><p>GAMM plotting using ggplot2</p></a></li>
<li><a href='#rgamm4Param'><p>Run a Generalized Additive Mixed Effects Model on all voxels of a NIfTI image return coefficients and residuals</p></a></li>
<li><a href='#rgamParam'><p>Run a Generalized Additive Model on all voxels of a NIfTI image and return coefficients and residuals</p></a></li>
<li><a href='#rlmerParam'><p>Run a Linear Mixed Effects Model on all voxels of a NIfTI image and return parametric coefficients and residuals</p></a></li>
<li><a href='#rlmParam'><p>Run a Linear Model on all voxels of a NIfTI and return parametric coefficients and residuals</p></a></li>
<li><a href='#rparMap'><p>Create parametric maps and residuals</p></a></li>
<li><a href='#ts2matrix'><p>Timeseries to Matrix</p></a></li>
<li><a href='#ts2meanCluster'><p>Timeseries to Mean Cluster</p></a></li>
<li><a href='#vgamm4Param'><p>Run a Generalized Additive Mixed Effects Model on all voxels of a NIfTI image and return parametric and smooth coefficients</p></a></li>
<li><a href='#vgamParam'><p>Run a Generalized Additive Model on all voxels of a NIfTI image within a mask and return parametric and smooth coefficients tables</p></a></li>
<li><a href='#vlmerParam'><p>Run a Linear Mixed Effects Model on all voxels of a NIfTI image within a mask and and return parametric coefficients tables</p></a></li>
<li><a href='#vlmParam'><p>Run a Linear Model on all voxels of a NIfTI image within a mask and and return parametric coefficients tables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Mass-Univariate Voxelwise Analysis of Medical Imaging Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the mass-univariate voxelwise analysis of medical imaging data that follows the NIfTI <a href="http://nifti.nimh.nih.gov">http://nifti.nimh.nih.gov</a> format. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3), lmerTest(&ge; 3.0-1)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/angelgar/voxel">https://github.com/angelgar/voxel</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel,stats,mgcv,gamm4,oro.nifti,ggplot2,methods,purrr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-25 19:22:03 UTC; angelgarciadelagarza</td>
</tr>
<tr>
<td>Author:</td>
<td>Angel Garcia de la Garza [aut, cre],
  Simon Vandekar [aut],
  David Roalf [aut],
  Kosha Ruparel [aut],
  Ruben Gur [aut],
  Raquel Gur [aut],
  Theodore Satterthwaite [aut],
  R. Taki Shinohara [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angel Garcia de la Garza &lt;agarciadlg@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-26 04:38:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='anovagammVoxel'>Computes voxelwise analysis of variance (ANOVA) tables for a Generalized Additive Mixed Effects Model.</h2><span id='topic+anovagammVoxel'></span>

<h3>Description</h3>

<p>This function computes analysis of variance tables for the fitted Generalized Additive Mixed Effects (from gamm4::gamm4) models.
The analysis will run in all voxels in the specified mask and will return a list with the ANOVA table at each voxel.
Please check the mgcv::anova.gam documentation for further information about specific arguments used in anova.gam. Multi-model calls are disabled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovagammVoxel(image, mask, fourdOut = NULL, formula, randomFormula, subjData,
  dispersion = NULL, freq = FALSE, mc.preschedule = TRUE, ncores = 1,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anovagammVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary.</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the output path to write out the fourd file. Do not include a suffix (i.e. .nii.gz). Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_randomformula">randomFormula</code></td>
<td>
<p>Random effects formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_dispersion">dispersion</code></td>
<td>
<p>To be passed to mgcv::anova.gam, Defaults to NULL. Dispersion Parameter, not normally used.</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_freq">freq</code></td>
<td>
<p>To be passed to mgcv::anova.gam, Defaults to FALSE. Frequentist or Bayesian approximations for p-values</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>To be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="anovagammVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gamm4()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(data = c(rep(0,15), rep(1,1)),
                                     dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y=runif(25), id = rep(1:5,5))
f1 &lt;- "~ s(x) + y"
randomFormula &lt;- "~(1|id)"
models &lt;- anovagammVoxel(image, mask, formula = f1,
                              randomFormula = randomFormula,
                              subjData = covs, ncores = 1, REML=TRUE)
</code></pre>

<hr>
<h2 id='anovagamVoxel'>Computes voxelwise analysis of variance (ANOVA) tables for a Generalized Additive Model.</h2><span id='topic+anovagamVoxel'></span>

<h3>Description</h3>

<p>This function computes analysis of variance tables for the fitted models after running a Generalized Additive Model (from mgcv::gam).
The analysis will run in all voxels in the mask and will return the analysis of variance table for each voxel.
Please check the mgcv::anova.gam documentation for further information about specific arguments used in anova.gam. Multi-model calls are disabled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovagamVoxel(image, mask, fourdOut = NULL, formula, subjData,
  dispersion = NULL, freq = FALSE, mc.preschedule = TRUE, ncores = 1,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anovagamVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gam()</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_dispersion">dispersion</code></td>
<td>
<p>To be passed to mgcv::anova.gam, Defaults to NULL. Dispersion Parameter, not normally used.</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_freq">freq</code></td>
<td>
<p>To be passed to mgcv::anova.gam, Defaults to FALSE. Frequentist or Bayesian approximations for p-values</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="anovagamVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gam()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:200, dim =c(2,2,2,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(2,2,2,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y=runif(25))
fm1 &lt;- "~ s(x) + y"
models &lt;- anovagamVoxel(image=image, mask=mask,
              formula=fm1, subjData=covs, ncores = 1)
</code></pre>

<hr>
<h2 id='anovalmerVoxel'>Computes voxelwise analysis of variance (ANOVA) tables for a Linear Mixed Effects Model.</h2><span id='topic+anovalmerVoxel'></span>

<h3>Description</h3>

<p>This function computes analysis of variance tables for the fitted models after running a Linear Mixed Effect Model using the lmerTest() function and the anova function in that package.
The analysis will run in all voxels in the mask and will return the analysis of variance table for each voxel.
Please check the lmerTest documentation for further information about specific arguments used in anova.lmerModLmerTest. Multi-model calls are disabled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovalmerVoxel(image, mask, fourdOut = NULL, formula, subjData,
  ddf = "Satterthwaite", type = 3, mc.preschedule = TRUE, ncores = 1,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anovalmerVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lmer()</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_ddf">ddf</code></td>
<td>
<p>Which approximation of DDF to be used. To be passed to anova.lmerModLmerTest. Defaults to &quot;Satterthwaite&quot;</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_type">type</code></td>
<td>
<p>Type of hypothesis to be test (defined from SAS terminology). Defaults to 3. To be passed to anova.lmerModLmerTest</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="anovalmerVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lmer()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,15), rep(1,1)), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ x + y + (1|id)"
models &lt;- anovalmerVoxel(image, mask, formula = fm1, subjData = covs, ncores = 1, REML=TRUE)

</code></pre>

<hr>
<h2 id='anovalmVoxel'>Computes voxelwise analysis of variance (ANOVA) tables for a Linear Model.</h2><span id='topic+anovalmVoxel'></span>

<h3>Description</h3>

<p>This function computes analysis of variance tables for the fitted models after running a Linear Model using the stats::lm() function.
The analysis will run in all voxels in the mask and will return the analysis of variance table for each voxel.
Please check the stats documentation for further information about specific arguments used in stats::anova.lm(). Multi-model calls are disabled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anovalmVoxel(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anovalmVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lm()</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="anovalmVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y=runif(25))
fm1 &lt;- "~ x + y"
models &lt;- anovalmVoxel(image=image, mask=mask,
              formula=fm1, subjData=covs, ncores = 1)
</code></pre>

<hr>
<h2 id='gamCluster'>Run a Generalized Additive Model on the mean intensity over a region of interest</h2><span id='topic+gamCluster'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Model (GAM) using the mgcv package. 
All clusters must be labeled with integers in the mask passed as an argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamCluster(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamCluster_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNiftis() and merge across time.</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. All clusters must be labeled with integers in the mask passed as an argument</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gam()</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for the analysis</p>
</td></tr>
<tr><td><code id="gamCluster_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gam()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to the mean voxel intensity over region of interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(1:4, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25))
fm1 &lt;- "~ s(x)"
models &lt;- gamCluster(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1, method="REML")
</code></pre>

<hr>
<h2 id='gammCluster'>Run a Generalized Additive Mixed Effects Model on the mean intensity over a region of interest</h2><span id='topic+gammCluster'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Mixed Effects Model (GAMM) using the gamm4() function. 
All clusters or Regions of Interest must be labeled with integers in the mask passed as an argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammCluster(image, mask, fourdOut = NULL, formula, randomFormula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammCluster_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. All clusters must be labeled with integers in the mask passed as an argument</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_randomformula">randomFormula</code></td>
<td>
<p>Random effects formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use for the analysis</p>
</td></tr>
<tr><td><code id="gammCluster_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gamm4()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to the mean voxel intensity a region or interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,14),1,2), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ s(x)"
randomFormula &lt;- "~(1|id)"
models &lt;- gammCluster(image, mask, formula = fm1, 
                              randomFormula = randomFormula, subjData = covs, ncores = 1, REML=TRUE)
                              
</code></pre>

<hr>
<h2 id='gammNIfTI'>Wrapper to run a Generalized Additive Mixed Effects model on an Nifti and output a parametric map</h2><span id='topic+gammNIfTI'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Model (GAMM) using the gamm4() function. 
The analysis will run in all voxels within the mask and will return parametric and smooth coefficients. 
The function will create parametric maps according to the model selected. 
The function will return a p-map, t-map, z-map, p-adjusted-map for parametric terms and p-map, z-map, p-adjusted-map for smooth terms.
You can select which type of p-value correction you want done on the map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammNIfTI(image, mask, fourdOut = NULL, formula, randomFormula, subjData,
  mc.preschedule = TRUE, ncores = 1, method = "none", residual = FALSE,
  outDir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammNIfTI_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_randomformula">randomFormula</code></td>
<td>
<p>Random effects formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_method">method</code></td>
<td>
<p>which method of correction for multiple comparisons (default is none)</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_residual">residual</code></td>
<td>
<p>If set to TRUE then residuals maps will be returned along parametric maps</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_outdir">outDir</code></td>
<td>
<p>Path to the folder where to output parametric maps (Default is Null, only change if you want to write maps out)</p>
</td></tr>
<tr><td><code id="gammNIfTI_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gamm4()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns Parametric maps of the fitted models over the NIfTI image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
image &lt;- oro.nifti::nifti(img = array(rnorm(1600, sd=10), dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,14), rep(1,2)), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ s(x) + s(y)"
randomFormula &lt;- "~(1|id)"
Maps &lt;- gammNIfTI(image, mask, formula = fm1, 
                 randomFormula = randomFormula, subjData = covs, ncores = 1,
                 method="fdr", REML=TRUE)


</code></pre>

<hr>
<h2 id='gammVoxel'>Run a Generalized Additive Mixed Effects Model on all voxels of a NIfTI image within a mask.</h2><span id='topic+gammVoxel'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Mixed Effects Model (GAMM) using the gamm4() function. 
The analysis will run in all voxels within the mask and will return the model fit for each voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammVoxel(image, mask, fourdOut = NULL, formula, randomFormula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_randomformula">randomFormula</code></td>
<td>
<p>Random effects formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="gammVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gamm4()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,14),1), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ s(x)"
randomFormula &lt;- "~(1|id)"
models &lt;- gammVoxel(image = image , mask = mask, formula = fm1, randomFormula = randomFormula, 
                                                       subjData = covs, ncores = 1, REML=TRUE)

</code></pre>

<hr>
<h2 id='gamNIfTI'>Wrapper to run a Generalized Additive model on a NIfTI image and output parametric maps</h2><span id='topic+gamNIfTI'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Model (GAM) using the mgcv package. 
The analysis will run in all voxels in in the mask and will return parametric and smooth coefficients.
The function will create parametric maps according to the model selected. 
The function will return a p-map, t-map, z-map, p-adjusted-map for parametric terms and p-map, z-map, p-adjusted-map for smooth terms.
You can select which type of p-value correction you want done on the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamNIfTI(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, method = "none", residual = FALSE,
  outDir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamNIfTI_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gam()</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_method">method</code></td>
<td>
<p>which method of correction for multiple comparisons (default is none)</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_residual">residual</code></td>
<td>
<p>If set to TRUE then residuals maps will be returned along parametric maps</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_outdir">outDir</code></td>
<td>
<p>Path to the folder where to output parametric maps (Default is Null, only change if you want to write maps out)</p>
</td></tr>
<tr><td><code id="gamNIfTI_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gam()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parametric maps of the fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = rnorm(25))
fm1 &lt;- "~ x + s(y)"
Maps &lt;- gamNIfTI(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1, method="fdr")
</code></pre>

<hr>
<h2 id='gamRandomise'>Generate FSL Randomise call for a GAM Model</h2><span id='topic+gamRandomise'></span>

<h3>Description</h3>

<p>This function is able to generate all the necessary files to run randomise with a GAM Model
This script will write out all design and contrast files 
This function will run a f-test to compare a full and reduced model (a model with and without spline)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamRandomise(image, maskPath = NULL, formulaFull, formulaRed, subjData,
  outDir, nsim = 500, thresh = 0.01, run = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamRandomise_+3A_image">image</code></td>
<td>
<p>Input path of 'nifti' image or vector of path(s) to images. If multiple paths, the script will all mergeNiftis() and merge across time.</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_maskpath">maskPath</code></td>
<td>
<p>to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_formulafull">formulaFull</code></td>
<td>
<p>Must be the formula of the full model (i.e. &quot;~s(age,k=5)+sex+mprage_antsCT_vol_TBV&quot;)</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_formulared">formulaRed</code></td>
<td>
<p>Must be the formula of the reduced model (i.e. &quot;~sex+mprage_antsCT_vol_TBV&quot;)</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_outdir">outDir</code></td>
<td>
<p>output directory for randomise</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_thresh">thresh</code></td>
<td>
<p>significance threshold</p>
</td></tr>
<tr><td><code id="gamRandomise_+3A_run">run</code></td>
<td>
<p>FALSE will only print randomise command but won't it</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return randomise command
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

subjData = mgcv::gamSim(1,n=400,dist="normal",scale=2)
OutDirRoot="Output Directory"
maskName="Path to mask"
imagePath="Path to output"
covsFormula="~s(age,k=5)+sex+mprage_antsCT_vol_TBV"
redFormula="~sex+mprage_antsCT_vol_TBV"

gamRandomise(image = imagePath, maskPath = maskName, formulaFull = covsFormula, 
           formulaRed = redFormula, subjData = subjData, outDir = OutDirRoot)


## End(Not run)

</code></pre>

<hr>
<h2 id='gamVoxel'>Run a Generalized Additive Model on all voxels of a NIfTI image within a mask.</h2><span id='topic+gamVoxel'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Model (GAM) using the mgcv package. 
The analysis will run in all voxels in in the mask and will return the model fit for each voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamVoxel(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gam()</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="gamVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gam()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25))
fm1 &lt;- "~ s(x)"
models &lt;- gamVoxel(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1)
</code></pre>

<hr>
<h2 id='listFormula'>Create list of Formulas for each voxel</h2><span id='topic+listFormula'></span>

<h3>Description</h3>

<p>This function is internal. 
This function creates list of formulas that will be passed for analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listFormula(x, formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listFormula_+3A_x">x</code></td>
<td>
<p>Index of voxels to be analyzed</p>
</td></tr>
<tr><td><code id="listFormula_+3A_formula">formula</code></td>
<td>
<p>covariates to be included in the analysis</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- 1
fm1 &lt;- "~ x1"
formula &lt;- listFormula(x, formula = fm1)
</code></pre>

<hr>
<h2 id='lmCluster'>Run a Linear Model on the mean intensity over a region of interest</h2><span id='topic+lmCluster'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Model using the stats package. 
All clusters must be labeled with integers in the mask passed as an argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmCluster(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmCluster_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. All clusters must be labeled with integers in the mask passed as an argument</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti. This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lm()</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="lmCluster_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to the mean voxel intensity a region or interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(1:4, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25))
fm1 &lt;- "~ x"
models &lt;- lmCluster(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1)
</code></pre>

<hr>
<h2 id='lmerCluster'>Run a Linear Mixed Effects Model on the mean intensity over a region of interest</h2><span id='topic+lmerCluster'></span>

<h3>Description</h3>

<p>This function is able to run a LME using the lmer() function.
All clusters or region of interest must be labeled with integers in the mask passed as an argument.
The function relies on lmerTest to create p-values using the Satterthwaite Approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerCluster(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmerCluster_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. All clusters must be labeled with integers in the mask passed as an argument</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lmer()</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="lmerCluster_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lmer()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to the mean voxel intensity a region or interest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,14),1,2), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ x + (1|id)"
models &lt;- lmerCluster(image, mask, formula = fm1, subjData = covs, ncores = 1, REML=TRUE)

</code></pre>

<hr>
<h2 id='lmerNIfTI'>Run a Linear Mixed Effects Model on a NIfTI image and output a parametric maps</h2><span id='topic+lmerNIfTI'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Mixed Effect Model using the lmer() function. 
The function relies on lmerTest to create p-values using the Satterthwaite Approximation.
The analysis will run in all voxels in in the mask and will return parametric coefficients.
The function will create parametric maps according to the model selected. 
The function will return a p-map, t-map, z-map, p-adjusted-map for parametric terms and p-map, z-map, p-adjusted-map for smooth terms.
You can select which type of p-value correction you want done on the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerNIfTI(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, method = "none", residual = FALSE,
  outDir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmerNIfTI_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lmer()</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_method">method</code></td>
<td>
<p>which method of correction for multiple comparisons (default is none)</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_residual">residual</code></td>
<td>
<p>If set to TRUE then residuals maps will be returned along parametric maps</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_outdir">outDir</code></td>
<td>
<p>Path to the folder where to output parametric maps (Default is Null, only change if you want to write maps out)</p>
</td></tr>
<tr><td><code id="lmerNIfTI_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lmer()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns parametric maps of the fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,14),1,1), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ x + (1|id)"
Maps &lt;- lmerNIfTI(image, mask, formula = fm1, subjData = covs, method="fdr", ncores = 1)

</code></pre>

<hr>
<h2 id='lmerVoxel'>Run a Linear Mixed Effects Model on all voxels of a NIfTI image within a mask.</h2><span id='topic+lmerVoxel'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Mixed Effect Model using the lmer() function. 
The analysis will run in all voxels in in the mask and will return parametric coefficients at each voxel 
The function relies on lmerTest to create p-values using the Satterthwaite Approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmerVoxel(image, mask, fourdOut = NULL, formula = NULL, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmerVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lmer()</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="lmerVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lmer()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ x + (1|id)"
models &lt;- lmerVoxel(image, mask, formula = fm1, subjData = covs, ncores = 1, REML=T)

## End(Not run)
</code></pre>

<hr>
<h2 id='lmNIfTI'>Wrapper to run a model on a NIfTI image and output parametric maps</h2><span id='topic+lmNIfTI'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Model using the stats package.
The analysis will run in all voxels in in the mask and will return parametric coefficients. 
The function will create parametric maps according to the model selected. 
The function will return a p-map, t-map, z-map, p-adjusted-map for parametric terms and p-map, z-map, p-adjusted-map for smooth terms.
You can select which type of p-value correction you want done on the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmNIfTI(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, method = "none", residual = FALSE,
  outDir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmNIfTI_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will call mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lm()</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_method">method</code></td>
<td>
<p>which method of correction for multiple comparisons (default is none)</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_residual">residual</code></td>
<td>
<p>If set to TRUE then residuals maps will be returned along parametric maps</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_outdir">outDir</code></td>
<td>
<p>Path to the folder where to output parametric maps (Default is Null, only change if you want to write maps out)</p>
</td></tr>
<tr><td><code id="lmNIfTI_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return parametric maps of the fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25))
fm1 &lt;- "~ x + y"
Maps &lt;- lmNIfTI(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1, method="fdr")
</code></pre>

<hr>
<h2 id='lmVoxel'>Run a Linear Model on all voxels of a NIfTI image within a mask.</h2><span id='topic+lmVoxel'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Model using the stats package. 
The analysis will run in all voxels in in the mask and will return the model fit for each voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmVoxel(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmVoxel_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lm()</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="lmVoxel_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of models fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25))
fm1 &lt;- "~ x"
models &lt;- lmVoxel(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1)
</code></pre>

<hr>
<h2 id='mergeNiftis'>Merge NIfTI Images across specified direction</h2><span id='topic+mergeNiftis'></span>

<h3>Description</h3>

<p>This function merges nifti images together in a specified direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeNiftis(inputPaths, direction = c("x", "y", "z", "t"), outfile = NULL,
  ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeNiftis_+3A_inputpaths">inputPaths</code></td>
<td>
<p>This is a vector of input filenames (character)</p>
</td></tr>
<tr><td><code id="mergeNiftis_+3A_direction">direction</code></td>
<td>
<p>This is the direction you want to merge your image over, x, y, z, or t</p>
</td></tr>
<tr><td><code id="mergeNiftis_+3A_outfile">outfile</code></td>
<td>
<p>This is the path and file name to save the Nifti file without the suffix, passed to writeNIfTI</p>
</td></tr>
<tr><td><code id="mergeNiftis_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to be used for this operation</p>
</td></tr>
<tr><td><code id="mergeNiftis_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to readNIfTI</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a merged NIfTI image
</p>

<hr>
<h2 id='parMap'>Create parametric maps</h2><span id='topic+parMap'></span>

<h3>Description</h3>

<p>This function create parametric maps according from model parametric tables or analysis of variance tables. 
The function will return a p-map, t-map, signed z-map, p-adjusted-map for parametric terms and p-map, z-map, p-adjusted-map for smooth terms. 
Additionally the function will return a p-map, F-map, p-to-z-map, and p-adjusted-map if the input is ANOVA.
You can select which type of p-value correction you want done on the map. The z-maps are signed just like FSL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parMap(parameters, mask, method = "none", outDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parMap_+3A_parameters">parameters</code></td>
<td>
<p>list of parametric and smooth table coefficients or ANOVA (like the output from vlmParam, vgamParam, anovalmVoxel)</p>
</td></tr>
<tr><td><code id="parMap_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to one. Must be a binary mask or a character. Must match the mask passed to one of vlmParam, vgamParam, vgamm4Param, vlmerParam</p>
</td></tr>
<tr><td><code id="parMap_+3A_method">method</code></td>
<td>
<p>which method of correction for multiple comparisons (default is none)</p>
</td></tr>
<tr><td><code id="parMap_+3A_outdir">outDir</code></td>
<td>
<p>Path to the folder where to output parametric maps (Default is Null, only change if you want to write maps out)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return parametric maps of the fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25))
fm1 &lt;- "~ x + y"
models &lt;- vlmParam(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1)
Maps &lt;- parMap(models, mask, method="fdr")
</code></pre>

<hr>
<h2 id='plotGAM'>GAM plotting using ggplot2</h2><span id='topic+plotGAM'></span>

<h3>Description</h3>

<p>GAM plotting using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGAM(gamFit, smooth.cov, groupCovs = NULL, orderedAsFactor = T,
  rawOrFitted = F, plotCI = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGAM_+3A_gamfit">gamFit</code></td>
<td>
<p>fitted gam model as produced by mgcv::gam()</p>
</td></tr>
<tr><td><code id="plotGAM_+3A_smooth.cov">smooth.cov</code></td>
<td>
<p>(character) name of smooth term to be plotted</p>
</td></tr>
<tr><td><code id="plotGAM_+3A_groupcovs">groupCovs</code></td>
<td>
<p>(character)  name of group variable to plot by, if NULL (default) then there are no groups in plot</p>
</td></tr>
<tr><td><code id="plotGAM_+3A_orderedasfactor">orderedAsFactor</code></td>
<td>
<p>if TRUE then the model is refitted with ordered variables as factors.</p>
</td></tr>
<tr><td><code id="plotGAM_+3A_raworfitted">rawOrFitted</code></td>
<td>
<p>If FALSE (default) then only smooth terms are plotted; if rawOrFitted = &quot;raw&quot; then raw values are plotted against smooth; if rawOrFitted = &quot;fitted&quot; then fitted values are plotted against smooth</p>
</td></tr>
<tr><td><code id="plotGAM_+3A_plotci">plotCI</code></td>
<td>
<p>if TRUE (default) upper and lower confidence intervals are added at 2 standard errors above and below the mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object that can be visualized using the print() function
</p>


<h3>See Also</h3>

<p>Other Plotting: <code><a href="#topic+plotGAMM">plotGAMM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- data.frame(x = rep(1:20, 2), group = rep(1:2, each = 20))
set.seed(1)
data$y &lt;- (data$x^2)*data$group*3 + rnorm(40, sd = 200)
data$group &lt;- ordered(data$group)

gam &lt;- mgcv::gam(y ~ s(x) + group, data=data)

plot1 &lt;- plotGAM(gamFit = gam, smooth.cov = "x", groupCovs = NULL,
                  rawOrFitted = "raw", plotCI=TRUE, orderedAsFactor = FALSE)
gam &lt;- mgcv::gam(y ~ s(x) + group + s(x, by=group), data=data)
plot2 &lt;- plotGAM(gamFit = gam, smooth.cov = "x", groupCovs = "group",
                             rawOrFitted = "raw", orderedAsFactor = FALSE)
</code></pre>

<hr>
<h2 id='plotGAMM'>GAMM plotting using ggplot2</h2><span id='topic+plotGAMM'></span>

<h3>Description</h3>

<p>GAMM plotting using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGAMM(gammFit, smooth.cov, groupCovs = NULL, orderedAsFactor = F,
  rawOrFitted = F, plotCI = T, grouping = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGAMM_+3A_gammfit">gammFit</code></td>
<td>
<p>fitted gam model as produced by gamm4::gamm()</p>
</td></tr>
<tr><td><code id="plotGAMM_+3A_smooth.cov">smooth.cov</code></td>
<td>
<p>(character) name of smooth term to be plotted</p>
</td></tr>
<tr><td><code id="plotGAMM_+3A_groupcovs">groupCovs</code></td>
<td>
<p>(character)  name of group variable to plot by, if NULL (default) then there are no groups in plot</p>
</td></tr>
<tr><td><code id="plotGAMM_+3A_orderedasfactor">orderedAsFactor</code></td>
<td>
<p>Disabled</p>
</td></tr>
<tr><td><code id="plotGAMM_+3A_raworfitted">rawOrFitted</code></td>
<td>
<p>If FALSE (default) then only smooth terms are plotted; if rawOrFitted = &quot;raw&quot; then raw values are plotted against smooth; if rawOrFitted = &quot;fitted&quot; then fitted values are plotted against smooth</p>
</td></tr>
<tr><td><code id="plotGAMM_+3A_plotci">plotCI</code></td>
<td>
<p>if TRUE (default) upper and lower confidence intervals are added at 2 standard errors above and below the mean</p>
</td></tr>
<tr><td><code id="plotGAMM_+3A_grouping">grouping</code></td>
<td>
<p>(character) Name of variable that you want to use as the group argument in ggplot2::aes(), useful for better visualization of longitudinal data, (default is NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object that can be visualized using the print() function
</p>


<h3>See Also</h3>

<p>Other Plotting: <code><a href="#topic+plotGAM">plotGAM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
data &lt;- data.frame(x = (seq(.25,25, .25) +rnorm(100)), group = rep(1:2, 5), z=rnorm(100),
              index.rnorm = rep(rnorm(50, sd = 50), 2), index.var = rep(1:50, 2))
data$y &lt;- (data$x)*data$group*10 + rnorm(100, sd = 700) + data$index.rnorm + data$z
data$group &lt;- ordered(data$group)


gamm &lt;- gamm4::gamm4(y ~ + s(x) + s(x, by=group) + z + group, data=data, random = ~ (1|index.var))


plot &lt;- plotGAMM(gammFit &lt;- gamm, smooth.cov &lt;- "x", groupCovs = "group",
                    plotCI &lt;- T, rawOrFitted = "raw", grouping = "index.var")

plot2 &lt;- plotGAMM(gammFit &lt;- gamm, smooth.cov &lt;- "x", groupCovs = "group",
                  plotCI &lt;- T, rawOrFitted = "fitted", grouping = "index.var")
</code></pre>

<hr>
<h2 id='rgamm4Param'>Run a Generalized Additive Mixed Effects Model on all voxels of a NIfTI image return coefficients and residuals</h2><span id='topic+rgamm4Param'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Mixed Effects Model (GAMM) using the gamm4() function. 
The analysis will run in all voxels in in the mask and will return parametric and smooth coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgamm4Param(image, mask, fourdOut = NULL, formula, randomFormula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgamm4Param_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_randomformula">randomFormula</code></td>
<td>
<p>Random effects formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="rgamm4Param_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gamm4()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,15), 1), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ s(x) + s(y)"
randomFormula &lt;- "~(1|id)"
models &lt;- rgamm4Param(image, mask, formula = fm1, 
                 randomFormula = randomFormula, subjData = covs, ncores = 1, REML=TRUE)

</code></pre>

<hr>
<h2 id='rgamParam'>Run a Generalized Additive Model on all voxels of a NIfTI image and return coefficients and residuals</h2><span id='topic+rgamParam'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Model (GAM) using the mgcv package. 
The analysis will run in all voxels in in the mask and will return parametric and smooth coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgamParam(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgamParam_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gam()</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="rgamParam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gam()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25))
fm1 &lt;- "~ s(x)"
models &lt;- rgamParam(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1, method="REML")
</code></pre>

<hr>
<h2 id='rlmerParam'>Run a Linear Mixed Effects Model on all voxels of a NIfTI image and return parametric coefficients and residuals</h2><span id='topic+rlmerParam'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Mixed Effect Model using the lmer() function.
The analysis will run in all voxels in in the mask and will return the model fit for each voxel.
The function relies on lmerTest to create p-values using the Satterthwaite Approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlmerParam(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlmerParam_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lmer()</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="rlmerParam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lmer()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,15),1), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ x + (1|id)"
models &lt;- rlmerParam(image, mask, formula = fm1, subjData = covs, ncores = 1)

</code></pre>

<hr>
<h2 id='rlmParam'>Run a Linear Model on all voxels of a NIfTI and return parametric coefficients and residuals</h2><span id='topic+rlmParam'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Model using the stats package. 
The analysis will run in all voxels in in the mask and will and will return parametric coefficients at each voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlmParam(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlmParam_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lm()</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="rlmParam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25))
fm1 &lt;- "~ x + y"
models &lt;- rlmParam(image=image, mask=mask, formula=fm1, subjData=covs, ncores = 1)
</code></pre>

<hr>
<h2 id='rparMap'>Create parametric maps and residuals</h2><span id='topic+rparMap'></span>

<h3>Description</h3>

<p>This function create parametric maps according from model parametric tables or analysis of variance tables. 
The function will return a p-map, t-map, signed z-map, p-adjusted-map for parametric terms and p-map, z-map, p-adjusted-map for smooth terms. 
Additionally the function will return a p-map, F-map, p-to-z-map, and p-adjusted-map if the input is ANOVA.
This function will return a residual map that can be used for cluster correction
You can select which type of p-value correction you want done on the map. The z-maps are signed just like FSL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rparMap(parameters, image, mask, method, ncores, mc.preschedule,
  outDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rparMap_+3A_parameters">parameters</code></td>
<td>
<p>list of parametric and smooth table coefficients or ANOVA (like the output from vlmParam, vgamParam, anovalmVoxel)</p>
</td></tr>
<tr><td><code id="rparMap_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="rparMap_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to one. Must be a binary mask or a character. Must match the mask passed to one of vlmParam, vgamParam, vgamm4Param, vlmerParam</p>
</td></tr>
<tr><td><code id="rparMap_+3A_method">method</code></td>
<td>
<p>which method of correction for multiple comparisons (default is none)</p>
</td></tr>
<tr><td><code id="rparMap_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="rparMap_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="rparMap_+3A_outdir">outDir</code></td>
<td>
<p>Path to the folder where to output parametric maps (Default is Null, only change if you want to write maps out)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return parametric maps of the fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25))
fm1 &lt;- "~ x + y"
models &lt;- rlmParam(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1)
Maps &lt;- rparMap(models, image, mask, method="fdr", ncores = 1, mc.preschedule=TRUE)
</code></pre>

<hr>
<h2 id='ts2matrix'>Timeseries to Matrix</h2><span id='topic+ts2matrix'></span>

<h3>Description</h3>

<p>This function is able to mask a 4-Dimensional image and create a matrix from it. 
Each column represents the same voxel in the xyz array while the rows represent the t-dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2matrix(image, mask)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts2matrix_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti'</p>
</td></tr>
<tr><td><code id="ts2matrix_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti'. Must be a binary mask</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:64, dim =c(4,4,4,5)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4)))
matrix &lt;- ts2matrix(image, mask)
</code></pre>

<hr>
<h2 id='ts2meanCluster'>Timeseries to Mean Cluster</h2><span id='topic+ts2meanCluster'></span>

<h3>Description</h3>

<p>This function is able to output the mean voxel intensity over a cluster. 
Each column represents a cluster and the rows represent the t-dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2meanCluster(image, mask)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts2meanCluster_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti'</p>
</td></tr>
<tr><td><code id="ts2meanCluster_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti'. Must have different clusters labeled as integers.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:320, dim =c(4,4,4,5)))
mask &lt;- oro.nifti::nifti(img = array(0:15, dim = c(4,4,4,1)))
matrix &lt;- ts2meanCluster(image, mask)
</code></pre>

<hr>
<h2 id='vgamm4Param'>Run a Generalized Additive Mixed Effects Model on all voxels of a NIfTI image and return parametric and smooth coefficients</h2><span id='topic+vgamm4Param'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Mixed Effects Model (GAMM) using the gamm4() function. 
The analysis will run in all voxels in in the mask and will return parametric and smooth coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgamm4Param(image, mask, fourdOut = NULL, formula, randomFormula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vgamm4Param_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_randomformula">randomFormula</code></td>
<td>
<p>Random effects formula passed to gamm4()</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="vgamm4Param_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gamm4()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,15), 1), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ s(x) + s(y)"
randomFormula &lt;- "~(1|id)"
models &lt;- vgamm4Param(image, mask, formula = fm1, 
                 randomFormula = randomFormula, subjData = covs, ncores = 1, REML=TRUE)

</code></pre>

<hr>
<h2 id='vgamParam'>Run a Generalized Additive Model on all voxels of a NIfTI image within a mask and return parametric and smooth coefficients tables</h2><span id='topic+vgamParam'></span>

<h3>Description</h3>

<p>This function is able to run a Generalized Additive Model (GAM) using the mgcv package. 
The analysis will run in all voxels in in the mask and will return parametric and smooth coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgamParam(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vgamParam_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to gam()</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="vgamParam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to gam()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25))
fm1 &lt;- "~ s(x)"
models &lt;- vgamParam(image=image, mask=mask, 
              formula=fm1, subjData=covs, ncores = 1, method="REML")
</code></pre>

<hr>
<h2 id='vlmerParam'>Run a Linear Mixed Effects Model on all voxels of a NIfTI image within a mask and and return parametric coefficients tables</h2><span id='topic+vlmerParam'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Mixed Effect Model using the lmer() function.
The analysis will run in all voxels in in the mask and will return the model fit for each voxel.
The function relies on lmerTest to create p-values using the Satterthwaite Approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlmerParam(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vlmerParam_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lmer()</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="vlmerParam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lmer()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(c(rep(0,15),1), dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), id = rep(1:5,5))
fm1 &lt;- "~ x + (1|id)"
models &lt;- vlmerParam(image, mask, formula = fm1, subjData = covs, ncores = 1)

</code></pre>

<hr>
<h2 id='vlmParam'>Run a Linear Model on all voxels of a NIfTI image within a mask and and return parametric coefficients tables</h2><span id='topic+vlmParam'></span>

<h3>Description</h3>

<p>This function is able to run a Linear Model using the stats package. 
The analysis will run in all voxels in in the mask and will and will return parametric coefficients at each voxel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vlmParam(image, mask, fourdOut = NULL, formula, subjData,
  mc.preschedule = TRUE, ncores = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vlmParam_+3A_image">image</code></td>
<td>
<p>Input image of type 'nifti' or vector of path(s) to images. If multiple paths, the script will all mergeNifti() and merge across time.</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_mask">mask</code></td>
<td>
<p>Input mask of type 'nifti' or path to mask. Must be a binary mask</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_fourdout">fourdOut</code></td>
<td>
<p>To be passed to mergeNifti, This is the path and file name without the suffix to save the fourd file. Default (NULL) means script won't write out 4D image.</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_formula">formula</code></td>
<td>
<p>Must be a formula passed to lm()</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_subjdata">subjData</code></td>
<td>
<p>Dataframe containing all the covariates used for the analysis</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p>Argument to be passed to mclapply, whether or not to preschedule the jobs. More info in parallel::mclapply</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use</p>
</td></tr>
<tr><td><code id="vlmParam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to lm()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return list of parametric and spline coefficients (include standard errors and p-values) fitted to each voxel over the masked images passed to function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- oro.nifti::nifti(img = array(1:1600, dim =c(4,4,4,25)))
mask &lt;- oro.nifti::nifti(img = array(0:1, dim = c(4,4,4,1)))
set.seed(1)
covs &lt;- data.frame(x = runif(25), y = runif(25))
fm1 &lt;- "~ x + y"
models &lt;- vlmParam(image=image, mask=mask, formula=fm1, subjData=covs, ncores = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
