<!DOCTYPE html><html><head><title>Help for package nlnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nlnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#data.gen'>
<p>Simulated Data Generation</p></a></li>
<li><a href='#KPC'>
<p>implementation of K-Profiles Clustering</p></a></li>
<li><a href='#nlhc'>
<p>Non-Linear Hierarchical Clustering</p></a></li>
<li><a href='#nlnet'>
<p>Non-Linear Network reconstruction from expression matrix</p></a></li>
<li><a href='#nvsd'>
<p>Nonlinear Variable Selection based on DCOL</p></a></li>
<li><a href='#stage.forward'>
<p>Nonlinear Forward stagewise regression using DCOL</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Network, Clustering, and Variable Selection Based on
DCOL</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Tianwei Yu, Haodong Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tianwei Yu&lt;yutianwei@cuhk.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>It includes four methods: DCOL-based K-profiles clustering, non-linear network reconstruction, non-linear hierarchical clustering, and variable selection for generalized additive model. References:  Tianwei Yu (2018)&lt;<a href="https://doi.org/10.1002%2Fsam.11381">doi:10.1002/sam.11381</a>&gt;; Haodong Liu and others (2016)&lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0158247">doi:10.1371/journal.pone.0158247</a>&gt;; Kai Wang and others (2015)&lt;<a href="https://doi.org/10.1155%2F2015%2F918954">doi:10.1155/2015/918954</a>&gt;; Tianwei Yu and others (2010)&lt;<a href="https://doi.org/10.1109%2FTCBB.2010.73">doi:10.1109/TCBB.2010.73</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>ROCR, TSP, igraph, fdrtool, coin, methods, graphics, stats,
earth, randomForest, e1071</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-17 04:39:26 UTC; tyu8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-19 23:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='data.gen'>
Simulated Data Generation 
</h2><span id='topic+data.gen'></span>

<h3>Description</h3>

<p>Generating gene matrix as a example of input. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
data.gen(n.genes=100, n.samples=100, n.grps=10, aver.grp.size=10, 
n.fun.types=6, epsilon=0.1, n.depend=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.gen_+3A_n.genes">n.genes</code></td>
<td>
<p>the number of rows of the matrix.
</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n.samples">n.samples</code></td>
<td>
<p>the number of columns of the matrix.
</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n.grps">n.grps</code></td>
<td>
<p>the number of hidden clusters.
</p>
</td></tr>
<tr><td><code id="data.gen_+3A_aver.grp.size">aver.grp.size</code></td>
<td>
<p>averge number of genes in a cluster.
</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n.fun.types">n.fun.types</code></td>
<td>
<p>number of function types to use.
</p>
</td></tr>
<tr><td><code id="data.gen_+3A_epsilon">epsilon</code></td>
<td>
<p>noise level.
</p>
</td></tr>
<tr><td><code id="data.gen_+3A_n.depend">n.depend</code></td>
<td>
<p>data generation dependence structure. can be 0, 1, 2.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The data generation scheme is described in detail in IEEE ACM Trans. Comput. Biol. Bioinform. 10(4):1080-85.
</p>


<h3>Value</h3>

<p>return the data including gene and clustering.
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>the gene matrix</p>
</td></tr>
<tr><td><code>grps</code></td>
<td>
<p>the predicted clustering</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianwei Yu&lt;tyu8@emory.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##generating a gene matrix with 100 genes, some in 5 clusters, and 100 samples per gene.
output&lt;-data.gen(n.genes=100, n.samples=10, n.grps=5)
##get the gene matrix from the source of data.
matrix&lt;-output$data
##get the hiden clusters from the source of data.
grps&lt;-output$grp
</code></pre>

<hr>
<h2 id='KPC'>
implementation of K-Profiles Clustering
</h2><span id='topic+KPC'></span>

<h3>Description</h3>

<p>implementation of K-Profiles Clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'> KPC(dataset, nCluster, maxIter = 100, p.max = 0.2, p.min = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KPC_+3A_dataset">dataset</code></td>
<td>

<p>the data matrix with genes in the row and samples in the column
</p>
</td></tr>
<tr><td><code id="KPC_+3A_ncluster">nCluster</code></td>
<td>

<p>the number of clusters K
</p>
</td></tr>
<tr><td><code id="KPC_+3A_maxiter">maxIter</code></td>
<td>

<p>the maximum number of iterations
</p>
</td></tr>
<tr><td><code id="KPC_+3A_p.max">p.max</code></td>
<td>

<p>the starting p-value cutoff to exclude noise genes
</p>
</td></tr>
<tr><td><code id="KPC_+3A_p.min">p.min</code></td>
<td>

<p>the final p-value cutoff to exclude noise genes
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list about gene cluster and the list of value p
</p>
<table>
<tr><td><code>cluster</code></td>
<td>
<p>gene cluster</p>
</td></tr>
<tr><td><code>p.list</code></td>
<td>
<p>a list of value p</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianwei Yu &lt;tianwei.yu@emory.edu&gt;
</p>


<h3>References</h3>

<p>http://www.hindawi.com/journals/bmri/aa/918954/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.gen">data.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## generating the data matrix &amp; hiden clusters as a sample
 input&lt;-data.gen(n.genes=40, n.grps=4)
 ## now input includes data matrix and hiden clusters, so get the matrix as input.
 input&lt;-input$data
 
 ## set nCluster value to 4
 kpc&lt;-KPC(input,nCluster=4)
  
 ##get the hiden cluster result from "KPC"
 cluster&lt;-kpc$cluster
 ##get the list of p
 p&lt;-kpc$p.list
</code></pre>

<hr>
<h2 id='nlhc'>
Non-Linear Hierarchical Clustering
</h2><span id='topic+nlhc'></span>

<h3>Description</h3>

<p>The non-linear hierarchical clustering based on DCOL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlhc(array, hamil.method = "nn", concorde.path = NA, 
use.normal.approx = FALSE, normalization = "standardize", combine.linear = TRUE,
use.traditional.hclust = FALSE, method.traditional.hclust = "average")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlhc_+3A_array">array</code></td>
<td>

<p>the data matrix with no missing values
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_hamil.method">hamil.method</code></td>
<td>

<p>the method to find the hamiltonian path. 
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_concorde.path">concorde.path</code></td>
<td>

<p>If using the Concorde TSP Solver, the local directory of the solver
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_use.normal.approx">use.normal.approx</code></td>
<td>

<p>whether to use the normal approximation for the null hypothesis.
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_normalization">normalization</code></td>
<td>

<p>the normalization method for the array.
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_combine.linear">combine.linear</code></td>
<td>

<p>whether linear association should be found by correlation to combine with nonlinear association found by DCOL. 
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_use.traditional.hclust">use.traditional.hclust</code></td>
<td>

<p>whether traditional agglomerative clustering should be used. 
</p>
</td></tr>
<tr><td><code id="nlhc_+3A_method.traditional.hclust">method.traditional.hclust</code></td>
<td>

<p>the method to pass on to hclust() if traditional method is chosen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hamil.method: It is passed onto the function tsp of library TSP. To use linkern method, the user needs to install concord as instructed in TSP.
</p>
<p>use.normal.approx: If TRUE, normal approximation is used for every feature, AND all covariances are assumed to be zero. If FALSE, generates permutation based null distribution - mean vector and a variance-covariance matrix.
</p>
<p>normalization: There are three choices - &quot;standardize&quot; means removing the mean of each row and make the standard deviation one; &quot;normal_score&quot; means normal score transformation; &quot;none&quot; means do nothing. In that case we still assume some normalization has been done by the user such that each row has approximately mean 0 and sd 1.
</p>
<p>combine.linear: The two pieces of information is combined at the start to initiate the distance matrix. 
</p>


<h3>Value</h3>

<p>Returns a hclust object same as the output of hclust().
Reference: help(hclust)
</p>
<table>
<tr><td><code>merge</code></td>
<td>
<p>an n-1 by 2 matrix. Row i of merge describes the merging of clusters at step i of the clustering. If an element j in the row is negative, then observation -j was merged at this stage. If j is positive then the merge was with the cluster formed at the (earlier) stage j of the algorithm.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>a set of n-1 real values, the value of the criterion associated with the clusterig method for the particular agglomeration</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>a vector giving the permutation of the original observations suitable for plotting, in the sense that a cluster plot using this ordering and matrix merge will not have crossings of the branches.</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>labels for each of the objects being clustered</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call which produced the result</p>
</td></tr>
<tr><td><code>dist.method</code></td>
<td>
<p>the distance that has been used to create d</p>
</td></tr>
<tr><td><code>height.0</code></td>
<td>
<p>original calculation of merging height</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianwei Yu &lt;tianwei.yu@emory.edu&gt;
</p>


<h3>References</h3>

<p>http://www.ncbi.nlm.nih.gov/pubmed/24334400
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.gen">data.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## generating the data matrix &amp; hiden clusters as a sample
 input&lt;-data.gen(n.genes=40, n.grps=4)
 ## now input includes data matrix and hiden clusters, so get the matrix as input.
 input&lt;-input$data

 nlhc.data&lt;-nlhc(input)
 plot(nlhc.data)
 ##get the merge from the input.
 merge&lt;-nlhc.data$merge 
</code></pre>

<hr>
<h2 id='nlnet'>
Non-Linear Network reconstruction from expression matrix
</h2><span id='topic+nlnet'></span>

<h3>Description</h3>

<p>Non-Linear Network reconstruction method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlnet(input, min.fdr.cutoff=0.05,max.fdr.cutoff=0.2, conn.proportion=0.007, 
gene.fdr.plot=FALSE, min.module.size=0, gene.community.method="multilevel", 
use.normal.approx=FALSE, normalization="standardize", plot.method="communitygraph")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlnet_+3A_input">input</code></td>
<td>
<p>the data matrix with no missing values.
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_min.fdr.cutoff">min.fdr.cutoff</code></td>
<td>

<p>the minimun allowable value of the local false discovery cutoff in establishing links between genes. 
</p>
</td></tr> <tr><td><code id="nlnet_+3A_max.fdr.cutoff">max.fdr.cutoff</code></td>
<td>

<p>the maximun allowable value of the local false discovery cutoff in establishing links between genes.
</p>
</td></tr> <tr><td><code id="nlnet_+3A_conn.proportion">conn.proportion</code></td>
<td>

<p>the target proportion of connections between all pairs of genes, if allowed by the fdr cutoff limits. 
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_gene.fdr.plot">gene.fdr.plot</code></td>
<td>

<p>whether plot a figure with estimated densities, distribution functions, and (local) false discovery rates.
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_min.module.size">min.module.size</code></td>
<td>

<p>the min number of genes together as a module.
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_gene.community.method">gene.community.method</code></td>
<td>
<p>the method for community detection.
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_use.normal.approx">use.normal.approx</code></td>
<td>
<p>whether to use the normal approximation for the null hypothesis. 
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_normalization">normalization</code></td>
<td>
<p>the normalization method for the array. 
</p>
</td></tr>
<tr><td><code id="nlnet_+3A_plot.method">plot.method</code></td>
<td>

<p>the method for graph and community ploting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gene.community.method: It provides three kinds of community detection method:
&quot;mutilevel&quot;, &quot;label.propagation&quot; and &quot;leading.eigenvector&quot;.
</p>
<p>use.normal.approx: If TRUE, normal approximation is used for every feature, AND all covariances are assumed to be zero. If FALSE, generates permutation based null distribution - mean vector and a variance-covariance matrix.
</p>
<p>normalization: There are three choices:
&quot;standardize&quot; means removing the mean of each row and make the standard deviation one; 
&quot;normal_score&quot; means normal score transformation; 
&quot;none&quot; means do nothing. In that case we still assume some normalization has been done by the user such that each row has approximately mean 0 and sd 1. 
</p>
<p>plot.method: It provides three kinds of ploting method:
&quot;none&quot; means ploting no graph,
&quot;communitygraph&quot; means ploting community with graph, 
&quot;graph&quot; means ploting graph, 
&quot;membership&quot; means ploting membership of the community 
</p>


<h3>Value</h3>

<p>it returns a graph and the community membership of the graph.
</p>
<table>
<tr><td><code>algorithm</code></td>
<td>
<p>The algorithm name for community detection</p>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>An igraph object including edges : Numeric vector defining the edges, the first edge points from the first element to the second, the second edge from the third to the fourth, etc.</p>
</td></tr>
<tr><td><code>community</code></td>
<td>
<p>Numeric vector, one value for each vertex, the membership vector of the community structure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Haodong Liu &lt;liuhaodong0828@gmail.com&gt;
</p>


<h3>References</h3>

<p>https://www.ncbi.nlm.nih.gov/pubmed/27380516
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.gen">data.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 ## generating the data matrix &amp; hiden clusters as a sample
  input&lt;-data.gen(n.genes=40, n.grps=4)
## now input includes data matrix and hiden clusters, so get the matrix as input.
input&lt;-input$data 
##change the ploting method
 result&lt;-nlnet(input,plot.method="graph")
  ## get the result and see it values
 graph&lt;-result$graph ##a igraph object.
 comm&lt;-result$community ##community of the graph
 
 ## use different community detection method
 #nlnet(input,gene.community.method="label.propagation")
 
 ## change the fdr pro to control connections of genes
 ## adjust the modularity size
 #nlnet(input,conn.proportion=0.005,min.module.size=10)
 
</code></pre>

<hr>
<h2 id='nvsd'>
Nonlinear Variable Selection based on DCOL	
</h2><span id='topic+nvsd'></span>

<h3>Description</h3>

<p>This is a nonlinear variable selection procedure for generalized additive models. It's based on DCOL, using forward stagewise selection. In addition, a cross-validation is conducted to tune the stopping alpha level and finalize the variable selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nvsd(X, y, fold = 10, step.size = 0.01, stop.alpha = 0.05, stop.var.count = 20, 
max.model.var.count = 10, roughening.method = "DCOL", do.plot = F, pred.method = "MARS")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nvsd_+3A_x">X</code></td>
<td>

<p>The predictor matrix. Each row is a gene (predictor), each column is a sample. Notice the dimensionality is different than most other packages, where each column is a predictor. This is to conform to other functions in this package that handles gene expression type of data. 
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_y">y</code></td>
<td>

<p>The numerical outcome vector.
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_fold">fold</code></td>
<td>

<p>The fold of cross-validation.
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_step.size">step.size</code></td>
<td>

<p>The step size of the roughening process. 
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_stop.alpha">stop.alpha</code></td>
<td>

<p>The alpha level (significance of the current selected predictor) to stop the iterations.	
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_stop.var.count">stop.var.count</code></td>
<td>

<p>The maximum number of predictors to select in the forward stagewise selection. Once this number is reached, the iteration stops.
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_max.model.var.count">max.model.var.count</code></td>
<td>

<p>The maximum number of predictors to select. Notice this can be smaller than the stop.var.count. Stop.var.count can be set more liniently, and this parameter controls the final maximum model size.
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_roughening.method">roughening.method</code></td>
<td>

<p>The method for roughening. The choices are &quot;DCOL&quot; or &quot;spline&quot;. 
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_do.plot">do.plot</code></td>
<td>

<p>Whether to plot the points change in each step.	
</p>
</td></tr>
<tr><td><code id="nvsd_+3A_pred.method">pred.method</code></td>
<td>

<p>The prediction method for the cross validation variable selection. As forward stagewise procedure doesn't do prediction, a method has to be borrowed from existing packages. The choices include &quot;MARS&quot;, &quot;RF&quot;, and &quot;SVM&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to the reference for details.
</p>


<h3>Value</h3>

<p>A list object is returned. The components include the following.
</p>
<table>
<tr><td><code>selected.pred</code></td>
<td>
<p> The selected predictors (row number).</p>
</td></tr>
<tr><td><code>all.pred</code></td>
<td>
<p>The selected predictors by the forward stagewise selection. The $selected.pred is a subset of this.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianwei Yu&lt;tianwei.yu@emory.edu&gt;
</p>


<h3>References</h3>

<p>https://arxiv.org/abs/1601.05285
</p>


<h3>See Also</h3>

<p>stage.forward
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-matrix(rnorm(2000),ncol=20)
y&lt;-sin(X[,1])+X[,2]^2+X[,3]
nvsd(t(X),y,stop.alpha=0.001,step.size=0.05)
</code></pre>

<hr>
<h2 id='stage.forward'>
Nonlinear Forward stagewise regression using DCOL
</h2><span id='topic+stage.forward'></span>

<h3>Description</h3>

<p>The subroutine conducts forward stagewise regression using DCOL. Either DCOL roughening or spline roughening is conducted. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stage.forward(X, y, step.size = 0.01, stop.alpha = 0.01, 
stop.var.count = 20, roughening.method = "DCOL", tol = 1e-08, 
spline.df = 5, dcol.sel.only = FALSE, do.plot = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stage.forward_+3A_x">X</code></td>
<td>

<p>The predictor matrix. Each row is a gene (predictor), each column is a sample. Notice the dimensionality is different than most other packages, where each column is a predictor. This is to conform to other functions in this package that handles gene expression type of data. 
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_y">y</code></td>
<td>

<p>The numerical outcome vector.
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_step.size">step.size</code></td>
<td>

<p>The step size of the roughening process. 
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_stop.alpha">stop.alpha</code></td>
<td>

<p>The alpha level (significance of the current selected predictor) to stop the iterations.	
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_stop.var.count">stop.var.count</code></td>
<td>

<p>The maximum number of predictors to select. Once this number is reached, the iteration stops.
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_roughening.method">roughening.method</code></td>
<td>

<p>The method for roughening. The choices are &quot;DCOL&quot; or &quot;spline&quot;. 
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_tol">tol</code></td>
<td>

<p>The tolerance level of sum of squared changes in the residuals. 	
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_spline.df">spline.df</code></td>
<td>

<p>The degree of freedom for the spline. 	
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_dcol.sel.only">dcol.sel.only</code></td>
<td>

<p>TRUE or FALSE. If FALSE, the selection of predictors will consider both linear and nonlinear association significance. 	
</p>
</td></tr>
<tr><td><code id="stage.forward_+3A_do.plot">do.plot</code></td>
<td>

<p>Whether to plot the points change in each step.	
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to the reference manuscript for details.
</p>


<h3>Value</h3>

<p>A list object is returned. The components include the following.
</p>
<table>
<tr><td><code>found.pred</code></td>
<td>
<p> The selected predictors (row number).</p>
</td></tr>
<tr><td><code>ssx.rec</code></td>
<td>
<p>The magnitude of variance explained using the current predictor at each step.</p>
</td></tr>
<tr><td><code>$sel.rec</code></td>
<td>
<p> The selected predictor at each step.</p>
</td></tr>
<tr><td><code>$p.rec</code></td>
<td>
<p> The p-value of the association between the current residual and the selected predictor at each step.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianwei Yu&lt;tianwei.yu@emory.edu&gt;
</p>


<h3>References</h3>

<p>https://arxiv.org/abs/1601.05285
</p>


<h3>See Also</h3>

<p>nvsd
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-matrix(rnorm(2000),ncol=20)
y&lt;-sin(X[,1])+X[,2]^2+X[,3]
stage.forward(t(X),y,stop.alpha=0.001,step.size=0.05)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
