<!DOCTYPE html><html lang="en"><head><title>Help for package MixfMRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MixfMRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MixfMRI-package'><p>fMRI Clustering Analysis</p></a></li>
<li><a href='#algorithm'><p>Main algorithms implemented in fclust</p></a></li>
<li><a href='#cluster.threshold'><p>Cluster threshold an array.</p></a></li>
<li><a href='#Compute+20Q+20values'><p>Q-values using Benjamini and Hochberg (1995)</p></a></li>
<li><a href='#Compute+20Statistics+20for+20Log+20Odds+20Ratio+20of+20Posterior+20Probability'><p>Compute Statistics for Log Odds Ratio of Posterior Probability</p></a></li>
<li><a href='#Covariance+20Matrices'><p>Covariance Matrices</p></a></li>
<li><a href='#Covariance+20Matrices+20of+20Logit+20ETA'><p>Covariance Matrices of Logit ETA</p></a></li>
<li><a href='#Density+20function+20of+20p-values'><p>Density function of p-values</p></a></li>
<li><a href='#EC.3D'><p>Expected Euler Characteristic for a 3D Random Field</p></a></li>
<li><a href='#Example+20Datasets'><p>Example datasets in MixfMRI</p></a></li>
<li><a href='#False+20Discovery+20Rates+20for+20Spatial+20Signals'><p>False Discovery Rates for Spatial Signals using Benjamini and Heller (2007)</p></a></li>
<li><a href='#General+20Internal+20Functions'><p>All General Internal Functions and Datasets</p></a></li>
<li><a href='#Generalized+20Cluster-Based+20Analysis+20+28CBA+29+20Method'><p>Generalized Cluster-Based Analysis (CBA) Method</p></a></li>
<li><a href='#initial'><p>Main initialization functions</p></a></li>
<li><a href='#Likelihood+20Mixture+20Tests+20with+20Identity+20Cov+20Matrix+20or+20Only+20p-values'><p>Likelihood Mixture Tests with Identity Cov Matrix or Only p-values</p></a></li>
<li><a href='#LRT'><p>Likelihood ratio tests</p></a></li>
<li><a href='#Main+20functions'><p>Main MixfMRI function</p></a></li>
<li><a href='#MixfMRI+20Control'><p>Sets of controls in MixfMRI</p></a></li>
<li><a href='#Plotting'><p>Main plotting function</p></a></li>
<li><a href='#Print+20Objects'><p>Print fclust related outputs</p></a></li>
<li><a href='#Simulations'><p>Generate datasets for MixfMRI simulations</p></a></li>
<li><a href='#Smoothing'><p>Generate datasets with smoothing for MixfMRI simulations</p></a></li>
<li><a href='#Summarized+20Overlap'><p>Summarized Overlap</p></a></li>
<li><a href='#Threshold.Bonferroni'><p>Calculates Bonferroni Threshold</p></a></li>
<li><a href='#Threshold.FDR'><p>False Discovery Rate (FDR) Threshold</p></a></li>
<li><a href='#Threshold.RF'><p>Random Field Theory Thersholds.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Mixture fMRI Clustering Analysis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, Matrix, RColorBrewer, fftw, MixSim, EMCluster</td>
</tr>
<tr>
<td>Enhances:</td>
<td>pbdMPI (&ge; 0.3-4), oro.nifti</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilizing model-based clustering (unsupervised)
        for functional magnetic resonance imaging (fMRI) data.
        The developed methods (Chen and Maitra (2023) &lt;<a href="https://doi.org/10.1002%2Fhbm.26425">doi:10.1002/hbm.26425</a>&gt;)
        include 2D and 3D clustering analyses
        (for p-values with voxel locations) and
        segmentation analyses (for p-values alone) for fMRI data where p-values
        indicate significant level of activation responding to stimulate
        of interesting. The analyses are mainly identifying active
        voxel/signal associated with normal brain behaviors.
        Analysis pipelines (R scripts) utilizing this package
        (see examples in 'inst/workflow/') is also implemented with high
        performance techniques.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">Mozilla Public License 2.0</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/snoweye/MixfMRI/issues">https://github.com/snoweye/MixfMRI/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/snoweye/MixfMRI">https://github.com/snoweye/MixfMRI</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei-Chen Chen &lt;wccsnow@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-17 01:22:42 UTC; snoweye</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei-Chen Chen [aut, cre],
  Ranjan Maitra [aut],
  Dan Nettleton [aut, ctb],
  Pierre Lafaye De Micheaux [aut, ctb] (Threshold functions from
    AnalyzeFMRI),
  Jonathan L Marchini [aut, ctb] (Threshold functions from AnalyzeFMRI)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-17 04:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='MixfMRI-package'>fMRI Clustering Analysis</h2><span id='topic+MixfMRI-package'></span><span id='topic+MixfMRI'></span>

<h3>Description</h3>

<p>Utilizing model-based clustering (unsupervised)
for fMRI data especially in a distributed manner. The methods
includes 2D and 3D clustering analyses and segmentation analyses for
fMRI signals where p-values are significant levels of active voxels
which respond to stimulate of interesting. The analyses are
mainly identifying active voxels/signals from normal brain behaviors.
Workflows are also implemented utilizing high performance techniques.
</p>


<h3>Details</h3>

<p>The main function of this package is <code><a href="#topic+fclust">fclust</a>()</code> that implements
model-based clustering algorithm for fMRI signal data and provides
unsupervised clustering results for the data. Several workflows implemented
with high-performance computing techniques are also built in for automatically
process clustering, hypothesis, cluster merging, and visualizations.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2023)
&ldquo;A practical model-based segmentation approach for improved
activation detection in single-subject functional magnetic
resonance imaging studies&rdquo;,
<em>Human Brain Mapping</em>, <b>44</b>(16), 5309&ndash;5335.
(<em>doi:10.1002/hbm.26425</em>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fclust">fclust</a>()</code>, <code><a href="#topic+set.global">set.global</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)

.rem &lt;- function(){

  demo(fclust3d,'MixfMRI',ask=FALSE,echo=FALSE)
  demo(fclust2d,'MixfMRI',ask=FALSE,echo=FALSE)

}

</code></pre>

<hr>
<h2 id='algorithm'>Main algorithms implemented in fclust</h2><span id='topic+ecm.step.gbd'></span><span id='topic+apecma.step.gbd'></span><span id='topic+em.step.gbd'></span>

<h3>Description</h3>

<p>Main algorithms implemented in fclust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ecm.step.gbd(PARAM.org)

  apecma.step.gbd(PARAM.org)

  em.step.gbd(PARAM.org)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algorithm_+3A_param.org">PARAM.org</code></td>
<td>
<p>an initialized <code>PARAM</code>, usually returned by
<code><a href="#topic+set.global">set.global</a>()</code>, <code><a href="#topic+initial.em.gbd">initial.em.gbd</a>()</code>,
and <code><a href="#topic+initial.RndEM.gbd">initial.RndEM.gbd</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are main algorithms implemented in <code><a href="#topic+fclust">fclust</a>()</code>.
</p>


<h3>Value</h3>

<p>Return an optimized <code>PARAM</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a>()</code>, <code><a href="#topic+fclust">fclust</a>()</code>, <code><a href="#topic+PARAM">PARAM</a></code>,
<code><a href="#topic+PARAM.org">PARAM.org</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
library(EMCluster, quietly = TRUE)
# .FC.CT$algorithm &lt;- "em"
# .FC.CT$model.X &lt;- "V"
# .FC.CT$ignore.X &lt;- TRUE
.FC.CT$check.X.unit &lt;- FALSE

### Test toy1.
set.seed(1234)
X.gbd &lt;- toy1$X.gbd
PV.gbd &lt;- toy1$PV.gbd
PARAM &lt;- set.global(X.gbd, PV.gbd, K = 2)
PARAM.new &lt;- initial.em.gbd(PARAM)
PARAM.toy1 &lt;- em.step.gbd(PARAM.new)
id.toy1 &lt;- .MixfMRIEnv$CLASS.gbd
print(PARAM.toy1$ETA)
RRand(toy1$CLASS.gbd, id.toy1)


.rem &lt;- function(){

  ### Test toy2.
  set.seed(1234)
  X.gbd &lt;- toy2$X.gbd
  PV.gbd &lt;- toy2$PV.gbd
  PARAM &lt;- set.global(X.gbd, PV.gbd, K = 3)
  PARAM.new &lt;- initial.em.gbd(PARAM)
  PARAM.toy2 &lt;- em.step.gbd(PARAM.new)
  id.toy2 &lt;- .MixfMRIEnv$CLASS.gbd
  print(PARAM.toy2$ETA)
  RRand(toy2$CLASS.gbd, id.toy2)

}

</code></pre>

<hr>
<h2 id='cluster.threshold'>Cluster threshold an array.</h2><span id='topic+cluster.threshold'></span><span id='topic+cluster_mass'></span>

<h3>Description</h3>

<p>Calculate contiguous clusters of locations in a 3D array that are
above some threshold and with some minimum size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.threshold(x, nmat = NULL, level.thr = 0.5, size.thr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.threshold_+3A_x">x</code></td>
<td>
<p>A 3D array</p>
</td></tr>
<tr><td><code id="cluster.threshold_+3A_nmat">nmat</code></td>
<td>
<p>A matrix with 3 columns specifying the neighbourhood
system. Default is 6 nearest neighbours in 3D.</p>
</td></tr>
<tr><td><code id="cluster.threshold_+3A_level.thr">level.thr</code></td>
<td>
<p>The level at which to threshold the array
values. Default is 0.5 and is designed to cluster 0-1 arrays.</p>
</td></tr>
<tr><td><code id="cluster.threshold_+3A_size.thr">size.thr</code></td>
<td>
<p>The cluster size threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function is directly copied from &quot;AnalyzeFMRI&quot;.
</p>


<h3>Value</h3>

<p>Returns an array of the same size as x with a 1 at all locations
which have a value above level.thr and are in a cluster of similiar
locations with size greater than size.thr. 
</p>


<h3>Author(s)</h3>

<p>J. L. Marchini</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- array(0, dim = c(64, 64, 21))
x[10:20, 10:20, 1:5] &lt;- 1
x[30:40, 30:40, 6:7] &lt;- 1
x[50, 50, 8:9] &lt;- 1

a &lt;- cluster.threshold(x, size.thr = 400)
sum(x) ## should be 849
sum(a) ## should be 605

</code></pre>

<hr>
<h2 id='Compute+20Q+20values'>Q-values using Benjamini and Hochberg (1995)</h2><span id='topic+qvalue'></span>

<h3>Description</h3>

<p>Compute q-values Benjamini and Hochberg's (1995) approach for controlling FDR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qvalue(p, method = c("BH1995", "BY2001"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Compute+2B20Q+2B20values_+3A_p">p</code></td>
<td>
<p>a p-value vector.</p>
</td></tr>
<tr><td><code id="Compute+2B20Q+2B20values_+3A_method">method</code></td>
<td>
<p>using method by either BH1995 or BY2001</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compute q-values using Benjamini and Hochberg's (1995)
approach for controlling FDR. The function <code>bh.fdr</code> is originally
written by Dr. Dan Nettleton.
</p>
<p>The Benjamini and Yeekutieli's (2001) approach for controlling FDR using
the function <code>by.fdr</code> is coded by Wei-Chen Chen.
</p>


<h3>Value</h3>

<p>Return corresponding q-values for the input p-values.
</p>


<h3>Author(s)</h3>

<p>Dan Nettleton.
</p>
<p>Modified by Wei-Chen Chen.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpval">dpval</a>()</code>, <code><a href="#topic+dmixpval">dmixpval</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)
da &lt;- gendataset(phantom = shepp1fMRI, overlap = 0.01)
p &lt;- da$pval[!is.na(da$pval)][1:100]
qvalue(p)
</code></pre>

<hr>
<h2 id='Compute+20Statistics+20for+20Log+20Odds+20Ratio+20of+20Posterior+20Probability'>Compute Statistics for Log Odds Ratio of Posterior Probability</h2><span id='topic+logor.stat'></span>

<h3>Description</h3>

<p>The function computes statistics for log odds ratio of posterior probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logor.stat(x, fcobj, post.z, cov.param = NULL, cov.post.z = NULL,
                 cov.logit.z = NULL, all.x = FALSE, drop.ETA1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_x">x</code></td>
<td>
<p>an input list of two elements <code>X.gbd</code> and <code>PV.gbd</code>.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_fcobj">fcobj</code></td>
<td>
<p>a <code>fclust</code> object.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_post.z">post.z</code></td>
<td>
<p>a matrix of <code>dim = N * K</code> for posterior probabilities,
which is also the return value of <code>post.prob()</code>.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_cov.param">cov.param</code></td>
<td>
<p>a covariance matrix of <code>dim = d * d</code> for parameters,
which is also a return of <code>cov.param()</code>.
<code>d</code> is total number of parameters which is dependent
on data and models.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_cov.post.z">cov.post.z</code></td>
<td>
<p>a covariance list of length equal to number of active
voxels, which is also a return of <code>cov.post.z()</code>.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_cov.logit.z">cov.logit.z</code></td>
<td>
<p>a covariance list of length equal to number of active
voxels, which is also a return of <code>cov.logit.z()</code>.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_all.x">all.x</code></td>
<td>
<p>all cov matrices for all observations are returned if TRUE,
while for only active observations (those of class ids are
greater than 1) if FALSE.</p>
</td></tr>
<tr><td><code id="Compute+2B20Statistics+2B20for+2B20Log+2B20Odds+2B20Ratio+2B20of+2B20Posterior+2B20Probability_+3A_drop.eta1">drop.ETA1</code></td>
<td>
<p>if drop the <code>ETA[1]</code> from the cov matrix due to the
<code>min.1st.prop</code> constrain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For posterior probability,
this function compute log odd ratio, cov matrix of log odd ratio,
degrees of freedom, and testing statistics.
</p>


<h3>Value</h3>

<p>A list is returned with four elements: <code>log.or</code>, <code>cov.log.or</code>,
<code>df</code>, and <code>test.stat</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code>post.prob()</code>, <code>cov.param()</code>, <code>cov.post.z()</code>,
<code>cov.logit.z()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
.FC.CT$model.X &lt;- "I"
.FC.CT$CONTROL$debug &lt;- 0
K &lt;- 3

### Fit toy1.
set.seed(1234)
X.gbd &lt;- toy1$X.gbd
X.range &lt;- apply(X.gbd, 2, range)
X.gbd &lt;- t((t(X.gbd) - X.range[1,]) / (X.range[2,] - X.range[1,]))
PV.gbd &lt;- toy1$PV.gbd
fcobj &lt;- fclust(X.gbd, PV.gbd, K = K, min.1st.prop = 0.5)

### Test log odds ratio.
x &lt;- list(X.gbd = X.gbd, PV.gbd = PV.gbd)
post.z &lt;- post.prob(x, fcobj)
lor &lt;- logor.stat(x, fcobj, post.z)

### Check if 95% CE covers log odd ratio = 1.
id &lt;- !is.na(lor$df)
id.cover.0 &lt;- which(lor$test.stat[id] &lt; pchisq(0.95, lor$df[id]))

### Get voxels needed for merging.
id.active &lt;- which(fcobj$class != 1)
id.merge &lt;- id.active[id][id.cover.0]

### Check results.
post.z[id.merge,]
cbind(toy1$X.gbd[id.merge,], toy1$PV.gbd[id.merge])
</code></pre>

<hr>
<h2 id='Covariance+20Matrices'>Covariance Matrices</h2><span id='topic+post.prob'></span><span id='topic+cov.param'></span><span id='topic+cov.post.z'></span><span id='topic+cov.logit.z'></span>

<h3>Description</h3>

<p>These functions compute posterior probabilities,
Fisher information with covariance matrix of parameters,
covariance matrix of posterior probabilities, and covariance matrix of
logit posterior probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  post.prob(x, fcobj)
  cov.param(x, fcobj, post.z, drop.ETA1 = FALSE)
  cov.post.z(x, fcobj, post.z, cov.param = NULL, all.x = FALSE,
                 drop.ETA1 = FALSE)
  cov.logit.z(x, fcobj, post.z, cov.param = NULL, cov.post.z = NULL,
                  all.x = FALSE, drop.ETA1 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Covariance+2B20Matrices_+3A_x">x</code></td>
<td>
<p>an input list of two elements <code>X.gbd</code> and <code>PV.gbd</code>.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices_+3A_fcobj">fcobj</code></td>
<td>
<p>a <code>fclust</code> object.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices_+3A_post.z">post.z</code></td>
<td>
<p>a matrix of <code>dim = N * K</code> for posterior probabilities,
which is also the return value of <code>post.prob()</code>.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices_+3A_cov.param">cov.param</code></td>
<td>
<p>a covariance matrix of <code>dim = d * d</code> for parameters,
which is also a return of <code>cov.param()</code>.
<code>d</code> is total number of parameters which is dependent
on data and models.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices_+3A_cov.post.z">cov.post.z</code></td>
<td>
<p>a covariance list of length equal to number of active
voxels, which is also a return of <code>cov.post.z()</code>.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices_+3A_all.x">all.x</code></td>
<td>
<p>all cov matrices for all observations are returned if TRUE,
while for only active observations (those of class ids are
greater than 1) if FALSE.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices_+3A_drop.eta1">drop.ETA1</code></td>
<td>
<p>if drop the <code>ETA[1]</code> from the cov matrix due to the
<code>min.1st.prop</code> constrain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are required to compute covariance matrices of
parameters and posterior probabilities.
</p>
<p>Use <code>post.prob()</code> to get the posterior probabilities.
</p>
<p>Input the returns of <code>post.prob()</code>
to <code>cov.param()</code> to obtain the cov matrix for parameters
(inversed Fisher information obtained from inner product of gradient
of log observed data likelihood). A list is returned with <code>I</code>
for Fisher information, and <code>cov</code> for the covariance matrix which
is inverted by <code>ginv()</code>.
</p>
<p>Input the returns of <code>post.prob()</code> and <code>cov.param()</code>
to <code>cov.post.z()</code> to obtain the cov matrix for posterior
probabilities by the multivariate delta method on the cov matrix for
parameters.
</p>
<p>Input the returns of <code>post.prob()</code>, <code>cov.param()</code>, and
<code>cov.post.z()</code> to <code>cov.logit.z()</code> to obtain cov matrix
for logit posterior probabilities by the multivariate delta method on
cov matrix of posterior probabilities.
</p>


<h3>Value</h3>

<p>A matrix or a list is returned.
</p>
<p>The <code>cov.param()</code> will return a list containing two elements
<code>I</code> for the Fisher information, and <code>cov</code> for the covariance matrix
by generalized inversed of the Fisher information. The dimension of both
elements are <code>d * d</code> where <code>d = K * 7 - 4</code> for 2D data and
<code>d = K * 9 - 4</code> for 3D data if <code>drop.ETA1 = TRUE</code>, otherwise
they are <code>d = K * 7 - 3</code> and <code>d = K * 9 -4</code>, respectively.
</p>
<p>The <code>cov.post.z()</code> will return a list containing cov matrices of
posterior probabilities for each valid/selected voxel.
</p>
<p>The <code>cov.logit.z()</code> will return a list containing cov matrices of
logit posterior probabilities for each valid/selected voxel.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code>EMCluster::lmt()</code>, <code>lmt.I()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
library(EMCluster, quietly = TRUE)
.FC.CT$model.X &lt;- "I"
.FC.CT$CONTROL$debug &lt;- 0
K &lt;- 3
  

.rem &lt;- function(){

  ### Fit toy1.
  set.seed(1234)
  X.gbd &lt;- toy1$X.gbd
  X.range &lt;- apply(X.gbd, 2, range)
  X.gbd &lt;- t((t(X.gbd) - X.range[1,]) / (X.range[2,] - X.range[1,]))
  PV.gbd &lt;- toy1$PV.gbd
  fcobj &lt;- fclust(X.gbd, PV.gbd, K = K, min.1st.prop = 0.5)
  
  ### Test cov matrix of posterior z and logit posterior z.
  x &lt;- list(X.gbd = X.gbd, PV.gbd = PV.gbd)
  post.z &lt;- post.prob(x, fcobj)
  cov.param &lt;- cov.param(x, fcobj, post.z = post.z)
  cov.post.z &lt;- cov.post.z(x, fcobj, post.z = post.z,
                               cov.param = cov.param$cov)
  cov.logit.z &lt;- cov.logit.z(x, fcobj, post.z = post.z,
                                 cov.param = cov.param$cov,
                                 cov.post.z = cov.post.z)
  
  ### Compute cov matrix of log odds ratio for all k &gt; 1.
  A &lt;- cbind(rep(-1, K - 1), diag(1, K - 1))
  logit.p &lt;- log(post.z[fcobj$class != 1,] / (1 - post.z[fcobj$class != 1,]))
  log.or &lt;- logit.p %*% t(A)
  cov.log.or &lt;- lapply(cov.logit.z, function(x) A %*% x %*% t(A))
  
  ### Check if 0 vector covered by 95% confidence ellipsoid.
  id &lt;- 1
  plot(log.or[id,],
       xlim = log.or[id, 1] + c(-5, 5),
       ylim = log.or[id, 2] + c(-5, 5),
       main = "1st observation", xlab = "x", ylab = "y")
  plotBN(log.or[id,], cov.log.or[[id]])
  points(0, 0, col = 2)

}

</code></pre>

<hr>
<h2 id='Covariance+20Matrices+20of+20Logit+20ETA'>Covariance Matrices of Logit ETA</h2><span id='topic+cov.logit.ETA'></span>

<h3>Description</h3>

<p>These functions computes covariance matrix of logit ETA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cov.logit.ETA(x, fcobj, cov.param = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Covariance+2B20Matrices+2B20of+2B20Logit+2B20ETA_+3A_x">x</code></td>
<td>
<p>an input list of two elements <code>X.gbd</code> and <code>PV.gbd</code>.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices+2B20of+2B20Logit+2B20ETA_+3A_fcobj">fcobj</code></td>
<td>
<p>a <code>fclust</code> object.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Matrices+2B20of+2B20Logit+2B20ETA_+3A_cov.param">cov.param</code></td>
<td>
<p>a covariance matrix of <code>dim = d * d</code> for parameters,
which is also a return of <code>cov.param()</code>.
<code>d</code> is total number of parameters which is dependent
on data and models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are required to compute covariance matrices of
logit ETA.
</p>
<p>Input the returns of <code>cov.param()</code>
to <code>cov.logit.ETA()</code> to obtain the cov matrix for logit ETA
by the multivariate delta method on the cov matrix for parameters.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code>EMCluster::lmt()</code>, <code>lmt.I()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
.FC.CT$model.X &lt;- "I"
.FC.CT$CONTROL$debug &lt;- 0
K &lt;- 3
  

.rem &lt;- function(){

  ### Fit toy1.
  set.seed(1234)
  X.gbd &lt;- toy1$X.gbd
  X.range &lt;- apply(X.gbd, 2, range)
  X.gbd &lt;- t((t(X.gbd) - X.range[1,]) / (X.range[2,] - X.range[1,]))
  PV.gbd &lt;- toy1$PV.gbd
  fcobj &lt;- fclust(X.gbd, PV.gbd, K = K, min.1st.prop = 0.5)
  
  ### Test cov matrix of posterior z.
  x &lt;- list(X.gbd = X.gbd, PV.gbd = PV.gbd)
  post.z &lt;- post.prob(x, fcobj)
  cov.param &lt;- cov.param(x, fcobj, post.z)
  cov.logit.ETA &lt;- cov.logit.ETA(x, fcobj, cov.param = cov.param$cov)
  
  ### Compute cov matrxi of eta_k - eta_1 for all k &gt; 1.
  A &lt;- cbind(rep(-1, K - 1), diag(1, K - 1))
  ETA &lt;- fcobj$param$ETA
  log.or &lt;- log(ETA / (1 - ETA)) %*% t(A)
  cov.log.or &lt;- A %*% cov.logit.ETA %*% t(A)

}

</code></pre>

<hr>
<h2 id='Density+20function+20of+20p-values'>Density function of p-values</h2><span id='topic+dpval'></span><span id='topic+dmixpval'></span>

<h3>Description</h3>

<p>These functions based on normal assumption and transformation to
derive a (mixture) density function of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dpval(x, mu = 0, log = FALSE)
  dmixpval(x, eta, mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Density+2B20function+2B20of+2B20p-values_+3A_x">x</code></td>
<td>
<p>support of p-values which should be between 0 and 1.</p>
</td></tr>
<tr><td><code id="Density+2B20function+2B20of+2B20p-values_+3A_mu">mu</code></td>
<td>
<p>hypothetical mean of testing statistics (in normal distribution)
for producing p-values.</p>
</td></tr>
<tr><td><code id="Density+2B20function+2B20of+2B20p-values_+3A_log">log</code></td>
<td>
<p>if return log of density.</p>
</td></tr>
<tr><td><code id="Density+2B20function+2B20of+2B20p-values_+3A_eta">eta</code></td>
<td>
<p>mixing proportion of <code>K</code> components if a mixture is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>eta</code> and <code>mu</code> in <code>dmixpval()</code> are of length
<code>K</code> for <code>K</code> component mixtures.
</p>


<h3>Value</h3>

<p>Corresponding density values (to the input <code>x</code>) are returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gendataset">gendataset</a>()</code>, <code><a href="#topic+qvalue">qvalue</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)
da &lt;- gendataset(phantom = shepp1fMRI, overlap = 0.01)
x &lt;- da$pval[!is.na(da$pval)][1:100]
dpval(x)
dmixpval(x, mu = da$mu, eta = da$eta)
</code></pre>

<hr>
<h2 id='EC.3D'>Expected Euler Characteristic for a 3D Random Field</h2><span id='topic+EC.3D'></span>

<h3>Description</h3>

<p>Calculates the Expected Euler Characteristic for a 3D
Random Field thesholded a level u.</p>


<h3>Usage</h3>

<pre><code class='language-R'>EC.3D(u, sigma, voxdim = c(1, 1, 1), num.vox, type = c("Normal", "t"), df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EC.3D_+3A_u">u</code></td>
<td>
<p>The threshold for the field.</p>
</td></tr>
<tr><td><code id="EC.3D_+3A_sigma">sigma</code></td>
<td>
<p>The spatial covariance matrix of the field.</p>
</td></tr>
<tr><td><code id="EC.3D_+3A_voxdim">voxdim</code></td>
<td>
<p>The dimensions of the cuboid 'voxels' upon which the
discretized field is observed.</p>
</td></tr>
<tr><td><code id="EC.3D_+3A_num.vox">num.vox</code></td>
<td>
<p>The number of voxels that make up the field.</p>
</td></tr>
<tr><td><code id="EC.3D_+3A_type">type</code></td>
<td>
<p>The marginal distribution of the Random Field (only Normal
and t at present).</p>
</td></tr>
<tr><td><code id="EC.3D_+3A_df">df</code></td>
<td>
<p>The degrees of freedom of the t field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Euler Characteristic <code class="reqn">\chi_u</code> (Adler, 1981) is a
topological measure that essentially counts the number of isolated
regions of the random field above the threshold <code class="reqn">u</code> minus the
number of 'holes'. As <code class="reqn">u</code> increases the holes disappear and
<code class="reqn">\chi_u</code> counts the number of local maxima. So when <code class="reqn">u</code>
becomes close to the maximum of the random field
<code class="reqn">Z_{\textrm{max}}</code> we have that
</p>
<p style="text-align: center;"><code class="reqn">P( \textrm{reject}  H_0 | H_0  \textrm{true}) =
  P(Z_{\textrm{max}}) = P(\chi_u &gt; 0) \approx E(\chi_u)</code>
</p>

<p>where <code class="reqn">H_0</code> is the null hypothesis that there is no signicant
positive actiavtion/signal present in the field. Thus the Type I error
of the test can be controlled through knowledge of the Expected Euler characteristic.
</p>
<p>Note: This function is directly copied from &quot;AnalyzeFMRI&quot;.
</p>


<h3>Value</h3>

<p>The value of the expected Euler Characteristic.
</p>


<h3>Author(s)</h3>

<p>J. L. Marchini</p>


<h3>References</h3>

<p>Adler, R. (1981) <em>The Geometry of Random Fields.</em>. New York: Wiley.
Worlsey, K. J. (1994) Local maxima and the expected euler
characteristic of excursion sets of <code class="reqn">\chi^2</code>, <code class="reqn">f</code> and <code class="reqn">t</code>
fields. <em>Advances in Applied Probability</em>, <b>26</b>, 13-42.</p>


<h3>See Also</h3>

<p><code><a href="#topic+Threshold.RF">Threshold.RF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>EC.3D(4.6, sigma = diag(1, 3), voxdim = c(1, 1, 1), num.vox = 10000)

EC.3D(4.6, sigma = diag(1, 3), voxdim = c(1, 1, 1), num.vox = 10000, type = "t", df = 100)

</code></pre>

<hr>
<h2 id='Example+20Datasets'>Example datasets in MixfMRI</h2><span id='topic+pstats'></span><span id='topic+pval.2d.complex'></span><span id='topic+pval.2d.mag'></span><span id='topic+shepp0fMRI'></span><span id='topic+shepp1fMRI'></span><span id='topic+shepp2fMRI'></span><span id='topic+sheppAnat'></span><span id='topic+toy1'></span><span id='topic+toy2'></span>

<h3>Description</h3>

<p>These are datasets used to demo examples and workflows in this package.
</p>


<h3>Format</h3>

<p>Objects may contain several information and data.
</p>


<h3>Details</h3>

<p><code>pstats</code> is a 3D example.
</p>
<p><code>pval.2d.complex</code> and <code>pval.2d.mag</code> are 2D examples.
</p>
<p><code>shepp0fMRI</code>, <code>shepp1fMRI</code>, <code>shepp2fMRI</code> and
<code>sheppAnat</code> are phantoms generated by Dr. Maitra
for simulation studies with different overlap levels for p-values.
</p>
<p><code>toy1</code> and <code>toy2</code> are two 3D toy examples.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)

### Plotting.
demo(shepp,'MixfMRI',ask=FALSE,echo=FALSE)
</code></pre>

<hr>
<h2 id='False+20Discovery+20Rates+20for+20Spatial+20Signals'>False Discovery Rates for Spatial Signals using Benjamini and Heller (2007)</h2><span id='topic+fdr.bh.p1'></span><span id='topic+fdr.bh.p2'></span>

<h3>Description</h3>

<p>Compute q-values Benjamini and Heller's (2007) approach for controlling FDR
for spatial signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fdr.bh.p1(p, w = rep(1, length(p)), q = 0.05)
  fdr.bh.p2(p, w = rep(1, length(p)), q = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="False+2B20Discovery+2B20Rates+2B20for+2B20Spatial+2B20Signals_+3A_p">p</code></td>
<td>
<p>a p-value vector. No NA is allowed and all values are in [0, 1].</p>
</td></tr>
<tr><td><code id="False+2B20Discovery+2B20Rates+2B20for+2B20Spatial+2B20Signals_+3A_w">w</code></td>
<td>
<p>a weight vector for p-values.</p>
</td></tr>
<tr><td><code id="False+2B20Discovery+2B20Rates+2B20for+2B20Spatial+2B20Signals_+3A_q">q</code></td>
<td>
<p>a desired cutoff for adjusting p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement first two procedures in Benjamini and Heller (2007)
for controlling FDR for spatial signals.
</p>


<h3>Value</h3>

<p>Return the number of rejected hypotheses and all
corresponding q-values for the input p-values.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qvalue">qvalue</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)
da &lt;- gendataset(phantom = shepp1fMRI, overlap = 0.01)
p &lt;- da$pval[!is.na(da$pval)][1:100]
fdr.bh.p1(p)
fdr.bh.p2(p)
</code></pre>

<hr>
<h2 id='General+20Internal+20Functions'>All General Internal Functions and Datasets</h2><span id='topic+.MixfMRIEnv'></span><span id='topic+my.YlOrRd'></span><span id='topic+my.YlGnBu'></span><span id='topic+my.Reds'></span><span id='topic+my.alpha.append'></span><span id='topic+print.lmt.I'></span><span id='topic+print.lmt.pv'></span>

<h3>Description</h3>

<p>All general internal functions
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>

<hr>
<h2 id='Generalized+20Cluster-Based+20Analysis+20+28CBA+29+20Method'>Generalized Cluster-Based Analysis (CBA) Method</h2><span id='topic+cba.cor'></span><span id='topic+cba.cor.2d'></span><span id='topic+cba.cor.3d'></span>

<h3>Description</h3>

<p>Find clusters in 2D or 3D based on a generalized CBA method. The CBA
method is originally proposed by Heller, et.al. (2006) using the correlation
of two time series as the similarity of two spatial locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cba.cor(da.ts, da.m = NULL, adj.dist = TRUE, fun.sim = stats::cor)
  cba.cor.2d(da.ts, da.m = NULL, adj.dist = TRUE, fun.sim = stats::cor)
  cba.cor.3d(da.ts, da.m = NULL, adj.dist = TRUE, fun.sim = stats::cor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Generalized+2B20Cluster-Based+2B20Analysis+2B20+2B28CBA+2B29+2B20Method_+3A_da.ts">da.ts</code></td>
<td>
<p>a time series array of dimensions <code>x * y * z * t</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Cluster-Based+2B20Analysis+2B20+2B28CBA+2B29+2B20Method_+3A_da.m">da.m</code></td>
<td>
<p>a mask determining inside of brain or not.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Cluster-Based+2B20Analysis+2B20+2B28CBA+2B29+2B20Method_+3A_adj.dist">adj.dist</code></td>
<td>
<p>if adjust correlations by distance.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Cluster-Based+2B20Analysis+2B20+2B28CBA+2B29+2B20Method_+3A_fun.sim">fun.sim</code></td>
<td>
<p>a function computing simility of two locations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions implement the 2D and 3D versions of CBA proposed by
Heller, et.al. (2006).
</p>
<p><code>da.ts</code> should have dimensions <code>x * y * z * t</code> for 3D data
and <code>x * y * time</code> for 2D data. Similarly, <code>da.m</code> would have
<code>x * y * z</code> and <code>x * y</code> correspondingly.
</p>
<p><code>da.m</code> has values 0 or 1 indicating outside or inside a brain,
respectively.
</p>
<p><code>fun.sim(a, B)</code> is a function return similarity between a location
<code>a</code> and N neighboring locations <code>B</code> where <code>a</code> is of dimension
<code>t * 1</code> and <code>B</code> is of dimension <code>t * N</code>.
Ideally, <code>fun.sim</code>()
should return values of similarity which take values
between 0 and 1 where 0 means totally different and
1 means completely identical of two spatial locations.
By default, <code>stats::cor</code> is used.
See the example section next for user defined functions for
<code>fun.sim</code>().
</p>


<h3>Value</h3>

<p>Return the cluster ids for each voxel. NA for outside of brain if
<code>da.m</code> is provided.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen.
</p>


<h3>References</h3>

<p>Heller, et.al. (2006) &ldquo;Cluster-based analysis of FMRI data&rdquo;,
NeuroImage, 33(2), 599-608.
</p>
<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fdr.bh.p1">fdr.bh.p1</a>()</code>, <code><a href="#topic+fdr.bh.p2">fdr.bh.p2</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Simulated data
library(MixfMRI, quietly = TRUE)
dim &lt;- c(4, 5, 4, 10)
set.seed(123)
da.ts &lt;- array(rnorm(prod(dim)), dim = dim)
id.class &lt;- suppressWarnings(cba.cor(da.ts))
table(id.class)

fun.tanh &lt;- function(a, B){
  d &lt;- 1 / apply(B, 2, function(b){ dist(rbind(as.vector(a), b)) })
  tanh(d)
}
id.class.tanh &lt;- suppressWarnings(cba.cor(da.ts, fun.sim = fun.tanh))
table(id.class.tanh)

fun.logit &lt;- function(a, B){
  d &lt;- dist(t(cbind(a, B)))[1:ncol(B)]
  (1 / (1 + exp(-d))) * 2 - 1
}
id.class.logit &lt;- suppressWarnings(cba.cor(da.ts, fun.sim = fun.logit))
table(id.class.logit)


.rem &lt;- function(){

  ### Real data
  # library(AnalyzeFMRI, quietly = TRUE)
  # library(oro.nifti, quietly = TRUE)

  # fn &lt;- "pb02_volreg_tlrc.nii"
  # da &lt;- readNIfTI(fn)
  # da.ts &lt;- da@.Data

  # fn &lt;- "mask_anat.nii"
  # da &lt;- readNIfTI(fn)
  # da.m &lt;- da@.Data

  # id.class &lt;- suppressWarnings(cba.cor(da.ts, da.m))
  # dim(id.class) &lt;- dim(da.m)
  # length(table(id.class))

}

</code></pre>

<hr>
<h2 id='initial'>Main initialization functions</h2><span id='topic+initial.em.gbd'></span><span id='topic+initial.RndEM.gbd'></span>

<h3>Description</h3>

<p>Main initialization functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  initial.em.gbd(PARAM)

  initial.RndEM.gbd(PARAM)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial_+3A_param">PARAM</code></td>
<td>
<p>a list of uninitialized parameters, as usual, the returned
values of <code><a href="#topic+set.global">set.global</a>()</code>, to be initialized
according to data (inside <code>PARAM</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>initial.em.gbd()</code> takes in a template of <code>PARAM</code> (uninitialized),
and usually is available by calling <code><a href="#topic+set.global">set.global</a>()</code>, then
return an initialized <code>PARAM</code> which is ready for EM runs.
</p>
<p>Internally, there are six different initializations implemented for
the function <code>initial.em.gbd()</code> including <code>prob.extend</code>,
<code>prob.simple</code>, <code>qnorm.extend</code>, <code>qnorm.simple</code>, <code>extend</code>,
and <code>simple</code>. These methods are mainly based on transformation of
original space of data (p-values and voxel locations) into more linear
space such that the Euclidean distance more makes sense (fairly) to
classify data in groups.
</p>
<p><code>initial.RndEM.gbd()</code> implement RndEM initialization algorithm
based on repeated calling <code>initial.em.gbd()</code>.
</p>
<p>Note that all configurations are included in <code>PARAM</code> set by
<code><a href="#topic+set.global">set.global</a>()</code>.
</p>


<h3>Value</h3>

<p>These functions return an initialized <code>PARAM</code> for EM runs based on
pre-stored configuration within the input uninitialized <code>PARAM</code>.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a>()</code>, <code><a href="#topic+fclust">fclust</a>()</code>, <code><a href="#topic+PARAM">PARAM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
library(EMCluster, quietly = TRUE)
# .FC.CT$algorithm &lt;- "em"
# .FC.CT$model.X &lt;- "V"
# .FC.CT$ignore.X &lt;- TRUE
.FC.CT$check.X.unit &lt;- FALSE

### Test toy1.
set.seed(1234)
X.gbd &lt;- toy1$X.gbd
PV.gbd &lt;- toy1$PV.gbd
PARAM &lt;- set.global(X.gbd, PV.gbd, K = 2)
PARAM.new &lt;- initial.em.gbd(PARAM)
PARAM.toy1 &lt;- em.step.gbd(PARAM.new)
id.toy1 &lt;- .MixfMRIEnv$CLASS.gbd
print(PARAM.toy1$ETA)
RRand(toy1$CLASS.gbd, id.toy1)


.rem &lt;- function(){

  ### Test toy2.
  set.seed(1234)
  X.gbd &lt;- toy2$X.gbd
  PV.gbd &lt;- toy2$PV.gbd
  PARAM &lt;- set.global(X.gbd, PV.gbd, K = 3)
  PARAM.new &lt;- initial.em.gbd(PARAM)
  PARAM.toy2 &lt;- em.step.gbd(PARAM.new)
  id.toy2 &lt;- .MixfMRIEnv$CLASS.gbd
  print(PARAM.toy2$ETA)
  RRand(toy2$CLASS.gbd, id.toy2)

}

</code></pre>

<hr>
<h2 id='Likelihood+20Mixture+20Tests+20with+20Identity+20Cov+20Matrix+20or+20Only+20p-values'>Likelihood Mixture Tests with Identity Cov Matrix or Only p-values</h2><span id='topic+lmt.I'></span><span id='topic+lmt.pv'></span>

<h3>Description</h3>

<p>These functions test two mixture Gaussian fMRI models with diagonal
covariance matrices and different numbers of clusters.
These functions are similar to the <code>EMCluster::lmt(</code>), but is coded
for fMRI models in <span class="pkg">MixfMRI</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lmt.I(fcobj.0, fcobj.a, X.gbd, PV.gbd, tau = 0.5, n.mc.E.delta = 1000,
        n.mc.E.chi2 = 1000, verbose = FALSE)
  lmt.pv(fcobj.0, fcobj.a, X.gbd, PV.gbd, tau = 0.5, n.mc.E.delta = 1000,
        n.mc.E.chi2 = 1000, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_fcobj.0">fcobj.0</code></td>
<td>
<p>a <code>fclust</code> object for the null hypothesis.</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_fcobj.a">fcobj.a</code></td>
<td>
<p>a <code>fclust</code> object for the alternative hypothesis.</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_x.gbd">X.gbd</code></td>
<td>
<p>a data matrix of <code>N</code> voxel locations.
<code>dim(X.gbd) = N x 3</code> for 3D data and
<code>N x 2</code> for 2D data.</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_pv.gbd">PV.gbd</code></td>
<td>
<p>a p-value vector of signals associated with voxels.
<code>length(PV.gbd) = N</code>.</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_tau">tau</code></td>
<td>
<p>proportion of null and alternative hypotheses.</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_n.mc.e.delta">n.mc.E.delta</code></td>
<td>
<p>number of Monte Carlo simulations for expectation
of delta (difference of logL).</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_n.mc.e.chi2">n.mc.E.chi2</code></td>
<td>
<p>number of Monte Carlo simulations for expectation
of chisquare statistics.</p>
</td></tr>
<tr><td><code id="Likelihood+2B20Mixture+2B20Tests+2B20with+2B20Identity+2B20Cov+2B20Matrix+2B20or+2B20Only+2B20p-values_+3A_verbose">verbose</code></td>
<td>
<p>if verbose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls several subroutines to compute information,
likelihood ratio statistics, degrees of freedom, non-centrality
of chi-squared distributions ... etc. Based on Monte Carlo methods
to estimate parameters of likelihood mixture tests, this function
return a p-value for testing H0: <code>fcobj.0</code> v.s. Ha: <code>fcobj.a</code>.
</p>
<p><code>lmt.pv()</code> only uses <code>PV.gbd</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>lmt.I</code> are returned.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code>EMCluster::lmt()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
library(EMCluster, quietly = TRUE)
.FC.CT$model.X &lt;- "I"
.FC.CT$check.X.unit &lt;- FALSE
.FC.CT$CONTROL$debug &lt;- 0
  

.rem &lt;- function(){

  ### Fit toy1.
  set.seed(1234)
  X.gbd &lt;- toy1$X.gbd
  PV.gbd &lt;- toy1$PV.gbd
  ret.2 &lt;- fclust(X.gbd, PV.gbd, K = 2)
  ret.3 &lt;- fclust(X.gbd, PV.gbd, K = 3)
  ret.4 &lt;- fclust(X.gbd, PV.gbd, K = 4)
  ret.5 &lt;- fclust(X.gbd, PV.gbd, K = 5)
  
  ### ARI
  RRand(toy1$CLASS.gbd, ret.2$class)
  RRand(toy1$CLASS.gbd, ret.3$class)
  RRand(toy1$CLASS.gbd, ret.4$class)
  RRand(toy1$CLASS.gbd, ret.5$class)
  
  ### Test toy1.
  (lmt.23 &lt;- lmt.I(ret.2, ret.3, X.gbd, PV.gbd))
  (lmt.24 &lt;- lmt.I(ret.2, ret.4, X.gbd, PV.gbd))
  (lmt.25 &lt;- lmt.I(ret.2, ret.5, X.gbd, PV.gbd))
  (lmt.34 &lt;- lmt.I(ret.3, ret.4, X.gbd, PV.gbd))
  (lmt.35 &lt;- lmt.I(ret.3, ret.5, X.gbd, PV.gbd))
  (lmt.45 &lt;- lmt.I(ret.4, ret.5, X.gbd, PV.gbd))
  
  ### Test toy1 using p-values only.
  (lmt.pv.23 &lt;- lmt.pv(ret.2, ret.3, X.gbd, PV.gbd))
  (lmt.pv.24 &lt;- lmt.pv(ret.2, ret.4, X.gbd, PV.gbd))
  (lmt.pv.25 &lt;- lmt.pv(ret.2, ret.5, X.gbd, PV.gbd))
  (lmt.pv.34 &lt;- lmt.pv(ret.3, ret.4, X.gbd, PV.gbd))
  (lmt.pv.35 &lt;- lmt.pv(ret.3, ret.5, X.gbd, PV.gbd))
  (lmt.pv.45 &lt;- lmt.pv(ret.4, ret.5, X.gbd, PV.gbd))

}

</code></pre>

<hr>
<h2 id='LRT'>Likelihood ratio tests</h2><span id='topic+lrt'></span><span id='topic+lrt2'></span><span id='topic+lrt.betamean'></span><span id='topic+lrt.betaab'></span>

<h3>Description</h3>

<p>Likelihood ratio tests for merging clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lrt(PV.gbd, CLASS.gbd, K, H0.alpha = .FC.CT$LRT$H0.alpha,
      H0.beta = .FC.CT$LRT$H0.beta)

  lrt2(PV.gbd, CLASS.gbd, K, H0.mean = .FC.CT$LRT$H0.mean,
    upper.beta = .FC.CT$INIT$BETA.beta.max, proc = c("1", "2", "weight"))

  lrt.betamean(PV.gbd, CLASS.gbd, K, proc = c("1", "2"))

  lrt.betaab(PV.gbd, CLASS.gbd, K, proc = c("1", "2"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LRT_+3A_pv.gbd">PV.gbd</code></td>
<td>
<p>a p-value vector of signals associated with voxels.
<code>length(PV.gbd) = N</code>.</p>
</td></tr>
<tr><td><code id="LRT_+3A_class.gbd">CLASS.gbd</code></td>
<td>
<p>a classification vector of signals associated with voxels.
<code>length(CLASS.gbd) = N</code>.</p>
</td></tr>
<tr><td><code id="LRT_+3A_k">K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code id="LRT_+3A_h0.alpha">H0.alpha</code></td>
<td>
<p>null hypothesis for the alpha parameter of Beta distribution.</p>
</td></tr>
<tr><td><code id="LRT_+3A_h0.beta">H0.beta</code></td>
<td>
<p>null hypothesis for the beta parameter of Beta distribution.</p>
</td></tr>
<tr><td><code id="LRT_+3A_h0.mean">H0.mean</code></td>
<td>
<p>null hypothesis for the mean of Beta distribution.</p>
</td></tr>
<tr><td><code id="LRT_+3A_upper.beta">upper.beta</code></td>
<td>
<p>BETA.beta.max, maximum value of beta parameter of
Beta distribution.</p>
</td></tr>
<tr><td><code id="LRT_+3A_proc">proc</code></td>
<td>
<p>q-value procedure for adjusting p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform likelihood ratio tests for merging clusters.
Only p-values coordinates (Beta density) are tested, while
voxel location coordinates (multivariate Normal density) are not involved
in testing.
</p>
<p><code>lrt.betamean</code> tests if means of any two pairs of mixture
(p-value) component were the same.
The chi-square distribution with 1 degree of freedom is used.
</p>
<p><code>lrt.betaab</code> tests if alpha and beta of any two pairs of mixture
(p-value) components were the same.
The chi-square distribution with 2 degrees of freedom is used.
</p>
<p>Procedure to adjust/select plausible p-values,
<code>proc = "1"</code> uses q-value <code>qvalue()</code>,
<code>proc = "2"</code> uses <code>fdr.bh.p2()</code>, and
<code>proc = "weight"</code> uses a weighted version of <code>fdr.bh.p2()</code>.
</p>


<h3>Value</h3>

<p>A matrix contains MLEs of parameters of Beta distribution under the null
hypothesis and the union of null and alternative hypotheses. The matrix
also contains testing statistics and p-values.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PARAM">PARAM</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)

### Test 2d data.
da &lt;- pval.2d.mag
id &lt;- !is.na(da)
PV.gbd &lt;- da[id]
id.loc &lt;- which(id, arr.ind = TRUE)
X.gbd &lt;- t(t(id.loc) / dim(da))
ret &lt;- fclust(X.gbd, PV.gbd, K = 2, min.1st.prop = 0.95)
# print(ret)

### p-values of rest clusters.
ret.lrt &lt;- lrt(PV.gbd, ret$class, K = 2)
print(ret.lrt)

.rem &lt;- function(){

  ret.lrt2 &lt;- lrt2(PV.gbd, ret$class, K = 3)
  print(ret.lrt2)

}

</code></pre>

<hr>
<h2 id='Main+20functions'>Main MixfMRI function</h2><span id='topic+fclust'></span><span id='topic+set.global'></span><span id='topic+PARAM'></span><span id='topic+PARAM.org'></span>

<h3>Description</h3>

<p>Main MixfMRI functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fclust(X.gbd, PV.gbd, K = 2,
    PARAM.init = NULL,
    min.1st.prop = .FC.CT$INIT$min.1st.prop,
    max.PV = .FC.CT$INIT$max.PV,
    class.method = .FC.CT$INIT$class.method[1],
    RndEM.iter = .FC.CT$CONTROL$RndEM.iter,
    algorithm = .FC.CT$algorithm[1],
    model.X = .FC.CT$model.X[1],
    ignore.X = .FC.CT$ignore.X,
    stop.unstable = TRUE,
    MPI.gbd = .FC.CT$MPI.gbd, common.gbd = .FC.CT$common.gbd)

  set.global(X.gbd, PV.gbd, K = 2,
    min.1st.prop = .FC.CT$INIT$min.1st.prop,
    max.PV = .FC.CT$INIT$max.PV,
    class.method = .FC.CT$INIT$class.method[1],
    RndEM.iter = .FC.CT$CONTROL$RndEM.iter,
    algorithm = .FC.CT$algorithm[1],
    model.X = .FC.CT$model.X[1],
    ignore.X = .FC.CT$ignore.X,
    check.X.unit = .FC.CT$check.X.unit,
    MPI.gbd = .FC.CT$MPI.gbd, common.gbd = .FC.CT$common.gbd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Main+2B20functions_+3A_x.gbd">X.gbd</code></td>
<td>
<p>a data matrix of <code>N</code> voxel locations.
<code>dim(X.gbd) = N x 3</code> for 3D data and
<code>N x 2</code> for 2D data.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_pv.gbd">PV.gbd</code></td>
<td>
<p>a p-value vector of signals associated with voxels.
<code>length(PV.gbd) = N</code>.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_k">K</code></td>
<td>
<p>number of clusters to be estimated.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_param.init">PARAM.init</code></td>
<td>
<p>initial parameters.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_min.1st.prop">min.1st.prop</code></td>
<td>
<p>lower bound of mixing proportion (ETA) of the 1st cluster
(uniform).</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_max.pv">max.PV</code></td>
<td>
<p>upper bound of p-values where initializations pick from.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_class.method">class.method</code></td>
<td>
<p>classification method for initializations.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_rndem.iter">RndEM.iter</code></td>
<td>
<p>number of RndEM iterations.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_algorithm">algorithm</code></td>
<td>
<p>either &ldquo;ecm&rdquo; (ECM), &ldquo;apecma&rdquo; (APECMa) or &ldquo;em&rdquo; (EM) algorithm.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_model.x">model.X</code></td>
<td>
<p>either &ldquo;I&rdquo; or &ldquo;V&rdquo; for covariance matrix.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_ignore.x">ignore.X</code></td>
<td>
<p>if <code>X.gbd</code> used in model, TRUE for PV.gbd only.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_check.x.unit">check.X.unit</code></td>
<td>
<p>if <code>X.gbd</code> are all in <code>[0, 1]</code>.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_stop.unstable">stop.unstable</code></td>
<td>
<p>if <code>fclust</code> stops if unstable results occur.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_mpi.gbd">MPI.gbd</code></td>
<td>
<p>if MPI (&ldquo;EGM&rdquo; algorithm) is used.</p>
</td></tr>
<tr><td><code id="Main+2B20functions_+3A_common.gbd">common.gbd</code></td>
<td>
<p>if <code>X.gbd</code> and <code>PV.gbd</code> are in common across all
ranks when <code>MPI.gbd = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fclust()</code> contains initialization and EM algorithms for clustering
fMRI signal data which have two parts: <code>X.gbd</code> for voxel information
either 2D or 3D, <code>PV.gbd</code> for p-value of signals associated with
voxels. Each signal is assumed as a mixture distribution with <code>K</code>
components with mixing proportion <code>ETA</code>, and each component has
two independent coordinates with density functions: Beta and multivariate
Normal distributions.
</p>
<p>Beta density:
The 1st component is restricted by <code>min.1st.prop</code> and Beta(1, 1)
distribution. The other <code>K - 1</code> components have Beta(alpha, beta)
distribution with <code>alpha &lt; 1 &lt; beta</code>.
</p>
<p>Multivariate Normal density:
<code>model.X = "I"</code> is for diagonal cov matrix of multivariate Normal
distribution, and <code>"V"</code> for unstructured cov matrix.
<code>ignore.X = TRUE</code> is to ignore <code>X.gbd</code> and normal density,
i.e. only Beta density is used.
</p>
<p>Currently, APECMa and EM algorithms are implemented with EGM algorithm
to speed up convergence if MPI is available.
RndEM initialization is also implemented for better chance of good
initial values for convergence.
</p>
<p>The <code>set.global()</code> has purposes: create a template/storage of
parameters, save configurations, and called by <code>fclust()</code> to initial
the parameters, such as <code><a href="#topic+initial.em.gbd">initial.em.gbd</a>()</code> or
<code><a href="#topic+initial.RndEM.gbd">initial.RndEM.gbd</a>()</code>.
</p>


<h3>Value</h3>

<p>A list with class <code>fclust</code> by <code>fclust()</code> is returned
which can be summarized by <code><a href="#topic+print.fclust">print.fclust</a>()</code>.
</p>
<p>A list <code>PARAM</code> or <code>PARAM.org</code> is returned by <code>set.global()</code>:
</p>
<table role = "presentation">
<tr><td><code>N.gbd</code></td>
<td>
<p>number of observations (within the rank), and should be
equal to <code>N.all</code> if <code>MPI.gbd = FALSE</code>.</p>
</td></tr>
<tr><td><code>N.all</code></td>
<td>
<p>numbers of observations (of all ranks
if <code>MPI.gbd = TRUE</code>).</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>total number of observations (<code>sum(N.all)</code>).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>dimension of an observation (3 for 2D signals, 4 for 3D signals),
equivalent to total number of coordinates.</p>
</td></tr>
<tr><td><code>p.X</code></td>
<td>
<p>dimension of <code>X.gbd</code> (2 for 2D signals, 3 for 3D signals,
0 when <code>ignore.X = TRUE</code>, number of voxel coordinates.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>number of clusters.</p>
</td></tr>
<tr><td><code>ETA</code></td>
<td>
<p>mixing proportion, length <code>K</code>.</p>
</td></tr>
<tr><td><code>log.ETA</code></td>
<td>
<p><code>log(ETA)</code>.</p>
</td></tr>
<tr><td><code>BETA</code></td>
<td>
<p>a list of length <code>K</code> containing parameters (alpha, beta)
of Beta density.</p>
</td></tr> 
<tr><td><code>MU</code></td>
<td>
<p>a matrix of dimension <code>p.X by K</code>.</p>
</td></tr>
<tr><td><code>SIGMA</code></td>
<td>
<p>a list of length <code>K</code>, and each is of dimension
<code>K x K</code>.</p>
</td></tr>
<tr><td><code>logL</code></td>
<td>
<p>log likelihood value.</p>
</td></tr>
<tr><td><code>min.1st.prop</code></td>
<td>
<p>carried from input.</p>
</td></tr>
<tr><td><code>max.PV</code></td>
<td>
<p>carried from input.</p>
</td></tr>
<tr><td><code>class.method</code></td>
<td>
<p>classification method of initializations.</p>
</td></tr>
<tr><td><code>min.N.CLASS</code></td>
<td>
<p><code>p + 1</code>.</p>
</td></tr>
<tr><td><code>model.X</code></td>
<td>
<p>carried from input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.fclust">print.fclust</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
library(EMCluster, quietly = TRUE)
# .FC.CT$algorithm &lt;- "em"
# .FC.CT$model.X &lt;- "V"
# .FC.CT$ignore.X &lt;- TRUE
.FC.CT$check.X.unit &lt;- FALSE
set.seed(1234)

### Test toy1.
X.gbd &lt;- toy1$X.gbd[, -3]
PV.gbd &lt;- toy1$PV.gbd
PARAM &lt;- fclust(X.gbd, PV.gbd, K = 2)
print(PARAM)
id.toy1 &lt;- .MixfMRIEnv$CLASS.gbd
print(RRand(toy1$CLASS.gbd, id.toy1))


.rem &lt;- function(){

  ### Test toy2.
  X.gbd &lt;- toy2$X.gbd[, -3]
  PV.gbd &lt;- toy2$PV.gbd
  PARAM &lt;- fclust(X.gbd, PV.gbd, K = 3)
  print(PARAM)
  id.toy2 &lt;- .MixfMRIEnv$CLASS.gbd
  print(RRand(toy2$CLASS.gbd, id.toy2))

}

</code></pre>

<hr>
<h2 id='MixfMRI+20Control'>Sets of controls in MixfMRI</h2><span id='topic+.FC.CT'></span>

<h3>Description</h3>

<p>These sets of controls are used to provide default values in this package.
</p>


<h3>Format</h3>

<p>Objects contain several parameters for methods.
</p>


<h3>Details</h3>

<p>The elements of <code>.FC.CT</code> are default values for main controls of
<span class="pkg">MixfMRI</span> including
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements             </td><td style="text-align: center;"> Default   </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>algorithm</code>     </td><td style="text-align: center;"> "apecma"  </td><td style="text-align: left;"> implemented algorithm </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>optim.method</code>  </td><td style="text-align: center;"> "BFGS"    </td><td style="text-align: left;"> optimization method </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>model.X</code>       </td><td style="text-align: center;"> "I"       </td><td style="text-align: left;"> cov matrix structure </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>ignore.X</code>      </td><td style="text-align: center;"> FALSE     </td><td style="text-align: left;"> if using voxel information </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>check.X.unit</code>  </td><td style="text-align: center;"> TRUE      </td><td style="text-align: left;"> if checking X in <code>[0, 1]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>CONTROL</code>       </td><td style="text-align: center;"> a list    </td><td style="text-align: left;"> see CONTROL next for details </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>INIT</code>          </td><td style="text-align: center;"> a list    </td><td style="text-align: left;"> see INIT next for details </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>LRT</code>           </td><td style="text-align: center;"> a list    </td><td style="text-align: left;"> see LRT next for details </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>MPI.gbd</code>       </td><td style="text-align: center;"> FALSE     </td><td style="text-align: left;"> if MPI speedup available </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>common.gbd</code>    </td><td style="text-align: center;"> TRUE      </td><td style="text-align: left;"> if X in common gbd format </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The elements of <code>CONTROL</code> are default values for optimization controls
of implemented EM algorithm including
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements            </td><td style="text-align: center;"> Default    </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>max.iter</code>     </td><td style="text-align: center;"> 1000       </td><td style="text-align: left;"> maximum number of EM iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>abs.err</code>      </td><td style="text-align: center;"> 1e-4       </td><td style="text-align: left;"> absolute error of convergence </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>rel.err</code>      </td><td style="text-align: center;"> 1e-6       </td><td style="text-align: left;"> relative error of convergence </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>debug</code>        </td><td style="text-align: center;"> 1          </td><td style="text-align: left;"> debugging level </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>RndEM.iter</code>   </td><td style="text-align: center;"> 10         </td><td style="text-align: left;"> RndEM iterations </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exp.min</code>      </td><td style="text-align: center;"> log(.Machine$double.xmin)         </td><td style="text-align: left;"> minimum exponential power </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>exp.max</code>      </td><td style="text-align: center;"> log(.Machine$double.xmax)         </td><td style="text-align: left;"> maximum exponential power </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>sigma.ill</code>    </td><td style="text-align: center;"> 1e-6       </td><td style="text-align: left;"> ill condition limit </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>DS.max</code>       </td><td style="text-align: center;"> 1e+4       </td><td style="text-align: left;"> maximum <code>chol()</code> cov matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>DS.min</code>       </td><td style="text-align: center;"> 1e-6       </td><td style="text-align: left;"> minimum <code>chol()</code> cov matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The elements of <code>INIT</code> are default values or limitations for initial
parameters implemented for EM algorithm including
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements              </td><td style="text-align: center;"> Default       </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>min.1st.prop</code>   </td><td style="text-align: center;"> 0.8           </td><td style="text-align: left;"> minimum proportion of 1st cluster </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>max.PV</code>         </td><td style="text-align: center;"> 0.1           </td><td style="text-align: left;"> maximum p-value for initialization </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>BETA.alpha.min</code> </td><td style="text-align: center;"> 0 + 1e-6      </td><td style="text-align: left;"> minimum value of alpha parameter of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>BETA.alpha.max</code> </td><td style="text-align: center;"> 1 - 1e-6      </td><td style="text-align: left;"> maximum value of alpha parameter of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>BETA.beta.min</code>  </td><td style="text-align: center;"> 1 + 1e-6      </td><td style="text-align: left;"> minimum value of beta parameter of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>BETA.beta.max</code>  </td><td style="text-align: center;"> 1e+6          </td><td style="text-align: left;"> maximum value of beta parameter of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>max.try.iter</code>   </td><td style="text-align: center;"> 10            </td><td style="text-align: left;"> maximum retry iterations if result is unstable </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>class.method</code>   </td><td style="text-align: center;"> "prob.extned" </td><td style="text-align: left;"> classification method at initializations </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The elements of <code>LRT</code> are default values or limitations for likelihood
ratio tests including
</p>

<table>
<tr>
 <td style="text-align: left;">
  Elements              </td><td style="text-align: center;"> Default   </td><td style="text-align: left;"> Usage </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>H0.alpha</code>       </td><td style="text-align: center;"> 1         </td><td style="text-align: left;"> null hypothesis alpha parameter of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>H0.beta</code>        </td><td style="text-align: center;"> 1         </td><td style="text-align: left;"> null hypothesis beta parameter of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>H0.mean</code>        </td><td style="text-align: center;"> 0.05      </td><td style="text-align: left;"> null hypothesis mean of Beta distribution </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a>()</code>, <code><a href="#topic+fclust">fclust</a>()</code>.
</p>

<hr>
<h2 id='Plotting'>Main plotting function</h2><span id='topic+plotfclust'></span><span id='topic+plotfclustpv'></span><span id='topic+plotpv'></span><span id='topic+plotpvlegend'></span>

<h3>Description</h3>

<p>Main plotting function in <span class="pkg">MixfMRI</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plotfclust(da, posterior, main = NULL, xlim = NULL, ylim = NULL)
  plotfclustpv(da, posterior, main = NULL, xlim = NULL, ylim = NULL)

  plotpv(da, posterior, PARAM, zlim = c(0, 0.01), plot.mean = TRUE,
         xlab = "", ylab = "", main = NULL, xlim = NULL, ylim = NULL,
         col = my.YlOrRd(), ignore.bg = FALSE)
  plotpvlegend(zlim = c(0, 0.01), n.level = 20, main = NULL,
               col = my.YlOrRd())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plotting_+3A_da">da</code></td>
<td>
<p>a data set to be plotted.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_posterior">posterior</code></td>
<td>
<p>a posterior data set to be plotted.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_param">PARAM</code></td>
<td>
<p>a returning parameter object from <code><a href="#topic+fclust">fclust</a>()</code>.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_main">main</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_xlim">xlim</code></td>
<td>
<p>limits of x-axis.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_ylim">ylim</code></td>
<td>
<p>limits of y-axis.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_zlim">zlim</code></td>
<td>
<p>limits of z-axis.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_xlab">xlab</code></td>
<td>
<p>labels of x-axis.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_ylab">ylab</code></td>
<td>
<p>labels of y-axis.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_plot.mean">plot.mean</code></td>
<td>
<p>if plotting mean values of each cluster.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_col">col</code></td>
<td>
<p>colors to be drawn.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_ignore.bg">ignore.bg</code></td>
<td>
<p>if ignoring the background.</p>
</td></tr>
<tr><td><code id="Plotting_+3A_n.level">n.level</code></td>
<td>
<p>number of levels to be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are example functions to plot results, simulations, and datasets.
</p>


<h3>Value</h3>

<p>Return plots.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)
  

.rem &lt;- function(){

  ### Check 2d data.
  da &lt;- pval.2d.complex
  id &lt;- !is.na(da)
  PV.gbd &lt;- da[id]
  hist(PV.gbd, nclass = 100, main = "p-value")
  
  ### Test 2d data.
  id.loc &lt;- which(id, arr.ind = TRUE)
  X.gbd &lt;- t(t(id.loc) / dim(da))
  ret &lt;- fclust(X.gbd, PV.gbd, K = 3)
  print(ret)
  
  ### p-values of rest clusters.
  ret.lrt &lt;- lrt(PV.gbd, ret$class, K = 3)
  print(ret.lrt)
  ret.lrt2 &lt;- lrt2(PV.gbd, ret$class, K = 3)
  print(ret.lrt2)
  
  ### Plotting.
  par(mfrow = c(2, 2), mar = c(0, 0, 2, 0))
  plotpv(da, ret$posterior, ret$param,
         zlim = c(0.005, 0.008), main = "Mean of Beta Distribution")
  plotpv(da, ret$posterior, ret$param,
         plot.mean = FALSE, main = "p-value")
  par(mar = c(5.1, 4.1, 4.1, 2.1))
  plotpvlegend(zlim = c(0.005, 0.008), main = "Mean of Beta Distribution")
  plotpvlegend(zlim = c(0, 0.01), main = "p-value")

}

</code></pre>

<hr>
<h2 id='Print+20Objects'>Print fclust related outputs</h2><span id='topic+print.fclust'></span>

<h3>Description</h3>

<p>Print flcust related outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'fclust'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Print+2B20Objects_+3A_x">x</code></td>
<td>
<p>an object with the class attributes.</p>
</td></tr>
<tr><td><code id="Print+2B20Objects_+3A_...">...</code></td>
<td>
<p>other arguments to the <code>print</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> is the return result from <code><a href="#topic+fclust">fclust</a>()</code>.
</p>


<h3>Value</h3>

<p>A summary of <code><a href="#topic+fclust">fclust</a></code> object is printed.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a>()</code>, <code><a href="#topic+fclust">fclust</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)

### Check 2d data.
da &lt;- pval.2d.complex
id &lt;- !is.na(da)
PV.gbd &lt;- da[id]
# hist(PV.gbd, nclass = 100, main = "p-value")

### Test 2d data.
id.loc &lt;- which(id, arr.ind = TRUE)
X.gbd &lt;- t(t(id.loc) / dim(da))
ret &lt;- fclust(X.gbd, PV.gbd, K = 2)
print(ret)
</code></pre>

<hr>
<h2 id='Simulations'>Generate datasets for MixfMRI simulations</h2><span id='topic+gendataset'></span>

<h3>Description</h3>

<p>Generate datasets for MixfMRI simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gendataset(phantom, overlap, smooth = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Simulations_+3A_phantom">phantom</code></td>
<td>
<p>a phantom dataset.</p>
</td></tr>
<tr><td><code id="Simulations_+3A_overlap">overlap</code></td>
<td>
<p>a desired overlap level.</p>
</td></tr>
<tr><td><code id="Simulations_+3A_smooth">smooth</code></td>
<td>
<p>if <code>gcv.smooth2d()</code> be applied to the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function to generate simulated fMRI data based on the input
<code>phantom</code> and the desired <code>overlap</code> level for the fMRI p-value.
</p>


<h3>Value</h3>

<p>Return a list contains <code>eta</code> for mixing proportion,
<code>overlap</code> for the desired level, <code>mu</code> for center of p-values,
<code>class.id</code> for the true classifications where p-values belong to,
<code>tval</code> for the testing statistics, and <code>pval</code> for the p-values
of interesting in simulations.
</p>


<h3>Author(s)</h3>

<p>Wei-Chen Chen and Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set.global">set.global</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rem &lt;- function(){

  library(MixfMRI, quietly = TRUE)
  set.seed(1234)
  da &lt;- gendataset(phantom = shepp1fMRI, overlap = 0.01)$pval
  da2 &lt;- gendataset(phantom = shepp2fMRI, overlap = 0.01)$pval

  par(mfrow = c(2, 2), mar = rep(0.05, 4))
  image(shepp1fMRI[50:210, 50:210], axes = FALSE)
  image(shepp2fMRI[50:210, 50:210], axes = FALSE)
  image(da[50:210, 50:210], axes = FALSE)
  image(da2[50:210, 50:210], axes = FALSE)

}

</code></pre>

<hr>
<h2 id='Smoothing'>Generate datasets with smoothing for MixfMRI simulations</h2><span id='topic+gcv.smooth2d'></span>

<h3>Description</h3>

<p>Generate datasets with smoothing for MixfMRI simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gcv.smooth2d(y, interval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Smoothing_+3A_y">y</code></td>
<td>
<p>a set of p-values in 2d phantom</p>
</td></tr>
<tr><td><code id="Smoothing_+3A_interval">interval</code></td>
<td>
<p>an interval for <code>optimize</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used to smooth for Dr. Maitra's 2d phantom simulation.
The smoothing method is based on Garcia (2010), CSDA.
</p>


<h3>Value</h3>

<p>Return a list containing two elements <code>im.smooth</code> and
<code>par.val</code>.
</p>


<h3>Author(s)</h3>

<p>Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>

<hr>
<h2 id='Summarized+20Overlap'>Summarized Overlap</h2><span id='topic+summarized.overlap'></span>

<h3>Description</h3>

<p>Compute summarized overlap on a given overlap (symmetric) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  summarized.overlap(overlap.mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Summarized+2B20Overlap_+3A_overlap.mat">overlap.mat</code></td>
<td>
<p>an overlap (symmetric) matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>overlap.mat</code> is a <code>p * p</code> matrix containing pair wised overlaps
of <code>p</code> experiments. <code>overlap.mat</code> is assumed a symmetric matrix.
This function returns a summarized overlap based on the input
<code>overlap.mat</code> that charactorizes the overall overlap behavior of the
<code>p</code> experiments.
</p>


<h3>Value</h3>

<p>A single value is returned.
</p>


<h3>Author(s)</h3>

<p>Ranjan Maitra.
</p>


<h3>References</h3>

<p>Chen, W.-C. and Maitra, R. (2021)
&ldquo;A Practical Model-based Segmentation Approach for Accurate
Activation Detection in Single-Subject functional Magnetic
Resonance Imaging Studies&rdquo;,
<em>arXiv:2102.03639</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MixfMRI, quietly = TRUE)
set.seed(1234)
p &lt;- 10  # 10 experiments.
overlap.mat &lt;- diag(1, p)
overlap.mat[lower.tri(overlap.mat)] &lt;- runif(p * (p - 1) / 2)
overlap.mat[upper.tri(overlap.mat)] &lt;- t(overlap.mat)[upper.tri(overlap.mat)]
summarized.overlap(overlap.mat)
</code></pre>

<hr>
<h2 id='Threshold.Bonferroni'>Calculates Bonferroni Threshold</h2><span id='topic+Threshold.Bonferroni'></span>

<h3>Description</h3>

<p>Calculate the Bonferroni threshold for n iid tests that
results in an overall p-value of p.val. The tests can be distributed
as Normal, t or F.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Threshold.Bonferroni(p.val, n, type = c("Normal", "t", "F"), df1 = NULL, df2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Threshold.Bonferroni_+3A_p.val">p.val</code></td>
<td>
<p>The required overall p-value.</p>
</td></tr>
<tr><td><code id="Threshold.Bonferroni_+3A_n">n</code></td>
<td>
<p>The number of tests.</p>
</td></tr>
<tr><td><code id="Threshold.Bonferroni_+3A_type">type</code></td>
<td>
<p>The distribution of the tests. One of &quot;Normal&quot;, &quot;t&quot; or &quot;F&quot;</p>
</td></tr>
<tr><td><code id="Threshold.Bonferroni_+3A_df1">df1</code></td>
<td>
<p>The degrees of freedom of the t-distribution or the first
degrees of freedom parameter for the F distribution.</p>
</td></tr>
<tr><td><code id="Threshold.Bonferroni_+3A_df2">df2</code></td>
<td>
<p>The second degrees of freedom parameter for the F distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function is directly copied from &quot;AnalyzeFMRI&quot;.
</p>


<h3>Value</h3>

<p>Returns the Bonferroni threshold.
</p>


<h3>Author(s)</h3>

<p>Pierre Lafaye De Micheaux and J. L. Marchini.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Threshold.Bonferroni(0.05, 1000)

Threshold.Bonferroni(0.05, 1000, type = c("t"), df1 = 20)

Threshold.Bonferroni(0.05, 1000, type = c("F"), df1 = 3, df2 = 100)

</code></pre>

<hr>
<h2 id='Threshold.FDR'>False Discovery Rate (FDR) Threshold</h2><span id='topic+Threshold.FDR'></span>

<h3>Description</h3>

<p>Calculates the False Discovery Rate (FDR) threshold for a
given vector of statistic values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Threshold.FDR(x, q, cV.type = 2, type = c("Normal", "t", "F"), df1 = NULL, df2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Threshold.FDR_+3A_x">x</code></td>
<td>
<p>A vector of test statistic values.</p>
</td></tr>
<tr><td><code id="Threshold.FDR_+3A_q">q</code></td>
<td>
<p>The desired False Discovery Rate threshold.</p>
</td></tr>
<tr><td><code id="Threshold.FDR_+3A_cv.type">cV.type</code></td>
<td>
<p>A flag that specifies the assumptions about the joint
distribution of p-values. Choose cV.type = 2 for fMRI data (see
Genovese et al (2001)</p>
</td></tr>
<tr><td><code id="Threshold.FDR_+3A_type">type</code></td>
<td>
<p>The distribution of the statistic values. Either &quot;Normal&quot;,
&quot;t&quot; or &quot;F&quot;.</p>
</td></tr>
<tr><td><code id="Threshold.FDR_+3A_df1">df1</code></td>
<td>
<p>The degrees of freedom of the t-distribution or the first
degrees of freedom parameter for the F distribution.</p>
</td></tr>
<tr><td><code id="Threshold.FDR_+3A_df2">df2</code></td>
<td>
<p>The second degrees of freedom parameter for the F distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This function is directly copied from &quot;AnalyzeFMRI&quot;.
</p>


<h3>Value</h3>

<p>Returns the FDR threshold.
</p>


<h3>Author(s)</h3>

<p>J. L. Marchini</p>


<h3>References</h3>

<p>Genovese et al. (2001) Thresholding of Statistical Maps in
Functional NeuroImaging Using the False Discovery Rate.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(1000), rnorm(100, mean = 3))
Threshold.FDR(x = x, q = 0.20, cV.type = 2) 
</code></pre>

<hr>
<h2 id='Threshold.RF'>Random Field Theory Thersholds.</h2><span id='topic+Threshold.RF'></span>

<h3>Description</h3>

<p>Calculates the Random Field theory threshold to give that
results in a specified p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Threshold.RF(p.val, sigma, voxdim = c(1, 1, 1), num.vox,
             type = c("Normal", "t"), df = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Threshold.RF_+3A_p.val">p.val</code></td>
<td>
<p>The required p-value.</p>
</td></tr>
<tr><td><code id="Threshold.RF_+3A_sigma">sigma</code></td>
<td>
<p>The 3D covariance matrix of the random field.</p>
</td></tr>
<tr><td><code id="Threshold.RF_+3A_voxdim">voxdim</code></td>
<td>
<p>The dimesnions of a voxel.</p>
</td></tr>
<tr><td><code id="Threshold.RF_+3A_num.vox">num.vox</code></td>
<td>
<p>The number of voxels that constitute the random field.</p>
</td></tr>
<tr><td><code id="Threshold.RF_+3A_type">type</code></td>
<td>
<p>The type of random field, &quot;Normal&quot; or &quot;t&quot;.</p>
</td></tr>
<tr><td><code id="Threshold.RF_+3A_df">df</code></td>
<td>
<p>The degrees of the t distributed field.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the threshold that produces an expected Euler
characteristic equal to the required p-value.
</p>
<p>Note: This function is directly copied from &quot;AnalyzeFMRI&quot;.
</p>


<h3>Value</h3>

<p>Returns the Random Field threshold.
</p>


<h3>Author(s)</h3>

<p>J. L. Marchini</p>


<h3>See Also</h3>

<p><code><a href="#topic+EC.3D">EC.3D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Threshold.RF(p.val = 0.05, sigma = diag(1, 3), voxdim = c(1, 1, 1), num.vox = 10000)

EC.3D(a, sigma = diag(1, 3), voxdim = c(1, 1, 1), num.vox = 10000)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
