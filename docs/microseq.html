<!DOCTYPE html><html><head><title>Help for package microseq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {microseq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backTranslate'><p>Replace amino acids with codons</p></a></li>
<li><a href='#findGenes'><p>Finding coding genes</p></a></li>
<li><a href='#findOrfs'><p>Finding ORFs in genomes</p></a></li>
<li><a href='#findrRNA'><p>Finding rRNA genes</p></a></li>
<li><a href='#gff2fasta'><p>Retrieving annotated sequences</p></a></li>
<li><a href='#gregexpr'><p>Extended <code>gregexpr</code> with substring retrieval</p></a></li>
<li><a href='#iupac2regex'><p>Ambiguity symbol conversion</p></a></li>
<li><a href='#lorfs'><p>Longest ORF</p></a></li>
<li><a href='#microseq-package'><p>Basic Biological Sequence Analysis</p></a></li>
<li><a href='#msa2mat'><p>Convert alignment to matrix</p></a></li>
<li><a href='#msalign'><p>Multiple alignment</p></a></li>
<li><a href='#msaTrim'><p>Trimming multiple sequence alignments</p></a></li>
<li><a href='#muscle'><p>Multiple alignment using MUSCLE</p></a></li>
<li><a href='#orfLength'><p>Length of ORF</p></a></li>
<li><a href='#orfSignature'><p>Signature for each ORF</p></a></li>
<li><a href='#readFasta'><p>Read and write FASTA files</p></a></li>
<li><a href='#readFastq'><p>Read and write FASTQ files</p></a></li>
<li><a href='#readGFF'><p>Reading and writing GFF-tables</p></a></li>
<li><a href='#reverseComplement'><p>Reverse-complementation of DNA</p></a></li>
<li><a href='#translate'><p>Translation according to the standard genetic code</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Basic Biological Sequence Handling</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Lars Snipen, Kristian Hovde Liland</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lars Snipen &lt;lars.snipen@nmbu.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic functions for microbial sequence data analysis. The idea is to use generic R data structures as much as possible, making R data wrangling possible also for sequence data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), tibble, stringr, dplyr, data.table, rlang</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>ZipData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 11:11:00 UTC; larssn</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='backTranslate'>Replace amino acids with codons</h2><span id='topic+backTranslate'></span>

<h3>Description</h3>

<p>Replaces aligned amino acids with their original codon triplets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backTranslate(aa.msa, nuc.ffn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backTranslate_+3A_aa.msa">aa.msa</code></td>
<td>
<p>A fasta object with a multiple alignment, see <code><a href="#topic+msalign">msalign</a></code>.</p>
</td></tr>
<tr><td><code id="backTranslate_+3A_nuc.ffn">nuc.ffn</code></td>
<td>
<p>A fasta object with the coding sequences, see <code><a href="#topic+readFasta">readFasta</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replaces the aligned amino acids in <code>aa.msa</code> with their
original codon triplets. This is possible only when the nucleotide sequences in <code>nuc.ffn</code>
are the exact nucleotide sequences behind the protein sequences that are aligned in <code>aa.msa</code>.
</p>
<p>It is required that the first token of the &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; lines is identical for a protein sequence
in <code>aa.msa</code> and its nucleotide version in &lsquo;<span class="samp">&#8288;nuc.ffn&#8288;</span>&rsquo;, otherwise it is impossible to
match them. Thus, they may not appear in the same order in the two input fasta objects.
</p>
<p>When aligning coding sequences, one should in general always align their protein sequences, to
keep the codon structure, and then use <code><a href="#topic+backTranslate">backTranslate</a></code> to convert this into a 
nucleotide alignment, if required.
</p>
<p>If the nuclotide sequences contain the stop codons, these will be removed.
</p>


<h3>Value</h3>

<p>A fasta object similar to <code>aa.msa</code>, but where each amino acid has been replace by 
its corresponding codon. All gaps &lsquo;<span class="samp">&#8288;"-"&#8288;</span>&rsquo; are replaced by triplets &lsquo;<span class="samp">&#8288;"---"&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msalign">msalign</a></code>, <code><a href="#topic+readFasta">readFasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msa.file &lt;- file.path(file.path(path.package("microseq"),"extdata"), "small.msa")
aa.msa &lt;- readFasta(msa.file)
nuc.file &lt;- file.path(file.path(path.package("microseq"),"extdata"), "small.ffn")
nuc &lt;- readFasta(nuc.file)
nuc.msa &lt;- backTranslate(aa.msa, nuc)

</code></pre>

<hr>
<h2 id='findGenes'>Finding coding genes</h2><span id='topic+findGenes'></span>

<h3>Description</h3>

<p>Finding coding genes in genomic DNA using the Prodigal software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findGenes(
  genome,
  prodigal.exe = "prodigal",
  faa.file = "",
  ffn.file = "",
  proc = "single",
  trans.tab = 11,
  mask.N = FALSE,
  bypass.SD = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findGenes_+3A_genome">genome</code></td>
<td>
<p>A table with columns Header and Sequence, containing the genome sequence(s).</p>
</td></tr>
<tr><td><code id="findGenes_+3A_prodigal.exe">prodigal.exe</code></td>
<td>
<p>Command to run the external software prodigal on the system (text).</p>
</td></tr>
<tr><td><code id="findGenes_+3A_faa.file">faa.file</code></td>
<td>
<p>If provided, prodigal will output all proteins to this fasta-file (text).</p>
</td></tr>
<tr><td><code id="findGenes_+3A_ffn.file">ffn.file</code></td>
<td>
<p>If provided, prodigal will output all DNA sequences to this fasta-file (text).</p>
</td></tr>
<tr><td><code id="findGenes_+3A_proc">proc</code></td>
<td>
<p>Either <code>"single"</code> or <code>"meta"</code>, see below.</p>
</td></tr>
<tr><td><code id="findGenes_+3A_trans.tab">trans.tab</code></td>
<td>
<p>Either 11 or 4 (see below).</p>
</td></tr>
<tr><td><code id="findGenes_+3A_mask.n">mask.N</code></td>
<td>
<p>Turn on masking of N's (logical)</p>
</td></tr>
<tr><td><code id="findGenes_+3A_bypass.sd">bypass.SD</code></td>
<td>
<p>Bypass Shine-Dalgarno filter (logical)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The external software Prodigal is used to scan through a prokaryotic genome to detect the protein
coding genes. The text in <code>prodigal.exe</code> must contain the exact command to invoke barrnap on the system.
</p>
<p>In addition to the standard output from this function, FASTA files with protein and/or DNA sequences may
be produced directly by providing filenames in <code>faa.file</code> and <code>ffn.file</code>.
</p>
<p>The input <code>proc</code> allows you to specify if the input data should be treated as a single genome
(default) or as a metagenome. In the latter case the <code>genome</code> are (un-binned) contigs.
</p>
<p>The translation table is by default 11 (the standard code), but table 4 should be used for Mycoplasma etc.
</p>
<p>The <code>mask.N</code> will prevent genes having runs of N inside. The <code>bypass.SD</code> turn off the search
for a Shine-Dalgarno motif.
</p>


<h3>Value</h3>

<p>A GFF-table (see <code><a href="#topic+readGFF">readGFF</a></code> for details) with one row for each detected
coding gene.
</p>


<h3>Note</h3>

<p>The prodigal software must be installed on the system for this function to work, i.e. the command
&lsquo;<span class="samp">&#8288;system("prodigal -h")&#8288;</span>&rsquo; must be recognized as a valid command if you run it in the Console window.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readGFF">readGFF</a></code>, <code><a href="#topic+gff2fasta">gff2fasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example requires the external prodigal software
# Using a genome file in this package.
genome.file &lt;- file.path(path.package("microseq"),"extdata","small.fna")

# Searching for coding sequences, this is Mycoplasma (trans.tab = 4)
genome &lt;- readFasta(genome.file)
gff.tbl &lt;- findGenes(genome, trans.tab = 4)

# Retrieving the sequences
cds.tbl &lt;- gff2fasta(gff.tbl, genome)

# You may use the pipe operator
library(ggplot2)
readFasta(genome.file) %&gt;% 
  findGenes(trans.tab = 4) %&gt;% 
  filter(Score &gt;= 50) %&gt;% 
  ggplot() +
  geom_histogram(aes(x = Score), bins = 25)

## End(Not run)

</code></pre>

<hr>
<h2 id='findOrfs'>Finding ORFs in genomes</h2><span id='topic+findOrfs'></span>

<h3>Description</h3>

<p>Finds all ORFs in prokaryotic genome sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOrfs(genome, circular = F, trans.tab = 11)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOrfs_+3A_genome">genome</code></td>
<td>
<p>A fasta object (<code>tibble</code>) with the genome sequence(s).</p>
</td></tr>
<tr><td><code id="findOrfs_+3A_circular">circular</code></td>
<td>
<p>Logical indicating if the genome sequences are completed, 
circular sequences.</p>
</td></tr>
<tr><td><code id="findOrfs_+3A_trans.tab">trans.tab</code></td>
<td>
<p>Translation table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A prokaryotic Open Reading Frame (ORF) is defined as a sub-sequence 
starting with a  start-codon (ATG, GTG or TTG), followed by an integer number
of triplets (codons), and ending with a stop-codon (TAA, TGA or TAG, unless 
<code>trans.tab = 4</code>, see below). This function will locate all such ORFs in
a genome.
</p>
<p>The argument <code>genome</code> is a fasta object, i.e. a table with columns 
&lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;, and will typically have several sequences
(chromosomes/plasmids/scaffolds/contigs). It is vital that the <em>first 
token</em> (characters before first space) of every &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; is
unique, since this will be used to identify these genome sequences in the
output.
</p>
<p>By default the genome sequences are assumed to be linear, i.e. contigs or
other incomplete fragments of a genome. In such cases there will usually be
some truncated ORFs at each end, i.e. ORFs where either the start- or the 
stop-codon is lacking. In the <code>orf.table</code> returned by this function this
is marked in the &lsquo;<span class="samp">&#8288;Attributes&#8288;</span>&rsquo; column. The texts &quot;Truncated=10&quot; or 
&quot;Truncated=01&quot; indicates truncated at the beginning or end of the genomic 
sequence, respectively. If the supplied <code>genome</code> is a completed genome,
with circular chromosome/plasmids, set the flag <code>circular = TRUE</code> and no
truncated ORFs will be listed. In cases where an ORF runs across the origin 
of a circular genome sequences, the stop coordinate will be larger than the 
length of the genome sequence. This is in line with the specifications of
the GFF3 format, where a &lsquo;<span class="samp">&#8288;Start&#8288;</span>&rsquo; cannot be larger than the
corresponding &lsquo;<span class="samp">&#8288;End&#8288;</span>&rsquo;.
</p>
<p>An alternative translation table may be specified, and as of now the only
alternative implemented is table 4. This means codon TGA is no longer a stop,
but codes for Tryptophan. This coding is used by some bacteria
(e.g. under the orders Entomoplasmatales and Mycoplasmatales).
</p>
<p>Note that for any given stop-codon there are usually multiple start-codons 
in the same reading frame. This function will return all such nested ORFs, 
i.e. the same stop position may appear multiple times. If you want ORFs with
the most upstream start-codon only (LORFs), then filter the output from this
function with <code><a href="#topic+lorfs">lorfs</a></code>.
</p>


<h3>Value</h3>

<p>This function returns an <code>orf.table</code>, which is simply a 
<code><a href="dplyr.html#topic+tibble">tibble</a></code> with columns adhering to the GFF3 format specifications
(a <code>gff.table</code>), see <code><a href="#topic+readGFF">readGFF</a></code>. If you want to retrieve
the actual ORF sequences, use <code><a href="#topic+gff2fasta">gff2fasta</a></code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readGFF">readGFF</a></code>, <code><a href="#topic+gff2fasta">gff2fasta</a></code>, <code><a href="#topic+lorfs">lorfs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a genome file in this package
genome.file &lt;- file.path(path.package("microseq"),"extdata","small.fna")

# Reading genome and finding orfs
genome &lt;- readFasta(genome.file)
orf.tbl &lt;- findOrfs(genome)

# Pipeline for finding LORFs of minimum length 100 amino acids
# and collecting their sequences from the genome
findOrfs(genome) %&gt;% 
 lorfs() %&gt;% 
 filter(orfLength(., aa = TRUE) &gt; 100) %&gt;% 
 gff2fasta(genome) -&gt; lorf.tbl

</code></pre>

<hr>
<h2 id='findrRNA'>Finding rRNA genes</h2><span id='topic+findrRNA'></span>

<h3>Description</h3>

<p>Finding rRNA genes in genomic DNA using the barrnap software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findrRNA(genome, barrnap.exe = "barrnap", bacteria = TRUE, cpu = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findrRNA_+3A_genome">genome</code></td>
<td>
<p>A table with columns Header and Sequence, containing the genome sequence(s).</p>
</td></tr>
<tr><td><code id="findrRNA_+3A_barrnap.exe">barrnap.exe</code></td>
<td>
<p>Command to run the external software barrnap on the system (text).</p>
</td></tr>
<tr><td><code id="findrRNA_+3A_bacteria">bacteria</code></td>
<td>
<p>Logical, the genome is either a bacteria (default) or an archea.</p>
</td></tr>
<tr><td><code id="findrRNA_+3A_cpu">cpu</code></td>
<td>
<p>Number of CPUs to use, default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The external software barrnap is used to scan through a prokaryotic genome to detect the
rRNA genes (5S, 16S, 23S).
The text in <code>barrnap.exe</code> must contain the exact command to invoke barrnap on the system.
</p>


<h3>Value</h3>

<p>A GFF-table (see <code><a href="#topic+readGFF">readGFF</a></code> for details) with one row for each detected
rRNA sequence.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readGFF">readGFF</a></code>, <code><a href="#topic+gff2fasta">gff2fasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This example requires the external barrnap software
# Using a genome file in this package.
genome.file &lt;- file.path(path.package("microseq"),"extdata","small.fna")

# Searching for rRNA sequences, and inspecting
genome &lt;- readFasta(genome.file)
gff.tbl &lt;- findrRNA(genome)
print(gff.table)

# Retrieving the sequences
rRNA &lt;- gff2fasta(gff.tbl, genome)

## End(Not run)

</code></pre>

<hr>
<h2 id='gff2fasta'>Retrieving annotated sequences</h2><span id='topic+gff2fasta'></span>

<h3>Description</h3>

<p>Retrieving from a genome the sequences specified in a <code>gff.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gff2fasta(gff.table, genome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gff2fasta_+3A_gff.table">gff.table</code></td>
<td>
<p>A <code>gff.table</code> (<code>tibble</code>) with genomic features information.</p>
</td></tr>
<tr><td><code id="gff2fasta_+3A_genome">genome</code></td>
<td>
<p>A fasta object (<code>tibble</code>) with the genome sequence(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row in <code>gff.table</code> (see <code><a href="#topic+readGFF">readGFF</a></code>) describes a genomic feature
in the <code>genome</code>, which is a <code><a href="dplyr.html#topic+tibble">tibble</a></code> with columns &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; and
&lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;. The information in the columns Seqid, Start, End and Strand are used to
retrieve the sequences from the &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo; column of <code>genome</code>. Every Seqid in
the <code>gff.table</code> must match the first token in one of the &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; texts, in
order to retrieve from the correct &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;.
</p>


<h3>Value</h3>

<p>A fasta object with one row for each row in <code>gff.table</code>. 
The <code>Header</code> for each sequence is a summary of the information in the
corresponding row of <code>gff.table</code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readGFF">readGFF</a></code>, <code><a href="#topic+findOrfs">findOrfs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using two files in this package
gff.file &lt;- file.path(path.package("microseq"),"extdata","small.gff")
genome.file &lt;- file.path(path.package("microseq"),"extdata","small.fna")

# Reading the genome first
genome &lt;- readFasta(genome.file)

# Retrieving sequences
gff.table &lt;- readGFF(gff.file)
fa.tbl &lt;- gff2fasta(gff.table, genome)

# Alternative, using piping
readGFF(gff.file) %&gt;% gff2fasta(genome) -&gt; fa.tbl

</code></pre>

<hr>
<h2 id='gregexpr'>Extended <code><a href="#topic+gregexpr">gregexpr</a></code> with substring retrieval</h2><span id='topic+gregexpr'></span>

<h3>Description</h3>

<p>An extension of the function <code>base::gregexpr</code> enabling retrieval of the 
matching substrings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gregexpr(
  pattern,
  text,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  extract = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gregexpr_+3A_pattern">pattern</code></td>
<td>
<p>Character string containing a <a href="base.html#topic+regular+20expression">regular expression</a> (or character string for 
<code>fixed = TRUE</code>) to be matched in the given character vector.  Coerced by <code><a href="base.html#topic+as.character">as.character</a></code> 
to a character string if possible.  If a character vector of length 2 or more is supplied, the first element
is used with a warning.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="gregexpr_+3A_text">text</code></td>
<td>
<p>A character vector where matches are sought, or an object which can be coerced by
<code><a href="base.html#topic+as.character">as.character</a></code> to a character vector.</p>
</td></tr>
<tr><td><code id="gregexpr_+3A_ignore.case">ignore.case</code></td>
<td>
<p>If <code>FALSE</code>, the pattern matching is <em>case sensitive</em> and if <code>TRUE</code>,
case is ignored during matching.</p>
</td></tr>
<tr><td><code id="gregexpr_+3A_perl">perl</code></td>
<td>
<p>Logical. Should perl-compatible regexps be used? Has priority over <code>extended</code>.</p>
</td></tr>
<tr><td><code id="gregexpr_+3A_fixed">fixed</code></td>
<td>
<p>Logical. If <code>TRUE</code>, &lsquo;<span class="samp">&#8288;pattern&#8288;</span>&rsquo; is a string to be matched as is. Overrides 
all conflicting arguments.</p>
</td></tr>
<tr><td><code id="gregexpr_+3A_usebytes">useBytes</code></td>
<td>
<p>Logical. If <code>TRUE</code> the matching is done byte-by-byte rather than character-by-character.
See <code><a href="base.html#topic+grep">grep</a></code> for details.</p>
</td></tr>
<tr><td><code id="gregexpr_+3A_extract">extract</code></td>
<td>
<p>Logical indicating if matching substrings should be extracted and returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extended version of <code>base:gregexpr</code> that enables the return of the substrings matching
the pattern. The last argument &lsquo;<span class="samp">&#8288;extract&#8288;</span>&rsquo; is the only difference to <code>base::gregexpr</code>. The default
behaviour is identical to <code>base::gregexpr</code>, but setting <code>extract=TRUE</code> means the matching substrings
are returned.
</p>


<h3>Value</h3>

<p>It will either return what the <code>base::gregexpr</code> would (<code>extract = FALSE</code>) or a &lsquo;<span class="samp">&#8288;list&#8288;</span>&rsquo;
of substrings matching the pattern (<code>extract = TRUE</code>). There is one &lsquo;<span class="samp">&#8288;list&#8288;</span>&rsquo; element for each string in
&lsquo;<span class="samp">&#8288;text&#8288;</span>&rsquo;, and each list element contains a character vector of all matching substrings in the corresponding
entry of &lsquo;<span class="samp">&#8288;text&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Liland.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequences &lt;- c("ACATGTCATGTCC", "CTTGTATGCTG")
gregexpr("ATG", sequences, extract = TRUE)

</code></pre>

<hr>
<h2 id='iupac2regex'>Ambiguity symbol conversion</h2><span id='topic+iupac2regex'></span><span id='topic+regex2iupac'></span>

<h3>Description</h3>

<p>Converting DNA ambiguity symbols to regular expressions, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iupac2regex(sequence)
regex2iupac(sequence)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iupac2regex_+3A_sequence">sequence</code></td>
<td>
<p>Character vector containing DNA sequences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The DNA alphabet may contain ambiguity symbols, e.g. a W means either A or T.
When using a regular expression search, these letters must be replaced by the proper
regular expression, e.g. W is replaced by [AT] in the string. The <code>iupac2regex</code> makes this
translation, while <code>regex2iupac</code> converts the other way again (replace [AT] with W).
</p>


<h3>Value</h3>

<p>A string where the ambiguity symbol has been replaced by a regular expression
(<code>iupac2regex</code>) or a regular expression has been replaced by an ambiguity symbol
(<code>regex2iupac</code>).
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>iupac2regex("ACWGT")
regex2iupac("AC[AG]GT")

</code></pre>

<hr>
<h2 id='lorfs'>Longest ORF</h2><span id='topic+lorfs'></span>

<h3>Description</h3>

<p>Filtering an <code>orf.table</code> with ORF information to keep only the LORFs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorfs(orf.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorfs_+3A_orf.tbl">orf.tbl</code></td>
<td>
<p>A <code>tibble</code> with the nine columns of the GFF-format (see <code><a href="#topic+findOrfs">findOrfs</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every stop-codon there are usually multiple possible start-codons in the same reading
frame (nested ORFs). The LORF (Longest ORF) is defined as the longest of these nested ORFs,
i.e. the ORF starting at the most upstream start-codon matching the stop-codon.
</p>


<h3>Value</h3>

<p>A <code><a href="dplyr.html#topic+tibble">tibble</a></code> with a subset of the rows of the argument <code>orf.tbl</code>. 
After this filtering the Type variable in <code>orf.tbl</code> is changed to <code>"LORF"</code>. If you want to
retrieve the LORF sequences, use <code><a href="#topic+gff2fasta">gff2fasta</a></code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readGFF">readGFF</a></code>, <code><a href="#topic+findOrfs">findOrfs</a></code>, <code><a href="#topic+gff2fasta">gff2fasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the example in the Help-file for findOrfs.

</code></pre>

<hr>
<h2 id='microseq-package'>Basic Biological Sequence Analysis</h2><span id='topic+microseq-package'></span><span id='topic+microseq'></span>

<h3>Description</h3>

<p>A collection of functions for basic analysis of microbial sequence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microseq()
</code></pre>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> microseq</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Lars Snipen, Kristian Hovde Liland<br />
Maintainer: Lars Snipen &lt;lars.snipen@nmbu.no&gt;
</p>

<hr>
<h2 id='msa2mat'>Convert alignment to matrix</h2><span id='topic+msa2mat'></span>

<h3>Description</h3>

<p>Converts a FASTA formatted multiple alignment to a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msa2mat(msa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msa2mat_+3A_msa">msa</code></td>
<td>
<p>A fasta object with a multiple alignment, see <code><a href="#topic+msalign">msalign</a></code>'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the fasta object <code>msa</code>, containing a multiple alignment,
to a matrix. This means each position in the alignment is a column in the matrix, and the
content of the &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; column of <code>msa</code> is used as rownames of theh matrix.
</p>
<p>Such a matrix is useful for conversion to a <code>DNAbin</code> object that is used by the <code>ape</code>
package for re-constructing phylogenetic trees.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> where each row is a vector of aligned bases/amino acids.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msalign">msalign</a></code>, <code><a href="#topic+readFasta">readFasta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msa.file &lt;- file.path(path.package("microseq"),"extdata", "small.msa")
msa &lt;- readFasta(msa.file)
msa.mat &lt;- msa2mat(msa)  # to use with ape::as.DNAbin(msa.mat)

</code></pre>

<hr>
<h2 id='msalign'>Multiple alignment</h2><span id='topic+msalign'></span>

<h3>Description</h3>

<p>Quickly computing a smallish multiple sequence alignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msalign(fsa.tbl, machine = "microseq::muscle")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msalign_+3A_fsa.tbl">fsa.tbl</code></td>
<td>
<p>A fasta object (<code>tibble</code>) with input sequences.</p>
</td></tr>
<tr><td><code id="msalign_+3A_machine">machine</code></td>
<td>
<p>Function that does the 'dirty work'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a multiple sequence alignment given a set of sequences in
a fasta object, see <code><a href="#topic+readFasta">readFasta</a></code> for more on fasta objects.
</p>
<p>It is merely a wrapper for the function named in <code>machine</code> to avoid explicit writing
and reading of files. This function should only be used for small data sets, since no result
files are stored. For heavier jobs, use the <code>machine</code> function directly.
</p>
<p>At present, the only <code>machine</code> function implemented is <code><a href="#topic+muscle">muscle</a></code>, but other
third-party <code>machine</code>s may be included later.
</p>
<p>Note that this function will run <code><a href="#topic+muscle">muscle</a></code> with default settings, which is fine
for small data sets.
</p>


<h3>Value</h3>

<p>Results are returned as a fasta object, i.e. a <code><a href="dplyr.html#topic+tibble">tibble</a></code> with columns
&lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muscle">muscle</a></code>, <code><a href="#topic+msaTrim">msaTrim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
prot.file &lt;- file.path(file.path(path.package("microseq"),"extdata"),"small.faa")
faa &lt;- readFasta(prot.file)
msa &lt;- msalign(faa)

## End(Not run)

</code></pre>

<hr>
<h2 id='msaTrim'>Trimming multiple sequence alignments</h2><span id='topic+msaTrim'></span>

<h3>Description</h3>

<p>Trimming a multiple sequence alignment by discarding columns with too many gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msaTrim(msa, gap.end = 0.5, gap.mid = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msaTrim_+3A_msa">msa</code></td>
<td>
<p>A fasta object containing a multiple alignment.</p>
</td></tr>
<tr><td><code id="msaTrim_+3A_gap.end">gap.end</code></td>
<td>
<p>Fraction of gaps tolerated at the ends of the alignment (0-1).</p>
</td></tr>
<tr><td><code id="msaTrim_+3A_gap.mid">gap.mid</code></td>
<td>
<p>Fraction of gaps tolerated inside the alignment (0-1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multiple alignment is trimmed by removing columns with too many indels (gap-symbols). Any 
columns containing a fraction of gaps larger than <code>gap.mid</code> are discarded. For this reason, <code>gap.mid</code>
should always be farily close to 1.0 therwise too many columns may be discarded, destroying the alignment.
</p>
<p>Due to the heuristics of multiple alignment methods, both ends of the alignment tend to be uncertain and most
of the trimming should be done at the ends. Starting at each end, columns are discarded as long as their fraction of gaps
surpasses <code>gap.end</code>. Typically <code>gap.end</code> can be much smaller than <code>gap.mid</code>, but if 
set too low you risk that all columns are discarded!
</p>


<h3>Value</h3>

<p>The trimmed alignment is returned as a fasta object.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+muscle">muscle</a></code>, <code><a href="#topic+msalign">msalign</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>msa.file &lt;- file.path(path.package("microseq"),"extdata", "small.msa")
msa &lt;- readFasta(msa.file)
print(str_length(msa$Sequence))
msa.trimmed &lt;- msaTrim(msa)
print(str_length(msa.trimmed$Sequence))
msa.mat &lt;- msa2mat(msa)  # for use with ape::as.DNAbin(msa.mat)

</code></pre>

<hr>
<h2 id='muscle'>Multiple alignment using MUSCLE</h2><span id='topic+muscle'></span>

<h3>Description</h3>

<p>Computing a multiple sequence alignment using the MUSCLE software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muscle(
  in.file,
  out.file,
  muscle.exe = "muscle",
  quiet = FALSE,
  diags = FALSE,
  maxiters = 16
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muscle_+3A_in.file">in.file</code></td>
<td>
<p>Name of FASTA file with input sequences.</p>
</td></tr>
<tr><td><code id="muscle_+3A_out.file">out.file</code></td>
<td>
<p>Name of file to store the result.</p>
</td></tr>
<tr><td><code id="muscle_+3A_muscle.exe">muscle.exe</code></td>
<td>
<p>Command to run the external software muscle on the system (text).</p>
</td></tr>
<tr><td><code id="muscle_+3A_quiet">quiet</code></td>
<td>
<p>Logical, <code>quiet = FALSE</code> produces screen output during computations.</p>
</td></tr>
<tr><td><code id="muscle_+3A_diags">diags</code></td>
<td>
<p>Logical, <code>diags = TRUE</code> gives faster but less reliable alignment.</p>
</td></tr>
<tr><td><code id="muscle_+3A_maxiters">maxiters</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The software MUSCLE (Edgar, 2004) must be installed and available on the system. The text in
<code>muscle.exe</code> must contain the exact command to invoke muscle on the system.
</p>
<p>By default <code>diags = FALSE</code> but can be set to <code>TRUE</code> to increase speed. This should be done
only if sequences are highly similar.
</p>
<p>By default <code>maxiters = 16</code>. If you have a large number of sequences (a few thousand), or they are 
very long, then this may be too slow for practical use. A good compromise between speed and accuracy
is to run just the first two iterations of the algorithm. On average, this gives accuracy equal to
T-Coffee and speeds much faster than CLUSTALW. This is done by the option <code>maxiters = 2</code>.
</p>


<h3>Value</h3>

<p>The result is written to the file specified in <code>out.file</code>.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>References</h3>

<p>Edgar, R.C. (2004). MUSCLE: multiple sequence alignment with high accuracy and high 
throughput, Nucleic Acids Res, 32, 1792-1797.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msaTrim">msaTrim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fa.file &lt;- file.path(file.path(path.package("microseq"),"extdata"),"small.faa")
muscle(in.file = fa.file, out.file = "delete_me.msa")

## End(Not run)

</code></pre>

<hr>
<h2 id='orfLength'>Length of ORF</h2><span id='topic+orfLength'></span>

<h3>Description</h3>

<p>Computing the lengths of all ORFs in an <code>orf.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orfLength(orf.table, aa = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orfLength_+3A_orf.table">orf.table</code></td>
<td>
<p>A GFF-formatted <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="orfLength_+3A_aa">aa</code></td>
<td>
<p>Logical, length in amino acids instead of bases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, computes the length of an ORF in bases, including the
stop codon. However, if <code>aa = TRUE</code>, then the length is in amino acids
after translation. This aa-length is the base-length divided by 3 and minus 
1, unless the ORF is truncated and lacks a stop codon.
</p>


<h3>Value</h3>

<p>A vector of lengths.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findOrfs">findOrfs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the example in the Help-file for findOrfs.

</code></pre>

<hr>
<h2 id='orfSignature'>Signature for each ORF</h2><span id='topic+orfSignature'></span>

<h3>Description</h3>

<p>Creates a signature text for orfs in an <code>orf.table</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orfSignature(orf.table, full = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orfSignature_+3A_orf.table">orf.table</code></td>
<td>
<p>A <code>tibble</code> with ORF information.</p>
</td></tr>
<tr><td><code id="orfSignature_+3A_full">full</code></td>
<td>
<p>Logical indicating type of signature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A signature is a text that uniquely identifies each ORF in an
<code>orf.table</code>, which is a GFF-table with columns <code>Seqid</code>, <code>Start</code>,
<code>End</code> and <code>Strand</code>.
</p>
<p>The full signature (<code>full = TRUE</code>) contains the <code>Seqid</code>, <code>Start</code>,
<code>End</code> and <code>Strand</code> information for each ORF, separated by 
semicolon <code>";"</code>. This text is always unique 
to each ORF. If <code>full = FALSE</code> the <code>Signature</code> will not contain 
the starting position information for each ORF. This means all nested ORFs ending 
at the same stop-codon will then get identical <code>Signature</code>s. This is 
useful for identifying which ORFs are nested within the same LORF.
</p>
<p>Note that the signature you get with <code>full = FALSE</code> contains <code>Seqid</code>, 
then <code>End</code> if on the positive <code>Strand</code>, <code>Start</code> otherwise, and then
the <code>Strand</code>.
</p>


<h3>Value</h3>

<p>A text vector with the <code>Signature</code> for each ORF.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findOrfs">findOrfs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a genome file in this package
genome.file &lt;- file.path(path.package("microseq"),"extdata","small.fna")

# Reading genome and finding orfs
genome &lt;- readFasta(genome.file)
orf.tbl &lt;- findOrfs(genome)

# Compute signatures
signature.full &lt;- orfSignature(orf.tbl)
signature.reduced &lt;- orfSignature(orf.tbl, full = FALSE)

</code></pre>

<hr>
<h2 id='readFasta'>Read and write FASTA files</h2><span id='topic+readFasta'></span><span id='topic+writeFasta'></span>

<h3>Description</h3>

<p>Reads and writes biological sequences (DNA, RNA, protein) in the FASTA format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFasta(in.file)
writeFasta(fdta, out.file, width = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFasta_+3A_in.file">in.file</code></td>
<td>
<p>url/directory/name of (gzipped) FASTA file to read.</p>
</td></tr>
<tr><td><code id="readFasta_+3A_fdta">fdta</code></td>
<td>
<p>A <code><a href="dplyr.html#topic+tibble">tibble</a></code> with sequence data, see &lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="readFasta_+3A_out.file">out.file</code></td>
<td>
<p>Name of (gzipped) FASTA file to create.</p>
</td></tr>
<tr><td><code id="readFasta_+3A_width">width</code></td>
<td>
<p>Number of characters per line, or 0 for no linebreaks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions handle input/output of sequences in the commonly used FASTA format.
For every sequence it is presumed there is one Header-line starting with a &lsquo;&gt;&rsquo;. If
filenames (<code>in.file</code> or <code>out.file</code>) have the extension <code>.gz</code> they will automatically be
compressed/uncompressed.
</p>
<p>The sequences are stored in a <code><a href="dplyr.html#topic+tibble">tibble</a></code>, opening up all the possibilities in R for
fast and easy manipulations. The content of the file is stored as two columns, &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo;
and &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;. If other columns are added, these will be ignored by <code><a href="#topic+writeFasta">writeFasta</a></code>.
</p>
<p>The default <code>width = 0</code> in <code><a href="#topic+writeFasta">writeFasta</a></code> results in no linebreaks in the sequences
(one sequence per line).
</p>


<h3>Value</h3>

<p><code><a href="#topic+readFasta">readFasta</a></code> returns a <code><a href="dplyr.html#topic+tibble">tibble</a></code> with the contents of the (gzipped) FASTA
file stored in two columns of text. The first, named &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo;, contains
the headerlines and the second, named &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;, contains the sequences.
</p>
<p><code><a href="#topic+writeFasta">writeFasta</a></code> produces a (gzipped) FASTA file.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readFastq">readFastq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# We need a FASTA-file to read, here is one example file:
fa.file &lt;- file.path(file.path(path.package("microseq"),"extdata"),"small.ffn")

# Read and write
fdta &lt;- readFasta(fa.file)
ok &lt;- writeFasta(fdta[4:5,], out.file = "delete_me.fasta")

# Make use of dplyr to copy parts of the file to another file
readFasta(fa.file) %&gt;% 
  filter(str_detect(Sequence, "TGA$")) %&gt;% 
  writeFasta(out.file = "TGAstop.fasta", width = 80) -&gt; ok

## End(Not run)

</code></pre>

<hr>
<h2 id='readFastq'>Read and write FASTQ files</h2><span id='topic+readFastq'></span><span id='topic+writeFastq'></span>

<h3>Description</h3>

<p>Reads and writes files in the FASTQ format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFastq(in.file)
writeFastq(fdta, out.file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFastq_+3A_in.file">in.file</code></td>
<td>
<p>url/directory/name of (gzipped) FASTQ file to read.</p>
</td></tr>
<tr><td><code id="readFastq_+3A_fdta">fdta</code></td>
<td>
<p>FASTQ object to write.</p>
</td></tr>
<tr><td><code id="readFastq_+3A_out.file">out.file</code></td>
<td>
<p>url/directory/name of (gzipped) FASTQ file to write.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions handle input/output of sequences in the commonly used FASTQ format,
typically used for storing DNA sequences (reads) after sequencing. If
filenames (<code>in.file</code> or <code>out.file</code>) have the extension <code>.gz</code> they will automatically be
compressed/uncompressed. 
</p>
<p>The sequences are stored in a <code><a href="dplyr.html#topic+tibble">tibble</a></code>, opening up all the possibilities in R for
fast and easy manipulations. The content of the file is stored as three columns, &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo;,
&lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;Quality&#8288;</span>&rsquo;. If other columns are added, these will be ignored by
<code><a href="#topic+writeFastq">writeFastq</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+readFastq">readFastq</a></code> returns a <code><a href="dplyr.html#topic+tibble">tibble</a></code> with the contents of the (gzipped) FASTQ
file stored in three columns of text. The first, named &lsquo;<span class="samp">&#8288;Header&#8288;</span>&rsquo;, contains
the headerlines, the second, named &lsquo;<span class="samp">&#8288;Sequence&#8288;</span>&rsquo;, contains the sequences and the third, named 
&lsquo;<span class="samp">&#8288;Quality&#8288;</span>&rsquo; contains the base quality scores.
</p>
<p><code><a href="#topic+writeFastq">writeFastq</a></code> produces a (gzipped) FASTQ file.
</p>


<h3>Note</h3>

<p>These functions will only handle files where each entry spans one single line, i.e. not the
(uncommon) multiline FASTQ format.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p>code<a href="#topic+readFasta">readFasta</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# We need a FASTQ-file to read, here is one example file:
fq.file &lt;- file.path(file.path(path.package("microseq"),"extdata"),"small.fastq.gz")

# Read and write
fdta &lt;- readFastq(fq.file)
ok &lt;- writeFastq(fdta[1:3,], out.file = "delete_me.fq")

# Make use of dplyr to copy parts of the file to another file
readFastq(fq.file) %&gt;% 
  mutate(Length = str_length(Sequence)) %&gt;% 
  filter(Length &gt; 200) %&gt;% 
  writeFasta(out.file = "long_reads.fa") # writing to FASTA file

## End(Not run)

</code></pre>

<hr>
<h2 id='readGFF'>Reading and writing GFF-tables</h2><span id='topic+readGFF'></span><span id='topic+writeGFF'></span>

<h3>Description</h3>

<p>Reading or writing a GFF-table from/to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readGFF(in.file)
writeGFF(gff.table, out.file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readGFF_+3A_in.file">in.file</code></td>
<td>
<p>Name of file with a GFF-table.</p>
</td></tr>
<tr><td><code id="readGFF_+3A_gff.table">gff.table</code></td>
<td>
<p>A table (<code>tibble</code>) with genomic features information.</p>
</td></tr>
<tr><td><code id="readGFF_+3A_out.file">out.file</code></td>
<td>
<p>Name of file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GFF-table is simply a <code><a href="dplyr.html#topic+tibble">tibble</a></code> with columns
adhering to the format specified by the GFF3 format, see
https://github.com/The-Sequence-Ontology/Specifications/blob/master/gff3.md for details. There is
one row for each feature.
</p>
<p>The following columns should always be in a full <code>gff.table</code> of the GFF3 format:
</p>

<ul>
<li><p> Seqid. A unique identifier of the genomic sequence on which the feature resides.
</p>
</li>
<li><p> Source. A description of the procedure that generated the feature, e.g. <code>"R-package micropan::findOrfs"</code>.
</p>
</li>
<li><p> Type The type of feature, e.g. <code>"ORF"</code>, <code>"16S"</code> etc.
</p>
</li>
<li><p> Start. The leftmost coordinate. This is the start if the feature is on the Sense strand, but
the end if it is on the Antisense strand.
</p>
</li>
<li><p> End. The rightmost coordinate. This is the end if the feature is on the Sense strand, but
the start if it is on the Antisense strand.
</p>
</li>
<li><p> Score. A numeric score (E-value, P-value) from the <code>Source</code>. 
</p>
</li>
<li><p> Strand. A <code>"+"</code> indicates Sense strand, a <code>"-"</code> Antisense.
</p>
</li>
<li><p> Phase. Only relevant for coding genes. the values 0, 1 or 2 indicates the reading frame, i.e. 
the number of bases to offset the <code>Start</code> in order to be in the reading frame.
</p>
</li>
<li><p> Attributes. A single string with semicolon-separated tokens prociding additional information.
</p>
</li></ul>

<p>Missing values are described by <code>"."</code> in the GFF3 format. This is also done here, except for the
numerical columns Start, End, Score and Phase. Here <code>NA</code> is used, but this is replaced by
<code>"."</code> when writing to file.
</p>
<p>The <code>readGFF</code> function will also read files where sequences in FASTA format are added after
the GFF-table. This file section must always start with the line <code>##FASTA</code>. This fasta object
is added to the GFF-table as an attribute (use <code>attr(gff.tbl, "FASTA")</code> to retrieve it).
</p>


<h3>Value</h3>

<p><code>readGFF</code> returns a <code>gff.table</code> with the columns described above.
</p>
<p><code>writeGFF</code> writes the supplied <code>gff.table</code> to a text-file.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+findOrfs">findOrfs</a></code>, <code><a href="#topic+lorfs">lorfs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Using a GFF file in this package
gff.file &lt;- file.path(path.package("microseq"),"extdata","small.gff")

# Reading gff-file
gff.tbl &lt;- readGFF(gff.file)

</code></pre>

<hr>
<h2 id='reverseComplement'>Reverse-complementation of DNA</h2><span id='topic+reverseComplement'></span>

<h3>Description</h3>

<p>The standard reverse-complement of nucleotide sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverseComplement(nuc.sequences, reverse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverseComplement_+3A_nuc.sequences">nuc.sequences</code></td>
<td>
<p>Character vector containing the nucleotide sequences.</p>
</td></tr>
<tr><td><code id="reverseComplement_+3A_reverse">reverse</code></td>
<td>
<p>Logical indicating if complement should be reversed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With &lsquo;<span class="samp">&#8288;reverse = FALSE&#8288;</span>&rsquo; the DNA sequence is only complemented, not reversed.
</p>
<p>This function will handle the IUPAC ambiguity symbols, i.e. &lsquo;<span class="samp">&#8288;R&#8288;</span>&rsquo; is
reverse-complemented to &lsquo;<span class="samp">&#8288;Y&#8288;</span>&rsquo; etc.
</p>


<h3>Value</h3>

<p>A character vector of reverse-complemented sequences.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iupac2regex">iupac2regex</a></code>, <code><a href="#topic+regex2iupac">regex2iupac</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fa.file &lt;- file.path(file.path(path.package("microseq"),"extdata"),"small.ffn")
fa &lt;- readFasta(fa.file)
reverseComplement(fa$Sequence)

#' # Or, make use of dplyr to manipulate tables
readFasta(fa.file) %&gt;%
  mutate(RevComp = reverseComplement(Sequence)) -&gt; fa.tbl

</code></pre>

<hr>
<h2 id='translate'>Translation according to the standard genetic code</h2><span id='topic+translate'></span>

<h3>Description</h3>

<p>The translation from DNA(RNA) to amino acid sequence according to the standard genetic code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translate(nuc.sequences, M.start = TRUE, no.stop = TRUE, trans.tab = 11)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="translate_+3A_nuc.sequences">nuc.sequences</code></td>
<td>
<p>Character vector containing the nucleotide sequences.</p>
</td></tr>
<tr><td><code id="translate_+3A_m.start">M.start</code></td>
<td>
<p>A logical indicating if the amino acid sequence should start with M regardless of start codon.</p>
</td></tr>
<tr><td><code id="translate_+3A_no.stop">no.stop</code></td>
<td>
<p>A logical indicating if terminal stops (*) should be eliminated from the translated sequence</p>
</td></tr>
<tr><td><code id="translate_+3A_trans.tab">trans.tab</code></td>
<td>
<p>Translation table, either 11 or 4</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Codons are by default translated according to translation table 11, i.e. the possible start codons
are ATG, GTG or TTG and stop codons are TAA, TGA and TAG.  The only alternative implemented here is
translation table 4, which is used by some bacteria (e.g. Mycoplasma, Mesoplasma). If <code>trans.tab</code> is 4,
the stop codon TGA istranslated to W (Tryptophan).
</p>


<h3>Value</h3>

<p>A character vector of translated sequences.
</p>


<h3>Author(s)</h3>

<p>Lars Snipen and Kristian Hovde Liland.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fa.file &lt;- file.path(file.path(path.package("microseq"),"extdata"),"small.ffn")
fa &lt;- readFasta(fa.file)
translate(fa$Sequence)

# Or, make use of dplyr to manipulate tables
readFasta(fa.file) %&gt;%
  mutate(Protein = translate(Sequence)) -&gt; fa.tbl

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
