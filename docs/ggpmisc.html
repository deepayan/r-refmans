<!DOCTYPE html><html><head><title>Help for package ggpmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggpmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggpmisc-package'><p>ggpmisc: Miscellaneous Extensions to 'ggplot2'</p></a></li>
<li><a href='#coef.lmodel2'><p>Extract Model Coefficients</p></a></li>
<li><a href='#confint.lmodel2'><p>Confidence Intervals for Model Parameters</p></a></li>
<li><a href='#cor_test_compute_fun'><p><code>Stat*</code> Objects</p></a></li>
<li><a href='#fail_safe_formula'><p>Safely extract the formula from an object</p></a></li>
<li><a href='#FC_format'><p>Formatter for fold change tick labels</p></a></li>
<li><a href='#FC_name'><p>Fold change- axis labels</p></a></li>
<li><a href='#find_peaks'><p>Find local maxima or global maximum (peaks)</p></a></li>
<li><a href='#keep_tidy'><p>Tidy, glance or augment an object keeping a trace of its origin</p></a></li>
<li><a href='#Moved'><p>Moved to package 'gginnards'</p></a></li>
<li><a href='#outcome2factor'><p>Convert numeric ternary outcomes into a factor</p></a></li>
<li><a href='#predict.lmodel2'><p>Model Predictions</p></a></li>
<li><a href='#reverselog_trans'><p>Reverse log transformation</p></a></li>
<li><a href='#scale_colour_logFC'><p>Colour and fill scales for log fold change data</p></a></li>
<li><a href='#scale_colour_outcome'><p>Colour and fill scales for ternary outcomes</p></a></li>
<li><a href='#scale_shape_outcome'><p>Shape scale for ternary outcomes</p></a></li>
<li><a href='#scale_x_logFC'><p>Position scales for log fold change data</p></a></li>
<li><a href='#scale_y_Pvalue'><p>Convenience scale for P-values</p></a></li>
<li><a href='#stat_correlation'><p>Annotate plot with correlation test</p></a></li>
<li><a href='#stat_fit_augment'><p>Augment data with fitted values and statistics</p></a></li>
<li><a href='#stat_fit_deviations'><p>Residuals from model fit as segments</p></a></li>
<li><a href='#stat_fit_glance'><p>One row summary data frame for a fitted model</p></a></li>
<li><a href='#stat_fit_residuals'><p>Residuals from a model fit</p></a></li>
<li><a href='#stat_fit_tb'><p>Model-fit summary or ANOVA</p></a></li>
<li><a href='#stat_fit_tidy'><p>One row data frame with fitted parameter estimates</p></a></li>
<li><a href='#stat_ma_eq'><p>Equation, p-value, R^2 of major axis regression</p></a></li>
<li><a href='#stat_ma_line'><p>Predicted line from major axis linear fit</p></a></li>
<li><a href='#stat_multcomp'><p>Labels for multiple comparisons</p></a></li>
<li><a href='#stat_peaks'><p>Local maxima (peaks) or minima (valleys)</p></a></li>
<li><a href='#stat_poly_eq'><p>Equation, p-value, <code class="reqn">R^2</code>, AIC and BIC of fitted polynomial</p></a></li>
<li><a href='#stat_poly_line'><p>Predicted line from linear model fit</p></a></li>
<li><a href='#stat_quant_band'><p>Predicted band from quantile regression fits</p></a></li>
<li><a href='#stat_quant_eq'><p>Equation, rho, AIC and BIC from quantile regression</p></a></li>
<li><a href='#stat_quant_line'><p>Predicted line from quantile regression fit</p></a></li>
<li><a href='#swap_xy'><p>Swap x and y in a formula</p></a></li>
<li><a href='#symmetric_limits'><p>Expand a range to make it symmetric</p></a></li>
<li><a href='#use_label'><p>Assemble label and map it</p></a></li>
<li><a href='#xy_outcomes2factor'><p>Convert two numeric ternary outcomes into a factor</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Miscellaneous Extensions to 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pedro J. Aphalo &lt;pedro.aphalo@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extensions to 'ggplot2' respecting the grammar of graphics
    paradigm. Statistics: locate and tag peaks and valleys; label plot with the
    equation of a fitted polynomial or other types of models; labels
    with P-value, R^2 or adjusted R^2 or information criteria for fitted models;
    label with ANOVA table for fitted models; label with summary for fitted
    models. Model fit classes for which suitable methods are provided by package
    'broom' and 'broom.mixed' are supported. Scales and stats to build volcano
    and quadrant plots based on outcomes, fold changes, p-values and false 
    discovery rates.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>TRUE</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), ggpp (&ge; 0.5.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, stats, ggplot2 (&ge; 3.4.0), scales (&ge; 1.2.0), rlang (&ge;
1.0.0), generics (&ge; 0.1.2), MASS (&ge; 7.3-51.6), confintr (&ge;
0.1.2), polynom (&ge; 1.4-0), quantreg (&ge; 5.93), lmodel2 (&ge;
1.7-3), splus2R (&ge; 1.3-3), multcomp (&ge; 1.4-25), multcompView
(&ge; 0.1-9), tibble (&ge; 3.1.5), plyr (&ge; 1.8.6), dplyr (&ge;
1.0.6), lubridate (&ge; 1.7.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.39), rmarkdown (&ge; 2.14), ggrepel (&ge; 0.9.2),
broom (&ge; 0.8.0), broom.mixed (&ge; 0.2.9.4), nlme (&ge; 3.1-152),
gginnards (&ge; 0.1.0-1), testthat, vdiffr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.r4photobiology.info/ggpmisc/">https://docs.r4photobiology.info/ggpmisc/</a>,
<a href="https://github.com/aphalo/ggpmisc">https://github.com/aphalo/ggpmisc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aphalo/ggpmisc/issues">https://github.com/aphalo/ggpmisc/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-14 23:32:24 UTC; aphalo</td>
</tr>
<tr>
<td>Author:</td>
<td>Pedro J. Aphalo <a href="https://orcid.org/0000-0003-3385-972X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kamil Slowikowski <a href="https://orcid.org/0000-0002-2843-6370"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Samer Mouksassi <a href="https://orcid.org/0000-0002-7152-6654"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-15 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggpmisc-package'>ggpmisc: Miscellaneous Extensions to 'ggplot2'</h2><span id='topic+ggpmisc'></span><span id='topic+ggpmisc-package'></span>

<h3>Description</h3>

<p>Extensions to 'ggplot2' respecting the grammar of graphics paradigm. Statistics: locate and tag peaks and valleys; label plot with the equation of a fitted polynomial or other types of models; labels with P-value, R^2 or adjusted R^2 or information criteria for fitted models; label with ANOVA table for fitted models; label with summary for fitted models. Model fit classes for which suitable methods are provided by package 'broom' and 'broom.mixed' are supported. Scales and stats to build volcano and quadrant plots based on outcomes, fold changes, p-values and false discovery rates.
</p>


<h3>Details</h3>

<p>The new facilities for cleanly defining new stats and geoms added to
'ggplot2' in version 2.0.0 and the support for nested tibbles and new syntax
for mapping computed values to aesthetics added to
'ggplot2' in version 3.0.0 are used in this package's code, as well as some
features added in more recent updates. This
means that current 'ggpmisc' versions require recent versions of ggplot2.
</p>
<p>Extensions provided:
</p>

<ul>
<li><p> Function for conversion of time series data into tibbles that can be
plotted with ggplot.
</p>
</li>
<li> <p><code>ggplot()</code> method for time series data.
</p>
</li>
<li><p> Stats for locating and tagging &quot;peaks&quot; and &quot;valleys&quot; (local or global
maxima and minima).
</p>
</li>
<li><p> Stat for generating labels from model fit objects, including
formatted equations. By default labels are R's plotmath expressions but LaTeX, markdown
and plain text formatted labels are optionaly assembled.
</p>
</li>
<li><p> Stats for extracting information from a any model fit supported by
package 'broom' and using it to generate various annotations and data labels.
</p>
</li>
<li><p> Stat for computing and generating labels for the results from multiple
comparisons, including adjusted <em>P</em>-values.</p>
</li></ul>

<p>The stats for peaks and valleys are coded so as to work correctly both with
numeric and POSIXct variables mapped to the x aesthetic. Special handling was
needed as text labels are generated from the data.
</p>


<h3>Note</h3>

<p>The signatures of <code>stat_peaks()</code> and <code>stat_valleys()</code> from
'ggpmisc' are identical to those of <code>stat_peaks</code> and
<code>stat_valleys</code> from package 'ggspectra' but the variables returned are
a subset as special handling of values related to light spectra is missing.
Furthermore the <code>stat_peaks()</code> and <code>stat_valleys()</code> from package
'ggpmisc' work correctly when date or datetime values are mapped to the
<em>x</em> statistic, while those from package 'ggspectra' do not generate
correct labels in this case.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pedro J. Aphalo <a href="mailto:pedro.aphalo@helsinki.fi">pedro.aphalo@helsinki.fi</a> (<a href="https://orcid.org/0000-0003-3385-972X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kamil Slowikowski (<a href="https://orcid.org/0000-0002-2843-6370">ORCID</a>) [contributor]
</p>
</li>
<li><p> Samer Mouksassi <a href="mailto:samermouksassi@gmail.com">samermouksassi@gmail.com</a> (<a href="https://orcid.org/0000-0002-7152-6654">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Package suite 'r4photobiology' web site at
<a href="https://www.r4photobiology.info/">https://www.r4photobiology.info/</a><br /> Package 'ggplot2' documentation at
<a href="https://ggplot2.tidyverse.org/">https://ggplot2.tidyverse.org/</a><br /> Package 'ggplot2' source code at
<a href="https://github.com/tidyverse/ggplot2">https://github.com/tidyverse/ggplot2</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.r4photobiology.info/ggpmisc/">https://docs.r4photobiology.info/ggpmisc/</a>
</p>
</li>
<li> <p><a href="https://github.com/aphalo/ggpmisc">https://github.com/aphalo/ggpmisc</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/aphalo/ggpmisc/issues">https://github.com/aphalo/ggpmisc/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

ggplot(lynx, as.numeric = FALSE) + geom_line() +
stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", angle = 66,
             hjust = -0.1, x.label.fmt = "%Y") +
  ylim(NA, 8000)

formula &lt;- y ~ poly(x, 2, raw = TRUE)
ggplot(cars, aes(speed, dist)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("eq", "R2", "P")),
               formula = formula,
               parse = TRUE) +
  labs(x = expression("Speed, "*x~("mph")),
       y = expression("Stopping distance, "*y~("ft")))

formula &lt;- y ~ x
ggplot(PlantGrowth, aes(group, weight)) +
  stat_summary(fun.data = "mean_se") +
  stat_fit_tb(method = "lm",
              method.args = list(formula = formula),
              tb.type = "fit.anova",
              tb.vars = c(Term = "term", "df", "M.S." = "meansq",
                          "italic(F)" = "statistic",
                          "italic(p)" = "p.value"),
              tb.params = c("Group" = 1, "Error" = 2),
              table.theme = ttheme_gtbw(parse = TRUE)) +
  labs(x = "Group", y = "Dry weight of plants") +
  theme_classic()

</code></pre>

<hr>
<h2 id='coef.lmodel2'>Extract Model Coefficients</h2><span id='topic+coef.lmodel2'></span>

<h3>Description</h3>

<p><code>coef</code> is a generic function which extracts model coefficients from
objects returned by modeling functions. <code>coefficients</code> is an alias for
it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmodel2'
coef(object, method = "MA", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lmodel2_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="coef.lmodel2_+3A_method">method</code></td>
<td>
<p>character One of the methods available in <code>object</code>.</p>
</td></tr>
<tr><td><code id="coef.lmodel2_+3A_...">...</code></td>
<td>
<p>ignored by this method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>lmodel2()</code> from package 'lmodel2' returns a fitted
model object of class <code>"lmodel2"</code> which differs from that returned by
<code>lm()</code>. Here we implement a <code>coef()</code> method for objects of this
class. It differs from de generic method and that for lm objects in having
an additional formal parameter <code>method</code> that must be used to select
estimates based on which of the methods supported by <code>lmodel2()</code> are
to be extracted. The returned object is identical in its structure to that
returned by <code>coef.lm()</code>.
</p>


<h3>Value</h3>

<p>A named numeric vector of length two.
</p>


<h3>See Also</h3>

<p><code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code>
</p>

<hr>
<h2 id='confint.lmodel2'>Confidence Intervals for Model Parameters</h2><span id='topic+confint.lmodel2'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more parameters in a fitted model.
This a method for objects inheriting from class &quot;lmodel2&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmodel2'
confint(object, parm, level = 0.95, method = "MA", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.lmodel2_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="confint.lmodel2_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence
intervals, either a vector of numbers or a vector of names. If missing, all
parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.lmodel2_+3A_level">level</code></td>
<td>
<p>the confidence level required. Currently only 0.95 accepted.</p>
</td></tr>
<tr><td><code id="confint.lmodel2_+3A_method">method</code></td>
<td>
<p>character One of the methods available in <code>object</code>.</p>
</td></tr>
<tr><td><code id="confint.lmodel2_+3A_...">...</code></td>
<td>
<p>ignored by this method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>lmodel2()</code> from package 'lmodel2' returns a fitted
model object of class <code>"lmodel2"</code> which differs from that returned by
<code>lm()</code>. Here we implement a <code>confint()</code> method for objects of
this class. It differs from the generic method and that for lm objects in
having an additional formal parameter <code>method</code> that must be used to
select estimates based on which of the methods supported by
<code>lmodel2()</code> are to be extracted. The returned object is identical in
its structure to that returned by <code>confint.lm()</code>.
</p>


<h3>Value</h3>

<p>A data frame with two rows and three columns.
</p>


<h3>See Also</h3>

<p><code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code>
</p>

<hr>
<h2 id='cor_test_compute_fun'><code>Stat*</code> Objects</h2><span id='topic+cor_test_compute_fun'></span><span id='topic+StatCorr'></span><span id='topic+fit_tb_compute_panel_fun'></span><span id='topic+StatFitTb'></span><span id='topic+fit_glance_compute_group_fun'></span><span id='topic+StatFitGlance'></span><span id='topic+fit_augment_compute_group_fun'></span><span id='topic+StatFitAugment'></span><span id='topic+fit_tidy_compute_group_fun'></span><span id='topic+StatFitTidy'></span><span id='topic+deviations_compute_group_fun'></span><span id='topic+StatFitDeviations'></span><span id='topic+fitted_compute_group_fun'></span><span id='topic+StatFitFitted'></span><span id='topic+residuals_compute_group_fun'></span><span id='topic+StatFitResiduals'></span><span id='topic+ma_eq_compute_group_fun'></span><span id='topic+StatMaEq'></span><span id='topic+ma_line_compute_group_fun'></span><span id='topic+StatMaLine'></span><span id='topic+multcomp_compute_fun'></span><span id='topic+StatMultcomp'></span><span id='topic+peaks_compute_group_fun'></span><span id='topic+valleys_compute_group_fun'></span><span id='topic+Stats'></span><span id='topic+StatPeaks'></span><span id='topic+StatValleys'></span><span id='topic+poly_eq_compute_group_fun'></span><span id='topic+StatPolyEq'></span><span id='topic+StatPolyLine'></span><span id='topic+quant_band_compute_group_fun'></span><span id='topic+StatQuantBand'></span><span id='topic+quant_eq_compute_group_fun'></span><span id='topic+StatQuantEq'></span><span id='topic+quant_line_compute_group_fun'></span><span id='topic+StatQuantLine'></span>

<h3>Description</h3>

<p>All <code>stat_*</code> functions (like <code>stat_bin</code>) return a layer that
contains a <code>Stat*</code> object (like <code>StatBin</code>). The <code>Stat*</code>
object is responsible for rendering the data in the plot.
</p>


<h3>Details</h3>

<p>Each of the <code>Stat*</code> objects is a <code><a href="ggplot2.html#topic+ggproto">ggproto</a></code> object,
derived from the top-level <code>Stat</code>, and each implements various methods
and fields. To create a new type of Stat object, you typically will want to
implement one or more of the following:
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot2-ggproto">ggplot2-ggproto</a></code>
</p>

<hr>
<h2 id='fail_safe_formula'>Safely extract the formula from an object</h2><span id='topic+fail_safe_formula'></span>

<h3>Description</h3>

<p>Safely extract the formula from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fail_safe_formula(fm, method.args = list(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fail_safe_formula_+3A_fm">fm</code></td>
<td>
<p>Fitted model object or a call object.</p>
</td></tr>
<tr><td><code id="fail_safe_formula_+3A_method.args">method.args</code></td>
<td>
<p>List of arguments to check for the formula.</p>
</td></tr>
<tr><td><code id="fail_safe_formula_+3A_verbose">verbose</code></td>
<td>
<p>logical If <code>TRUE</code> message triggered if call to
<code>formula()</code> fails.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code><a href="stats.html#topic+formula">formula</a></code> is not implemented for all fitted
model objects, while the default method triggers an error and stops
exectution. Function <code>fail_safe_formula()</code> wraps the call to
<code>formula()</code> and handles the error conditions by attempting to
extract the formula from a list of arguments. If this fails, it returns
<code>NA</code>, with a message.
</p>


<h3>Value</h3>

<p>A named list with objects of class formula or NA as member(s).
</p>

<hr>
<h2 id='FC_format'>Formatter for fold change tick labels</h2><span id='topic+FC_format'></span><span id='topic+FC_plain'></span>

<h3>Description</h3>

<p>Generate tick labels discounting a log transformation in data, and
optionally applying a different log transformation or no transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FC_format(log.base.data = 2, log.base.labels = 10, digits = 3, ...)

FC_plain(
  x,
  log.base.data = 2,
  log.base.labels = 10,
  digits = 3,
  fmt = "%+.*g",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FC_format_+3A_log.base.data">log.base.data</code></td>
<td>
<p>of data.</p>
</td></tr>
<tr><td><code id="FC_format_+3A_log.base.labels">log.base.labels</code></td>
<td>
<p>of labels.</p>
</td></tr>
<tr><td><code id="FC_format_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to show.</p>
</td></tr>
<tr><td><code id="FC_format_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>
<tr><td><code id="FC_format_+3A_x">x</code></td>
<td>
<p>a numeric vector to format.</p>
</td></tr>
<tr><td><code id="FC_format_+3A_fmt">fmt</code></td>
<td>
<p>character string containing the format for one number using
<code>*</code> for the precision.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with single parameter x, a numeric vector, that
returns a character vector.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_outcome">scale_colour_outcome</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_y_Pvalue">scale_y_Pvalue</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
FC_format(2, 10)(1:5)
FC_format(0, 2)(c(1/4, 1/2, 1,2,4,8))
FC_format(10, 0)(-1:3)
FC_format(0, 10)(c(0.1, 1, 10, 100, 100))

</code></pre>

<hr>
<h2 id='FC_name'>Fold change- axis labels</h2><span id='topic+FC_name'></span>

<h3>Description</h3>

<p>Generate axis labels for different log-fold change on different log bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FC_name(
  name = "Abundance%unit",
  log.base = FALSE,
  format = getOption("photobiology.math", default = "R.expression")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FC_name_+3A_name">name</code></td>
<td>
<p>character The axis-label or name of the scale.</p>
</td></tr>
<tr><td><code id="FC_name_+3A_log.base">log.base</code></td>
<td>
<p>integer The base used for the logarithm transformation.</p>
</td></tr>
<tr><td><code id="FC_name_+3A_format">format</code></td>
<td>
<p>character string, &quot;R&quot;, &quot;R.expression&quot;, &quot;R.character&quot;, or
&quot;LaTeX&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string or an R expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
FC_name()
FC_name(format = "R.expression")
FC_name(format = "LaTeX")
FC_name(name = "Metabolite concentration")
FC_name(log.base = 10)
FC_name(log.base = 0)

</code></pre>

<hr>
<h2 id='find_peaks'>Find local maxima or global maximum (peaks)</h2><span id='topic+find_peaks'></span>

<h3>Description</h3>

<p>This method finds peaks (local maxima) in a vector, using a user selectable
span and size threshold relative to the tallest peak (global maximum).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peaks(x, ignore_threshold = 0, span = 3, strict = FALSE, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_peaks_+3A_x">x</code></td>
<td>
<p>numeric vector.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_ignore_threshold">ignore_threshold</code></td>
<td>
<p>numeric value between 0.0 and 1.0 indicating the size
threshold below which peaks will be ignored, or a negative value &gt;= -1,
to ignore peaks above a threshold. These values are relative to the range
of <code>x</code>.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_span">span</code></td>
<td>
<p>a peak is defined as an element in a sequence which is greater
than all other elements within a window of width span centered at that
element. The default value is 3, meaning that a peak is bigger than both of
its neighbors. <code>span = NULL</code> extends the span to the whole length of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_strict">strict</code></td>
<td>
<p>logical flag: if TRUE, an element must be strictly greater than
all other values in its window to be considered a peak. Default: TRUE.</p>
</td></tr>
<tr><td><code id="find_peaks_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether <code>NA</code> values should be stripped
before searching for peaks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper built onto function
<code><a href="splus2R.html#topic+peaks">peaks</a></code> from <span class="pkg">splus2R</span> and handles non-finite
(including NA) values differently than <code>peaks</code>, instead of giving an
error when <code>na.rm = FALSE</code> and <code>x</code> contains <code>NA</code> values,
<code>NA</code> values are replaced with the smallest finite value in <code>x</code>.
<code>span = NULL</code> is treated as a special case and returns <code>max(x)</code>.
</p>


<h3>Value</h3>

<p>A vector of logical values. Values that are TRUE correspond to local
peaks in vector <code>x</code> and can be used to extract the rows corresponding
to peaks from a data frame.
</p>


<h3>Note</h3>

<p>The default for parameter <code>strict</code> is <code>FALSE</code> in functions
<code>peaks()</code> and <code>find_peaks()</code>, as in <code>stat_peaks()</code> and in
<code>stat_valleys()</code>, while the default in <code><a href="splus2R.html#topic+peaks">peaks</a></code>
is <code>strict = TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="splus2R.html#topic+peaks">peaks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># lynx is a time.series object
lynx_num.df &lt;-
  try_tibble(lynx,
             col.names = c("year", "lynx"),
             as.numeric = TRUE) # years -&gt; as numeric

which(find_peaks(lynx_num.df$lynx, span = 31))
lynx_num.df[find_peaks(lynx_num.df$lynx, span = 15), ]
lynx_num.df[find_peaks(lynx_num.df$lynx, span = NULL), ]
lynx_num.df[find_peaks(lynx_num.df$lynx,
                       span = 31,
                       ignore_threshold = 0.75), ]

lynx_datetime.df &lt;-
   try_tibble(lynx,
              col.names = c("year", "lynx")) # years -&gt; POSIXct

which(find_peaks(lynx_datetime.df$lynx, span = 31))
lynx_datetime.df[find_peaks(lynx_datetime.df$lynx, span = 31), ]
lynx_datetime.df[find_peaks(lynx_datetime.df$lynx,
                            span = 31,
                            ignore_threshold = 0.75), ]

</code></pre>

<hr>
<h2 id='keep_tidy'>Tidy, glance or augment an object keeping a trace of its origin</h2><span id='topic+keep_tidy'></span><span id='topic+keep_glance'></span><span id='topic+keep_augment'></span>

<h3>Description</h3>

<p>Methods implemented in package 'broom' to tidy, glance and augment the output
from model fits return a consistently organized tibble with generic column
names. Although this simplifies later steps in the data analysis and
reporting, it drops key information needed for interpretation.
<code>keep_tidy()</code> makes it possible to retain fields from the model fit
object passed as argument to parameter <code>x</code> in the attribute <code>"fm"</code>.
The class of <code>x</code> is always stored, and by default also fields
<code>"call"</code>, <code>"terms"</code>, <code>"formula"</code>, <code>"fixed"</code> and
<code>"random"</code> if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_tidy(x, ..., to.keep = c("call", "terms", "formula", "fixed", "random"))

keep_glance(x, ..., to.keep = c("call", "terms", "formula", "fixed", "random"))

keep_augment(
  x,
  ...,
  to.keep = c("call", "terms", "formula", "fixed", "random")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_tidy_+3A_x">x</code></td>
<td>
<p>An object for which <code>tidy()</code>, <code>glance</code> and/or
<code>augment</code> method is available.</p>
</td></tr>
<tr><td><code id="keep_tidy_+3A_...">...</code></td>
<td>
<p>Other named arguments passed along to <code>tidy()</code>, <code>glance</code>
or <code>augment</code>.</p>
</td></tr>
<tr><td><code id="keep_tidy_+3A_to.keep">to.keep</code></td>
<td>
<p>character vector of field names in <code>x</code> to copy to
attribute <code>"fm"</code> of the tibble returned by <code>tidy()</code>,
<code>glance</code> or <code>augment</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>keep_tidy()</code>, <code>keep_glance</code> or
<code>keep_augment</code> are simple wrappers of the generic methods which make
it possible to add to the returned values an attribute named <code>"fm"</code>
preserving user selected fields and class of the model fit object. Fields
names in <code>to.keep</code> missing in <code>x</code> are silently ignored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# these examples can only be run if package 'broom' is available

if (requireNamespace("broom", quietly = TRUE)) {

  library(broom)

  mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)

  attr(keep_tidy(mod), "fm")[["class"]]
  attr(keep_glance(mod), "fm")[["class"]]
  attr(keep_augment(mod), "fm")[["class"]]

  attr(keep_tidy(summary(mod)), "fm")[["class"]]

  library(MASS)
  rmod &lt;- rlm(mpg ~ wt + qsec, data = mtcars)
  attr(keep_tidy(rmod), "fm")[["class"]]

}

</code></pre>

<hr>
<h2 id='Moved'>Moved to package 'gginnards'</h2><span id='topic+Moved'></span><span id='topic+geom_null'></span><span id='topic+stat_debug_group'></span><span id='topic+stat_debug_panel'></span><span id='topic+geom_debug'></span><span id='topic+append_layers'></span><span id='topic+bottom_layer'></span><span id='topic+delete_layers'></span><span id='topic+extract_layers'></span><span id='topic+move_layers'></span><span id='topic+num_layers'></span><span id='topic+shift_layers'></span><span id='topic+top_layer'></span><span id='topic+which_layers'></span>

<h3>Description</h3>

<p>Some stats, geoms and the plot layer manipulation functions have been
moved from package 'ggpmisc' to a separate new package called 'gginnards'.
</p>


<h3>Details</h3>

<p>To continue using any of these functions and methods, simply run at
the R prompt or add to your script <code>library(gginnards)</code>, after
installing package 'gginnards'.
</p>


<h3>See Also</h3>

<p><code><a href="gginnards.html#topic+gginnards-package">gginnards-package</a></code>,
<code><a href="gginnards.html#topic+geom_null">geom_null</a></code>,
<code><a href="gginnards.html#topic+stat_debug_group">stat_debug_group</a></code>,
<code><a href="gginnards.html#topic+stat_debug_panel">stat_debug_panel</a></code>,
<code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> and
<code><a href="gginnards.html#topic+delete_layers">delete_layers</a></code>.
</p>

<hr>
<h2 id='outcome2factor'>Convert numeric ternary outcomes into a factor</h2><span id='topic+outcome2factor'></span><span id='topic+threshold2factor'></span>

<h3>Description</h3>

<p>Convert numeric ternary outcomes into a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outcome2factor(x, n.levels = 3L)

threshold2factor(x, n.levels = 3L, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outcome2factor_+3A_x">x</code></td>
<td>
<p>a numeric vector of -1, 0, and +1 values, indicating down-regulation,
uncertain response or up-regulation, or a numeric vector that can be
converted into such values using a pair of thresholds.</p>
</td></tr>
<tr><td><code id="outcome2factor_+3A_n.levels">n.levels</code></td>
<td>
<p>numeric Number of levels to create, either 3 or 2.</p>
</td></tr>
<tr><td><code id="outcome2factor_+3A_threshold">threshold</code></td>
<td>
<p>numeric vector Range enclosing the values to be considered
uncertain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions convert the numerically encoded values into a factor
with the three levels <code>"down"</code>, <code>"uncertain"</code> and <code>"up"</code>, or
into a factor with two levels <code>de</code> and <code>uncertain</code> as expected by
default by scales <code><a href="#topic+scale_colour_outcome">scale_colour_outcome</a></code>,
<code><a href="#topic+scale_fill_outcome">scale_fill_outcome</a></code> and <code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a></code>.
When <code>n.levels = 2</code> both -1 and +1 are merged to the same level of the
factor with label <code>"de"</code>.
</p>


<h3>Note</h3>

<p>These are convenience functions that only save some typing. The same
result can be achieved by a direct call to <code><a href="base.html#topic+factor">factor</a></code> and
comparisons. These functions aim at making it easier to draw volcano and
quadrant plots.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+FC_format">FC_format</a>()</code>,
<code><a href="#topic+scale_colour_outcome">scale_colour_outcome</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_y_Pvalue">scale_y_Pvalue</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>
<p>Other scales for omics data: 
<code><a href="#topic+scale_colour_logFC">scale_colour_logFC</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_x_logFC">scale_x_logFC</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
outcome2factor(c(-1, 1, 0, 1))
outcome2factor(c(-1, 1, 0, 1), n.levels = 2L)

threshold2factor(c(-0.1, -2, 0, +5))
threshold2factor(c(-0.1, -2, 0, +5), n.levels = 2L)
threshold2factor(c(-0.1, -2, 0, +5), threshold = c(-1, 1))

</code></pre>

<hr>
<h2 id='predict.lmodel2'>Model Predictions</h2><span id='topic+predict.lmodel2'></span>

<h3>Description</h3>

<p><code>predict</code> is a generic function for predictions from the results of
various model fitting functions. <code>predict.lmodel2</code> is the method
for model fit objects of class <code>"lmodel2"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmodel2'
predict(
  object,
  method = "MA",
  newdata = NULL,
  interval = c("none", "confidence"),
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lmodel2_+3A_object">object</code></td>
<td>
<p>a fitted model object.</p>
</td></tr>
<tr><td><code id="predict.lmodel2_+3A_method">method</code></td>
<td>
<p>character One of the methods available in <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.lmodel2_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.lmodel2_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation.</p>
</td></tr>
<tr><td><code id="predict.lmodel2_+3A_level">level</code></td>
<td>
<p>the confidence level required. Currently only 0.95 accepted.</p>
</td></tr>
<tr><td><code id="predict.lmodel2_+3A_...">...</code></td>
<td>
<p>ignored by this method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>lmodel2()</code> from package 'lmodel2' returns a fitted
model object of class <code>"lmodel2"</code> which differs from that returned by
<code>lm()</code>. Here we implement a <code>predict()</code> method for objects of
this class. It differs from the generic method and that for <code>lm</code>
objects in having an additional formal parameter <code>method</code> that must be
used to select which of the methods supported by <code>lmodel2()</code> are to be
used in the prediction. The returned object is similar in its structure to
that returned by <code>predict.lm()</code> but lacking names or rownames.
</p>


<h3>Value</h3>

<p>If <code>interval = "none"</code> a numeric vector is returned, while if
<code>interval = "confidence"</code> a data frame with columns <code>fit</code>,
<code>lwr</code> and <code>upr</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code>
</p>

<hr>
<h2 id='reverselog_trans'>Reverse log transformation</h2><span id='topic+reverselog_trans'></span>

<h3>Description</h3>

<p>Reverse log transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverselog_trans(base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverselog_trans_+3A_base">base</code></td>
<td>
<p>numeric Base of logarithm</p>
</td></tr>
</table>

<hr>
<h2 id='scale_colour_logFC'>Colour and fill scales for log fold change data</h2><span id='topic+scale_colour_logFC'></span><span id='topic+scale_color_logFC'></span><span id='topic+scale_fill_logFC'></span>

<h3>Description</h3>

<p>Continuous scales for <code>colour</code> and <code>fill</code> aesthetics with defaults
suitable for values expressed as log2 fold change in <code>data</code> and
fold-change in tick labels. Supports tick labels and data expressed in any
combination of fold-change, log2 fold-change and log10 fold-change. Supports
addition of units to legend title passed as argument to the <code>name</code>
formal parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_logFC(
  name = "Abundance of y%unit",
  breaks = NULL,
  labels = NULL,
  limits = symmetric_limits,
  oob = scales::squish,
  expand = expansion(mult = 0.05, add = 0),
  log.base.labels = FALSE,
  log.base.data = 2L,
  midpoint = NULL,
  low.colour = "dodgerblue2",
  mid.colour = "grey50",
  high.colour = "red",
  na.colour = "black",
  aesthetics = "colour",
  ...
)

scale_color_logFC(
  name = "Abundance of y%unit",
  breaks = NULL,
  labels = NULL,
  limits = symmetric_limits,
  oob = scales::squish,
  expand = expansion(mult = 0.05, add = 0),
  log.base.labels = FALSE,
  log.base.data = 2L,
  midpoint = NULL,
  low.colour = "dodgerblue2",
  mid.colour = "grey50",
  high.colour = "red",
  na.colour = "black",
  aesthetics = "colour",
  ...
)

scale_fill_logFC(
  name = "Abundance of y%unit",
  breaks = NULL,
  labels = NULL,
  limits = symmetric_limits,
  oob = scales::squish,
  expand = expansion(mult = 0.05, add = 0),
  log.base.labels = FALSE,
  log.base.data = 2L,
  midpoint = 1,
  low.colour = "dodgerblue2",
  mid.colour = "grey50",
  high.colour = "red",
  na.colour = "black",
  aesthetics = "fill",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_logFC_+3A_name">name</code></td>
<td>
<p>The name of the scale without units, used for the legend title.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_breaks">breaks</code></td>
<td>
<p>The positions of ticks or a function to generate them. Default
varies depending on argument passed to <code>log.base.labels</code>. if supplied
as a numeric vector they should be given using the data as passed to
parameter <code>data</code>.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_labels">labels</code></td>
<td>
<p>The tick labels or a function to generate them from the tick
positions. The default is function that uses the arguments passed to
<code>log.base.data</code> and <code>log.base.labels</code> to generate suitable
labels.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_limits">limits</code></td>
<td>
<p>limits    One of: NULL to use the default scale range from
ggplot2. A numeric vector of length two providing limits of the scale,
using NA to refer to the existing minimum or maximum. A function that
accepts the existing (automatic) limits and returns new limits. The default
is function <code>symmetric_limits()</code> which keep 1 at the middle of the
axis..</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_oob">oob</code></td>
<td>
<p>Function that handles limits outside of the scale limits (out of
bounds). The default squishes out-of-bounds values to the boundary.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_expand">expand</code></td>
<td>
<p>Vector of range expansion constants used to add some padding
around the data, to ensure that they are placed some distance away from
the axes. The default is to expand the scale by 15% on each end for
log-fold-data, so as to leave space for counts annotations.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_log.base.labels">log.base.labels</code>, <code id="scale_colour_logFC_+3A_log.base.data">log.base.data</code></td>
<td>
<p>integer or logical Base of logarithms used to
express fold-change values in tick labels and in <code>data</code>. Use <code>FALSE</code>
for no logarithm transformation.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_midpoint">midpoint</code></td>
<td>
<p>numeric Value at the middle of the colour gradient, defaults
to FC = 1, assuming data is expressed as logarithm.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_low.colour">low.colour</code>, <code id="scale_colour_logFC_+3A_mid.colour">mid.colour</code>, <code id="scale_colour_logFC_+3A_high.colour">high.colour</code>, <code id="scale_colour_logFC_+3A_na.colour">na.colour</code></td>
<td>
<p>character Colour
definitions to use for the gradient extremes and middle.</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful,
for example, to apply colour settings to the colour and fill aesthetics at
the same time, via aesthetics = c(&quot;colour&quot;, &quot;fill&quot;).</p>
</td></tr>
<tr><td><code id="scale_colour_logFC_+3A_...">...</code></td>
<td>
<p>other named arguments passed to <code>scale_y_continuous</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These scales only alter default arguments of
<code>scale_colour_gradient2()</code> and <code>scale_fill_gradient2()</code>. Please,
see documentation for <code><a href="ggplot2.html#topic+scale_continuous">scale_continuous</a></code> for details.
The name argument supports the use of <code>"%unit"</code> at the end of the
string to automatically add a units string, otherwise user-supplied values
for names, breaks, and labels work as usual. Tick labels in the legend are
built based on the transformation already applied to the data (log2 by
default) and a possibly different log transformation (default is
fold-change with no transformation). The default for handling out of
bounds values is to &quot;squish&quot; them to the extreme of the scale, which is
different from the default used in 'ggplot2'.
</p>


<h3>See Also</h3>

<p>Other scales for omics data: 
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_x_logFC">scale_x_logFC</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12346)
my.df &lt;- data.frame(x = rnorm(50, sd = 4), y = rnorm(50, sd = 4))
# we assume that both x and y values are expressed as log2 fold change

ggplot(my.df, aes(x, y, colour = y)) +
  geom_point(shape = "circle", size = 2.5) +
  scale_x_logFC() +
  scale_y_logFC() +
  scale_colour_logFC()

ggplot(my.df, aes(x, y, fill = y)) +
  geom_point(shape = "circle filled", colour = "black", size = 2.5) +
  scale_x_logFC() +
  scale_y_logFC() +
  scale_fill_logFC()

my.labels &lt;-
  scales::trans_format(function(x) {log10(2^x)}, scales::math_format())
ggplot(my.df, aes(x, y, colour = y)) +
  geom_point() +
  scale_x_logFC(labels = my.labels) +
  scale_y_logFC(labels = my.labels) +
  scale_colour_logFC(labels = my.labels)

ggplot(my.df, aes(x, y, colour = y)) +
  geom_point() +
  scale_x_logFC(log.base.labels = 2) +
  scale_y_logFC(log.base.labels = 2) +
  scale_colour_logFC(log.base.labels = 2)

ggplot(my.df, aes(x, y, colour = y)) +
  geom_point() +
  scale_x_logFC(log.base.labels = 10) +
  scale_y_logFC(log.base.labels = 10) +
  scale_colour_logFC(log.base.labels = 10)

ggplot(my.df, aes(x, y, colour = y)) +
  geom_point() +
  scale_x_logFC(log.base.labels = 10) +
  scale_y_logFC(log.base.labels = 10) +
  scale_colour_logFC(log.base.labels = 10,
                     labels = FC_format(log.base.labels = 10,
                                        log.base.data = 2L,
                                        fmt = "% .*g"))

# override default arguments.
ggplot(my.df, aes(x, y, colour = y)) +
  geom_point() +
  scale_x_logFC() +
  scale_y_logFC() +
  scale_colour_logFC(name = "Change",
                     labels = function(x) {paste(2^x, "fold")})

</code></pre>

<hr>
<h2 id='scale_colour_outcome'>Colour and fill scales for ternary outcomes</h2><span id='topic+scale_colour_outcome'></span><span id='topic+scale_color_outcome'></span><span id='topic+scale_fill_outcome'></span>

<h3>Description</h3>

<p>Manual scales for colour and fill aesthetics with defaults suitable for the
three way outcome from some statistical tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_colour_outcome(
  ...,
  name = "Outcome",
  ns.colour = "grey80",
  up.colour = "red",
  down.colour = "dodgerblue2",
  de.colour = "goldenrod",
  na.colour = "black",
  values = "outcome:updown",
  drop = TRUE,
  aesthetics = "colour"
)

scale_color_outcome(
  ...,
  name = "Outcome",
  ns.colour = "grey80",
  up.colour = "red",
  down.colour = "dodgerblue2",
  de.colour = "goldenrod",
  na.colour = "black",
  values = "outcome:updown",
  drop = TRUE,
  aesthetics = "colour"
)

scale_fill_outcome(
  ...,
  name = "Outcome",
  ns.colour = "grey80",
  up.colour = "red",
  down.colour = "dodgerblue2",
  de.colour = "goldenrod",
  na.colour = "black",
  values = "outcome:both",
  drop = TRUE,
  aesthetics = "fill"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_colour_outcome_+3A_...">...</code></td>
<td>
<p>other named arguments passed to <code>scale_colour_manual</code>.</p>
</td></tr>
<tr><td><code id="scale_colour_outcome_+3A_name">name</code></td>
<td>
<p>The name of the scale, used for the axis-label.</p>
</td></tr>
<tr><td><code id="scale_colour_outcome_+3A_ns.colour">ns.colour</code>, <code id="scale_colour_outcome_+3A_down.colour">down.colour</code>, <code id="scale_colour_outcome_+3A_up.colour">up.colour</code>, <code id="scale_colour_outcome_+3A_de.colour">de.colour</code></td>
<td>
<p>The colour definitions to
use for each of the three possible outcomes.</p>
</td></tr>
<tr><td><code id="scale_colour_outcome_+3A_na.colour">na.colour</code></td>
<td>
<p>colour definition used for NA.</p>
</td></tr>
<tr><td><code id="scale_colour_outcome_+3A_values">values</code></td>
<td>
<p>a set of aesthetic values to map data values to. The values
will be matched in order (usually alphabetical) with the limits of the
scale, or with breaks if provided. If this is a named vector, then the
values will be matched based on the names instead. Data values that don't
match will be given na.value. In addition the special values
<code>"outcome:updown"</code>, <code>"outcome:de"</code> and <code>"outcome:both"</code> set
predefined values, with <code>"outcome:both"</code> as default.</p>
</td></tr>
<tr><td><code id="scale_colour_outcome_+3A_drop">drop</code></td>
<td>
<p>logical Should unused factor levels be omitted from the scale?
The default, TRUE, uses the levels that appear in the data; FALSE uses all
the levels in the factor.</p>
</td></tr>
<tr><td><code id="scale_colour_outcome_+3A_aesthetics">aesthetics</code></td>
<td>
<p>Character string or vector of character strings listing the
name(s) of the aesthetic(s) that this scale works with. This can be useful,
for example, to apply colour settings to the colour and fill aesthetics at
the same time, via aesthetics = c(&quot;colour&quot;, &quot;fill&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These scales only alter the <code>breaks</code>, <code>values</code>, and
<code>na.value</code> default arguments of <code>scale_colour_manual()</code> and
<code>scale_fill_manual()</code>. Please, see documentation for
<code><a href="ggplot2.html#topic+scale_manual">scale_manual</a></code> for details.
</p>


<h3>Note</h3>

<p>In 'ggplot2' (3.3.4, 3.3.5, 3.3.6) <code>scale_colour_manual()</code> and
<code>scale_fill_manual()</code> do not obey <code>drop</code>, most likely due to a
bug as this worked in version 3.3.3 and earlier. This results in spureous
levels in the plot legend when using versions 3.3.4, 3.3.5, 3.3.6 of
'ggplot2'.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+FC_format">FC_format</a>()</code>,
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_y_Pvalue">scale_y_Pvalue</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12346)
outcome &lt;- sample(c(-1, 0, +1), 50, replace = TRUE)
my.df &lt;- data.frame(x = rnorm(50),
                    y = rnorm(50),
                    outcome2 = outcome2factor(outcome, n.levels = 2),
                    outcome3 = outcome2factor(outcome))

ggplot(my.df, aes(x, y, colour = outcome3)) +
  geom_point() +
  scale_colour_outcome() +
  theme_bw()

ggplot(my.df, aes(x, y, colour = outcome2)) +
  geom_point() +
  scale_colour_outcome() +
  theme_bw()

ggplot(my.df, aes(x, y, fill = outcome3)) +
  geom_point(shape = 21) +
  scale_fill_outcome() +
  theme_bw()

</code></pre>

<hr>
<h2 id='scale_shape_outcome'>Shape scale for ternary outcomes</h2><span id='topic+scale_shape_outcome'></span>

<h3>Description</h3>

<p>Manual scales for colour and fill aesthetics with defaults suitable for the
three way outcome from some statistical tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_shape_outcome(
  ...,
  name = "Outcome",
  ns.shape = "circle filled",
  up.shape = "triangle filled",
  down.shape = "triangle down filled",
  de.shape = "square filled",
  na.shape = "cross"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_shape_outcome_+3A_...">...</code></td>
<td>
<p>other named arguments passed to <code>scale_manual</code>.</p>
</td></tr>
<tr><td><code id="scale_shape_outcome_+3A_name">name</code></td>
<td>
<p>The name of the scale, used for the axis-label.</p>
</td></tr>
<tr><td><code id="scale_shape_outcome_+3A_ns.shape">ns.shape</code>, <code id="scale_shape_outcome_+3A_down.shape">down.shape</code>, <code id="scale_shape_outcome_+3A_up.shape">up.shape</code>, <code id="scale_shape_outcome_+3A_de.shape">de.shape</code></td>
<td>
<p>The shapes to use for each
of the three possible outcomes.</p>
</td></tr>
<tr><td><code id="scale_shape_outcome_+3A_na.shape">na.shape</code></td>
<td>
<p>Shape used for NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These scales only alter the <code>values</code>, and
<code>na.value</code> default arguments of
<code>scale_shape_manual()</code>. Please, see
documentation for <code><a href="ggplot2.html#topic+scale_manual">scale_manual</a></code> for details.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+FC_format">FC_format</a>()</code>,
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_outcome">scale_colour_outcome</a>()</code>,
<code><a href="#topic+scale_y_Pvalue">scale_y_Pvalue</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>
<p>Other scales for omics data: 
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_logFC">scale_colour_logFC</a>()</code>,
<code><a href="#topic+scale_x_logFC">scale_x_logFC</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12346)
outcome &lt;- sample(c(-1, 0, +1), 50, replace = TRUE)
my.df &lt;- data.frame(x = rnorm(50),
                    y = rnorm(50),
                    outcome2 = outcome2factor(outcome, n.levels = 2),
                    outcome3 = outcome2factor(outcome))

ggplot(my.df, aes(x, y, shape = outcome3)) +
  geom_point() +
  scale_shape_outcome() +
  theme_bw()

ggplot(my.df, aes(x, y, shape = outcome3)) +
  geom_point() +
  scale_shape_outcome(guide = FALSE) +
  theme_bw()

ggplot(my.df, aes(x, y, shape = outcome2)) +
  geom_point(size = 2) +
  scale_shape_outcome() +
  theme_bw()

ggplot(my.df, aes(x, y, shape = outcome3, fill = outcome2)) +
  geom_point() +
  scale_shape_outcome() +
  scale_fill_outcome() +
  theme_bw()

ggplot(my.df, aes(x, y, shape = outcome3, fill = outcome2)) +
  geom_point() +
  scale_shape_outcome(name = "direction") +
  scale_fill_outcome(name = "significance") +
  theme_bw()

</code></pre>

<hr>
<h2 id='scale_x_logFC'>Position scales for log fold change data</h2><span id='topic+scale_x_logFC'></span><span id='topic+scale_y_logFC'></span>

<h3>Description</h3>

<p>Continuous scales for x and y aesthetics with defaults suitable for values
expressed as log2 fold change in <code>data</code> and fold-change in tick labels.
Supports tick labels and data expressed in any combination of fold-change,
log2 fold-change and log10 fold-change. Supports addition of units to
axis labels passed as argument to the <code>name</code> formal parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_logFC(
  name = "Abundance of x%unit",
  breaks = NULL,
  labels = NULL,
  limits = symmetric_limits,
  oob = scales::squish,
  expand = expansion(mult = 0.05, add = 0),
  log.base.labels = FALSE,
  log.base.data = 2L,
  ...
)

scale_y_logFC(
  name = "Abundance of y%unit",
  breaks = NULL,
  labels = NULL,
  limits = symmetric_limits,
  oob = scales::squish,
  expand = expansion(mult = 0.05, add = 0),
  log.base.labels = FALSE,
  log.base.data = 2L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_x_logFC_+3A_name">name</code></td>
<td>
<p>The name of the scale without units, used for the axis-label.</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_breaks">breaks</code></td>
<td>
<p>The positions of ticks or a function to generate them. Default
varies depending on argument passed to <code>log.base.labels</code>. if supplied
as a numeric vector they should be given using the data as passed to
parameter <code>data</code>.</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_labels">labels</code></td>
<td>
<p>The tick labels or a function to generate them from the tick
positions. The default is function that uses the arguments passed to
<code>log.base.data</code> and <code>log.base.labels</code> to generate suitable
labels.</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_limits">limits</code></td>
<td>
<p>limits    One of: NULL to use the default scale range from
ggplot2. A numeric
vector of length two providing limits of the scale, using NA to refer to the
existing minimum or maximum. A function that accepts the existing
(automatic) limits and returns new limits. The default is function
<code>symmetric_limits()</code> which keep 1 at the middle of the axis..</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_oob">oob</code></td>
<td>
<p>Function that handles limits outside of the scale limits (out of
bounds). The default squishes out-of-bounds values to the boundary.</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_expand">expand</code></td>
<td>
<p>Vector of range expansion constants used to add some padding
around the data, to ensure that they are placed some distance away from
the axes. The default is to expand the scale by 15% on each end for
log-fold-data, so as to leave space for counts annotations.</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_log.base.labels">log.base.labels</code>, <code id="scale_x_logFC_+3A_log.base.data">log.base.data</code></td>
<td>
<p>integer or logical Base of logarithms used to
express fold-change values in tick labels and in <code>data</code>. Use <code>FALSE</code>
for no logarithm transformation.</p>
</td></tr>
<tr><td><code id="scale_x_logFC_+3A_...">...</code></td>
<td>
<p>other named arguments passed to <code>scale_y_continuous</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These scales only alter default arguments of
<code>scale_x_continuous()</code> and <code>scale_y_continuous()</code>. Please, see
documentation for <code><a href="ggplot2.html#topic+scale_continuous">scale_continuous</a></code> for details. The
name argument supports the use of <code>"%unit"</code> at the end of the string
to automatically add a units string, otherwise user-supplied values for
names, breaks, and labels work as usual. Tick labels are built based on the
transformation already applied to the data (log2 by default) and a possibly
different log transformation (default is fold-change with no
transformation). The default for handling out of bounds values is to
&quot;squish&quot; them to the extreme of the scale, which is different from the
default used in 'ggplot2'.
</p>


<h3>See Also</h3>

<p>Other scales for omics data: 
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_logFC">scale_colour_logFC</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12346)
my.df &lt;- data.frame(x = rnorm(50, sd = 4), y = rnorm(50, sd = 4))
# we assume that both x and y values are expressed as log2 fold change

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC() +
  scale_y_logFC()

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC(labels = scales::trans_format(function(x) {log10(2^x)},
                         scales::math_format())) +
  scale_y_logFC(labels = scales::trans_format(function(x) {log10(2^x)},
                         scales::math_format()))

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC(log.base.labels = 2) +
  scale_y_logFC(log.base.labels = 2)

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC("A concentration%unit", log.base.labels = 10) +
  scale_y_logFC("B concentration%unit", log.base.labels = 10)

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC("A concentration%unit", breaks = NULL) +
  scale_y_logFC("B concentration%unit", breaks = NULL)

# taking into account that data are expressed as log2 FC.
ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC("A concentration%unit", breaks = log2(c(1/100, 1, 100))) +
  scale_y_logFC("B concentration%unit", breaks = log2(c(1/100, 1, 100)))

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC(labels = scales::trans_format(function(x) {log10(2^x)},
                         scales::math_format())) +
  scale_y_logFC(labels = scales::trans_format(function(x) {log10(2^x)},
                         scales::math_format()))

# override "special" default arguments.
ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC("A concentration",
                breaks = waiver(),
                labels = waiver()) +
  scale_y_logFC("B concentration",
                breaks = waiver(),
                labels = waiver())

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC() +
  scale_y_logFC() +
  geom_quadrant_lines() +
  stat_quadrant_counts(size = 3.5)

</code></pre>

<hr>
<h2 id='scale_y_Pvalue'>Convenience scale for P-values</h2><span id='topic+scale_y_Pvalue'></span><span id='topic+scale_y_FDR'></span><span id='topic+scale_x_Pvalue'></span><span id='topic+scale_x_FDR'></span>

<h3>Description</h3>

<p>Scales for y aesthetic mapped to P-values as used in volcano plots with
transcriptomics and metabolomics data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_Pvalue(
  ...,
  name = expression(italic(P) - plain(value)),
  trans = NULL,
  breaks = NULL,
  labels = NULL,
  limits = c(1, 1e-20),
  oob = NULL,
  expand = NULL
)

scale_y_FDR(
  ...,
  name = "False discovery rate",
  trans = NULL,
  breaks = NULL,
  labels = NULL,
  limits = c(1, 1e-10),
  oob = NULL,
  expand = NULL
)

scale_x_Pvalue(
  ...,
  name = expression(italic(P) - plain(value)),
  trans = NULL,
  breaks = NULL,
  labels = NULL,
  limits = c(1, 1e-20),
  oob = NULL,
  expand = NULL
)

scale_x_FDR(
  ...,
  name = "False discovery rate",
  trans = NULL,
  breaks = NULL,
  labels = NULL,
  limits = c(1, 1e-10),
  oob = NULL,
  expand = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_y_Pvalue_+3A_...">...</code></td>
<td>
<p>other named arguments passed to <code>scale_y_continuous</code>.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_name">name</code></td>
<td>
<p>The name of the scale without units, used for the axis-label.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_trans">trans</code></td>
<td>
<p>Either the name of a transformation object, or the object itself. Use
NULL for the default.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_breaks">breaks</code></td>
<td>
<p>The positions of ticks or a function to generate them. Default
varies depending on argument passed to <code>log.base.labels</code>.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_labels">labels</code></td>
<td>
<p>The tick labels or a function to generate them from the tick
positions. The default is function that uses the arguments passed to
<code>log.base.data</code> and <code>log.base.labels</code> to generate suitable
labels.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_limits">limits</code></td>
<td>
<p>Use one of: <code>NULL</code> to use the default scale range, a numeric
vector of length two providing limits of the scale; NA to refer to the
existing minimum or maximum; a function that accepts the existing
(automatic) limits and returns new limits.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_oob">oob</code></td>
<td>
<p>Function that handles limits outside of the scale limits (out of
bounds). The default squishes out-of-bounds values to the boundary.</p>
</td></tr>
<tr><td><code id="scale_y_Pvalue_+3A_expand">expand</code></td>
<td>
<p>Vector of range expansion constants used to add some padding
around the data, to ensure that they are placed some distance away from
the axes. The default is to expand the scale by 15% on each end for
log-fold-data, so as to leave space for counts annotations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These scales only alter default arguments of
<code>scale_x_continuous()</code> and <code>scale_y_continuous()</code>. Please, see
documentation for <code><a href="ggplot2.html#topic+scale_continuous">scale_continuous</a></code> for details.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+FC_format">FC_format</a>()</code>,
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_outcome">scale_colour_outcome</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+xy_outcomes2factor">xy_outcomes2factor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12346)
my.df &lt;- data.frame(x = rnorm(50, sd = 4),
                    y = 10^-runif(50, min = 0, max = 20))

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC() +
  scale_y_Pvalue()

ggplot(my.df, aes(x, y)) +
  geom_point() +
  scale_x_logFC() +
  scale_y_FDR(limits = c(NA, 1e-20))

</code></pre>

<hr>
<h2 id='stat_correlation'>Annotate plot with correlation test</h2><span id='topic+stat_correlation'></span>

<h3>Description</h3>

<p><code>stat_correlation()</code> applies <code>stats::cor.test()</code>
respecting grouping with <code>method = "pearson"</code> default but
alternatively using <code>"kendall"</code> or <code>"spearman"</code> methods. It
generates labels for correlation coefficients and p-value, coefficient of
determination (R^2) for method &quot;pearson&quot; and number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_correlation(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  ...,
  method = "pearson",
  n.min = 2L,
  alternative = "two.sided",
  exact = NULL,
  r.conf.level = ifelse(method == "pearson", 0.95, NA),
  continuity = FALSE,
  small.r = FALSE,
  small.p = FALSE,
  coef.keep.zeros = TRUE,
  r.digits = 2,
  t.digits = 3,
  p.digits = 3,
  CI.brackets = c("[", "]"),
  label.x = "left",
  label.y = "top",
  hstep = 0,
  vstep = NULL,
  output.type = NULL,
  boot.R = ifelse(method == "pearson", 0, 999),
  na.rm = FALSE,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_correlation_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override the
plot defaults.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_method">method</code></td>
<td>
<p>character One of &quot;pearson&quot;, &quot;kendall&quot; or &quot;spearman&quot;.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the variables for
fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_alternative">alternative</code></td>
<td>
<p>character One of &quot;two.sided&quot;, &quot;less&quot; or &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_exact">exact</code></td>
<td>
<p>logical Whether an exact p-value should be computed. Used for
Kendall's tau and Spearman's rho.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_r.conf.level">r.conf.level</code></td>
<td>
<p>numeric Confidence level for the returned confidence
interval. If set to <code>NA</code> computation of CI is skipped.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_continuity">continuity</code></td>
<td>
<p>logical If TRUE , a continuity correction is used for
Kendall's tau and Spearman's rho when not computed exactly.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_small.r">small.r</code>, <code id="stat_correlation_+3A_small.p">small.p</code></td>
<td>
<p>logical Flags to switch use of lower case r and p for
coefficient of correlation (only for <code>method = "pearson"</code>) and
p-value.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_coef.keep.zeros">coef.keep.zeros</code></td>
<td>
<p>logical Keep or drop trailing zeros when formatting
the correlation coefficients and t-value, z-value or S-value (see note
below).</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_r.digits">r.digits</code>, <code id="stat_correlation_+3A_t.digits">t.digits</code>, <code id="stat_correlation_+3A_p.digits">p.digits</code></td>
<td>
<p>integer Number of digits after the decimal
point to use for R, r.squared, tau or rho and P-value in labels.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_ci.brackets">CI.brackets</code></td>
<td>
<p>character vector of length 2. The opening and closing
brackets used for the CI label.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_label.x">label.x</code>, <code id="stat_correlation_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 &quot;normalized parent
coordinates&quot; (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_hstep">hstep</code>, <code id="stat_correlation_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical
displacement step-size used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_output.type">output.type</code></td>
<td>
<p>character One of &quot;expression&quot;, &quot;LaTeX&quot;, &quot;text&quot;, &quot;markdown&quot;
or &quot;numeric&quot;.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_boot.r">boot.R</code></td>
<td>
<p>interger The number of bootstrap resamples. Set to zero for no
bootstrap estimates for the CI.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_parse">parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_correlation_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic can be used to annotate a plot with the correlation
coefficient and the outcome of its test of significance. It supports
Pearson, Kendall and Spearman methods to compute correlation. This
statistic generates labels as R expressions by default but LaTeX (use TikZ
device), markdown (use package 'ggtext') and plain text are also supported,
as well as numeric values for user-generated text labels. The character
labels include the symbol describing the quantity together with the numeric
value. For the confidence interval (CI) the default is to follow the APA
recommendation of using square brackets.
</p>
<p>The value of <code>parse</code> is set automatically based on <code>output-type</code>,
but if you assemble labels that need parsing from <code>numeric</code> output,
the default needs to be overridden. By default the value of
<code>output.type</code> is guessed from the name of the geometry.
</p>
<p>A ggplot statistic receives as <code>data</code> a data frame that is not the one
passed as argument by the user, but instead a data frame with the variables
mapped to aesthetics. <code>cor.test()</code> is always applied to the variables
mapped to the <code>x</code> and <code>y</code> aesthetics, so the scales used for
<code>x</code> and <code>y</code> should both be continuous scales rather than
discrete.
</p>


<h3>Aesthetics</h3>

<p><code>stat_correaltion()</code> requires <code>x</code> and
<code>y</code>. In addition, the aesthetics understood by the geom
(<code>"text"</code> is the default) are understood and grouping respected.
</p>


<h3>Computed variables</h3>

<p>If output.type is <code>"numeric"</code> the returned
tibble contains the columns listed below with variations depending on the
<code>method</code>. If the model fit function used does not return a value, the
variable is set to <code>NA_real_</code>.
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>r, and cor, tau or rho</dt><dd><p>numeric values for correlation coefficient estimates</p>
</dd>
<dt>t.value and its df, z.value or S.value </dt><dd><p>numeric values for statistic estimates</p>
</dd>
<dt>p.value, n</dt><dd><p>numeric values.</p>
</dd>
<dt>r.conf.level</dt><dd><p>numeric value, as fraction of one.</p>
</dd>
<dt>r.confint.low</dt><dd><p>Confidence interval limit for <code>r</code>.</p>
</dd>
<dt>r.confint.high</dt><dd><p>Confidence interval limit for <code>r</code>.</p>
</dd>
<dt>grp.label</dt><dd><p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>method.label</dt><dd><p>Set according <code>method</code> used.</p>
</dd>
<dt>method, test</dt><dd><p>character values</p>
</dd></dl>

<p>If output.type different from <code>"numeric"</code> the returned tibble contains
in addition to the columns listed above those listed below. If the numeric
value is missing the label is set to <code>character(0L)</code>.
</p>

<dl>
<dt>r.label, and cor.label, tau.label or rho.label</dt><dd><p>Correlation coefficient as a character string.</p>
</dd>
<dt>t.value.label, z.value.label or S.value.label</dt><dd><p>t-value and degrees of freedom, z-value or S-value as a character string.</p>
</dd>
<dt>p.value.label</dt><dd><p>P-value for test against zero, as a character string.</p>
</dd>
<dt>r.confint.label, and cor.conint.label, tau.confint.label or rho.confint.label</dt><dd><p>Confidence interval for <code>r</code> (only with <code>method = "pearson"</code>).</p>
</dd>
<dt>n.label</dt><dd><p>Number of observations used in the fit, as a character string.</p>
</dd>
<dt>grp.label</dt><dd><p>Set according to mapping in <code>aes</code>, as a character string.</p>
</dd></dl>

<p>To explore the computed values returned for a given input we suggest the use
of <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> as shown in the last examples below.
</p>


<h3>Note</h3>

<p>Currently <code>coef.keep.zeros</code> is ignored, with trailing zeros always
retained in the labels but not protected from being dropped by R when
character strings are parsed into expressions.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor.test">cor.test</a></code> for details on the computations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(4321)
x &lt;- (1:100) / 10
y &lt;- x + rnorm(length(x))
my.data &lt;- data.frame(x = x,
                      y = y,
                      y.desc = - y,
                      group = c("A", "B"))

# by default only R is displayed
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(small.r = TRUE)

ggplot(my.data, aes(x, y.desc)) +
  geom_point() +
  stat_correlation(label.x = "right")

# non-default methods
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(method = "kendall")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(method = "spearman")

# use_label() can map a user selected label
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(use_label("R2"))

# use_label() can assemble and map a combined label
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(use_label(c("R", "P", "n", "method")))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(use_label(c("R", "R.CI")))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(use_label(c("R", "R.CI")),
                   r.conf.level = 0.95)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(use_label(c("R", "R.CI")),
                   method = "kendall",
                   r.conf.level = 0.95)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(use_label(c("R", "R.CI")),
                   method = "spearman",
                   r.conf.level = 0.95)

# manually assemble and map a specific label using paste() and aes()
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(aes(label = paste(after_stat(r.label),
                                     after_stat(p.value.label),
                                     after_stat(n.label),
                                     sep = "*\", \"*")))

# manually format and map a specific label using sprintf() and aes()
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_correlation(aes(label = sprintf("%s*\" with \"*%s*\" for \"*%s",
                                       after_stat(r.label),
                                       after_stat(p.value.label),
                                       after_stat(t.value.label))))

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics with after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

# the whole of computed data
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug", method = "pearson")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug", method = "kendall")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug", method = "spearman")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug", output.type = "numeric")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug", output.type = "markdown")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_correlation(geom = "debug", output.type = "LaTeX")

</code></pre>

<hr>
<h2 id='stat_fit_augment'>Augment data with fitted values and statistics</h2><span id='topic+stat_fit_augment'></span>

<h3>Description</h3>

<p><code>stat_fit_augment</code> fits a model and returns a &quot;tidy&quot;
version of the model's data with prediction added, using '<code>augmnent()</code>
methods from packages 'broom', 'broom.mixed', or other sources. The
prediction can be added to the plot as a curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fit_augment(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  method = "lm",
  method.args = list(formula = y ~ x),
  n.min = 2L,
  augment.args = list(),
  level = 0.95,
  y.out = ".fitted",
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fit_augment_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_method">method</code></td>
<td>
<p>character or function.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_method.args">method.args</code>, <code id="stat_fit_augment_+3A_augment.args">augment.args</code></td>
<td>
<p>list of arguments to pass to <code>method</code>
and to to <code>broom:augment</code>.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_level">level</code></td>
<td>
<p>numeric Level of confidence interval to use (0.95 by default)</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_y.out">y.out</code></td>
<td>
<p>character (or numeric) index to column to return as <code>y</code>.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fit_augment_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_fit_augment</code> together with <code><a href="#topic+stat_fit_glance">stat_fit_glance</a></code>
and <code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a></code>, based on package 'broom' can be used
with a broad range of model fitting functions as supported at any given
time by 'broom'. In contrast to <code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code> which can
generate text or expression labels automatically, for these functions the
mapping of aesthetic <code>label</code> needs to be explicitly supplied in the
call, and labels built on the fly.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. In other words, it respects the grammar of graphics and
consequently within arguments passed through <code>method.args</code> names of
aesthetics like $x$ and $y$ should be used instead of the original variable
names, while data is automatically passed the data frame. This helps ensure
that the model is fitted to the same data as plotted in other layers.
</p>


<h3>Warning!</h3>

<p>Not all &lsquo;glance()' methods are defined in package &rsquo;broom'.
'glance()' specializations for mixed models fits of classes 'lme', 'nlme',
&lsquo;lme4', and many others are defined in package &rsquo;broom.mixed'.
</p>


<h3>Handling of grouping</h3>

<p><code>stat_fit_augment</code> applies the function
given by <code>method</code> separately to each group of observations; in ggplot2
factors mapped to aesthetics generate a separate group for each level.
Because of this, <code>stat_fit_augment</code> is not useful for annotating plots
with results from <code>t.test()</code> or ANOVA or ANCOVA. In such cases use
instead <code>stat_fit_tb()</code> which applies the model fitting per panel.
</p>


<h3>Computed variables</h3>

<p>The output of <code>augment()</code> is
returned as is, except for <code>y</code> which is set based on <code>y.out</code> and
<code>y.observed</code> which preserves the <code>y</code> returned by the
<code>generics::augment</code> methods. This renaming is needed so that the geom
works as expected.
</p>
<p>To explore the values returned by this statistic, which vary depending
on the model fitting function and model formula we suggest the use of
<code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code>. An example is shown below.
</p>


<h3>Note</h3>

<p>The statistic <code>stat_fit_augment</code> can be used only with
<code>methods</code> that accept formulas under any formal parameter name and a
<code>data</code> argument. Use <code>ggplot2::stat_smooth()</code> instead of
<code>stat_fit_augment</code> in production code if the additional features are
not needed.
</p>
<p>Although arguments passed to parameter <code>augment.args</code> will be
passed to [generics::augment()] whether they are silently ignored or obeyed
depends on each specialization of [augment()], so do carefully read the
documentation for the version of [augment()] corresponding to the 'method'
used to fit the model.
</p>


<h3>See Also</h3>

<p><code><a href="broom.html#topic+broom">broom</a></code> and <code>broom.mixed</code> for details on how
the tidying of the result of model fits is done.
</p>
<p>Other ggplot statistics for model fits: 
<code><a href="#topic+stat_fit_deviations">stat_fit_deviations</a>()</code>,
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a>()</code>,
<code><a href="#topic+stat_fit_residuals">stat_fit_residuals</a>()</code>,
<code><a href="#topic+stat_fit_tb">stat_fit_tb</a>()</code>,
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Package 'broom' needs to be installed to run these examples.
# We check availability before running them to avoid errors.

if (requireNamespace("broom", quietly = TRUE)) {
  broom.installed &lt;- TRUE
  library(broom)
  library(quantreg)

# Inspecting the returned data using geom_debug()
  if (requireNamespace("gginnards", quietly = TRUE)) {
    library(gginnards)

# Regression by panel, inspecting data
    ggplot(mtcars, aes(x = disp, y = mpg)) +
      geom_point(aes(colour = factor(cyl))) +
      stat_fit_augment(method = "lm",
                       method.args = list(formula = y ~ x),
                       geom = "debug",
                       summary.fun = colnames)
  }
}

# Regression by panel example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_augment(method = "lm",
                     method.args = list(formula = y ~ x))

# Residuals from regression by panel example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    geom_hline(yintercept = 0, linetype = "dotted") +
    stat_fit_augment(geom = "point",
                     method = "lm",
                     method.args = list(formula = y ~ x),
                     y.out = ".resid")

# Regression by group example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, colour = factor(cyl))) +
    geom_point() +
    stat_fit_augment(method = "lm",
                     method.args = list(formula = y ~ x))

# Residuals from regression by group example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, colour = factor(cyl))) +
    geom_hline(yintercept = 0, linetype = "dotted") +
    stat_fit_augment(geom = "point",
                     method.args = list(formula = y ~ x),
                     y.out = ".resid")

# Weighted regression example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, weight = cyl)) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_augment(method = "lm",
                     method.args = list(formula = y ~ x,
                                        weights = quote(weight)))

# Residuals from weighted regression example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, weight = cyl)) +
    geom_hline(yintercept = 0, linetype = "dotted") +
    stat_fit_augment(geom = "point",
                     method.args = list(formula = y ~ x,
                                        weights = quote(weight)),
                     y.out = ".resid")

# Quantile regression
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    geom_point() +
    stat_fit_augment(method = "rq")


</code></pre>

<hr>
<h2 id='stat_fit_deviations'>Residuals from model fit as segments</h2><span id='topic+stat_fit_deviations'></span><span id='topic+stat_fit_fitted'></span>

<h3>Description</h3>

<p><code>stat_fit_deviations</code> fits a linear model and returns fitted values and
residuals ready to be plotted as segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fit_deviations(
  mapping = NULL,
  data = NULL,
  geom = "segment",
  method = "lm",
  method.args = list(),
  n.min = 2L,
  formula = NULL,
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_fit_fitted(
  mapping = NULL,
  data = NULL,
  geom = "point",
  method = "lm",
  method.args = list(),
  n.min = 2L,
  formula = NULL,
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fit_deviations_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;lm&quot;, &quot;rlm&quot;, &quot;lqs&quot;, &quot;rq&quot;
and the name of a function to be matched, possibly followed by the fit
function's <code>method</code> argument separated by a colon (e.g.
<code>"rq:br"</code>). Functions implementing methods must accept arguments to
parameters <code>formula</code>, <code>data</code>, <code>weights</code> and <code>method</code>. A
<code>fitted()</code> method must exist for the returned model fit object class.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_formula">formula</code></td>
<td>
<p>a &quot;formula&quot; object. Using aesthetic names instead of
original variable names.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and should not inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fit_deviations_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This stat can be used to automatically highlight residuals as
segments in a plot of a fitted model equation. This stat only generates the
residuals, the predicted values need to be separately added to the plot, so
to make sure that the same model formula is used in all steps it is best to
save the formula as an object and supply this object as argument to the
different statistics.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. In other words, it respects the grammar of graphics and
consequently within the model <code>formula</code> names of aesthetics like $x$
and $y$ should be used instead of the original variable names. This helps
ensure that the model is fitted to the same data as plotted in other
layers.
</p>


<h3>Computed variables</h3>

<p>Data frame with same <code>nrow</code> as <code>data</code>
as subset for each group containing five numeric variables. </p>

<dl>
<dt>x</dt><dd><p>x coordinates of observations</p>
</dd> <dt>x.fitted</dt><dd><p>x coordinates of
fitted values</p>
</dd> <dt>y</dt><dd><p>y coordinates of observations</p>
</dd> <dt>y.fitted</dt><dd><p>y
coordinates of fitted values</p>
</dd></dl>

<p>To explore the values returned by this statistic we suggest the use of
<code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code>. An example is shown below, where one
can also see in addition to the computed values the default mapping of the
fitted values to aesthetics <code>xend</code> and <code>yend</code>.
</p>


<h3>Note</h3>

<p>In the case of <code>method = "rq"</code> quantiles are fixed at <code>tau =
  0.5</code> unless <code>method.args</code> has length &gt; 0. Parameter <code>orientation</code>
is redundant as it only affects the default for <code>formula</code> but is
included for consistency with <code>ggplot2</code>.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for model fits: 
<code><a href="#topic+stat_fit_augment">stat_fit_augment</a>()</code>,
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a>()</code>,
<code><a href="#topic+stat_fit_residuals">stat_fit_residuals</a>()</code>,
<code><a href="#topic+stat_fit_tb">stat_fit_tb</a>()</code>,
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
library(MASS)

set.seed(4321)
x &lt;- 1:100
y &lt;- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data &lt;- data.frame(x, y)

# plot residuals from linear model
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = y ~ x) +
  stat_fit_deviations(method = "lm", formula = y ~ x, colour = "red") +
  geom_point()

# plot residuals from linear model with y as explanatory variable
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = y ~ x, orientation = "y") +
  stat_fit_deviations(method = "lm", formula = x ~ y, colour = "red") +
  geom_point()

# as above using orientation
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", orientation = "y") +
  stat_fit_deviations(orientation = "y", colour = "red") +
  geom_point()

# both regressions and their deviations
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm") +
  stat_fit_deviations(colour = "blue") +
  geom_smooth(method = "lm", orientation = "y", colour = "red") +
  stat_fit_deviations(orientation = "y", colour = "red") +
  geom_point()

# give a name to a formula
my.formula &lt;- y ~ poly(x, 3, raw = TRUE)

# plot linear regression
ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = my.formula) +
  stat_fit_deviations(formula = my.formula, colour = "red") +
  geom_point()

ggplot(my.data, aes(x, y)) +
  geom_smooth(method = "lm", formula = my.formula) +
  stat_fit_deviations(formula = my.formula, method = stats::lm, colour = "red") +
  geom_point()

# plot robust regression
ggplot(my.data, aes(x, y)) +
  stat_smooth(method = "rlm", formula = my.formula) +
  stat_fit_deviations(formula = my.formula, method = "rlm", colour = "red") +
  geom_point()

# plot robust regression with weights indicated by colour
my.data.outlier &lt;- my.data
my.data.outlier[6, "y"] &lt;- my.data.outlier[6, "y"] * 10
ggplot(my.data.outlier, aes(x, y)) +
  stat_smooth(method = MASS::rlm, formula = my.formula) +
  stat_fit_deviations(formula = my.formula, method = "rlm",
                      mapping = aes(colour = after_stat(weights)),
                      show.legend = TRUE) +
  scale_color_gradient(low = "red", high = "blue", limits = c(0, 1),
                       guide = "colourbar") +
  geom_point()

# plot quantile regression (= median regression)
ggplot(my.data, aes(x, y)) +
  stat_quantile(formula = my.formula, quantiles = 0.5) +
  stat_fit_deviations(formula = my.formula, method = "rq", colour = "red") +
  geom_point()

# plot quantile regression (= "quartile" regression)
ggplot(my.data, aes(x, y)) +
  stat_quantile(formula = my.formula, quantiles = 0.75) +
  stat_fit_deviations(formula = my.formula, colour = "red",
                      method = "rq", method.args = list(tau = 0.75)) +
  geom_point()

# inspecting the returned data with geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

# plot, using geom_debug() to explore the after_stat data
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_smooth(method = "lm", formula = my.formula) +
    stat_fit_deviations(formula = my.formula, geom = "debug") +
    geom_point()

if (gginnards.installed)
  ggplot(my.data.outlier, aes(x, y)) +
    stat_smooth(method = MASS::rlm, formula = my.formula) +
    stat_fit_deviations(formula = my.formula, method = "rlm", geom = "debug") +
    geom_point()

</code></pre>

<hr>
<h2 id='stat_fit_glance'>One row summary data frame for a fitted model</h2><span id='topic+stat_fit_glance'></span>

<h3>Description</h3>

<p><code>stat_fit_glance</code> fits a model and returns a &quot;tidy&quot; version
of the model's fit, using '<code>glance()</code> methods from packages 'broom',
'broom.mixed', or other sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fit_glance(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  method = "lm",
  method.args = list(formula = y ~ x),
  n.min = 2L,
  glance.args = list(),
  label.x = "left",
  label.y = "top",
  hstep = 0,
  vstep = 0.075,
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fit_glance_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_data">data</code></td>
<td>
<p>A layer specific data set - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_method">method</code></td>
<td>
<p>character or function.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_method.args">method.args</code>, <code id="stat_fit_glance_+3A_glance.args">glance.args</code></td>
<td>
<p>list of arguments to pass to <code>method</code>
and to [generics::glance()], respectively.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_label.x">label.x</code>, <code id="stat_fit_glance_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 &quot;normalized parent
coordinates&quot; (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_hstep">hstep</code>, <code id="stat_fit_glance_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fit_glance_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_fit_glance</code> together with <code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a></code> and
<code><a href="#topic+stat_fit_augment">stat_fit_augment</a></code>, based on package 'broom' can be used with a
broad range of model fitting functions as supported at any given time by
package 'broom'. In contrast to <code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code> which can
generate text or expression labels automatically, for these functions the
mapping of aesthetic <code>label</code> needs to be explicitly supplied in the
call, and labels built on the fly.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. In other words, it respects the grammar of graphics and
consequently within arguments passed through <code>method.args</code> names of
aesthetics like $x$ and $y$ should be used instead of the original variable
names, while data is automatically passed the data frame. This helps ensure
that the model is fitted to the same data as plotted in other layers.
</p>


<h3>Value</h3>

<p>The output of the <code>glance()</code> methods is returned almost as is in
the <code>data</code> object, as a data frame. The names of the columns in the
returned data are consistent with those returned by method <code>glance()</code>
from package 'broom', that will frequently differ from the name of values
returned by the print methods corresponding to the fit or test function
used. To explore the values returned by this statistic including the name
of variables/columns, which vary depending on the model fitting function
and model formula we suggest the use of
<code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code>. An example is shown below.
</p>


<h3>Warning!</h3>

<p>Not all &lsquo;glance()' methods are defined in package &rsquo;broom'.
'glance()' specializations for mixed models fits of classes 'lme', 'nlme',
&lsquo;lme4', and many others are defined in package &rsquo;broom.mixed'.
</p>


<h3>Handling of grouping</h3>

<p><code>stat_fit_glance</code> applies the function
given by <code>method</code> separately to each group of observations, and
factors mapped to aesthetics, including <code>x</code> and <code>y</code>, create a
separate group for each factor level. Because of this,
<code>stat_fit_glance</code> is not useful for annotating plots with results from
<code>t.test()</code>, ANOVA or ANCOVA. In such cases use the
<code>stat_fit_tb()</code> statistic which applies the model fitting per panel.
</p>


<h3>Model formula required</h3>

<p>The current implementation works only with
methods that accept a formula as argument and which have a <code>data</code>
parameter through which a data frame can be passed. For example,
<code>lm()</code> should be used with the formula interface, as the evaluation of
<code>x</code> and <code>y</code> needs to be delayed until the internal <code>data</code>
object of the ggplot is available. With some methods like
<code>stats::cor.test()</code> the data embedded in the <code>"ggplot"</code> object
cannot be automatically passed as argument for the <code>data</code> parameter of
the test or model fit function. Please, for annotations based on
<code>stats::cor.test()</code> use <code>stat_correlation()</code>.
</p>


<h3>Note</h3>

<p>Although arguments passed to parameter <code>glance.args</code> will be
passed to [generics::glance()] whether they are silently ignored or obeyed
depends on each specialization of [glance()], so do carefully read the
documentation for the version of [glance()] corresponding to the 'method'
used to fit the model.
</p>


<h3>See Also</h3>

<p><code><a href="broom.html#topic+broom">broom</a></code> and <code>broom.mixed</code> for details on how
the tidying of the result of model fits is done.
</p>
<p>Other ggplot statistics for model fits: 
<code><a href="#topic+stat_fit_augment">stat_fit_augment</a>()</code>,
<code><a href="#topic+stat_fit_deviations">stat_fit_deviations</a>()</code>,
<code><a href="#topic+stat_fit_residuals">stat_fit_residuals</a>()</code>,
<code><a href="#topic+stat_fit_tb">stat_fit_tb</a>()</code>,
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># package 'broom' needs to be installed to run these examples

if (requireNamespace("broom", quietly = TRUE)) {
  broom.installed &lt;- TRUE
  library(broom)
  library(quantreg)

# Inspecting the returned data using geom_debug()
  if (requireNamespace("gginnards", quietly = TRUE)) {
    library(gginnards)

    ggplot(mtcars, aes(x = disp, y = mpg)) +
      stat_smooth(method = "lm") +
      geom_point(aes(colour = factor(cyl))) +
      stat_fit_glance(method = "lm",
                      method.args = list(formula = y ~ x),
                      geom = "debug")
  }
}

if (broom.installed)
# Regression by panel example
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    stat_smooth(method = "lm", formula = y ~ x) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_glance(method = "lm",
                    label.y = "bottom",
                    method.args = list(formula = y ~ x),
                    mapping = aes(label = sprintf('italic(r)^2~"="~%.3f~~italic(P)~"="~%.2g',
                                  after_stat(r.squared), after_stat(p.value))),
                    parse = TRUE)

# Regression by group example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, colour = factor(cyl))) +
    stat_smooth(method = "lm") +
    geom_point() +
    stat_fit_glance(method = "lm",
                    label.y = "bottom",
                    method.args = list(formula = y ~ x),
                    mapping = aes(label = sprintf('r^2~"="~%.3f~~italic(P)~"="~%.2g',
                                  after_stat(r.squared), after_stat(p.value))),
                    parse = TRUE)

# Weighted regression example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, weight = cyl)) +
    stat_smooth(method = "lm") +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_glance(method = "lm",
                    label.y = "bottom",
                    method.args = list(formula = y ~ x, weights = quote(weight)),
                    mapping = aes(label = sprintf('r^2~"="~%.3f~~italic(P)~"="~%.2g',
                                  after_stat(r.squared), after_stat(p.value))),
                    parse = TRUE)

# correlation test
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    geom_point() +
    stat_fit_glance(method = "cor.test",
                    label.y = "bottom",
                    method.args = list(formula = ~ x + y),
                    mapping = aes(label = sprintf('r[Pearson]~"="~%.3f~~italic(P)~"="~%.2g',
                                  after_stat(estimate), after_stat(p.value))),
                    parse = TRUE)

if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    geom_point() +
    stat_fit_glance(method = "cor.test",
                    label.y = "bottom",
                    method.args = list(formula = ~ x + y, method = "spearman", exact = FALSE),
                    mapping = aes(label = sprintf('r[Spearman]~"="~%.3f~~italic(P)~"="~%.2g',
                                  after_stat(estimate), after_stat(p.value))),
                    parse = TRUE)

# Quantile regression by group example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    stat_smooth(method = "lm") +
    geom_point() +
    stat_fit_glance(method = "rq",
                    label.y = "bottom",
                    method.args = list(formula = y ~ x),
                    mapping = aes(label = sprintf('AIC = %.3g, BIC = %.3g',
                                  after_stat(AIC), after_stat(BIC))))

</code></pre>

<hr>
<h2 id='stat_fit_residuals'>Residuals from a model fit</h2><span id='topic+stat_fit_residuals'></span>

<h3>Description</h3>

<p><code>stat_fit_residuals</code> fits a linear model and returns
residuals ready to be plotted as points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fit_residuals(
  mapping = NULL,
  data = NULL,
  geom = "point",
  method = "lm",
  method.args = list(),
  n.min = 2L,
  formula = NULL,
  resid.type = NULL,
  weighted = FALSE,
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fit_residuals_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;lm&quot;, &quot;rlm&quot;, &quot;rq&quot; and the
name of a function to be matched, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>).
Functions implementing methods must accept arguments to parameters
<code>formula</code>, <code>data</code>, <code>weights</code> and <code>method</code>. A
<code>residuals()</code> method must exist for the returned model fit object
class.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_formula">formula</code></td>
<td>
<p>a &quot;formula&quot; object. Using aesthetic names instead of
original variable names.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_resid.type">resid.type</code></td>
<td>
<p>character passed to <code>residuals()</code> as argument for
<code>type</code> (defaults to <code>"working"</code> except if <code>weighted = TRUE</code>
when it is forced to <code>"deviance"</code>).</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_weighted">weighted</code></td>
<td>
<p>logical If true weighted residuals will be returned.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and should not inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fit_residuals_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This stat can be used to automatically plot residuals as points in a
plot. At the moment it supports only linear models fitted with function
<code>lm()</code> or <code>rlm()</code>. It applies to the fitted model object methods
<code><a href="stats.html#topic+residuals">residuals</a></code> or <code><a href="stats.html#topic+weighted.residuals">weighted.residuals</a></code>
depending on the argument passed to parameter <code>weighted</code>.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. In other words, it respects the grammar of graphics and
consequently within the model <code>formula</code> names of
aesthetics like $x$ and $y$ should be used instead of the original variable
names, while data is automatically passed the data frame. This helps ensure
that the model is fitted to the same data as plotted in other layers.
</p>


<h3>Computed variables</h3>

<p>Data frame with same value of <code>nrow</code> as
<code>data</code> as subset for each group containing five numeric variables.
</p>
 <dl>
<dt>x</dt><dd><p>x coordinates of observations or x residuals from
fitted values</p>
</dd></dl>
<p>, </p>
<dl>
<dt>y</dt><dd><p>y coordinates of observations or y residuals from
fitted values</p>
</dd></dl>
<p>, </p>
<dl>
<dt>x.resid</dt><dd><p>residuals from fitted values</p>
</dd></dl>
<p>,
</p>
<dl>
<dt>y.resid</dt><dd><p>residuals from fitted values</p>
</dd></dl>
<p>, </p>
<dl>
<dt>weights</dt><dd><p>the weights
passed as input to lm or those computed by rlm</p>
</dd></dl>
<p>.
</p>
<p>For <code>orientation = "x"</code>, the default, <code>stat(y.resid)</code> is copied
to variable <code>y</code>, while for <code>orientation = "y"</code>
<code>stat(x.resid)</code> is copied to variable <code>x</code>.
</p>


<h3>Note</h3>

<p>How weights are applied to residuals depends on the method used to fit
the model. For ordinary least squares (OLS), weights are applied to the
squares of the residuals, so the weighted residuals are obtained by
multiplying the &quot;deviance&quot; residuals by the square root of the weights.
When residuals are penalized differently to fit a model, the weighted
residuals need to be computed accordingly. Say if we use the absolute value
of the residuals instead of the squared values, weighted residuals are
obtained by multiplying the residuals by the weights.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for model fits: 
<code><a href="#topic+stat_fit_augment">stat_fit_augment</a>()</code>,
<code><a href="#topic+stat_fit_deviations">stat_fit_deviations</a>()</code>,
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a>()</code>,
<code><a href="#topic+stat_fit_tb">stat_fit_tb</a>()</code>,
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(4321)
x &lt;- 1:100
y &lt;- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data &lt;- data.frame(x, y)

# plot residuals from linear model
ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = y ~ x)

ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = y ~ x, weighted = TRUE)

# plot residuals from linear model with y as explanatory variable
ggplot(my.data, aes(x, y)) +
  geom_vline(xintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = x ~ y) +
  coord_flip()

# give a name to a formula
my.formula &lt;- y ~ poly(x, 3, raw = TRUE)

# plot residuals from linear model
ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = my.formula) +
  coord_flip()

ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = my.formula, resid.type = "response")

# plot residuals from robust regression
ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = my.formula, method = "rlm")

# plot residuals with weights indicated by colour
my.data.outlier &lt;- my.data
my.data.outlier[6, "y"] &lt;- my.data.outlier[6, "y"] * 10
ggplot(my.data.outlier, aes(x, y)) +
  stat_fit_residuals(formula = my.formula, method = "rlm",
                      mapping = aes(colour = after_stat(weights)),
                      show.legend = TRUE) +
  scale_color_gradient(low = "red", high = "blue", limits = c(0, 1),
                       guide = "colourbar")

# plot weighted residuals with weights indicated by colour
ggplot(my.data.outlier) +
  stat_fit_residuals(formula = my.formula, method = "rlm",
                     mapping = aes(x = x,
                                   y = stage(start = y, after_stat = y * weights),
                                   colour = after_stat(weights)),
                     show.legend = TRUE) +
  scale_color_gradient(low = "red", high = "blue", limits = c(0, 1),
                       guide = "colourbar")

# plot residuals from quantile regression (median)
ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = my.formula, method = "rq")

# plot residuals from quantile regression (upper quartile)
ggplot(my.data, aes(x, y)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_fit_residuals(formula = my.formula, method = "rq",
  method.args = list(tau = 0.75))

# inspecting the returned data
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
   stat_fit_residuals(formula = my.formula, resid.type = "working",
                      geom = "debug")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    stat_fit_residuals(formula = my.formula, method = "rlm",
                       geom = "debug")

</code></pre>

<hr>
<h2 id='stat_fit_tb'>Model-fit summary or ANOVA</h2><span id='topic+stat_fit_tb'></span>

<h3>Description</h3>

<p><code>stat_fit_tb</code> fits a model and returns a &quot;tidy&quot; version of
the model's summary or ANOVA table, using '<code>tidy()</code> methods from
packages 'broom', 'broom.mixed', or other 'broom' extensions. The
annotation is added to the plots in tabular form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fit_tb(
  mapping = NULL,
  data = NULL,
  geom = "table_npc",
  method = "lm",
  method.args = list(formula = y ~ x),
  n.min = 2L,
  tidy.args = list(),
  tb.type = "fit.summary",
  tb.vars = NULL,
  tb.params = NULL,
  digits = 3,
  p.digits = digits,
  label.x = "center",
  label.y = "top",
  label.x.npc = NULL,
  label.y.npc = NULL,
  position = "identity",
  table.theme = NULL,
  table.rownames = FALSE,
  table.colnames = TRUE,
  table.hjust = 1,
  parse = FALSE,
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fit_tb_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override the
plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_method">method</code></td>
<td>
<p>character.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_method.args">method.args</code>, <code id="stat_fit_tb_+3A_tidy.args">tidy.args</code></td>
<td>
<p>lists of arguments to pass to <code>method</code> and
to <code>tidy()</code>.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_tb.type">tb.type</code></td>
<td>
<p>character One of &quot;fit.summary&quot;, &quot;fit.anova&quot; or &quot;fit.coefs&quot;.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_tb.vars">tb.vars</code>, <code id="stat_fit_tb_+3A_tb.params">tb.params</code></td>
<td>
<p>character or numeric vectors, optionally named, used
to select and/or rename the columns or the parameters in the table
returned.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of significant digits to be used
for all numeric values in the table.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_p.digits">p.digits</code></td>
<td>
<p>integer indicating the number of decimal places to round
p-values to, with those rounded to zero displayed as the next larger
possible value preceded by &quot;&lt;&quot;. If <code>p.digits</code> is outside the range
1..22 no rounding takes place.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_label.x">label.x</code>, <code id="stat_fit_tb_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> Coordinates (in data units) to be used
for absolute positioning of the output. If too short they will be recycled.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_label.x.npc">label.x.npc</code>, <code id="stat_fit_tb_+3A_label.y.npc">label.y.npc</code></td>
<td>
<p><code>numeric</code> with range 0..1 or character.
Coordinates to be used for positioning the output, expressed in &quot;normalized
parent coordinates&quot; or character string. If too short they will be
recycled.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_table.theme">table.theme</code></td>
<td>
<p>NULL, list or function A 'gridExtra' <code>ttheme</code>
definition, or a constructor for a <code>ttheme</code> or NULL for default.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_table.rownames">table.rownames</code>, <code id="stat_fit_tb_+3A_table.colnames">table.colnames</code></td>
<td>
<p>logical flag to enable or disabling
printing of row names and column names.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_table.hjust">table.hjust</code></td>
<td>
<p>numeric Horizontal justification for the core and column
headings of the table.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_parse">parse</code></td>
<td>
<p>If TRUE, the labels will be parsed into expressions and
displayed as described in <code>?plotmath</code>.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fit_tb_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_fit_tb()</code> Applies a model fitting function per panel,
using the grouping factors from aesthetic mappings in the fitted model.
This is suitable, for example for analysis of variance used to test for
differences among groups.
</p>
<p>The argument to <code>method</code> can be any fit method for which a suitable
<code>tidy()</code> method is available, including non-linear regression. Fit
methods retain their default arguments unless overridden.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. In other words, it respects the grammar of graphics and
consequently within arguments passed through <code>method.args</code> names of
aesthetics like <code class="reqn">x</code> and <code class="reqn">y</code> should be used instead of the original
variable names. The plot's default <code>data</code> is used by default, which
helps ensure that the model is fitted to the same data as plotted in other
layers.
</p>


<h3>Value</h3>

<p>A tibble with columns named <code>fm.tb</code> (a tibble returned by
<code>tidy()</code> with possibly renamed and subset columns and rows, within a
list), <code>fm.tb.type</code> (copy of argument passed to <code>tb.type</code>),
<code>fm.class</code> (the class of the fitted model object), <code>fm.method</code>
(the fit function's name), <code>fm.call</code> (the call if available), <code>x</code>
and <code>y</code>.
</p>
<p>To explore the values returned by this statistic, which vary depending on
the model fitting function and model formula we suggest the use of
<code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code>.
</p>


<h3>Computed variables</h3>

<p>The output of <code>tidy()</code> is returned as a
single &quot;cell&quot; in a tibble (i.e., a tibble nested within a tibble). The
returned <code>data</code> object contains a single tibble, containing the result
from a single model fit to all data in a panel. If grouping is present, it
is ignored in the sense of returning a single table, but the grouping
aesthetic can be a term in the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="broom.html#topic+broom">broom</a></code>, <code>broom.mixed</code>, and
<code><a href="broom.html#topic+tidy">tidy</a></code> for details on how the tidying of the result of
model fits is done. See <code><a href="ggpp.html#topic+geom_table">geom_table</a></code> for details on how
inset tables respond to mapped aesthetics and table themes. For details on
predefined table themes see <code><a href="ggpp.html#topic+ttheme_gtdefault">ttheme_gtdefault</a></code>.
</p>
<p>Other ggplot statistics for model fits: 
<code><a href="#topic+stat_fit_augment">stat_fit_augment</a>()</code>,
<code><a href="#topic+stat_fit_deviations">stat_fit_deviations</a>()</code>,
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a>()</code>,
<code><a href="#topic+stat_fit_residuals">stat_fit_residuals</a>()</code>,
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Package 'broom' needs to be installed to run these examples.
# We check availability before running them to avoid errors.
broom.installed &lt;- requireNamespace("broom", quietly = TRUE)

if (broom.installed)
  library(broom)

# data for examples
  x &lt;- c(44.4, 45.9, 41.9, 53.3, 44.7, 44.1, 50.7, 45.2, 60.1)
  covariate &lt;- sqrt(x) + rnorm(9)
  group &lt;- factor(c(rep("A", 4), rep("B", 5)))
  my.df &lt;- data.frame(x, group, covariate)

gginnards.installed  &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

## covariate is a numeric or continuous variable
# Linear regression fit summary, all defaults
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb() +
    expand_limits(y = 70)

# we can use geom_debug() and str() to inspect the returned value
# and discover the variables that can be mapped to aesthetics with
# after_stat()
if (broom.installed &amp;&amp; gginnards.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(geom = "debug", summary.fun = str) +
    expand_limits(y = 70)

# Linear regression fit summary, with default formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.summary") +
    expand_limits(y = 70)

# Linear regression fit summary, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(digits = 2,
                p.digits = 4,
                tb.params = c("intercept" = 1, "covariate" = 2),
                tb.vars = c(Term = 1, Estimate = 2,
                            "italic(s)" = 3, "italic(t)" = 4,
                            "italic(P)" = 5),
                parse = TRUE) +
    expand_limits(y = 70)

# Linear regression ANOVA table, with default formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova") +
    expand_limits(y = 70)

# Linear regression ANOVA table, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova",
                tb.params = c("Covariate" = 1, 2),
                tb.vars = c(Effect = 1, d.f. = 2,
                            "M.S." = 4, "italic(F)" = 5,
                            "italic(P)" = 6),
                parse = TRUE) +
    expand_limits(y = 67)

# Linear regression fit coeficients, with default formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.coefs") +
    expand_limits(y = 67)

# Linear regression fit coeficients, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.coefs",
                tb.params = c(a = 1, b = 2),
                tb.vars = c(Term = 1, Estimate = 2)) +
    expand_limits(y = 67)

## x is also a numeric or continuous variable
# Polynomial regression, with default formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(method.args = list(formula = y ~ poly(x, 2))) +
    expand_limits(y = 70)

# Polynomial regression, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(method.args = list(formula = y ~ poly(x, 2)),
                tb.params = c("x^0" = 1, "x^1" = 2, "x^2" = 3),
                tb.vars = c("Term" = 1, "Estimate" = 2, "S.E." = 3,
                            "italic(t)" = 4, "italic(P)" = 5),
                parse = TRUE) +
    expand_limits(y = 70)

## group is a factor or discrete variable
# ANOVA summary, with default formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb() +
    expand_limits(y = 70)

# ANOVA table, with default formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova") +
    expand_limits(y = 70)

# ANOVA table, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova",
                tb.vars = c(Effect = "term", "df", "italic(F)" = "statistic",
                            "italic(P)" = "p.value"),
                tb.params = c(Group = 1, Error = 2),
                parse = TRUE)

# ANOVA table, with manual table formatting
# using column names with partial matching
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova",
                tb.vars = c(Effect = "term", "df", "italic(F)" = "stat",
                            "italic(P)" = "p"),
                tb.params = c(Group = "x", Error = "Resid"),
                parse = TRUE)

# ANOVA summary, with default formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb() +
    expand_limits(y = 70)

## covariate is a numeric variable and group is a factor
# ANCOVA (covariate not plotted) ANOVA table, with default formatting
if (broom.installed)
  ggplot(my.df, aes(group, x, z = covariate)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova",
                method.args = list(formula = y ~ x + z))

# ANCOVA (covariate not plotted) ANOVA table, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(group, x, z = covariate)) +
    geom_point() +
    stat_fit_tb(tb.type = "fit.anova",
                method.args = list(formula = y ~ x + z),
                tb.vars = c(Effect = 1, d.f. = 2,
                            "M.S." = 4, "italic(F)" = 5,
                            "italic(P)" = 6),
                tb.params = c(Group = 1,
                              Covariate = 2,
                              Error = 3),
                parse = TRUE)

## group is a factor or discrete variable
# t-test, minimal output, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb(method = "t.test",
              tb.vars = c("italic(t)" = "statistic", "italic(P)" = "p.value"),
              parse = TRUE)

# t-test, more detailed output, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb(method = "t.test",
              tb.vars = c("\"Delta \"*italic(x)" = "estimate",
                          "CI low" = "conf.low", "CI high" = "conf.high",
                          "italic(t)" = "statistic", "italic(P)" = "p.value"),
              parse = TRUE) +
    expand_limits(y = 67)

# t-test (equal variances assumed), minimal output, with manual table formatting
if (broom.installed)
  ggplot(my.df, aes(group, x)) +
    geom_point() +
    stat_fit_tb(method = "t.test",
                method.args = list(formula = y ~ x, var.equal = TRUE),
                tb.vars = c("italic(t)" = "statistic", "italic(P)" = "p.value"),
                parse = TRUE)

## covariate is a numeric or continuous variable
# Linear regression using a table theme and non-default position
if (broom.installed)
  ggplot(my.df, aes(covariate, x)) +
    geom_point() +
    stat_fit_tb(table.theme = ttheme_gtlight,
                npcx = "left", npcy = "bottom") +
    expand_limits(y = 35)

</code></pre>

<hr>
<h2 id='stat_fit_tidy'>One row data frame with fitted parameter estimates</h2><span id='topic+stat_fit_tidy'></span>

<h3>Description</h3>

<p><code>stat_fit_tidy</code> fits a model and returns a &quot;tidy&quot; version
of the model's summary, using '<code>tidy()</code> methods from packages 'broom',
'broom.mixed', or other sources. To add the summary in tabular form use
<code><a href="#topic+stat_fit_tb">stat_fit_tb</a></code> instead of this statistic. When using
<code>stat_fit_tidy()</code> you will most likely want to change the default
mapping for label.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_fit_tidy(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  method = "lm",
  method.args = list(formula = y ~ x),
  n.min = 2L,
  tidy.args = list(),
  label.x = "left",
  label.y = "top",
  hstep = 0,
  vstep = NULL,
  sanitize.names = FALSE,
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_fit_tidy_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs
to be set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_method">method</code></td>
<td>
<p>character or function.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_method.args">method.args</code>, <code id="stat_fit_tidy_+3A_tidy.args">tidy.args</code></td>
<td>
<p>list of arguments to pass to <code>method</code>,
and to [generics::tidy], respectively.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_label.x">label.x</code>, <code id="stat_fit_tidy_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 or character.
Coordinates to be used for positioning the output, expressed in &quot;normalized
parent coordinates&quot; or character string. If too short they will be
recycled.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_hstep">hstep</code>, <code id="stat_fit_tidy_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_sanitize.names">sanitize.names</code></td>
<td>
<p>logical If true sanitize column names in the returned
<code>data</code> with R's <code>make.names()</code> function.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped
before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_fit_tidy_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_fit_tidy</code> together with <code><a href="#topic+stat_fit_glance">stat_fit_glance</a></code>
and <code><a href="#topic+stat_fit_augment">stat_fit_augment</a></code>, based on package 'broom' can be used
with a broad range of model fitting functions as supported at any given
time by 'broom'. In contrast to <code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code> which can
generate text or expression labels automatically, for these functions the
mapping of aesthetic <code>label</code> needs to be explicitly supplied in the
call, and labels built on the fly.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. In other words, it respects the grammar of graphics and
consequently within arguments passed through <code>method.args</code> names of
aesthetics like $x$ and $y$ should be used instead of the original variable
names, while data is automatically passed the data frame. This helps ensure
that the model is fitted to the same data as plotted in other layers.
</p>


<h3>Value</h3>

<p>The output of <code>tidy()</code> is returned after reshaping it into a
single row. Grouping is respected, and the model fitted separately to each
group of data. The returned <code>data</code> object has one row for each group
within a panel. To use the intercept, note that output of <code>tidy()</code> is
renamed from <code>(Intercept)</code> to <code>Intercept</code>. Otherwise, the names
of the columns in the returned data are based on those returned by the
<code>tidy()</code> method for the model fit class returned by the fit function.
These will frequently differ from the name of values returned by the print
methods corresponding to the fit or test function used. To explore the
values returned by this statistic including the name of variables/columns,
which vary depending on the model fitting function and model formula, we
suggest the use of <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code>. An example is shown
below. Names of columns as returned by default are not always syntactically
valid R names making it necessary to use back ticks to access them.
Syntactically valid names are guaranteed if <code>sanitize.names = TRUE</code> is
added to the call.
</p>
<p>To explore the values returned by this statistic, which vary depending on
the model fitting function and model formula we suggest the use of
<code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code>. An example is shown below.
</p>


<h3>Warning!</h3>

<p>Not all &lsquo;glance()' methods are defined in package &rsquo;broom'.
'glance()' specializations for mixed models fits of classes 'lme', 'nlme',
&lsquo;lme4', and many others are defined in package &rsquo;broom.mixed'.
</p>


<h3>Handling of grouping</h3>

<p><code>stat_fit_tidy</code> applies the function
given by <code>method</code> separately to each group of observations; in ggplot2
factors mapped to aesthetics generate a separate group for each level.
Because of this, <code>stat_fit_tidy</code> is not useful for annotating plots
with results from <code>t.test()</code> or ANOVA or ANCOVA. In such cases use
instead <code>stat_fit_tb()</code> which applies the model fitting per panel.
</p>


<h3>Note</h3>

<p>The statistic <code>stat_fit_tidy</code> can be used only with
<code>methods</code> that accept formulas under any formal parameter name and a
<code>data</code> argument. Use <code>ggplot2::stat_smooth()</code> instead of
<code>stat_fit_augment</code> in production code if the additional features are
not needed.
</p>
<p>Although arguments passed to parameter <code>tidy.args</code> will be
passed to [generics::tidy()] whether they are silently ignored or obeyed
depends on each specialization of [tidy()], so do carefully read the
documentation for the version of [tidy()] corresponding to the 'method'
used to fit the model. You will also need to manually install the package,
such as 'broom', where the tidier you intend to use are defined.
</p>


<h3>See Also</h3>

<p><code><a href="broom.html#topic+broom">broom</a></code> and <code>broom.mixed</code> for details on how
the tidying of the result of model fits is done.
</p>
<p>Other ggplot statistics for model fits: 
<code><a href="#topic+stat_fit_augment">stat_fit_augment</a>()</code>,
<code><a href="#topic+stat_fit_deviations">stat_fit_deviations</a>()</code>,
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a>()</code>,
<code><a href="#topic+stat_fit_residuals">stat_fit_residuals</a>()</code>,
<code><a href="#topic+stat_fit_tb">stat_fit_tb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Package 'broom' needs to be installed to run these examples.
# We check availability before running them to avoid errors.

if (requireNamespace("broom", quietly = TRUE)) {
  broom.installed &lt;- TRUE
  library(broom)
  library(quantreg)

# Inspecting the returned data using geom_debug()
  if (requireNamespace("gginnards", quietly = TRUE)) {
    library(gginnards)

# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics. This is specially important for
# this stat as these names depend on the specific tidy() method used, which
# depends on the method used, such as lm(), used to fit the model.

# Regression by panel, default column names
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    stat_smooth(method = "lm", formula = y ~ x + I(x^2)) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_tidy(method = "lm",
                  method.args = list(formula = y ~ x + I(x^2)),
                  geom = "debug")

# Regression by panel, sanitized column names
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    stat_smooth(method = "lm", formula = y ~ x + I(x^2)) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_tidy(method = "lm",
                  method.args = list(formula = y ~ x + I(x^2)),
                  geom = "debug", sanitize.names = TRUE)
  }
}

# Regression by panel example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    stat_smooth(method = "lm", formula = y ~ x) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_tidy(method = "lm",
                  label.x = "right",
                  method.args = list(formula = y ~ x),
                  mapping = aes(label = sprintf("Slope = %.3g\np-value = %.3g",
                                                after_stat(x_estimate),
                                                after_stat(x_p.value))))

# Regression by group example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, colour = factor(cyl))) +
    stat_smooth(method = "lm", formula = y ~ x) +
    geom_point() +
    stat_fit_tidy(method = "lm",
                  label.x = "right",
                  method.args = list(formula = y ~ x),
                  mapping = aes(label = sprintf("Slope = %.3g, p-value = %.3g",
                                                after_stat(x_estimate),
                                                after_stat(x_p.value))))

# Weighted regression example
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg, weight = cyl)) +
    stat_smooth(method = "lm", formula = y ~ x) +
    geom_point(aes(colour = factor(cyl))) +
    stat_fit_tidy(method = "lm",
                  label.x = "right",
                  method.args = list(formula = y ~ x, weights = quote(weight)),
                  mapping = aes(label = sprintf("Slope = %.3g\np-value = %.3g",
                                                after_stat(x_estimate),
                                                after_stat(x_p.value))))

# Quantile regression
if (broom.installed)
  ggplot(mtcars, aes(x = disp, y = mpg)) +
    stat_smooth(method = "lm", formula = y ~ x) +
    geom_point() +
    stat_fit_tidy(method = "rq",
                  label.y = "bottom",
                  method.args = list(formula = y ~ x),
                  tidy.args = list(se.type = "nid"),
                  mapping = aes(label = sprintf("Slope = %.3g\np-value = %.3g",
                                                after_stat(x_estimate),
                                                after_stat(x_p.value))))

</code></pre>

<hr>
<h2 id='stat_ma_eq'>Equation, p-value, R^2 of major axis regression</h2><span id='topic+stat_ma_eq'></span>

<h3>Description</h3>

<p><code>stat_ma_eq</code> fits model II regressions. From the fitted model it
generates several labels including the equation, p-value,
coefficient of determination (R^2), and number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ma_eq(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  ...,
  formula = NULL,
  method = "lmodel2:MA",
  method.args = list(),
  n.min = 2L,
  range.y = NULL,
  range.x = NULL,
  nperm = 99,
  eq.with.lhs = TRUE,
  eq.x.rhs = NULL,
  small.r = FALSE,
  small.p = FALSE,
  coef.digits = 3,
  coef.keep.zeros = TRUE,
  rr.digits = 2,
  theta.digits = 2,
  p.digits = max(1, ceiling(log10(nperm))),
  label.x = "left",
  label.y = "top",
  hstep = 0,
  vstep = NULL,
  output.type = NULL,
  na.rm = FALSE,
  orientation = NA,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ma_eq_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;MA&quot;, &quot;SMA&quot; , &quot;RMA&quot; or
&quot;OLS&quot;, alternatively &quot;lmodel2&quot; or the name of a model fit function are
accepted, possibly followed by the fit function's <code>method</code> argument
separated by a colon (e.g. <code>"lmodel2:MA"</code>). If a function different to
<code>lmodel2()</code>, it must accept arguments named <code>formula</code>,
<code>data</code>, <code>range.y</code>, <code>range.x</code> and <code>nperm</code> and return a
model fit object of class <code>lmodel2</code>.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_range.y">range.y</code>, <code id="stat_ma_eq_+3A_range.x">range.x</code></td>
<td>
<p>character Pass &quot;relative&quot; or &quot;interval&quot; if method
&quot;RMA&quot; is to be computed.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_nperm">nperm</code></td>
<td>
<p>integer Number of permutation used to estimate significance.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_eq.with.lhs">eq.with.lhs</code></td>
<td>
<p>If <code>character</code> the string is pasted to the front of
the equation label before parsing or a <code>logical</code> (see note).</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_eq.x.rhs">eq.x.rhs</code></td>
<td>
<p><code>character</code> this string will be used as replacement for
<code>"x"</code> in the model equation when generating the label before parsing
it.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_small.r">small.r</code>, <code id="stat_ma_eq_+3A_small.p">small.p</code></td>
<td>
<p>logical Flags to switch use of lower case r and p for
coefficient of determination and p-value.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_coef.digits">coef.digits</code></td>
<td>
<p>integer Number of significant digits to use for
the fitted coefficients.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_coef.keep.zeros">coef.keep.zeros</code></td>
<td>
<p>logical Keep or drop trailing zeros when formatting
the fitted coefficients and F-value.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_rr.digits">rr.digits</code>, <code id="stat_ma_eq_+3A_p.digits">p.digits</code>, <code id="stat_ma_eq_+3A_theta.digits">theta.digits</code></td>
<td>
<p>integer Number of digits after the
decimal point to use for R^2, theta and P-value in labels.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_label.x">label.x</code>, <code id="stat_ma_eq_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 &quot;normalized parent
coordinates&quot; (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_hstep">hstep</code>, <code id="stat_ma_eq_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_output.type">output.type</code></td>
<td>
<p>character One of &quot;expression&quot;, &quot;LaTeX&quot;, &quot;text&quot;,
&quot;markdown&quot; or &quot;numeric&quot;.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_parse">parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_ma_eq_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This stat can be used to automatically annotate a plot with <code class="reqn">R^2</code>,
<code class="reqn">P</code>-value, <code class="reqn">n</code> and/or the fitted model equation. It supports linear major axis
(MA), standard major axis (SMA) and ranged major axis (RMA) regression by
means of function <code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code>. Please see the
documentation, including the vignette of package 'lmodel2' for details.
The parameters in <code>stat_ma_eq()</code> follow the same naming as in function
<code>lmodel2()</code>.
</p>
<p>It is important to keep in mind that although the fitted line does not
depend on whether the <code class="reqn">x</code> or <code class="reqn">y</code> appears on the rhs of the model
formula, the numeric estimates for the parameters do depend on this.
</p>
<p>A ggplot statistic receives as <code>data</code> a data frame that is not the one
passed as argument by the user, but instead a data frame with the variables
mapped to aesthetics. <code>stat_ma_eq()</code> mimics how <code>stat_smooth()</code>
works, except that only linear regression can be fitted. Similarly to these
statistics the model fits respect grouping, so the scales used for <code>x</code>
and <code>y</code> should both be continuous scales rather than discrete.
</p>
<p>The minimum number of observations with distinct values can be set through
parameter <code>n.min</code>. The default <code>n.min = 2L</code> is the smallest
possible value. However, model fits with very few observations are of
little interest and using a larger number for <code>n.min</code> than the default
is usually wise.
</p>


<h3>Value</h3>

<p>A data frame, with a single row and columns as described under
<strong>Computed variables</strong>. In cases when the number of observations is
less than <code>n.min</code> a data frame with no rows or columns is returned
rendered as an empty/invisible plot layer.
</p>


<h3>Aesthetics</h3>

<p><code>stat_ma_eq</code> understands <code>x</code> and <code>y</code>, to
be referenced in the <code>formula</code> while the <code>weight</code> aesthetic is
ignored. Both <code>x</code> and <code>y</code> must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"text"</code> is the default) are understood and grouping respected.
</p>
<p><em>Transformation of <code>x</code> or <code>y</code> within the model formula
is not supported by <code>stat_ma_eq()</code>. In this case, transformations
should never be applied in the model formula, but instead in the mapping
of the variables within <code>aes</code>.</em>
</p>


<h3>Computed variables</h3>

<p>If output.type different from <code>"numeric"</code> the returned tibble contains
columns listed below. If the fitted model does not contain a given value,
the label is set to <code>character(0L)</code>.
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>eq.label</dt><dd><p>equation for the fitted polynomial as a character string to be parsed</p>
</dd>
<dt>rr.label</dt><dd><p><code class="reqn">R^2</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>p.value.label</dt><dd><p>P-value if available, depends on <code>method</code>.</p>
</dd>
<dt>theta.label</dt><dd><p>Angle in degrees between the two OLS lines for lines estimated from <code>y ~ x</code> and <code>x ~ y</code> linear model (<code>lm</code>) fits.</p>
</dd>
<dt>n.label</dt><dd><p>Number of observations used in the fit.</p>
</dd>
<dt>grp.label</dt><dd><p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>method.label</dt><dd><p>Set according <code>method</code> used.</p>
</dd>
<dt>r.squared, theta, p.value, n</dt><dd><p>numeric values, from the model fit object</p>
</dd></dl>

<p>If output.type is <code>"numeric"</code> the returned tibble contains columns
listed below. If the model fit function used does not return a value,
the variable is set to <code>NA_real_</code>.
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>coef.ls</dt><dd><p>list containing the &quot;coefficients&quot; matrix from the summary of the fit object</p>
</dd>
<dt>r.squared, theta, p.value, n</dt><dd><p>numeric values, from the model fit object</p>
</dd>
<dt>grp.label</dt><dd><p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>b_0.constant</dt><dd><p>TRUE is polynomial is forced through the origin</p>
</dd>
<dt>b_i</dt><dd><p>One or two columns with the coefficient estimates</p>
</dd></dl>

<p>To explore the computed values returned for a given input we suggest the use
of <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> as shown in the last examples below.
</p>


<h3>Note</h3>

<p>For backward compatibility a logical is accepted as argument for
<code>eq.with.lhs</code>. If <code>TRUE</code>, the default is used, either
<code>"x"</code> or <code>"y"</code>, depending on the argument passed to <code>formula</code>.
However, <code>"x"</code> or <code>"y"</code> can be substituted by providing a
suitable replacement character string through <code>eq.x.rhs</code>.
Parameter <code>orientation</code> is redundant as it only affects the default
for <code>formula</code> but is included for consistency with
<code>ggplot2::stat_smooth()</code>.
</p>
<p>Methods in <code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code> are all computed always except
for RMA that requires a numeric argument to at least one of <code>range.y</code>
or <code>range.x</code>. The results for specific methods are extracted a
posteriori from the model fit object. When a function is passed as argument
to <code>method</code>, the method can be passed in a list to <code>method.args</code>
as member <code>method</code>. More easily, the name of the function can be
passed as a character string together with the <code>lmodel2</code>-supported
method.
</p>
<p>R option <code>OutDec</code> is obeyed based on its value at the time the plot
is rendered, i.e., displayed or printed. Set <code>options(OutDec = ",")</code>
for languages like Spanish or French.
</p>


<h3>See Also</h3>

<p>The major axis regression model is fitted with function
<code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code>, please consult its documentation. Statistic
<code>stat_ma_eq()</code> can return different ready formatted labels depending
on the argument passed to <code>output.type</code>. If ordinary least squares
polynomial regression is desired, then <code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code>. If
quantile-fitted polynomial regression is desired,
<code><a href="#topic+stat_quant_eq">stat_quant_eq</a></code> should be used. For other types of models such
as non-linear models, statistics <code><a href="#topic+stat_fit_glance">stat_fit_glance</a></code> and
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a></code> should be used and the code for construction of
character strings from numeric values and their mapping to aesthetic
<code>label</code> explicitly supplied in the call.
</p>
<p>Other ggplot statistics for major axis regression: 
<code><a href="#topic+stat_ma_line">stat_ma_line</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(98723)
my.data &lt;- data.frame(x = rnorm(100) + (0:99) / 10 - 5,
                      y = rnorm(100) + (0:99) / 10 - 5,
                      group = c("A", "B"))

# using defaults (major axis regression)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line() +
  stat_ma_eq()

# use_label() can assemble and map a combined label
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA") +
  stat_ma_eq(use_label(c("eq", "R2", "P")))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA") +
  stat_ma_eq(use_label(c("R2", "P", "theta", "method")))

# using ranged major axis regression
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "RMA",
               range.y = "interval",
               range.x = "interval") +
  stat_ma_eq(use_label(c("eq", "R2", "P")),
             method = "RMA",
             range.y = "interval",
             range.x = "interval")

# No permutation-based test
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA") +
  stat_ma_eq(use_label(c("eq", "R2")),
             method = "MA",
             nperm = 0)

# explicit formula "x explained by y"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(formula = x ~ y) +
  stat_ma_eq(formula = x ~ y,
             use_label(c("eq", "R2", "P")))

# modifying both variables within aes()
ggplot(my.data, aes(log(x + 10), log(y + 10))) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq(use_label("eq"),
               eq.x.rhs = "~~log(x+10)",
               eq.with.lhs = "log(y+10)~~`=`~~")

# grouping
ggplot(my.data, aes(x, y, color = group)) +
  geom_point() +
  stat_ma_line() +
  stat_ma_eq()

# labelling equations
ggplot(my.data,
       aes(x, y,  shape = group, linetype = group, grp.label = group)) +
  geom_point() +
  stat_ma_line(color = "black") +
  stat_ma_eq(use_label(c("grp", "eq", "R2"))) +
  theme_classic()

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics with after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

# default is output.type = "expression"
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(geom = "debug")

## Not run: 
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(aes(label = after_stat(eq.label)),
               geom = "debug",
               output.type = "markdown")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(geom = "debug", output.type = "text")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_ma_eq(geom = "debug", output.type = "numeric")

## End(Not run)

</code></pre>

<hr>
<h2 id='stat_ma_line'>Predicted line from major axis linear fit</h2><span id='topic+stat_ma_line'></span>

<h3>Description</h3>

<p>Predicted values and a confidence band are computed and, by default, plotted.
<code>stat_ma_line()</code> behaves similarly to <code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code>
except for fitting the model with <code>lmodel2::lmodel2()</code> with <code>"MA"</code>
as default for <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_ma_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = "lmodel2:MA",
  method.args = list(),
  n.min = 2L,
  formula = NULL,
  range.y = NULL,
  range.x = NULL,
  se = TRUE,
  fm.values = FALSE,
  n = 80,
  nperm = 99,
  fullrange = FALSE,
  level = 0.95,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_ma_line_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be set at the layer level if you
are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;MA&quot;, &quot;SMA&quot; , &quot;RMA&quot; or
&quot;OLS&quot;, alternatively &quot;lmodel2&quot; or the name of a model fit function are
accepted, possibly followed by the fit function's <code>method</code> argument
separated by a colon (e.g. <code>"lmodel2:MA"</code>). If a function different to
<code>lmodel2()</code>, it must accept arguments named <code>formula</code>,
<code>data</code>, <code>range.y</code>, <code>range.x</code> and <code>nperm</code> and return a
model fit object of class <code>lmodel2</code>.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_range.y">range.y</code>, <code id="stat_ma_line_+3A_range.x">range.x</code></td>
<td>
<p>character Pass &quot;relative&quot; or &quot;interval&quot; if method
&quot;RMA&quot; is to be computed.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_se">se</code></td>
<td>
<p>logical Return confidence interval around smooth? ('TRUE' by
default, see 'level' to control.)</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_fm.values">fm.values</code></td>
<td>
<p>logical Add R2, p-value and n as columns to returned data?
('FALSE' by default.)</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_nperm">nperm</code></td>
<td>
<p>integer Number of permutation used to estimate significance.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_fullrange">fullrange</code></td>
<td>
<p>Should the fit span the full range of the plot, or just
the data?</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_level">level</code></td>
<td>
<p>Level of confidence interval to use (only 0.95 currently).</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_ma_line_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic fits major axis (<code>"MA"</code>) and other model II
regressions with function <code><a href="lmodel2.html#topic+lmodel2">lmodel2</a></code>. Model II
regression is called for when both <code>x</code> and <code>y</code> are subject to
random variation and the intention is not to predict <code>y</code> from <code>x</code>
by means of the model but rather to study the relationship between two
independent variables. A frequent case in biology are allometric
relationships among body parts.
</p>
<p>As the fitted line is the same whether <code>x</code> or <code>y</code> is on the rhs
of the model equation, <code>orientation</code> even if accepted does not have an
effect on the fit. In contrast, <code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code> treats
each axis differently and can thus have two orientations. The orientation
is easy to deduce from the argument passed to <code>formula</code>. Thus,
<code>stat_ma_line()</code> will by default guess which orientation the layer
should have. If no argument is passed to <code>formula</code>, the orientation
can be specified directly passing an argument to the <code>orientation</code>
parameter, which can be either <code>"x"</code> or <code>"y"</code>. The value gives
the axis that is on the rhs of the model equation, <code>"x"</code> being the
default orientation. Package 'ggpmisc' does not define new geometries
matching the new statistics as they are not needed and conceptually
transformations of <code>data</code> are expressed as statistics.
</p>
<p>The minimum number of observations with distinct values can be set through
parameter <code>n.min</code>. The default <code>n.min = 2L</code> is the smallest
possible value. However, model fits with very few observations are of
little interest and using a larger number for <code>n.min</code> than the default
is wise.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values and their confidence limits. Optionally
it will also include additional values related to the model fit.
</p>


<h3>Computed variables</h3>

<p>'stat_ma_line()' provides the following
variables, some of which depend on the orientation: </p>
 <dl>
<dt>y *or*
x</dt><dd><p>predicted value</p>
</dd> <dt>ymin *or* xmin</dt><dd><p>lower pointwise confidence
interval around the mean</p>
</dd> <dt>ymax *or* xmax</dt><dd><p>upper pointwise confidence
interval around the mean</p>
</dd> <dt>se</dt><dd><p>standard error</p>
</dd> </dl>

<p>If <code>fm.values = TRUE</code> is passed then columns based on the summary of
the model fit are added, with the same value in each row within a group.
This is wasteful and disabled by default, but provides a simple and robust
approach to achieve effects like colouring or hiding of the model fit line
based on P-values, r-squared or the number of observations.
</p>


<h3>Aesthetics</h3>

<p><code>stat_ma_line</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code>. Both must be mapped to
<code>numeric</code> variables. In addition, the aesthetics understood by the
geom (<code>"geom_smooth"</code> is the default) are understood and grouping
respected.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for major axis regression: 
<code><a href="#topic+stat_ma_eq">stat_ma_eq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(98723)
my.data &lt;- data.frame(x = rnorm(100) + (0:99) / 10 - 5,
                      y = rnorm(100) + (0:99) / 10 - 5,
                      group = c("A", "B"))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "MA")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "SMA")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "RMA",
               range.y = "interval", range.x = "interval")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(method = "OLS")

# plot line to the ends of range of data (the default)
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(fullrange = FALSE) +
  expand_limits(x = c(-10, 10), y = c(-10, 10))

# plot line to the limits of the scales
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(fullrange = TRUE) +
  expand_limits(x = c(-10, 10), y = c(-10, 10))

# plot line to the limits of the scales
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(orientation = "y", fullrange = TRUE) +
  expand_limits(x = c(-10, 10), y = c(-10, 10))

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line(formula = x ~ y)

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(my.data, aes(x, y, colour = group)) +
  geom_point() +
  stat_ma_line()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_ma_line() +
  facet_wrap(~group)

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    stat_ma_line(geom = "debug")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    stat_ma_line(geom = "debug", fm.values = TRUE)

</code></pre>

<hr>
<h2 id='stat_multcomp'>Labels for multiple comparisons</h2><span id='topic+stat_multcomp'></span>

<h3>Description</h3>

<p><code>stat_multcomp</code> fits a linear model by default with <code>stats::lm()</code>
but alternatively using other model fit functions. The model is passed to
function <code>glht()</code> from package 'multcomp' to fit Tukey or Dunnet
contrasts and generates labels based on adjusted <em>P</em>-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_multcomp(
  mapping = NULL,
  data = NULL,
  geom = NULL,
  position = "identity",
  ...,
  formula = NULL,
  method = "lm",
  method.args = list(),
  contrast.type = "Tukey",
  adjusted.type = "single-step",
  small.p = FALSE,
  p.digits = 3,
  label.type = "bars",
  fm.cutoff.p.value = 1,
  mc.cutoff.p.value = 1,
  mc.critical.p.value = 0.05,
  label.y = NULL,
  vstep = NULL,
  output.type = NULL,
  na.rm = FALSE,
  orientation = NA,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_multcomp_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;lm&quot; (or its equivalent
&quot;aov&quot;), &quot;rlm&quot; or the name of a model fit function are accepted, possibly
followed by the fit function's <code>method</code> argument separated by a colon
(e.g. <code>"rlm:M"</code>). If a function different to <code>lm()</code>, it must
accept as a minimum a model formula through its first parameter, and have
formal parameters named <code>data</code>, <code>weights</code>, and <code>method</code>, and
return a model fit object accepted by function <code>glht()</code>.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_contrast.type">contrast.type</code></td>
<td>
<p>character One of &quot;Tukey&quot; or &quot;Dunnet&quot;.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_adjusted.type">adjusted.type</code></td>
<td>
<p>character As the argument for parameter <code>type</code> of
function <code>adjusted()</code> passed as argument to parameter <code>test</code> of
<code><a href="multcomp.html#topic+summary.glht">summary.glht</a></code>. Accepted values are &quot;single-step&quot;,
&quot;Shaffer&quot;, &quot;Westfall&quot;, &quot;free&quot;, &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;,
&quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_small.p">small.p</code></td>
<td>
<p>logical If true, use of lower case <em>p</em> instead of capital
<em>P</em> as the symbol for <em>P</em>-value in labels.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_p.digits">p.digits</code></td>
<td>
<p>integer Number of digits after the decimal point to
use for <code class="reqn">R^2</code> and <em>P</em>-value in labels.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_label.type">label.type</code></td>
<td>
<p>character One of &quot;bars&quot;, &quot;letters&quot; or &quot;LETTERS&quot;, selects
how the results of the multiple comparisons are displayed. Only &quot;bars&quot; can
be used together with <code>contrast.type = "Dunnet"</code>.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_fm.cutoff.p.value">fm.cutoff.p.value</code></td>
<td>
<p>numeric [0..1] The <em>P</em>-value for the main effect of
factor <code>x</code> in the ANOVA test for the fitted model above which no
pairwise comparisons are computed or labels generated. Be aware that recent
literature tends to recommend to consider which testing approach is
relevant to the problem at hand instead of requiring the significance of
the main effect before applying multiple comparisons' tests. The default
value is 1, imposing no restrictions.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_mc.cutoff.p.value">mc.cutoff.p.value</code></td>
<td>
<p>numeric [0..1] The <em>P</em>-value for the individual
contrasts above which no labelled bars are generated. Default is 1,
labelling all pairwise contrasts tested.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_mc.critical.p.value">mc.critical.p.value</code></td>
<td>
<p>numeric The critical <em>P</em>-value used for tests when
when encoded as letters.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_label.y">label.y</code></td>
<td>
<p>numeric vector Values in native data units or if
<code>character</code>, one of &quot;top&quot; or &quot;bottom&quot;. Recycled if too short and
truncated if too long.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal displacement step-size
used between labels for different contrasts when <code>label.type = "bars"</code>.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_output.type">output.type</code></td>
<td>
<p>character One of &quot;expression&quot;, &quot;LaTeX&quot;, &quot;text&quot;,
&quot;markdown&quot; or &quot;numeric&quot;.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>. <strong>Support for <code>orientation</code> is not yet implemented but is
planned.</strong></p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_parse">parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_multcomp_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic can be used to automatically annotate a plot with
<em>P</em>-values for multiple comparison tests, based on Tukey contrasts
(all pairwise) or Dunnet contrasts (other levels against the first one).
See Meier (2022, Chapter 3) for an accessible explanation of multiple
comparisons and contrasts with package 'multcomp', of which
<code>stat_multcomp()</code> is mostly a wrapper.
</p>
<p>The explanatory variable mapped to the <em>x</em> aesthetic must be a factor
as this creates the required grouping. Currently, arbitrary contrasts are
not supported, mainly because they would be difficult to convert into plot
annotations.
</p>
<p>Two ways of displaying the outcomes are implemented, and are selected by
'&quot;bars&quot;', '&quot;letters&quot;' or '&quot;LETTERS&quot;' as argument to parameter
'label.type'. '&quot;letters&quot;' and '&quot;LETTERS&quot;' can be used only with Tukey
contrasts, as otherwise the encoding is ambiguous. As too many bars clutter
a plot, the maximum number of factor levels supported for '&quot;bars&quot;' together
with Tukey contrasts is five, and together with Dunnet contrasts, unlimited.
</p>
<p><code>stat_multcomp()</code> by default generates character labels ready to be
parsed as R expressions but LaTeX (use TikZ device), markdown (use package
'ggtext') and plain text are also supported, as well as numeric values for
user-generated text labels. The value of <code>parse</code> is set automatically
based on <code>output.type</code>, but if you assemble labels that need parsing
from <code>numeric</code> output, the default needs to be overridden. This
statistic only generates annotation labels and segments connecting the
compared factor levels, or letter labels that discriminate significantly
different groups.
</p>


<h3>Value</h3>

<p>A data frame with one row per comparison for <code>label.type =
  "bars"</code>, or a data frame with one row per factor <code>x</code> level for
<code>label.type = "letters"</code> and for <code>label.type = "LETTERS"</code>.
Variables (= columns) as described under <strong>Computed variables</strong>.
</p>


<h3>Aesthetics</h3>

<p><code>stat_multcomp()</code> understands <code>x</code> and
<code>y</code>, to be referenced in the <code>formula</code> and <code>weight</code> passed
as argument to parameter <code>weights</code>. A factor must be mapped to
<code>x</code> and <code>numeric</code> variables to <code>y</code>, and, if used, to
<code>weight</code>. In addition, the aesthetics understood by the geom
(<code>"label_pairwise"</code> is the default for <code>label.type = "bars"</code>,
<code>"text"</code> is the default for <code>label.type = "letters"</code> and for
<code>label.type = "LETTERS"</code>) are understood and grouping
respected.
</p>


<h3>Computed variables</h3>

<p>If <code>output.type = "numeric"</code> and
<code>label.type = "bars"</code> the returned tibble contains
columns listed below. In all cases if the model fit function used does not return a value,
the label is set to <code>character(0L)</code> and the numeric value to <code>NA</code>.
</p>

<dl>
<dt>x,x.left.tip,x.right.tip</dt><dd><p>x position, numeric.</p>
</dd>
<dt>y</dt><dd><p>y position, numeric.</p>
</dd>
<dt>coefficients</dt><dd><p>Delta estimate from pairwise contrasts, numeric.</p>
</dd>
<dt>contrasts</dt><dd><p>Contrasts as two levels' ordinal &quot;numbers&quot; separated by a dash, character.</p>
</dd>
<dt>tstat</dt><dd><p><em>t</em>-statistic estimates for the pairwise contrasts, numeric.</p>
</dd>
<dt>p.value</dt><dd><p><em>P</em>-value for the pairwise contrasts.</p>
</dd>
<dt>fm.method</dt><dd><p>Set according <code>method</code> used.</p>
</dd>
<dt>fm.class</dt><dd><p>Most derived class of the fitted model object.</p>
</dd>
<dt>fm.formula</dt><dd><p>Formula extracted from the fitted model object if available, or the formula argument.</p>
</dd>
<dt>fm.formula.chr</dt><dd><p>Formula extracted from the fitted model object if available, or the formula argument, formatted as character.</p>
</dd>
<dt>mc.adjusted</dt><dd><p>The method used to adjust the <em>P</em>-values.</p>
</dd>
<dt>mc.contrast</dt><dd><p>The type of contrast used for multiple comparisons.</p>
</dd>
<dt>n</dt><dd><p>The total number of observations or rows in data.</p>
</dd>
<dt>default.label</dt><dd><p>text label, always included, but possibly NA.</p>
</dd>
</dl>

<p>If output.type is not <code>"numeric"</code> the returned data frame includes in
addition the following labels:
</p>

<dl>
<dt>stars.label</dt><dd><p><em>P</em>-value for the pairwise contrasts encoded as &quot;starts&quot;, character.</p>
</dd>
<dt>p.value.label</dt><dd><p><em>P</em>-value for the pairwise contrasts, character.</p>
</dd>
<dt>delta.label</dt><dd><p>The coefficient or estimate for the difference between compared pairs of levels.</p>
</dd>
<dt>t.value.label</dt><dd><p><em>t</em>-statistic estimates for the pairwise contrasts, character.</p>
</dd>
</dl>

<p>If <code>label.type = "letters"</code> or <code>label.type = "LETTERS"</code> the returned tibble contains
columns listed below.
</p>

<dl>
<dt>x,x.left.tip,x.right.tip</dt><dd><p>x position, numeric.</p>
</dd>
<dt>y</dt><dd><p>y position, numeric.</p>
</dd>
<dt>critical.p.value</dt><dd><p><em>P</em>-value used in pairwise tests, numeric.</p>
</dd>
<dt>fm.method</dt><dd><p>Set according <code>method</code> used.</p>
</dd>
<dt>fm.class</dt><dd><p>Most derived class of the fitted model object.</p>
</dd>
<dt>fm.formula</dt><dd><p>Formula extracted from the fitted model object if available, or the formula argument.</p>
</dd>
<dt>fm.formula.chr</dt><dd><p>Formula extracted from the fitted model object if available, or the formula argument, formatted as character.</p>
</dd>
<dt>mc.adjusted</dt><dd><p>The method used to adjust the <em>P</em>-values.</p>
</dd>
<dt>mc.contrast</dt><dd><p>The type of contrast used for multiple comparisons.</p>
</dd>
<dt>n</dt><dd><p>The total number of observations or rows in data.</p>
</dd>
<dt>default.label</dt><dd><p>text label, always included, but possibly NA.</p>
</dd>
</dl>

<p>If output.type is not <code>"numeric"</code> the returned data frame includes in
addition the following labels:
</p>

<dl>
<dt>letters.label</dt><dd><p>Letters that distinguish levels based on significance from multiple comparisons test.</p>
</dd>
</dl>



<h3>Alternatives</h3>

<p><code>stat_signif()</code> in package 'ggsignif' is
an earlier and independent implementation of pairwise tests.
</p>


<h3>Note</h3>

<p>R option <code>OutDec</code> is obeyed based on its value at the time the plot
is rendered, i.e., displayed or printed. Set <code>options(OutDec = ",")</code>
for languages like Spanish or French.
</p>


<h3>References</h3>

<p>Meier, Lukas (2022) <em>ANOVA and Mixed Models: A Short Introduction
Using R</em>. Chapter 3 Contrasts and Multiple Testing. The R Series. Boca Raton:
Chapman and Hall/CRC. ISBN: 9780367704209, <a href="https://doi.org/10.1201/9781003146216">doi:10.1201/9781003146216</a>.
</p>


<h3>See Also</h3>

<p>This statistic uses the implementation of Tests of General Linear
Hypotheses in function <code><a href="multcomp.html#topic+glht">glht</a></code>. See
<code><a href="multcomp.html#topic+summary.glht">summary.glht</a></code> and <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
for the supported and tests and the references therein for the theory
behind them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p1 &lt;- ggplot(mpg, aes(factor(cyl), hwy)) +
  geom_boxplot(width = 0.33)

## labeleld bars

p1 +
  stat_multcomp()

# test against a control, with first level being the control
# change order of factor levels in data to set the control group
p1 +
  stat_multcomp(contrast.type = "Dunnet")

# different methods to adjust the contrasts
p1 +
  stat_multcomp(adjusted.type = "bonferroni")

p1 +
  stat_multcomp(adjusted.type = "holm")

p1 +
  stat_multcomp(adjusted.type = "fdr")

# sometimes we need to expand the plotting area
p1 +
  stat_multcomp(geom = "text_pairwise") +
  scale_y_continuous(expand = expansion(mult = c(0.05, 0.10)))

# position of contrasts' bars (based on scale limits)
p1 +
  stat_multcomp(label.y = "bottom")

p1 +
  stat_multcomp(label.y = 11)

# use different labels: difference and P-value from hypothesis tests
p1 +
  stat_multcomp(use_label(c("Delta", "P")),
                size = 2.75)

# control smallest P-value displayed and number of digits
p1 +
  stat_multcomp(p.digits = 4)

# label only significant differences
# but test and correct for all pairwise contrasts!
p1 +
  stat_multcomp(mc.cutoff.p.value = 0.01)

## letters as labels for test results

p1 +
  stat_multcomp(label.type = "letters")

# use capital letters
p1 +
  stat_multcomp(label.type = "LETTERS")

# location
p1 +
  stat_multcomp(label.type = "letters",
                label.y = "top")

p1 +
  stat_multcomp(label.type = "letters",
                label.y = 0)

# stricter critical p-value than default used for test
p1 +
  stat_multcomp(label.type = "letters",
                mc.critical.p.value = 0.01)

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics with after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
p1 +
  stat_multcomp(label.type = "bars",
                geom = "debug")

if (gginnards.installed)
p1 +
  stat_multcomp(label.type = "letters",
                geom = "debug")

if (gginnards.installed)
p1 +
  stat_multcomp(label.type = "bars",
                output.type = "numeric",
                geom = "debug")

</code></pre>

<hr>
<h2 id='stat_peaks'>Local maxima (peaks) or minima (valleys)</h2><span id='topic+stat_peaks'></span><span id='topic+stat_valleys'></span>

<h3>Description</h3>

<p><code>stat_peaks</code> finds at which x positions local y maxima are located and
<code>stat_valleys</code> finds at which x positions local y minima are located.
Both stats return a subset of <code>data</code> with rows matching for peaks or
valleys with formatted character labels added. The formatting is determined
by a format string compatible with <code>sprintf()</code> or <code>strftime()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_peaks(
  mapping = NULL,
  data = NULL,
  geom = "point",
  span = 5,
  ignore_threshold = 0,
  strict = FALSE,
  label.fmt = NULL,
  x.label.fmt = NULL,
  y.label.fmt = NULL,
  orientation = "x",
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_valleys(
  mapping = NULL,
  data = NULL,
  geom = "point",
  span = 5,
  ignore_threshold = 0,
  strict = FALSE,
  label.fmt = NULL,
  x.label.fmt = NULL,
  y.label.fmt = NULL,
  orientation = "x",
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_peaks_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_data">data</code></td>
<td>
<p>A layer specific dataset - only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_span">span</code></td>
<td>
<p>a peak is defined as an element in a sequence which is greater
than all other elements within a window of width span centered at that
element. The default value is 5, meaning that a peak is bigger than two
consecutive neighbors on each side. A <code>NULL</code> value for <code>span</code>
is taken as a span covering the whole of the data range.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_ignore_threshold">ignore_threshold</code></td>
<td>
<p>numeric value between 0.0 and 1.0 indicating the size
threshold below which peaks will be ignored.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_strict">strict</code></td>
<td>
<p>logical flag: if TRUE, an element must be strictly greater than
all other values in its window to be considered a peak. Default: FALSE.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_label.fmt">label.fmt</code></td>
<td>
<p>character  string giving a format definition for converting
values into character strings by means of function <code><a href="base.html#topic+sprintf">sprintf</a></code>
or <code><a href="base.html#topic+strptime">strptime</a></code>, its use is deprecated.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_x.label.fmt">x.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $x$-values into character strings by means of function
<code><a href="base.html#topic+sprintf">sprintf</a></code> or <code><a href="base.html#topic+strftime">strftime</a></code>. The default argument
varies depending on the scale in use.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_y.label.fmt">y.label.fmt</code></td>
<td>
<p>character  string giving a format definition for
converting $y$-values into character strings by means of function
<code><a href="base.html#topic+sprintf">sprintf</a></code>.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points
on this layer.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
<tr><td><code id="stat_peaks_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These stats use <code>geom_point</code> by default as it is the geom most
likely to work well in almost any situation without need of tweaking. The
default aesthetics set by these stats allow their direct use with
<code>geom_text</code>, <code>geom_label</code>, <code>geom_line</code>, <code>geom_rug</code>,
<code>geom_hline</code> and <code>geom_vline</code>. The formatting of the labels
returned can be controlled by the user.
</p>
<p>The default for parameter <code>strict</code> is <code>TRUE</code> in functions
<code>splus2R::peaks()</code> and <code>find_peaks()</code>, while the default is <code>FALSE</code>
in <code>stat_peaks()</code> and in <code>stat_valleys()</code>.
</p>


<h3>Returned and computed variables</h3>


<dl>
<dt>x</dt><dd><p>x-value at the peak (or valley) as numeric</p>
</dd>
<dt>y</dt><dd><p>y-value at the peak (or valley) as numeric</p>
</dd>
<dt>x.label</dt><dd><p>x-value at the peak (or valley) as character</p>
</dd>
<dt>y.label</dt><dd><p>y-value at the peak (or valley) as character</p>
</dd>
</dl>



<h3>Warning!</h3>

<p>The current version of these statistics do not support
passing <code>nudge_x</code> or <code>nurge_y</code> named parameters to the geometry.
Use 'position' and one of the position functions such as
<code><a href="ggpp.html#topic+position_nudge_keep">position_nudge_keep</a></code> instead.
</p>


<h3>Note</h3>

<p>These statistics check the scale of the <code>x</code> aesthetic and if it is
Date or Datetime they correctly generate the labels by transforming the
numeric <code>x</code> values to Date or POSIXct objects, respectively. In which
case the <code>x.label.fmt</code> must follow the syntax supported by
<code>strftime()</code> rather than by <code>sprintf()</code>. Overlap of labels with
points can avoided by use of one of the nudge positions, possibly together
with geometry <code><a href="ggpp.html#topic+geom_text_s">geom_text_s</a></code> from package
<code><a href="ggpp.html#topic+ggpp">ggpp</a></code>, or with <code><a href="ggrepel.html#topic+geom_text_repel">geom_text_repel</a></code> or
<code><a href="ggrepel.html#topic+geom_label_repel">geom_label_repel</a></code> from package
<code><a href="ggrepel.html#topic+ggrepel">ggrepel</a></code>. To discard overlapping labels use
<code>check_overlap = TRUE</code> as argument to <code>geom_text</code> or
<code>geom_text_s</code>. By default the labels are character values suitable to
be plotted as is, but with a suitable format passed as argument to
<code>label.fmt</code> labels suitable for parsing by the geoms (e.g. into
expressions containing Greek letters, super- or subscripts, maths symbols
or maths constructs) can be also easily obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># lynx is a time.series object
lynx_num.df &lt;-
  try_tibble(lynx,
             col.names = c("year", "lynx"),
             as.numeric = TRUE) # years -&gt; as numeric

ggplot(lynx_num.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_valleys(colour = "blue")

ggplot(lynx_num.df, aes(lynx, year)) +
  geom_line(orientation = "y") +
  stat_peaks(colour = "red", orientation = "y") +
  stat_valleys(colour = "blue", orientation = "y")

ggplot(lynx_num.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red", geom = "rug")

ggplot(lynx_num.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red", geom = "text", hjust = -0.1, angle = 33)

ggplot(lynx_num.df, aes(lynx, year)) +
  geom_line(orientation = "y") +
  stat_peaks(colour = "red", orientation = "y") +
  stat_peaks(colour = "red", orientation = "y",
             geom = "text", hjust = -0.1)

lynx_datetime.df &lt;-
   try_tibble(lynx,
              col.names = c("year", "lynx")) # years -&gt; POSIXct

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_valleys(colour = "blue")

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red",
             geom = "text",
             hjust = -0.1,
             x.label.fmt = "%Y",
             angle = 33)

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red") +
  stat_peaks(colour = "red",
             geom = "text_s",
             position = position_nudge_keep(x = 0, y = 200),
             hjust = -0.1,
             x.label.fmt = "%Y",
             angle = 90) +
  expand_limits(y = 8000)

ggplot(lynx_datetime.df, aes(year, lynx)) +
  geom_line() +
  stat_peaks(colour = "red",
             geom = "text_s",
             position = position_nudge_to(y = 7600),
             arrow = arrow(length = grid::unit(1.5, "mm")),
             point.padding = 0.7,
             x.label.fmt = "%Y",
             angle = 90) +
  expand_limits(y = 9000)

</code></pre>

<hr>
<h2 id='stat_poly_eq'>Equation, p-value, <code class="reqn">R^2</code>, AIC and BIC of fitted polynomial</h2><span id='topic+stat_poly_eq'></span>

<h3>Description</h3>

<p><code>stat_poly_eq</code> fits a polynomial by default with <code>stats::lm()</code> but
alternatively using robust regression. From the fitted model it
generates several labels including the equation, p-value, F-value,
coefficient of determination (R^2), 'AIC', 'BIC', and number of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_poly_eq(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  ...,
  formula = NULL,
  method = "lm",
  method.args = list(),
  n.min = 2L,
  eq.with.lhs = TRUE,
  eq.x.rhs = NULL,
  small.r = FALSE,
  small.p = FALSE,
  CI.brackets = c("[", "]"),
  rsquared.conf.level = 0.95,
  coef.digits = 3,
  coef.keep.zeros = TRUE,
  rr.digits = 2,
  f.digits = 3,
  p.digits = 3,
  label.x = "left",
  label.y = "top",
  label.x.npc = NULL,
  label.y.npc = NULL,
  hstep = 0,
  vstep = NULL,
  output.type = NULL,
  na.rm = FALSE,
  orientation = NA,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_poly_eq_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;lm&quot;, &quot;rlm&quot; or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rlm:M"</code>). If a
function different to <code>lm()</code>, it must accept as a minimum a model
formula through its first parameter, and have formal parameters named
<code>data</code>, <code>weights</code>, and <code>method</code>, and return a model fit
object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_eq.with.lhs">eq.with.lhs</code></td>
<td>
<p>If <code>character</code> the string is pasted to the front of
the equation label before parsing or a <code>logical</code> (see note).</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_eq.x.rhs">eq.x.rhs</code></td>
<td>
<p><code>character</code> this string will be used as replacement for
<code>"x"</code> in the model equation when generating the label before parsing
it.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_small.r">small.r</code>, <code id="stat_poly_eq_+3A_small.p">small.p</code></td>
<td>
<p>logical Flags to switch use of lower case r and p for
coefficient of determination and p-value.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_ci.brackets">CI.brackets</code></td>
<td>
<p>character vector of length 2. The opening and closing
brackets used for the CI label.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_rsquared.conf.level">rsquared.conf.level</code></td>
<td>
<p>numeric Confidence level for the returned
confidence interval. Set to NA to skip CI computation.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_coef.digits">coef.digits</code>, <code id="stat_poly_eq_+3A_f.digits">f.digits</code></td>
<td>
<p>integer Number of significant digits to use for
the fitted coefficients and F-value.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_coef.keep.zeros">coef.keep.zeros</code></td>
<td>
<p>logical Keep or drop trailing zeros when formatting
the fitted coefficients and F-value.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_rr.digits">rr.digits</code>, <code id="stat_poly_eq_+3A_p.digits">p.digits</code></td>
<td>
<p>integer Number of digits after the decimal point to
use for <code class="reqn">R^2</code> and P-value in labels.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_label.x">label.x</code>, <code id="stat_poly_eq_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 &quot;normalized parent
coordinates&quot; (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_label.x.npc">label.x.npc</code>, <code id="stat_poly_eq_+3A_label.y.npc">label.y.npc</code></td>
<td>
<p><code>numeric</code> with range 0..1 (npc units)
DEPRECATED, use label.x and label.y instead; together with a geom
using npcx and npcy aesthetics.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_hstep">hstep</code>, <code id="stat_poly_eq_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_output.type">output.type</code></td>
<td>
<p>character One of &quot;expression&quot;, &quot;LaTeX&quot;, &quot;text&quot;,
&quot;markdown&quot; or &quot;numeric&quot;.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_parse">parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_poly_eq_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic can be used to automatically annotate a plot with
<code class="reqn">R^2</code>, adjusted <code class="reqn">R^2</code> or the fitted model equation. It supports
linear regression, robust linear regression and median regression fitted
with functions <code><a href="stats.html#topic+lm">lm</a></code>, or <code><a href="MASS.html#topic+rlm">rlm</a></code>. The <code class="reqn">R^2</code>
and adjusted <code class="reqn">R^2</code> annotations can be used with any linear model
formula. The confidence interval for <code class="reqn">R^2</code> is computed with function
<code><a href="confintr.html#topic+ci_rsquared">ci_rsquared</a></code> from package 'confintr'. The fitted
equation label is correctly generated for polynomials or quasi-polynomials
through the origin. Model formulas can use <code>poly()</code> or be defined
algebraically with terms of powers of increasing magnitude with no missing
intermediate terms, except possibly for the intercept indicated by &quot;- 1&quot; or
&quot;-1&quot; or <code>"+ 0"</code> in the formula. The validity of the <code>formula</code> is
not checked in the current implementation, and for this reason the default
aesthetics sets <code class="reqn">R^2</code> as label for the annotation. This statistic
generates labels as R expressions by default but LaTeX (use TikZ device),
markdown (use package 'ggtext') and plain text are also supported, as well
as numeric values for user-generated text labels. The value of <code>parse</code>
is set automatically based on <code>output-type</code>, but if you assemble
labels that need parsing from <code>numeric</code> output, the default needs to
be overridden. This stat only generates annotation labels, the predicted
values/line need to be added to the plot as a separate layer using
<code><a href="#topic+stat_poly_line">stat_poly_line</a></code> (or <code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code>), if
the default formula is overriden with an argument, it is crucial to make
sure that the same model formula is used in all layers. In this case it is
best to save the formula as an object and supply this object as argument to
the different statistics.
</p>
<p>A ggplot statistic receives as <code>data</code> a data frame that is not the one
passed as argument by the user, but instead a data frame with the variables
mapped to aesthetics. <code>stat_poly_eq()</code> mimics how <code>stat_smooth()</code>
works, except that only polynomials can be fitted. Similarly to these
statistics the model fits respect grouping, so the scales used for <code>x</code>
and <code>y</code> should both be continuous scales rather than discrete.
</p>
<p>With method <code>"lm"</code>, singularity results in terms being dropped with a
message if more numerous than can be fitted with a singular (exact) fit.
In this case or if the model results in a perfect fit due to a low
number of observations, estimates for various parameters are <code>NaN</code> or
<code>NA</code>. When this is the case the corresponding labels are set to
<code>character(0L)</code> and thus not visble in the plot.
</p>
<p>With methods other than <code>"lm"</code>, the model fit functions simply fail
in case of singularity, e.g., singular fits are not implemented in
<code>"rlm"</code>.
</p>
<p>In both cases the minimum number of observations with distinct values in
the explanatory variable can be set through parameter <code>n.min</code>. The
default <code>n.min = 2L</code> is the smallest suitable for method <code>"lm"</code>
but too small for method <code>"rlm"</code> for which <code>n.min = 3L</code> is
needed. Anyway, model fits with very few observations are of little
interest and using larger values of <code>n.min</code> than the default is
usually wise.
</p>


<h3>Value</h3>

<p>A data frame, with a single row and columns as described under
<strong>Computed variables</strong>. In cases when the number of observations is
less than <code>n.min</code> a data frame with no rows or columns is returned
rendered as an empty/invisible plot layer.
</p>


<h3>Aesthetics</h3>

<p><code>stat_poly_eq()</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code>. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"text"</code> is the default) are understood and grouping respected.
</p>
<p><em>If the model formula includes a transformation of <code>x</code>, a
matching argument should be passed to parameter <code>eq.x.rhs</code>
as its default value <code>"x"</code> will not reflect the applied
transformation. In plots, transformation should never be applied to the
left hand side of the model formula, but instead in the mapping of the
variable within <code>aes</code>, as otherwise plotted observations and fitted
curve will not match. In this case it may be necessary to also pass
a matching argument to parameter <code>eq.with.lhs</code>.</em>
</p>


<h3>Computed variables</h3>

<p>If output.type different from <code>"numeric"</code> the returned tibble contains
columns listed below. If the model fit function used does not return a value,
the label is set to <code>character(0L)</code>.
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>eq.label</dt><dd><p>equation for the fitted polynomial as a character string to be parsed</p>
</dd>
<dt>rr.label</dt><dd><p><code class="reqn">R^2</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>adj.rr.label</dt><dd><p>Adjusted <code class="reqn">R^2</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>rr.confint.label</dt><dd><p>Confidence interval for <code class="reqn">R^2</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>f.value.label</dt><dd><p>F value and degrees of freedom for the fitted model as a whole.</p>
</dd>
<dt>p.value.label</dt><dd><p>P-value for the F-value above.</p>
</dd>
<dt>AIC.label</dt><dd><p>AIC for the fitted model.</p>
</dd>
<dt>BIC.label</dt><dd><p>BIC for the fitted model.</p>
</dd>
<dt>n.label</dt><dd><p>Number of observations used in the fit.</p>
</dd>
<dt>grp.label</dt><dd><p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>method.label</dt><dd><p>Set according <code>method</code> used.</p>
</dd>
<dt>r.squared, adj.r.squared, p.value, n</dt><dd><p>numeric values, from the model fit object</p>
</dd></dl>

<p>If output.type is <code>"numeric"</code> the returned tibble contains columns
listed below. If the model fit function used does not return a value,
the variable is set to <code>NA_real_</code>.
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>coef.ls</dt><dd><p>list containing the &quot;coefficients&quot; matrix from the summary of the fit object</p>
</dd>
<dt>r.squared, rr.confint.level, rr.confint.low, rr.confint.high, adj.r.squared, f.value, f.df1, f.df2, p.value, AIC, BIC, n</dt><dd><p>numeric values, from the model fit object</p>
</dd>
<dt>grp.label</dt><dd><p>Set according to mapping in <code>aes</code>.</p>
</dd>
<dt>b_0.constant</dt><dd><p>TRUE is polynomial is forced through the origin</p>
</dd>
<dt>b_i</dt><dd><p>One or columns with the coefficient estimates</p>
</dd></dl>

<p>To explore the computed values returned for a given input we suggest the use
of <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> as shown in the last examples below.
</p>


<h3>Alternatives</h3>

<p><code>stat_regline_equation()</code> in package 'ggpubr' is
a renamed but almost unchanged copy of <code>stat_poly_eq()</code> taken from an
old version of this package (without acknowledgement of source and
authorship). <code>stat_regline_equation()</code> lacks important functionality
and contains bugs that have been fixed in <code>stat_poly_eq()</code>.
</p>


<h3>Note</h3>

<p>For backward compatibility a logical is accepted as argument for
<code>eq.with.lhs</code>. If <code>TRUE</code>, the default is used, either
<code>"x"</code> or <code>"y"</code>, depending on the argument passed to <code>formula</code>.
However, <code>"x"</code> or <code>"y"</code> can be substituted by providing a
suitable replacement character string through <code>eq.x.rhs</code>.
Parameter <code>orientation</code> is redundant as it only affects the default
for <code>formula</code> but is included for consistency with
<code>ggplot2::stat_smooth()</code>.
</p>
<p>R option <code>OutDec</code> is obeyed based on its value at the time the plot
is rendered, i.e., displayed or printed. Set <code>options(OutDec = ",")</code>
for languages like Spanish or French.
</p>


<h3>References</h3>

<p>Originally written as an answer to question 7549694 at
Stackoverflow but enhanced based on suggestions from users and my own
needs.
</p>


<h3>See Also</h3>

<p>This statistics fits a model with function <code><a href="stats.html#topic+lm">lm</a></code>,
function <code><a href="MASS.html#topic+rlm">rlm</a></code> or a user supplied function returning an
object of class <code>"lm"</code>. Consult the documentation of these functions
for the details and additional arguments that can be passed to them by name
through parameter <code>method.args</code>.
</p>
<p>This <code>stat_poly_eq</code> statistic can return ready formatted labels
depending on the argument passed to <code>output.type</code>. This is possible
because only polynomial and quasy-polynomial models are supported. For
quantile regression <code><a href="#topic+stat_quant_eq">stat_quant_eq</a></code> should be used instead of
<code>stat_poly_eq</code> while for model II or major axis regression
<code><a href="#topic+stat_ma_eq">stat_ma_eq</a></code> should be used. For other types of models such as
non-linear models, statistics <code><a href="#topic+stat_fit_glance">stat_fit_glance</a></code> and
<code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a></code> should be used and the code for construction of
character strings from numeric values and their mapping to aesthetic
<code>label</code> needs to be explicitly supplied by the user.
</p>
<p>Other ggplot statistics for linear and polynomial regression: 
<code><a href="#topic+stat_poly_line">stat_poly_line</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(4321)
x &lt;- 1:100
y &lt;- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
y &lt;- y / max(y)
my.data &lt;- data.frame(x = x, y = y,
                      group = c("A", "B"),
                      y2 = y * c(1, 2) + c(0, 0.1),
                      w = sqrt(x))

# give a name to a formula
formula &lt;- y ~ poly(x, 3, raw = TRUE)

# using defaults
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line() +
  stat_poly_eq()

# no weights
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula)

# other labels
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label("eq"), formula = formula)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("eq", "R2")), formula = formula)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("R2", "R2.CI", "P", "method")), formula = formula)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("R2", "F", "P", "n"), sep = "*\"; \"*"),
               formula = formula)

# grouping
ggplot(my.data, aes(x, y2, color = group)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula)

# rotation
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula, angle = 90)

# label location
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula, label.y = "bottom", label.x = "right")

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula, label.y = 0.1, label.x = 0.9)

# modifying the explanatory variable within the model formula
# modifying the response variable within aes()
formula.trans &lt;- y ~ I(x^2)
ggplot(my.data, aes(x, y + 1)) +
  geom_point() +
  stat_poly_line(formula = formula.trans) +
  stat_poly_eq(use_label("eq"),
               formula = formula.trans,
               eq.x.rhs = "~x^2",
               eq.with.lhs = "y + 1~~`=`~~")

# using weights
ggplot(my.data, aes(x, y, weight = w)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula)

# no weights, 4 digits for R square
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula, rr.digits = 4)

# manually assemble and map a specific label using paste() and aes()
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(aes(label =  paste(after_stat(rr.label),
                                  after_stat(n.label), sep = "*\", \"*")),
               formula = formula)

# manually assemble and map a specific label using sprintf() and aes()
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(aes(label =  sprintf("%s*\" with \"*%s*\" and \"*%s",
                                    after_stat(rr.label),
                                    after_stat(f.value.label),
                                    after_stat(p.value.label))),
               formula = formula)

# x on y regression
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula, orientation = "y") +
  stat_poly_eq(use_label(c("eq", "adj.R2")),
               formula = x ~ poly(y, 3, raw = TRUE))

# conditional user specified label
ggplot(my.data, aes(x, y2, color = group)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(aes(label =  ifelse(after_stat(adj.r.squared) &gt; 0.96,
                                   paste(after_stat(adj.rr.label),
                                         after_stat(eq.label),
                                         sep = "*\", \"*"),
                                   after_stat(adj.rr.label))),
               rr.digits = 3,
               formula = formula)

# geom = "text"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(geom = "text", label.x = 100, label.y = 0, hjust = 1,
               formula = formula)

# using numeric values
# Here we use columns b_0 ... b_3 for the coefficient estimates
my.format &lt;-
  "b[0]~`=`~%.3g*\", \"*b[1]~`=`~%.3g*\", \"*b[2]~`=`~%.3g*\", \"*b[3]~`=`~%.3g"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(formula = formula,
               output.type = "numeric",
               parse = TRUE,
               mapping =
                aes(label = sprintf(my.format,
                                    after_stat(b_0), after_stat(b_1),
                                    after_stat(b_2), after_stat(b_3))))

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics with after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug", output.type = "numeric")

# names of the variables
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug",
                 summary.fun = colnames)

# only data$eq.label
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug",
                 output.type = "expression",
                 summary.fun = function(x) {x[["eq.label"]]})

# only data$eq.label
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(aes(label = after_stat(eq.label)),
                 formula = formula, geom = "debug",
                 output.type = "markdown",
                 summary.fun = function(x) {x[["eq.label"]]})

# only data$eq.label
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug",
                 output.type = "latex",
                 summary.fun = function(x) {x[["eq.label"]]})

# only data$eq.label
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug",
                 output.type = "text",
                 summary.fun = function(x) {x[["eq.label"]]})

# show the content of a list column
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_poly_line(formula = formula) +
    stat_poly_eq(formula = formula, geom = "debug", output.type = "numeric",
                 summary.fun = function(x) {x[["coef.ls"]][[1]]})

</code></pre>

<hr>
<h2 id='stat_poly_line'>Predicted line from linear model fit</h2><span id='topic+stat_poly_line'></span>

<h3>Description</h3>

<p>Predicted values and a confidence band are computed and, by default, plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_poly_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = "lm",
  formula = NULL,
  se = TRUE,
  fm.values = FALSE,
  n = 80,
  fullrange = FALSE,
  level = 0.95,
  method.args = list(),
  n.min = 2L,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_poly_line_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;lm&quot;, &quot;rlm&quot; or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rlm:M"</code>). If a
function different to <code>lm()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, and <code>method</code> and return a
model fit object of class <code>lm</code>.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_se">se</code></td>
<td>
<p>Display confidence interval around smooth? ('TRUE' by default, see
'level' to control.)</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_fm.values">fm.values</code></td>
<td>
<p>logical Add R2, adjusted R2, p-value and n as columns to
returned data? ('FALSE' by default.)</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_fullrange">fullrange</code></td>
<td>
<p>Should the fit span the full range of the plot, or just
the data?</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_level">level</code></td>
<td>
<p>Level of confidence interval to use (0.95 by default).</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_poly_line_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic is similar to <code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code> but has
different defaults. It interprets the argument passed to <code>formula</code>
differently, accepting <code>y</code> as explanatory variable and setting
<code>orientation</code> automatically. The default for <code>method</code> is
<code>"lm"</code> and spline-based smoothers like <code>loess</code> are not supported.
Other defaults are consistent with those in <code>stat_poly_eq()</code>,
<code>stat_quant_line()</code>, <code>stat_quant_eq()</code>, <code>stat_ma_line()</code>,
<code>stat_ma_eq()</code>.
</p>
<p><code>geom_poly_line()</code> treats the x and y aesthetics differently and can
thus have two orientations. The orientation can be deduced from the argument
passed to <code>formula</code>. Thus, <code>stat_poly_line()</code> will by default guess
which orientation the layer should have. If no argument is passed to
<code>formula</code>, the formula defaults to <code>y ~ x</code>. For consistency with
<code><a href="ggplot2.html#topic+stat_smooth">stat_smooth</a></code> orientation can be also specified directly
passing an argument to the <code>orientation</code> parameter, which can be either
<code>"x"</code> or <code>"y"</code>. The value of <code>orientation</code> gives the axis that
is taken as the explanatory variable or <code>x</code> in the model formula.
Package 'ggpmisc' does not define new geometries matching the new statistics
as they are not needed and conceptually transformations of <code>data</code> are
statistics in the grammar of graphics.
</p>
<p>A ggplot statistic receives as <code>data</code> a data frame that is not the one
passed as argument by the user, but instead a data frame with the variables
mapped to aesthetics. <code>stat_poly_eq()</code> mimics how <code>stat_smooth()</code>
works, except that only polynomials can be fitted. Similarly to these
statistics the model fits respect grouping, so the scales used for <code>x</code>
and <code>y</code> should both be continuous scales rather than discrete.
</p>
<p>With method <code>"lm"</code>, singularity results in terms being dropped with a
message if more numerous than can be fitted with a singular (exact) fit.
In this case and if the model results in a perfect fit due to low
number of observation, estimates for various parameters are <code>NaN</code> or
<code>NA</code>.
</p>
<p>With methods other than <code>"lm"</code>, the model fit functions simply fail
in case of singularity, e.g., singular fits are not implemented in
<code>"rlm"</code>.
</p>
<p>In both cases the minimum number of observations with distinct values in
the explanatory variable can be set through parameter <code>n.min</code>. The
default <code>n.min = 2L</code> is the smallest suitable for method <code>"lm"</code>
but too small for method <code>"rlm"</code> for which <code>n.min = 3L</code> is
needed. Anyway, model fits with very few observations are of little
interest and using larger values of <code>n.min</code> than the default is
wise.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, with <code>n</code>
rows of predicted values and their confidence limits. Optionally it will
also include additional values related to the model fit.
</p>


<h3>Computed variables</h3>

<p>'stat_poly_line()' provides the following
variables, some of which depend on the orientation: </p>
 <dl>
<dt>y *or*
x</dt><dd><p>predicted value</p>
</dd> <dt>ymin *or* xmin</dt><dd><p>lower pointwise confidence
interval around the mean</p>
</dd> <dt>ymax *or* xmax</dt><dd><p>upper pointwise confidence
interval around the mean</p>
</dd> <dt>se</dt><dd><p>standard error</p>
</dd> </dl>

<p>If <code>fm.values = TRUE</code> is passed then columns based on the summary of
the model fit are added, with the same value in each row within a group.
This is wasteful and disabled by default, but provides a simple and robust
approach to achieve effects like colouring or hiding of the model fit line
based on P-values, r-squared, adjusted r-squared or the number of
observations.
</p>


<h3>Aesthetics</h3>

<p><code>stat_poly_line</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code>. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"geom_smooth"</code> is the default) are understood and grouping
respected.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for linear and polynomial regression: 
<code><a href="#topic+stat_poly_eq">stat_poly_eq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line()

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line(formula = x ~ poly(y, 3))

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  stat_poly_line(se = FALSE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_poly_line() +
  facet_wrap(~drv)

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_poly_line(geom = "debug")

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_poly_line(geom = "debug", fm.values = TRUE)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_poly_line(geom = "debug", method = lm, fm.values = TRUE)

</code></pre>

<hr>
<h2 id='stat_quant_band'>Predicted band from quantile regression fits</h2><span id='topic+stat_quant_band'></span>

<h3>Description</h3>

<p>Predicted values are computed and, by default, plotted as a band plus an
optional line within. <code>stat_quant_band()</code> supports the use of both
<code>x</code> and <code>y</code> as explanatory variable in the model formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_quant_band(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  fm.values = FALSE,
  n = 80,
  method = "rq",
  method.args = list(),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_quant_band_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector Two or three values in 0..1 indicating the
quantiles at the  edges of the band and optionally a line within the band.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_fm.values">fm.values</code></td>
<td>
<p>logical Add n as a column to returned data? ('FALSE' by
default.)</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;rq&quot;, &quot;rqss&quot; or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>). If a
function different to <code>rq()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, <code>tau</code> and <code>method</code>
and return a model fit object of class <code>rq</code>, <code>rqs</code> or
<code>rqss</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_quant_band_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic is similar to <code><a href="#topic+stat_quant_line">stat_quant_line</a></code> but plots the
quantiles differently with the band representing a region between two
quantiles, while in <code>stat_quant_line()</code> the bands plotted when
<code>se = TRUE</code> represent confidence intervals for the fitted quantile
lines.
</p>
<p><code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code>, which is used by default, treats each
axis differently and thus is dependent on orientation. If no argument is
passed to <code>formula</code>, it defaults to <code>y ~ x</code> but <code>x ~y</code> is also
accepted, and equivalent to <code>y ~ x</code> plus <code>orientation = "y"</code>.
Package 'ggpmisc' does not define a new geometry matching this statistic as
it is enough for the statistic to return suitable 'x' and 'y' values.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values for three quantiles as <code>y</code>,
<code>ymin</code> and <code>ymax</code>, plus <code>x</code>.
</p>


<h3>Aesthetics</h3>

<p><code>stat_quant_eq</code> expects <code>x</code> and <code>y</code>,
aesthetics to be used in the <code>formula</code> rather than the names of the
variables mapped to them. If present, the variable mapped to the
<code>weight</code> aesthetics is passed as argument to parameter <code>weights</code>
of the fitting function. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics recognized by the geometry
(<code>"geom_smooth"</code> is the default) are obeyed and grouping
respected.
</p>


<h3>See Also</h3>

<p>Other ggplot statistics for quantile regression: 
<code><a href="#topic+stat_quant_eq">stat_quant_eq</a>()</code>,
<code><a href="#topic+stat_quant_line">stat_quant_line</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band()

# If you need the fitting to be done along the y-axis set the orientation
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(orientation = "y")

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = x ~ poly(y, 3))

# Instead of rq() we can use rqss() to fit an additive model:
library(quantreg)
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(method = "rqss",
                  formula = y ~ qss(x))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(method = "rqss",
                  formula = x ~ qss(y, constraint = "D"))

# Regressions are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  stat_quant_band(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(formula = y ~ poly(x, 2)) +
  facet_wrap(~drv)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_band(linetype = "dashed", color = "darkred", fill = "red")

ggplot(mpg, aes(displ, hwy)) +
  stat_quant_band(color = NA, alpha = 1) +
  geom_point()

ggplot(mpg, aes(displ, hwy)) +
  stat_quant_band(quantiles = c(0, 0.1, 0.2)) +
  geom_point()

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_band(geom = "debug")

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_band(geom = "debug", fm.values = TRUE)

</code></pre>

<hr>
<h2 id='stat_quant_eq'>Equation, rho, AIC and BIC from quantile regression</h2><span id='topic+stat_quant_eq'></span>

<h3>Description</h3>

<p><code>stat_quant_eq</code> fits a polynomial model by quantile regression and
generates several labels including the equation, rho, 'AIC' and 'BIC'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_quant_eq(
  mapping = NULL,
  data = NULL,
  geom = "text_npc",
  position = "identity",
  ...,
  formula = NULL,
  quantiles = c(0.25, 0.5, 0.75),
  method = "rq:br",
  method.args = list(),
  n.min = 3L,
  eq.with.lhs = TRUE,
  eq.x.rhs = NULL,
  coef.digits = 3,
  coef.keep.zeros = TRUE,
  rho.digits = 2,
  label.x = "left",
  label.y = "top",
  label.x.npc = NULL,
  label.y.npc = NULL,
  hstep = 0,
  vstep = NULL,
  output.type = "expression",
  na.rm = FALSE,
  orientation = NA,
  parse = NULL,
  show.legend = FALSE,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_quant_eq_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names instead of
original variable names.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector Values in 0..1 indicating the quantiles.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;rq&quot; or the name of a model
fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>). If a
function different to <code>rq()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, <code>tau</code> and <code>method</code>
and return a model fit object of class <code>rq</code> or <code>rqs</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments passed to <code>rq()</code>
or to a function passed as argument to <code>method</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of observations needed for fiting a
the model.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_eq.with.lhs">eq.with.lhs</code></td>
<td>
<p>If <code>character</code> the string is pasted to the front of
the equation label before parsing or a <code>logical</code> (see note).</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_eq.x.rhs">eq.x.rhs</code></td>
<td>
<p><code>character</code> this string will be used as replacement for
<code>"x"</code> in the model equation when generating the label before parsing
it.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_coef.digits">coef.digits</code>, <code id="stat_quant_eq_+3A_rho.digits">rho.digits</code></td>
<td>
<p>integer Number of significant digits to use for
the fitted coefficients and rho in labels.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_coef.keep.zeros">coef.keep.zeros</code></td>
<td>
<p>logical Keep or drop trailing zeros when formatting
the fitted coefficients and F-value.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_label.x">label.x</code>, <code id="stat_quant_eq_+3A_label.y">label.y</code></td>
<td>
<p><code>numeric</code> with range 0..1 &quot;normalized parent
coordinates&quot; (npc units) or character if using <code>geom_text_npc()</code> or
<code>geom_label_npc()</code>. If using <code>geom_text()</code> or <code>geom_label()</code>
numeric in native data units. If too short they will be recycled.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_label.x.npc">label.x.npc</code>, <code id="stat_quant_eq_+3A_label.y.npc">label.y.npc</code></td>
<td>
<p><code>numeric</code> with range 0..1 (npc units)
DEPRECATED, use label.x and label.y instead; together with a geom
using npcx and npcy aesthetics.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_hstep">hstep</code>, <code id="stat_quant_eq_+3A_vstep">vstep</code></td>
<td>
<p>numeric in npc units, the horizontal and vertical step
used between labels for different groups.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_output.type">output.type</code></td>
<td>
<p>character One of <code>"expression"</code>, <code>"LaTeX"</code>,
<code>"text"</code>, <code>"markdown"</code> or <code>"numeric"</code>. In most cases,
instead of using this statistics to obtain numeric values, it is better to
use <code>stat_fit_tidy()</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_orientation">orientation</code></td>
<td>
<p>character Either <code>"x"</code> or <code>"y"</code> controlling the
default for <code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_parse">parse</code></td>
<td>
<p>logical Passed to the geom. If <code>TRUE</code>, the labels will be
parsed into expressions and displayed as described in <code>?plotmath</code>.
Default is <code>TRUE</code> if <code>output.type = "expression"</code> and
<code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_quant_eq_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic interprets the argument passed to <code>formula</code> differently
than <code><a href="ggplot2.html#topic+stat_quantile">stat_quantile</a></code> accepting <code>y</code> as well as
<code>x</code> as explanatory variable, matching <code>stat_quant_line()</code>.
</p>
<p>When two variables are subject to mutual constrains, it is useful to consider
both of them as explanatory and interpret the relationship based on them. So,
from version 0.4.1 'ggpmisc' makes it possible to easily implement the
approach described by Cardoso (2019) under the name of &quot;Double quantile
regression&quot;.
</p>
<p>This stat can be used to automatically annotate a plot with rho or
the fitted model equation. The model fitting is done using package
'quantreg', please, consult its documentation for the
details. It supports only linear models fitted with function <code>rq()</code>,
passing <code>method = "br"</code> to it, should work well with up to several
thousand observations. The rho, AIC, BIC and n annotations can be used with
any linear model formula. The fitted equation label is correctly generated
for polynomials or quasi-polynomials through the origin. Model formulas can
use <code>poly()</code> or be defined algebraically with terms of powers of
increasing magnitude with no missing intermediate terms, except possibly
for the intercept indicated by <code>"- 1"</code> or <code>"-1"</code> or <code>"+ 0"</code>
in the formula. The validity of the <code>formula</code> is not checked in the
current implementation. The default aesthetics sets rho as label for the
annotation.  This stat generates labels as R expressions by default but
LaTeX (use TikZ device), markdown (use package 'ggtext') and plain text are
also supported, as well as numeric values for user-generated text labels.
The value of <code>parse</code> is set automatically based on <code>output-type</code>,
but if you assemble labels that need parsing from <code>numeric</code> output,
the default needs to be overridden. This stat only generates annotation
labels, the predicted values/line need to be added to the plot as a
separate layer using <code><a href="#topic+stat_quant_line">stat_quant_line</a></code>,
<code><a href="#topic+stat_quant_band">stat_quant_band</a></code> or <code><a href="ggplot2.html#topic+stat_quantile">stat_quantile</a></code>, so
to make sure that the same model formula is used in all steps it is best to
save the formula as an object and supply this object as argument to the
different statistics.
</p>
<p>A ggplot statistic receives as data a data frame that is not the one passed
as argument by the user, but instead a data frame with the variables mapped
to aesthetics. <code>stat_quant_eq()</code> mimics how <code>stat_smooth()</code>
works, except that only polynomials can be fitted. In other words, it
respects the grammar of graphics. This helps ensure that the model is
fitted to the same data as plotted in other layers.
</p>
<p>Function <code><a href="quantreg.html#topic+rq">rq</a></code> does not support singular fits, in
contrast to <code>lm</code>.
</p>
<p>The minimum number of observations with distinct values in the explanatory
variable can be set through parameter <code>n.min</code>. The default <code>n.min
  = 3L</code> is the smallest usable value. However, model fits with very few
observations are of little interest and using larger values of <code>n.min</code>
than the default is usually wise.
</p>


<h3>Value</h3>

<p>A data frame, with one row per quantile and columns as described
under <strong>Computed variables</strong>. In cases when the number of observations
is less than <code>n.min</code> a data frame with no rows or columns is returned
rendered as an empty/invisible plot layer.
</p>


<h3>Aesthetics</h3>

<p><code>stat_quant_eq()</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code> of <code>rq()</code>. All three must be mapped to
<code>numeric</code> variables. In addition, the aesthetics understood by the
geom used (<code>"text"</code> by default) are understood and grouping respected.
</p>
<p><em>If the model formula includes a transformation of <code>x</code>, a
matching argument should be passed to parameter <code>eq.x.rhs</code>
as its default value <code>"x"</code> will not reflect the applied
transformation. In plots, transformation should never be applied to the
left hand side of the model formula, but instead in the mapping of the
variable within <code>aes</code>, as otherwise plotted observations and fitted
curve will not match. In this case it may be necessary to also pass
a matching argument to parameter <code>eq.with.lhs</code>.</em>
</p>


<h3>Computed variables</h3>

<p>If output.type different from <code>"numeric"</code> the returned tibble contains
columns below in addition to a modified version of the original <code>group</code>:
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>eq.label</dt><dd><p>equation for the fitted polynomial as a character string to be parsed</p>
</dd>
<dt>r.label, and one of cor.label, rho.label, or tau.label</dt><dd><p><code class="reqn">rho</code> of the fitted model as a character string to be parsed</p>
</dd>
<dt>AIC.label</dt><dd><p>AIC for the fitted model.</p>
</dd>
<dt>n.label</dt><dd><p>Number of observations used in the fit.</p>
</dd>
<dt>method.label</dt><dd><p>Set according <code>method</code> used.</p>
</dd>
<dt>rq.method</dt><dd><p>character, method used.</p>
</dd>
<dt>rho, n</dt><dd><p>numeric values extracted or computed from fit object.</p>
</dd>
<dt>hjust, vjust</dt><dd><p>Set to &quot;inward&quot; to override the default of the &quot;text&quot; geom.</p>
</dd>
<dt>quantile</dt><dd><p>Numeric value of the quantile used for the fit</p>
</dd>
<dt>quantile.f</dt><dd><p>Factor with a level for each quantile</p>
</dd>
</dl>

<p>If output.type is <code>"numeric"</code> the returned tibble contains columns
in addition to a modified version of the original <code>group</code>:
</p>

<dl>
<dt>x,npcx</dt><dd><p>x position</p>
</dd>
<dt>y,npcy</dt><dd><p>y position</p>
</dd>
<dt>coef.ls</dt><dd><p>list containing the &quot;coefficients&quot; matrix from the summary of the fit object</p>
</dd>
<dt>rho, AIC, n</dt><dd><p>numeric values extracted or computed from fit object</p>
</dd>
<dt>rq.method</dt><dd><p>character, method used.</p>
</dd>
<dt>hjust, vjust</dt><dd><p>Set to &quot;inward&quot; to override the default of the &quot;text&quot; geom.</p>
</dd>
<dt>quantile</dt><dd><p>Indicating the quantile  used for the fit</p>
</dd>
<dt>quantile.f</dt><dd><p>Factor with a level for each quantile</p>
</dd>
<dt>b_0.constant</dt><dd><p>TRUE is polynomial is forced through the origin</p>
</dd>
<dt>b_i</dt><dd><p>One or columns with the coefficient estimates</p>
</dd></dl>

<p>To explore the computed values returned for a given input we suggest the use
of <code><a href="gginnards.html#topic+geom_debug">geom_debug</a></code> as shown in the example below.
</p>


<h3>Note</h3>

<p>For backward compatibility a logical is accepted as argument for
<code>eq.with.lhs</code>. If <code>TRUE</code>, the default is used, either
<code>"x"</code> or <code>"y"</code>, depending on the argument passed to <code>formula</code>.
However, <code>"x"</code> or <code>"y"</code> can be substituted by providing a
suitable replacement character string through <code>eq.x.rhs</code>.
Parameter <code>orientation</code> is redundant as it only affects the default
for <code>formula</code> but is included for consistency with
<code>ggplot2::stat_smooth()</code>.
</p>
<p>R option <code>OutDec</code> is obeyed based on its value at the time the plot
is rendered, i.e., displayed or printed. Set <code>options(OutDec = ",")</code>
for languages like Spanish or French.
</p>
<p>Support for the <code>angle</code> aesthetic is not automatic and requires
that the user passes as argument suitable numeric values to override the
defaults for label positions.
</p>


<h3>References</h3>

<p>Written as an answer to question 65695409 by Mark Neal at
Stackoverflow.
</p>


<h3>See Also</h3>

<p>The quantile fit is done with function <code><a href="quantreg.html#topic+rq">rq</a></code>,
please consult its documentation. This <code>stat_quant_eq</code> statistic can
return ready formatted labels depending on the argument passed to
<code>output.type</code>. This is possible because only polynomial models are
supported. For other types of models, statistics
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a></code>,  <code><a href="#topic+stat_fit_tidy">stat_fit_tidy</a></code> and
<code><a href="#topic+stat_fit_glance">stat_fit_glance</a></code> should be used instead and the code for
construction of character strings from numeric values and their mapping to
aesthetic <code>label</code> needs to be explicitly supplied in the call.
</p>
<p>Other ggplot statistics for quantile regression: 
<code><a href="#topic+stat_quant_band">stat_quant_band</a>()</code>,
<code><a href="#topic+stat_quant_line">stat_quant_line</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(4321)
x &lt;- 1:100
y &lt;- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
y &lt;- y / max(y)
my.data &lt;- data.frame(x = x, y = y,
                      group = c("A", "B"),
                      y2 = y * c(1, 2) + max(y) * c(0, 0.1),
                      w = sqrt(x))

# using defaults
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line() +
  stat_quant_eq()

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line() +
  stat_quant_eq(use_label(c("eq", "method")))

# same formula as default
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = y ~ x) +
  stat_quant_eq(formula = y ~ x)

# explicit formula "x explained by y"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = x ~ y) +
  stat_quant_eq(formula = x ~ y)

# using color
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(aes(color = after_stat(quantile.f))) +
  stat_quant_eq(aes(color = after_stat(quantile.f))) +
  labs(color = "Quantiles")

# location and colour
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(aes(color = after_stat(quantile.f))) +
  stat_quant_eq(aes(color = after_stat(quantile.f)),
                label.y = "bottom", label.x = "right") +
  labs(color = "Quantiles")

# give a name to a formula
formula &lt;- y ~ poly(x, 3, raw = TRUE)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula)

# angle
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula, angle = 90, hstep = 0.04, vstep = 0,
                label.y = 0.02, hjust = 0) +
  expand_limits(x = -15) # make space for equations

# user set quantiles
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, quantiles = 0.5) +
  stat_quant_eq(formula = formula, quantiles = 0.5)

ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_band(formula = formula,
                  quantiles = c(0.1, 0.5, 0.9)) +
  stat_quant_eq(formula = formula, parse = TRUE,
                quantiles = c(0.1, 0.5, 0.9))

# grouping
ggplot(my.data, aes(x, y2, color = group)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula)

ggplot(my.data, aes(x, y2, color = group)) +
  geom_point() +
  stat_quant_band(formula = formula, linewidth = 0.75) +
  stat_quant_eq(formula = formula) +
  theme_bw()

# labelling equations
ggplot(my.data, aes(x, y2,  shape = group, linetype = group,
       grp.label = group)) +
  geom_point() +
  stat_quant_band(formula = formula, color = "black", linewidth = 0.75) +
  stat_quant_eq(use_label(c("grp", "eq"), sep = "*\": \"*"),
                formula = formula) +
  expand_limits(y = 3) +
  theme_classic()

# modifying the explanatory variable within the model formula
# modifying the response variable within aes()
formula.trans &lt;- y ~ I(x^2)
ggplot(my.data, aes(x, y + 1)) +
  geom_point() +
  stat_quant_line(formula = formula.trans) +
  stat_quant_eq(use_label("eq"),
               formula = formula.trans,
               eq.x.rhs = "~x^2",
               eq.with.lhs = "y + 1~~`=`~~")

# using weights
ggplot(my.data, aes(x, y, weight = w)) +
  geom_point() +
  stat_quant_line(formula = formula, linewidth = 0.5) +
  stat_quant_eq(formula = formula)

# no weights, quantile set to upper boundary
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, quantiles = 0.95) +
  stat_quant_eq(formula = formula, quantiles = 0.95)

# manually assemble and map a specific label using paste() and aes()
ggplot(my.data, aes(x, y2, color = group, grp.label = group)) +
  geom_point() +
  stat_quant_line(method = "rq", formula = formula,
                quantiles = c(0.05, 0.5, 0.95),
                linewidth = 0.5) +
  stat_quant_eq(aes(label = paste(after_stat(grp.label), "*\": \"*",
                                   after_stat(eq.label), sep = "")),
                quantiles = c(0.05, 0.5, 0.95),
                formula = formula, size = 3)

# manually assemble and map a specific label using sprintf() and aes()
ggplot(my.data, aes(x, y2, color = group, grp.label = group)) +
  geom_point() +
  stat_quant_band(method = "rq", formula = formula,
                  quantiles = c(0.05, 0.5, 0.95)) +
  stat_quant_eq(aes(label = sprintf("%s*\": \"*%s",
                                    after_stat(grp.label),
                                    after_stat(eq.label))),
                quantiles = c(0.05, 0.5, 0.95),
                formula = formula, size = 3)

# geom = "text"
ggplot(my.data, aes(x, y)) +
  geom_point() +
  stat_quant_line(formula = formula, quantiles = 0.5) +
  stat_quant_eq(label.x = "left", label.y = "top",
                formula = formula,
                quantiles = 0.5)

# Inspecting the returned data using geom_debug()
# This provides a quick way of finding out the names of the variables that
# are available for mapping to aesthetics using after_stat().

gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, geom = "debug")

## Not run: 
if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(aes(label = after_stat(eq.label)),
                  formula = formula, geom = "debug",
                  output.type = "markdown")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, geom = "debug", output.type = "text")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, geom = "debug", output.type = "numeric")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, quantiles = c(0.25, 0.5, 0.75),
                  geom = "debug", output.type = "text")

if (gginnards.installed)
  ggplot(my.data, aes(x, y)) +
    geom_point() +
    stat_quant_eq(formula = formula, quantiles = c(0.25, 0.5, 0.75),
                  geom = "debug", output.type = "numeric")

## End(Not run)

</code></pre>

<hr>
<h2 id='stat_quant_line'>Predicted line from quantile regression fit</h2><span id='topic+stat_quant_line'></span>

<h3>Description</h3>

<p>Predicted values are computed and, by default, plotted. Depending on the
fit method, a confidence band can be computed and plotted. The confidence
band can be interpreted similarly as that produced by <code>stat_smooth()</code>
and <code>stat_poly_line()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_quant_line(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  se = length(quantiles) == 1L,
  fm.values = FALSE,
  n = 80,
  method = "rq",
  method.args = list(),
  n.min = 3L,
  level = 0.95,
  type = "direct",
  interval = "confidence",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_quant_line_+3A_mapping">mapping</code></td>
<td>
<p>The aesthetic mapping, usually constructed with
<code><a href="ggplot2.html#topic+aes">aes</a></code>. Only needs to be
set at the layer level if you are overriding the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_data">data</code></td>
<td>
<p>A layer specific dataset, only needed if you want to override
the plot defaults.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_position">position</code></td>
<td>
<p>The position adjustment to use for overlapping points on this
layer</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_...">...</code></td>
<td>
<p>other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer</a></code>. This
can include aesthetics whose values you want to set, not map. See
<code><a href="ggplot2.html#topic+layer">layer</a></code> for more details.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector Values in 0..1 indicating the quantiles.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_formula">formula</code></td>
<td>
<p>a formula object. Using aesthetic names <code>x</code> and <code>y</code>
instead of original variable names.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_se">se</code></td>
<td>
<p>logical Passed to <code>quantreg::predict.rq()</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_fm.values">fm.values</code></td>
<td>
<p>logical Add n as a column to returned data? ('FALSE' by
default.)</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_n">n</code></td>
<td>
<p>Number of points at which to evaluate smoother.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_method">method</code></td>
<td>
<p>function or character If character, &quot;rq&quot;, &quot;rqss&quot; or the name of
a model fit function are accepted, possibly followed by the fit function's
<code>method</code> argument separated by a colon (e.g. <code>"rq:br"</code>). If a
function different to <code>rq()</code>, it must accept arguments named
<code>formula</code>, <code>data</code>, <code>weights</code>, <code>tau</code> and <code>method</code>
and return a model fit object of class <code>rq</code>, <code>rqs</code> or
<code>rqss</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_method.args">method.args</code></td>
<td>
<p>named list with additional arguments passed to
<code>rq()</code>, <code>rqss()</code> or to a function passed as argument to
<code>method</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_n.min">n.min</code></td>
<td>
<p>integer Minimum number of distinct values in the explanatory
variable (on the rhs of formula) for fitting to the attempted.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_level">level</code></td>
<td>
<p>numeric in range [0..1] Passed to <code>quantreg::predict.rq()</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_type">type</code></td>
<td>
<p>character Passed to <code>quantreg::predict.rq()</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_interval">interval</code></td>
<td>
<p>character Passed to <code>quantreg::predict.rq()</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NA values should be stripped before
the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_orientation">orientation</code></td>
<td>
<p>character Either &quot;x&quot; or &quot;y&quot; controlling the default for
<code>formula</code>.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped. <code>FALSE</code>
never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
<tr><td><code id="stat_quant_line_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stat_quant_line()</code> behaves similarly to
<code>ggplot2::stat_smooth()</code> and <code>stat_poly_line()</code> but supports
fitting regressions for multiple quantiles in the same plot layer. This
statistic interprets the argument passed to <code>formula</code> accepting
<code>y</code> as well as <code>x</code> as explanatory variable, matching
<code>stat_quant_eq()</code>. While <code>stat_quant_eq()</code> supports only method
<code>"rq"</code>, <code>stat_quant_line()</code> and <code>stat_quant_band()</code> support
both <code>"rq"</code> and <code>"rqss"</code>, In the case of <code>"rqss"</code> the model
formula makes normally use of <code>qss()</code> to formulate the spline and its
constraints.
</p>
<p><code><a href="ggplot2.html#topic+geom_smooth">geom_smooth</a></code>, which is used by default, treats each
axis differently and thus is dependent on orientation. If no argument is
passed to <code>formula</code>, it defaults to <code>y ~ x</code>. Formulas with
<code>y</code> as explanatory variable are treated as if <code>x</code> was the
explanatory variable and <code>orientation = "y"</code>.
</p>
<p>Package 'ggpmisc' does not define a new geometry matching this statistic as
it is enough for the statistic to return suitable <code>x</code>, <code>y</code>,
<code>ymin</code>, <code>ymax</code> and <code>group</code> values.
</p>
<p>The minimum number of observations with distinct values in the explanatory
variable can be set through parameter <code>n.min</code>. The default <code>n.min
  = 3L</code> is the smallest usable value. However, model fits with very few
observations are of little interest and using larger values of <code>n.min</code>
than the default is wise.
</p>
<p>There are multiple uses for double regression on x and y. For example, when
two variables are subject to mutual constrains, it is useful to consider
both of them as explanatory and interpret the relationship based on them.
So, from version 0.4.1 'ggpmisc' makes it possible to easily implement the
approach described by Cardoso (2019) under the name of &quot;Double quantile
regression&quot;.
</p>


<h3>Value</h3>

<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values and and their confidence limits for each
quantile, with each quantile in a group. The variables are <code>x</code> and
<code>y</code> with <code>y</code> containing predicted values. In addition,
<code>quantile</code> and <code>quantile.f</code> indicate the quantile used and
and edited <code>group</code> preserves the original grouping adding a new
&quot;level&quot; for each quantile. Is <code>se = TRUE</code>, a confidence band is
computed and values for it returned in <code>ymax</code> and <code>ymin</code>.
</p>
<p>The value returned by the statistic is a data frame, that will have
<code>n</code> rows of predicted values and their confidence limits. Optionally
it will also include additional values related to the model fit.
</p>


<h3>Computed variables</h3>

<p>'stat_quant_line()' provides the following
variables, some of which depend on the orientation: </p>
 <dl>
<dt>y *or*
x</dt><dd><p>predicted value</p>
</dd> <dt>ymin *or* xmin</dt><dd><p>lower confidence
interval around the mean</p>
</dd> <dt>ymax *or* xmax</dt><dd><p>upper confidence
interval around the mean</p>
</dd></dl>

<p>If <code>fm.values = TRUE</code> is passed then one column with the number of
observations <code>n</code> used for each fit is also included, with the same
value in each row within a group. This is wasteful and disabled by default,
but provides a simple and robust approach to achieve effects like colouring
or hiding of the model fit line based on the number of observations.
</p>


<h3>Aesthetics</h3>

<p><code>stat_quant_line</code> understands <code>x</code> and <code>y</code>,
to be referenced in the <code>formula</code> and <code>weight</code> passed as argument
to parameter <code>weights</code>. All three must be mapped to <code>numeric</code>
variables. In addition, the aesthetics understood by the geom
(<code>"geom_smooth"</code> is the default) are understood and grouping
respected.
</p>


<h3>References</h3>

<p>Cardoso, G. C. (2019) Double quantile regression accurately assesses
distance to boundary trade-off. Methods in ecology and evolution,
10(8), 1322-1331.
</p>


<h3>See Also</h3>

<p><code><a href="quantreg.html#topic+rq">rq</a></code>, <code><a href="quantreg.html#topic+rqss">rqss</a></code> and
<code><a href="quantreg.html#topic+qss">qss</a></code>.
</p>
<p>Other ggplot statistics for quantile regression: 
<code><a href="#topic+stat_quant_band">stat_quant_band</a>()</code>,
<code><a href="#topic+stat_quant_eq">stat_quant_eq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line()

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(se = TRUE)

# If you need the fitting to be done along the y-axis set the orientation
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(orientation = "y")

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(orientation = "y", se = TRUE)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ x)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = x ~ y)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ poly(x, 3))

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = x ~ poly(y, 3))

# Instead of rq() we can use rqss() to fit an additive model:
library(quantreg)
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(method = "rqss",
                  formula = y ~ qss(x, constraint = "D"),
                  quantiles = 0.5)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(method = "rqss",
                  formula = x ~ qss(y, constraint = "D"),
                  quantiles = 0.5)

ggplot(mpg, aes(displ, hwy)) +
  geom_point()+
  stat_quant_line(method="rqss",
                  interval="confidence",
                  se = TRUE,
                  mapping = aes(fill = factor(after_stat(quantile)),
                                color = factor(after_stat(quantile))),
                  quantiles=c(0.05,0.5,0.95))

# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

ggplot(mpg, aes(displ, hwy, colour = drv, fill = drv)) +
  geom_point() +
  stat_quant_line(method = "rqss",
                  formula = y ~ qss(x, constraint = "V"),
                   quantiles = 0.5)

ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  stat_quant_line(formula = y ~ poly(x, 2)) +
  facet_wrap(~drv)

# Inspecting the returned data using geom_debug()
gginnards.installed &lt;- requireNamespace("gginnards", quietly = TRUE)

if (gginnards.installed)
  library(gginnards)

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_line(geom = "debug")

if (gginnards.installed)
  ggplot(mpg, aes(displ, hwy)) +
    stat_quant_line(geom = "debug", fm.values = TRUE)

</code></pre>

<hr>
<h2 id='swap_xy'>Swap x and y in a formula</h2><span id='topic+swap_xy'></span>

<h3>Description</h3>

<p>By default a formula of x on y is converted into a formula of y
on x, while the reverse swap is done only if <code>backward = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_xy(f, backwards = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_xy_+3A_f">f</code></td>
<td>
<p>formula An R model formula</p>
</td></tr>
<tr><td><code id="swap_xy_+3A_backwards">backwards</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be used only as a helper within 'ggplot2'
statistics. Normally together with geometries supporting orientation when
we want to automate the change in orientation based on a user-supplied
formula. Only <code>x</code> and <code>y</code> are changed, and in other respects
the formula is rebuilt copying the environment from <code>f</code>.
</p>


<h3>Value</h3>

<p>A copy of <code>f</code> with <code>x</code> and <code>y</code> swapped by each other
in the lhs and rhs.
</p>

<hr>
<h2 id='symmetric_limits'>Expand a range to make it symmetric</h2><span id='topic+symmetric_limits'></span>

<h3>Description</h3>

<p>Expand scale limits to make them symmetric around zero. Can be
passed as argument to parameter <code>limits</code> of continuous scales from
packages 'ggplot2' or 'scales'. Can be also used to obtain an enclosing
symmetric range for numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetric_limits(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetric_limits_+3A_x">x</code></td>
<td>
<p>numeric The automatic limits when used as argument to a scale's
<code>limits</code> formal parameter. Otherwise a numeric vector, possibly a
range, for which to compute a symmetric enclosing range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length two with the new limits, which are always
such that the absolute value of upper and lower limits is the same.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
symmetric_limits(c(-1, 1.8))
symmetric_limits(c(-10, 1.8))
symmetric_limits(-5:20)

</code></pre>

<hr>
<h2 id='use_label'>Assemble label and map it</h2><span id='topic+use_label'></span>

<h3>Description</h3>

<p>Assemble model-fit-derived text or expressions and map them to
the <code>label</code> aesthetic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_label(
  labels = c("eq", "p.value"),
  other.mapping = NULL,
  sep = "*\", \"*"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_label_+3A_labels">labels</code></td>
<td>
<p>character A vector with the name of the label components in the
order they will be included in the combined label.</p>
</td></tr>
<tr><td><code id="use_label_+3A_other.mapping">other.mapping</code></td>
<td>
<p>An unevaluated expression constructed with function
<code><a href="ggplot2.html#topic+aes">aes</a></code>.</p>
</td></tr>
<tr><td><code id="use_label_+3A_sep">sep</code></td>
<td>
<p>character A string used as separator when pasting the label
components together.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Statistics <code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code>, <code><a href="#topic+stat_ma_eq">stat_ma_eq</a></code>,
<code><a href="#topic+stat_quant_eq">stat_quant_eq</a></code> and <code><a href="#topic+stat_correlation">stat_correlation</a></code> return
multiple text strings to be used individually or assembled into longer
character strings depending on the labels actually desired. Assembling and
mapping them requires verbose R code and familiarity with R expression
syntax. Function <code>use_label()</code> automates these two taks and accepts
abbreviated familiar names for the parameters in addition to the name of
the columns in the data object returned by the statistics. The default
separator is that for expressions.
</p>
<p>The statistics return variables with names ending in <code>.label</code>. This
ending can be omitted, as well as <code>.value</code> for <code>f.value.label</code>,
<code>t.value.label</code>, <code>z.value.label</code>, <code>S.value.label</code> and
<code>p.value.label</code>. <code>R2</code> can be used in place of <code>rr</code>.
Furthermore, case is ignored.
</p>


<h3>Value</h3>

<p>A to the <code>label</code> aesthetic as an unevaluated R expression, built
using function <code><a href="ggplot2.html#topic+aes">aes</a></code>.
</p>


<h3>Note</h3>

<p>Function <code>use_label()</code> can be only used to generate an argument
passed to formal parameter <code>mapping</code> of the statistics
<code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code>, <code><a href="#topic+stat_ma_eq">stat_ma_eq</a></code>,
<code><a href="#topic+stat_quant_eq">stat_quant_eq</a></code> and <code><a href="#topic+stat_correlation">stat_correlation</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stat_poly_eq">stat_poly_eq</a></code>, <code><a href="#topic+stat_ma_eq">stat_ma_eq</a></code>,
<code><a href="#topic+stat_quant_eq">stat_quant_eq</a></code> and <code><a href="#topic+stat_correlation">stat_correlation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate artificial data
set.seed(4321)
x &lt;- 1:100
y &lt;- (x + x^2 + x^3) + rnorm(length(x), mean = 0, sd = mean(x^3) / 4)
my.data &lt;- data.frame(x = x,
                      y = y * 1e-5,
                      group = c("A", "B"),
                      y2 = y * 1e-5 + c(2, 0))

# give a name to a formula
formula &lt;- y ~ poly(x, 3, raw = TRUE)

ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("eq", "F")), formula = formula)

ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("R2", "F"), sep = "*\" with \"*"),
               formula = formula)

ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("eq", "adj.R2", "n")), formula = formula)

ggplot(my.data, aes(x, y2, colour = group)) +
  geom_point() +
  stat_poly_line(formula = formula) +
  stat_poly_eq(use_label(c("F", "P", "AIC", "BIC")), formula = formula)

ggplot(my.data, aes(x, y)) +
  stat_quant_band(formula = formula) +
  stat_quant_eq(use_label(c("eq", "n")), formula = formula) +
  geom_point()

ggplot(my.data, aes(x, y)) +
  stat_ma_line() +
  stat_ma_eq(use_label(c("eq", "n"))) +
  geom_point()

ggplot(my.data, aes(x, y)) +
  stat_correlation(use_label(c("r", "t", "p"))) +
  geom_point()

# pass additional mappings if desired
ggplot(my.data, aes(x, y2)) +
  geom_point(aes(colour = group)) +
  stat_poly_line(aes(colour = group), formula = formula) +
  stat_poly_eq(use_label(c("eq", "F"), aes(grp.label = group)), formula = formula)

</code></pre>

<hr>
<h2 id='xy_outcomes2factor'>Convert two numeric ternary outcomes into a factor</h2><span id='topic+xy_outcomes2factor'></span><span id='topic+xy_thresholds2factor'></span>

<h3>Description</h3>

<p>Convert two numeric ternary outcomes into a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_outcomes2factor(x, y)

xy_thresholds2factor(x, y, x_threshold = 0, y_threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_outcomes2factor_+3A_x">x</code>, <code id="xy_outcomes2factor_+3A_y">y</code></td>
<td>
<p>numeric vectors of -1, 0, and +1 values, indicating down
regulation, uncertain response or up-regulation, or numeric vectors that can be
converted into such values using a pair of thresholds.</p>
</td></tr>
<tr><td><code id="xy_outcomes2factor_+3A_x_threshold">x_threshold</code>, <code id="xy_outcomes2factor_+3A_y_threshold">y_threshold</code></td>
<td>
<p>numeric vector Ranges enclosing the values to be considered
uncertain for each of the two vectors..</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts the numerically encoded values into a factor
with the four levels <code>"xy"</code>, <code>"x"</code>, <code>"y"</code> and <code>"none"</code>.
The factor created can be used for faceting or can be mapped to aesthetics.
</p>


<h3>Note</h3>

<p>This is an utility function that only saves some typing. The same
result can be achieved by a direct call to <code><a href="base.html#topic+factor">factor</a></code>. This
function aims at making it easier to draw quadrant plots with facets
based on the combined outcomes.
</p>


<h3>See Also</h3>

<p>Other Functions for quadrant and volcano plots: 
<code><a href="#topic+FC_format">FC_format</a>()</code>,
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_outcome">scale_colour_outcome</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_y_Pvalue">scale_y_Pvalue</a>()</code>
</p>
<p>Other scales for omics data: 
<code><a href="#topic+outcome2factor">outcome2factor</a>()</code>,
<code><a href="#topic+scale_colour_logFC">scale_colour_logFC</a>()</code>,
<code><a href="#topic+scale_shape_outcome">scale_shape_outcome</a>()</code>,
<code><a href="#topic+scale_x_logFC">scale_x_logFC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xy_outcomes2factor(c(-1, 0, 0, 1, -1), c(0, 1, 0, 1, -1))
xy_thresholds2factor(c(-1, 0, 0, 1, -1), c(0, 1, 0, 1, -1))
xy_thresholds2factor(c(-1, 0, 0, 0.1, -5), c(0, 2, 0, 1, -1))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
