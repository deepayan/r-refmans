<!DOCTYPE html><html lang="en"><head><title>Help for package grpSLOPE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grpSLOPE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admmSolverGroupSLOPE'><p>Alternating direction method of multipliers</p></a></li>
<li><a href='#coef.grpSLOPE'><p>Extract model coefficients</p></a></li>
<li><a href='#getGroupID'><p>Get a groupID object</p></a></li>
<li><a href='#grpSLOPE'><p>Group SLOPE (Group Sorted L-One Penalized Estimation)</p></a></li>
<li><a href='#lambdaGroupSLOPE'><p>Regularizing sequence for Group SLOPE</p></a></li>
<li><a href='#predict.grpSLOPE'><p>Obtain predictions</p></a></li>
<li><a href='#prox_sorted_L1'><p>Prox for sorted L1 norm</p></a></li>
<li><a href='#proxGroupSortedL1'><p>Prox for group SLOPE</p></a></li>
<li><a href='#proximalGradientSolverGroupSLOPE'><p>Proximal gradient method for Group SLOPE</p></a></li>
<li><a href='#sigma'><p>Extract (estimated) noise level</p></a></li>
<li><a href='#SLOPE_solver'><p>Sorted L1 solver</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Group Sorted L1 Penalized Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Group SLOPE (Group Sorted L1 Penalized Estimation) is
    a penalized linear regression method that is used for adaptive
    selection of groups of significant predictors in a high-dimensional
    linear model. The Group SLOPE method can control the (group) false
    discovery rate at a user-specified level (i.e., control the expected
    proportion of irrelevant among all selected groups of predictors).
    For additional information about the implemented methods please see
    Brzyski, Gossmann, Su, Bogdan (2018) &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1411269">doi:10.1080/01621459.2017.1411269</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agisga/grpSLOPE">https://github.com/agisga/grpSLOPE</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agisga/grpSLOPE/issues">https://github.com/agisga/grpSLOPE/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, pander, isotone, SLOPE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-23 22:23:46 UTC; alexej</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexej Gossmann [aut, cre],
  Damian Brzyski [aut],
  Weijie Su [aut],
  Malgorzata Bogdan [aut],
  Ewout van den Berg [ctb] (Code adapted from 'SLOPE' version 0.1.3, as
    well as from
    http://statweb.stanford.edu/~candes/SortedL1/software.html under
    GNU GPL-3),
  Emmanuel Candes [ctb] (Code adapted from 'SLOPE' version 0.1.3, as well
    as from http://statweb.stanford.edu/~candes/SortedL1/software.html
    under GNU GPL-3),
  Chiara Sabatti [ctb] (Code adapted from 'SLOPE' version 0.1.3, as well
    as from http://statweb.stanford.edu/~candes/SortedL1/software.html
    under GNU GPL-3),
  Evan Patterson [ctb] (Code adapted from 'SLOPE' version 0.1.3, as well
    as from http://statweb.stanford.edu/~candes/SortedL1/software.html
    under GNU GPL-3)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexej Gossmann &lt;alexej.go@googlemail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-24 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='admmSolverGroupSLOPE'>Alternating direction method of multipliers</h2><span id='topic+admmSolverGroupSLOPE'></span>

<h3>Description</h3>

<p>Compute the coefficient estimates for the Group SLOPE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admmSolverGroupSLOPE(
  y,
  A,
  group,
  wt,
  lambda,
  rho = NULL,
  max.iter = 10000,
  verbose = FALSE,
  absolute.tol = 1e-04,
  relative.tol = 1e-04,
  z.init = NULL,
  u.init = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admmSolverGroupSLOPE_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_a">A</code></td>
<td>
<p>the model matrix</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_group">group</code></td>
<td>
<p>A vector describing the grouping structure. It should
contain a group id for each predictor variable.</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_wt">wt</code></td>
<td>
<p>A vector of weights (per coefficient)</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_lambda">lambda</code></td>
<td>
<p>A decreasing sequence of regularization parameters <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_rho">rho</code></td>
<td>
<p>Penalty parameter in the augmented Lagrangian (see Boyd et al., 2011)</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of iterations to carry out</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> specifying whether to print output or not</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_absolute.tol">absolute.tol</code></td>
<td>
<p>The absolute tolerance used in the stopping criteria for the primal and dual feasibility conditions (see Boyd et al., 2011, Sec. 3.3.1)</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_relative.tol">relative.tol</code></td>
<td>
<p>The relative tolerance used in the stopping criteria for the primal and dual feasibility conditions (see Boyd et al., 2011, Sec. 3.3.1)</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_z.init">z.init</code></td>
<td>
<p>An optional initial value for the iterative algorithm</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_u.init">u.init</code></td>
<td>
<p>An optional initial value for the iterative algorithm</p>
</td></tr>
<tr><td><code id="admmSolverGroupSLOPE_+3A_...">...</code></td>
<td>
<p>Options passed to <code><a href="#topic+prox_sorted_L1">prox_sorted_L1</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>admmSolverGroupSLOPE</code> computes the coefficient estimates
for the Group SLOPE model. The employed optimization algorithm is
the alternating direction method of multipliers (ADMM).
</p>


<h3>Value</h3>

<p>A list with the entries:
</p>

<dl>
<dt>x</dt><dd><p>Solution (n-by-1 matrix)</p>
</dd>
<dt>status</dt><dd><p>Convergence status: 1 if optimal, 2 if iteration limit reached</p>
</dd>
<dt>iter</dt><dd><p>Number of iterations of the ADMM method</p>
</dd>
</dl>



<h3>References</h3>

<p>S. Boyd, N. Parikh, E. Chu, B. Peleato, and J. Eckstein (2011) <em>Distributed Optimization and Statistical Learning via the Alternating Direction Method of Multipliers.</em> Foundations and Trends in Machine Learning 3 (1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
A   &lt;- matrix(runif(100, 0, 1), 10, 10)
grp &lt;- c(0, 0, 1, 1, 2, 2, 2, 2, 2, 3)
wt  &lt;- c(2, 2, 2, 2, 5, 5, 5, 5, 5, 1)
x   &lt;- c(0, 0, 5, 1, 0, 0, 0, 1, 0, 3)
y   &lt;- A %*% x
lam &lt;- 0.1 * (10:7)
result &lt;- admmSolverGroupSLOPE(y = y, A = A, group = grp, wt = wt,
                               lambda=lam, rho = 1, verbose = FALSE)
result$x
#           [,1]
#  [1,] 0.000000
#  [2,] 0.000000
#  [3,] 3.856002
#  [4,] 2.080742
#  [5,] 0.000000
#  [6,] 0.000000
#  [7,] 0.000000
#  [8,] 0.000000
#  [9,] 0.000000
# [10,] 3.512829

</code></pre>

<hr>
<h2 id='coef.grpSLOPE'>Extract model coefficients</h2><span id='topic+coef.grpSLOPE'></span>

<h3>Description</h3>

<p>Extract the regression coefficients from a <code>grpSLOPE</code> object, either on the
scale of the normalized design matrix (i.e., columns centered and scaled to unit norm),
or on the original scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grpSLOPE'
coef(object, scaled = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.grpSLOPE_+3A_object">object</code></td>
<td>
<p>A <code>grpSLOPE</code> object</p>
</td></tr>
<tr><td><code id="coef.grpSLOPE_+3A_scaled">scaled</code></td>
<td>
<p>Should the coefficients be returned for the normalized version of the design matrix?</p>
</td></tr>
<tr><td><code id="coef.grpSLOPE_+3A_...">...</code></td>
<td>
<p>Potentially further arguments passed to and from methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>scaled</code> is set to <code>TRUE</code>, then the coefficients are returned for the 
normalized version of the design matrix, which is the scale on which they were computed. 
If <code>scaled</code> is set to <code>FALSE</code>, then the coefficients are transformed to
correspond to the original (unaltered) design matrix.
In case that <code>scaled = FALSE</code>, an estimate for the intercept term is returned with
the other coefficients. In case that <code>scaled = TRUE</code>, the estimate of the intercept 
is always equal to zero, and is not explicitly provided.
</p>


<h3>Value</h3>

<p>A named vector of regression coefficients where the names signify the group that each entry belongs to
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
A   &lt;- matrix(rnorm(100^2), 100, 100)
grp &lt;- rep(rep(letters[1:20]), each=5)
b   &lt;- c(rep(1, 20), rep(0, 80))
y   &lt;- A %*% b + rnorm(10) 
result &lt;- grpSLOPE(X=A, y=y, group=grp, fdr=0.1)
head(coef(result), 8)
#       a_1       a_2       a_3       a_4       a_5       b_1       b_2       b_3 
#  7.942177  7.979269  8.667013  8.514861 10.026664  8.963364 10.037355 10.448692 
head(coef(result, scaled = FALSE), 8)
# (Intercept)         a_1         a_2         a_3         a_4         a_5         b_1         b_2 
#  -0.4418113   0.8886878   0.8372108   0.8422089   0.8629597   0.8615827   0.9323849   0.9333445 

</code></pre>

<hr>
<h2 id='getGroupID'>Get a groupID object</h2><span id='topic+getGroupID'></span>

<h3>Description</h3>

<p>Mostly intended for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGroupID(group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGroupID_+3A_group">group</code></td>
<td>
<p>A vector describing the grouping structure. It should 
contain a group id for each predictor variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class groupID, which is a list, whose members are 
vectors of indices corresponding to each group. The names of
the list members are the corresponding group names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group  &lt;- c("A", "A", 2, 9, "A", 9, 9, 2, "A")
group.id &lt;- getGroupID(group)
group.id
# $A
# [1] 1 2 5 9
# 
# $`2`
# [1] 3 8
# 
# $`9`
# [1] 4 6 7
# 
# attr(,"class")
# [1] "groupID"

</code></pre>

<hr>
<h2 id='grpSLOPE'>Group SLOPE (Group Sorted L-One Penalized Estimation)</h2><span id='topic+grpSLOPE'></span>

<h3>Description</h3>

<p>Performs selection of significant groups of predictors and estimation of the
corresponding coefficients using the Group SLOPE method (see Brzyski et. al., 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpSLOPE(
  X,
  y,
  group,
  fdr,
  lambda = "corrected",
  sigma = NULL,
  verbose = FALSE,
  orthogonalize = NULL,
  normalize = TRUE,
  max.iter = 10000,
  dual.gap.tol = 1e-06,
  infeas.tol = 1e-06,
  x.init = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grpSLOPE_+3A_x">X</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_y">y</code></td>
<td>
<p>The response variable</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_group">group</code></td>
<td>
<p>A vector describing the grouping structure. It should 
contain a group id for each predictor variable.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_fdr">fdr</code></td>
<td>
<p>Target group false discovery rate (gFDR)</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_lambda">lambda</code></td>
<td>
<p>Method used to obtain the regularizing sequence lambda. Possible
values are &quot;max&quot;, &quot;mean&quot;, and &quot;corrected&quot; (default).
See <code><a href="#topic+lambdaGroupSLOPE">lambdaGroupSLOPE</a></code> for detail. Alternatively, any
non-increasing sequence of the correct length can be passed.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_sigma">sigma</code></td>
<td>
<p>Noise level. If ommited, estimated from the data, using Procedure 2 in Brzyski et. al. (2016).</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> specifying whether to print output or not</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_orthogonalize">orthogonalize</code></td>
<td>
<p>Whether to orthogonalize the model matrix within each group.
Do not set manually unless you are certain that your data is appropriately pre-processed.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_normalize">normalize</code></td>
<td>
<p>Whether to center the input data and re-scale the columns
of the design matrix to have unit norms. Do not disable this unless you
are certain that your data are appropriately pre-processed.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_max.iter">max.iter</code></td>
<td>
<p>See <code><a href="#topic+proximalGradientSolverGroupSLOPE">proximalGradientSolverGroupSLOPE</a></code>.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_dual.gap.tol">dual.gap.tol</code></td>
<td>
<p>See <code><a href="#topic+proximalGradientSolverGroupSLOPE">proximalGradientSolverGroupSLOPE</a></code>.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_infeas.tol">infeas.tol</code></td>
<td>
<p>See <code><a href="#topic+proximalGradientSolverGroupSLOPE">proximalGradientSolverGroupSLOPE</a></code>.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_x.init">x.init</code></td>
<td>
<p>See <code><a href="#topic+proximalGradientSolverGroupSLOPE">proximalGradientSolverGroupSLOPE</a></code>.</p>
</td></tr>
<tr><td><code id="grpSLOPE_+3A_...">...</code></td>
<td>
<p>Options passed to <code><a href="#topic+prox_sorted_L1">prox_sorted_L1</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple methods are available to generate the regularizing sequence <code>lambda</code>,
see <code><a href="#topic+lambdaGroupSLOPE">lambdaGroupSLOPE</a></code> for detail.
The model matrix is transformed by orthogonalization within each group (see Section 2.1
in Brzyski et. al., 2016), and penalization is imposed on <code class="reqn">\| X_{I_i} \beta_{I_i} \|</code>.
When <code>orthogonalize = TRUE</code>, due to within group orthogonalization,
the solution vector <code>beta</code> cannot be computed, if a group submatrix does not have full
column rank (e.g., if there are more predictors in a selected group than there are observations).
In that case only the solution vector <code>c</code> of the transformed (orthogonalized) model is returned.
Additionally, in any case the vector <code>group.norms</code> is returned with its <code class="reqn">i</code>th entry
being <code class="reqn">\| X_{I_i} \beta_{I_i} \|</code>, i.e., the overall effect of each group.
Note that all of these results are returned on the scale of the normalized versions of <code>X</code> and <code>y</code>.
However, <code>original.scale</code> contains the regression coefficients transformed to correspond to 
the original (unaltered) <code>X</code> and <code>y</code>. In that case, an estimate for the intercept term is also
returned with the other coefficients in <code>original.scale</code> (while on the normalized scale the estimate
of the intercept is always equal to zero, and is not explicitly provided in the <code>grpSLOPE</code> output).
</p>


<h3>Value</h3>

<p>A list with members:
</p>

<dl>
<dt>beta</dt><dd><p>Solution vector. See Details.</p>
</dd>
<dt>c</dt><dd><p>Solution vector of the transformed model. See Details.</p>
</dd>
<dt>group.norms</dt><dd><p>Overall effect of each group. See Details.</p>
</dd>
<dt>selected</dt><dd><p>Names of selected groups (i.e., groups of predictors with at least one non-zero coefficient estimate)</p>
</dd>
<dt>optimal</dt><dd><p>Convergence status</p>
</dd>
<dt>iter</dt><dd><p>Iterations of the proximal gradient method</p>
</dd>
<dt>lambda</dt><dd><p>Regularizing sequence</p>
</dd>
<dt>lambda.method</dt><dd><p>Method used to construct the regularizing sequence</p>
</dd>
<dt>sigma</dt><dd><p>(Estimated) noise level</p>
</dd>
<dt>group</dt><dd><p>The provided grouping structure (corresponding to <code>beta</code>)</p>
</dd>
<dt>group.c</dt><dd><p>Grouping structure of the transformed model (corresponding to <code>c</code>)</p>
</dd>
<dt>original.scale</dt><dd><p>A list containing the estimated intercept and regression coefficients on the original scale. See Details.</p>
</dd>
</dl>



<h3>References</h3>

<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2016) <em>Group SLOPE &ndash; adaptive selection of groups of predictors</em>, <a href="https://arxiv.org/abs/1610.04960">https://arxiv.org/abs/1610.04960</a>
</p>
<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2019) <em>Group SLOPE &ndash; adaptive selection of groups of predictors</em>. Journal of the American Statistical Association 114 (525): 419–33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate some data
set.seed(1)
A   &lt;- matrix(rnorm(100^2), 100, 100)
grp &lt;- rep(rep(1:20), each=5)
b   &lt;- c(runif(20), rep(0, 80))
# (i.e., groups 1, 2, 3, 4, are truly significant)
y   &lt;- A %*% b + rnorm(10) 
fdr &lt;- 0.1 # target false discovery rate
# fit a Group SLOPE model
result &lt;- grpSLOPE(X=A, y=y, group=grp, fdr=fdr)
result$selected
# [1] "1"  "2"  "3"  "4"  "14"
result$sigma
# [1] 0.7968632
head(result$group.norms)
#         1         2         3         4         5         6 
#  2.905449  5.516103  8.964201 10.253792  0.000000  0.000000 

</code></pre>

<hr>
<h2 id='lambdaGroupSLOPE'>Regularizing sequence for Group SLOPE</h2><span id='topic+lambdaGroupSLOPE'></span>

<h3>Description</h3>

<p>Generate the regularizing sequence <code>lambda</code> for the Group SLOPE
problem according to one of multiple methods (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaGroupSLOPE(method, fdr, group, wt, n.obs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambdaGroupSLOPE_+3A_method">method</code></td>
<td>
<p>Possible values are &quot;max&quot;, &quot;mean&quot;,
and &quot;corrected&quot;. See under Details.</p>
</td></tr>
<tr><td><code id="lambdaGroupSLOPE_+3A_fdr">fdr</code></td>
<td>
<p>Target group false discovery rate (gFDR)</p>
</td></tr>
<tr><td><code id="lambdaGroupSLOPE_+3A_group">group</code></td>
<td>
<p>A vector describing the grouping structure. It should 
contain a group id for each predictor variable.</p>
</td></tr>
<tr><td><code id="lambdaGroupSLOPE_+3A_wt">wt</code></td>
<td>
<p>A named vector of weights, one weight per group of predictors
(named according to names as in vector <code>group</code>)</p>
</td></tr>
<tr><td><code id="lambdaGroupSLOPE_+3A_n.obs">n.obs</code></td>
<td>
<p>Number of observations (i.e., number of rows in <code>A</code>);
required only if method is &quot;corrected&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple methods are available to generate the regularizing sequence <code>lambda</code>:
</p>

<ul>
<li><p> &quot;max&quot; &ndash; lambdas as in Theorem 2.5 in Brzyski et. al. (2016).
Provalby controls gFDR in orthogonal designs.
</p>
</li>
<li><p> &quot;mean&quot; &ndash; lambdas of equation (2.16) in Brzyski et. al. (2016).
Applicable for gFDR control in orthogonal designs. Less conservative than &quot;max&quot;.
</p>
</li>
<li><p> &quot;corrected&quot; &ndash; lambdas of Procedure 1 in Brzyski et. al. (2016);
in the special case that all group sizes are equal and <code>wt</code> is a constant vector, 
Procedure 6 of Brzyski et. al. (2016) is applied.
Applicable for gFDR control when predictors from different groups are stochastically independent.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector containing the calculated lambda values.
</p>


<h3>References</h3>

<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2016) <em>Group SLOPE &ndash; adaptive selection of groups of predictors</em>, <a href="https://arxiv.org/abs/1610.04960">https://arxiv.org/abs/1610.04960</a>
</p>
<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2019) <em>Group SLOPE &ndash; adaptive selection of groups of predictors</em>. Journal of the American Statistical Association 114 (525): 419–33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify 6 groups of sizes 2, 3, and 4
group &lt;- c(1, 1, 2, 2, 2, 3, 3, 3, 3,
           4, 4, 5, 5, 5, 6, 6, 6, 6)
# set the weight for each group to the square root of the group's size
wt &lt;- rep(c(sqrt(2), sqrt(3), sqrt(4)), 2)
names(wt) &lt;- 1:6
# compute different lambda sequences
lambda.max &lt;- lambdaGroupSLOPE(method="max", fdr=0.1, group=group, wt=wt) 
lambda.mean &lt;- lambdaGroupSLOPE(method="mean", fdr=0.1, group=group, wt=wt) 
lambda.corrected &lt;- lambdaGroupSLOPE(method="corrected", fdr=0.1,
                                     group=group, wt=wt, n.obs=1000)
rbind(lambda.max, lambda.mean, lambda.corrected)
#                      [,1]     [,2]     [,3]     [,4]     [,5]     [,6]
# lambda.max       2.023449 1.844234 1.730818 1.645615 1.576359 1.517427
# lambda.mean      1.880540 1.723559 1.626517 1.554561 1.496603 1.447609
# lambda.corrected 1.880540 1.729811 1.637290 1.568971 1.514028 1.467551

</code></pre>

<hr>
<h2 id='predict.grpSLOPE'>Obtain predictions</h2><span id='topic+predict.grpSLOPE'></span>

<h3>Description</h3>

<p>Obtain predictions from a <code>grpSLOPE</code> model on new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grpSLOPE'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.grpSLOPE_+3A_object">object</code></td>
<td>
<p>A <code>grpSLOPE</code> object</p>
</td></tr>
<tr><td><code id="predict.grpSLOPE_+3A_newdata">newdata</code></td>
<td>
<p>Predictor variables arranged in a matrix</p>
</td></tr>
<tr><td><code id="predict.grpSLOPE_+3A_...">...</code></td>
<td>
<p>Potentially further arguments passed to and from methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>newdata</code> must contain
the same predictor variables as columns in the same order as the
design matrix <code>X</code> that was used for the <code>grpSLOPE</code> model fit.
</p>


<h3>Value</h3>

<p>A vector of length nrow(newdata) containing the resulting predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
A   &lt;- matrix(rnorm(100^2), 100, 100)
grp &lt;- rep(rep(1:20), each = 5)
b   &lt;- c(rep(1, 20), rep(0, 80))
y   &lt;- A %*% b + rnorm(10) 
result &lt;- grpSLOPE(X = A, y = y, group = grp, fdr = 0.1)
newdata &lt;- matrix(rnorm(800), 8, 100)
# group SLOPE predictions:
predict(result, newdata)
# [1] -5.283385 -6.313938 -3.173068  1.901488  9.796677 -0.144516 -0.611164 -5.167620
# true mean values:
as.vector(newdata %*% b)
# [1] -5.0937160 -6.5814111 -3.5776124  2.7877449 11.0668777  1.0253236 -0.4261076 -4.8622940

</code></pre>

<hr>
<h2 id='prox_sorted_L1'>Prox for sorted L1 norm</h2><span id='topic+prox_sorted_L1'></span>

<h3>Description</h3>

<p>Compute the prox for the sorted L1 norm. That is, given a vector <code class="reqn">x</code>
and a decreasing vector <code class="reqn">\lambda</code>, compute the unique value of <code class="reqn">y</code>
minimizing
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2} \Vert x - y \Vert_2^2 +
      \sum_{i=1}^n \lambda_i |x|_{(i)}.</code>
</p>

<p>At present, two methods for computing the sorted L1 prox are
supported. By default, we use a fast custom C implementation. Since SLOPE
can be viewed as an isotonic regression problem, the prox can also be
computed using the <code>isotone</code> package. This option is provided
primarily for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prox_sorted_L1(x, lambda, method = c("c", "isotone"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prox_sorted_L1_+3A_x">x</code></td>
<td>
<p>input vector</p>
</td></tr>
<tr><td><code id="prox_sorted_L1_+3A_lambda">lambda</code></td>
<td>
<p>vector of <code class="reqn">\lambda</code>'s, sorted in decreasing order</p>
</td></tr>
<tr><td><code id="prox_sorted_L1_+3A_method">method</code></td>
<td>
<p>underlying prox implementation, either 'c' or 'isotone'
(see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been adapted (with only cosmetic changes) from
the R package <code>SLOPE</code> version 0.1.3, due to this function being
deprecated and defunct in <code>SLOPE</code> versions which are newer than 0.1.3.
</p>


<h3>Value</h3>

<p>The solution vector <code class="reqn">y</code>.
</p>

<hr>
<h2 id='proxGroupSortedL1'>Prox for group SLOPE</h2><span id='topic+proxGroupSortedL1'></span>

<h3>Description</h3>

<p>Evaluate the proximal mapping for the group SLOPE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proxGroupSortedL1(y, group, lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proxGroupSortedL1_+3A_y">y</code></td>
<td>
<p>The response vector</p>
</td></tr>
<tr><td><code id="proxGroupSortedL1_+3A_group">group</code></td>
<td>
<p>Either a vector or an object of class <code>groupID</code> (e.g.,
as produced by <code><a href="#topic+getGroupID">getGroupID</a></code>), which is describing the
grouping structure. If it is a vector, then it should contain
a group id for each predictor variable.</p>
</td></tr>
<tr><td><code id="proxGroupSortedL1_+3A_lambda">lambda</code></td>
<td>
<p>A decreasing sequence of regularization parameters <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="proxGroupSortedL1_+3A_...">...</code></td>
<td>
<p>Options passed to <code><a href="#topic+prox_sorted_L1">prox_sorted_L1</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>proxGroupSortedL1</code> evaluates the proximal mapping of the group SLOPE
problem by reducing it to the prox for the (regular) SLOPE and then applying
the fast prox algorithm for the Sorted L1 norm.
</p>


<h3>Value</h3>

<p>The solution vector.
</p>


<h3>References</h3>

<p>M. Bogdan, E. van den Berg, C. Sabatti, W. Su, E. Candes (2015), <em>SLOPE &ndash; Adaptive variable selection via convex optimization</em>, <a href="https://arxiv.org/abs/1407.3824">https://arxiv.org/abs/1407.3824</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grp &lt;- c(0,0,0,1,1,0,2,1,0,2)
proxGroupSortedL1(y = 1:10, group = grp, lambda = c(10, 9, 8))
#  [1] 0.2032270 0.4064540 0.6096810 0.8771198 1.0963997 1.2193620 1.3338960
#  [8] 1.7542395 1.8290430 1.9055657

</code></pre>

<hr>
<h2 id='proximalGradientSolverGroupSLOPE'>Proximal gradient method for Group SLOPE</h2><span id='topic+proximalGradientSolverGroupSLOPE'></span>

<h3>Description</h3>

<p>Compute the coefficient estimates for the Group SLOPE problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proximalGradientSolverGroupSLOPE(
  y,
  A,
  group,
  wt,
  lambda,
  max.iter = 10000,
  verbose = FALSE,
  dual.gap.tol = 1e-06,
  infeas.tol = 1e-06,
  x.init = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_y">y</code></td>
<td>
<p>the response vector</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_a">A</code></td>
<td>
<p>the model matrix</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_group">group</code></td>
<td>
<p>A vector describing the grouping structure. It should
contain a group id for each predictor variable.</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_wt">wt</code></td>
<td>
<p>A vector of weights (per coefficient)</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_lambda">lambda</code></td>
<td>
<p>A decreasing sequence of regularization parameters <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximal number of iterations to carry out</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_verbose">verbose</code></td>
<td>
<p>A <code>logical</code> specifying whether to print output or not</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_dual.gap.tol">dual.gap.tol</code></td>
<td>
<p>The tolerance used in the stopping criteria for the duality gap</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_infeas.tol">infeas.tol</code></td>
<td>
<p>The tolerance used in the stopping criteria for the infeasibility</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_x.init">x.init</code></td>
<td>
<p>An optional initial value for the iterative algorithm</p>
</td></tr>
<tr><td><code id="proximalGradientSolverGroupSLOPE_+3A_...">...</code></td>
<td>
<p>Options passed to <code><a href="#topic+prox_sorted_L1">prox_sorted_L1</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>proximalGradientSolverGroupSLOPE</code> computes the coefficient estimates
for the Group SLOPE model. The employed optimization algorithm is FISTA with
backtracking Lipschitz search.
</p>


<h3>Value</h3>

<p>A list with the entries:
</p>

<dl>
<dt>x</dt><dd><p>Solution (n-by-1 matrix)</p>
</dd>
<dt>status</dt><dd><p>Convergence status: 1 if optimal, 2 if iteration limit reached</p>
</dd>
<dt>L</dt><dd><p>Approximation of the Lipschitz constant (step size)</p>
</dd>
<dt>iter</dt><dd><p>Iterations of the proximal gradient method</p>
</dd>
<dt>L.iter</dt><dd><p>Total number of iterations spent in Lipschitz search</p>
</dd>
</dl>



<h3>References</h3>

<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2016) <em>Group SLOPE &ndash; adaptive selection of groups of predictors</em>, <a href="https://arxiv.org/abs/1610.04960">https://arxiv.org/abs/1610.04960</a>
</p>
<p>D. Brzyski, A. Gossmann, W. Su, and M. Bogdan (2019) <em>Group SLOPE &ndash; adaptive selection of groups of predictors</em>. Journal of the American Statistical Association 114 (525): 419–33. <a href="https://doi.org/10.1080/01621459.2017.1411269">doi:10.1080/01621459.2017.1411269</a>
</p>
<p>A. Gossmann, S. Cao, Y.-P. Wang (2015) <em>Identification of Significant Genetic Variants via SLOPE, and Its Extension to Group SLOPE</em>. In Proceedings of ACM BCB 2015. <a href="https://doi.org/10.1145/2808719.2808743">doi:10.1145/2808719.2808743</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
A   &lt;- matrix(runif(100, 0, 1), 10, 10)
grp &lt;- c(0, 0, 1, 1, 2, 2, 2, 2, 2, 3)
wt  &lt;- c(2, 2, 2, 2, 5, 5, 5, 5, 5, 1)
x   &lt;- c(0, 0, 5, 1, 0, 0, 0, 1, 0, 3)
y   &lt;- A %*% x
lam &lt;- 0.1 * (10:7)
result &lt;- proximalGradientSolverGroupSLOPE(y=y, A=A, group=grp, wt=wt, lambda=lam, verbose=FALSE)
result$x
#           [,1]
#  [1,] 0.000000
#  [2,] 0.000000
#  [3,] 3.856005
#  [4,] 2.080736
#  [5,] 0.000000
#  [6,] 0.000000
#  [7,] 0.000000
#  [8,] 0.000000
#  [9,] 0.000000
# [10,] 3.512833

</code></pre>

<hr>
<h2 id='sigma'>Extract (estimated) noise level</h2><span id='topic+sigma'></span><span id='topic+sigma.grpSLOPE'></span>

<h3>Description</h3>

<p>Extract the noise level of the <code>grpSLOPE</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grpSLOPE'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_+3A_object">object</code></td>
<td>
<p>A <code>grpSLOPE</code> object</p>
</td></tr>
<tr><td><code id="sigma_+3A_...">...</code></td>
<td>
<p>Potentially further arguments passed to and from methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This basically obtains <code>object$sigma</code>. For <code>R (&gt;= 3.3.0)</code>
<code>sigma</code> is an S3 method with the default method coming from the
<code>stats</code> package.
</p>


<h3>Value</h3>

<p>The noise level of the given <code>grpSLOPE</code> model. A number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
A   &lt;- matrix(rnorm(100^2), 100, 100)
grp &lt;- rep(rep(1:20), each = 5)
b   &lt;- c(rep(1, 20), rep(0, 80))
y   &lt;- A %*% b + rnorm(10) 
# model with unknown noise level
result &lt;- grpSLOPE(X = A, y = y, group = grp, fdr = 0.1)
sigma(result)
# [1] 0.6505558
# model with known noise level
result &lt;- grpSLOPE(X = A, y = y, group = grp, fdr = 0.1, sigma = 1)
sigma(result)
# [1] 1

</code></pre>

<hr>
<h2 id='SLOPE_solver'>Sorted L1 solver</h2><span id='topic+SLOPE_solver'></span>

<h3>Description</h3>

<p>Solves the sorted L1 penalized regression problem: given a matrix <code class="reqn">A</code>,
a vector <code class="reqn">b</code>, and a decreasing vector <code class="reqn">\lambda</code>, find the vector
<code class="reqn">x</code> minimizing
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}\Vert Ax - b \Vert_2^2 +
      \sum_{i=1}^p \lambda_i |x|_{(i)}.</code>
</p>

<p>This optimization problem is convex and is solved using an accelerated
proximal gradient descent method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SLOPE_solver(
  A,
  b,
  lambda,
  initial = NULL,
  prox = prox_sorted_L1,
  max_iter = 10000,
  grad_iter = 20,
  opt_iter = 1,
  tol_infeas = 1e-06,
  tol_rel_gap = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SLOPE_solver_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">n</code>-by-<code class="reqn">p</code> matrix</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_b">b</code></td>
<td>
<p>vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_lambda">lambda</code></td>
<td>
<p>vector of length <code class="reqn">p</code>, sorted in decreasing order</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_initial">initial</code></td>
<td>
<p>initial guess for <code class="reqn">x</code></p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_prox">prox</code></td>
<td>
<p>function that computes the sorted L1 prox</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations in the gradient descent</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_grad_iter">grad_iter</code></td>
<td>
<p>number of iterations between gradient updates</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_opt_iter">opt_iter</code></td>
<td>
<p>number of iterations between checks for optimality</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_tol_infeas">tol_infeas</code></td>
<td>
<p>tolerance for infeasibility</p>
</td></tr>
<tr><td><code id="SLOPE_solver_+3A_tol_rel_gap">tol_rel_gap</code></td>
<td>
<p>tolerance for relative gap between primal and dual
problems</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been adapted (with only cosmetic changes) from
the R package <code>SLOPE</code> version 0.1.3, due to this function being
deprecated and defunct in <code>SLOPE</code> versions which are newer than 0.1.3.
</p>


<h3>Value</h3>

<p>An object of class <code>SLOPE_solver.result</code>. This object is a list
containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>solution vector <code class="reqn">x</code></p>
</td></tr>
<tr><td><code>optimal</code></td>
<td>
<p>logical: whether the solution is optimal</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
