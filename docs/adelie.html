<!DOCTYPE html><html><head><title>Help for package adelie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adelie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gaussian_cov'><p>Solves group elastic net via covariance method.</p></a></li>
<li><a href='#glm.binomial'><p>Creates a Binomial GLM family object.</p></a></li>
<li><a href='#glm.cox'><p>Creates a Cox GLM family object.</p></a></li>
<li><a href='#glm.gaussian'><p>Creates a Gaussian GLM family object.</p></a></li>
<li><a href='#glm.multigaussian'><p>Creates a MultiGaussian GLM family object.</p></a></li>
<li><a href='#glm.multinomial'><p>Creates a Multinomial GLM family object.</p></a></li>
<li><a href='#glm.poisson'><p>Creates a Poisson GLM family object.</p></a></li>
<li><a href='#grpnet'><p>Solves group elastic net via naive method.</p></a></li>
<li><a href='#io.snp_phased_ancestry'><p>IO handler for SNP phased, ancestry matrix.</p></a></li>
<li><a href='#io.snp_unphased'><p>IO handler for SNP unphased matrix.</p></a></li>
<li><a href='#matrix.block_diag'><p>Creates a block-diagonal matrix.</p></a></li>
<li><a href='#matrix.concatenate'><p>Creates a concatenation of the matrices.</p></a></li>
<li><a href='#matrix.dense'><p>Creates a viewer of a dense matrix.</p></a></li>
<li><a href='#matrix.interaction'><p>Creates a matrix with pairwise interactions.</p></a></li>
<li><a href='#matrix.kronecker_eye'><p>Creates a Kronecker product with identity matrix.</p></a></li>
<li><a href='#matrix.lazy_cov'><p>Creates a lazy covariance matrix.</p></a></li>
<li><a href='#matrix.one_hot'><p>Creates a one-hot encoded matrix.</p></a></li>
<li><a href='#matrix.snp_phased_ancestry'><p>Creates a SNP phased, ancestry matrix.</p></a></li>
<li><a href='#matrix.snp_unphased'><p>Creates a SNP unphased matrix.</p></a></li>
<li><a href='#matrix.sparse'><p>Creates a viewer of a sparse matrix.</p></a></li>
<li><a href='#matrix.standardize'><p>Creates a standardized matrix.</p></a></li>
<li><a href='#matrix.subset'><p>Creates a subset of the matrix along an axis.</p></a></li>
<li><a href='#set_configs'><p>Set configuration settings.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Fast and Flexible Group Elastic Net Solver</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>R bindings for the Python package 'adelie'.
    These bindings offer a general purpose group elastic net solver, 
    a wide range of matrix classes that can exploit special structure 
    to allow large-scale inputs, and an assortment of 
    generalized linear model classes for fitting various types of data. 
    The package is an implementation of Yang, J. and Hastie, T. (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2405.08631">doi:10.48550/arXiv.2405.08631</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, r2r, Rcpp, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, reshape2, latex2exp, cowplot, gridExtra, testthat
(&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JamesYang007/adelie-r">https://github.com/JamesYang007/adelie-r</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JamesYang007/adelie-r/issues">https://github.com/JamesYang007/adelie-r/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-19 14:21:43 UTC; jhyang</td>
</tr>
<tr>
<td>Author:</td>
<td>James Yang [aut, cre, cph],
  Trevor Hastie [aut, cph, fnd],
  Balasubramanian Narasimhan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Yang &lt;jamesyang916@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-20 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gaussian_cov'>Solves group elastic net via covariance method.</h2><span id='topic+gaussian_cov'></span>

<h3>Description</h3>

<p>Solves group elastic net via covariance method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_cov(
  A,
  v,
  constraints = NULL,
  groups = NULL,
  alpha = 1,
  penalty = NULL,
  lmda_path = NULL,
  max_iters = as.integer(1e+05),
  tol = 1e-07,
  rdev_tol = 0.001,
  newton_tol = 1e-12,
  newton_max_iters = 1000,
  n_threads = 1,
  early_exit = TRUE,
  screen_rule = "pivot",
  min_ratio = 0.01,
  lmda_path_size = 100,
  max_screen_size = NULL,
  max_active_size = NULL,
  pivot_subset_ratio = 0.1,
  pivot_subset_min = 1,
  pivot_slack_ratio = 1.25,
  check_state = FALSE,
  progress_bar = TRUE,
  warm_start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_cov_+3A_a">A</code></td>
<td>
<p>Positive semi-definite matrix.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_v">v</code></td>
<td>
<p>Linear term.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_constraints">constraints</code></td>
<td>
<p>Constraints.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_groups">groups</code></td>
<td>
<p>Groups.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_alpha">alpha</code></td>
<td>
<p>Elastic net parameter.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_penalty">penalty</code></td>
<td>
<p>Penalty factor.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_lmda_path">lmda_path</code></td>
<td>
<p>The regularization path.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_max_iters">max_iters</code></td>
<td>
<p>Maximum number of coordinate descents.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_tol">tol</code></td>
<td>
<p>Coordinate descent convergence tolerance.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_rdev_tol">rdev_tol</code></td>
<td>
<p>Relative percent deviance explained tolerance.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_newton_tol">newton_tol</code></td>
<td>
<p>Convergence tolerance for the BCD update.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_newton_max_iters">newton_max_iters</code></td>
<td>
<p>Maximum number of iterations for the BCD update.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_early_exit">early_exit</code></td>
<td>
<p><code>TRUE</code> if the function should early exit.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_screen_rule">screen_rule</code></td>
<td>
<p>Screen rule.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_min_ratio">min_ratio</code></td>
<td>
<p>Ratio between largest and smallest regularization.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_lmda_path_size">lmda_path_size</code></td>
<td>
<p>Number of regularizations.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_max_screen_size">max_screen_size</code></td>
<td>
<p>Maximum number of screen groups.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_max_active_size">max_active_size</code></td>
<td>
<p>Maximum number of active groups.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_pivot_subset_ratio">pivot_subset_ratio</code></td>
<td>
<p>Subset ratio of pivot rule.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_pivot_subset_min">pivot_subset_min</code></td>
<td>
<p>Minimum subset of pivot rule.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_pivot_slack_ratio">pivot_slack_ratio</code></td>
<td>
<p>Slack ratio of pivot rule.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_check_state">check_state</code></td>
<td>
<p>Check state.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Progress bar.</p>
</td></tr>
<tr><td><code id="gaussian_cov_+3A_warm_start">warm_start</code></td>
<td>
<p>Warm start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>State of the solver.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
n &lt;- 100
p &lt;- 200
X &lt;- matrix(rnorm(n * p), n, p)
y &lt;- X[,1] * rnorm(1) + rnorm(n)
A &lt;- t(X) %*% X / n
v &lt;- t(X) %*% y / n
state &lt;- gaussian_cov(A, v)

</code></pre>

<hr>
<h2 id='glm.binomial'>Creates a Binomial GLM family object.</h2><span id='topic+glm.binomial'></span>

<h3>Description</h3>

<p>Creates a Binomial GLM family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.binomial(y, weights = NULL, link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.binomial_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="glm.binomial_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="glm.binomial_+3A_link">link</code></td>
<td>
<p>The link function type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Binomial GLM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
y &lt;- rbinom(n, 1, 0.5)
obj &lt;- glm.binomial(y)
</code></pre>

<hr>
<h2 id='glm.cox'>Creates a Cox GLM family object.</h2><span id='topic+glm.cox'></span>

<h3>Description</h3>

<p>Creates a Cox GLM family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.cox(start, stop, status, weights = NULL, tie_method = "efron")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.cox_+3A_start">start</code></td>
<td>
<p>Start time vector.</p>
</td></tr>
<tr><td><code id="glm.cox_+3A_stop">stop</code></td>
<td>
<p>Stop time vector.</p>
</td></tr>
<tr><td><code id="glm.cox_+3A_status">status</code></td>
<td>
<p>Status vector.</p>
</td></tr>
<tr><td><code id="glm.cox_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="glm.cox_+3A_tie_method">tie_method</code></td>
<td>
<p>The tie-breaking method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cox GLM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
start &lt;- sample.int(20, size=n, replace=TRUE)
stop &lt;- start + 1 + sample.int(5, size=n, replace=TRUE)
status &lt;- rbinom(n, 1, 0.5)
obj &lt;- glm.cox(start, stop, status)
</code></pre>

<hr>
<h2 id='glm.gaussian'>Creates a Gaussian GLM family object.</h2><span id='topic+glm.gaussian'></span>

<h3>Description</h3>

<p>Creates a Gaussian GLM family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.gaussian(y, weights = NULL, opt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.gaussian_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="glm.gaussian_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="glm.gaussian_+3A_opt">opt</code></td>
<td>
<p>If <code>TRUE</code>, an optimized routine is run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gaussian GLM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
y &lt;- rnorm(n)
obj &lt;- glm.gaussian(y)
</code></pre>

<hr>
<h2 id='glm.multigaussian'>Creates a MultiGaussian GLM family object.</h2><span id='topic+glm.multigaussian'></span>

<h3>Description</h3>

<p>Creates a MultiGaussian GLM family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.multigaussian(y, weights = NULL, opt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.multigaussian_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="glm.multigaussian_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="glm.multigaussian_+3A_opt">opt</code></td>
<td>
<p>If <code>TRUE</code>, an optimized routine is run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MultiGaussian GLM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
K &lt;- 5
y &lt;- matrix(rnorm(n*K), n, K)
obj &lt;- glm.multigaussian(y)
</code></pre>

<hr>
<h2 id='glm.multinomial'>Creates a Multinomial GLM family object.</h2><span id='topic+glm.multinomial'></span>

<h3>Description</h3>

<p>Creates a Multinomial GLM family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.multinomial(y, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.multinomial_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="glm.multinomial_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multinomial GLM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
K &lt;- 5
y &lt;- t(rmultinom(n, 1, rep(1/K, K)))
obj &lt;- glm.multinomial(y)
</code></pre>

<hr>
<h2 id='glm.poisson'>Creates a Poisson GLM family object.</h2><span id='topic+glm.poisson'></span>

<h3>Description</h3>

<p>Creates a Poisson GLM family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.poisson(y, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.poisson_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="glm.poisson_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Poisson GLM object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
y &lt;- rpois(n, 1)
obj &lt;- glm.poisson(y)
</code></pre>

<hr>
<h2 id='grpnet'>Solves group elastic net via naive method.</h2><span id='topic+grpnet'></span>

<h3>Description</h3>

<p>Solves group elastic net via naive method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grpnet(
  X,
  glm,
  constraints = NULL,
  groups = NULL,
  alpha = 1,
  penalty = NULL,
  offsets = NULL,
  lmda_path = NULL,
  irls_max_iters = as.integer(10000),
  irls_tol = 1e-07,
  max_iters = as.integer(1e+05),
  tol = 1e-07,
  adev_tol = 0.9,
  ddev_tol = 0,
  newton_tol = 1e-12,
  newton_max_iters = 1000,
  n_threads = 1,
  early_exit = TRUE,
  intercept = TRUE,
  screen_rule = "pivot",
  min_ratio = 0.01,
  lmda_path_size = 100,
  max_screen_size = NULL,
  max_active_size = NULL,
  pivot_subset_ratio = 0.1,
  pivot_subset_min = 1,
  pivot_slack_ratio = 1.25,
  check_state = FALSE,
  progress_bar = TRUE,
  warm_start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grpnet_+3A_x">X</code></td>
<td>
<p>Feature matrix.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_glm">glm</code></td>
<td>
<p>GLM object.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_constraints">constraints</code></td>
<td>
<p>Constraints.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_groups">groups</code></td>
<td>
<p>Groups.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_alpha">alpha</code></td>
<td>
<p>Elastic net parameter.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_penalty">penalty</code></td>
<td>
<p>Penalty factor.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_offsets">offsets</code></td>
<td>
<p>Offsets.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_lmda_path">lmda_path</code></td>
<td>
<p>The regularization path.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_irls_max_iters">irls_max_iters</code></td>
<td>
<p>Maximum number of IRLS iterations.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_irls_tol">irls_tol</code></td>
<td>
<p>IRLS convergence tolerance.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_max_iters">max_iters</code></td>
<td>
<p>Maximum number of coordinate descents.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_tol">tol</code></td>
<td>
<p>Coordinate descent convergence tolerance.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_adev_tol">adev_tol</code></td>
<td>
<p>Percent deviance explained tolerance.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_ddev_tol">ddev_tol</code></td>
<td>
<p>Difference in percent deviance explained tolerance.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_newton_tol">newton_tol</code></td>
<td>
<p>Convergence tolerance for the BCD update.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_newton_max_iters">newton_max_iters</code></td>
<td>
<p>Maximum number of iterations for the BCD update.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_early_exit">early_exit</code></td>
<td>
<p><code>TRUE</code> if the function should early exit.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_intercept">intercept</code></td>
<td>
<p><code>TRUE</code> to fit with intercept.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_screen_rule">screen_rule</code></td>
<td>
<p>Screen rule.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_min_ratio">min_ratio</code></td>
<td>
<p>Ratio between largest and smallest regularization.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_lmda_path_size">lmda_path_size</code></td>
<td>
<p>Number of regularizations.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_max_screen_size">max_screen_size</code></td>
<td>
<p>Maximum number of screen groups.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_max_active_size">max_active_size</code></td>
<td>
<p>Maximum number of active groups.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_pivot_subset_ratio">pivot_subset_ratio</code></td>
<td>
<p>Subset ratio of pivot rule.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_pivot_subset_min">pivot_subset_min</code></td>
<td>
<p>Minimum subset of pivot rule.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_pivot_slack_ratio">pivot_slack_ratio</code></td>
<td>
<p>Slack ratio of pivot rule.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_check_state">check_state</code></td>
<td>
<p>Check state.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Progress bar.</p>
</td></tr>
<tr><td><code id="grpnet_+3A_warm_start">warm_start</code></td>
<td>
<p>Warm start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>State of the solver.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
n &lt;- 100
p &lt;- 200
X &lt;- matrix(rnorm(n * p), n, p)
y &lt;- X[,1] * rnorm(1) + rnorm(n)
state &lt;- grpnet(X, glm.gaussian(y))

</code></pre>

<hr>
<h2 id='io.snp_phased_ancestry'>IO handler for SNP phased, ancestry matrix.</h2><span id='topic+io.snp_phased_ancestry'></span>

<h3>Description</h3>

<p>IO handler for SNP phased, ancestry matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>io.snp_phased_ancestry(filename, read_mode = "file")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="io.snp_phased_ancestry_+3A_filename">filename</code></td>
<td>
<p>File name.</p>
</td></tr>
<tr><td><code id="io.snp_phased_ancestry_+3A_read_mode">read_mode</code></td>
<td>
<p>Reading mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IO handler for SNP phased, ancestry data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 123
s &lt;- 423
A &lt;- 8
filename &lt;- paste(tempdir(), "snp_phased_ancestry_dummy.snpdat", sep="/")
handle &lt;- io.snp_phased_ancestry(filename)
calldata &lt;- matrix(
    as.integer(sample.int(
        2, n * s * 2,
        replace=TRUE,
        prob=c(0.7, 0.3)
    ) - 1),
    n, s * 2
)
ancestries &lt;- matrix(
    as.integer(sample.int(
        A, n * s * 2,
        replace=TRUE,
        prob=rep_len(1/A, A)
    ) - 1),
    n, s * 2
)
handle$write(calldata, ancestries, A, 1)
handle$read()
file.remove(filename)
</code></pre>

<hr>
<h2 id='io.snp_unphased'>IO handler for SNP unphased matrix.</h2><span id='topic+io.snp_unphased'></span>

<h3>Description</h3>

<p>IO handler for SNP unphased matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>io.snp_unphased(filename, read_mode = "file")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="io.snp_unphased_+3A_filename">filename</code></td>
<td>
<p>File name.</p>
</td></tr>
<tr><td><code id="io.snp_unphased_+3A_read_mode">read_mode</code></td>
<td>
<p>Reading mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IO handler for SNP unphased data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 123
s &lt;- 423
filename &lt;- paste(tempdir(), "snp_unphased_dummy.snpdat", sep="/")
handle &lt;- io.snp_unphased(filename)
mat &lt;- matrix(
    as.integer(sample.int(
        3, n * s, 
        replace=TRUE, 
        prob=c(0.7, 0.2, 0.1)
    ) - 1),
    n, s
)
impute &lt;- double(s)
handle$write(mat, "mean", impute, 1)
handle$read()
file.remove(filename)
</code></pre>

<hr>
<h2 id='matrix.block_diag'>Creates a block-diagonal matrix.</h2><span id='topic+matrix.block_diag'></span>

<h3>Description</h3>

<p>Creates a block-diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.block_diag(mats, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.block_diag_+3A_mats">mats</code></td>
<td>
<p>List of matrices.</p>
</td></tr>
<tr><td><code id="matrix.block_diag_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Block-diagonal matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
ps &lt;- c(10, 20, 30)
mats &lt;- lapply(ps, function(p) {
    X &lt;- matrix(rnorm(n * p), n, p)
    matrix.dense(t(X) %*% X, method="cov")
})
out &lt;- matrix.block_diag(mats)
</code></pre>

<hr>
<h2 id='matrix.concatenate'>Creates a concatenation of the matrices.</h2><span id='topic+matrix.concatenate'></span>

<h3>Description</h3>

<p>Creates a concatenation of the matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.concatenate(mats, axis = 0, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.concatenate_+3A_mats">mats</code></td>
<td>
<p>List of matrices.</p>
</td></tr>
<tr><td><code id="matrix.concatenate_+3A_axis">axis</code></td>
<td>
<p>The axis along which the matrices will be joined.</p>
</td></tr>
<tr><td><code id="matrix.concatenate_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Concatenation of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
ps &lt;- c(10, 20, 30)
mats &lt;- lapply(ps, function(p) { 
    matrix.dense(matrix(rnorm(n * p), n, p))
})
out &lt;- matrix.concatenate(mats, axis=1)
ns &lt;- c(10, 20, 30)
p &lt;- 100
mats &lt;- lapply(ns, function(n) { 
    matrix.dense(matrix(rnorm(n * p), n, p))
})
out &lt;- matrix.concatenate(mats, axis=0)
</code></pre>

<hr>
<h2 id='matrix.dense'>Creates a viewer of a dense matrix.</h2><span id='topic+matrix.dense'></span>

<h3>Description</h3>

<p>Creates a viewer of a dense matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.dense(mat, method = "naive", n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.dense_+3A_mat">mat</code></td>
<td>
<p>The dense matrix.</p>
</td></tr>
<tr><td><code id="matrix.dense_+3A_method">method</code></td>
<td>
<p>Method type.</p>
</td></tr>
<tr><td><code id="matrix.dense_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dense matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X_dense &lt;- matrix(rnorm(n * p), n, p)
out &lt;- matrix.dense(X_dense, method="naive")
A_dense &lt;- t(X_dense) %*% X_dense
out &lt;- matrix.dense(A_dense, method="cov")
</code></pre>

<hr>
<h2 id='matrix.interaction'>Creates a matrix with pairwise interactions.</h2><span id='topic+matrix.interaction'></span>

<h3>Description</h3>

<p>Creates a matrix with pairwise interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.interaction(mat, intr_keys, intr_values, levels = NULL, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.interaction_+3A_mat">mat</code></td>
<td>
<p>The dense matrix.</p>
</td></tr>
<tr><td><code id="matrix.interaction_+3A_intr_keys">intr_keys</code></td>
<td>
<p>List of feature indices.</p>
</td></tr>
<tr><td><code id="matrix.interaction_+3A_intr_values">intr_values</code></td>
<td>
<p>List of list of feature indices.</p>
</td></tr>
<tr><td><code id="matrix.interaction_+3A_levels">levels</code></td>
<td>
<p>Levels.</p>
</td></tr>
<tr><td><code id="matrix.interaction_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pairwise interaction matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
p &lt;- 20
X_dense &lt;- matrix(rnorm(n * p), n, p)
X_dense[,1] &lt;- rbinom(n, 4, 0.5)
intr_keys &lt;- c(0, 1)
intr_values &lt;- list(NULL, c(0, 2))
levels &lt;- c(c(5), rep(0, p-1))
out &lt;- matrix.interaction(X_dense, intr_keys, intr_values, levels)
</code></pre>

<hr>
<h2 id='matrix.kronecker_eye'>Creates a Kronecker product with identity matrix.</h2><span id='topic+matrix.kronecker_eye'></span>

<h3>Description</h3>

<p>Creates a Kronecker product with identity matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.kronecker_eye(mat, K, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.kronecker_eye_+3A_mat">mat</code></td>
<td>
<p>The matrix to view as a Kronecker product.</p>
</td></tr>
<tr><td><code id="matrix.kronecker_eye_+3A_k">K</code></td>
<td>
<p>Dimension of the identity matrix.</p>
</td></tr>
<tr><td><code id="matrix.kronecker_eye_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kronecker product with identity matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
K &lt;- 2
mat &lt;- matrix(rnorm(n * p), n, p)
out &lt;- matrix.kronecker_eye(mat, K)
mat &lt;- matrix.dense(mat)
out &lt;- matrix.kronecker_eye(mat, K)
</code></pre>

<hr>
<h2 id='matrix.lazy_cov'>Creates a lazy covariance matrix.</h2><span id='topic+matrix.lazy_cov'></span>

<h3>Description</h3>

<p>Creates a lazy covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.lazy_cov(mat, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.lazy_cov_+3A_mat">mat</code></td>
<td>
<p>The data matrix.</p>
</td></tr>
<tr><td><code id="matrix.lazy_cov_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lazy covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
mat &lt;- matrix(rnorm(n * p), n, p)
out &lt;- matrix.lazy_cov(mat)
</code></pre>

<hr>
<h2 id='matrix.one_hot'>Creates a one-hot encoded matrix.</h2><span id='topic+matrix.one_hot'></span>

<h3>Description</h3>

<p>Creates a one-hot encoded matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.one_hot(mat, levels = NULL, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.one_hot_+3A_mat">mat</code></td>
<td>
<p>The dense matrix.</p>
</td></tr>
<tr><td><code id="matrix.one_hot_+3A_levels">levels</code></td>
<td>
<p>Levels.</p>
</td></tr>
<tr><td><code id="matrix.one_hot_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One-hot encoded matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
mat &lt;- matrix(rnorm(n * p), n, p)
out &lt;- matrix.one_hot(mat)
</code></pre>

<hr>
<h2 id='matrix.snp_phased_ancestry'>Creates a SNP phased, ancestry matrix.</h2><span id='topic+matrix.snp_phased_ancestry'></span>

<h3>Description</h3>

<p>Creates a SNP phased, ancestry matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.snp_phased_ancestry(io, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.snp_phased_ancestry_+3A_io">io</code></td>
<td>
<p>IO handler.</p>
</td></tr>
<tr><td><code id="matrix.snp_phased_ancestry_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SNP phased, ancestry matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 123
s &lt;- 423
A &lt;- 8
filename &lt;- paste(tempdir(), "snp_phased_ancestry_dummy.snpdat", sep="/")
handle &lt;- io.snp_phased_ancestry(filename)
calldata &lt;- matrix(
    as.integer(sample.int(
        2, n * s * 2,
        replace=TRUE,
        prob=c(0.7, 0.3)
    ) - 1),
    n, s * 2
)
ancestries &lt;- matrix(
    as.integer(sample.int(
        A, n * s * 2,
        replace=TRUE,
        prob=rep_len(1/A, A)
    ) - 1),
    n, s * 2
)
handle$write(calldata, ancestries, A, 1)
out &lt;- matrix.snp_phased_ancestry(handle)
file.remove(filename)
</code></pre>

<hr>
<h2 id='matrix.snp_unphased'>Creates a SNP unphased matrix.</h2><span id='topic+matrix.snp_unphased'></span>

<h3>Description</h3>

<p>Creates a SNP unphased matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.snp_unphased(io, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.snp_unphased_+3A_io">io</code></td>
<td>
<p>IO handler.</p>
</td></tr>
<tr><td><code id="matrix.snp_unphased_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SNP unphased matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 123
s &lt;- 423
filename &lt;- paste(tempdir(), "snp_unphased_dummy.snpdat", sep="/")
handle &lt;- io.snp_unphased(filename)
mat &lt;- matrix(
    as.integer(sample.int(
        3, n * s, 
        replace=TRUE, 
        prob=c(0.7, 0.2, 0.1)
    ) - 1),
    n, s
)
impute &lt;- double(s)
handle$write(mat, "mean", impute, 1)
out &lt;- matrix.snp_unphased(handle)
file.remove(filename)
</code></pre>

<hr>
<h2 id='matrix.sparse'>Creates a viewer of a sparse matrix.</h2><span id='topic+matrix.sparse'></span>

<h3>Description</h3>

<p>Creates a viewer of a sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.sparse(mat, method = "naive", n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.sparse_+3A_mat">mat</code></td>
<td>
<p>The sparse matrix to view.</p>
</td></tr>
<tr><td><code id="matrix.sparse_+3A_method">method</code></td>
<td>
<p>Method type.</p>
</td></tr>
<tr><td><code id="matrix.sparse_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sparse matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X_dense &lt;- matrix(rnorm(n * p), n, p)
X_sp &lt;- as(X_dense, "dgCMatrix")
out &lt;- matrix.sparse(X_sp, method="naive")
A_dense &lt;- t(X_dense) %*% X_dense
A_sp &lt;- as(A_dense, "dgCMatrix")
out &lt;- matrix.sparse(A_sp, method="cov")
</code></pre>

<hr>
<h2 id='matrix.standardize'>Creates a standardized matrix.</h2><span id='topic+matrix.standardize'></span>

<h3>Description</h3>

<p>Creates a standardized matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.standardize(mat, centers = NULL, scales = NULL, ddof = 0, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.standardize_+3A_mat">mat</code></td>
<td>
<p>The underlying matrix.</p>
</td></tr>
<tr><td><code id="matrix.standardize_+3A_centers">centers</code></td>
<td>
<p>The center values.</p>
</td></tr>
<tr><td><code id="matrix.standardize_+3A_scales">scales</code></td>
<td>
<p>The scale values.</p>
</td></tr>
<tr><td><code id="matrix.standardize_+3A_ddof">ddof</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code id="matrix.standardize_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardized matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix(rnorm(n * p), n, p)
out &lt;- matrix.standardize(matrix.dense(X))
</code></pre>

<hr>
<h2 id='matrix.subset'>Creates a subset of the matrix along an axis.</h2><span id='topic+matrix.subset'></span>

<h3>Description</h3>

<p>Creates a subset of the matrix along an axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.subset(mat, indices, axis = 0, n_threads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.subset_+3A_mat">mat</code></td>
<td>
<p>The matrix to subset.</p>
</td></tr>
<tr><td><code id="matrix.subset_+3A_indices">indices</code></td>
<td>
<p>Array of indices to subset the matrix.</p>
</td></tr>
<tr><td><code id="matrix.subset_+3A_axis">axis</code></td>
<td>
<p>The axis along which to subset.</p>
</td></tr>
<tr><td><code id="matrix.subset_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset of the matrix along an axis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
p &lt;- 20
X &lt;- matrix.dense(matrix(rnorm(n * p), n, p))
indices &lt;- c(1, 3, 10)
out &lt;- matrix.subset(X, indices, axis=0)
out &lt;- matrix.subset(X, indices, axis=1)
</code></pre>

<hr>
<h2 id='set_configs'>Set configuration settings.</h2><span id='topic+set_configs'></span>

<h3>Description</h3>

<p>Set configuration settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_configs(name, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_configs_+3A_name">name</code></td>
<td>
<p>Configuration variable name.</p>
</td></tr>
<tr><td><code id="set_configs_+3A_value">value</code></td>
<td>
<p>Value to assign to the configuration variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Assigned value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_configs("hessian_min", 1e-6)
set_configs("hessian_min")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
