<!DOCTYPE html><html><head><title>Help for package revdbayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {revdbayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binpost'><p>Random sampling from a binomial posterior distribution</p></a></li>
<li><a href='#create_prior_xptr'><p>Create an external pointer to a C++ prior</p></a></li>
<li><a href='#dgaps_post'><p>Random sampling from D-gaps posterior distribution</p></a></li>
<li><a href='#gev'><p>The Generalised Extreme Value Distribution</p></a></li>
<li><a href='#gev_beta'><p>Beta-type prior for GEV shape parameter <code class="reqn">\xi</code></p></a></li>
<li><a href='#gev_flat'><p>Flat prior for GEV parameters (<code class="reqn">\mu, log \sigma, \xi</code>)</p></a></li>
<li><a href='#gev_flatflat'><p>Flat prior for GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>)</p></a></li>
<li><a href='#gev_loglognorm'><p>Trivariate normal prior for GEV parameters (<code class="reqn">log \mu, log \sigma, \xi</code>)</p></a></li>
<li><a href='#gev_mdi'><p>Maximal data information (MDI) prior for GEV parameters</p>
(<code class="reqn">\mu, \sigma, \xi</code>)</a></li>
<li><a href='#gev_norm'><p>Trivariate normal prior for GEV parameters (<code class="reqn">\mu, log \sigma, \xi</code>)</p></a></li>
<li><a href='#gev_prob'><p>Informative GEV prior on a probability scale</p></a></li>
<li><a href='#gev_quant'><p>Informative GEV prior on a quantile scale</p></a></li>
<li><a href='#gom'><p>Storm peak significant wave heights from the Gulf of Mexico</p></a></li>
<li><a href='#gp'><p>The Generalised Pareto Distribution</p></a></li>
<li><a href='#gp_beta'><p>Beta-type prior for GP shape parameter <code class="reqn">\xi</code></p></a></li>
<li><a href='#gp_flat'><p>Flat prior for GP parameters (<code class="reqn">log \sigma, \xi</code>)</p></a></li>
<li><a href='#gp_flatflat'><p>Flat prior for GP parameters (<code class="reqn">\sigma, \xi</code>)</p></a></li>
<li><a href='#gp_jeffreys'><p>Jeffreys prior for GP parameters (<code class="reqn">\sigma, \xi</code>)</p></a></li>
<li><a href='#gp_lrs'><p>Linear Combinations of Ratios of Spacings estimation of generalised Pareto</p>
parameters</a></li>
<li><a href='#gp_mdi'><p>Maximal data information (MDI) prior for GP parameters</p>
(<code class="reqn">\sigma, \xi</code>)</a></li>
<li><a href='#gp_norm'><p>Bivariate normal prior for GP parameters (<code class="reqn">log \sigma, \xi</code>)</p></a></li>
<li><a href='#gp_pwm'><p>Probability-weighted moments estimation of generalised Pareto parameters</p></a></li>
<li><a href='#grimshaw_gp_mle'><p>Maximum likelihood estimation of generalised Pareto parameters</p></a></li>
<li><a href='#kgaps_post'><p>Random sampling from K-gaps posterior distribution</p></a></li>
<li><a href='#newlyn'><p>Newlyn sea surges</p></a></li>
<li><a href='#oxford'><p>Annual Maximum Temperatures at Oxford</p></a></li>
<li><a href='#plot.evpost'><p>Plot diagnostics for an evpost object</p></a></li>
<li><a href='#plot.evpred'><p>Plot diagnostics for an evpred object</p></a></li>
<li><a href='#portpirie'><p>Annual Maximum Sea Levels at Port Pirie, South Australia</p></a></li>
<li><a href='#pp_check.evpost'><p>Posterior predictive checks for an evpost object</p></a></li>
<li><a href='#predict.evpost'><p>Predictive inference for the largest value observed in <code class="reqn">N</code> years.</p></a></li>
<li><a href='#print.evpost'><p>Print method for objects of class &quot;evpost&quot;</p></a></li>
<li><a href='#print.summary.evpost'><p>Print method for objects of class &quot;summary.evpost&quot;</p></a></li>
<li><a href='#quantile_to_gev'><p>Converts quantiles to GEV parameters</p></a></li>
<li><a href='#rainfall'><p>Daily Aggregate Rainfall</p></a></li>
<li><a href='#rDir'><p>Simulation from a Dirichlet distribution</p></a></li>
<li><a href='#revdbayes-internal'><p>Internal revdbayes functions</p></a></li>
<li><a href='#revdbayes-package'><p>revdbayes: Ratio-of-Uniforms Sampling for Bayesian Extreme Value Analysis</p></a></li>
<li><a href='#rpost'><p>Random sampling from extreme value posterior distributions</p></a></li>
<li><a href='#rpost_rcpp'><p>Random sampling from extreme value posterior distributions</p></a></li>
<li><a href='#rprior_prob'><p>Prior simulation of GEV parameters - prior on probability scale</p></a></li>
<li><a href='#rprior_quant'><p>Prior simulation of GEV parameters - prior on quantile scale</p></a></li>
<li><a href='#set_bin_prior'><p>Construction of a prior distribution for a binomial probability <code class="reqn">p</code></p></a></li>
<li><a href='#set_prior'><p>Construction of prior distributions for extreme value model parameters</p></a></li>
<li><a href='#summary.evpost'><p>Summarizing an evpost object</p></a></li>
<li><a href='#venice'><p>Largest Sea Levels in Venice</p></a></li>
<li><a href='#wbinpost'><p>Random sampling from a binomial posterior distribution, using weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Ratio-of-Uniforms Sampling for Bayesian Extreme Value Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for the Bayesian analysis of extreme value
    models.  The 'rust' package <a href="https://cran.r-project.org/package=rust">https://cran.r-project.org/package=rust</a> is
    used to simulate a random sample from the required posterior distribution.
    The functionality of 'revdbayes' is similar to the 'evdbayes' package
    <a href="https://cran.r-project.org/package=evdbayes">https://cran.r-project.org/package=evdbayes</a>, which uses Markov Chain
    Monte Carlo ('MCMC') methods for posterior simulation.  In addition, there
    are functions for making inferences about the extremal index, using 
    the models for threshold inter-exceedance times of Suveges and Davison 
    (2010) &lt;<a href="https://doi.org/10.1214%2F09-AOAS292">doi:10.1214/09-AOAS292</a>&gt; and Holesovsky and Fusek (2020) 
    &lt;<a href="https://doi.org/10.1007%2Fs10687-020-00374-3">doi:10.1007/s10687-020-00374-3</a>&gt;. Also provided are d,p,q,r functions for 
    the Generalised Extreme Value ('GEV') and Generalised Pareto ('GP') 
    distributions that deal appropriately with cases where the shape parameter 
    is very close to zero.</td>
</tr>
<tr>
<td>Imports:</td>
<td>bayesplot (&ge; 1.1.0), exdex, graphics, Rcpp, rust (&ge; 1.2.2),
stats, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0),</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 2.2.1), knitr, microbenchmark, rmarkdown,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulnorthrop.github.io/revdbayes/">https://paulnorthrop.github.io/revdbayes/</a>,
<a href="https://github.com/paulnorthrop/revdbayes">https://github.com/paulnorthrop/revdbayes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulnorthrop/revdbayes/issues">https://github.com/paulnorthrop/revdbayes/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.10), RcppArmadillo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 20:18:05 UTC; Paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul J. Northrop [aut, cre, cph],
  Scott D. Grimshaw [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 00:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='binpost'>Random sampling from a binomial posterior distribution</h2><span id='topic+binpost'></span>

<h3>Description</h3>

<p>Samples from the posterior distribution of the probability <code class="reqn">p</code>
of a binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binpost(n, prior, ds_bin, param = c("logit", "p"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binpost_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="binpost_+3A_prior">prior</code></td>
<td>
<p>A function to evaluate the prior, created by
<code><a href="#topic+set_bin_prior">set_bin_prior</a></code>.</p>
</td></tr>
<tr><td><code id="binpost_+3A_ds_bin">ds_bin</code></td>
<td>
<p>A numeric list.  Sufficient statistics for inference
about a binomial probability <code class="reqn">p</code>.  Contains
</p>

<ul>
<li> <p><code>n_raw</code> : number of raw observations.
</p>
</li>
<li> <p><code>m</code> : number of threshold exceedances.
</p>
</li></ul>
</td></tr>
<tr><td><code id="binpost_+3A_param">param</code></td>
<td>
<p>A character scalar.  Only relevant if <code>prior$prior</code> is a
(user-supplied) R function.  <code>param</code> specifies the parameterization
of the posterior distribution that <code><a href="rust.html#topic+ru">ru</a></code> uses for
sampling.
</p>
<p>If <code>param = "p"</code> the original parameterization <code class="reqn">p</code> is
used.
</p>
<p>If <code>param = "logit"</code> (the default) then <code><a href="rust.html#topic+ru">ru</a></code>
samples from the posterior for the logit of <code class="reqn">p</code>, before transforming
back to the <code class="reqn">p</code>-scale.
</p>
<p>The latter tends to make the optimizations involved in the
ratio-of-uniforms algorithm more stable and to increase the probability
of acceptance, but at the expense of slower function evaluations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>prior$prior == "bin_beta"</code> then the posterior for <code class="reqn">p</code>
is a beta distribution so <code><a href="stats.html#topic+Beta">rbeta</a></code> is used to
sample from the posterior.
</p>
<p>If <code>prior$prior == "bin_mdi"</code> then
rejection sampling is used to sample from the posterior with an envelope
function equal to the density of a
beta(<code>ds$m</code> + 1, <code>ds$n_raw - ds$m</code> + 1) density.
</p>
<p>If <code>prior$prior == "bin_northrop"</code> then
rejection sampling is used to sample from the posterior with an envelope
function equal to the posterior density that results from using a
Haldane prior.
</p>
<p>If <code>prior$prior</code> is a (user-supplied) R function then
<code><a href="rust.html#topic+ru">ru</a></code> is used to sample from the posterior using the
generalised ratio-of-uniforms method.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"binpost"</code> with components
</p>
<table>
<tr><td><code>bin_sim_vals:</code></td>
<td>
<p>An <code>n</code> by 1 numeric matrix of values
simulated from the posterior for the binomial
probability <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>bin_logf:</code></td>
<td>
<p>A function returning the log-posterior for
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>bin_logf_args:</code></td>
<td>
<p>A list of arguments to <code>bin_logf</code>.</p>
</td></tr>
</table>
<p>If <code>prior$prior</code> is a (user-supplied) R function then this list
also contains <code>ru_object</code> the object of class <code>"ru"</code>
returned by <code><a href="rust.html#topic+ru">ru</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_bin_prior">set_bin_prior</a></code> for setting a prior distribution
for the binomial probability <code class="reqn">p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- quantile(gom, probs = 0.65)
ds_bin &lt;- list()
ds_bin$n_raw &lt;- length(gom)
ds_bin$m &lt;- sum(gom &gt; u)
bp &lt;- set_bin_prior(prior = "jeffreys")
temp &lt;- binpost(n = 1000, prior = bp, ds_bin = ds_bin)
graphics::hist(temp$bin_sim_vals, prob = TRUE)

# Setting a beta prior (Jeffreys in this case) by hand
beta_prior_fn &lt;- function(p, ab) {
  return(stats::dbeta(p, shape1 = ab[1], shape2 = ab[2], log = TRUE))
}
jeffreys &lt;- set_bin_prior(beta_prior_fn, ab = c(1 / 2, 1 / 2))
temp &lt;- binpost(n = 1000, prior = jeffreys, ds_bin = ds_bin)
</code></pre>

<hr>
<h2 id='create_prior_xptr'>Create an external pointer to a C++ prior</h2><span id='topic+create_prior_xptr'></span>

<h3>Description</h3>

<p>This function provides an example of a way in which a user can specify
their own prior density to <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.
More specifically, a function like this (the user will need to create
an edited version tailored to their own C++ function(s)) can be used to
generate an external pointer to a compiled C++ function that evaluates
the log-prior density.  Please see the vignette
&quot;Faster simulation using revdbayes&quot; for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_prior_xptr(fstr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_prior_xptr_+3A_fstr">fstr</code></td>
<td>
<p>A string indicating the C++ function required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that the user's C++ functions are in a file called &quot;user_fns.cpp&quot;.
These functions must be compiled and made available to R before the
pointer is created. This can be achieved using the function
<code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code> in the <strong>Rcpp</strong> package
or using RStudio's Source button on the editor toolbar.
</p>
<p>For details see the examples in the documentation of the functions
<code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> and <code><a href="#topic+set_prior">set_prior</a></code>,
the vignette &quot;Faster simulation using revdbayes&quot;
and the vignette &quot;Rusting Faster: Simulation using Rcpp&quot; in the package
<strong>rust</strong>.
</p>


<h3>Value</h3>

<p>An external pointer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code> to specify a prior distribution using
an external pointer returned by <code>create_prior_xptr</code> and for
details of in-built named prior distributions.
</p>
<p>The examples in the documentation of <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ptr_gp_flat &lt;- create_prior_xptr("gp_flat")
prior_cfn &lt;- set_prior(prior = ptr_gp_flat, model = "gp", min_xi = -1)

ptr_gev_flat &lt;- create_prior_xptr("gev_flat")
prior_cfn &lt;- set_prior(prior = ptr_gev_flat, model = "gev", min_xi = -1,
                       max_xi = Inf)

mat &lt;- diag(c(10000, 10000, 100))
ptr_gev_norm &lt;- create_prior_xptr("gev_norm")
pn_u &lt;- set_prior(prior = ptr_gev_norm, model = "gev", mean = c(0,0,0),
                  icov = solve(mat))
</code></pre>

<hr>
<h2 id='dgaps_post'>Random sampling from D-gaps posterior distribution</h2><span id='topic+dgaps_post'></span>

<h3>Description</h3>

<p>Uses the <code><a href="rust.html#topic+rust">rust</a></code> package to simulate from the posterior
distribution of the extremal index <code class="reqn">\theta</code> based on the D-gaps model
for threshold interexceedance times of Holesovsky and Fusek (2020). We refer
to this as the <code class="reqn">D</code>-gaps model, because it uses a tuning parameter
<code class="reqn">D</code>, whereas the related <code class="reqn">K</code>-gaps model of Suveges and Davison
(2010) has a tuning parameter <code class="reqn">K</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgaps_post(
  data,
  thresh,
  D = 1,
  n = 1000,
  inc_cens = TRUE,
  alpha = 1,
  beta = 1,
  param = c("logit", "theta"),
  use_rcpp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgaps_post_+3A_data">data</code></td>
<td>
<p>A numeric vector or numeric matrix of raw data.  If <code>data</code>
is a matrix then the log-likelihood is constructed as the sum of
(independent) contributions from different columns. A common situation is
where each column relates to a different year.
</p>
<p>If <code>data</code> contains missing values then
<code><a href="exdex.html#topic+split_by_NAs">split_by_NAs</a></code> is used to divide the data further into
sequences of non-missing values, stored in different columns in a matrix.
Again, the log-likelihood is constructed as a sum of contributions from
different columns.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_thresh">thresh</code></td>
<td>
<p>A numeric scalar.  Extreme value threshold applied to data.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_d">D</code></td>
<td>
<p>A numeric scalar.  The censoring parameter <code class="reqn">D</code>, as defined in
Holesovsky and Fusek (2020). Threshold inter-exceedances times that are
not larger than <code>D</code> units are left-censored, occurring with
probability <code class="reqn">\log(1 - \theta e^{-\theta d})</code>,
where <code class="reqn">d = q D</code> and <code class="reqn">q</code> is the probability with which the
threshold <code class="reqn">u</code> is exceeded.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_inc_cens">inc_cens</code></td>
<td>
<p>A logical scalar indicating whether or not to include
contributions from right-censored inter-exceedance times, relating to the
first and last observations. It is known that these times are greater
than or equal to the time observed.
If <code>data</code> has multiple columns then there will be right-censored
first and last inter-exceedance times for each column. See also the
<strong>Details</strong> section of <code><a href="exdex.html#topic+dgaps">dgaps</a></code>.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_alpha">alpha</code>, <code id="dgaps_post_+3A_beta">beta</code></td>
<td>
<p>Positive numeric scalars.  Parameters of a
beta(<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>) prior for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_param">param</code></td>
<td>
<p>A character scalar.  If <code>param = "logit"</code> (the default)
then we simulate from the posterior distribution of
<code class="reqn">\phi = \log(\theta / (1-\theta))</code>
and then transform back to the
<code class="reqn">\theta</code>-scale.  If <code>param = "theta"</code> then we simulate
directly from the posterior distribution of <code class="reqn">\theta</code>, unless
the sample D-gaps are all equal to zero or all positive, when we revert
to <code>param = "logit"</code>.  This is to avoid the possibility of sampling
directly from a posterior with mode equal to 0 or 1.</p>
</td></tr>
<tr><td><code id="dgaps_post_+3A_use_rcpp">use_rcpp</code></td>
<td>
<p>A logical scalar.  If <code>TRUE</code> (the default) the
rust function <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> is used for
posterior simulation.  If <code>FALSE</code> the (slower) function
<code><a href="rust.html#topic+ru">ru</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A beta(<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>) prior distribution is used for
<code class="reqn">\theta</code> so that the posterior from which values are simulated is
proportional to
</p>
<p style="text-align: center;"><code class="reqn">\theta ^ {2 N_1 + \alpha - 1}
    (1 - \theta e^{-\theta d}) ^ {N_0 + \beta - 1}
    \exp\{- \theta q (I_0 T_0 + \cdots + I_N T_N)\}.</code>
</p>

<p>See <code><a href="exdex.html#topic+dgaps_stat">dgaps_stat</a></code> for a description of the variables
involved in the contribution of the likelihood to this expression.
</p>
<p>The <code><a href="rust.html#topic+ru">ru</a></code> function in the <code><a href="rust.html#topic+rust">rust</a></code>
package simulates from this posterior distribution using the
generalised ratio-of-uniforms distribution.  To improve the probability
of acceptance, and to ensure that the simulation will work even in
extreme cases where the posterior density of <code class="reqn">\theta</code> is unbounded as
<code class="reqn">\theta</code> approaches 0 or 1, we simulate from the posterior
distribution of
<code class="reqn">\phi = \log(\theta / (1-\theta))</code>
and then transform back to the <code class="reqn">\theta</code>-scale.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"evpost"</code>, which has the same
structure as an object of class <code>"ru"</code> returned from
<code><a href="rust.html#topic+ru">ru</a></code>.
In addition this list contains
</p>

<ul>
<li> <p><code>call</code>: The call to <code>dgaps()</code>.
</p>
</li>
<li> <p><code>model</code>: The character scalar <code>"dgaps"</code>.
</p>
</li>
<li> <p><code>thresh</code>: The argument <code>thresh</code>.
</p>
</li>
<li> <p><code>ss</code>: The sufficient statistics for the D-gaps likelihood,
as calculated by <code><a href="exdex.html#topic+dgaps_stat">dgaps_stat</a></code>.
</p>
</li></ul>



<h3>References</h3>

<p>Holesovsky, J. and Fusek, M. Estimation of the extremal index
using censored distributions. Extremes 23, 197-213 (2020).
<a href="https://doi.org/10.1007/s10687-020-00374-3">doi:10.1007/s10687-020-00374-3</a>
</p>
<p>Suveges, M. and Davison, A. C. (2010) Model
misspecification in peaks over threshold analysis, <em>The Annals of
Applied Statistics</em>, <strong>4</strong>(1), 203-221. <a href="https://doi.org/10.1214/09-AOAS292">doi:10.1214/09-AOAS292</a>
</p>


<h3>See Also</h3>

<p><code><a href="rust.html#topic+ru">ru</a></code> for the form of the object returned by
<code>dgaps_post</code>.
</p>
<p><code><a href="#topic+kgaps_post">kgaps_post</a></code> for Bayesian inference about the
extremal index <code class="reqn">\theta</code> using the <code class="reqn">K</code>-gaps model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Newlyn sea surges

thresh &lt;- quantile(newlyn, probs = 0.90)
d_postsim &lt;- dgaps_post(newlyn, thresh)
plot(d_postsim)

### Cheeseboro wind gusts

d_postsim &lt;- dgaps_post(exdex::cheeseboro, thresh = 45, D = 3)
plot(d_postsim)
</code></pre>

<hr>
<h2 id='gev'>The Generalised Extreme Value Distribution</h2><span id='topic+gev'></span><span id='topic+dgev'></span><span id='topic+pgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the generalised extreme value (GEV)
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgev(x, loc = 0, scale = 1, shape = 0, log = FALSE, m = 1)

pgev(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, log.p = FALSE, m = 1)

qgev(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, log.p = FALSE, m = 1)

rgev(n, loc = 0, scale = 1, shape = 0, m = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_+3A_x">x</code>, <code id="gev_+3A_q">q</code></td>
<td>
<p>Numeric vectors of quantiles.</p>
</td></tr>
<tr><td><code id="gev_+3A_loc">loc</code>, <code id="gev_+3A_scale">scale</code>, <code id="gev_+3A_shape">shape</code></td>
<td>
<p>Numeric vectors.
Location, scale and shape parameters.
All elements of <code>scale</code> must be positive.</p>
</td></tr>
<tr><td><code id="gev_+3A_log">log</code>, <code id="gev_+3A_log.p">log.p</code></td>
<td>
<p>A logical scalar; if TRUE, probabilities p are given as
log(p).</p>
</td></tr>
<tr><td><code id="gev_+3A_m">m</code></td>
<td>
<p>A numeric scalar.  The distribution is reparameterised by working
with the GEV(<code>loc, scale, shape</code>) distribution function raised to the
power <code>m</code>.  See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="gev_+3A_lower.tail">lower.tail</code></td>
<td>
<p>A logical scalar.  If TRUE (default), probabilities
are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="gev_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities in [0,1].</p>
</td></tr>
<tr><td><code id="gev_+3A_n">n</code></td>
<td>
<p>Numeric scalar.  The number of observations to be simulated.
If <code>length(n) &gt; 1</code> then <code>length(n)</code> is taken to be the number
required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution function of a GEV distribution with parameters
<code>loc</code> = <code class="reqn">\mu</code>, <code>scale</code> = <code class="reqn">\sigma (&gt; 0)</code> and
<code>shape</code> = <code class="reqn">\xi</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \exp\{-[1 + \xi (x - \mu) / \sigma] ^ {-1/\xi} \}</code>
</p>

<p>for <code class="reqn">1 + \xi (x - \mu) / \sigma &gt; 0</code>.  If <code class="reqn">\xi = 0</code> the
distribution function is defined as the limit as <code class="reqn">\xi</code> tends to zero.
The support of the distribution depends on <code class="reqn">\xi</code>: it is
<code class="reqn">x \leq \mu - \sigma / \xi</code> for <code class="reqn">\xi &lt; 0</code>;
<code class="reqn">x \geq \mu - \sigma / \xi</code> for <code class="reqn">\xi &gt; 0</code>;
and <code class="reqn">x</code> is unbounded for <code class="reqn">\xi = 0</code>.
Note that if <code class="reqn">\xi &lt; -1</code> the GEV density function becomes infinite
as <code class="reqn">x</code> approaches <code class="reqn">\mu -\sigma / \xi</code> from below.
</p>
<p>If <code>lower.tail = TRUE</code> then if <code>p = 0</code> (<code>p = 1</code>) then
the lower (upper) limit of the distribution is returned, which is
<code>-Inf</code> or <code>Inf</code> in some cases.  Similarly, but reversed,
if <code>lower.tail = FALSE</code>.
</p>
<p>See
<a href="https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution">https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution</a>
for further information.
</p>
<p>The effect of <code>m</code> is to change the location, scale and shape
parameters to
<code class="reqn">(\mu + \sigma \log m, \sigma, \xi)</code>
if <code class="reqn">\xi = 0</code> and
<code class="reqn">(\mu + \sigma (m ^ \xi - 1) / \xi, \sigma m ^ \xi, \xi)</code>.
For integer <code>m</code> we can think of this as working with the
maximum of <code>m</code> independent copies of the original
GEV(<code>loc, scale, shape</code>) variable.
</p>


<h3>Value</h3>

<p><code>dgev</code> gives the density function, <code>pgev</code> gives the
distribution function, <code>qgev</code> gives the quantile function,
and <code>rgev</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for <code>rgev</code>,
and is the maximum of the lengths of the numerical arguments for the
other functions.
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the length
of the result.
</p>


<h3>References</h3>

<p>Jenkinson, A. F. (1955) The frequency distribution of the
annual maximum (or minimum) of meteorological elements.
<em>Quart. J. R. Met. Soc.</em>, <strong>81</strong>, 158-171.
Chapter 3: <a href="https://doi.org/10.1002/qj.49708134804">doi:10.1002/qj.49708134804</a>
</p>
<p>Coles, S. G. (2001) <em>An Introduction to Statistical
Modeling of Extreme Values</em>, Springer-Verlag, London.
<a href="https://doi.org/10.1007/978-1-4471-3675-0_3">doi:10.1007/978-1-4471-3675-0_3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgev(-1:4, 1, 0.5, 0.8)
dgev(1:6, 1, 0.5, -0.2, log = TRUE)
dgev(1, shape = c(-0.2, 0.4))

pgev(-1:4, 1, 0.5, 0.8)
pgev(1:6, 1, 0.5, -0.2)
pgev(1, c(1, 2), c(1, 2), c(-0.2, 0.4))
pgev(-3, c(1, 2), c(1, 2), c(-0.2, 0.4))
pgev(7, 1, 1, c(-0.2, 0.4))

qgev((1:9)/10, 2, 0.5, 0.8)
qgev(0.5, c(1,2), c(0.5, 1), c(-0.5, 0.5))

p &lt;- (1:9)/10
pgev(qgev(p, 1, 2, 0.8), 1, 2, 0.8)

rgev(6, 1, 0.5, 0.8)
</code></pre>

<hr>
<h2 id='gev_beta'>Beta-type prior for GEV shape parameter <code class="reqn">\xi</code></h2><span id='topic+gev_beta'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_beta(pars, min_xi = -1/2, max_xi = 1/2, pq = c(6, 9), trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_beta_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_beta_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_beta_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_beta_+3A_pq">pq</code></td>
<td>
<p>A numeric vector of length 2.
See <code><a href="#topic+set_prior">set_prior</a></code> for details.</p>
</td></tr>
<tr><td><code id="gev_beta_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gev_flat'>Flat prior for GEV parameters (<code class="reqn">\mu, log \sigma, \xi</code>)</h2><span id='topic+gev_flat'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_flat(pars, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_flat_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_flat_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.</p>
</td></tr>
<tr><td><code id="gev_flat_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_flat_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gev_flatflat'>Flat prior for GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>)</h2><span id='topic+gev_flatflat'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_flatflat(pars, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_flatflat_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_flatflat_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.</p>
</td></tr>
<tr><td><code id="gev_flatflat_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_flatflat_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gev_loglognorm'>Trivariate normal prior for GEV parameters (<code class="reqn">log \mu, log \sigma, \xi</code>)</h2><span id='topic+gev_loglognorm'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_loglognorm(pars, mean, icov, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_loglognorm_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_loglognorm_+3A_mean">mean</code></td>
<td>
<p>A numeric vector of length 3.  Prior mean.</p>
</td></tr>
<tr><td><code id="gev_loglognorm_+3A_icov">icov</code></td>
<td>
<p>A 3x3 numeric matrix.
The inverse of the prior covariance matrix.</p>
</td></tr>
<tr><td><code id="gev_loglognorm_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_loglognorm_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_loglognorm_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gev_mdi'>Maximal data information (MDI) prior for GEV parameters
(<code class="reqn">\mu, \sigma, \xi</code>)</h2><span id='topic+gev_mdi'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_mdi(pars, a = 0.577215664901532, min_xi = -1, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_mdi_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_mdi_+3A_a">a</code></td>
<td>
<p>A numeric scalar.  The default value, Euler's constant, gives the
MDI prior.</p>
</td></tr>
<tr><td><code id="gev_mdi_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.</p>
</td></tr>
<tr><td><code id="gev_mdi_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_mdi_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gev_norm'>Trivariate normal prior for GEV parameters (<code class="reqn">\mu, log \sigma, \xi</code>)</h2><span id='topic+gev_norm'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_norm(pars, mean, icov, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_norm_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_norm_+3A_mean">mean</code></td>
<td>
<p>A numeric vector of length 3.  Prior mean.</p>
</td></tr>
<tr><td><code id="gev_norm_+3A_icov">icov</code></td>
<td>
<p>A 3x3 numeric matrix.
The inverse of the prior covariance matrix.</p>
</td></tr>
<tr><td><code id="gev_norm_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_norm_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_norm_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gev_prob'>Informative GEV prior on a probability scale</h2><span id='topic+gev_prob'></span>

<h3>Description</h3>

<p>Constructs an informative prior for GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>),
constructed on the probability scale. For information about how to set this
prior see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_prob(pars, quant, alpha, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_prob_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_prob_+3A_quant">quant</code></td>
<td>
<p>A numeric vector of length 3 containing quantiles
(<code class="reqn">q_1, q_2, q_3</code>) such that
<code class="reqn">q_1 &lt; q_2 &lt; q_3</code>. If the values
in <code>quant</code> are not ordered from smallest to largest then they
will be ordered inside <code>set_prior</code> without warning.</p>
</td></tr>
<tr><td><code id="gev_prob_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector of length 4.  Parameters specifying a
prior distribution for probabilities related to the quantiles in
<code>quant</code>.  See <strong>Details</strong> below.</p>
</td></tr>
<tr><td><code id="gev_prob_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_prob_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_prob_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A prior for GEV parameters <code class="reqn">(\mu, \sigma, \xi)</code>,
based on Crowder (1992).  This construction is typically used to set
an informative prior, based on specified quantiles
<code class="reqn">q_1, q_2, q_3</code>.
There are two interpretations of the parameter vector
<code>alpha</code> = <code class="reqn">(\alpha_1, \alpha_2, \alpha_3, \alpha_4)</code>:
as the parameters of beta distributions for ratio of exceedance
probabilities (Stephenson, 2016) and as the parameters of a Dirichlet
distribution for differences between non-exceedance probabilities
(Northrop et al., 2017). See these publications for details.
</p>


<h3>Value</h3>

<p>The log of the prior density.
</p>


<h3>References</h3>

<p>Crowder, M. (1992) Bayesian priors based on parameter
transformation using the distribution function
<em>Ann. Inst. Statist. Math.</em>, <strong>44</strong>, 405-416.
<a href="https://link.springer.com/article/10.1007/BF00050695">https://link.springer.com/article/10.1007/BF00050695</a>.
</p>
<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>
<p>Stephenson, A. (2016) Bayesian inference for extreme value
modelling.  In <em>Extreme Value Modeling and Risk Analysis: Methods
and Applications</em> (eds D. K. Dey and J. Yan), 257-280, Chapman and Hall,
London. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code> for setting a prior distribution.
</p>
<p><code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for sampling
from an extreme value posterior distribution.
</p>
<p>Sets the same prior as the function
<code>prior.prob</code> in the evdbayes package.
</p>

<hr>
<h2 id='gev_quant'>Informative GEV prior on a quantile scale</h2><span id='topic+gev_quant'></span>

<h3>Description</h3>

<p>Informative GEV prior for GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>)
constructed on the quantile scale.  For information about how to set this
prior see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev_quant(pars, prob, shape, scale, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev_quant_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GEV parameters (<code class="reqn">\mu, \sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gev_quant_+3A_prob">prob</code></td>
<td>
<p>A numeric vector of length 3 containing exceedance
probabilities (<code class="reqn">p_1, p_2, p_3</code>) such that
<code class="reqn">p_1 &gt; p_2 &gt; p_3</code>.
If the values in <code>quant</code> are not ordered from largest to smallest
then they will be ordered inside <code>set_prior</code> without warning.</p>
</td></tr>
<tr><td><code id="gev_quant_+3A_shape">shape</code>, <code id="gev_quant_+3A_scale">scale</code></td>
<td>
<p>Numeric vectors of length 3. Shape and scale
parameters specifying (independent) gamma prior distributions placed
on the differences between the quantiles corresponding to the
probabilities given in <code>prob</code>.</p>
</td></tr>
<tr><td><code id="gev_quant_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_quant_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gev_quant_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Coles and Tawn (1996) and/or Stephenson (2016) for details.
</p>
<p>Note that the lower end point of the distribution of the distribution
of the variable in question is assumed to be equal to zero.
If this is not the case then the user should shift the data to
ensure that this is true.
</p>


<h3>Value</h3>

<p>The log of the prior density.
</p>


<h3>References</h3>

<p>Coles, S. G. and Tawn, J. A. (1996) A Bayesian analysis of
extreme rainfall data. <em>Appl. Statist.</em>, <strong>45</strong>, 463-478.
</p>
<p>Stephenson, A. (2016) Bayesian inference for extreme value
modelling.  In <em>Extreme Value Modeling and Risk Analysis: Methods
and Applications</em> (eds D. K. Dey and J. Yan), 257-280, Chapman and Hall,
London. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>.
</p>

<hr>
<h2 id='gom'>Storm peak significant wave heights from the Gulf of Mexico</h2><span id='topic+gom'></span>

<h3>Description</h3>

<p>A numeric vector containing 315 hindcasts of storm peak significant wave
heights, metres, from 1900 to 2005 at an unnamed location in the Gulf
of Mexico.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gom
</code></pre>


<h3>Format</h3>

<p>A vector containing 315 observations.
</p>


<h3>Source</h3>

<p>Oceanweather Inc. (2005) GOMOS &ndash; Gulf of Mexico hindcast study.
</p>


<h3>References</h3>

<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>

<hr>
<h2 id='gp'>The Generalised Pareto Distribution</h2><span id='topic+gp'></span><span id='topic+dgp'></span><span id='topic+pgp'></span><span id='topic+qgp'></span><span id='topic+rgp'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function and
random generation for the generalised Pareto (GP) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgp(x, loc = 0, scale = 1, shape = 0, log = FALSE)

pgp(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, log.p = FALSE)

qgp(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, log.p = FALSE)

rgp(n, loc = 0, scale = 1, shape = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_+3A_x">x</code>, <code id="gp_+3A_q">q</code></td>
<td>
<p>Numeric vectors of quantiles.  All elements of <code>x</code>
and <code>q</code> must be non-negative.</p>
</td></tr>
<tr><td><code id="gp_+3A_loc">loc</code>, <code id="gp_+3A_scale">scale</code>, <code id="gp_+3A_shape">shape</code></td>
<td>
<p>Numeric vectors.
Location, scale and shape parameters.
All elements of <code>scale</code> must be positive.</p>
</td></tr>
<tr><td><code id="gp_+3A_log">log</code>, <code id="gp_+3A_log.p">log.p</code></td>
<td>
<p>A logical scalar; if TRUE, probabilities p are given as
log(p).</p>
</td></tr>
<tr><td><code id="gp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>A logical scalar.  If TRUE (default), probabilities
are <code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="gp_+3A_p">p</code></td>
<td>
<p>A numeric vector of probabilities in [0,1].</p>
</td></tr>
<tr><td><code id="gp_+3A_n">n</code></td>
<td>
<p>Numeric scalar.  The number of observations to be simulated.
If <code>length(n) &gt; 1</code> then <code>length(n)</code> is taken to be the number
required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution function of a GP distribution with parameters
<code>location</code> = <code class="reqn">\mu</code>, <code>scale</code> = <code class="reqn">\sigma (&gt; 0)</code> and
<code>shape</code> = <code class="reqn">\xi</code> is
</p>
<p style="text-align: center;"><code class="reqn">F(x) = 1 - [1 + \xi (x - \mu) / \sigma] ^ {-1/\xi}</code>
</p>

<p>for <code class="reqn">1 + \xi (x - \mu) / \sigma &gt; 0</code>.  If <code class="reqn">\xi = 0</code> the
distribution function is defined as the limit as <code class="reqn">\xi</code> tends to zero.
The support of the distribution depends on <code class="reqn">\xi</code>: it is
<code class="reqn">x \geq \mu</code> for <code class="reqn">\xi \geq 0</code>; and
<code class="reqn">\mu \leq x \leq \mu - \sigma / \xi</code>
for <code class="reqn">\xi &lt; 0</code>.  Note that if <code class="reqn">\xi &lt; -1</code> the GP density function
becomes infinite as <code class="reqn">x</code> approaches <code class="reqn">\mu - \sigma/\xi</code>.
</p>
<p>If <code>lower.tail = TRUE</code> then if <code>p = 0</code> (<code>p = 1</code>) then
the lower (upper) limit of the distribution is returned.
The upper limit is <code>Inf</code> if <code>shape</code> is non-negative.
Similarly, but reversed, if <code>lower.tail = FALSE</code>.
</p>
<p>See
<a href="https://en.wikipedia.org/wiki/Generalized_Pareto_distribution">https://en.wikipedia.org/wiki/Generalized_Pareto_distribution</a>
for further information.
</p>


<h3>Value</h3>

<p><code>dgp</code> gives the density function, <code>pgp</code> gives the
distribution function, <code>qgp</code> gives the quantile function,
and <code>rgp</code> generates random deviates.
</p>


<h3>References</h3>

<p>Pickands, J. (1975) Statistical inference using extreme
order statistics. <em>Annals of Statistics</em>, <strong>3</strong>, 119-131.
<a href="https://doi.org/10.1214/aos/1176343003">doi:10.1214/aos/1176343003</a>
</p>
<p>Coles, S. G. (2001) <em>An Introduction to Statistical
Modeling of Extreme Values</em>, Springer-Verlag, London.
Chapter 4: <a href="https://doi.org/10.1007/978-1-4471-3675-0_4">doi:10.1007/978-1-4471-3675-0_4</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgp(0:4, scale = 0.5, shape = 0.8)
dgp(1:6, scale = 0.5, shape = -0.2, log = TRUE)
dgp(1, scale = 1, shape = c(-0.2, 0.4))

pgp(0:4, scale = 0.5, shape = 0.8)
pgp(1:6, scale = 0.5, shape = -0.2)
pgp(1, scale = c(1, 2), shape = c(-0.2, 0.4))
pgp(7, scale = 1, shape = c(-0.2, 0.4))

qgp((0:9)/10, scale = 0.5, shape = 0.8)
qgp(0.5, scale = c(0.5, 1), shape = c(-0.5, 0.5))

p &lt;- (1:9)/10
pgp(qgp(p, scale = 2, shape = 0.8), scale = 2, shape = 0.8)

rgp(6, scale = 0.5, shape = 0.8)
</code></pre>

<hr>
<h2 id='gp_beta'>Beta-type prior for GP shape parameter <code class="reqn">\xi</code></h2><span id='topic+gp_beta'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_beta(pars, min_xi = -1/2, max_xi = 1/2, pq = c(6, 9), trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_beta_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 2.
GP parameters (<code class="reqn">\sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gp_beta_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_beta_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_beta_+3A_pq">pq</code></td>
<td>
<p>A numeric vector of length 2.
See <code><a href="#topic+set_prior">set_prior</a></code> for details.</p>
</td></tr>
<tr><td><code id="gp_beta_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gp_flat'>Flat prior for GP parameters (<code class="reqn">log \sigma, \xi</code>)</h2><span id='topic+gp_flat'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_flat(pars, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_flat_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 2.
GP parameters (<code class="reqn">\sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gp_flat_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.</p>
</td></tr>
<tr><td><code id="gp_flat_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_flat_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gp_flatflat'>Flat prior for GP parameters (<code class="reqn">\sigma, \xi</code>)</h2><span id='topic+gp_flatflat'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_flatflat(pars, min_xi = -Inf, max_xi = Inf, trendsd = 0, upper = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_flatflat_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 2.
GP parameters (<code class="reqn">\sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gp_flatflat_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.</p>
</td></tr>
<tr><td><code id="gp_flatflat_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_flatflat_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
<tr><td><code id="gp_flatflat_+3A_upper">upper</code></td>
<td>
<p>A positive numeric scalar.  The upper endpoint of the GP
distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gp_jeffreys'>Jeffreys prior for GP parameters (<code class="reqn">\sigma, \xi</code>)</h2><span id='topic+gp_jeffreys'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_jeffreys(pars, min_xi = -1/2, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_jeffreys_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 2.
GP parameters (<code class="reqn">\sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gp_jeffreys_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.</p>
</td></tr>
<tr><td><code id="gp_jeffreys_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_jeffreys_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gp_lrs'>Linear Combinations of Ratios of Spacings estimation of generalised Pareto
parameters</h2><span id='topic+gp_lrs'></span>

<h3>Description</h3>

<p>Uses the Linear Combinations of Ratios of Spacings (LRS) methodology of
(Reiss and Thomas, 2007, page 134) to estimate the parameters of the
generalised Pareto (GP) distribution, based on a sample of positive values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_lrs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_lrs_+3A_x">x</code></td>
<td>
<p>A numeric vector containing only <strong>positive</strong> values, assumed
to be a random sample from a generalized Pareto distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2.  The estimates of the scale parameter
<code class="reqn">\sigma</code> and the shape parameter <code class="reqn">\xi</code>.
</p>


<h3>References</h3>

<p>Reiss, R.-D., Thomas, M. (2007) Statistical Analysis of
Extreme Values with Applications to Insurance, Finance, Hydrology and
Other Fields.Birkhauser.
<a href="https://doi.org/10.1007/978-3-7643-7399-3">doi:10.1007/978-3-7643-7399-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code> for details of the parameterisation of the GP
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- quantile(gom, probs = 0.65)
gp_lrs((gom - u)[gom &gt; u])
</code></pre>

<hr>
<h2 id='gp_mdi'>Maximal data information (MDI) prior for GP parameters
(<code class="reqn">\sigma, \xi</code>)</h2><span id='topic+gp_mdi'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_mdi(pars, a = 1, min_xi = -1, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_mdi_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 3.
GP parameters (<code class="reqn">\sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gp_mdi_+3A_a">a</code></td>
<td>
<p>A numeric scalar.  The default value, Euler's constant, gives the
MDI prior.</p>
</td></tr>
<tr><td><code id="gp_mdi_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.
Must not be <code>-Inf</code> because this results in an improper posterior.
See Northrop and Attalides (2016) for details.</p>
</td></tr>
<tr><td><code id="gp_mdi_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_mdi_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>


<h3>References</h3>

<p>Northrop, P.J. and Attalides, N. (2016) Posterior propriety in
Bayesian extreme value analyses using reference priors
<em>Statistica Sinica</em>, <strong>26(2)</strong>, 721&ndash;743
<a href="https://doi.org/10.5705/ss.2014.034">doi:10.5705/ss.2014.034</a>.
</p>

<hr>
<h2 id='gp_norm'>Bivariate normal prior for GP parameters (<code class="reqn">log \sigma, \xi</code>)</h2><span id='topic+gp_norm'></span>

<h3>Description</h3>

<p>For information about this and other priors see <code><a href="#topic+set_prior">set_prior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_norm(pars, mean, icov, min_xi = -Inf, max_xi = Inf, trendsd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_norm_+3A_pars">pars</code></td>
<td>
<p>A numeric vector of length 2.
GP parameters (<code class="reqn">\sigma, \xi</code>).</p>
</td></tr>
<tr><td><code id="gp_norm_+3A_mean">mean</code></td>
<td>
<p>A numeric vector of length 2.  Prior mean.</p>
</td></tr>
<tr><td><code id="gp_norm_+3A_icov">icov</code></td>
<td>
<p>A 2x2 numeric matrix.
The inverse of the prior covariance matrix.</p>
</td></tr>
<tr><td><code id="gp_norm_+3A_min_xi">min_xi</code></td>
<td>
<p>A numeric scalar.  Prior lower bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_norm_+3A_max_xi">max_xi</code></td>
<td>
<p>A numeric scalar.  Prior upper bound on <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gp_norm_+3A_trendsd">trendsd</code></td>
<td>
<p>Has no function other than to achieve compatibility with
function in the evdbayes package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the prior density.
</p>

<hr>
<h2 id='gp_pwm'>Probability-weighted moments estimation of generalised Pareto parameters</h2><span id='topic+gp_pwm'></span>

<h3>Description</h3>

<p>Uses the methodology of Hosking and Wallis (1987) to estimate the parameters
of the generalised Pareto (GP) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gp_pwm(gp_data, u = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gp_pwm_+3A_gp_data">gp_data</code></td>
<td>
<p>A numeric vector of raw data, assumed to be a random sample
from a probability distribution.</p>
</td></tr>
<tr><td><code id="gp_pwm_+3A_u">u</code></td>
<td>
<p>A numeric scalar.  A threshold.  The GP distribution is fitted to
the excesses of <code>u</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<ul>
<li> <p><code>est</code>: A numeric vector.  PWM estimates of GP parameters
<code class="reqn">\sigma</code> (scale) and <code class="reqn">\xi</code> (shape).
</p>
</li>
<li> <p><code>se</code>: A numeric vector.  Estimated standard errors of
<code class="reqn">\sigma</code> and <code class="reqn">\xi</code>.
</p>
</li>
<li> <p><code>cov</code>: A numeric matrix.  Estimate covariance matrix of the
the PWM estimators of <code class="reqn">\sigma</code> and <code class="reqn">\xi</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Hosking, J. R. M. and Wallis, J. R. (1987) Parameter and
Quantile Estimation for the Generalized Pareto Distribution.
Technometrics, 29(3), 339-349. <a href="https://doi.org/10.2307/1269343">doi:10.2307/1269343</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code> for details of the parameterisation of the GP
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- quantile(gom, probs = 0.65)
gp_pwm(gom, u)
</code></pre>

<hr>
<h2 id='grimshaw_gp_mle'>Maximum likelihood estimation of generalised Pareto parameters</h2><span id='topic+grimshaw_gp_mle'></span>

<h3>Description</h3>

<p>Uses the methodology of Grimshaw (1993) to find the MLEs of the parameters
of the generalised Pareto distribution, based on a sample of positive
values.  The function is essentially the same as that made available with
Grimshaw (1993), with only minor modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grimshaw_gp_mle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grimshaw_gp_mle_+3A_x">x</code></td>
<td>
<p>A numeric vector containing only <strong>positive</strong> values, assumed
to be a random sample from a generalized Pareto distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2.  The estimates of the <strong>negated</strong>
shape parameter <code class="reqn">k (= -\xi)</code> and the scale parameter
<code class="reqn">a (= \sigma)</code>.
</p>


<h3>References</h3>

<p>Grimshaw, S. D. (1993) Computing Maximum Likelihood Estimates
for the Generalized Pareto Distribution.  Technometrics, 35(2), 185-191.
and Computing (1991) 1, 129-133.
<a href="https://doi.org/10.1080/00401706.1993.10485040">doi:10.1080/00401706.1993.10485040</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gp">gp</a></code> for details of the parameterisation of the GP
distribution, in terms of <code class="reqn">\sigma</code> and <code class="reqn">\xi</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- quantile(gom, probs = 0.65)
grimshaw_gp_mle((gom - u)[gom &gt; u])
</code></pre>

<hr>
<h2 id='kgaps_post'>Random sampling from K-gaps posterior distribution</h2><span id='topic+kgaps_post'></span>

<h3>Description</h3>

<p>Uses the <code><a href="rust.html#topic+rust">rust</a></code> package to simulate from the posterior
distribution of the extremal index <code class="reqn">\theta</code> based on the K-gaps model
for threshold interexceedance times of Suveges and Davison (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kgaps_post(
  data,
  thresh,
  k = 1,
  n = 1000,
  inc_cens = TRUE,
  alpha = 1,
  beta = 1,
  param = c("logit", "theta"),
  use_rcpp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kgaps_post_+3A_data">data</code></td>
<td>
<p>A numeric vector or numeric matrix of raw data.  If <code>data</code>
is a matrix then the log-likelihood is constructed as the sum of
(independent) contributions from different columns. A common situation is
where each column relates to a different year.
</p>
<p>If <code>data</code> contains missing values then
<code><a href="exdex.html#topic+split_by_NAs">split_by_NAs</a></code> is used to divide the data further into
sequences of non-missing values, stored in different columns in a matrix.
Again, the log-likelihood is constructed as a sum of contributions from
different columns.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_thresh">thresh</code></td>
<td>
<p>A numeric scalar.  Extreme value threshold applied to data.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_k">k</code></td>
<td>
<p>A numeric scalar.  Run parameter <code class="reqn">K</code>, as defined in Suveges and
Davison (2010).  Threshold inter-exceedances times that are not larger
than <code>k</code> units are assigned to the same cluster, resulting in a
<code class="reqn">K</code>-gap equal to zero.  Specifically, the <code class="reqn">K</code>-gap <code class="reqn">S</code>
corresponding to an inter-exceedance time of <code class="reqn">T</code> is given by
<code class="reqn">S = \max(T - K, 0)</code>.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_inc_cens">inc_cens</code></td>
<td>
<p>A logical scalar indicating whether or not to include
contributions from right-censored inter-exceedance times, relating to the
first and last observations.  It is known that these times are greater
than or equal to the time observed.
If <code>data</code> has multiple columns then there will be right-censored
first and last inter-exceedance times for each column.  See also the
<strong>Details</strong> section of <code><a href="exdex.html#topic+kgaps">kgaps</a></code>.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_alpha">alpha</code>, <code id="kgaps_post_+3A_beta">beta</code></td>
<td>
<p>Positive numeric scalars.  Parameters of a
beta(<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>) prior for <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_param">param</code></td>
<td>
<p>A character scalar.  If <code>param = "logit"</code> (the default)
then we simulate from the posterior distribution of
<code class="reqn">\phi = \log(\theta / (1-\theta))</code>
and then transform back to the
<code class="reqn">\theta</code>-scale.  If <code>param = "theta"</code> then we simulate
directly from the posterior distribution of <code class="reqn">\theta</code>, unless
the sample K-gaps are all equal to zero or all positive, when we revert
to <code>param = "logit"</code>.  This is to avoid sampling directly from a
posterior with mode equal to 0 or 1.</p>
</td></tr>
<tr><td><code id="kgaps_post_+3A_use_rcpp">use_rcpp</code></td>
<td>
<p>A logical scalar.  If <code>TRUE</code> (the default) the
rust function <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> is used for
posterior simulation.  If <code>FALSE</code> the (slower) function
<code><a href="rust.html#topic+ru">ru</a></code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A beta(<code class="reqn">\alpha</code>, <code class="reqn">\beta</code>) prior distribution is used for
<code class="reqn">\theta</code> so that the posterior from which values are simulated is
proportional to
</p>
<p style="text-align: center;"><code class="reqn">\theta ^ {2 N_1 + \alpha - 1} (1 - \theta) ^ {N_0 + \beta - 1}
    \exp\{- \theta q (S_0 + \cdots + S_N)\}.</code>
</p>

<p>See <code><a href="exdex.html#topic+kgaps_stat">kgaps_stat</a></code> for a description of the variables
involved in the contribution of the likelihood to this expression.
</p>
<p>The <code><a href="rust.html#topic+ru">ru</a></code> function in the <code><a href="rust.html#topic+rust">rust</a></code>
package simulates from this posterior distribution using the
generalised ratio-of-uniforms distribution.  To improve the probability
of acceptance, and to ensure that the simulation will work even in
extreme cases where the posterior density of <code class="reqn">\theta</code> is unbounded as
<code class="reqn">\theta</code> approaches 0 or 1, we simulate from the posterior
distribution of
<code class="reqn">\phi = \log(\theta / (1-\theta))</code>
and then transform back to the <code class="reqn">\theta</code>-scale.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"evpost"</code>, which has the same
structure as an object of class <code>"ru"</code> returned from
<code><a href="rust.html#topic+ru">ru</a></code>.
In addition this list contains
</p>

<ul>
<li> <p><code>call</code>: The call to <code>kgaps()</code>.
</p>
</li>
<li> <p><code>model</code>: The character scalar <code>"kgaps"</code>.
</p>
</li>
<li> <p><code>thresh</code>: The argument <code>thresh</code>.
</p>
</li>
<li> <p><code>ss</code>: The sufficient statistics for the K-gaps likelihood,
as calculated by <code><a href="exdex.html#topic+kgaps_stat">kgaps_stat</a></code>.
</p>
</li></ul>



<h3>References</h3>

<p>Suveges, M. and Davison, A. C. (2010) Model
misspecification in peaks over threshold analysis, <em>The Annals of
Applied Statistics</em>, <strong>4</strong>(1), 203-221. <a href="https://doi.org/10.1214/09-AOAS292">doi:10.1214/09-AOAS292</a>
</p>


<h3>See Also</h3>

<p><code><a href="rust.html#topic+ru">ru</a></code> for the form of the object returned by
<code>kgaps_post</code>.
</p>
<p><code><a href="#topic+dgaps_post">dgaps_post</a></code> for Bayesian inference about the
extremal index <code class="reqn">\theta</code> using the <code class="reqn">D</code>-gaps model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Newlyn sea surges

thresh &lt;- quantile(newlyn, probs = 0.90)
k_postsim &lt;- kgaps_post(newlyn, thresh)
plot(k_postsim)

### Cheeseboro wind gusts

k_postsim &lt;- kgaps_post(exdex::cheeseboro, thresh = 45, k = 3)
plot(k_postsim)
</code></pre>

<hr>
<h2 id='newlyn'>Newlyn sea surges</h2><span id='topic+newlyn'></span>

<h3>Description</h3>

<p>The vector <code>newlyn</code> contains 2894 maximum sea-surges measured at
Newlyn, Cornwall, UK over the period 1971-1976. The observations are
the maximum hourly sea-surge heights over contiguous 15-hour time
periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newlyn
</code></pre>


<h3>Format</h3>

<p>A vector of length 2894.
</p>


<h3>Source</h3>

<p>Coles, S.G. (1991) Modelling extreme multivariate events. PhD thesis,
University of Sheffield, U.K.
</p>


<h3>References</h3>

<p>Fawcett, L. and Walshaw, D. (2012) Estimating return levels from
serially dependent extremes. <em>Environmetrics</em>, <strong>23</strong>(3),
272-283.  <a href="https://doi.org/10.1002/env.2133">doi:10.1002/env.2133</a>
</p>
<p>Northrop, P. J. (2015) An efficient semiparametric maxima
estimator of the extremal index. <em>Extremes</em>, <strong>18</strong>,
585-603.  <a href="https://doi.org/10.1007/s10687-015-0221-5">doi:10.1007/s10687-015-0221-5</a>
</p>

<hr>
<h2 id='oxford'>Annual Maximum Temperatures at Oxford</h2><span id='topic+oxford'></span>

<h3>Description</h3>

<p>A numeric vector containing annual maximum temperatures, in degrees
Fahrenheit, from 1901 to 1980 at Oxford, England.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oxford
</code></pre>


<h3>Format</h3>

<p>A vector containing 80 observations.
</p>


<h3>Source</h3>

<p>Tabony, R. C. (1983) Extreme value analysis in meteorology.
<em>The Meteorological Magazine</em>, <strong>112</strong>, 77-98.
</p>

<hr>
<h2 id='plot.evpost'>Plot diagnostics for an evpost object</h2><span id='topic+plot.evpost'></span>

<h3>Description</h3>

<p><code>plot</code> method for class &quot;evpost&quot;.  For <code>d = 1</code> a histogram of the
simulated values is plotted with a the density function superimposed.
The density is normalized crudely using the trapezium rule.  For
<code>d = 2</code> a scatter plot of the simulated values is produced with
density contours superimposed.  For <code>d &gt; 2</code> pairwise plots of the
simulated values are produced.
An interface is also provided to the functions in the <strong>bayesplot</strong>
package that produce plots of Markov chain Monte Carlo (MCMC)
simulations.  See <a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a> for details of these
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evpost'
plot(
  x,
  y,
  ...,
  n = ifelse(x$d == 1, 1001, 101),
  prob = c(0.5, 0.1, 0.25, 0.75, 0.95, 0.99),
  ru_scale = FALSE,
  rows = NULL,
  xlabs = NULL,
  ylabs = NULL,
  points_par = list(col = 8),
  pu_only = FALSE,
  add_pu = FALSE,
  use_bayesplot = FALSE,
  fun_name = c("areas", "intervals", "dens", "hist", "scatter")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evpost_+3A_x">x</code></td>
<td>
<p>An object of class &quot;evpost&quot;, a result of a call to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>hist</code>, <code>lines</code>,
<code>contour</code>, <code>points</code> or functions from the <strong>bayesplot</strong>
package.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_n">n</code></td>
<td>
<p>A numeric scalar.  Only relevant if <code>x$d = 1</code> or
<code>x$d = 2</code>. The meaning depends on the value of x$d.
</p>

<ul>
<li><p> For d = 1 : n + 1 is the number of abscissae in the trapezium
method used to normalize the density.
</p>
</li>
<li><p> For d = 2 : an n by n regular grid is used to contour the density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.evpost_+3A_prob">prob</code></td>
<td>
<p>Numeric vector. Only relevant for d = 2.  The contour lines are
drawn such that the respective probabilities that the variable lies
within the contour are approximately prob.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_ru_scale">ru_scale</code></td>
<td>
<p>A logical scalar.  Should we plot data and density on the
scale used in the ratio-of-uniforms algorithm (TRUE) or on the original
scale (FALSE)?</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_rows">rows</code></td>
<td>
<p>A numeric scalar.  When <code>d</code> &gt; 2 this sets the number of
rows of plots.  If the user doesn't provide this then it is set
internally.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_xlabs">xlabs</code>, <code id="plot.evpost_+3A_ylabs">ylabs</code></td>
<td>
<p>Numeric vectors.  When <code>d</code> &gt; 2 these set the labels
on the x and y axes respectively.  If the user doesn't provide these then
the column names of the simulated data matrix to be plotted are used.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_points_par">points_par</code></td>
<td>
<p>A list of arguments to pass to
<code><a href="graphics.html#topic+points">points</a></code> to control the appearance of points
depicting the simulated values. Only relevant when <code>d = 2</code>.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_pu_only">pu_only</code></td>
<td>
<p>Only produce a plot relating to the posterior distribution
for the threshold exceedance probability <code class="reqn">p</code>. Only relevant when
<code>model == "bingp"</code> was used in the call to <code>rpost</code> or
<code>rpost_rcpp</code>.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_add_pu">add_pu</code></td>
<td>
<p>Before producing the plots add the threshold exceedance
probability <code class="reqn">p</code> to the parameters of the extreme value model. Only
relevant when <code>model == "bingp"</code> was used in the call to
<code>rpost</code> or <code>rpost_rcpp</code>.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_use_bayesplot">use_bayesplot</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code> the bayesplot
function indicated by <code>fun_name</code> is called.  In principle <em>any</em>
bayesplot function (that starts with <code>mcmc_</code>) can be called but
this may not always be successful because, for example, some of the
bayesplot functions work only with multiple MCMC simulations.</p>
</td></tr>
<tr><td><code id="plot.evpost_+3A_fun_name">fun_name</code></td>
<td>
<p>A character scalar.  The name of the bayesplot function,
with the initial <code>mcmc_</code> part removed.  See
<a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a> and links therein for the names of these
functions. Some examples are given below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the <strong>bayesplot</strong> functions available when
<code>use_bayesplot = TRUE</code> see <a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a> and
the <strong>bayesplot</strong> vignette
<a href="https://CRAN.R-project.org/package=bayesplot">Plotting MCMC draws</a>.
</p>


<h3>Value</h3>

<p>Nothing is returned unless <code>use_bayesplot = TRUE</code> when a
ggplot object, which can be further customized using the
<strong>ggplot2</strong> package, is returned.
</p>


<h3>References</h3>

<p>Jonah Gabry (2016). bayesplot: Plotting for Bayesian
Models. R package version 1.1.0.
<a href="https://CRAN.R-project.org/package=bayesplot">https://CRAN.R-project.org/package=bayesplot</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.evpost">summary.evpost</a></code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>
<p><code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code>,
<code><a href="bayesplot.html#topic+MCMC-intervals">MCMC-intervals</a></code>,
<code><a href="bayesplot.html#topic+MCMC-distributions">MCMC-distributions</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GP posterior
u &lt;- stats::quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
gpg &lt;- rpost(n = 1000, model = "gp", prior = fp, thresh = u, data = gom)
plot(gpg)


# Using the bayesplot package
plot(gpg, use_bayesplot = TRUE)
plot(gpg, use_bayesplot = TRUE, pars = "xi", prob = 0.95)
plot(gpg, use_bayesplot = TRUE, fun_name = "intervals", pars = "xi")
plot(gpg, use_bayesplot = TRUE, fun_name = "hist")
plot(gpg, use_bayesplot = TRUE, fun_name = "dens")
plot(gpg, use_bayesplot = TRUE, fun_name = "scatter")


## bin-GP posterior
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
bp &lt;- set_bin_prior(prior = "jeffreys")
npy_gom &lt;- length(gom)/105
bgpg &lt;- rpost(n = 1000, model = "bingp", prior = fp, thresh = u,
              data = gom, bin_prior = bp, npy = npy_gom)
plot(bgpg)
plot(bgpg, pu_only = TRUE)
plot(bgpg, add_pu = TRUE)


# Using the bayesplot package
dimnames(bgpg$bin_sim_vals)
plot(bgpg, use_bayesplot = TRUE)
plot(bgpg, use_bayesplot = TRUE, fun_name = "hist")
plot(bgpg, use_bayesplot = TRUE, pars = "p[u]")

</code></pre>

<hr>
<h2 id='plot.evpred'>Plot diagnostics for an evpred object</h2><span id='topic+plot.evpred'></span>

<h3>Description</h3>

<p><code>plot</code> method for class &quot;evpred&quot;.  Plots summarising the predictive
distribution of the largest value to be observed in N years are produced.
The plot produced depends on <code>x$type</code>.
If <code>x$type = "d", "p"</code> or <code>"q"</code> then
<code><a href="graphics.html#topic+matplot">matplot</a></code> is used to produce a line plot of the
predictive density, distribution or quantile function, respectively,
with a line for each value of N in <code>x$n_years</code>.
If <code>x$type = "r"</code> then estimates of the predictive density
(from <code><a href="stats.html#topic+density">density</a></code>) are plotted with a line for each N.
If <code>x$type = "i"</code> then lines representing estimated predictive
intervals are plotted, with the level of the interval indicated next to
the line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evpred'
plot(
  x,
  ...,
  leg_pos = NULL,
  leg_text = NULL,
  which_int = c("long", "short", "both")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.evpred_+3A_x">x</code></td>
<td>
<p>An object of class &quot;evpost&quot;, a result of a call to
<code><a href="#topic+rpost">rpost</a></code>.</p>
</td></tr>
<tr><td><code id="plot.evpred_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="graphics.html#topic+matplot">matplot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.evpred_+3A_leg_pos">leg_pos</code></td>
<td>
<p>A character scalar. Keyword for the position of legend.
See <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.evpred_+3A_leg_text">leg_text</code></td>
<td>
<p>A character or expression vector.  Text for legend.
See <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="plot.evpred_+3A_which_int">which_int</code></td>
<td>
<p>A character scalar.  If <code>x$type = "i"</code> which
intervals should be plotted?  <code>"long"</code> for equi-tailed intervals,
<code>"short"</code> for the shortest possible intervals, <code>"both"</code> for
both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.evpost">predict.evpost</a></code> for the S3 <code>predict</code> method
for objects of class <code>evpost</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(portpirie)
mat &lt;- diag(c(10000, 10000, 100))
pn &lt;- set_prior(prior = "norm", model = "gev", mean = c(0,0,0), cov = mat)
gevp  &lt;- rpost(n = 1000, model = "gev", prior = pn, data = portpirie)

# Predictive density function
d_gevp &lt;- predict(gevp, type = "d", n_years = c(100, 1000))
plot(d_gevp)

# Predictive distribution function
p_gevp &lt;- predict(gevp, type = "p", n_years = c(100, 1000))
plot(p_gevp)

# Predictive quantiles
q_gevp &lt;- predict(gevp, type = "q", n_years = c(100, 1000))
plot(q_gevp)

# Predictive intervals
i_gevp &lt;- predict(gevp, type = "i", n_years = c(100, 1000), hpd = TRUE)
plot(i_gevp, which_int = "both")

# Sample from predictive distribution
r_gevp &lt;- predict(gevp, type = "r", n_years = c(100, 1000))
plot(r_gevp)
plot(r_gevp, xlim = c(4, 10))

</code></pre>

<hr>
<h2 id='portpirie'>Annual Maximum Sea Levels at Port Pirie, South Australia</h2><span id='topic+portpirie'></span>

<h3>Description</h3>

<p>A numeric vector of length 65 containing annual maximum sea levels,
in metres, from 1923 to 1987 at Port Pirie, South Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portpirie
</code></pre>


<h3>Format</h3>

<p>A numeric vector containing 65 observations.
</p>


<h3>Source</h3>

<p>Coles, S. G. (2001) <em>An Introduction to Statistical Modelling
of Extreme Values</em>. London: Springer.
<a href="https://doi.org/10.1007/978-1-4471-3675-0">doi:10.1007/978-1-4471-3675-0</a>
</p>

<hr>
<h2 id='pp_check.evpost'>Posterior predictive checks for an evpost object</h2><span id='topic+pp_check.evpost'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p><code>pp_check</code> method for class &quot;evpost&quot;.  This provides an interface
to the functions that perform posterior predictive checks in the
<strong>bayesplot</strong> package.  See <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a> for
details of these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evpost'
pp_check(
  object,
  ...,
  type = c("stat", "overlaid", "multiple", "intervals", "user"),
  subtype = NULL,
  stat = "median",
  nrep = 8,
  fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.evpost_+3A_object">object</code></td>
<td>
<p>An object of class &quot;evpost&quot;, a result of a call to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.
Currently <code>object$model = "gev"</code>,
<code>"gp"</code>, <code>"bingp"</code> and <code>"pp"</code> are supported.</p>
</td></tr>
<tr><td><code id="pp_check.evpost_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to bayesplot functions.</p>
</td></tr>
<tr><td><code id="pp_check.evpost_+3A_type">type</code></td>
<td>
<p>A character vector.  The type of bayesplot plot required:
</p>

<ul>
<li><p> &quot;stat&quot; for predictive test statistics
(see <a href="bayesplot.html#topic+PPC-test-statistics">PPC-test-statistics</a>),
</p>
</li>
<li><p> &quot;overlaid&quot; for comparison of observed data to predictive simulated
datasets using overlaid density function or distribution functions
(see <a href="bayesplot.html#topic+PPC-distributions">PPC-distributions</a>),
</p>
</li>
<li><p> &quot;multiple&quot; for comparison of observed data to predictive simulated
datasets using multiple summary plots
(see <a href="bayesplot.html#topic+PPC-distributions">PPC-distributions</a>),
</p>
</li>
<li><p> &quot;intervals&quot; for comparison of observed data to predictive simulated
datasets using sample medians and a predictive interval,
(see <a href="bayesplot.html#topic+PPC-intervals">PPC-intervals</a>),
</p>
</li>
<li><p> &quot;user&quot; for direct access to the default bayesplot function
<code><a href="bayesplot.html#topic+pp_check">pp_check</a></code>.  This requires the argument
<code>fun</code> to be supplied
(see <a href="bayesplot.html#topic+pp_check">pp_check</a>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_check.evpost_+3A_subtype">subtype</code></td>
<td>
<p>A character scalar.  Specifies the form of the plot(s)
produced.  Could be one of
<code>"dens", "hist", "boxplot", "ribbon"</code> or <code>"intervals"</code>.
If <code>subtype</code> is not supplied then the defaults are:
<code>"ecdf"</code> if <code>type = overlaid</code>,
<code>"dens"</code> if <code>type = multiple</code>,
<code>"intervals"</code> if <code>type = intervals</code>.
<code>subtype</code> is not relevant if <code>type = "stat"</code>.</p>
</td></tr>
<tr><td><code id="pp_check.evpost_+3A_stat">stat</code></td>
<td>
<p>See <a href="bayesplot.html#topic+PPC-test-statistics">PPC-test-statistics</a>.</p>
</td></tr>
<tr><td><code id="pp_check.evpost_+3A_nrep">nrep</code></td>
<td>
<p>If <code>type = "multiple"</code> the maximum number of
summary plots of the predictive simulated datasets to include.
If <code>nrep</code> is greater than <code>nrow(object$data_rep)</code> then
<code>nrep</code> is set equal to <code>nrow(object$data_rep)</code>.</p>
</td></tr>
<tr><td><code id="pp_check.evpost_+3A_fun">fun</code></td>
<td>
<p>The plotting function to call.
Only relevant if <code>type = "user"</code>.
Can be any of the functions detailed at <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a>.
The &quot;ppc_&quot; prefix can optionally be dropped if fun is specified
as a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of these functions see <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a>.
See also the vignette
<a href="https://CRAN.R-project.org/package=revdbayes">Posterior Predictive Extreme Value Inference</a>
and the <strong>bayesplot</strong> vignette
<a href="https://CRAN.R-project.org/package=bayesplot">Graphical posterior predictive checks</a>.
</p>
<p>The general idea is to compare the observed data <code>object$data</code>
with a matrix <code>object$data_rep</code> in which each row is a
replication of the observed data simulated from the posterior predictive
distribution.  For greater detail see Chapter 6 of Gelman et al. (2013).
</p>
<p>The format of <code>object$data</code> depends on the model:
</p>

<ul>
<li> <p><code>model = "gev"</code>. A vector of block maxima.
</p>
</li>
<li> <p><code>model = "gp"</code>. Data that lie above the threshold,
i.e. threshold exceedances.
</p>
</li>
<li> <p><code>model = "bingp"</code> or <code>model = "pp"</code>. The input data are
returned but any value lying below the threshold is set to
<code>object$thresh</code>.
</p>
</li></ul>

<p>In all cases any missing values have been removed from the data.
</p>
<p>If <code>model = "bingp"</code> or <code>"pp"</code> the rate of threshold exceedance
is part of the inference.  Therefore, the number of values in
<code>object$data_rep</code> that lie above the threshold varies between
predictive replications, with values below the threshold being
left-censored at the threshold.  This limits a little the posterior
predictive checks that it is useful to perform.  In the examples below
we have compared <code>object$data</code> and <code>object$data_rep</code> using
only their sample maxima.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further customized using the
<strong>ggplot2</strong> package.
</p>


<h3>References</h3>

<p>Jonah Gabry (2016). bayesplot: Plotting for Bayesian
Models. R package version 1.1.0.
<a href="https://CRAN.R-project.org/package=bayesplot">https://CRAN.R-project.org/package=bayesplot</a>
</p>
<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B.,
Vehtari, A., and Rubin, D. B. (2013). <em>Bayesian Data Analysis</em>.
Chapman &amp; Hall/CRC Press, London, third edition. (Chapter 6)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for sampling
from an extreme value posterior distribution.
</p>
<p><strong>bayesplot</strong> functions <a href="bayesplot.html#topic+PPC-overview">PPC-overview</a>,
<a href="bayesplot.html#topic+PPC-distributions">PPC-distributions</a>,
<a href="bayesplot.html#topic+PPC-test-statistics">PPC-test-statistics</a>,
<a href="bayesplot.html#topic+PPC-intervals">PPC-intervals</a>,
<a href="bayesplot.html#topic+pp_check">pp_check</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GEV model
data(portpirie)
mat &lt;- diag(c(10000, 10000, 100))
pn &lt;- set_prior(prior = "norm", model = "gev", mean = c(0,0,0), cov = mat)
gevp  &lt;- rpost(1000, model = "gev", prior = pn, data = portpirie,
               nrep = 50)

# Posterior predictive test statistics
pp_check(gevp)
pp_check(gevp, stat = "min")
pp_check(gevp, stat = c("min", "max"))
iqr &lt;- function(y) diff(quantile(y, c(0.25, 0.75)))
pp_check(gevp, stat = "iqr")

# Overlaid density and distributions functions
pp_check(gevp, type = "overlaid")
pp_check(gevp, type = "overlaid", subtype = "dens")

# Multiple plots
pp_check(gevp, type = "multiple")
pp_check(gevp, type = "multiple", subtype = "hist")
pp_check(gevp, type = "multiple", subtype = "boxplot")

# Intervals
pp_check(gevp, type = "intervals")
pp_check(gevp, type = "intervals", subtype = "ribbon")

# User-supplied bayesplot function
# Equivalent to p_check(gevp, type = "overlaid")
pp_check(gevp, type = "user", fun = "dens_overlay")

# GP model
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
gpg &lt;- rpost(n = 1000, model = "gp", prior = fp, thresh = u,
             data = gom, nrep = 50)
pp_check(gpg)
pp_check(gpg, type = "overlaid")

# bin-GP model
bp &lt;- set_bin_prior(prior = "jeffreys")
bgpg &lt;- rpost(n = 1000, model = "bingp", prior = fp, thresh = u,
              data = gom, bin_prior = bp, nrep = 50)
pp_check(bgpg, stat = "max")

# PP model
data(rainfall)
rthresh &lt;- 40
pf &lt;- set_prior(prior = "flat", model = "gev", min_xi = -1)
ppr &lt;- rpost(n = 1000, model = "pp", prior = pf, data = rainfall,
             thresh = rthresh, noy = 54, nrep = 50)
pp_check(ppr, stat = "max")

</code></pre>

<hr>
<h2 id='predict.evpost'>Predictive inference for the largest value observed in <code class="reqn">N</code> years.</h2><span id='topic+predict.evpost'></span>

<h3>Description</h3>

<p><code>predict</code> method for class &quot;evpost&quot;.  Performs predictive inference
about the largest value to be observed over a future time period of
<code class="reqn">N</code> years.  Predictive inferences accounts for uncertainty in model
parameters and for uncertainty owing to the variability of future
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evpost'
predict(
  object,
  type = c("i", "p", "d", "q", "r"),
  x = NULL,
  x_num = 100,
  n_years = 100,
  npy = NULL,
  level = 95,
  hpd = FALSE,
  lower_tail = TRUE,
  log = FALSE,
  big_q = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.evpost_+3A_object">object</code></td>
<td>
<p>An object of class <code>"evpost"</code>, a result of a call to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> with <code>model = "gev"</code>,
<code>model = "os"</code>, <code>model = "pp"</code> or <code>model == "bingp"</code>.
Calling these functions after a call to <code>rpost</code> or <code>rpost_rcpp</code>
with <code>model == "gp"</code> will produce an error, because inferences about
the probability of threshold exceedance are required, in addition to the
distribution of threshold excesses. The model is stored in
<code>object$model</code>.
</p>
<p><code>object</code> may also be an object created within the function
<code>predict.blite</code> in the <code>lite</code> package. In this case
<code>object$sim_vals</code> has a column named <code>"theta"</code> containing
a posterior sample of values of the extremal index.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_type">type</code></td>
<td>
<p>A character vector.  Indicates which type of inference is
required:
</p>

<ul>
<li><p> &quot;i&quot; for predictive intervals,
</p>
</li>
<li><p> &quot;p&quot; for the predictive distribution function,
</p>
</li>
<li><p> &quot;d&quot; for the predictive density function,
</p>
</li>
<li><p> &quot;q&quot; for the predictive quantile function,
</p>
</li>
<li><p> &quot;r&quot; for random generation from the predictive distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.evpost_+3A_x">x</code></td>
<td>
<p>A numeric vector or a matrix with <code>n_years</code> columns.
The meaning of <code>x</code> depends on <code>type</code>.
</p>

<ul>
<li> <p><code>type = "p"</code> or <code>type = "d"</code>: <code>x</code> contains
quantiles at which to evaluate the distribution or density function.
</p>
<p>If <code>object$model == "bingp"</code> then no element of <code>x</code> can be
less than the threshold <code>object$thresh</code>.
</p>
<p>If <code>x</code> is not supplied then <code>n_year</code>-specific defaults are
set: vectors of length <code>x_num</code> from the 0.1% quantile to the
99% quantile, subject all values being greater than the threshold.
</p>
</li>
<li> <p><code>type = "q"</code>: <code>x</code> contains probabilities in (0,1)
at which to evaluate the quantile function.  Any values outside
(0, 1) will be removed without warning.
</p>
<p>If <code>object$model == "bingp"</code> then no element of <code>p</code> can
correspond to a predictive quantile that is below the threshold,
<code>object$thresh</code>.  That is, no element of <code>p</code> can be less
than the value of <code>predict.evpost(object,</code>
<code>type = "q", x = object$thresh)</code>.
</p>
<p>If <code>x</code> is not supplied then a default value of
<code>c(0.025, 0.25, 0.5, 0.75, 0.975)</code> is used.
</p>
</li>
<li> <p><code>type = "i"</code> or <code>type = "r"</code>: <code>x</code> is not relevant.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.evpost_+3A_x_num">x_num</code></td>
<td>
<p>A numeric scalar.  If <code>type = "p"</code> or <code>type = "d"</code>
and <code>x</code> is not supplied then <code>x_num</code> gives the number of values
in <code>x</code> for each value in <code>n_years</code>.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_n_years">n_years</code></td>
<td>
<p>A numeric vector. Values of <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_npy">npy</code></td>
<td>
<p>A numeric scalar. The mean number of observations per year
of data, after excluding any missing values, i.e. the number of
non-missing observations divided by total number of years' worth of
non-missing data.
</p>
<p>If <code>rpost</code> or <code>rpost_rcpp</code> was called with
<code>model == "bingp"</code> then <code>npy</code> must either have been supplied
in that call or be supplied here.
</p>
<p>Otherwise, a default value will be assumed if <code>npy</code> is not supplied,
based on the value of <code>model</code> in the call to <code>rpost</code> or
<code>rpost_rcpp</code>:
</p>

<ul>
<li> <p><code>model = "gev"</code>: <code>npy</code> = 1, i.e. the data were
annual maxima so the block size is one year.
</p>
</li>
<li> <p><code>model = "os"</code>: <code>npy</code> = 1, i.e. the data were
annual order statistics so the block size is one year.
</p>
</li>
<li> <p><code>model = "pp"</code>:
<code>npy</code> = <code>length(x$data)</code> / <code>object$noy</code>,
i.e. the value of <code>noy</code> used in the call to <code><a href="#topic+rpost">rpost</a></code>
or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> is equated to a block size of one year.
</p>
</li></ul>

<p>If <code>npy</code> is supplied twice then the value supplied here will be
used and a warning given.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_level">level</code></td>
<td>
<p>A numeric vector of values in (0, 100).
Only relevant when <code>type = "i"</code>.
Levels of predictive intervals for the largest value observed in
<code class="reqn">N</code> years, i.e. level% predictive intervals are returned.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_hpd">hpd</code></td>
<td>
<p>A logical scalar.
Only relevant when <code>type = "i"</code>.
</p>
<p>If <code>hpd = FALSE</code> then the interval is
equi-tailed, with its limits produced by <br />
<code>predict.evpost(</code><code>object, type ="q", x = p)</code>,
where <code>p = c((1-level/100)/2,</code> <code>(1+level/100)/2)</code>.
</p>
<p>If <code>hpd = TRUE</code> then, in addition to the equi-tailed interval,
the shortest possible level% interval is calculated.
If the predictive distribution is unimodal then this
is a highest predictive density (HPD) interval.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_lower_tail">lower_tail</code></td>
<td>
<p>A logical scalar.
Only relevant when <code>type = "p"</code> or <code>type = "q"</code>.
If TRUE (default), (output or input) probabilities are
<code class="reqn">P[X \leq x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_log">log</code></td>
<td>
<p>A logical scalar.  Only relevant when <code>type = "d"</code>.
If TRUE the log-density is returned.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_big_q">big_q</code></td>
<td>
<p>A numeric scalar.  Only relevant when <code>type = "q"</code>.
An initial upper bound for the desired quantiles to be passed to
<code><a href="stats.html#topic+uniroot">uniroot</a></code> (its argument <code>upper</code>) in the
search for the predictive quantiles.  If this is not sufficiently large
then it is increased until it does provide an upper bound.</p>
</td></tr>
<tr><td><code id="predict.evpost_+3A_...">...</code></td>
<td>
<p>Additional optional arguments. At present no optional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inferences about future extreme observations are integrated over
the posterior distribution of the model parameters, thereby accounting
for uncertainty in model parameters and uncertainty owing to the
variability of future observations.  In practice the integrals involved
are estimated using an empirical mean over the posterior sample.
See, for example, Coles (2001), Stephenson (2016) or
Northrop et al. (2017) for details. See also the vignette
<a href="https://CRAN.R-project.org/package=revdbayes">Posterior Predictive Extreme Value Inference</a>
</p>
<p><strong>GEV / OS / PP</strong>.
If <code>model = "gev"</code>, <code>model = "os"</code> or <code>model = "pp"</code>
in the call to <code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>
we first calculate the number of blocks <code class="reqn">b</code> in <code>n_years</code> years.
To calculate the density function or distribution function of the maximum
over <code>n_years</code> we call <code><a href="#topic+dgev">dgev</a></code> or <code><a href="#topic+pgev">pgev</a></code>
with <code>m</code> = <code class="reqn">b</code>.
</p>

<ul>
<li> <p><code>type = "p"</code>. We calculate using <code><a href="#topic+pgev">pgev</a></code>
the GEV distribution function at <code>q</code> for each of the posterior
samples of the location, scale and shape parameters.  Then we take
the mean of these values.
</p>
</li>
<li> <p><code>type = "d"</code>. We calculate using <code><a href="#topic+dgev">dgev</a></code>
the GEV density function at <code>x</code> for each of the posterior samples
of the location, scale and shape parameters.  Then we take the
mean of these values.
</p>
</li>
<li> <p><code>type = "q"</code>. We solve numerically
<code>predict.evpost(object, type = "p", x = q)</code> = <code>p[i]</code>
numerically for <code>q</code> for each element <code>p[i]</code> of <code>p</code>.
</p>
</li>
<li> <p><code>type = "i"</code>. If <code>hpd = FALSE</code> then the interval is
equi-tailed, equal to <code>predict.evpost()</code> <code>object, type ="q", x = p)</code>,
where <code>p = c((1-level/100)/2,</code> <code>(1+level/100)/2)</code>.
If <code>hpd = TRUE</code> then, in addition, we perform a
numerical minimisation of the length of level% intervals, after
approximating the predictive quantile function using monotonic
cubic splines, to reduce computing time.
</p>
</li>
<li> <p><code>type = "r"</code>. For each simulated value of the GEV parameters
at the <code>n_years</code> level of aggregation we simulate one value from
this GEV distribution using <code><a href="#topic+rgev">rgev</a></code>.  Thus, each sample
from the predictive distribution is of a size equal to the size of
the posterior sample.
</p>
</li></ul>

<p><strong>Binomial-GP</strong>.  If <code>model = "bingp"</code> in the call to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> then we calculate the
mean number of observations in <code>n_years</code> years, i.e.
<code>npy * n_years</code>.
</p>
<p>Following Northrop et al. (2017), let <code class="reqn">M_N</code> be the largest value
observed in <code class="reqn">N</code> years, <code class="reqn">m</code> = <code>npy * n_years</code> and <code class="reqn">u</code> the
threshold <code>object$thresh</code> used in the call to <code>rpost</code>
or <code>rpost_rcpp</code>.
For fixed values of <code class="reqn">\theta = (p, \sigma, \xi)</code> the distribution
function of <code class="reqn">M_N</code> is given by <code class="reqn">F(z, \theta)^m</code>, for
<code class="reqn">z \geq u</code>, where
</p>
<p style="text-align: center;"><code class="reqn">F(z, \theta) = 1 - p [1 + \xi (x - u) / \sigma] ^ {-1/\xi}.</code>
</p>

<p>The distribution function of <code class="reqn">M_N</code> cannot be evaluated for
<code class="reqn">z &lt; u</code> because no model has been supposed for observations below
the threshold.
</p>

<ul>
<li> <p><code>type = "p"</code>. We calculate
<code class="reqn">F(z, \theta)^m</code> at <code>q</code> for each of the posterior samples
<code class="reqn">\theta</code>.  Then we take the mean of these values.
</p>
</li>
<li> <p><code>type = "d"</code>.  We calculate the density of of <code class="reqn">M_n</code>, i.e.
the derivative of <code class="reqn">F(z, \theta)^m</code> with respect to <code class="reqn">z</code> at
<code>x</code> for each of the posterior samples <code class="reqn">\theta</code>.  Then we take
the mean of these values.
</p>
</li>
<li> <p><code>type = "q"</code> and <code>type = "i"</code>. We perform calculations
that are analogous to the GEV case above.  If <code>n_years</code> is very
small and/or level is very close to 100 then a predictive interval
may extend below the threshold.  In such cases <code>NA</code>s are returned
(see <strong>Value</strong> below).
</p>
</li>
<li> <p><code>type = "r"</code>.  For each simulated value of the bin-GP
parameter we simulate from the distribution of <code class="reqn">M_N</code> using the
inversion method applied to the distribution function of <code class="reqn">M_N</code> given
above.  Occasionally a value below the threshold would need to be
simulated.  If these instances a missing value code <code>NA</code> is
returned. Thus, each sample from the predictive distribution is of a
size equal to the size of the posterior sample, perhaps with a small
number os <code>NA</code>s.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &quot;evpred&quot;, a list containing a subset of the
following components:
</p>
<table>
<tr><td><code>type</code></td>
<td>
<p>The argument <code>type</code> supplied to <code>predict.evpost</code>.
Which of the following components are present depends <code>type</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A matrix containing the argument <code>x</code> supplied to
<code>predict.evpost</code>, or set within <code>predict.evpost</code> if <code>x</code>
was not supplied, replicated to have <code>n_years</code> columns
if necessary.
Only present if <code>type</code> is <code>"p", "d"</code> or <code>"q"</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The content of <code>y</code> depends on <code>type</code>:
</p>

<ul>
<li> <p><code>type = "p", "d", "q"</code>:  A matrix with the same
dimensions as <code>x</code>.  Contains distribution function values
(<code>type = "p"</code>), predictive density (<code>type = "d"</code>)
or quantiles (<code>type = "q"</code>).
</p>
</li>
<li> <p><code>type = "r"</code>: A numeric matrix with <code>length(n_years)</code>
columns and number of rows equal to the size of the posterior sample.
</p>
</li>
<li> <p><code>type = "i"</code>: <code>y</code> is not present.
</p>
</li></ul>
</td></tr>
<tr><td><code>long</code></td>
<td>
<p>A <code>length(n_years)*length(level)</code> by 4 numeric
matrix containing the equi-tailed limits with columns:
lower limit, upper limit, n_years, level.
Only present if <code>type = "i"</code>.  If an interval extends below
the threshold then <code>NA</code> is returned.</p>
</td></tr>
<tr><td><code>short</code></td>
<td>
<p>A matrix with the same structure as <code>long</code>
containing the HPD limits.  Only present if <code>type = "i"</code>.
Columns 1 and 2 contain <code>NA</code>s if <code>hpd = FALSE</code>
or if the corresponding equi-tailed interval extends below
the threshold.</p>
</td></tr>
</table>
<p>The arguments <code>n_years, level, hpd, lower_tail, log</code> supplied
to <code>predict.evpost</code> are also included, as is the argument <code>npy</code>
supplied to, or set within, <code>predict.evpost</code> and
the arguments <code>data</code> and <code>model</code> from the original call to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.
</p>


<h3>References</h3>

<p>Coles, S. G. (2001) <em>An Introduction to Statistical
Modeling of Extreme Values</em>, Springer-Verlag, London.
Chapter 9: <a href="https://doi.org/10.1007/978-1-4471-3675-0_9">doi:10.1007/978-1-4471-3675-0_9</a>
</p>
<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>
<p>Stephenson, A. (2016). Bayesian Inference for Extreme Value
Modelling. In <em>Extreme Value Modeling and Risk Analysis: Methods and
Applications</em>, edited by D. K. Dey and J. Yan, 257-80. London:
Chapman and Hall. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.evpred">plot.evpred</a></code> for the S3 <code>plot</code> method for
objects of class <code>evpred</code>.
</p>
<p><code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for sampling
from an extreme value posterior distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### GEV
data(portpirie)
mat &lt;- diag(c(10000, 10000, 100))
pn &lt;- set_prior(prior = "norm", model = "gev", mean = c(0,0,0), cov = mat)
gevp  &lt;- rpost_rcpp(n = 1000, model = "gev", prior = pn, data = portpirie)

# Interval estimation
predict(gevp)$long
predict(gevp, hpd = TRUE)$short
# Density function
x &lt;- 4:7
predict(gevp, type = "d", x = x)$y
plot(predict(gevp, type = "d", n_years = c(100, 1000)))
# Distribution function
predict(gevp, type = "p", x = x)$y
plot(predict(gevp, type = "p", n_years = c(100, 1000)))
# Quantiles
predict(gevp, type = "q", n_years = c(100, 1000))$y
# Random generation
plot(predict(gevp, type = "r"))

### Binomial-GP
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
bp &lt;- set_bin_prior(prior = "jeffreys")
npy_gom &lt;- length(gom)/105
bgpg &lt;- rpost_rcpp(n = 1000, model = "bingp", prior = fp, thresh = u,
                   data = gom, bin_prior = bp)

# Setting npy in call to predict.evpost()
predict(bgpg, npy = npy_gom)$long

# Setting npy in call to rpost() or rpost_rcpp()
bgpg &lt;- rpost_rcpp(n = 1000, model = "bingp", prior = fp, thresh = u,
                   data = gom, bin_prior = bp, npy = npy_gom)

# Interval estimation
predict(bgpg)$long
predict(bgpg, hpd = TRUE)$short
# Density function
plot(predict(bgpg, type = "d", n_years = c(100, 1000)))
# Distribution function
plot(predict(bgpg, type = "p", n_years = c(100, 1000)))
# Quantiles
predict(bgpg, type = "q", n_years = c(100, 1000))$y
# Random generation
plot(predict(bgpg, type = "r"))
</code></pre>

<hr>
<h2 id='print.evpost'>Print method for objects of class &quot;evpost&quot;</h2><span id='topic+print.evpost'></span>

<h3>Description</h3>

<p>Print method for objects of class &quot;evpost&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evpost'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.evpost_+3A_x">x</code></td>
<td>
<p>An object of class &quot;evpost&quot;, a result of a call to
<code><a href="#topic+rpost">rpost</a></code>, <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>, <code><a href="#topic+kgaps_post">kgaps_post</a></code>
or <code><a href="#topic+dgaps_post">dgaps_post</a></code>.</p>
</td></tr>
<tr><td><code id="print.evpost_+3A_...">...</code></td>
<td>
<p>Further arguments.  None are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.evpost</code> just prints the original function call, to
avoid printing a huge list.
</p>


<h3>Value</h3>

<p>The argument <code>x</code> is returned, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.evpost">plot.evpost</a></code> for a diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Newlyn sea surges

thresh &lt;- quantile(newlyn, probs = 0.90)
k_postsim &lt;- kgaps_post(newlyn, thresh)
k_postsim
</code></pre>

<hr>
<h2 id='print.summary.evpost'>Print method for objects of class &quot;summary.evpost&quot;</h2><span id='topic+print.summary.evpost'></span>

<h3>Description</h3>

<p><code>print</code> method for an object <code>object</code> of class &quot;summary.evpost&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.evpost'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.evpost_+3A_x">x</code></td>
<td>
<p>An object of class &quot;summary.evpost&quot;, a result of a call to
<code><a href="#topic+summary.evpost">summary.evpost</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.evpost_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints
</p>

<ul>
<li><p> information about the ratio-of-uniforms bounding box, i.e.
<code>object$box</code>
</p>
</li>
<li><p> an estimate of the probability of acceptance, i.e.
<code>object$pa</code>
</p>
</li>
<li><p> a summary of the simulated values, via
<code>summary(object$sim_vals)</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="rust.html#topic+ru">ru</a></code> or <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> for
descriptions of <code>object$sim_vals</code> and <code>$box</code>.
</p>
<p><code><a href="#topic+plot.evpost">plot.evpost</a></code> for a diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GP posterior
u &lt;- stats::quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
gpg &lt;- rpost_rcpp(n = 1000, model = "gp", prior = fp, thresh = u,
                  data = gom)
summary(gpg)
</code></pre>

<hr>
<h2 id='quantile_to_gev'>Converts quantiles to GEV parameters</h2><span id='topic+quantile_to_gev'></span>

<h3>Description</h3>

<p>Three quantiles, that is, the value of quantile and their respective
exceedance probabilities, are provided. This function attempts to
find the location, scale and shape parameters of a GEV distribution that
has these quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_to_gev(quant, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_to_gev_+3A_quant">quant</code></td>
<td>
<p>A numeric vector of length 3. Values of the quantiles.
The values should <em>increase</em> with the index of the vector.
If not, the values in <code>quant</code> will be sorted into increasing order
without warning.</p>
</td></tr>
<tr><td><code id="quantile_to_gev_+3A_prob">prob</code></td>
<td>
<p>A numeric vector of length 3. Exceedance probabilities
corresponding to the quantiles in <code>quant</code>.
The values should <em>decrease</em> with the index of the vector.
If not, the values in <code>prob</code> will be sorted into decreasing order
without warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that <code class="reqn">G(x)</code> is the distribution function of
a GEV(<code class="reqn">\mu, \sigma, \xi</code>) distribution.  This function attempts to
solve numerically the set of three non-linear equations
</p>
<p style="text-align: center;"><code class="reqn">G(q_i) = 1 - p_i, i = 1, 2, 3</code>
</p>

<p>where <code class="reqn">q_i, i=1,2,3</code> are the quantiles in <code>quant</code> and
<code class="reqn">p_i, i=1,2,3</code> are the exceedance probabilities in <code>prob</code>.
This is reduced to a one-dimensional optimisation over the GEV
shape parameter.
</p>


<h3>Value</h3>

<p>A numeric vector of length 3 containing the GEV location, scale and
shape parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rprior_quant">rprior_quant</a></code> for simulation of GEV parameters from
a prior constructed on the quantile scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_q &lt;- c(15, 20, 22.5)
my_p &lt;- 1-c(0.5, 0.9, 0.5^0.01)
x &lt;- quantile_to_gev(quant = my_q, prob = my_p)
# Check
qgev(p = 1 - my_p, loc = x[1], scale = x[2], shape = x[3])
</code></pre>

<hr>
<h2 id='rainfall'>Daily Aggregate Rainfall</h2><span id='topic+rainfall'></span>

<h3>Description</h3>

<p>A numeric vector of length 20820 containing daily aggregate rainfall
observations, in millimetres, recorded at a rain gauge in England
over a 57 year period, beginning on a leap year. Three of these years
contain only missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rainfall
</code></pre>


<h3>Format</h3>

<p>A vector containing 20820 observations.
</p>


<h3>Source</h3>

<p>Unknown
</p>

<hr>
<h2 id='rDir'>Simulation from a Dirichlet distribution</h2><span id='topic+rDir'></span>

<h3>Description</h3>

<p>Simulates from a Dirichlet distribution with concentration parameter
vector <code class="reqn">\alpha</code> = (<code class="reqn">\alpha_1</code>, ..., <code class="reqn">\alpha_K</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDir(n = 1, alpha = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDir_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of sample required.</p>
</td></tr>
<tr><td><code id="rDir_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector.  Dirichlet concentration parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is based on the property that if
<code class="reqn">Y_1, \ldots, Y_K</code> are independent, <code class="reqn">Y_i</code> has a
gamma(<code class="reqn">\alpha_i</code>, 1) distribution and
<code class="reqn">S = Y_1 + \cdots + Y_k</code>
then <code class="reqn">(Y_1, \ldots, Y_K) / S</code> has a
Dirichlet(<code class="reqn">\alpha_1</code>, ..., <code class="reqn">\alpha_K</code>) distribution.
</p>
<p>See
<a href="https://en.wikipedia.org/wiki/Dirichlet_distribution#Gamma_distribution">https://en.wikipedia.org/wiki/Dirichlet_distribution#Gamma_distribution</a>
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>length(alpha)</code> numeric matrix.
</p>


<h3>References</h3>

<p>Kotz, S., Balakrishnan, N. and Johnson, N. L. (2000)
<em>Continuous Multivariate Distributions, vol. 1, Models and
Applications, 2nd edn</em>, ch. 49. New York: Wiley.
<a href="https://doi.org/10.1002/0471722065">doi:10.1002/0471722065</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rprior_prob">rprior_prob</a></code> for prior simulation of
GEV parameters - prior on probability scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rDir(n = 10, alpha = 1:4)
</code></pre>

<hr>
<h2 id='revdbayes-internal'>Internal revdbayes functions</h2><span id='topic+revdbayes-internal'></span><span id='topic+process_data'></span><span id='topic+create_ru_list'></span><span id='topic+set_which_lam'></span><span id='topic+set_range_phi'></span><span id='topic+box_cox'></span><span id='topic+box_cox_vec'></span><span id='topic+box_cox_deriv'></span><span id='topic+check_sample_size'></span><span id='topic+check_sample_size_message'></span><span id='topic+logNegNA'></span><span id='topic+fallback_gp_mle'></span>

<h3>Description</h3>

<p>Internal revdbayes functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_data(model, data, thresh, noy, use_noy, ros, weights = NULL)

create_ru_list(model, trans, rotate, min_xi, max_xi)

set_which_lam(model)

set_range_phi(model, phi_mid, se_phi, mult)

box_cox(x, lambda = 1, gm = 1, lambda_tol = 1e-06, poly_order = 3)

box_cox_vec(x, lambda = 1, lambda_tol = 1e-06)

box_cox_deriv(x, lambda = 1, lambda_tol = 1e-06, poly_order = 3)

check_sample_size(prior_name, n_check)

check_sample_size_message(prior_name, n_check)

logNegNA(x)

fallback_gp_mle(init, ...)
</code></pre>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='revdbayes-package'>revdbayes: Ratio-of-Uniforms Sampling for Bayesian Extreme Value Analysis</h2><span id='topic+revdbayes'></span><span id='topic+revdbayes-package'></span>

<h3>Description</h3>

<p>Uses the multivariate generalized ratio-of-uniforms method to simulate
random samples from the posterior distributions commonly encountered in
Bayesian extreme value analyses.
</p>


<h3>Details</h3>

<p>The main functions in the revdbayes package are <code><a href="#topic+rpost">rpost</a></code>
and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>, which simulate random samples from the
posterior distribution of extreme value model parameters using the
functions <code><a href="rust.html#topic+ru">ru</a></code> and <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code>
from the rust package, respectively. The user chooses the extreme value
model, the prior density for the parameters and provides the data.
There are options to improve the probability of acceptance of the
ratio-of-uniforms algorithm by working with transformation of the model
parameters.
</p>
<p>The functions <code><a href="#topic+kgaps_post">kgaps_post</a></code> and <code><a href="#topic+dgaps_post">dgaps_post</a></code>
simulate from the posterior distribution of the extremal index
<code class="reqn">\theta</code> based on the K-gaps model for threshold interexceedance
times of Suveges and Davison (2010) and the similar D-gaps model of
Holesovsky and Fusek (2020).  See also Attalides (2015).
</p>
<p>See <code>vignette("revdbayes-a-vignette", package = "revdbayes")</code> for an
overview of the package and
<code>vignette("revdbayes-b-using-rcpp-vignette", package = "revdbayes")</code>
for an illustration of the improvements in efficiency produced using
the Rcpp package.
See
<code>vignette("revdbayes-c-predictive-vignette", package = "revdbayes")</code>
for an outline of how to use revdbayes to perform posterior predictive
extreme value inference and
<code>vignette("revdbayes-d-kgaps-vignette", package = "revdbayes")</code>
considers Bayesian inference for the extremal index <code class="reqn">\theta</code>
using threshold inter-exceedance times.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul J. Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Scott D. Grimshaw [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Holesovsky, J. and Fusek, M. Estimation of the extremal index
using censored distributions. Extremes 23, 197-213 (2020).
<a href="https://doi.org/10.1007/s10687-020-00374-3">doi:10.1007/s10687-020-00374-3</a>
</p>
<p>Northrop, P. J. (2016). rust: Ratio-of-Uniforms Simulation with
Transformation. R package version 1.2.2.
<a href="https://cran.r-project.org/package=rust">https://cran.r-project.org/package=rust</a>.
</p>
<p>Suveges, M. and Davison, A. C. (2010) Model
misspecification in peaks over threshold analysis, <em>The Annals of
Applied Statistics</em>, <strong>4</strong>(1), 203-221.
<a href="https://doi.org/10.1214/09-AOAS292">doi:10.1214/09-AOAS292</a>
</p>
<p>Attalides, N. (2015) Threshold-based extreme value modelling,
PhD thesis, University College London.
<a href="https://discovery.ucl.ac.uk/1471121/1/Nicolas_Attalides_Thesis.pdf">https://discovery.ucl.ac.uk/1471121/1/Nicolas_Attalides_Thesis.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code> to set a prior density for extreme value
parameters.
</p>
<p><code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> to perform
ratio-of-uniforms sampling from an extreme value posterior distribution.
</p>
<p><code><a href="#topic+kgaps_post">kgaps_post</a></code> and <code><a href="#topic+dgaps_post">dgaps_post</a></code> to sample
from a posterior distribution for the extremal index based on
inter-exceedance times.
</p>
<p>The <code><a href="rust.html#topic+ru">ru</a></code> and <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code>
functions in the <code>rust</code> package for details of the arguments
that can be passed to <code>ru</code> via <code>rpost</code> and for the form of the
object (of class &quot;evpost&quot;) returned from <code>rpost</code>, which has the same
structure as an object (of class &quot;ru&quot;) returned by <code>ru</code> and
<code>ru_rcpp</code>.
</p>

<hr>
<h2 id='rpost'>Random sampling from extreme value posterior distributions</h2><span id='topic+rpost'></span>

<h3>Description</h3>

<p>Uses the <code><a href="rust.html#topic+ru">ru</a></code> function in the <code><a href="rust.html#topic+rust">rust</a></code>
package to simulate from the posterior distribution of an extreme value
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpost(
  n,
  model = c("gev", "gp", "bingp", "pp", "os"),
  data,
  prior,
  ...,
  nrep = NULL,
  thresh = NULL,
  noy = NULL,
  use_noy = TRUE,
  npy = NULL,
  ros = NULL,
  bin_prior = structure(list(prior = "bin_beta", ab = c(1/2, 1/2), class = "binprior")),
  bin_param = "logit",
  init_ests = NULL,
  mult = 2,
  use_phi_map = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpost_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="rpost_+3A_model">model</code></td>
<td>
<p>A character string.  Specifies the extreme value model.</p>
</td></tr>
<tr><td><code id="rpost_+3A_data">data</code></td>
<td>
<p>Sample data, of a format appropriate to the value of
<code>model</code>.
</p>

<ul>
<li> <p><code>"gp"</code>. A numeric vector of threshold excesses or raw data.
</p>
</li>
<li> <p><code>"bingp"</code>. A numeric vector of raw data.
</p>
</li>
<li> <p><code>"gev"</code>. A numeric vector of block maxima.
</p>
</li>
<li> <p><code>"pp"</code>. A numeric vector of raw data.
</p>
</li>
<li> <p><code>"os"</code>. A numeric matrix or data frame. Each row should contain
the largest order statistics for a block of data.  These need not
be ordered: they are sorted inside <code>rpost</code>. If a block
contains fewer than <code>dim(as.matrix(data))[2]</code> order statistics
then the corresponding row should be padded by <code>NA</code>s. If
<code>ros</code> is supplied then only the largest <code>ros</code> values in
each row are used.  If a vector is supplied then this is converted
to a matrix with one column.  This is equivalent to using
<code>model = "gev"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rpost_+3A_prior">prior</code></td>
<td>
<p>A list specifying the prior for the parameters of the extreme
value model, created by <code><a href="#topic+set_prior">set_prior</a></code>.</p>
</td></tr>
<tr><td><code id="rpost_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="rust.html#topic+ru">ru</a></code>.  Most
importantly <code>trans</code> and <code>rotate</code> (see <strong>Details</strong>), and
perhaps <code>r</code>, <code>ep</code>, <code>a_algor</code>, <code>b_algor</code>,
<code>a_method</code>, <code>b_method</code>, <code>a_control</code>, <code>b_control</code>.
May also be used to pass the arguments <code>n_grid</code> and/or <code>ep_bc</code>
to <code><a href="rust.html#topic+find_lambda">find_lambda</a></code>.</p>
</td></tr>
<tr><td><code id="rpost_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  If <code>nrep</code> is not <code>NULL</code> then
<code>nrep</code> gives the number of replications of the original dataset
simulated from the posterior predictive distribution.
Each replication is based on one of the samples from the posterior
distribution.  Therefore, <code>nrep</code> must not be greater than <code>n</code>.
In that event <code>nrep</code> is set equal to <code>n</code>.
Currently only implemented if <code>model = "gev"</code> or <code>"gp"</code> or
<code>"bingp"</code> or <code>"pp"</code>, i.e. <em>not</em> implemented if
<code>model = "os"</code>.</p>
</td></tr>
<tr><td><code id="rpost_+3A_thresh">thresh</code></td>
<td>
<p>A numeric scalar.  Extreme value threshold applied to data.
Only relevant when <code>model = "gp"</code>, <code>"pp"</code> or <code>"bingp"</code>.
Must be supplied when <code>model = "pp"</code> or <code>"bingp"</code>.
If <code>model = "gp"</code> and <code>thresh</code> is not supplied then
<code>thresh = 0</code> is used and <code>data</code> should contain threshold
excesses.</p>
</td></tr>
<tr><td><code id="rpost_+3A_noy">noy</code></td>
<td>
<p>A numeric scalar. The number of blocks of observations,
excluding any missing values.  A block is often a year.
Only relevant, and must be supplied, if <code>model = "pp"</code>.</p>
</td></tr>
<tr><td><code id="rpost_+3A_use_noy">use_noy</code></td>
<td>
<p>A logical scalar.  Only relevant if model is &quot;pp&quot;.
If <code>use_noy = FALSE</code> then sampling is based on a likelihood in
which the number of blocks (years) is set equal to the number of threshold
excesses, to reduce posterior dependence between the parameters
(Wadsworth <em>et al</em>., 2010).
The sampled values are transformed back to the required parameterisation
before returning them to the user.  If <code>use_noy = TRUE</code> then the
user's value of <code>noy</code> is used in the likelihood.</p>
</td></tr>
<tr><td><code id="rpost_+3A_npy">npy</code></td>
<td>
<p>A numeric scalar. The mean number of observations per year
of data, after excluding any missing values, i.e. the number of
non-missing observations divided by total number of years' worth of
non-missing data.
</p>
<p>The value of <code>npy</code> does not affect any calculation in
<code>rpost</code>, it only affects subsequent extreme value inferences using
<code>predict.evpost</code>.  However, setting <code>npy</code> in the call to
<code>rpost</code> avoids the need to supply <code>npy</code> when calling
<code>predict.evpost</code>.  This is likely to be useful only when
<code>model = bingp</code>. See the documentation of
<code><a href="#topic+predict.evpost">predict.evpost</a></code> for further details.</p>
</td></tr>
<tr><td><code id="rpost_+3A_ros">ros</code></td>
<td>
<p>A numeric scalar.  Only relevant when <code>model = "os"</code>. The
largest <code>ros</code> values in each row of the matrix <code>data</code> are used
in the analysis.</p>
</td></tr>
<tr><td><code id="rpost_+3A_bin_prior">bin_prior</code></td>
<td>
<p>A list specifying the prior for a binomial probability
<code class="reqn">p</code>, created by <code><a href="#topic+set_bin_prior">set_bin_prior</a></code>.  Only relevant if
<code>model = "bingp"</code>.  If this is not supplied then the Jeffreys
beta(1/2, 1/2) prior is used.</p>
</td></tr>
<tr><td><code id="rpost_+3A_bin_param">bin_param</code></td>
<td>
<p>A character scalar.  The argument <code>param</code> passed to
<code><a href="#topic+binpost">binpost</a></code>.  Only relevant if a user-supplied prior function
is set using <code><a href="#topic+set_bin_prior">set_bin_prior</a></code>.</p>
</td></tr>
<tr><td><code id="rpost_+3A_init_ests">init_ests</code></td>
<td>
<p>A numeric vector.  Initial parameter estimates for search
for the mode of the posterior distribution.</p>
</td></tr>
<tr><td><code id="rpost_+3A_mult">mult</code></td>
<td>
<p>A numeric scalar.  The grid of values used to choose the Box-Cox
transformation parameter lambda is based on the maximum a posteriori (MAP)
estimate +/- mult x estimated posterior standard deviation.</p>
</td></tr>
<tr><td><code id="rpost_+3A_use_phi_map">use_phi_map</code></td>
<td>
<p>A logical scalar. If trans = &quot;BC&quot; then <code>use_phi_map</code>
determines whether the grid of values for phi used to set lambda is
centred on the maximum a posterior (MAP) estimate of phi
(<code>use_phi_map = TRUE</code>), or on the initial estimate of phi
(<code>use_phi_map = FALSE</code>).</p>
</td></tr>
<tr><td><code id="rpost_+3A_weights">weights</code></td>
<td>
<p>An optional numeric vector of weights by which to multiply
the observations when constructing the log-likelihood.
Currently only implemented for <code>model = "gp"</code> or
<code>model = "bingp"</code>.
In the latter case <code>bin_prior$prior</code> must be <code>"bin_beta"</code>.
<code>weights</code> must have the same length as <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Generalised Pareto (GP)</em>: <code>model = "gp"</code>.  A model for threshold
excesses.  Required arguments: <code>n</code>, <code>data</code> and <code>prior</code>.
If <code>thresh</code> is supplied then only the values in <code>data</code> that
exceed <code>thresh</code> are used and the GP distribution is fitted to the
amounts by which those values exceed <code>thresh</code>.
If <code>thresh</code> is not supplied then the GP distribution is fitted to
all values in <code>data</code>, in effect <code>thresh = 0</code>.
See also <code><a href="#topic+gp">gp</a></code>.
</p>
<p><em>Binomial-GP</em>: <code>model = "bingp"</code>.  The GP model for threshold
excesses supplemented by a binomial(<code>length(data)</code>, <code class="reqn">p</code>)
model for the number of threshold excesses.  See Northrop et al. (2017)
for details.  Currently, the GP and binomial parameters are assumed to
be independent <em>a priori</em>.
</p>
<p><em>Generalised extreme value (GEV) model</em>: <code>model = "gev"</code>.  A
model for block maxima.  Required arguments: <code>n</code>, <code>data</code>,
<code>prior</code>.  See also <code><a href="#topic+gev">gev</a></code>.
</p>
<p><em>Point process (PP) model</em>: <code>model = "pp"</code>. A model for
occurrences of threshold exceedances and threshold excesses.  Required
arguments: <code>n</code>, <code>data</code>, <code>prior</code>, <code>thresh</code> and
<code>noy</code>.
</p>
<p><em>r-largest order statistics (OS) model</em>: <code>model = "os"</code>.
A model for the largest order statistics within blocks of data.
Required arguments: <code>n</code>, <code>data</code>, <code>prior</code>.  All the values
in <code>data</code> are used unless <code>ros</code> is supplied.
</p>
<p><em>Parameter transformation</em>.  The scalar logical arguments (to the
function <code>ru</code>) <code>trans</code> and <code>rotate</code> determine,
respectively, whether or not Box-Cox transformation is used to reduce
asymmetry in the posterior distribution and rotation of parameter
axes is used to reduce posterior parameter dependence.  The default
is <code>trans = "none"</code> and <code>rotate = TRUE</code>.
</p>
<p>See the <a href="https://CRAN.R-project.org/package=revdbayes">Introducing revdbayes vignette</a>
for further details and examples.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"evpost"</code>, which has the same
structure as an object of class <code>"ru"</code> returned from
<code><a href="rust.html#topic+ru">ru</a></code>.
In addition this list contains
</p>
<table>
<tr><td><code>model:</code></td>
<td>
<p>The argument <code>model</code> to <code>rpost</code>
detailed above.</p>
</td></tr>
<tr><td><code>data:</code></td>
<td>
<p>The content depends on <code>model</code>:
if <code>model = "gev"</code> then this is the argument <code>data</code> to
<code>rpost</code> detailed above, with missing values removed;
if <code>model = "gp"</code> then only the values that lie above the
threshold are included; if <code>model = "bingp"</code> or
<code>model = "pp"</code> then the input data are returned
but any value lying below the threshold is set to <code>thresh</code>;
if <code>model = "os"</code> then the order statistics used are returned
as a single vector.</p>
</td></tr>
<tr><td><code>prior:</code></td>
<td>
<p>The argument <code>prior</code> to <code>rpost</code>
detailed above.</p>
</td></tr>
</table>
<p>If <code>nrep</code> is not <code>NULL</code> then this list also contains
<code>data_rep</code>, a numerical matrix with <code>nrep</code> rows.  Each
row contains a replication of the original data <code>data</code>
simulated from the posterior predictive distribution.
If <code>model = "bingp"</code> or <code>"pp"</code> then the rate of threshold
exceedance is part of the inference.  Therefore, the number of values in
<code>data_rep</code> that lie above the threshold varies between
predictive replications (different rows of <code>data_rep</code>).
Values below the threshold are left-censored at the threshold, i.e. they
are set at the threshold.
</p>
<p>If <code>model == "pp"</code> then this list also contains the argument
<code>noy</code> to <code>rpost</code> detailed above.
If the argument <code>npy</code> was supplied then this list also contains
<code>npy</code>.
</p>
<p>If <code>model == "gp"</code> or <code>model == "bingp"</code> then this list also
contains the argument <code>thresh</code> to <code>rpost</code> detailed above.
</p>
<p>If <code>model == "bingp"</code> then this list also contains
</p>
<table>
<tr><td><code>bin_sim_vals:</code></td>
<td>
<p>An <code>n</code> by 1 numeric matrix of values
simulated from the posterior for the binomial probability <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>bin_logf:</code></td>
<td>
<p>A function returning the log-posterior for
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>bin_logf_args:</code></td>
<td>
<p>A list of arguments to <code>bin_logf</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Coles, S. G. and Powell, E. A. (1996) Bayesian methods in
extreme value modelling: a review and new developments.
<em>Int. Statist. Rev.</em>, <strong>64</strong>, 119-136.
</p>
<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>
<p>Stephenson, A. (2016) Bayesian Inference for Extreme Value
Modelling. In <em>Extreme Value Modeling and Risk Analysis: Methods and
Applications</em>, edited by D. K. Dey and J. Yan, 257-80. London:
Chapman and Hall. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>
value posterior using the evdbayes package.
</p>
<p>Wadsworth, J. L., Tawn, J. A. and Jonathan, P. (2010)
Accounting for choice of measurement scale in extreme value modeling.
<em>The Annals of Applied Statistics</em>, <strong>4</strong>(3), 1558-1578.
<a href="https://doi.org/10.1214/10-AOAS333">doi:10.1214/10-AOAS333</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code> for setting a prior distribution.
</p>
<p><code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for faster posterior simulation using
the Rcpp package.
</p>
<p><code><a href="#topic+plot.evpost">plot.evpost</a></code>, <code><a href="#topic+summary.evpost">summary.evpost</a></code> and
<code><a href="#topic+predict.evpost">predict.evpost</a></code> for the S3 <code>plot</code>, <code>summary</code>
and <code>predict</code> methods for objects of class <code>evpost</code>.
</p>
<p><code><a href="rust.html#topic+ru">ru</a></code> and <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> in the
<code><a href="rust.html#topic+rust">rust</a></code> package for details of the arguments that can
be passed to <code>ru</code> and the form of the object returned by
<code>rpost</code>.
</p>
<p><code><a href="rust.html#topic+find_lambda">find_lambda</a></code> and
<code><a href="rust.html#topic+find_lambda_rcpp">find_lambda_rcpp</a></code> in the <code><a href="rust.html#topic+rust">rust</a></code>
package is used inside <code>rpost</code> to set the Box-Cox transformation
parameter lambda when the <code>trans = "BC"</code> argument is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GP model
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
gpg &lt;- rpost(n = 1000, model = "gp", prior = fp, thresh = u, data = gom)
plot(gpg)

# Binomial-GP model
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
bp &lt;- set_bin_prior(prior = "jeffreys")
bgpg &lt;- rpost(n = 1000, model = "bingp", prior = fp, thresh = u, data = gom,
              bin_prior = bp)
plot(bgpg, pu_only = TRUE)
plot(bgpg, add_pu = TRUE)

# Setting the same binomial (Jeffreys) prior by hand
beta_prior_fn &lt;- function(p, ab) {
  return(stats::dbeta(p, shape1 = ab[1], shape2 = ab[2], log = TRUE))
}
jeffreys &lt;- set_bin_prior(beta_prior_fn, ab = c(1 / 2, 1 / 2))
bgpg &lt;- rpost(n = 1000, model = "bingp", prior = fp, thresh = u, data = gom,
              bin_prior = jeffreys)
plot(bgpg, pu_only = TRUE)
plot(bgpg, add_pu = TRUE)

# GEV model
mat &lt;- diag(c(10000, 10000, 100))
pn &lt;- set_prior(prior = "norm", model = "gev", mean = c(0, 0, 0), cov = mat)
gevp  &lt;- rpost(n = 1000, model = "gev", prior = pn, data = portpirie)
plot(gevp)

# GEV model, informative prior constructed on the probability scale
pip  &lt;- set_prior(quant = c(85, 88, 95), alpha = c(4, 2.5, 2.25, 0.25),
                  model = "gev", prior = "prob")
ox_post &lt;- rpost(n = 1000, model = "gev", prior = pip, data = oxford)
plot(ox_post)

# PP model
pf &lt;- set_prior(prior = "flat", model = "gev", min_xi = -1)
ppr &lt;- rpost(n = 1000, model = "pp", prior = pf, data = rainfall,
             thresh = 40, noy = 54)
plot(ppr)

# PP model, informative prior constructed on the quantile scale
piq &lt;- set_prior(prob = 10^-(1:3), shape = c(38.9, 7.1, 47),
                 scale = c(1.5, 6.3, 2.6), model = "gev", prior = "quant")
rn_post &lt;- rpost(n = 1000, model = "pp", prior = piq, data = rainfall,
                 thresh = 40, noy = 54)
plot(rn_post)

# OS model
mat &lt;- diag(c(10000, 10000, 100))
pv &lt;- set_prior(prior = "norm", model = "gev", mean = c(0, 0, 0), cov = mat)
osv &lt;- rpost(n = 1000, model = "os", prior = pv, data = venice)
plot(osv)

</code></pre>

<hr>
<h2 id='rpost_rcpp'>Random sampling from extreme value posterior distributions</h2><span id='topic+rpost_rcpp'></span>

<h3>Description</h3>

<p>Uses the <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> function in the
<code><a href="rust.html#topic+rust">rust</a></code> package to simulate from the posterior distribution
of an extreme value model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpost_rcpp(
  n,
  model = c("gev", "gp", "bingp", "pp", "os"),
  data,
  prior,
  ...,
  nrep = NULL,
  thresh = NULL,
  noy = NULL,
  use_noy = TRUE,
  npy = NULL,
  ros = NULL,
  bin_prior = structure(list(prior = "bin_beta", ab = c(1/2, 1/2), class = "binprior")),
  init_ests = NULL,
  mult = 2,
  use_phi_map = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpost_rcpp_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_model">model</code></td>
<td>
<p>A character string.  Specifies the extreme value model.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_data">data</code></td>
<td>
<p>Sample data, of a format appropriate to the value of
<code>model</code>.
</p>

<ul>
<li> <p><code>"gp"</code>. A numeric vector of threshold excesses or raw data.
</p>
</li>
<li> <p><code>"bingp"</code>. A numeric vector of raw data.
</p>
</li>
<li> <p><code>"gev"</code>. A numeric vector of block maxima.
</p>
</li>
<li> <p><code>"pp"</code>. A numeric vector of raw data.
</p>
</li>
<li> <p><code>"os"</code>. A numeric matrix or data frame. Each row should contain
the largest order statistics for a block of data.  These need not
be ordered: they are sorted inside <code>rpost</code>. If a block
contains fewer than <code>dim(as.matrix(data))[2]</code> order statistics
then the corresponding row should be padded by <code>NA</code>s. If
<code>ros</code> is supplied then only the largest <code>ros</code> values in
each row are used.  If a vector is supplied then this is converted
to a matrix with one column.  This is equivalent to using
<code>model = "gev"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_prior">prior</code></td>
<td>
<p>A list specifying the prior for the parameters of the extreme
value model, created by <code><a href="#topic+set_prior">set_prior</a></code>.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code>.
Most importantly <code>trans</code> and <code>rotate</code> (see <strong>Details</strong>),
and perhaps <code>r</code>, <code>ep</code>, <code>a_algor</code>, <code>b_algor</code>,
<code>a_method</code>, <code>b_method</code>, <code>a_control</code>, <code>b_control</code>.
May also be used to pass the arguments <code>n_grid</code> and/or <code>ep_bc</code>
to <code><a href="rust.html#topic+find_lambda">find_lambda</a></code>.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_nrep">nrep</code></td>
<td>
<p>A numeric scalar.  If <code>nrep</code> is not <code>NULL</code> then
<code>nrep</code> gives the number of replications of the original dataset
simulated from the posterior predictive distribution.
Each replication is based on one of the samples from the posterior
distribution.  Therefore, <code>nrep</code> must not be greater than <code>n</code>.
In that event <code>nrep</code> is set equal to <code>n</code>.
Currently only implemented if <code>model = "gev"</code> or <code>"gp"</code> or
<code>"bingp"</code> or <code>"pp"</code>, i.e. <em>not</em> implemented if
<code>model = "os"</code>.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_thresh">thresh</code></td>
<td>
<p>A numeric scalar.  Extreme value threshold applied to data.
Only relevant when <code>model = "gp"</code>, <code>"pp"</code> or <code>"bingp"</code>.
Must be supplied when <code>model = "pp"</code> or <code>"bingp"</code>.
If <code>model = "gp"</code> and <code>thresh</code> is not supplied then
<code>thresh = 0</code> is used and <code>data</code> should contain threshold
excesses.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_noy">noy</code></td>
<td>
<p>A numeric scalar. The number of blocks of observations,
excluding any missing values.  A block is often a year.
Only relevant, and must be supplied, if <code>model = "pp"</code>.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_use_noy">use_noy</code></td>
<td>
<p>A logical scalar.  Only relevant if model is &quot;pp&quot;.
If <code>use_noy = FALSE</code> then sampling is based on a likelihood in
which the number of blocks (years) is set equal to the number of threshold
excesses, to reduce posterior dependence between the parameters
(Wadsworth <em>et al</em>., 2010).
The sampled values are transformed back to the required parameterisation
before returning them to the user.  If <code>use_noy = TRUE</code> then the
user's value of <code>noy</code> is used in the likelihood.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_npy">npy</code></td>
<td>
<p>A numeric scalar. The mean number of observations per year
of data, after excluding any missing values, i.e. the number of
non-missing observations divided by total number of years' worth of
non-missing data.
</p>
<p>The value of <code>npy</code> does not affect any calculation in
<code>rpost</code>, it only affects subsequent extreme value inferences using
<code>predict.evpost</code>.  However, setting <code>npy</code> in the call to
<code>rpost</code> avoids the need to supply <code>npy</code> when calling
<code>predict.evpost</code>.  This is likely to be useful only when
<code>model = bingp</code>. See the documentation of
<code><a href="#topic+predict.evpost">predict.evpost</a></code> for further details.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_ros">ros</code></td>
<td>
<p>A numeric scalar.  Only relevant when <code>model = "os"</code>. The
largest <code>ros</code> values in each row of the matrix <code>data</code> are used
in the analysis.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_bin_prior">bin_prior</code></td>
<td>
<p>A list specifying the prior for a binomial probability
<code class="reqn">p</code>, created by <code><a href="#topic+set_bin_prior">set_bin_prior</a></code>.  Only relevant if
<code>model = "bingp"</code>.  If this is not supplied then the Jeffreys
beta(1/2, 1/2) prior is used.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_init_ests">init_ests</code></td>
<td>
<p>A numeric vector.  Initial parameter estimates for search
for the mode of the posterior distribution.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_mult">mult</code></td>
<td>
<p>A numeric scalar.  The grid of values used to choose the Box-Cox
transformation parameter lambda is based on the maximum a posteriori (MAP)
estimate +/- mult x estimated posterior standard deviation.</p>
</td></tr>
<tr><td><code id="rpost_rcpp_+3A_use_phi_map">use_phi_map</code></td>
<td>
<p>A logical scalar. If trans = &quot;BC&quot; then <code>use_phi_map</code>
determines whether the grid of values for phi used to set lambda is
centred on the maximum a posterior (MAP) estimate of phi
(<code>use_phi_map = TRUE</code>), or on the initial estimate of phi
(<code>use_phi_map = FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Generalised Pareto (GP)</em>: <code>model = "gp"</code>.  A model for threshold
excesses.  Required arguments: <code>n</code>, <code>data</code> and <code>prior</code>.
If <code>thresh</code> is supplied then only the values in <code>data</code> that
exceed <code>thresh</code> are used and the GP distribution is fitted to the
amounts by which those values exceed <code>thresh</code>.
If <code>thresh</code> is not supplied then the GP distribution is fitted to
all values in <code>data</code>, in effect <code>thresh = 0</code>.
See also <code><a href="#topic+gp">gp</a></code>.
</p>
<p><em>Binomial-GP</em>: <code>model = "bingp"</code>.  The GP model for threshold
excesses supplemented by a binomial(<code>length(data)</code>, <code class="reqn">p</code>)
model for the number of threshold excesses.  See Northrop et al. (2017)
for details.  Currently, the GP and binomial parameters are assumed to
be independent <em>a priori</em>.
</p>
<p><em>Generalised extreme value (GEV) model</em>: <code>model = "gev"</code>.  A
model for block maxima.  Required arguments: <code>n</code>, <code>data</code>,
<code>prior</code>.  See also <code><a href="#topic+gev">gev</a></code>.
</p>
<p><em>Point process (PP) model</em>: <code>model = "pp"</code>. A model for
occurrences of threshold exceedances and threshold excesses.  Required
arguments: <code>n</code>, <code>data</code>, <code>prior</code>, <code>thresh</code> and
<code>noy</code>.
</p>
<p><em>r-largest order statistics (OS) model</em>: <code>model = "os"</code>.
A model for the largest order statistics within blocks of data.
Required arguments: <code>n</code>, <code>data</code>, <code>prior</code>.  All the values
in <code>data</code> are used unless <code>ros</code> is supplied.
</p>
<p><em>Parameter transformation</em>.  The scalar logical arguments (to the
function <code>ru</code>) <code>trans</code> and <code>rotate</code> determine,
respectively, whether or not Box-Cox transformation is used to reduce
asymmetry in the posterior distribution and rotation of parameter
axes is used to reduce posterior parameter dependence.  The default
is <code>trans = "none"</code> and <code>rotate = TRUE</code>.
</p>
<p>See the <a href="https://CRAN.R-project.org/package=revdbayes">Introducing revdbayes vignette</a>
for further details and examples.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"evpost"</code>, which has the same
structure as an object of class <code>"ru"</code> returned from
<code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code>.  In addition this list contains
</p>
<table>
<tr><td><code>model:</code></td>
<td>
<p>The argument <code>model</code> to <code>rpost</code>
detailed above.</p>
</td></tr>
<tr><td><code>data:</code></td>
<td>
<p>The content depends on <code>model</code>:
if <code>model = "gev"</code> then this is the argument <code>data</code> to
<code>rpost</code> detailed above, with missing values removed;
if <code>model = "gp"</code> then only the values that lie above the
threshold are included; if <code>model = "bingp"</code> or
<code>model = "pp"</code> then the input data are returned
but any value lying below the threshold is set to <code>thresh</code>;
if <code>model = "os"</code> then the order statistics used are returned
as a single vector.</p>
</td></tr>
<tr><td><code>prior:</code></td>
<td>
<p>The argument <code>prior</code> to <code>rpost</code>
detailed above.</p>
</td></tr>
<tr><td><code>logf_rho_args:</code></td>
<td>
<p>A list of arguments to the (transformed)
target log-density.</p>
</td></tr>
</table>
<p>If <code>nrep</code> is not <code>NULL</code> then this list also contains
<code>data_rep</code>, a numerical matrix with <code>nrep</code> rows.  Each
row contains a replication of the original data <code>data</code>
simulated from the posterior predictive distribution.
If <code>model = "bingp"</code> or <code>"pp"</code> then the rate of threshold
exceedance is part of the inference.  Therefore, the number of values in
<code>data_rep</code> that lie above the threshold varies between
predictive replications (different rows of <code>data_rep</code>).
Values below the threshold are left-censored at the threshold, i.e. they
are set at the threshold.
</p>
<p>If <code>model == "pp"</code> then this list also contains the argument
<code>noy</code> to <code>rpost</code> detailed above.
If the argument <code>npy</code> was supplied then this list also contains
<code>npy</code>.
</p>
<p>If <code>model == "gp"</code> or <code>model == "bingp"</code> then this list also
contains the argument <code>thresh</code> to <code>rpost</code> detailed above.
</p>
<p>If <code>model == "bingp"</code> then this list also contains
</p>
<table>
<tr><td><code>bin_sim_vals:</code></td>
<td>
<p>An <code>n</code> by 1 numeric matrix of values
simulated from the posterior for the binomial probability <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>bin_logf:</code></td>
<td>
<p>A function returning the log-posterior for
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>bin_logf_args:</code></td>
<td>
<p>A list of arguments to <code>bin_logf</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Coles, S. G. and Powell, E. A. (1996) Bayesian methods in
extreme value modelling: a review and new developments.
<em>Int. Statist. Rev.</em>, <strong>64</strong>, 119-136.
</p>
<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>
<p>Stephenson, A. (2016) Bayesian Inference for Extreme Value
Modelling. In <em>Extreme Value Modeling and Risk Analysis: Methods and
Applications</em>, edited by D. K. Dey and J. Yan, 257-80. London:
Chapman and Hall. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>
value posterior using the evdbayes package.
</p>
<p>Wadsworth, J. L., Tawn, J. A. and Jonathan, P. (2010)
Accounting for choice of measurement scale in extreme value modeling.
<em>The Annals of Applied Statistics</em>, <strong>4</strong>(3), 1558-1578.
<a href="https://doi.org/10.1214/10-AOAS333">doi:10.1214/10-AOAS333</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_prior">set_prior</a></code> for setting a prior distribution.
</p>
<p><code><a href="#topic+rpost">rpost</a></code> for posterior simulation without using
the Rcpp package.
</p>
<p><code><a href="#topic+plot.evpost">plot.evpost</a></code>, <code><a href="#topic+summary.evpost">summary.evpost</a></code> and
<code><a href="#topic+predict.evpost">predict.evpost</a></code> for the S3 <code>plot</code>, <code>summary</code>
and <code>predict</code> methods for objects of class <code>evpost</code>.
</p>
<p><code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> in the <code><a href="rust.html#topic+rust">rust</a></code>
package for details of the arguments that can be passed to
<code>ru_rcpp</code> and the form of the object returned by <code>rpost_rcpp</code>.
</p>
<p><code><a href="rust.html#topic+find_lambda">find_lambda</a></code> in the
<code><a href="rust.html#topic+rust">rust</a></code> package is used inside <code>rpost</code> to set the
Box-Cox transformation parameter lambda when the <code>trans = "BC"</code>
argument is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GP model
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
gpg &lt;- rpost_rcpp(n = 1000, model = "gp", prior = fp, thresh = u,
                  data = gom)
plot(gpg)

# GP model, user-defined prior (same prior as the previous example)
ptr_gp_flat &lt;- create_prior_xptr("gp_flat")
p_user &lt;- set_prior(prior = ptr_gp_flat, model = "gp", min_xi = -1)
gpg &lt;- rpost_rcpp(n = 1000, model = "gp", prior = p_user, thresh = u,
                  data = gom)
plot(gpg)

# Binomial-GP model
u &lt;- quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
bp &lt;- set_bin_prior(prior = "jeffreys")
bgpg &lt;- rpost_rcpp(n = 1000, model = "bingp", prior = fp, thresh = u,
                   data = gom, bin_prior = bp)
plot(bgpg, pu_only = TRUE)
plot(bgpg, add_pu = TRUE)

# Setting the same binomial (Jeffreys) prior by hand
beta_prior_fn &lt;- function(p, ab) {
  return(stats::dbeta(p, shape1 = ab[1], shape2 = ab[2], log = TRUE))
}
jeffreys &lt;- set_bin_prior(beta_prior_fn, ab = c(1 / 2, 1 / 2))
bgpg &lt;- rpost_rcpp(n = 1000, model = "bingp", prior = fp, thresh = u,
                   data = gom, bin_prior = jeffreys)
plot(bgpg, pu_only = TRUE)
plot(bgpg, add_pu = TRUE)

# GEV model
mat &lt;- diag(c(10000, 10000, 100))
pn &lt;- set_prior(prior = "norm", model = "gev", mean = c(0, 0, 0), cov = mat)
gevp  &lt;- rpost_rcpp(n = 1000, model = "gev", prior = pn, data = portpirie)
plot(gevp)

# GEV model, user-defined prior (same prior as the previous example)
mat &lt;- diag(c(10000, 10000, 100))
ptr_gev_norm &lt;- create_prior_xptr("gev_norm")
pn_u &lt;- set_prior(prior = ptr_gev_norm, model = "gev", mean = c(0, 0, 0),
                  icov = solve(mat))
gevu &lt;- rpost_rcpp(n = 1000, model = "gev", prior = pn_u, data = portpirie)
plot(gevu)

# GEV model, informative prior constructed on the probability scale
pip  &lt;- set_prior(quant = c(85, 88, 95), alpha = c(4, 2.5, 2.25, 0.25),
  model = "gev", prior = "prob")
ox_post &lt;- rpost_rcpp(n = 1000, model = "gev", prior = pip, data = oxford)
plot(ox_post)

# PP model
pf &lt;- set_prior(prior = "flat", model = "gev", min_xi = -1)
ppr &lt;- rpost_rcpp(n = 1000, model = "pp", prior = pf, data = rainfall,
                  thresh = 40, noy = 54)
plot(ppr)

# PP model, user-defined prior (same prior as the previous example)
ptr_gev_flat &lt;- create_prior_xptr("gev_flat")
pf_u &lt;- set_prior(prior = ptr_gev_flat, model = "gev", min_xi = -1,
                  max_xi = Inf)
ppru &lt;- rpost_rcpp(n = 1000, model = "pp", prior = pf_u, data = rainfall,
                   thresh = 40, noy = 54)
plot(ppru)

# PP model, informative prior constructed on the quantile scale
piq &lt;- set_prior(prob = 10^-(1:3), shape = c(38.9, 7.1, 47),
                 scale = c(1.5, 6.3, 2.6), model = "gev", prior = "quant")
rn_post &lt;- rpost_rcpp(n = 1000, model = "pp", prior = piq, data = rainfall,
                      thresh = 40, noy = 54)
plot(rn_post)

# OS model
mat &lt;- diag(c(10000, 10000, 100))
pv &lt;- set_prior(prior = "norm", model = "gev", mean = c(0, 0, 0), cov = mat)
osv &lt;- rpost_rcpp(n = 1000, model = "os", prior = pv, data = venice)
plot(osv)
</code></pre>

<hr>
<h2 id='rprior_prob'>Prior simulation of GEV parameters - prior on probability scale</h2><span id='topic+rprior_prob'></span>

<h3>Description</h3>

<p>Simulates from the prior distribution for GEV parameters based on
Crowder (1992), in which independent beta priors are specified
for ratios of probabilities (which is equivalent to
a Dirichlet prior on differences between these probabilities).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rprior_prob(n, quant, alpha, exc = FALSE, lb = NULL, lb_prob = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprior_prob_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of sample required.</p>
</td></tr>
<tr><td><code id="rprior_prob_+3A_quant">quant</code></td>
<td>
<p>A numeric vector of length 3.  Contains quantiles
<code class="reqn">q_1, q_2, q_3</code>.  A prior distribution is placed on the
non-exceedance (<code>exc = FALSE</code>) or exceedance (<code>exc = TRUE</code>)
probabilities corresponding to these quantiles.
The values should <em>increase</em> with the index of the vector.
If not, the values in <code>quant</code> will be sorted into increasing order
without warning.</p>
</td></tr>
<tr><td><code id="rprior_prob_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector of length 4. Parameters of the Dirichlet
distribution for the exceedance probabilities.</p>
</td></tr>
<tr><td><code id="rprior_prob_+3A_exc">exc</code></td>
<td>
<p>A logical scalar.  Let <code class="reqn">M</code> be the GEV variable,
<code class="reqn">r_q = P(M \leq q)</code>,
<code class="reqn">p_q = P(M &gt; q) = 1 - r_q</code> and
<code>quant</code> = (<code class="reqn">q_1, q_2, q_3</code>).
If <code>exc = FALSE</code> then a Dirichlet(<code>alpha</code>) distribution is
placed on
<code class="reqn">(r_{q_1}, r_{q_2} - r_{q_1}, r_{q_3} - r_{q_2}, 1 - r_{q_3})</code>, as in
Northrop et al. (2017).
If <code>exc = TRUE</code> then a Dirichlet(<code>alpha</code>) distribution
is placed on
<code class="reqn">(1 - p_{q_1}, p_{q_1} - p_{q_2}, p_{q_2} - p_{q_3}, p_{q_3})</code>, where
<code class="reqn">p_q = P(M &gt; q)</code>, as in Stephenson (2016).</p>
</td></tr>
<tr><td><code id="rprior_prob_+3A_lb">lb</code></td>
<td>
<p>A numeric scalar.  If this is not <code>NULL</code> then the simulation
is constrained so that <code>lb</code> is an approximate lower bound on the
GEV variable.  Specifically, only simulated GEV parameter values for
which the 100<code>lb_prob</code>% quantile is greater than <code>lb</code> are
retained.</p>
</td></tr>
<tr><td><code id="rprior_prob_+3A_lb_prob">lb_prob</code></td>
<td>
<p>A numeric scalar.  The non-exceedance probability involved
in the specification of <code>lb</code>.  Must be in (0,1).  If <code>lb=NULL</code>
then <code>lb_prob</code> is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is based on the way that the prior is constructed.
See Stephenson (1996) the evdbayes user guide or Northrop et al. (2017)
Northrop et al. (2017) for details of the construction of the prior.
First, differences between probabilities are simulated from a Dirichlet
distribution. Then the GEV location, scale and shape parameters that
correspond to these quantile values are found, by solving numerically a
set of three non-linear equations in which the GEV quantile function
evaluated at the simulated probabilities is equated to the quantiles in
<code>quant</code>. This is reduced to a one-dimensional optimisation over the
GEV shape parameter.
</p>


<h3>Value</h3>

<p>An <code>n</code> by 3 numeric matrix.
</p>


<h3>References</h3>

<p>Crowder, M. (1992) Bayesian priors based on parameter
transformation using the distribution function.
<em>Ann. Inst. Statist. Math.</em>, <strong>44</strong>(3), 405-416.
<a href="https://link.springer.com/article/10.1007/BF00050695">https://link.springer.com/article/10.1007/BF00050695</a>
</p>
<p>Stephenson, A. 2016. Bayesian Inference for Extreme Value
Modelling. In <em>Extreme Value Modeling and Risk Analysis: Methods and
Applications</em>, edited by D. K. Dey and J. Yan, 257-80. London:
Chapman and Hall. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>
</p>
<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for sampling
from an extreme value posterior distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quant &lt;- c(85, 88, 95)
alpha &lt;- c(4, 2.5, 2.25, 0.25)
x &lt;- rprior_prob(n = 1000, quant = quant, alpha = alpha, exc = TRUE)
x &lt;- rprior_prob(n = 1000, quant = quant, alpha = alpha, exc = TRUE, lb = 0)
</code></pre>

<hr>
<h2 id='rprior_quant'>Prior simulation of GEV parameters - prior on quantile scale</h2><span id='topic+rprior_quant'></span>

<h3>Description</h3>

<p>Simulates from the prior distribution for GEV parameters proposed in
Coles and Tawn (1996), based on independent gamma priors for differences
between quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rprior_quant(n, prob, shape, scale, lb = NULL, lb_prob = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprior_quant_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of sample required.</p>
</td></tr>
<tr><td><code id="rprior_quant_+3A_prob">prob</code></td>
<td>
<p>A numeric vector of length 3. Exceedance probabilities
corresponding to the quantiles used to specify the prior distribution.
The values should <em>decrease</em> with the index of the vector.
If not, the values in <code>prob</code> will be sorted into decreasing order
without warning.</p>
</td></tr>
<tr><td><code id="rprior_quant_+3A_shape">shape</code></td>
<td>
<p>A numeric vector of length 3. Respective shape parameters of
the gamma priors for the quantile differences.</p>
</td></tr>
<tr><td><code id="rprior_quant_+3A_scale">scale</code></td>
<td>
<p>A numeric vector of length 3. Respective scale parameters of
the gamma priors for the quantile differences.</p>
</td></tr>
<tr><td><code id="rprior_quant_+3A_lb">lb</code></td>
<td>
<p>A numeric scalar.  If this is not <code>NULL</code> then the simulation
is constrained so that <code>lb</code> is an approximate lower bound on the
GEV variable.  Specifically, only simulated GEV parameter values for
which the 100<code>lb_prob</code>% quantile is greater than <code>lb</code> are
retained.</p>
</td></tr>
<tr><td><code id="rprior_quant_+3A_lb_prob">lb_prob</code></td>
<td>
<p>A numeric scalar.  The non-exceedance probability involved
in the specification of <code>lb</code>.  Must be in (0,1).  If <code>lb=NULL</code>
then <code>lb_prob</code> is not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation is based on the way that the prior is constructed.
See Coles and Tawn (1996), Stephenson (2016) or the evdbayes user guide
for details of the construction of the prior. First, the quantile
differences are simulated from the specified gamma distributions.
Then the simulated quantiles are calculated. Then the GEV location,
scale and shape parameters that give these quantile values are found,
by solving numerically a set of three non-linear equations in which the
GEV quantile function evaluated at the values in <code>prob</code> is equated
to the simulated quantiles.  This is reduced to a one-dimensional
optimisation over the GEV shape parameter.
</p>


<h3>Value</h3>

<p>An <code>n</code> by 3 numeric matrix.
</p>


<h3>References</h3>

<p>Coles, S. G. and Tawn, J. A. (1996) A Bayesian analysis of
extreme rainfall data. <em>Appl. Statist.</em>, <strong>45</strong>, 463-478.
</p>
<p>Stephenson, A. 2016. Bayesian Inference for Extreme Value
Modelling. In <em>Extreme Value Modeling and Risk Analysis: Methods and
Applications</em>, edited by D. K. Dey and J. Yan, 257-80. London:
Chapman and Hall. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for sampling
from an extreme value posterior distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pr &lt;- 10 ^ -(1:3)
sh &lt;- c(38.9, 7.1, 47)
sc &lt;- c(1.5, 6.3, 2.6)
x &lt;- rprior_quant(n = 1000, prob = pr, shape = sh, scale = sc)
x &lt;- rprior_quant(n = 1000, prob = pr, shape = sh, scale = sc, lb = 0)
</code></pre>

<hr>
<h2 id='set_bin_prior'>Construction of a prior distribution for a binomial probability <code class="reqn">p</code></h2><span id='topic+set_bin_prior'></span>

<h3>Description</h3>

<p>Constructs a prior distribution for use as the argument <code>bin_prior</code> in
<code><a href="#topic+rpost">rpost</a></code> or in <code><a href="#topic+binpost">binpost</a></code>.  The user can choose
from a list of in-built priors or specify their own prior function,
returning the <strong>log</strong> of the prior density, using an R function
and arguments for hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_bin_prior(
  prior = c("jeffreys", "laplace", "haldane", "beta", "mdi", "northrop"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_bin_prior_+3A_prior">prior</code></td>
<td>
<p>Either
</p>

<ul>
<li><p> An R function that returns the value of the log of the prior
density (see <strong>Examples</strong>), or
</p>
</li>
<li><p> A character string giving the name of the prior for <code class="reqn">p</code>.
See <strong>Details</strong> for a list of priors available.
</p>
</li></ul>
</td></tr>
<tr><td><code id="set_bin_prior_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the user-supplied or in-built
prior function.  For the latter this is only relevant if
<code>prior = "beta"</code>, when <code>ab</code> can be passed. See <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Binomial priors.</strong> The names of the binomial priors set using
<code>bin_prior</code> are:
</p>

<ul>
<li> <p><code>"jeffreys"</code>: the <em>Jeffreys</em> beta(1/2, 1/2) prior.
</p>
</li>
<li> <p><code>"laplace"</code>: the <em>Bayes-Laplace</em> beta(1, 1) prior.
</p>
</li>
<li> <p><code>"haldane"</code>: the <em>Haldane</em> beta(0, 0) prior.
</p>
</li>
<li> <p><code>"beta"</code>: a beta(<code class="reqn">\alpha, \beta</code>) prior.  The argument
<code>ab</code> is a vector containing <code>c</code>(<code class="reqn">\alpha, \beta</code>).
The default is <code>ab = c(1, 1)</code>.
</p>
</li>
<li> <p><code>"mdi"</code>: the MDI prior
<code class="reqn">\pi(p) = 1.6186 p^p (1-p)^{1-p}</code>,
for <code class="reqn">0 &lt; p &lt; 1.</code>
</p>
</li>
<li> <p><code>"northrop"</code>: the improper prior
<code class="reqn">\pi(p)=\{-\ln(1-p)\}^{-1}(1-p)^{-1}</code>,
for <code class="reqn">0 &lt; p &lt; 1.</code>
</p>
</li></ul>

<p>Apart from the last two priors these are all beta distributions.
</p>


<h3>Value</h3>

<p>A list of class <code>"binprior"</code>.  The first component is the
name of the input prior.  Apart from the MDI prior this will be &quot;beta&quot;,
in which case the other component of the list is a vector of length two
giving the corresponding values of the beta parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binpost">binpost</a></code> for sampling from a binomial posterior
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bp &lt;- set_bin_prior(prior = "jeffreys")

# Setting the Jeffreys prior by hand
beta_prior_fn &lt;- function(p, ab) {
  return(stats::dbeta(p, shape1 = ab[1], shape2 = ab[2], log = TRUE))
}
jeffreys &lt;- set_bin_prior(beta_prior_fn, ab = c(1 / 2, 1 / 2))
</code></pre>

<hr>
<h2 id='set_prior'>Construction of prior distributions for extreme value model parameters</h2><span id='topic+set_prior'></span>

<h3>Description</h3>

<p>Constructs a prior distribution for use as the argument <code>prior</code> in
<code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.  The user can either
specify their own prior function, returning the <strong>log</strong> of the prior
density, (using an R function or an external pointer to a compiled C++
function) and arguments for hyperparameters or choose from a list of
in-built model-specific priors.  Note that the arguments
<code>model = "gev"</code>, <code>model = "pp"</code> and <code>model =="os"</code> are
equivalent because a prior is specified is the GEV parameterisation in each
of these cases.
Note also that for <code>model = "pp"</code> the prior GEV parameterisation
relates to the value of <code>noy</code> subsequently supplied to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.
The argument <code>model</code> is used for consistency with <code>rpost</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_prior(
  prior = c("norm", "loglognorm", "mdi", "flat", "flatflat", "jeffreys", "beta", "prob",
    "quant"),
  model = c("gev", "gp", "pp", "os"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_prior_+3A_prior">prior</code></td>
<td>
<p>Either
</p>

<ul>
<li><p> An R function, or a pointer to a user-supplied compiled
C++ function, that returns the value of the log of the prior density
(see <strong>Examples</strong>), or
</p>
</li>
<li><p> A character string giving the name of the prior.
See <strong>Details</strong> for a list of priors available for each model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="set_prior_+3A_model">model</code></td>
<td>
<p>A character string.  If <code>prior</code> is a character string
then <code>model</code> gives the extreme value model to be used.  Using
either <code>model = "gev"</code>, <code>model = "pp"</code> or
<code>model = "os"</code> will result in the same (GEV) parameterisation.
If <code>prior</code> is a function then the value of <code>model</code> is stored
so that in the subsequent call to <code>rpost</code>, consistency of the
prior and extreme value model parameterisations can be checked.</p>
</td></tr>
<tr><td><code id="set_prior_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the user-supplied or
in-built prior function.  For details of the latter see <strong>Details</strong>
and/or the relevant underlying function: <code><a href="#topic+gp_norm">gp_norm</a></code>,
<code><a href="#topic+gp_mdi">gp_mdi</a></code>, <code><a href="#topic+gp_flat">gp_flat</a></code>, <code><a href="#topic+gp_flatflat">gp_flatflat</a></code>,
<code><a href="#topic+gp_jeffreys">gp_jeffreys</a></code>, <code><a href="#topic+gp_beta">gp_beta</a></code>,
<code><a href="#topic+gev_norm">gev_norm</a></code>, <code><a href="#topic+gev_loglognorm">gev_loglognorm</a></code>,
<code><a href="#topic+gev_mdi">gev_mdi</a></code>, <code><a href="#topic+gev_flat">gev_flat</a></code>, <code><a href="#topic+gev_flatflat">gev_flatflat</a></code>,
<code><a href="#topic+gev_beta">gev_beta</a></code>, <code><a href="#topic+gev_prob">gev_prob</a></code>, <code><a href="#topic+gev_quant">gev_quant</a></code>.
All these priors have the arguments <code>min_xi</code> (prior lower bound on
<code class="reqn">\xi</code>) and <code>max_xi</code> (prior upper bound on <code class="reqn">\xi</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Of the in-built named priors available in revdbayes only
those specified using <code>prior = "prob"</code> (<code><a href="#topic+gev_prob">gev_prob</a></code>),
<code>prior = "quant"</code> (<code><a href="#topic+gev_quant">gev_quant</a></code>)
<code>prior = "norm"</code> (<code><a href="#topic+gev_norm">gev_norm</a></code>) or
<code>prior = "loglognorm"</code> (<code><a href="#topic+gev_loglognorm">gev_loglognorm</a></code>) are proper.
If <code>model = "gev"</code> these priors are equivalent to priors available
in the evdbayes package, namely <code>prior.prob</code>,
<code>prior.quant</code>, <code>prior.norm</code> and <code>prior.loglognorm</code>.
</p>
<p>The other in-built priors are improper, that is, the integral of the
prior function over its support is not finite.  Such priors do not
necessarily result in a proper posterior distribution. Northrop and
Attalides (2016) consider the issue of posterior propriety in Bayesian
extreme value analyses.  In most of improper priors below the prior for
the scale parameter <code class="reqn">\sigma</code> is taken to be <code class="reqn">1/\sigma</code>,
i.e. a flat prior for <code class="reqn">\log \sigma</code>.  Here we denote the
scale parameter of the GP distribution by <code class="reqn">\sigma</code>, whereas we use
<code class="reqn">\sigma_u</code> in the revdbayes vignette.
</p>
<p>For all in-built priors the arguments <code>min_xi</code> and <code>max_xi</code> may
be supplied by the user.  The prior density is set to zero for any value
of the shape parameter <code class="reqn">\xi</code> that is outside
(<code>min_xi</code>, <code>max_xi</code>).  This will override the default values
of <code>min_xi</code> and <code>max_xi</code> in the named priors detailed above.
</p>
<p><strong>Extreme value priors.</strong> It is typical to use either
<code>prior = "prob"</code> (<code><a href="#topic+gev_prob">gev_prob</a></code>) or
<code>prior = "quant"</code> (<code><a href="#topic+gev_quant">gev_quant</a></code>) to set an informative
prior and one of the other prior (or a user-supplied function) otherwise.
The names of the in-built extreme value priors set using <code>prior</code>
and details of hyperparameters are:
</p>

<ul>
<li> <p><code>"prob"</code>.  A prior for GEV parameters <code class="reqn">(\mu, \sigma, \xi)</code>
based on Crowder (1992).  See <code><a href="#topic+gev_prob">gev_prob</a></code> for details.
See also Northrop et al. (2017) and Stephenson (2016).
</p>
</li>
<li> <p><code>"quant"</code>.  A prior for GEV parameters <code class="reqn">(\mu, \sigma, \xi)</code>
based on Coles and Tawn (1996). See <code><a href="#topic+gev_quant">gev_quant</a></code> for details.
</p>
</li>
<li> <p><code>"norm"</code>.
</p>
<p>For <code>model = "gp"</code>:
(<code class="reqn">\log \sigma, \xi</code>), is bivariate normal
with mean <code>mean</code> (a numeric vector of length 2) and covariance
matrix <code>cov</code> (a symmetric positive definite 2 by 2 matrix).
</p>
<p>For <code>model = "gev"</code>:
(<code class="reqn">\mu, \log \sigma, \xi</code>), is trivariate
normal with mean <code>mean</code> (a numeric vector of length 3) and
covariance matrix <code>cov</code> (a symmetric positive definite 3 by 3
matrix).
</p>
</li>
<li> <p><code>"loglognorm"</code>.  For <code>model = "gev"</code> only:
(<code class="reqn">\log \mu, \log \sigma, \xi</code>), is
trivariate normal with mean <code>mean</code> (a numeric vector of length 3)
and covariance matrix <code>cov</code> (a symmetric positive definite 3 by 3
matrix).
</p>
</li>
<li> <p><code>"mdi"</code>.
</p>
<p>For <code>model = "gp"</code>: (an extended version
of) the maximal data information (MDI) prior, that is,
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma, \xi) = \sigma^{-1} \exp[-a(\xi + 1)], {\rm ~for~}
    \sigma &gt; 0, \xi \geq -1, a \geq 0.</code>
</p>

<p>The value of <code class="reqn">a</code> is set using the argument <code>a</code>.  The default
value is <code class="reqn">a = 1</code>, which gives the MDI prior.
</p>
<p>For <code>model = "gev"</code>: (an extended version
of) the maximal data information (MDI) prior, that is,
</p>
<p style="text-align: center;"><code class="reqn">\pi(\mu, \sigma, \xi) = \sigma^{-1} \exp[-a(\xi + 1)],
    {\rm ~for~} \sigma &gt; 0, \xi \geq -1, a \geq 0.</code>
</p>

<p>The value of <code class="reqn">a</code> is set using the argument <code>a</code>.  The default
value is <code class="reqn">a = \gamma</code>, where <code class="reqn">\gamma = 0.57721</code> is Euler's
constant, which gives the MDI prior.
</p>
<p>For each of these cases <code class="reqn">\xi</code> must be is bounded below
<em>a priori</em> for the posterior to be proper
(Northrop and Attalides, 2016).  An argument for the
bound <code class="reqn">\xi \geq -1</code> is that for <code class="reqn">\xi &lt; -1</code> the
GP (GEV) likelihood is unbounded above as <code class="reqn">-\sigma/\xi</code>
(<code class="reqn">\mu - \sigma/\xi</code>)) approaches the sample maximum.  In
maximum likelihood estimation of GP parameters (Grimshaw, 1993)
and GEV parameters a local maximum of the likelihood
is sought on the region
<code class="reqn">\sigma &gt; 0, \xi \geq -1</code>.
</p>
</li>
<li><p><code>"flat"</code>.
</p>
<p>For <code>model = "gp"</code>: a flat prior for
<code class="reqn">\xi</code> (and for <code class="reqn">\log \sigma</code>):
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma, \xi) = \sigma^{-1}, {\rm ~for~} \sigma &gt; 0.</code>
</p>

<p>For <code>model = "gev"</code>: a flat prior for
<code class="reqn">\xi</code> (and for <code class="reqn">\mu</code> and <code class="reqn">\log \sigma</code>):
</p>
<p style="text-align: center;"><code class="reqn">\pi(\mu, \sigma, \xi) = \sigma^{-1}, {\rm ~for~} \sigma &gt; 0.</code>
</p>

</li>
<li> <p><code>"flatflat"</code>.
</p>
<p>For <code>model = "gp"</code>: flat priors for
<code class="reqn">\sigma</code> and <code class="reqn">\xi</code>:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma, \xi) = 1, {\rm ~for~} \sigma &gt; 0.</code>
</p>

<p>For <code>model = "gev"</code>: flat priors for <code class="reqn">\mu</code>, <code class="reqn">\sigma</code>
and <code class="reqn">\xi</code>:
</p>
<p style="text-align: center;"><code class="reqn">\pi(\mu, \sigma, \xi) = 1, {\rm ~for~} \sigma &gt; 0.</code>
</p>

<p>Therefore, the posterior is proportional to the likelihood.
</p>
</li>
<li> <p><code>"jeffreys"</code>.  For <code>model = "gp"</code> only: the Jeffreys
prior (Castellanos and Cabras, 2007):
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma, \xi) = \sigma^{-1}(1+\xi)^{-1}(1+2\xi)^{-1/2},
      {\rm ~for~} \sigma &gt; 0, \xi &gt; -1 / 2.</code>
</p>

<p>In the GEV case the Jeffreys prior doesn't yield a proper posterior
for any sample size.  See Northrop and Attalides (2016) for details.
</p>
</li>
<li> <p><code>"beta"</code>.
For <code>model = "gp"</code>: a beta-type(p, q)
prior is used for xi on the interval (<code>min_xi</code>, <code>max_xi</code>):
</p>
<p style="text-align: center;"><code class="reqn">\pi(\sigma, \xi) = \sigma^{-1} (\xi - {\min}_{\xi}) ^ {p-1}
          ({\max}_{\xi} - \xi) ^ {q-1}, {\rm ~for~}
          {\min}_{\xi} &lt; \xi &lt; {\max}_{\xi}.</code>
</p>

<p>For <code>model = "gev"</code>: similarly ...
</p>
<p style="text-align: center;"><code class="reqn">\pi(\mu, \sigma, \xi) = \sigma^{-1} (\xi - {\min}_{\xi}) ^ {p-1}
          ({\max}_{\xi} - \xi) ^ {q-1}, {\rm ~for~}
          {\min}_{\xi} &lt; \xi &lt; {\max}_{\xi}.</code>
</p>

<p>The argument <code>pq</code> is a vector containing <code>c(p,q)</code>.
The default settings for this prior are <code>p = 6, q = 9</code> and
<code>min_xi = -1/2, max_xi = 1/2</code>, which corresponds to the
prior for <code class="reqn">\xi</code> proposed in Martins and Stedinger (2000, 2001).
</p>
</li></ul>



<h3>Value</h3>

<p>A list with class <code>"evprior"</code>.  The first component is the
input prior, i.e. either the name of the prior or a user-supplied
function.  The remaining components contain the numeric values of any
hyperparameters in the prior.
</p>


<h3>References</h3>

<p>Castellanos, E. M. and Cabras, S. (2007) A default Bayesian
procedure for the generalized Pareto distribution.
<em>Journal of Statistical Planning and Inference</em> <strong>137(2)</strong>,
473-483. <a href="https://doi.org/10.1016/j.jspi.2006.01.006">doi:10.1016/j.jspi.2006.01.006</a>.
</p>
<p>Coles, S. G. and Tawn, J. A. (1996) A Bayesian analysis of
extreme rainfall data. <em>Appl. Statist.</em>, <strong>45</strong>, 463-478.
</p>
<p>Crowder, M. (1992) Bayesian priors based on parameter
transformation using the distribution function
<em>Ann. Inst. Statist. Math.</em>, <strong>44</strong>, 405-416.
<a href="https://link.springer.com/article/10.1007/BF00050695">https://link.springer.com/article/10.1007/BF00050695</a>.
</p>
<p>Grimshaw, S. D. (1993) Computing Maximum Likelihood Estimates
for the Generalized Pareto Distribution.  <em>Technometrics</em>,
<strong>35(2)</strong>, 185-191.
<a href="https://doi.org/10.1080/00401706.1993.10485040">doi:10.1080/00401706.1993.10485040</a>.
</p>
<p>Hosking, J. R. M. and Wallis, J. R. (1987) Parameter and
Quantile Estimation for the Generalized Pareto Distribution.
<em>Technometrics</em>, <strong>29(3)</strong>, 339-349.
<a href="https://doi.org/10.2307/1269343">doi:10.2307/1269343</a>.
</p>
<p>Martins, E. S. and Stedinger, J. R. (2000) Generalized maximum
likelihood generalized extreme value quantile estimators for hydrologic
data, <em>Water Resources Research</em>, <strong>36(3)</strong>, 737-744.
<a href="https://doi.org/10.1029/1999WR900330">doi:10.1029/1999WR900330</a>.
</p>
<p>Martins, E. S. and Stedinger, J. R. (2001) Generalized maximum
likelihood Pareto-Poisson estimators for partial duration series,
<em>Water Resources Research</em>, <strong>37(10)</strong>, 2551-2557.
<a href="https://doi.org/10.1029/2001WR000367">doi:10.1029/2001WR000367</a>.
</p>
<p>Northrop, P.J. and Attalides, N. (2016) Posterior propriety in
Bayesian extreme value analyses using reference priors
<em>Statistica Sinica</em>, <strong>26</strong>(2), 721&ndash;743
<a href="https://doi.org/10.5705/ss.2014.034">doi:10.5705/ss.2014.034</a>.
</p>
<p>Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
Cross-validatory extreme value threshold selection and uncertainty
with application to ocean storm severity.
<em>Journal of the Royal Statistical Society Series C: Applied
Statistics</em>, <strong>66</strong>(1), 93-120.
<a href="https://doi.org/10.1111/rssc.12159">doi:10.1111/rssc.12159</a>
</p>
<p>Stephenson, A. (2016) Bayesian inference for extreme value
modelling.  In <em>Extreme Value Modeling and Risk Analysis: Methods
and Applications</em> (eds D. K. Dey and J. Yan), 257-280, Chapman and Hall,
London. <a href="https://doi.org/10.1201/b19721">doi:10.1201/b19721</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpost">rpost</a></code> and <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code> for sampling
from an extreme value posterior distribution.
</p>
<p><code><a href="#topic+create_prior_xptr">create_prior_xptr</a></code> for creating an external
pointer to a C++ function to evaluate the log-prior density.
</p>
<p><code><a href="#topic+rprior_prob">rprior_prob</a></code> and <code><a href="#topic+rprior_quant">rprior_quant</a></code> for
sampling from informative prior distributions for GEV parameters.
</p>
<p><code><a href="#topic+gp_norm">gp_norm</a></code>, <code><a href="#topic+gp_mdi">gp_mdi</a></code>,
<code><a href="#topic+gp_flat">gp_flat</a></code>, <code><a href="#topic+gp_flatflat">gp_flatflat</a></code>,
<code><a href="#topic+gp_jeffreys">gp_jeffreys</a></code>, <code><a href="#topic+gp_beta">gp_beta</a></code> to see the arguments
for priors for GP parameters.
</p>
<p><code><a href="#topic+gev_norm">gev_norm</a></code>, <code><a href="#topic+gev_loglognorm">gev_loglognorm</a></code>,
<code><a href="#topic+gev_mdi">gev_mdi</a></code>, <code><a href="#topic+gev_flat">gev_flat</a></code>, <code><a href="#topic+gev_flatflat">gev_flatflat</a></code>,
<code><a href="#topic+gev_beta">gev_beta</a></code>, <code><a href="#topic+gev_prob">gev_prob</a></code>, <code><a href="#topic+gev_quant">gev_quant</a></code>
to see the arguments for priors for GEV parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal prior for GEV parameters (mu, log(sigma), xi).
mat &lt;- diag(c(10000, 10000, 100))
pn &lt;- set_prior(prior = "norm", model = "gev", mean = c(0,0,0), cov = mat)
pn

# Prior for GP parameters with flat prior for xi on (-1, infinity).
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
fp

# A user-defined prior (see the vignette for details).
u_prior_fn &lt;- function(x, ab) {
  if (x[1] &lt;= 0 | x[2] &lt;= -1 | x[2] &gt;= 1) {
    return(-Inf)
  }
  return(-log(x[1]) + (ab[1] - 1) * log(1 + x[2]) +
         (ab[2] - 1) * log(1 - x[2]))
}
up &lt;- set_prior(prior = u_prior_fn, ab = c(2, 2), model = "gp")

# A user-defined prior using a pointer to a C++ function
ptr_gp_flat &lt;- create_prior_xptr("gp_flat")
u_prior_ptr &lt;- set_prior(prior = ptr_gp_flat, model = "gp")
</code></pre>

<hr>
<h2 id='summary.evpost'>Summarizing an evpost object</h2><span id='topic+summary.evpost'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;evpost&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'evpost'
summary(object, add_pu = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.evpost_+3A_object">object</code></td>
<td>
<p>An object of class &quot;evpost&quot;, a result of a call to
<code><a href="#topic+rpost">rpost</a></code> or <code><a href="#topic+rpost_rcpp">rpost_rcpp</a></code>.</p>
</td></tr>
<tr><td><code id="summary.evpost_+3A_add_pu">add_pu</code></td>
<td>
<p>Includes in the summary of the simulated values the threshold
exceedance probability <code class="reqn">p</code>. Only relevant when <code>model == "bingp"</code>
was used in the call to <code>rpost</code> or <code>rpost_rcpp</code>.</p>
</td></tr>
<tr><td><code id="summary.evpost_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>print</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints
</p>

<ul>
<li><p> information about the ratio-of-uniforms bounding box, i.e.
<code>object$box</code>
</p>
</li>
<li><p> an estimate of the probability of acceptance, i.e.
<code>object$pa</code>
</p>
</li>
<li><p> a summary of the simulated values, via
<code>summary(object$sim_vals)</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="rust.html#topic+ru">ru</a></code> or <code><a href="rust.html#topic+ru_rcpp">ru_rcpp</a></code> for
descriptions of <code>object$sim_vals</code> and <code>object$box</code>.
</p>
<p><code><a href="#topic+plot.evpost">plot.evpost</a></code> for a diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GP posterior
u &lt;- stats::quantile(gom, probs = 0.65)
fp &lt;- set_prior(prior = "flat", model = "gp", min_xi = -1)
gpg &lt;- rpost_rcpp(n = 1000, model = "gp", prior = fp, thresh = u,
                  data = gom)
summary(gpg)
</code></pre>

<hr>
<h2 id='venice'>Largest Sea Levels in Venice</h2><span id='topic+venice'></span>

<h3>Description</h3>

<p>The <code>venice</code> data frame has 51 rows and 10 columns. The jth column
contains the jth largest sea levels in Venice, for the years 1931-1981. Only
the largest six measurements are available for the year 1935; the
corresponding row contains four missing values. The years for each set of
measurements are given as row names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>venice
</code></pre>


<h3>Format</h3>

<p>A data frame with 51 rows and 10 columns.
</p>


<h3>Source</h3>

<p>Smith, R. L. (1986) Extreme value theory based on the <em>r</em>
largest annual events. <em>Journal of Hydrology</em>, <strong>86</strong>, 27-43.
<a href="https://doi.org/10.1016/0022-1694%2886%2990004-1">doi:10.1016/0022-1694(86)90004-1</a>
</p>


<h3>References</h3>

<p>Coles, S. G. (2001) <em>An Introduction to Statistical
Modelling of Extreme Values</em>. London: Springer.
<a href="https://doi.org/10.1007/978-1-4471-3675-0">doi:10.1007/978-1-4471-3675-0</a>
</p>

<hr>
<h2 id='wbinpost'>Random sampling from a binomial posterior distribution, using weights</h2><span id='topic+wbinpost'></span>

<h3>Description</h3>

<p>Samples from the posterior distribution of the probability <code class="reqn">p</code>
of a binomial distribution.  User-supplied weights are applied to each
observation when constructing the log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbinpost(n, prior, ds_bin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wbinpost_+3A_n">n</code></td>
<td>
<p>A numeric scalar. The size of posterior sample required.</p>
</td></tr>
<tr><td><code id="wbinpost_+3A_prior">prior</code></td>
<td>
<p>A function to evaluate the prior, created by
<code><a href="#topic+set_bin_prior">set_bin_prior</a></code>.
<code>prior$prior</code> must be <code>"bin_beta"</code>.</p>
</td></tr>
<tr><td><code id="wbinpost_+3A_ds_bin">ds_bin</code></td>
<td>
<p>A numeric list.  Sufficient statistics for inference
about the binomial probability <code class="reqn">p</code>.  Contains
</p>

<ul>
<li> <p><code>sf</code> : a logical vector of success (<code>TRUE</code>) and failure
(<code>FALSE</code>) indicators.
</p>
</li>
<li> <p><code>w</code> : a numeric vector of length <code>length(sf)</code> containing
the values by which to multiply the observations when constructing the
log-likelihood.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>prior$prior == "bin_beta"</code> the posterior for <code class="reqn">p</code>
is a beta distribution so <code><a href="stats.html#topic+Beta">rbeta</a></code> is used to
sample from the posterior.
</p>


<h3>Value</h3>

<p>An object (list) of class <code>"binpost"</code> with components
</p>
<table>
<tr><td><code>bin_sim_vals:</code></td>
<td>
<p>An <code>n</code> by 1 numeric matrix of values
simulated from the posterior for the binomial
probability <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>bin_logf:</code></td>
<td>
<p>A function returning the log-posterior for
<code class="reqn">p</code>.</p>
</td></tr>
<tr><td><code>bin_logf_args:</code></td>
<td>
<p>A list of arguments to <code>bin_logf</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+set_bin_prior">set_bin_prior</a></code> for setting a prior distribution
for the binomial probability <code class="reqn">p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- quantile(gom, probs = 0.65)
ds_bin &lt;- list(sf = gom &gt; u, w = rep(1, length(gom)))
bp &lt;- set_bin_prior(prior = "jeffreys")
temp &lt;- wbinpost(n = 1000, prior = bp, ds_bin = ds_bin)
graphics::hist(temp$bin_sim_vals, prob = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
