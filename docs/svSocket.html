<!DOCTYPE html><html><head><title>Help for package svSocket</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {svSocket}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#close_socket_clients'><p>Close one or more clients currently connected</p></a></li>
<li><a href='#eval_socket_server'><p>Evaluate R code in a server process</p></a></li>
<li><a href='#get_socket_clients'><p>Get infos about socket clients</p></a></li>
<li><a href='#get_socket_server_name'><p>Get the name of a R socket server</p></a></li>
<li><a href='#get_socket_servers'><p>Get the ports of current R socket servers</p></a></li>
<li><a href='#par_socket_server'><p>Get or set parameters specific to SciViews socket clients</p></a></li>
<li><a href='#process_socket_server'><p>The function that processes a command coming from the socket</p></a></li>
<li><a href='#send_socket_clients'><p>Send data to one or more clients through a socket</p></a></li>
<li><a href='#socket_client_connection'><p>Open a connection to a SciViews socket client for write access</p></a></li>
<li><a href='#start_socket_server'><p>Start and stop a R socket server</p></a></li>
<li><a href='#svSocket-package'><p>svSocket: 'SciViews' - Socket Server</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-29</td>
</tr>
<tr>
<td>Title:</td>
<td>'SciViews' - Socket Server</td>
</tr>
<tr>
<td>Description:</td>
<td>A socket server allows to connect clients to R.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philippe Grosjean &lt;phgrosjean@sciviews.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tcltk, svMisc (&ge; 0.9-68), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>svHttp, spelling, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SciViews/svSocket">https://github.com/SciViews/svSocket</a>,
<a href="https://www.sciviews.org/svSocket/">https://www.sciviews.org/svSocket/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SciViews/svSocket/issues">https://github.com/SciViews/svSocket/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 14:12:18 UTC; phgrosjean</td>
</tr>
<tr>
<td>Author:</td>
<td>Philippe Grosjean <a href="https://orcid.org/0000-0002-2694-9471"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Matthew Dowle [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='close_socket_clients'>Close one or more clients currently connected</h2><span id='topic+close_socket_clients'></span><span id='topic+closeSocketClients'></span>

<h3>Description</h3>

<p>The socket servers asks to clients to nicely disconnect (possibly doing
further process on their side). This function is used by
<code><a href="#topic+stop_socket_server">stop_socket_server()</a></code>, but it can also be invoked manually to ask for
disconnection of a particular client. Note that, in this case, the client
still can decide not to disconnect! The code send to ask for client
disconnection is: <code style="white-space: pre;">&#8288;\\f&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_socket_clients(sockets = "all", server_port = 8888)

closeSocketClients(sockets = "all", server_port = 8888)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close_socket_clients_+3A_sockets">sockets</code></td>
<td>
<p>the list of socket client names (sockXXX) to close, or <code>"all"</code>
(by default) to disconnect all currently connected clients.</p>
</td></tr>
<tr><td><code id="close_socket_clients_+3A_server_port">server_port</code></td>
<td>
<p>the corresponding R socket server port.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+send_socket_clients">send_socket_clients()</a></code>
</p>

<hr>
<h2 id='eval_socket_server'>Evaluate R code in a server process</h2><span id='topic+eval_socket_server'></span><span id='topic+evalServer'></span>

<h3>Description</h3>

<p>This function is designed to connect two R processes together using the
socket server. It allows for piloting the server R process from a client R
process, to evaluate R code in the server and return its results to the
client.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_socket_server(con, expr, send = NULL)

evalServer(con, expr, send = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_socket_server_+3A_con">con</code></td>
<td>
<p>a socket connection with the server (see examples).</p>
</td></tr>
<tr><td><code id="eval_socket_server_+3A_expr">expr</code></td>
<td>
<p>an R expression to evaluate in the server.</p>
</td></tr>
<tr><td><code id="eval_socket_server_+3A_send">send</code></td>
<td>
<p>optional data to send to the server.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function serializes R objects using <code><a href="base.html#topic+dump">dump()</a></code> on the server, and it
<code><a href="base.html#topic+source">source()</a></code>s the data on the client side. It has, thus, the same limitations
as <code><a href="base.html#topic+dump">dump()</a></code>, (see <code>?dump</code>), and in particular, environments, external
pointers, weak references and objects of type <code>S4</code> are not serializable with
<code><a href="base.html#topic+dump">dump()</a></code> and will raise an error, or will produce unusable objects on the
client side. Note also that lists or attributes of accepted objects may
contain external pointers or environments, and thus, the whole object becomes
unserializable. In that case, try to coerce your object, or extract a part of
it on the server side to make sure you send just the part that is
transferable between the two R processes.
</p>


<h3>Value</h3>

<p>The object returned by the last evaluation in the server.
</p>


<h3>Author(s)</h3>

<p>Matthew Dowle
</p>


<h3>See Also</h3>

<p><code><a href="#topic+send_socket_clients">send_socket_clients()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Start an R process and make it a server
library(svSocket)
start_socket_server()

# Start a second R process and run this code in it (the R client):
library(svSocket)

# Connect with the R socket server
con &lt;- socketConnection(host = "localhost", port = 8888, blocking = FALSE)

L &lt;- 10:20
L
eval_socket_server(con, L)             # L is not an the server, hence the error
eval_socket_server(con, L, L)          # Send it to the server
eval_socket_server(con, L)             # Now it is there
eval_socket_server(con, L, L + 2)
L
eval_socket_server(con, L)

# More examples
eval_socket_server(con, "x &lt;- 42")     # Set x
eval_socket_server(con, "y &lt;- 10")     # Set y
eval_socket_server(con, x + y)         # Quotes not needed
eval_socket_server(con, "x + y")       # but you can put quotes if you like
eval_socket_server(con, x)             # Same as get x
eval_socket_server(con, "x + Y")       # Return server side-error to the client
eval_socket_server(con, x)             # Keep working after an error
eval_socket_server(con, "x &lt;- 'a'")    # Embedded quotes are OK

# Examples of sending data
eval_socket_server(con, X, -42)        # Alternative way to assign to X
eval_socket_server(con, Y, 1:10)
eval_socket_server(con, X + Y)
X  # Generates an error, X is not here in the client, only on the server
eval_socket_server(con, X)
eval_socket_server(con, "Z &lt;- X + 3")  # Send an assignment to execute remotely
eval_socket_server(con, X + Z)
eval_socket_server(con, "Z &lt;- X + 1:1000; NULL")   # Same but do not return Z
eval_socket_server(con, length(Z))
Z &lt;- eval_socket_server(con, Z)        # Bring it back to client
Z

# Close connection with the R socket server
close(con)

# Now, switch back to the R server process and check
# that the created variables are there
L
x
y
X
Y
Z

# Stop the socket server
stop_socket_server()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_socket_clients'>Get infos about socket clients</h2><span id='topic+get_socket_clients'></span><span id='topic+getSocketClients'></span><span id='topic+get_socket_clients_names'></span><span id='topic+getSocketClientsNames'></span><span id='topic+getSocketServerName'></span>

<h3>Description</h3>

<p>List all clients currently connected to a given R socket server, or their
names (<code>sockXXX</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_socket_clients(port = 8888)

getSocketClients(port = 8888)

get_socket_clients_names(port = 8888)

getSocketClientsNames(port = 8888)

getSocketServerName(port = 8888)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_socket_clients_+3A_port">port</code></td>
<td>
<p>the port of the R socket server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+get_socket_clients">get_socket_clients()</a></code> returns a vector of character string with the address of
clients in the form XXX.XXX.XXX.XXX:YYY where XXX.XXX.XXX.XXX is their ip
address and YYY is their port. For security reasons, only localhost clients
(on the same machine) can connect to the socket server. Thus, XXX.XXX.XXX.XXX
is ALWAYS 127.0.0.1. However, the function returns the full IP address, just
in case of further extensions in the future. The name of these items equals
the corresponding Tcl socket name.
</p>
<p><code><a href="#topic+get_socket_clients_names">get_socket_clients_names()</a></code> returns only a list of the socket client names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_socket_servers">get_socket_servers()</a></code>
</p>

<hr>
<h2 id='get_socket_server_name'>Get the name of a R socket server</h2><span id='topic+get_socket_server_name'></span>

<h3>Description</h3>

<p>Get the internal name given to a particular R socket server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_socket_server_name(port = 8888)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_socket_server_name_+3A_port">port</code></td>
<td>
<p>the port of the R socket server.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the server name, or <code>NULL</code> if it does not exist.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_socket_servers">get_socket_servers()</a></code>
</p>

<hr>
<h2 id='get_socket_servers'>Get the ports of current R socket servers</h2><span id='topic+get_socket_servers'></span><span id='topic+getSocketServers'></span>

<h3>Description</h3>

<p>Returns a list with all the ports of currently running R socket servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_socket_servers()

getSocketServers()
</code></pre>


<h3>Value</h3>

<p>A character string vector, or <code>NULL</code> if no R socket server is currently
running.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_socket_clients">get_socket_clients()</a></code>, <code><a href="#topic+get_socket_server_name">get_socket_server_name()</a></code>, <a href="#topic+start_socket_server">start_socket_server</a>
</p>

<hr>
<h2 id='par_socket_server'>Get or set parameters specific to SciViews socket clients</h2><span id='topic+par_socket_server'></span><span id='topic+parSocket'></span>

<h3>Description</h3>

<p>This function manage to persistently store sensible parameters for
configuring communication between the server and the client, as well as, any
other persistent data you may need. Parameters remain set even if the client
disconnects and then reconnects to R, as long R was not restarted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_socket_server(client, server_port = 8888, client_socket = client, ...)

parSocket(client, server_port = 8888, client_socket = client, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_socket_server_+3A_client">client</code></td>
<td>
<p>the client identification. By default, it is the socket
identifier as it appears in <code><a href="#topic+get_socket_clients">get_socket_clients()</a></code>. Since no attempt is made
to check if the client really exists and is connected, you can create fake
ones, outside of the socket server, to test your code for instance.</p>
</td></tr>
<tr><td><code id="par_socket_server_+3A_server_port">server_port</code></td>
<td>
<p>the port on which the server is running, 8888 by default.
Not important for fake socket client configurations.</p>
</td></tr>
<tr><td><code id="par_socket_server_+3A_client_socket">client_socket</code></td>
<td>
<p>the Tcl name of the socket where the client is connected.
By default, it is the same as <code>client</code> name, but in case it was modified, do
provide a correct <code>client_socket</code> string if you want to be able to activate a
redirection to it (see <code><a href="#topic+socket_client_connection">socket_client_connection()</a></code>).</p>
</td></tr>
<tr><td><code id="par_socket_server_+3A_...">...</code></td>
<td>
<p>the parameters you want to change as named arguments. Non named
arguments are ignored with a warning. If you specify <code>arg = NULL</code>, the
corresponding variable is deleted from the environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can assign the environment to a variable, and then, access its content
like if it was a list (<code>e$var</code> or <code>e$var &lt;- "new value"</code>). To get a list of
the content, use <code>ls(par_socket_server(client, port))</code>, or
<code>ls(par_socket_server(client, port), all.names = TRUE)</code>, but not
<code>names(par_socket_server(client, port))</code>. As long as you keep a variable
pointing on that environment alive, you have access to last values (i.e.,
changes done elsewhere are taken into account). If you want a frozen snapshot
of the parameters, you should use
<code style="white-space: pre;">&#8288;myvar &lt;- as.list(par_socket_server(client, port)&#8288;</code>.
</p>
<p>There is a convenient placeholder for code send by the client to insert
automatically the right socket and server_port in
<code>par_socket_server()</code>: <code style="white-space: pre;">&#8288;&lt;&lt;&lt;s&gt;&gt;&gt;&#8288;</code>.
Hence, code that the client send to access or change its environment is just
<code style="white-space: pre;">&#8288;par_socket_server(&lt;&lt;&lt;s&gt;&gt;&gt;, bare = FALSE)&#8288;</code> or
<code style="white-space: pre;">&#8288;par_socket_server(&lt;&lt;&lt;s&gt;&gt;&gt;)$bare&#8288;</code> to set or get one parameter. Note that you
can set or change many parameters at once.
</p>
<p>Currently, parameters are:
</p>

<ul>
<li> <p><code>bare = TRUE|FALSE</code> for &quot;bare&quot; mode (no prompt, no echo, no multiline; by
default, <code>bare = TRUE</code>),
</p>
</li>
<li> <p><code>multiline = TRUE|FALSE</code>: does the server accept code spread on multiple
lines and send in several steps (by default, yes, but works only if
<code>bare = FALSE</code>.
</p>
</li>
<li> <p><code>echo = TRUE|FALSE</code> is the command echoed to the regular R console (by
default <code>echo = FALSE</code>).
</p>
</li>
<li> <p><code>last = ""</code> string to append to each output (for instance to indicate that
processing is done),
</p>
</li>
<li> <p><code>prompt = "&gt; "</code>, the prompt to use (if not in bare mode) and
</p>
</li>
<li> <p><code>continue = "+ "</code> the continuation prompt to use, when multiline mode is
active. You can only cancel a multiline mode by completing the R code you are
sending to the server, but you can break it too by sending <code style="white-space: pre;">&#8288;&lt;&lt;&lt;esc&gt;&gt;&gt;&#8288;</code> before
the next instruction. You can indicate <code style="white-space: pre;">&#8288;&lt;&lt;&lt;q&gt;&gt;&gt;&#8288;</code> or <code style="white-space: pre;">&#8288;&lt;&lt;&lt;Q&gt;&gt;&gt;&#8288;</code> at the very
beginning of an instruction to tell R to disconnect the connection after the
command is processed and result is returned (with <code style="white-space: pre;">&#8288;&lt;&lt;&lt;q&gt;&gt;&gt;&#8288;</code>), or when the
instructions are received but before they are processed (with <code style="white-space: pre;">&#8288;&lt;&lt;&lt;Q&gt;&gt;&gt;&#8288;</code>).
This is useful for &quot;one shot&quot; clients (clients that connect, send code and
want to disconnect immediately after that). The code send by the server to
the client to tell him to disconnect gracefully (and do some housekeeping) is
<code style="white-space: pre;">&#8288;\\f&#8288;</code> send at the beginning of one line. So, clients should detect this and
perform the necessary actions to gracefully disconnect from the server as
soon as possible, and he cannot send further instructions from this moment
on.
</p>
</li></ul>

<p>For clients that repeatedly connect and disconnect, but want persistent data,
the default client identifier (the socket name) cannot be used, because that
socket name would change from connection to connection. The client must then
provide its own identifier. This is done by sending <code style="white-space: pre;">&#8288;&lt;&lt;&lt;id=myID&gt;&gt;&gt;&#8288;</code> at the
very beginning of a command. This must be done for all commands! <code>myID</code> must
use only characters or digits. This code could be followed by <code style="white-space: pre;">&#8288;&lt;&lt;&lt;e&gt;&gt;&gt;&#8288;</code>,
<code style="white-space: pre;">&#8288;&lt;&lt;&lt;h&gt;&gt;&gt;&#8288;</code> or <code style="white-space: pre;">&#8288;&lt;&lt;&lt;H&gt;&gt;&gt;&#8288;</code>. These commands are intended for R editors/IDE. The
first code <code style="white-space: pre;">&#8288;&lt;&lt;&lt;e&gt;&gt;&gt;&#8288;</code> sets the server into a mode that is suitable to
evaluate R code (including in a multi-line way). The other code temporarily
configure the server to run the command (in single line mode only) in a
hidden way. They can be used to execute R code without displaying it in the
console (for instance, to start context help, to get a calltip, or a
completion list, etc.). The differences between <code style="white-space: pre;">&#8288;&lt;&lt;&lt;h&gt;&gt;&gt;&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;&lt;&lt;H&gt;&gt;&gt;&#8288;</code> is
that the former waits for command completion and returns results of the
command to the client before disconnecting, while the latter disconnects from
the client before executing the command.
</p>
<p>There is a simple client (written in Tcl) available in the /etc subdirectory
of this package installation. Please, read the 'ReadMe.txt' file in the same
directory to learn how to use it. You can use this simple client to
experiment with the communication using these sockets, but it does not
provide advanced command line edition, no command history, and avoid pasting
more than one line of code into it.
</p>


<h3>Value</h3>

<p>Returns the environment where parameters and data for the client are stored.
To access those data, see examples below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_socket_server">start_socket_server()</a></code>, <code><a href="#topic+send_socket_clients">send_socket_clients()</a></code>, <code><a href="#topic+get_socket_clients">get_socket_clients()</a></code>,
<code><a href="#topic+socket_client_connection">socket_client_connection()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We use a fake socket client configuration environment
e &lt;- par_socket_server("fake")
# Look at what it contains
ls(e)
# Get one data
e$bare
# ... or
par_socket_server("fake")$bare

# Change it
par_socket_server("fake", bare = FALSE)$bare
# Note it is changed too for e
e$bare

# You can change it too with
e$bare &lt;- TRUE
e$bare
par_socket_server("fake")$bare

# Create a new entry
e$foo &lt;- "test"
ls(e)
par_socket_server("fake")$foo
# Now delete it
par_socket_server("fake", foo = NULL)
ls(e)

# Our fake socket config is in SciViews:TempEnv environment
s &lt;- search()
l &lt;- length(s)
pos &lt;- (1:l)[s == "SciViews:TempEnv"]
ls(pos = pos)  # It is named 'socket_client_fake'
# Delete it
rm(socket_client_fake, pos = pos)
# Do some house keeping
rm(list = c("s", "l", "pos"))
</code></pre>

<hr>
<h2 id='process_socket_server'>The function that processes a command coming from the socket</h2><span id='topic+process_socket_server'></span><span id='topic+processSocket'></span>

<h3>Description</h3>

<p>This is the default R function called each time data is send by a client
through a socket. It is possible to customize this function and to use
customized versions for particular R socket servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_socket_server(msg, socket, server_port, ...)

processSocket(msg, socket, server_port, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_socket_server_+3A_msg">msg</code></td>
<td>
<p>the message send by the client, to be processed.</p>
</td></tr>
<tr><td><code id="process_socket_server_+3A_socket">socket</code></td>
<td>
<p>the client socket identifier, as in <code><a href="#topic+get_socket_clients">get_socket_clients()</a></code>.
This is passed by the calling function and can be used internally.</p>
</td></tr>
<tr><td><code id="process_socket_server_+3A_server_port">server_port</code></td>
<td>
<p>the port on which the server is running, this is passed by
the calling function and can be used internally.</p>
</td></tr>
<tr><td><code id="process_socket_server_+3A_...">...</code></td>
<td>
<p>anything you want to pass to <code><a href="#topic+process_socket_server">process_socket_server()</a></code>, but it
needs to rework <code><a href="#topic+start_socket_server">start_socket_server()</a></code> to use it).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are special code that one can send to R to easily turn the server
(possibly temporarily) into a given configuration. First, if you want to
persistently store parameters for your client in the R server and make sure
you retrieve the same parameters the next time you reconnect, you should
specify your own identifier. This is done by sending <code style="white-space: pre;">&#8288;&lt;&lt;&lt;id=myID&gt;&gt;&gt;&#8288;</code> at the
very beginning of each of your commands. Always remember that, if you do not
specify an identifier, the name of your socket will be used. Since socket
names can be reused, you should always reinitialize the configuration of your
server the first time you connect to it.
</p>
<p>Then, sending <code style="white-space: pre;">&#8288;&lt;&lt;&lt;esc&gt;&gt;&gt;&#8288;</code> breaks current multiline code submission and
flushes the multiline buffer.
</p>
<p>The sequence <code style="white-space: pre;">&#8288;&lt;&lt;&lt;q&gt;&gt;&gt;&#8288;</code> at the beginning of a command indicates that the
server wants to disconnect once the command is fully treated by R. Similarly,
the sequence <code style="white-space: pre;">&#8288;&lt;&lt;&lt;Q&gt;&gt;&gt;&#8288;</code> tells the server to disconnect the client before
processing the command (no error message is returned to the client!).
</p>
<p>It is easy to turn the server to evaluate R code (including multiline code)
and return the result and disconnect by using the <code style="white-space: pre;">&#8288;&lt;&lt;&lt;e&gt;&gt;&gt;&#8288;</code> sequence at the
beginning of a command. Using <code style="white-space: pre;">&#8288;&lt;&lt;&lt;h&gt;&gt;&gt;&#8288;</code> or <code style="white-space: pre;">&#8288;&lt;&lt;&lt;H&gt;&gt;&gt;&#8288;</code> configures that server
to process a (single-line code only) command silently and disconnect before
(uppercase H) or after (lowercase h) processing that command. It is the less
intrusive mode that is very useful for all commands that should be executed
behind the scene between R and a R editor or IDE, like contextual help,
calltips, completion lists, etc.). Note that using these modes in a server
that is, otherwise, configured as a multi-line server does not break current
multi-line buffer.
</p>
<p>The other sequences that can be used are: <code style="white-space: pre;">&#8288;&lt;&lt;&lt;s&gt;&gt;&gt;&#8288;</code> for a placeholder to
configure the current server (with configuration parameters after it), and
<code style="white-space: pre;">&#8288;&lt;&lt;&lt;n&gt;&gt;&gt;&#8288;</code> to indicate a newline in your code (submitting two lines of code
as a single one; also works with servers configured as single-line
evaluators).
</p>
<p>To debug the R socket server and inspect how commands send by a client are
interpreted by this function, use <code>options(debug.Socket = TRUE)</code>. This
function uses <code><a href="svMisc.html#topic+parse_text">svMisc::parse_text()</a></code> and <code><a href="svMisc.html#topic+capture_all">svMisc::capture_all()</a></code> in order to
evaluate R code in character string almost exactly the same way as if it was
typed at the command line of a R console.
</p>


<h3>Value</h3>

<p>The results of processing <code>msg</code> in a character string vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+start_socket_server">start_socket_server()</a></code>, <code><a href="#topic+send_socket_clients">send_socket_clients()</a></code>,
<code><a href="#topic+par_socket_server">par_socket_server()</a></code>, <code><a href="svMisc.html#topic+parse_text">svMisc::parse_text()</a></code>, <code><a href="svMisc.html#topic+capture_all">svMisc::capture_all()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A simple REPL (R eval/process loop) using basic features of processSocket()
repl &lt;- function() {
  pars &lt;- par_socket_server("repl", "", bare = FALSE)  # Parameterize the loop
  cat("Enter R code, hit &lt;CTRL-C&gt; or &lt;ESC&gt; to exit\n&gt; ")   # First prompt
  repeat {
    entry &lt;- readLines(n = 1) 				 # Read a line of entry
    if (entry == "") entry &lt;- "&lt;&lt;&lt;esc&gt;&gt;&gt;"    # Exit from multiline mode
    cat(process_socket_server(entry, "repl", ""))    # Process the entry
  }
}
repl()

## End(Not run)
</code></pre>

<hr>
<h2 id='send_socket_clients'>Send data to one or more clients through a socket</h2><span id='topic+send_socket_clients'></span><span id='topic+sendSocketClients'></span>

<h3>Description</h3>

<p>The text is send to one or more clients of the R socket server currently
connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>send_socket_clients(text, sockets = "all", server_port = 8888)

sendSocketClients(text, sockets = "all", server_port = 8888)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="send_socket_clients_+3A_text">text</code></td>
<td>
<p>the text to send to the client(s).</p>
</td></tr>
<tr><td><code id="send_socket_clients_+3A_sockets">sockets</code></td>
<td>
<p>the Tcl name of the client(s) socket(s) currently connected
(<code>sockXXX</code>), or <code>"all"</code> (by default) to send the same text to all connected
clients.</p>
</td></tr>
<tr><td><code id="send_socket_clients_+3A_server_port">server_port</code></td>
<td>
<p>the port of the server considered.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+close_socket_clients">close_socket_clients()</a></code>, <code><a href="#topic+process_socket_server">process_socket_server()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Start an R process (R#1) and make it a server
library(svSocket)
server_port &lt;- 8888  # Port 8888 by default, but you can change it
start_socket_server(port = server_port)


# Start a second R process (R#2) and run this code in it (the R client):
library(svSocket)
# Connect with the R socket server
con &lt;- socketConnection(host = "localhost", port = 8888, blocking = FALSE)


# Now, go back to the server R#1
get_socket_clients() # You should have one client registered
# Send something to all clients from R#1
send_socket_clients("Hi there!")


# Switch back to client R#2
# Since the connection is not blocking, you have to read lines actively
readLines(con)
# Note the final empty string indicating there is no more data
close(con) # Once done...


# Switch to the R#1 server and close the server
stop_socket_server(port = server_port)

## End(Not run)
</code></pre>

<hr>
<h2 id='socket_client_connection'>Open a connection to a SciViews socket client for write access</h2><span id='topic+socket_client_connection'></span><span id='topic+summary.sockclientconn'></span><span id='topic+socketClientConnection'></span>

<h3>Description</h3>

<p>A 'sockclientconn' object is created that opens a connection from R to a
SciViews socket client (that must be currently connected). A timeout is
defined by <code>options(timeout = XX)</code> where <code>XX</code> is a number of seconds. In R,
its default value is 60 sec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>socket_client_connection(
  client,
  server_port = 8888,
  socket,
  blocking = FALSE,
  open = "a",
  encoding = getOption("encoding")
)

## S3 method for class 'sockclientconn'
summary(object, ...)

socketClientConnection(
  client,
  server_port = 8888,
  socket,
  blocking = FALSE,
  open = "a",
  encoding = getOption("encoding")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="socket_client_connection_+3A_client">client</code></td>
<td>
<p>the client identification. By default, it is the socket
identifier as it appears in <code><a href="#topic+get_socket_clients">get_socket_clients()</a></code>. The client must be
currently connected.</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_server_port">server_port</code></td>
<td>
<p>the port on which the server is running, 8888 by default.
This server must be currently running.</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_socket">socket</code></td>
<td>
<p>the Tcl socket name where the targeted client is connected. If
not provided, it will be guessed from <code>client</code>, otherwise, <code>client</code> is
ignored.</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_blocking">blocking</code></td>
<td>
<p>logical. Should the connection wait that the data is written
before exiting?</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_open">open</code></td>
<td>
<p>character. How the connection is opened. Currently, only <code>"a"</code>
for append (default) or <code>"w"</code> for write access are usable.</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_encoding">encoding</code></td>
<td>
<p>the name of the encoding to use.</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_object">object</code></td>
<td>
<p>A 'sockclientconn' object as returned by
<code><a href="#topic+socket_client_connection">socket_client_connection()</a></code>.</p>
</td></tr>
<tr><td><code id="socket_client_connection_+3A_...">...</code></td>
<td>
<p>further arguments passed to the method (not used for the moment).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+socket_client_connection">socket_client_connection()</a></code> creates a 'sockclientconn' object redirects text
send to it to the SciViews socket server client. It is inherits from a
'sockconn' object (see <code>socketConnection()</code>), and the only difference is that
output is redirected to a Tcl socket corresponding to a given SciViews socket
client currently connected.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+socketConnection">socketConnection()</a></code>, <code><a href="#topic+send_socket_clients">send_socket_clients()</a></code>
</p>

<hr>
<h2 id='start_socket_server'>Start and stop a R socket server</h2><span id='topic+start_socket_server'></span><span id='topic+startSocketServer'></span><span id='topic+stop_socket_server'></span><span id='topic+stopSocketServer'></span>

<h3>Description</h3>

<p>A R socket server is listening for command send by clients to a TCP port.
This server is implemented in Tcl/Tk, using the powerful 'socket' command.
Since it runs in the separate tcltk event loop, it is not blocking R, and it
runs in the background; the user can still enter commands at the R prompt
while one or several R socket servers are running and even, possibly,
processing socket clients requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_socket_server(
  port = 8888,
  server_name = "Rserver",
  procfun = process_socket_server,
  secure = FALSE,
  local = !secure
)

startSocketServer(
  port = 8888,
  server_name = "Rserver",
  procfun = process_socket_server,
  secure = FALSE,
  local = !secure
)

stop_socket_server(port = 8888)

stopSocketServer(port = 8888)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_socket_server_+3A_port">port</code></td>
<td>
<p>the TCP port of the R socket server.</p>
</td></tr>
<tr><td><code id="start_socket_server_+3A_server_name">server_name</code></td>
<td>
<p>the internal name of this server.</p>
</td></tr>
<tr><td><code id="start_socket_server_+3A_procfun">procfun</code></td>
<td>
<p>the function to use to process client's commands. By default,
it is <code>process_socket_server()</code>.</p>
</td></tr>
<tr><td><code id="start_socket_server_+3A_secure">secure</code></td>
<td>
<p>do we start a secure (TLS) server? (not implemented yet)</p>
</td></tr>
<tr><td><code id="start_socket_server_+3A_local">local</code></td>
<td>
<p>if <code>TRUE</code>, accept only connections from local clients, i.e.,
from clients with IP address 127.0.0.1. Set by default if the server is not
secure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This server is currently synchronous in the processing of the command.
However, neither R, nor the client are blocked during exchange of data
(communication is asynchronous).
</p>
<p>Note also that socket numbers are reused, and corresponding configurations
are not deleted from one connection to the other. So, it is possible for a
client to connect/disconnect several times and continue to work with the same
configuration (in particular, the multiline code submitted line by line) if
every command starts with <code style="white-space: pre;">&#8288;&lt;&lt;&lt;id=myID&gt;&gt;&gt;&#8288;</code> where <code>myID</code> is an alphanumeric
(unique) identifier. This property is call a stateful server. Take care! The
R server never checks uniqueness of this identifier. You are responsible to
use one that would not interfere with other, concurrent, clients connected
to the same server.
</p>
<p>For trials and basic testings of the R socket server, you can use the Tcl
script <code>SimpleClient.Tcl</code>. See the <code>ReadMe.txt</code> file in the
/etc/ subdirectory of the svSocket package folder. Also, in the source of the
svSocket package you will find <code>testCLI.R</code>, a script to torture test CLI for
R (console).
</p>


<h3>Note</h3>

<p>Due to a change in R 4.3.x in its event loop, some Tcl socket events are not
processes and this prevents the R socket server to work properly. This is
corrected in R 4.4.0. The socket server also works well with R 4.0.x, R 4.1.x
and R 4.2.x.
</p>
<p>One can write a different <code>procfun()</code> function than the default one for
special servers. That function must accept one argument (a string with the
command send by the client) and it must return a character string containing
the result of the computation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+process_socket_server">process_socket_server()</a></code>, <code><a href="#topic+send_socket_clients">send_socket_clients()</a></code>
</p>

<hr>
<h2 id='svSocket-package'>svSocket: 'SciViews' - Socket Server</h2><span id='topic+svSocket'></span><span id='topic+svSocket-package'></span>

<h3>Description</h3>

<p>A socket server allows to connect clients to R.
</p>


<h3>Details</h3>

<p>The SciViews {svSocket} package provides a stateful, multi-client and
preemptive socket server. Socket transaction are operational even when R is
busy in its main event loop (calculation done at the prompt). This R socket
server uses the excellent asynchronous socket ports management by Tcl, and
thus, it needs a working version of Tcl/Tk (&gt;= 8.4) and of the {tcltk} R
package.
</p>
<p>A particular effort has been made to handle requests the same way as if they
where introduced at the command prompt, including presentation of the output.
However, the server sends results back to the client only at the end of the
computations. It means that any interaction during computation (for instance,
using <code><a href="base.html#topic+scan">scan()</a></code>, <code><a href="base.html#topic+browser">browser()</a></code>, or <code>par(ask = TRUE)</code> is not echoed in the client
on due time. If you parameterize the socket server to echo commands in the R
console, such interaction would be possible from there. Another option is to
run R in non-interactive mode.
</p>
<p>Although initially designed to server GUI clients, the R socket server can
also be used to exchange data between separate R processes. The
<code><a href="#topic+eval_socket_server">eval_socket_server()</a></code> function is particularly useful for this. Note,
however, that R objects are serialized into a text (i.e., using <code><a href="base.html#topic+dump">dump()</a></code>)
format, currently. It means that the transfer of large object is not as
efficient as, say {Rserver} ({Rserver} exchanges R objects in binary format,
but {Rserver} is not stateful, clients do not share the same global workspace
and it does not allow concurrent use of the command prompt).
</p>
<p>Due to a change in R 4.3.x in its event loop, some Tcl socket events are not
processes and this prevents the R socket server to work properly. This is
corrected in R 4.4.0. The socket server also works well with R 4.0.x, R 4.1.x
and R 4.2.x.
</p>
<p>See <code><a href="#topic+start_socket_server">start_socket_server()</a></code> and <code><a href="#topic+process_socket_server">process_socket_server()</a></code> for further
implementation details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Philippe Grosjean <a href="mailto:phgrosjean@sciviews.org">phgrosjean@sciviews.org</a> (<a href="https://orcid.org/0000-0002-2694-9471">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Matthew Dowle <a href="mailto:mdowle@mdowle.plus.com">mdowle@mdowle.plus.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/SciViews/svSocket">https://github.com/SciViews/svSocket</a>
</p>
</li>
<li> <p><a href="https://www.sciviews.org/svSocket/">https://www.sciviews.org/svSocket/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SciViews/svSocket/issues">https://github.com/SciViews/svSocket/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
