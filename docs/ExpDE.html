<!DOCTYPE html><html><head><title>Help for package ExpDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ExpDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_stop_criteria'><p>Stop criteria for DE</p></a></li>
<li><a href='#create_population'><p>Create population</p></a></li>
<li><a href='#evaluate_population'><p>Evaluate DE population</p></a></li>
<li><a href='#ExpDE'><p>Experimental Differential Evolution - ExpDE</p></a></li>
<li><a href='#mutation_best'><p>/best mutation for DE</p></a></li>
<li><a href='#mutation_current_to_pbest'><p>/current-to-pbest mutation for DE</p></a></li>
<li><a href='#mutation_mean'><p>/mean mutation for DE</p></a></li>
<li><a href='#mutation_none'><p>NULL mutation for DE</p></a></li>
<li><a href='#mutation_operators'><p>Mutation operators available</p></a></li>
<li><a href='#mutation_rand'><p>/rand mutation for DE</p></a></li>
<li><a href='#mutation_wgi'><p>/wgi mutation for DE</p></a></li>
<li><a href='#print_progress'><p>Print progress of DE</p></a></li>
<li><a href='#recombination_arith'><p>Arithmetic recombination for DE</p></a></li>
<li><a href='#recombination_bin'><p>/bin recombination for DE</p></a></li>
<li><a href='#recombination_blxAlphaBeta'><p>Blend Alpha Beta recombination for DE</p></a></li>
<li><a href='#recombination_eigen'><p>/eigen recombination for DE</p></a></li>
<li><a href='#recombination_exp'><p>Exponential recombination for DE</p></a></li>
<li><a href='#recombination_geo'><p>Geometric recombination for DE</p></a></li>
<li><a href='#recombination_lbga'><p>Linear BGA recombination for DE</p></a></li>
<li><a href='#recombination_linear'><p>Linear recombination for DE</p></a></li>
<li><a href='#recombination_mmax'><p>Min Max Arithmetical recombination for DE</p></a></li>
<li><a href='#recombination_none'><p>NULL recombination for DE</p></a></li>
<li><a href='#recombination_npoint'><p>n-point recombination for DE</p></a></li>
<li><a href='#recombination_onepoint'><p>One-point recombination for DE</p></a></li>
<li><a href='#recombination_operators'><p>Recombination operators available</p></a></li>
<li><a href='#recombination_pbest'><p>p-Best recombination for DE</p></a></li>
<li><a href='#recombination_sbx'><p>/sbx recombination for DE</p></a></li>
<li><a href='#recombination_wright'><p>Heuristic Wright recombination for DE</p></a></li>
<li><a href='#selection_standard'><p>Standard selection for DE</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modular Differential Evolution for Experimenting with Operators</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>smoof, cec2013</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-01-09</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/fcampelo/ExpDE">http://github.com/fcampelo/ExpDE</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felipe Campelo &lt;fcampelo@ufmg.br&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Modular implementation of the Differential Evolution algorithm for
    experimenting with different types of operators.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-09 20:31:41 UTC; fcampelo</td>
</tr>
<tr>
<td>Author:</td>
<td>Felipe Campelo [aut, cre],
  Moises Botelho [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-10 10:45:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_stop_criteria'>Stop criteria for DE</h2><span id='topic+check_stop_criteria'></span>

<h3>Description</h3>

<p>Implements different stop criteria for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_stop_criteria()
</code></pre>


<h3>Value</h3>

<p>logical flag indicating whether any stop condition has been reached.
</p>


<h3>Warning</h3>

<p>This routine accesses the parent environment used in the main function 
<code>ExpDE()</code>, which means that changes made in the variables 
contained in <code>env</code> WILL change the original values. DO NOT change 
anything unless you're absolutely sure of what you're doing.
</p>

<hr>
<h2 id='create_population'>Create population</h2><span id='topic+create_population'></span>

<h3>Description</h3>

<p>Creates a new population for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_population(popsize, probpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_population_+3A_popsize">popsize</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="create_population_+3A_probpars">probpars</code></td>
<td>
<p>list of named problem parameters (see <code><a href="#topic+ExpDE">ExpDE</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the population for the ExpDE
</p>

<hr>
<h2 id='evaluate_population'>Evaluate DE population</h2><span id='topic+evaluate_population'></span>

<h3>Description</h3>

<p>Evaluates the DE population on a given objective function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_population(probpars, Pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_population_+3A_probpars">probpars</code></td>
<td>
<p>problem parameters (see <code><a href="#topic+ExpDE">ExpDE</a></code> for details).</p>
</td></tr>
<tr><td><code id="evaluate_population_+3A_pop">Pop</code></td>
<td>
<p>population matrix (each row is a candidate solution, normalized 
to the [0, 1] interval,)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector (with length <code>nrow(Pop)</code>) containing the function 
values of each point in the population.
</p>

<hr>
<h2 id='ExpDE'>Experimental Differential Evolution - ExpDE</h2><span id='topic+ExpDE'></span>

<h3>Description</h3>

<p>Modular implementation of the Differential Evolution Algorithm for 
the experimental investigation of the effects of different operators 
on the performance of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpDE(popsize, mutpars = list(name = "mutation_rand", f = 0.2),
  recpars = list(name = "recombination_bin", cr = 0.8, nvecs = 1),
  selpars = list(name = "standard"), stopcrit, probpars, seed = NULL,
  showpars = list(show.iters = "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpDE_+3A_popsize">popsize</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_mutpars">mutpars</code></td>
<td>
<p>list of named mutation parameters.
See <code>Mutation parameters</code> for details.</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_recpars">recpars</code></td>
<td>
<p>list of named recombination parameters.
See <code>Recombination parameters</code> for details.</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_selpars">selpars</code></td>
<td>
<p>list of named selection parameters.
See <code>Selection parameters</code> for details.</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_stopcrit">stopcrit</code></td>
<td>
<p>list of named stop criteria parameters. 
See <code>Stop criteria</code> for details.</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_probpars">probpars</code></td>
<td>
<p>list of named problem parameters.
See <code>Problem Description</code> for details.</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_seed">seed</code></td>
<td>
<p>seed for the random number generator. 
See <code>Random Seed</code> for details.</p>
</td></tr>
<tr><td><code id="ExpDE_+3A_showpars">showpars</code></td>
<td>
<p>parameters that regulate the echoing of progress indicators
See <code>Showpars</code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is used to launch a differential evolution algorithm for the 
<strong>minimization</strong> of a given problem instance using different variants of 
the recombination, mutation and selection operators. The input parameters 
that describe those operators receive list objects describing the operator 
variants to be used in a given optimization procedure.
</p>


<h3>Value</h3>

<p>A list object containing the final population (sorted by performance)
, the performance vector, and some run statistics.
</p>


<h3>Mutation Parameters</h3>

<p><code>mutpars</code> is used to inform the routine the type of differential 
mutation to use, as well as any mutation-related parameter values. The 
current version accepts the following options:
</p>

<ul>
<li> <p><code><a href="#topic+mutation_best">mutation_best</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mutation_rand">mutation_rand</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mutation_mean">mutation_mean</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mutation_none">mutation_none</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mutation_current_to_pbest">mutation_current_to_pbest</a></code> (incl. special case
<code>current-to-best</code>)
</p>
</li>
<li> <p><code><a href="#topic+mutation_wgi">mutation_wgi</a></code>
</p>
</li></ul>

<p><code>mutpars</code> receives a list object with name field <code>mutpars$name</code> 
(containing the name of the function to be called, e.g., 
<code>name = "mutation_rand"</code>) as well as whatever parameters that function 
may require/accept (e.g., <code>mutpars$f = 0.7</code>, <code>mutpars$nvecs = 2</code>, 
etc.). See the specific documentation of each function for details. 
</p>
<p>Some examples are provided in the <code>Examples</code> section below.
</p>


<h3>Recombination parameters</h3>

<p>As with the mutation parameters, <code>recpars</code> is used to define the 
desired recombination strategy. The current version accepts the following 
options:
</p>

<ul>
<li> <p><code><a href="#topic+recombination_arith">recombination_arith</a></code>   
</p>
</li>
<li> <p><code><a href="#topic+recombination_bin">recombination_bin</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_blxAlphaBeta">recombination_blxAlphaBeta</a></code> (incl. special cases 
<code>blxAlpha</code> and <code>flat</code>)
</p>
</li>
<li> <p><code><a href="#topic+recombination_eigen">recombination_eigen</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_exp">recombination_exp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_geo">recombination_geo</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_lbga">recombination_lbga</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_linear">recombination_linear</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_mmax">recombination_mmax</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_npoint">recombination_npoint</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_none">recombination_none</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_onepoint">recombination_onepoint</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_pbest">recombination_pbest</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_sbx">recombination_sbx</a></code>
</p>
</li>
<li> <p><code><a href="#topic+recombination_wright">recombination_wright</a></code>    
</p>
</li></ul>

<p><code>recpars</code> receives a list object with name field <code>recpars$name</code> 
(containing the name of the function to be called, e.g., 
<code>name = "recombination_bin"</code>) as well as whatever parameters that 
function may require/accept (e.g., <code>recpars$cr = 0.8</code>, 
<code>recpars$minchange = TRUE</code>, etc.). See the specific documentation of 
each function for details. 
</p>
<p>Some examples are provided in the <code>Examples</code> section below.
</p>


<h3>Selection parameters</h3>

<p><code>selpars</code> follows the same idea as <code>mutpars</code> and <code>recpars</code>, 
and is used to define the selection operators. Currently, only the standard 
DE selection, <code><a href="#topic+selection_standard">selection_standard</a></code>, is implemented.
</p>


<h3>Stop criteria</h3>

<p><code>stopcrit</code> is similar to <code>recpar</code> and the other list arguments, 
but with the difference that multiple stop criteria can be defined for the
algorithm. The names of the stop criteria to be used are passed in the 
<code>stopcrit$names</code> field, which must contain a character vector. Other 
parameters to be used for stopping the algorithm (e.g., the maximum number 
of iterations <code>stopcrit$maxiter</code>) can also be included as 
<code>stopcrit</code> fields. Currently implemented criteria are:
</p>

<ul>
<li> <p><code>"stop_maxiter"</code> (requires additional field 
<code>stopcrit$maxiter = ?</code> with the maximum number of iterations).
</p>
</li>
<li> <p><code>"stop_maxeval"</code> (requires additional field 
<code>stopcrit$maxevals = ?</code> with the maximum number of function calls).
</p>
</li></ul>

<p>See <code><a href="#topic+check_stop_criteria">check_stop_criteria</a></code> for details.
</p>


<h3>Problem description</h3>

<p>The <code>probpars</code> parameter receives a list with all definitions related 
to the problem instance to be optimized. There are three required fields in 
this parameter:
</p>

<ul>
<li> <p><code>probpars$name</code>, the name of the function that represents the 
problem to be solved.
</p>
</li>
<li> <p><code>probpars$xmin</code>, a vector containing the lower bounds of all 
optimization variables (i.e., a vector of length M, where M is the 
dimension of the problem).
</p>
</li>
<li> <p><code>probpars$xmax</code>, a vector containing the upper bounds of all 
optimization variables.
</p>
</li></ul>

<p>This list can also contain the following optional arguments
</p>

<ul>
<li> <p><code>probpars$matrixEval</code>, indicates what kind of input is expected 
by the function provided in <code>probpars$name</code>. Valid entries are 
<code>"vector"</code>, <code>"colMatrix"</code> and <code>"rowMatrix"</code>. 
Defaults to <code>probpars$matrixEval = "rowMatrix"</code>
</p>
</li></ul>

<p><strong>Important</strong>: the objective function routine must receive either a 
vector or a matrix of vectors to be evaluated in the form of an input 
parameter named either &quot;x&quot; or &quot;X&quot; or &quot;Pop&quot; (any one of the three is allowed).
</p>


<h3>Random Seed</h3>

<p>The <code>seed</code> argument receives the desired seed for the PRNG. This value 
can be set for reproducibility purposes. The value of this parameter defaults 
to NULL, in which case the seed is arbitrarily set using 
<code>as.numeric(Sys.time())</code>.
</p>


<h3>Showpars</h3>

<p><code>showpars</code> is a list containing parameters that control the printed
output of <code>ExpDE</code>. Parameter <code>showpars</code> can have the following 
fields:
</p>

<ul>
<li> <p><code>showpars$show.iters = c("dots", "numbers", "none")</code>: type of 
output. Defaults to <code>"numbers"</code>.
</p>
</li>
<li> <p><code>showpars$showevery</code>: positive integer that determines how 
frequently the routine echoes something to the terminal. Defaults 
to <code>1</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Felipe Campelo (<a href="mailto:fcampelo@ufmg.br">fcampelo@ufmg.br</a>) and Moises Botelho 
(<a href="mailto:moisesufop@gmail.com">moisesufop@gmail.com</a>)
</p>


<h3>References</h3>

<p>F. Campelo, M. Botelho, &quot;Experimental Investigation of Recombination 
Operators for Differential Evolution&quot;, Genetic and Evolutionary 
Computation Conference, July 20-24, 2016, Denver/CO. 
DOI: 10.1145/2908812.2908852
</p>


<h3>Examples</h3>

<pre><code class='language-R'># DE/rand/1/bin with population 40, F = 0.8 and CR = 0.5
popsize  &lt;- 100
mutpars  &lt;- list(name = "mutation_rand", f = 0.8)
recpars  &lt;- list(name = "recombination_bin", cr = 0.5, minchange = TRUE)
selpars  &lt;- list(name = "selection_standard")
stopcrit &lt;- list(names = "stop_maxiter", maxiter = 100)
probpars &lt;- list(name  = "sphere",
                xmin = rep(-5.12,10), xmax = rep(5.12,10))
seed &lt;- NULL
showpars &lt;- list(show.iters = "numbers", showevery = 1)
ExpDE(popsize, mutpars, recpars, selpars, stopcrit, probpars, seed, showpars)


# DE/wgi/1/blxAlpha
recpars  &lt;- list(name = "recombination_blxAlphaBeta", alpha = 0.1, beta = 0.1)
mutpars  &lt;- list(name = "mutation_wgi", f = 0.8)
ExpDE(popsize, mutpars, recpars, selpars, stopcrit, probpars)

# DE/best/1/sbx
recpars  &lt;- list(name = "recombination_sbx", eta = 10)
mutpars  &lt;- list(name = "mutation_best", f = 0.6, nvecs = 1)
ExpDE(popsize, mutpars, recpars, selpars, stopcrit, probpars)

# DE/best/1/eigen/bin
recpars  &lt;- list(name = "recombination_eigen", 
                 othername = "recombination_bin", 
                 cr = 0.5, minchange = TRUE)
showpars &lt;- list(show.iters = "dots", showevery = 10)
stopcrit &lt;- list(names = "stop_maxeval", maxevals = 10000)
ExpDE(popsize, mutpars, recpars, selpars, stopcrit, probpars, seed = 1234)

</code></pre>

<hr>
<h2 id='mutation_best'>/best mutation for DE</h2><span id='topic+mutation_best'></span>

<h3>Description</h3>

<p>Implements the &quot;/best/nvecs&quot; mutation for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_best(X, mutpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_best_+3A_x">X</code></td>
<td>
<p>population matrix</p>
</td></tr>
<tr><td><code id="mutation_best_+3A_mutpars">mutpars</code></td>
<td>
<p>mutation parameters (see <code>Mutation parameters</code> for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>M</code> containing the mutated population
</p>


<h3>Mutation Parameters</h3>

<p>The <code>mutpars</code> parameter contains all parameters required to define the 
mutation. <code>mutation_best()</code> understands the following fields in 
<code>mutpars</code>:
</p>

<ul>
<li> <p><code>f</code> : scaling factor for difference vector(s).<br />
Accepts numeric vectors of size 1 or <code>nvecs</code>.
</p>
</li>
<li> <p><code>nvecs</code> : number of difference vectors to use.<br /> 
Accepts <code>1 &lt;= nvecs &lt;= (nrow(X)/2 - 2)</code><br />
Defaults to 1.
</p>
</li></ul>



<h3>Warning</h3>

<p>This routine will search for the performance vector 
of population <code>X</code> (<code>J</code>) in the parent environment (using 
<code>parent.frame()</code>. This variable must be defined for 
<code>mutation_best()</code> to work.
</p>


<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A 
Practical Approach to Global Optimization&quot;, Springer 2005
</p>


<h3>Author(s)</h3>

<p>Felipe Campelo (<a href="mailto:fcampelo@ufmg.br">fcampelo@ufmg.br</a>)
</p>

<hr>
<h2 id='mutation_current_to_pbest'>/current-to-pbest mutation for DE</h2><span id='topic+mutation_current_to_pbest'></span>

<h3>Description</h3>

<p>Implements the &quot;/current-to-pbest&quot; mutation for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_current_to_pbest(X, mutpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_current_to_pbest_+3A_x">X</code></td>
<td>
<p>population matrix</p>
</td></tr>
<tr><td><code id="mutation_current_to_pbest_+3A_mutpars">mutpars</code></td>
<td>
<p>mutation parameters (see <code>Mutation parameters</code> for details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine also implements one special case: 
</p>

<ul>
<li><p> current-to-best mutation (<code>current_to_best</code>), by setting 
<code>mutpars$p = 1</code>); 
</p>
</li>
<li><p> Flat recombination (<code>flat</code>), by setting 
<code>recpars$alpha = recpars$beta = 0</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix <code>M</code> containing the mutated population
</p>


<h3>Mutation Parameters</h3>

<p>The <code>mutpars</code> parameter contains all parameters required to define the 
mutation. <code>mutation_current_to_pbest()</code> understands the following fields in 
<code>mutpars</code>:
</p>

<ul>
<li> <p><code>f</code> : scaling factor for difference vector(s).<br />
Accepts numeric vectors of size 1 or <code>nvecs</code>.
</p>
</li>
<li> <p><code>p</code> : either the number of &quot;best&quot; vectors to use (if given as a 
positive integer) or the proportion of the population to use as &quot;best&quot;
vectors (if 0 &lt; p &lt; 1).
</p>
</li></ul>



<h3>Warning</h3>

<p>This routine will search for the performance vector 
of population <code>X</code> (<code>J</code>) in the parent environment (using 
<code>parent.frame()</code>. This variable must be defined for 
<code>mutation_current_to_pbest()</code> to work.
</p>


<h3>References</h3>

<p>J. Zhang, A.C. Sanderson, 
&quot;JADE: Adaptive differential evolution with optional external archive&quot;. 
IEEE Transactions on Evolutionary Computation 13:945-958, 2009
</p>


<h3>Author(s)</h3>

<p>Felipe Campelo (<a href="mailto:fcampelo@ufmg.br">fcampelo@ufmg.br</a>)
</p>

<hr>
<h2 id='mutation_mean'>/mean mutation for DE</h2><span id='topic+mutation_mean'></span>

<h3>Description</h3>

<p>Implements the &quot;/mean/nvecs&quot; mutation for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_mean(X, mutpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_mean_+3A_x">X</code></td>
<td>
<p>population matrix</p>
</td></tr>
<tr><td><code id="mutation_mean_+3A_mutpars">mutpars</code></td>
<td>
<p>mutation parameters (see <code>Mutation parameters</code> for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>M</code> containing the mutated population
</p>


<h3>Mutation Parameters</h3>

<p>The <code>mutpars</code> parameter contains all parameters required to define the 
mutation. <code>mutation_mean()</code> understands the following fields in 
<code>mutpars</code>:
</p>

<ul>
<li> <p><code>f</code> : scaling factor for difference vector(s).<br />
Accepts numeric vectors of size 1 or <code>nvecs</code>.
</p>
</li>
<li> <p><code>nvecs</code> : number of difference vectors to use.<br /> 
Accepts <code>1 &lt;= nvecs &lt;= (nrow(X)/2 - 2)</code><br />
Defaults to 1.
</p>
</li></ul>



<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A 
Practical Approach to Global Optimization&quot;, Springer 2005
</p>


<h3>Author(s)</h3>

<p>Felipe Campelo (<a href="mailto:fcampelo@ufmg.br">fcampelo@ufmg.br</a>)
</p>

<hr>
<h2 id='mutation_none'>NULL mutation for DE</h2><span id='topic+mutation_none'></span>

<h3>Description</h3>

<p>Implements the &quot;/none&quot; mutation (i.e., no mutation performed) for the 
ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_none(X, mutpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_none_+3A_x">X</code></td>
<td>
<p>population matrix</p>
</td></tr>
<tr><td><code id="mutation_none_+3A_mutpars">mutpars</code></td>
<td>
<p>mutation parameters (see <code>Mutation parameters</code> for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>@return The same matrix <code>X</code> used as an input.
</p>


<h3>Mutation Parameters</h3>

<p>The <code>mutpars</code> parameter contains all parameters required to define the 
mutation. <code>mutation_none()</code> requires no fields in this parameter.
</p>

<hr>
<h2 id='mutation_operators'>Mutation operators available</h2><span id='topic+mutation_operators'></span>

<h3>Description</h3>

<p>List all available mutation operators in the ExpDE package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_operators()
</code></pre>


<h3>Value</h3>

<p>Character vector with the names of all mutation operators
</p>

<hr>
<h2 id='mutation_rand'>/rand mutation for DE</h2><span id='topic+mutation_rand'></span>

<h3>Description</h3>

<p>Implements the &quot;/rand/nvecs&quot; mutation for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_rand(X, mutpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_rand_+3A_x">X</code></td>
<td>
<p>population matrix</p>
</td></tr>
<tr><td><code id="mutation_rand_+3A_mutpars">mutpars</code></td>
<td>
<p>mutation parameters (see <code>Mutation parameters</code> for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>M</code> containing the mutated population
</p>


<h3>Mutation Parameters</h3>

<p>The <code>mutpars</code> parameter contains all parameters required to define the 
mutation. <code>mutation_rand()</code> understands the following fields in 
<code>mutpars</code>:
</p>

<ul>
<li> <p><code>f</code> : scaling factor for difference vector(s).<br />
Accepts numeric vectors of size 1 or <code>nvecs</code>.
</p>
</li>
<li> <p><code>nvecs</code> : number of difference vectors to use.<br /> 
Accepts <code>1 &lt;= nvecs &lt;= (nrow(X)/2 - 2)</code><br />
Defaults to 1.
</p>
</li></ul>



<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A 
Practical Approach to Global Optimization&quot;, Springer 2005
</p>


<h3>Author(s)</h3>

<p>Felipe Campelo (<a href="mailto:fcampelo@ufmg.br">fcampelo@ufmg.br</a>)
</p>

<hr>
<h2 id='mutation_wgi'>/wgi mutation for DE</h2><span id='topic+mutation_wgi'></span>

<h3>Description</h3>

<p>Implements the &quot;/wgi/nvecs&quot; mutation (weighted global intermediate) for the 
ExpDE framework. This variant is based on a recombination strategy known as
&quot;weighted global intermediate recombination&quot; (see the References section for 
details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutation_wgi(X, mutpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutation_wgi_+3A_x">X</code></td>
<td>
<p>population matrix</p>
</td></tr>
<tr><td><code id="mutation_wgi_+3A_mutpars">mutpars</code></td>
<td>
<p>mutation parameters (see <code>Mutation parameters</code> for 
details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>M</code> containing the mutated population
</p>


<h3>Mutation Parameters</h3>

<p>The <code>mutpars</code> parameter contains all parameters required to define the 
mutation. <code>mutation_wgi()</code> understands the following fields in 
<code>mutpars</code>:
</p>

<ul>
<li> <p><code>f</code> : scaling factor for difference vector(s).<br />
Accepts numeric vectors of size 1 or <code>nvecs</code>.
</p>
</li>
<li> <p><code>nvecs</code> : number of difference vectors to use.<br /> 
Accepts <code>1 &lt;= nvecs &lt;= (nrow(X)/2 - 2)</code><br />
Defaults to 1.
</p>
</li></ul>



<h3>References</h3>

<p>D. Arnold,
&quot;Weighted multirecombination evolution strategies&quot;. 
Theoretical Computer Science 361(1): 18-37, 2006.
</p>
<p>T. Glasmachers, C. Igel,
&quot;Uncertainty handling in model selection for support vector machines&quot;. 
Proc. International Conference on Parallel Problem Solving from Nature 
(PPSN'08), 185-194, 2008.
</p>


<h3>Author(s)</h3>

<p>Felipe Campelo (<a href="mailto:fcampelo@ufmg.br">fcampelo@ufmg.br</a>)
</p>

<hr>
<h2 id='print_progress'>Print progress of DE</h2><span id='topic+print_progress'></span>

<h3>Description</h3>

<p>Echoes the progress of DE to the terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_progress()
</code></pre>


<h3>Parameters</h3>

<p>This routine accesses all variables defined in the calling environment using
<code>parent.frame()</code>, so it does not require any explicit input parameters.
However, the calling environment must contain:
</p>

<ul>
<li> <p><code>showpars</code>: list containing parameters that control the printed
output of <code>moead()</code>. Parameter <code>showpars</code>
can have the following fields:
</p>

<ul>
<li> <p><code>$show.iters = c("dots", "numbers", "none")</code>: type of output.
Defaults to <code>"numbers"</code>.
</p>
</li>
<li> <p><code>$showevery</code>: positive integer that determines how frequently
the routine echoes something to the terminal.
Defaults to <code>1</code>.
</p>
</li></ul>

</li>
<li> <p><code>iters()</code> : counter function that registers the iteration
number
</p>
</li></ul>


<hr>
<h2 id='recombination_arith'>Arithmetic recombination for DE</h2><span id='topic+recombination_arith'></span>

<h3>Description</h3>

<p>Implements the &quot;/arith&quot; (arithmetic) recombination for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_arith(X, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_arith_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_arith_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_arith_+3A_...">...</code></td>
<td>
<p>optional parameters (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.
</p>

<hr>
<h2 id='recombination_bin'>/bin recombination for DE</h2><span id='topic+recombination_bin'></span>

<h3>Description</h3>

<p>Implements the &quot;/bin&quot; (binomial) recombination for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_bin(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_bin_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_bin_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_bin_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_bin()</code> understands the following fields in 
<code>recpars</code>:
</p>

<ul>
<li> <p><code>cr</code> : component-wise probability of using the value in 
<code>M</code>.<br />
Accepts numeric value <code>0 &lt; cr &lt;= 1</code>.
</p>
</li>
<li> <p><code>minchange</code> : logical flag to force each new candidate solution 
to inherit at least one component from its 
mutated 'parent'.<br />
Defaults to TRUE
</p>
</li></ul>



<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A 
Practical Approach to Global Optimization&quot;, Springer 2005
</p>

<hr>
<h2 id='recombination_blxAlphaBeta'>Blend Alpha Beta recombination for DE</h2><span id='topic+recombination_blxAlphaBeta'></span>

<h3>Description</h3>

<p>Implements the &quot;/blxAlphaBeta&quot; (Blend Alpha Beta) recombination for the ExpDE 
framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_blxAlphaBeta(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_blxAlphaBeta_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_blxAlphaBeta_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_blxAlphaBeta_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine also implements two special cases: 
</p>

<ul>
<li><p> BLX-alpha recombination (<code>blxAlpha</code>), by setting 
<code>recpars$alpha = recpars$beta</code>); 
</p>
</li>
<li><p> Flat recombination (<code>flat</code>), by setting 
<code>recpars$alpha = recpars$beta = 0</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_blxAlpha()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>alpha</code> : extrapolation parameter for 'best' parent vector.<br />
Accepts real value <code>0 &lt;= alpha &lt;= 0.5</code>.
</p>
</li>
<li> <p><code>beta</code> : extrapolation parameter for 'worst' parent vector.<br />
Accepts real value <code>0 &lt;= beta &lt;= 0.5</code>. 
</p>
</li></ul>

<p>@section Warning:
This recombination operator evaluates the candidate solutions in <code>M</code>, 
which adds an extra <code>popsize</code> evaluations per iteration.
</p>


<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.
</p>

<hr>
<h2 id='recombination_eigen'>/eigen recombination for DE</h2><span id='topic+recombination_eigen'></span>

<h3>Description</h3>

<p>Implements the &quot;/eigen&quot; (eigenvector-based) recombination for the ExpDE 
framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_eigen(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_eigen_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_eigen_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_eigen_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_eigen()</code> understands the following fields 
in <code>recpars</code>:
</p>

<ul>
<li> <p><code>othername</code>: name of the recombination operator to be applied 
after the projection in the eigenvector basis
</p>
</li>
<li> <p><code>...</code> :  parameters required (or optional) to the operator 
defined by <code>recpars$othername</code>
</p>
</li></ul>



<h3>References</h3>

<p>Shu-Mei Guo e Chin-Chang Yang, &quot;Enhancing differential evolution utilizing 
eigenvector-based crossover operator&quot;, IEEE Transactions on Evolutionary 
Computation 19(1):31-49, 2015.
</p>

<hr>
<h2 id='recombination_exp'>Exponential recombination for DE</h2><span id='topic+recombination_exp'></span>

<h3>Description</h3>

<p>Implements the &quot;/exp&quot; (exponential) recombination for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_exp(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_exp_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_exp_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_exp_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_exp()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>cr</code> : component-wise probability of selection as a cut-point.
<br />
Accepts numeric value <code>0 &lt; cr &lt;= 1</code>.
</p>
</li></ul>



<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A 
Practical Approach to Global Optimization&quot;, Springer 2005
</p>

<hr>
<h2 id='recombination_geo'>Geometric recombination for DE</h2><span id='topic+recombination_geo'></span>

<h3>Description</h3>

<p>Implements the &quot;/geo&quot; (geometric) recombination for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_geo(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_geo_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_geo_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_geo_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_geo()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>alpha</code> : exponent for geometrical recombination.<br />
Accepts numeric value <code>0 &lt;= alpha &lt;= 1</code> or <code>NULL</code> (in which 
case a random value is chosen for each recombination).
</p>
</li></ul>



<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.
</p>

<hr>
<h2 id='recombination_lbga'>Linear BGA recombination for DE</h2><span id='topic+recombination_lbga'></span>

<h3>Description</h3>

<p>Implements the &quot;/lbga&quot; (Linear Breeder Genetic Algorithm) recombination for 
the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_lbga(X, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_lbga_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_lbga_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_lbga_+3A_...">...</code></td>
<td>
<p>optional parameters (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Warning</h3>

<p>This recombination operator evaluates the candidate solutions in <code>M</code>, 
which adds an extra <code>popsize</code> evaluations per iteration.
</p>


<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.<br />
D. Schlierkamp-voosen , H. Muhlenbein, &quot;Strategy Adaptation by 
Competing Subpopulations&quot;, Proc. Parallel Problem Solving from Nature 
(PPSN III), 199-208, 1994.
</p>

<hr>
<h2 id='recombination_linear'>Linear recombination for DE</h2><span id='topic+recombination_linear'></span>

<h3>Description</h3>

<p>Implements the &quot;/linear&quot; recombination for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_linear(X, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_linear_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_linear_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_linear_+3A_...">...</code></td>
<td>
<p>optional parameters (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Warning</h3>

<p>This recombination operator evaluates <code>3*popsize</code> candidate solutions 
per iteration of the algorithm. The value of the <code>nfe</code> counter and the 
vector of performance values <code>G</code> are updated in the calling environment.
</p>


<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.<br />
A.H. Wright, &quot;Genetic Algorithms for Real Parameter Optimization&quot;,
Proc. Foundations of Genetic Algorithms, 205-218, 1991.
</p>

<hr>
<h2 id='recombination_mmax'>Min Max Arithmetical recombination for DE</h2><span id='topic+recombination_mmax'></span>

<h3>Description</h3>

<p>Implements the &quot;/mmax&quot; (min-max-arithmetical) recombination for the ExpDE 
framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_mmax(X, M, recpars = list(lambda = NULL))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_mmax_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_mmax_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_mmax_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Warning</h3>

<p>This recombination operator evaluates <code>4*popsize</code> candidate solutions 
per iteration of the algorithm. The value of the <code>nfe</code> counter and the 
vector of performance values <code>G</code> are updated in the calling environment.
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_pbest()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>lambda</code> : Recombination multiplier.<br />
Optional. Defaults to <code>NULL</code>
Accepts numeric value <code>0 &lt; lambda &lt; 1</code> or 
<code>NULL</code> (in which case a random value is 
independently used for each variable of each 
recombination pair).
</p>
</li></ul>



<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3):309-338, 2003.<br />
F Herrera, M. Lozano,  J.L. Verdegay, &quot;Tuning fuzzy logic controllers by 
genetic algorithms.&quot;, International Journal of Approximate Reasoning 
12(3):299-315, 1995. <br />
</p>

<hr>
<h2 id='recombination_none'>NULL recombination for DE</h2><span id='topic+recombination_none'></span>

<h3>Description</h3>

<p>Implements the &quot;/none&quot; recombination (i.e., no recombination performed) 
for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_none(X, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_none_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_none_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_none_+3A_...">...</code></td>
<td>
<p>optional parameters (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same matrix <code>M</code> used as an input.
</p>

<hr>
<h2 id='recombination_npoint'>n-point recombination for DE</h2><span id='topic+recombination_npoint'></span>

<h3>Description</h3>

<p>Implements the &quot;/npoint&quot; (n-point) recombination for the ExpDE (as used in 
the Simple GA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_npoint(X, M, recpars = list(N = NULL))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_npoint_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_npoint_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_npoint_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_npoint()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>N</code> : cut number points for crossover.<br />
Accepts integer value <code>0 &lt;= N &lt; n</code>, where <code>n</code> is the 
dimension of the problem; Use <code>N = 0</code> or <code>N = NULL</code> for randomly 
choosing a number of cut points.<br />
Defaults to <code>NULL</code>.
</p>
</li></ul>



<h3>References</h3>

<p>L.J. Eshelman, R.A. Caruana, J.D. Schaffer (1989), &quot;Biases in the crossover 
landscape. In: Proceedings of the Third International Conference on Genetic 
Algorithms, pp. 10-19, San Francisco, CA, USA.
</p>

<hr>
<h2 id='recombination_onepoint'>One-point recombination for DE</h2><span id='topic+recombination_onepoint'></span>

<h3>Description</h3>

<p>Implements the one-point recombination (as used in the Simple GA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_onepoint(X, M, recpars = list(K = NULL))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_onepoint_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_onepoint_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_onepoint_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_onepoint()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>K</code> : cut point for crossover.<br />
Accepts integer value <code>0 &lt;= K &lt; n</code>, where <code>n</code> is the 
dimension of the problem; Use <code>K = 0</code> or <code>K = NULL</code> for randomly 
choosing a position for each pair of points.<br />
Defaults to <code>NULL</code>.
</p>
</li></ul>



<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.
</p>

<hr>
<h2 id='recombination_operators'>Recombination operators available</h2><span id='topic+recombination_operators'></span>

<h3>Description</h3>

<p>List all available recombination operators in the ExpDE package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_operators()
</code></pre>


<h3>Value</h3>

<p>Character vector with the names of all recombination operator 
routines
</p>

<hr>
<h2 id='recombination_pbest'>p-Best recombination for DE</h2><span id='topic+recombination_pbest'></span>

<h3>Description</h3>

<p>Implements the &quot;/pbest&quot; (p-Best) recombination for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_pbest(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_pbest_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_pbest_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_pbest_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_pbest()</code> understands the following 
fields in <code>recpars</code>:
</p>

<ul>
<li> <p><code>cr</code> : component-wise probability of using the value in 
<code>M</code>.<br />
Accepts numeric value <code>0 &lt; cr &lt;= 1</code>.
</p>
</li></ul>



<h3>Warning</h3>

<p>This routine will search for the iterations counter (<code>t</code>), the maximum 
number of iterations (<code>stopcrit$maxiter</code>), and the performance vector 
of population <code>X</code> (<code>J</code>) in the parent environment (using 
<code>parent.frame()</code>. These variables must be defined for 
<code>recombination_pbest()</code> to work.
</p>


<h3>References</h3>

<p>S.M. Islam, S. Das, S. Ghosh, S. Roy, P.N. Suganthan, &quot;An Adaptive 
Differential Evolution Algorithm With Novel Mutation and Crossover 
Strategies for Global Numerical Optimization&quot;, IEEE. Trans. Systems, Man
and Cybernetics - Part B 42(2), 482-500, 2012
</p>

<hr>
<h2 id='recombination_sbx'>/sbx recombination for DE</h2><span id='topic+recombination_sbx'></span>

<h3>Description</h3>

<p>Implements the &quot;/sbx&quot; (Simulated Binary) recombination for the ExpDE 
framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_sbx(X, M, recpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_sbx_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_sbx_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_sbx_+3A_recpars">recpars</code></td>
<td>
<p>recombination parameters (see <code>Recombination parameters</code> 
for details)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Recombination Parameters</h3>

<p>The <code>recpars</code> parameter contains all parameters required to define the 
recombination. <code>recombination_sbx()</code> understands the following field in 
<code>recpars</code>:
</p>

<ul>
<li> <p><code>eta</code> : spread factor.<br />
Accepts numeric value <code>eta &gt; 0</code>.
</p>
</li></ul>



<h3>References</h3>

<p>K. Price, R.M. Storn, J.A. Lampinen, &quot;Differential Evolution: A 
Practical Approach to Global Optimization&quot;, Springer 2005<br />
F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.<br />
K. Deb, R.B. Agrawal, &quot;Simulated binary crossover for continuous search 
space&quot;, Complex Systems (9):115-148, 1995.
</p>

<hr>
<h2 id='recombination_wright'>Heuristic Wright recombination for DE</h2><span id='topic+recombination_wright'></span>

<h3>Description</h3>

<p>Implements the &quot;/wright&quot; (Heuristic Wright) recombination for the ExpDE 
framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombination_wright(X, M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recombination_wright_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="recombination_wright_+3A_m">M</code></td>
<td>
<p>population matrix (mutated)</p>
</td></tr>
<tr><td><code id="recombination_wright_+3A_...">...</code></td>
<td>
<p>optional parameters (unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix <code>U</code> containing the recombined population
</p>


<h3>Warning</h3>

<p>This recombination operator evaluates the candidate solutions in <code>M</code>, 
which adds an extra <code>popsize</code> evaluations per iteration.
</p>


<h3>References</h3>

<p>F. Herrera, M. Lozano, A. M. Sanchez, &quot;A taxonomy for the crossover
operator for real-coded genetic algorithms: an experimental study&quot;, 
International Journal of Intelligent Systems 18(3) 309-338, 2003.<br />
A.H. Wright, &quot;Genetic Algorithms for Real Parameter Optimization&quot;,
Proc. Foundations of Genetic Algorithms, 205-218, 1991.
</p>

<hr>
<h2 id='selection_standard'>Standard selection for DE</h2><span id='topic+selection_standard'></span>

<h3>Description</h3>

<p>Implements the standard selection (greedy) for the ExpDE framework
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection_standard(X, U, J, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection_standard_+3A_x">X</code></td>
<td>
<p>population matrix (original)</p>
</td></tr>
<tr><td><code id="selection_standard_+3A_u">U</code></td>
<td>
<p>population matrix (recombined)</p>
</td></tr>
<tr><td><code id="selection_standard_+3A_j">J</code></td>
<td>
<p>performance vector for population <code>X</code></p>
</td></tr>
<tr><td><code id="selection_standard_+3A_g">G</code></td>
<td>
<p>performance vector for population <code>U</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list object containing the selected population (<code>Xsel</code>) and 
its corresponding performance values (<code>Jsel</code>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
