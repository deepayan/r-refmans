<!DOCTYPE html><html lang="en"><head><title>Help for package RSclient</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSclient}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RC-methods'>
<p>Methods for the RserveConnection class</p></a></li>
<li><a href='#RCC'><p>Functions to talk to an Rserve instance (new version)</p></a></li>
<li><a href='#Rclient'><p>Functions to talk to an Rserve</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.7-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Client for Rserve</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Urbanek &lt;Simon.Urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Urbanek &lt;Simon.Urbanek@r-project.org&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.7.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Client for Rserve, allowing to connect to Rserve instances and issue commands.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.rforge.net/RSclient/">http://www.rforge.net/RSclient/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 21:55:48 UTC; rforge</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 08:44:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='RC-methods'>
Methods for the RserveConnection class
</h2><span id='topic+RC-methods'></span><span id='topic+print.RserveConnection'></span><span id='topic++3D+3D.RserveConnection'></span><span id='topic++21+3D.RserveConnection'></span>

<h3>Description</h3>

<p>Basic methods (printing, comparison) for the RserveConnection class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RserveConnection'
print(x, ...)
## S3 method for class 'RserveConnection'
e1 == e2
## S3 method for class 'RserveConnection'
e1 != e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RC-methods_+3A_x">x</code></td>
<td>
<p>Rserve connection object</p>
</td></tr>
<tr><td><code id="RC-methods_+3A_e1">e1</code></td>
<td>
<p>Rserve connection object</p>
</td></tr>
<tr><td><code id="RC-methods_+3A_e2">e2</code></td>
<td>
<p>Rserve connection object</p>
</td></tr>
<tr><td><code id="RC-methods_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print</code> returns <code>x</code> invisibly
</p>
<p><code>==</code> and <code>!=</code> return a logical scalar
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek
</p>

<hr>
<h2 id='RCC'>Functions to talk to an Rserve instance (new version)</h2><span id='topic+RCC'></span><span id='topic+RS.connect'></span><span id='topic+RS.close'></span><span id='topic+RS.eval'></span><span id='topic+RS.eval.qap'></span><span id='topic+RS.login'></span><span id='topic+RS.switch'></span><span id='topic+RS.authkey'></span><span id='topic+RS.collect'></span><span id='topic+RS.assign'></span><span id='topic+RS.oobCallbacks'></span><span id='topic+RS.server.shutdown'></span><span id='topic+RS.server.eval'></span><span id='topic+RS.server.source'></span>

<h3>Description</h3>

<p>Rserve is a server providing R functionality via sockets. The
following functions allow another R session to start new Rserve
sessions and evaluate commands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RS.connect(host = NULL, port = 6311L, tls = FALSE, verify = TRUE,
           proxy.target = NULL, proxy.wait = TRUE, chain, key, ca)
RS.login(rsc, user, password, pubkey, authkey)
RS.eval(rsc, x, wait = TRUE, lazy = TRUE)
RS.eval.qap(rsc, x, wait = TRUE)
RS.collect(rsc, timeout = Inf, detail = FALSE, qap = FALSE)
RS.close(rsc)
RS.assign(rsc, name, value, wait = TRUE)
RS.switch(rsc, protocol = "TLS", verify = TRUE, chain, key, ca)
RS.authkey(rsc, type = "rsa-authkey")
RS.server.eval(rsc, text)
RS.server.source(rsc, filename)
RS.server.shutdown(rsc)
RS.oobCallbacks(rsc, send, msg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RCC_+3A_host">host</code></td>
<td>
<p>host to connect to or socket path or <code>NULL</code> for local host</p>
</td></tr>
<tr><td><code id="RCC_+3A_port">port</code></td>
<td>
<p>TCP port to connect to or 0 if unix socket is to be used</p>
</td></tr>
<tr><td><code id="RCC_+3A_tls">tls</code></td>
<td>
<p>if <code>TRUE</code> then SSL/TLS encrypted connection is
started</p>
</td></tr>
<tr><td><code id="RCC_+3A_verify">verify</code></td>
<td>
<p>logical, if <code>FALSE</code> no verification of the server
certificate is done, otherwise the certificate is verified and the
function will fail with an error if it is not valid.</p>
</td></tr>
<tr><td><code id="RCC_+3A_chain">chain</code></td>
<td>
<p>string, optional, path to a file in PEM format that contains
client certificate and its chain. The client certificate must be
first in the chain.</p>
</td></tr>
<tr><td><code id="RCC_+3A_key">key</code></td>
<td>
<p>string, optional, path to a file in PEM format containing
the private key for the client certificate. If a client certificate
is necessary for the connection, both <code>chain</code> and <code>key</code>
must be set.</p>
</td></tr>
<tr><td><code id="RCC_+3A_ca">ca</code></td>
<td>
<p>string, optional, path to a file holding any additional
certificate authority (CA) certificates (including intermediate
certificates) in PEM format that are required for the verification
of the server certificate. Only relevant if <code>verify=TRUE</code>.</p>
</td></tr>
<tr><td><code id="RCC_+3A_proxy.target">proxy.target</code></td>
<td>
<p>proxy target (string) in the form <code>&lt;host&gt;:&lt;port&gt;</code>
to be used when connecting to a non-transparent proxy that requires
target designation. Not used when connected to transparent proxies
or directly to Rserve instances. Note that literal IPv6 addresses must be
quoted in <code>[]</code>.</p>
</td></tr>
<tr><td><code id="RCC_+3A_proxy.wait">proxy.wait</code></td>
<td>
<p>if <code>TRUE</code> then the proxy will wait (indefinitely) if the
target is unavailable due to too high load, if <code>FALSE</code> then
the proxy is instructed to close the connection in such instance instead</p>
</td></tr>
<tr><td><code id="RCC_+3A_rsc">rsc</code></td>
<td>
<p>Rserve connection as obtained from <code>RS.connect</code></p>
</td></tr>
<tr><td><code id="RCC_+3A_user">user</code></td>
<td>
<p>username for authentication (mandatory)</p>
</td></tr>
<tr><td><code id="RCC_+3A_password">password</code></td>
<td>
<p>password for authentication</p>
</td></tr>
<tr><td><code id="RCC_+3A_pubkey">pubkey</code></td>
<td>
<p>public key for authentication</p>
</td></tr>
<tr><td><code id="RCC_+3A_authkey">authkey</code></td>
<td>
<p>authkey (as obtained from <code>RS.authkey</code>) for secure authentication</p>
</td></tr>
<tr><td><code id="RCC_+3A_x">x</code></td>
<td>
<p>expression to evaluate</p>
</td></tr>
<tr><td><code id="RCC_+3A_wait">wait</code></td>
<td>
<p>if <code>TRUE</code> then the result is delivered synchronously,
if <code>FALSE</code> then <code>NULL</code> is returned instead and the result
can be collected later with <code>RS.collect</code></p>
</td></tr>
<tr><td><code id="RCC_+3A_lazy">lazy</code></td>
<td>
<p>if <code>TRUE</code> then the passed expression is not evaluated
locally but passed for remote evaluation (as if quoted, modulo
substitution). Otherwise it is evaluated locally first and the
result is passed for remote evaluation.</p>
</td></tr>
<tr><td><code id="RCC_+3A_timeout">timeout</code></td>
<td>
<p>numeric, timeout (in seconds) to wait before giving up</p>
</td></tr>
<tr><td><code id="RCC_+3A_detail">detail</code></td>
<td>
<p>if <code>TRUE</code> then the result payload is returned in a
list with elements <code>value</code> (unserialized result value of the
command - where applicable) and <code>rsc</code> (connection which
returned this result) which allows to identify the source of the
result and to distinguish timeout from a <code>NULL</code>
value. Otherwise the returned value is just the payload value of the
result.</p>
</td></tr>
<tr><td><code id="RCC_+3A_name">name</code></td>
<td>
<p>string, name of the symbol to assign to</p>
</td></tr>
<tr><td><code id="RCC_+3A_value">value</code></td>
<td>
<p>value to assign &ndash; if missing <code>name</code> is assumed to
be a symbol and its evaluated value will be used as value while the
symbol name will be used as name</p>
</td></tr>
<tr><td><code id="RCC_+3A_protocol">protocol</code></td>
<td>
<p>protocol to switch to (string)</p>
</td></tr>
<tr><td><code id="RCC_+3A_type">type</code></td>
<td>
<p>type of the authentication to perform (string)</p>
</td></tr>
<tr><td><code id="RCC_+3A_send">send</code></td>
<td>
<p>callback function for <code>OOB_SEND</code></p>
</td></tr>
<tr><td><code id="RCC_+3A_msg">msg</code></td>
<td>
<p>callback function for <code>OOB_MSG</code></p>
</td></tr>
<tr><td><code id="RCC_+3A_text">text</code></td>
<td>
<p>string that will be parsed and evaluated on the server side</p>
</td></tr>
<tr><td><code id="RCC_+3A_filename">filename</code></td>
<td>
<p>name of the file (on the server!) to source</p>
</td></tr>
<tr><td><code id="RCC_+3A_qap">qap</code></td>
<td>
<p>logical, if <code>TRUE</code> then the result is assumed to be
in QAP encoding (native Rserve protocol), otherwise it is assumed to
be using R serialization.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RS.connect</code> creates a connection to a Rserve. The returned handle
is to be used in all subsequent calls to client functions. The session
associated witht he connection is alive until closed via
<code>RS.close</code>.
</p>
<p><code>RS.close</code> closes the Rserve connection.
</p>
<p><code>RS.login</code> performs authentication with the Rserve. The
<code>user</code> entry is mandatory and at least one of <code>password</code>,
<code>pubkey</code> and <code>authkey</code> must be provided. Typical secure
authentication is performed with
<code>RS.login(rsc, "username", "password", authkey=RS.authkey(rsc))</code>
which ensures that the authentication request is encrypted and cannot
be spoofed. When using TLS connections <code>RS.authkey</code> is not
necessary as the connection is already encrypted.
</p>
<p><code>RS.eval</code> evaluates the supplied expression remotely.
</p>
<p><code>RS.eval.qap</code> behaves like <code>RS.eval(..., lazy=FALSE)</code>, but
uses the Rserve QAP serialization of R objects instead of the native R
serialization.
</p>
<p><code>RS.collect</code> collects results from <code>RS.eval(..., wait =
    FALSE)</code> calls. Note that in this case <code>rsc</code> can be either one
connection or a list of connections.
</p>
<p><code>RS.assign</code> assigns a value to the remote global workspace.
</p>
<p><code>RS.switch</code> attempts to switch the protocol currently used for
communication with Rserve. Currently the only supported protocol
switch is from plain QAP1 to TLS secured (encrypted) QAP1.
</p>
<p><code>RS.oobCallbacks</code> sets or retrieves the callback functions
associated with <code>OOB_SEND</code> and <code>OOB_MSG</code> out-of-band
commands. If neither <code>send</code> nor <code>msg</code> is specified then
<code>RS.oobCallbacks</code> simply returns the current callback functions,
otherwise it replaces the existing ones. Both functions have the form
<code>function(code, payload)</code> where <code>code</code> is the OOB sub-code
(scalar integer) and <code>payload</code> is the content passed in the OOB
command. For <code>OOB_SEND</code> the result of the callback is disarded,
for <code>OOB_MSG</code> the result is encoded and sent back to the
server. Note that OOB commands in this client are only processed when
waiting for the response to another command (typically
<code>RS.eval</code>). OOB commands must be explicitly enabled in the
server in order to be used (they are disabled by default).
</p>
<p><code>RS.server.eval</code>, <code>RS.server.source</code> and
<code>RS.server.shutdown</code> are &lsquo;control commands&rsquo; which are enqueued to
be processed by the server asynchronously. They return <code>TRUE</code> on
success which means the command was enqueued - it does not mean that
the server has processed the command. All control commands affect only
future connections, they do NOT affect any already established client
connection (including the curretn one). <code>RS.server.eval</code> parses
and evaluates the given code in the server instance,
<code>RS.server.source</code> sources the given file in the server (the path
is interpreted by the server, it is not the local path of the client!)
and <code>RS.server.shutdown</code> attempts a clean shutdown of the
server. Note that control commands are disabled by default and must be
enabled in Rserve either in the configuration file with <code>control
  enable</code> or on the command line with <code>--RS-enable-control</code> (the
latter only works with Rserve 1.7 and higher). If Rserve is configured
with authentication enabled then only admin users can issues control
commands (see Rserve documentation for details).
</p>


<h3>Parallel use</h3>

<p>It is currently possible to use Rserve connections in parallel via
<code>mcparallel</code> or <code>mclapply</code> if certain conditions are
met. First, only clear connection (non-TLS) are eligible for parallel
use and there may be no OOB commands. Then it is legal to use
connections in forked process as long as both the request is sent and
the result is collected in the same process while no other process
uses the connection. However, connections can only be created in the
parent session (except if the connection is created and subsequently
closed in the child process).
</p>
<p>One possible use is to initiate connections to a cluster and perform
operations in parallel. For example:
</p>
<pre>    library(RSclient)
    library(parallel)
    ## try to connect to 50 different nodes
    ## cannot parallelize this - must be in the parent process
    c &lt;- lapply(paste("machine", 1:50, sep=''),
                function(name) try(RS.connect(name), silent=TRUE))
    ## keep only successful connections
    c &lt;- c[sapply(c, class) == "RserveConnection"]
    ## login to all machines in parallel (using RSA secured login)
    unlist(mclapply(c,
           function(c) RS.login(c, "user", "password",, RS.authkey(c)),
	   mc.cores=length(c)))
    ## do parallel work ...
    ## pre-load some "job" function to all nodes
    unlist(mclapply(c, function(c) RS.assign(c, job), mc.cores=length(c)))
    ## etc. etc. then call it in parallel on all nodes ...
    mclapply(c, function(c) RS.eval(c, job()), mc.cores=length(c))
    
    ## close all
    sapply(c, RS.close)
  </pre>


<h3>Note</h3>

<p>The current version of the <code>RSclient</code> package supplies two
clients - one documented in <code><a href="#topic+Rclient">Rclient</a></code> which uses R
connections and one documented in <code><a href="#topic+RCC">RCC</a></code> which uses C code
and is far more versatile and efficient. This is the documentation for
the latter which is new and supports features that are not supported
by R such as unix sockets, SSL/TLS connections, protocol switching,
secure authentication and multi-server collection.
</p>


<h3>Note</h3>

<p>The RSclient package can be compiled with TLS/SSL support based on
OpenSSL. Therefore the following statements may be true if RSclient
binaries are shipped together with OpenSSL: This product includes
software developed by the OpenSSL Project for use in the OpenSSL
Toolkit (http://www.openssl.org/). This product includes cryptographic
software written by Eric Young (eay@cryptsoft.com). This product
includes software written by Tim Hudson (tjh@cryptsoft.com).
They are not true otherwise.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  c &lt;- RS.connect()
  RS.eval(c, data(stackloss))
  RS.eval(c, library(MASS))
  RS.eval(c, rlm(stack.loss ~ ., stackloss)$coeff)
  RS.eval(c, getwd())
  x &lt;- rnorm(1e5)
  ## this sends the contents of x to the remote side and runs `sum` on
  ## it without actually creating the binding x on the remote side
  RS.eval(c, as.call(list(quote(sum), x)), lazy=FALSE)
  RS.close(c)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='Rclient'>Functions to talk to an Rserve</h2><span id='topic+Rclient'></span><span id='topic+RSconnect'></span><span id='topic+RSclose'></span><span id='topic+RSeval'></span><span id='topic+RSlogin'></span><span id='topic+RSdetach'></span><span id='topic+RSevalDetach'></span><span id='topic+RSattach'></span><span id='topic+RSassign'></span><span id='topic+RSshutdown'></span><span id='topic+RSserverEval'></span><span id='topic+RSserverSource'></span>

<h3>Description</h3>

<p>Rserve is a server providing R functionality via sockets. The
following functions allow another R session to start new Rserve
sessions and evaluate commands. The support is very rudimentary and
uses only a fraction of the funtionality provided by Rserve. The
typical use of Rserve is to connect to other applications, not
necessarily to connect two R processes. However, it is not uncommon to
have a cluster of Rserve machines so the following functions provide a
simple client access.
</p>
<p>For more complete cilent implementation see <code>src/clients</code>
directory of the Rserve distribution which show a C/C++ client. Also
available from the Rserve pages is a Java client
(<code>JRclient</code>). See <code>http://rosuda.org/Rserve</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSconnect(host = "localhost", port = 6311)
RSlogin(c, user, pwd, silent = FALSE)
RSeval(c, expr)
RSclose(c)
RSshutdown(c, pwd = NULL, ctrl = FALSE)
RSdetach(c)
RSevalDetach(c, cmd = "")
RSattach(session)
RSassign(c, obj, name = deparse(substitute(obj)) )
RSserverEval(c, expr)
RSserverSource(c, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rclient_+3A_host">host</code></td>
<td>
<p>host to connect to</p>
</td></tr>
<tr><td><code id="Rclient_+3A_port">port</code></td>
<td>
<p>TCP port to connect to</p>
</td></tr>
<tr><td><code id="Rclient_+3A_c">c</code></td>
<td>
<p>Rserve connection</p>
</td></tr>
<tr><td><code id="Rclient_+3A_user">user</code></td>
<td>
<p>username for authentication</p>
</td></tr>
<tr><td><code id="Rclient_+3A_pwd">pwd</code></td>
<td>
<p>password for authentication</p>
</td></tr>
<tr><td><code id="Rclient_+3A_cmd">cmd</code></td>
<td>
<p>command (as string) to evaluate</p>
</td></tr>
<tr><td><code id="Rclient_+3A_silent">silent</code></td>
<td>
<p>flag indicating whether a failure should raise an error
or not</p>
</td></tr>
<tr><td><code id="Rclient_+3A_session">session</code></td>
<td>
<p>session object as returned by <code>RSdetach</code> or
<code>RSevalDetach</code></p>
</td></tr>
<tr><td><code id="Rclient_+3A_obj">obj</code></td>
<td>
<p>value to assign</p>
</td></tr>
<tr><td><code id="Rclient_+3A_name">name</code></td>
<td>
<p>name to assign to on the remote side</p>
</td></tr>
<tr><td><code id="Rclient_+3A_expr">expr</code></td>
<td>
<p>R expression to evaluate remotely</p>
</td></tr>
<tr><td><code id="Rclient_+3A_file">file</code></td>
<td>
<p>path to a file on the server(!) that will be sourced into
the main instance</p>
</td></tr>
<tr><td><code id="Rclient_+3A_ctrl">ctrl</code></td>
<td>
<p>logical, if <code>TRUE</code> then control command
(<code>CMD_ctrlShutdown</code>) is used for shutdown, otherwise the
legacy <code>CMD_shutdown</code> is used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RSconnect</code> creates a connection to a Rserve. The returned handle
is to be used in all subsequent calls to client functions. The session
associated witht he connection is alive until closed via
<code>RSclose</code>.
</p>
<p><code>RSlogin</code> performs authentication with the Rserve. Currently this
simple client supports only plain text authentication, encryption is
not supported.
</p>
<p><code>RSclose</code> closes the Rserve connection.
</p>
<p><code>RSeval</code> evaluates the supplied expression
remotely. <code>expr</code> can be either a string or any R
expression. Use <code><a href="base.html#topic+quote">quote</a></code> to use unevaluated
expressions. The implementation of <code>RSeval</code> is very efficient
in that it does not require any buffer on the remote side and uses
native R serialization as the protocol. See exmples below for
correct use.
</p>
<p><code>RSdetach</code> detaches from the current Rserve connection. The
connection is closed but can be restored by using <code>RSattach</code> with
the value returned by <code>RSdetach</code>. Technically the R on the other
end is still running and waiting to be atached.
</p>
<p><code>RSshutdown</code> terminates the server gracefully. It should be
immediately followed by <code>RSclose</code> since the server closes the
connection. It can be issued only on a valid (authenticated)
connection. The password parameter is currently ignored since
password-protected shutdown is not yet supported. Please note that
you should not terminate servers that you did not start. More recent
Rserve installation can disable regular shutdown and only allow
control shutdown (avaiable to control users only) which is invoked
by specifying <code>ctrl=TRUE</code>.
</p>
<p><code>RSevalDetach</code> same as <code>RSdetach</code> but allows asynchronous
evaluation of the command. The remote Rserve is instructed to evaluate
the command after the connection is detached. Please note that the
session cannot be attached until the evaluation finished. Therefore it
is advisable to use another session when attaching to verify the
status of the detached session where necessary.
</p>
<p><code>RSattach</code> resume connection to an existing session in
Rserve. The <code>session</code> argument must have been previously returned
from the <code>RSdetach</code> or <code>RSevalDetach</code> comment.
</p>
<p><code>RSassign</code> pushes an object to Rserve and assigns it to the given
name. Note that the name can be an (unevaluated) R expression itself
thus allowing constructs such as <code>RSassign(c, 1:5,
  quote(a$foo))</code> which will result in <code>a$foo &lt;- 1:5</code>
remotely. However, character names are interpreted literarly.
</p>
<p><code>RSserverEval</code> and <code>RSserverSource</code> enqueue commands in the
server instance of Rserve, i.e. their effect will be visible for all
subsequent client connections. The Rserve instance must have control
commands enabled (not the default) in order to allow those
commands. <code>RSserverEval</code> evaluates the supplied expression and
<code>RSserverSource</code> sources the specified file - it must be a valid
path to a file on the server, not the client machine! Both commands
are executed asynchronously in the server, so the success of those
commands only means that they were queued on the server - they will be
executed between subsequent client connections. Note that only
subsequent connections will be affected, not the one issuing those
commands.
</p>


<h3>Author(s)</h3>

<p>Simon Urbanek</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  c &lt;- RSconnect()
  data(stackloss)
  RSassign(c, stackloss)
  RSeval(c, quote(library(MASS)))
  RSeval(c, quote(rlm(stack.loss ~ ., stackloss)$coeff))
  RSeval(c, "getwd()")
  
  image &lt;- RSeval(c, quote(try({
    attach(stackloss)
    library(Cairo)
    Cairo(file="plot.png")
    plot(Air.Flow,stack.loss,col=2,pch=19,cex=2)
    dev.off()
    readBin("plot.png", "raw", 999999)})))
  if (inherits(image, "try-error"))
    stop(image)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
