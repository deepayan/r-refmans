<!DOCTYPE html><html><head><title>Help for package frailtyEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frailtyEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoplot'><p>Generic autoplot function</p></a></li>
<li><a href='#autoplot.emfrail'><p>Plots for emfrail objects using <code>ggplot2</code></p></a></li>
<li><a href='#ca_test'><p>Commenges-Andersen test for heterogeneity</p></a></li>
<li><a href='#dist_to_pars'><p>dist_to_pars</p></a></li>
<li><a href='#emfrail'><p>Fitting semi-parametric shared frailty models with the EM algorithm</p></a></li>
<li><a href='#emfrail_control'><p>Control parameters for emfrail</p></a></li>
<li><a href='#emfrail_dist'><p>Distribution parameters for emfrail</p></a></li>
<li><a href='#emfrail_pll'><p>Profile log-likelihood calculation</p></a></li>
<li><a href='#Estep'><p>Perform the E step calculations</p></a></li>
<li><a href='#fast_Estep'><p>Fast fitting of the E step</p></a></li>
<li><a href='#frailtyEM-package'><p>frailtyEM: Fitting Frailty Models with the EM Algorithm</p></a></li>
<li><a href='#laplace_transform'><p>Laplace transform calculation</p></a></li>
<li><a href='#logLik.emfrail'><p>Log-likelihood for <code>emfrail</code> fitted models</p></a></li>
<li><a href='#plot.emfrail'><p>Plots for emfrail objects</p></a></li>
<li><a href='#predict.emfrail'><p>Predicted hazard and survival curves from an <code>emfrail</code> object</p></a></li>
<li><a href='#residuals.emfrail'><p>Residuals for frailty models</p></a></li>
<li><a href='#summary.emfrail'><p>Summary for <code>emfrail</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Frailty Models with the EM Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Theodor Adrian Balan, Hein Putter</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Theodor Adrian Balan &lt;hello@tbalan.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tbalan/frailtyEM">https://github.com/tbalan/frailtyEM</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tbalan/frailtyEM/issues">https://github.com/tbalan/frailtyEM/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions for fitting shared frailty models with a semi-parametric
    baseline hazard with the Expectation-Maximization algorithm. Supported data formats 
    include clustered failures with left truncation and recurrent events in gap-time
    or Andersen-Gill format. Several frailty distributions, such as the the gamma, positive stable
    and the Power Variance Family are supported. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.8), magrittr, msm, ggplot2, expint, tibble,
Matrix, numDeriv</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, plotly, gridExtra, egg</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'autoplot.emfrail.R' 'ca_test_cph.R'
'ca_test_fit.R' 'em_fit.R' 'emfrail_aux.R' 'emfrail.R'
'emfrail_arguments.R' 'emfrail_methods.R' 'fast_Estep.R'
'frailtyEM.R' 'plot.emfrail.R' 'predict.emfrail.R'
'print.emfrail.R' 'print.emfrail_summary.R' 'summary.emfrail.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-19 21:58:30 UTC; theodor</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-22 13:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoplot'>Generic autoplot function</h2><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>The following is imported and then re-exported to avoid conflicts with <code>ggplot2</code>
</p>

<hr>
<h2 id='autoplot.emfrail'>Plots for emfrail objects using <code>ggplot2</code></h2><span id='topic+autoplot.emfrail'></span>

<h3>Description</h3>

<p>Plots for emfrail objects using <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emfrail'
autoplot(object, type = c("hist", "hr", "pred",
  "frail"), newdata = NULL, lp = NULL, strata = NULL,
  quantity = "cumhaz", type_pred = c("conditional", "marginal"),
  conf_int = "adjusted", conf_level = 0.95, individual = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.emfrail_+3A_object">object</code></td>
<td>
<p><code>emfrail</code> object, typically result of <code>emfrail()</code></p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_type">type</code></td>
<td>
<p>One (or more) of <code>hist</code> for a histogram of the estimated frailty values,
<code>hr</code> for a plot of the conditional and marginal hazard ratio between two cases,
<code>pred</code> for the predicted conditional and marginal cumulative hazard or survival for one case,
<code>frail</code> for a caterpillar plot of the ordered frailty estimates with confidence intervals, where available.</p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> with values of the covariates. For <code>type == "hr"</code> the hazard ratio
between the first two rows of <code>newdata</code> is calculated. For <code>type == "pred"</code> the prediction
for the first row of <code>newdata</code> is calculated.</p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_lp">lp</code></td>
<td>
<p>A numeric vector of values of the linear predictor, each corresponding to a case. For <code>type == "hr"</code> the hazard ratio
between the first two values of <code>lp</code> is calculated. For <code>type == "pred"</code> the prediction
for the first value of <code>lp</code> is calculated.</p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_strata">strata</code></td>
<td>
<p>The name of the strata (if applicable) for which the prediction should be made.</p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_quantity">quantity</code></td>
<td>
<p>One of <code>c("cumhaz", "survival")</code> for <code>type == "pred"</code>; see <code>quantity</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_type_pred">type_pred</code></td>
<td>
<p>One of <code>c("conditional", "marginal")</code> for <code>type == "pred"</code>; see <code>type</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_conf_int">conf_int</code></td>
<td>
<p>One of <code>c("regular", "adjusted")</code> for <code>type == "pred"</code>; see <code>conf_int</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_conf_level">conf_level</code></td>
<td>
<p>The width of the confidence interval for <code>type == "pred"</code>; see <code>conf_level</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_individual">individual</code></td>
<td>
<p>Logical, for <code>type == "pred"</code> to be used for drawing a curve when the rows of <code>newdata</code> refer to the same individual; see
<code>individual</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="autoplot.emfrail_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to 'ggplot' (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>ggplot2</code> objects corresponding to the required plots, or one <code>ggplot2</code> if only one plot is selected
</p>
<p>For the catterpillar plot, in the case of the gamma frailty model, the vertical lines represent the 0.025 and 0.975 quantiles of the
posterior gamma distribution. For other distributions, this quantity is not easy to calculate (at least not in closed form)
and only the frailty estimates are shown.
</p>


<h3>Note</h3>

<p>It's normal for <code>autoplot</code> to give a warning of the type <code>Warning: Ignoring unknown aesthetics: id
</code>. This is because, in <code>ggplot2</code> terms, the <code>id</code> aesthetic is not recognized. This is correct, and for any
practical purpose this will not make a difference (you can safely ignore the warnings). However, this makes it
easier to create an interactive plot out of the resulting object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.emfrail">predict.emfrail</a></code>, <code><a href="#topic+summary.emfrail">summary.emfrail</a></code>, <code><a href="#topic+plot.emfrail">plot.emfrail</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod_rec &lt;- emfrail(Surv(start, stop, status) ~ treatment + number + cluster(id), bladder1,
control = emfrail_control(ca_test = FALSE, lik_ci = FALSE))

# Histogram of the estimated frailties
autoplot(mod_rec, type = "hist")

# Ordered estimated frailties (with confidence intervals, for gamma distribution)
autoplot(mod_rec, type = "frail")

# hazard ratio between placebo and pyridoxine
newdata1 &lt;- data.frame(treatment = c("placebo", "pyridoxine"),
                       number = c(1, 3))

autoplot(mod_rec, type = "hr", newdata = newdata1)

# predicted cumulative hazard for placebo, and number = 1
autoplot(mod_rec, type = "pred", newdata = newdata1[1,])

# predicted survival for placebo, and number = 1
autoplot(mod_rec, type = "pred", quantity = "survival", newdata = newdata1[1,])

# predicted survival for an individual that switches from
# placebo to pyridoxine at time = 15
## Not run: 
newdata2 &lt;- data.frame(treatment = c("placebo", "pyridoxine"),
                       number = c(1, 3),
                       tstart = c(0, 15),
                       tstop = c(15, Inf))

autoplot(mod_rec, type = "pred", quantity = "survival", newdata = newdata2, individual = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ca_test'>Commenges-Andersen test for heterogeneity</h2><span id='topic+ca_test'></span>

<h3>Description</h3>

<p>Commenges-Andersen test for heterogeneity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca_test(object, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca_test_+3A_object">object</code></td>
<td>
<p>A <code>coxph</code> object with a <code>cluster()</code> statement in the right-hand side of the formula.</p>
</td></tr>
<tr><td><code id="ca_test_+3A_id">id</code></td>
<td>
<p>Optionally, a vector determining the grouping to be tested. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cox model with a <code>+cluster()</code> statement has the same point estimates
as the one without that statmenet. The only difference is in the adjusted standard errors.
In some cases, a model with <code>+cluster()</code> statments can't be fitted. For example, when there
are no covariates. In that case, a vector may be passed on in the <code>cluster</code> argument.
</p>


<h3>Value</h3>

<p>A named vector containing the test statistic, variance, and p-value
</p>


<h3>References</h3>

<p>Commenges, D. and Andersen, P.K., 1995. Score test of homogeneity for survival data. Lifetime Data Analysis, 1(2), pp.145-156.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcox1 &lt;- coxph(Surv(time, status) ~ rx + sex + cluster(litter),
rats, model = TRUE, x = TRUE)
ca_test(mcox1)

mcox2 &lt;- coxph(Surv(time, status) ~ 1, rats, x = TRUE)
ca_test(mcox2, rats$litter)
</code></pre>

<hr>
<h2 id='dist_to_pars'>dist_to_pars</h2><span id='topic+dist_to_pars'></span>

<h3>Description</h3>

<p>dist_to_pars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_to_pars(dist, logfrailtypar, pvfm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_to_pars_+3A_dist">dist</code></td>
<td>
<p>One of gamma, stable, pvf</p>
</td></tr>
<tr><td><code id="dist_to_pars_+3A_logfrailtypar">logfrailtypar</code></td>
<td>
<p>The log of theta</p>
</td></tr>
<tr><td><code id="dist_to_pars_+3A_pvfm">pvfm</code></td>
<td>
<p>The pvfm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 elements: alpha, beta (the parameters of the Laplace transform) and dist_id.
</p>

<hr>
<h2 id='emfrail'>Fitting semi-parametric shared frailty models with the EM algorithm</h2><span id='topic+emfrail'></span>

<h3>Description</h3>

<p>Fitting semi-parametric shared frailty models with the EM algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emfrail(formula, data, distribution = emfrail_dist(),
  control = emfrail_control(), model = FALSE, model.matrix = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emfrail_+3A_formula">formula</code></td>
<td>
<p>A formula that contains on the left hand side an object of the type <code>Surv</code>
and on the right hand side a <code>+cluster(id)</code> statement. Two special statments may also be used:
<code>+strata()</code> for specifying a grouping column that will represent different strata and
<code>+terminal()</code></p>
</td></tr>
<tr><td><code id="emfrail_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which the formula argument can be evaluated</p>
</td></tr>
<tr><td><code id="emfrail_+3A_distribution">distribution</code></td>
<td>
<p>An object as created by <code><a href="#topic+emfrail_dist">emfrail_dist</a></code></p>
</td></tr>
<tr><td><code id="emfrail_+3A_control">control</code></td>
<td>
<p>An object as created by <code><a href="#topic+emfrail_control">emfrail_control</a></code></p>
</td></tr>
<tr><td><code id="emfrail_+3A_model">model</code></td>
<td>
<p>Logical. Should the model frame be returned?</p>
</td></tr>
<tr><td><code id="emfrail_+3A_model.matrix">model.matrix</code></td>
<td>
<p>Logical. Should the model matrix be returned?</p>
</td></tr>
<tr><td><code id="emfrail_+3A_...">...</code></td>
<td>
<p>Other arguments, currently used to warn about deprecated argument names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>emfrail</code> function fits shared frailty models for processes which have intensity
</p>
<p style="text-align: center;"><code class="reqn">\lambda(t) = z \lambda_0(t) \exp(\beta' \mathbf{x})</code>
</p>

<p>with a non-parametric (Breslow) baseline intensity <code class="reqn">\lambda_0(t)</code>. The outcome
(left hand side of the <code>formula</code>) must be a <code>Surv</code> object.
</p>
<p>If the object is <code>Surv(tstop, status)</code> then the usual failure time data is represented.
Gap-times between recurrent events are represented in the same way.
If the left hand side of the formula is created as <code>Surv(tstart, tstop, status)</code>, this may represent a number of things:
(a) recurrent events episodes in calendar time where a recurrent event episode starts at <code>tstart</code> and ends at <code>tstop</code>
(b) failure time data with time-dependent covariates where <code>tstop</code> is the time of a change in covariates or censoring
(<code>status = 0</code>) or an event time (<code>status = 1</code>) or (c) clustered failure time with left truncation, where
<code>tstart</code> is the individual's left truncation time. Unlike regular Cox models, a major distinction is that in case (c) the
distribution of the frailty must be considered conditional on survival up to the left truncation time.
</p>
<p>The <code>+cluster()</code> statement specified the column that determines the grouping (the observations that share the same frailty).
The <code>+strata()</code> statement specifies a column that determines different strata, for which different baseline hazards are calculated.
The <code>+terminal</code> specifies a column that contains an indicator for dependent censoring, and then performs a score test
</p>
<p>The <code>distribution</code> argument must be generated by a call to <code><a href="#topic+emfrail_dist">emfrail_dist</a></code>. This determines the
frailty distribution, which may be one of gamma, positive stable or PVF (power-variance-function), and the starting
value for the maximum likelihood estimation. The PVF family
also includes a tuning parameter that differentiates between inverse Gaussian and compound Poisson distributions.
Note that, with univariate data (at most one event per individual, no clusters), only distributions with finite expectation
are identifiable. This means that the positive stable distribution should have a maximum likelihood on the edge of the parameter
space (<code class="reqn">theta = +\inf</code>, corresponding to a Cox model for independent observations).
</p>
<p>The <code>control</code> argument must be generated by a call to <code><a href="#topic+emfrail_control">emfrail_control</a></code>. Several parameters
may be adjusted that control the precision of the convergenge criteria or supress the calculation of different
quantities.
</p>


<h3>Value</h3>

<p>An object of class <code>emfrail</code> that contains the following fields:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>A named vector of the estimated regression coefficients</p>
</td></tr>
<tr><td><code>hazard</code></td>
<td>
<p>The breslow estimate of the baseline hazard at each event time point, in chronological order</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The variance-covariance matrix corresponding to the coefficients and hazard, assuming <code class="reqn">\theta</code> constant</p>
</td></tr>
<tr><td><code>var_adj</code></td>
<td>
<p>The variance-covariance matrx corresponding to the
coefficients and hazard, adjusted for the estimation of theta</p>
</td></tr>
<tr><td><code>logtheta</code></td>
<td>
<p>The logarithm of the point estimate of <code class="reqn">\theta</code>. For the gamma and
PVF family of distributions, this is the inverse of the estimated frailty variance.</p>
</td></tr>
<tr><td><code>var_logtheta</code></td>
<td>
<p>The variance of the estimated logarithm of <code class="reqn">\theta</code></p>
</td></tr>
<tr><td><code>ci_logtheta</code></td>
<td>
<p>The likelihood-based 95% confidence interval for the logarithm of <code class="reqn">\theta</code></p>
</td></tr>
<tr><td><code>frail</code></td>
<td>
<p>The posterior (empirical Bayes) estimates of the frailty for each cluster</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>A list with two elements, cluster which is a vector that the sum of the
cumulative hazards from each cluster for a frailty value of 1, and
individual, which is a vector that contains the cumulative hazard corresponding to each row of the data,
multiplied by the corresponding frailty estimate</p>
</td></tr>
<tr><td><code>tev</code></td>
<td>
<p>The time points of the events in the data set, this is the same length as hazard</p>
</td></tr>
<tr><td><code>nevents_id</code></td>
<td>
<p>The number of events for each cluster</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>A vector of length two with the log-likelihood of the starting Cox model
and the maximized log-likelihood</p>
</td></tr>
<tr><td><code>ca_test</code></td>
<td>
<p>The results of the Commenges-Andersen test for heterogeneity</p>
</td></tr>
<tr><td><code>cens_test</code></td>
<td>
<p>The results of the test for dependence between a recurrent event and a terminal event,
if the <code>+terminal()</code> statement is specified and the frailty distribution is gamma</p>
</td></tr>
<tr><td><code>zph</code></td>
<td>
<p>The result of <code>cox.zph</code> called on a model with the estimated log-frailties as offset</p>
</td></tr>
<tr><td><code>formula</code>, <code>distribution</code>, <code>control</code></td>
<td>
<p>The original arguments</p>
</td></tr>
<tr><td><code>nobs</code>, <code>fitted</code></td>
<td>
<p>Number of observations and fitted values (i.e. <code class="reqn">z \exp(\beta^T x)</code>)</p>
</td></tr>
<tr><td><code>mf</code></td>
<td>
<p>The <code>model.frame</code>, if <code>model = TRUE</code></p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>The <code>model.matrix</code>, if <code>model.matrix = TRUE</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>Several options in the <code>control</code> arguemnt shorten the running time for <code>emfrail</code> significantly.
These are disabling the adjustemnt of the standard errors (<code>se_adj = FALSE</code>), disabling the likelihood-based confidence intervals (<code>lik_ci = FALSE</code>) or
disabling the score test for heterogeneity (<code>ca_test = FALSE</code>).
</p>
<p>The algorithm is detailed in the package vignette. For the gamma frailty,
the results should be identical with those from <code>coxph</code> with <code>ties = "breslow"</code>.
</p>


<h3>Author(s)</h3>

<p>Theodor Balan <a href="mailto:hello@tbalan.com">hello@tbalan.com</a>
</p>


<h3>References</h3>

<p>Balan TA, Putter H (2019) &quot;frailtyEM: An R Package for Estimating Semiparametric Shared Frailty Models&quot;, <em>Journal of Statistical Software</em> <strong>90</strong>(7) 1-29. doi:10.18637/jss.v090.i07
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.emfrail">plot.emfrail</a></code> and <code><a href="#topic+autoplot.emfrail">autoplot.emfrail</a></code> for plot functions directly available, <code><a href="#topic+emfrail_pll">emfrail_pll</a></code> for calculating <code class="reqn">\widehat{L}(\theta)</code> at specific values of <code class="reqn">\theta</code>,
<code><a href="#topic+summary.emfrail">summary.emfrail</a></code> for transforming the <code>emfrail</code> object into a more human-readable format and for
visualizing the frailty (empirical Bayes) estimates,
<code><a href="#topic+predict.emfrail">predict.emfrail</a></code> for calculating and visalizing conditional and marginal survival and cumulative
hazard curves. <code><a href="#topic+residuals.emfrail">residuals.emfrail</a></code> for extracting martingale residuals and <code><a href="#topic+logLik.emfrail">logLik.emfrail</a></code> for extracting
the log-likelihood of the fitted model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m_gamma &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                   data =  rats)

# Inverse Gaussian distribution
m_ig &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                data =  rats,
                distribution = emfrail_dist(dist = "pvf"))

# for the PVF distribution with m = 0.75
m_pvf &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                 data =  rats,
                 distribution = emfrail_dist(dist = "pvf", pvfm = 0.75))

# for the positive stable distribution
m_ps &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                data =  rats,
                distribution = emfrail_dist(dist = "stable"))
## Not run: 
# Compare marginal log-likelihoods
models &lt;- list(m_gamma, m_ig, m_pvf, m_ps)

models
logliks &lt;- lapply(models, logLik)

names(logliks) &lt;- lapply(models,
                         function(x) with(x$distribution,
                                          ifelse(dist == "pvf",
                                                 paste(dist, "/", pvfm),
                                                 dist))
)

logliks

## End(Not run)

# Stratified analysis
## Not run: 
  m_strat &lt;- emfrail(formula = Surv(time, status) ~  rx + strata(sex) + cluster(litter),
                     data =  rats)

## End(Not run)


# Test for conditional proportional hazards (log-frailty as offset)
## Not run: 
m_gamma &lt;- emfrail(formula = Surv(time, status) ~  rx + sex + cluster(litter),
  data =  rats, control = emfrail_control(zph = TRUE))
par(mfrow = c(1,2))
plot(m_gamma$zph)

## End(Not run)

# Draw the profile log-likelihood
## Not run: 
  fr_var &lt;- seq(from = 0.01, to = 1.4, length.out = 20)

  # For gamma the variance is 1/theta (see parametrizations)
  pll_gamma &lt;- emfrail_pll(formula = Surv(time, status) ~  rx + sex + cluster(litter),
                           data =  rats,
                           values = 1/fr_var )
  plot(fr_var, pll_gamma,
       type = "l",
       xlab = "Frailty variance",
       ylab = "Profile log-likelihood")


  # Recurrent events
  mod_rec &lt;- emfrail(Surv(start, stop, status) ~ treatment + cluster(id), bladder1)
  # The warnings appear from the Surv object, they also appear in coxph.

  plot(mod_rec, type = "hist")

## End(Not run)

# Left truncation
## Not run: 
  # We simulate some data with truncation times
  set.seed(2018)
  nclus &lt;- 300
  nind &lt;- 5
  x &lt;- sample(c(0,1), nind * nclus, TRUE)
  u &lt;- rep(rgamma(nclus,1,1), each = 3)

  stime &lt;- rexp(nind * nclus, rate = u * exp(0.5 * x))

  status &lt;- ifelse(stime &gt; 5, 0, 1)
  stime[status == 0] &lt;- 5

  # truncate uniform between 0 and 2
  ltime &lt;- runif(nind * nclus, min = 0, max = 2)

  d &lt;- data.frame(id = rep(1:nclus, each = nind),
                  x = x,
                  stime = stime,
                  u = u,
                  ltime = ltime,
                  status = status)
  d_left &lt;- d[d$stime &gt; d$ltime,]

  mod &lt;- emfrail(Surv(stime, status)~ x + cluster(id), d)
  # This model ignores the left truncation, 0.378 frailty variance:
  mod_1 &lt;- emfrail(Surv(stime, status)~ x + cluster(id), d_left)

  # This model takes left truncation into account,
 # but it considers the distribution of the frailty unconditional on the truncation
 mod_2 &lt;- emfrail(Surv(ltime, stime, status)~ x + cluster(id), d_left)

  # This is identical with:
  mod_cox &lt;- coxph(Surv(ltime, stime, status)~ x + frailty(id), data = d_left)


  # The correct thing is to consider the distribution of the frailty given the truncation
  mod_3 &lt;- emfrail(Surv(ltime, stime, status)~ x + cluster(id), d_left,
                   distribution = emfrail_dist(left_truncation = TRUE))

  summary(mod_1)
  summary(mod_2)
  summary(mod_3)

## End(Not run)
</code></pre>

<hr>
<h2 id='emfrail_control'>Control parameters for emfrail</h2><span id='topic+emfrail_control'></span>

<h3>Description</h3>

<p>Control parameters for emfrail
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emfrail_control(opt_fit = TRUE, se = TRUE, se_adj = TRUE,
  ca_test = TRUE, lik_ci = TRUE, lik_interval = exp(c(-3, 20)),
  lik_interval_stable = exp(c(0, 20)), nlm_control = list(stepmax = 1),
  zph = FALSE, zph_transform = "km", em_control = list(eps = 1e-04,
  maxit = Inf, fast_fit = TRUE, verbose = FALSE, upper_tol = exp(10),
  lik_tol = 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emfrail_control_+3A_opt_fit">opt_fit</code></td>
<td>
<p>Logical. Whether the outer optimization should be carried out.
If <code>FALSE</code>, then the frailty parameter is treated as fixed and the <code>emfrail</code> function returns only log-likelihood. See details.</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_se">se</code></td>
<td>
<p>Logical. Whether to calculate the variance / covariance matrix.</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_se_adj">se_adj</code></td>
<td>
<p>Logical. Whether to calculate the adjusted variance / covariance matrix (needs <code>se == TRUE</code>)</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_ca_test">ca_test</code></td>
<td>
<p>Logical. Should the Commenges-Andersen test be calculated?</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_lik_ci">lik_ci</code></td>
<td>
<p>Logical. Should likelihood-based confidence interval be calculated for the frailty parameter?</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_lik_interval">lik_interval</code></td>
<td>
<p>The edges, on the scale of <code class="reqn">\theta</code>, of the parameter space in which to search for likelihood-based confidence interval</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_lik_interval_stable">lik_interval_stable</code></td>
<td>
<p>(for dist = &quot;stable&quot;) The edges, on the scale of <code class="reqn">\theta</code>, of the parameter space in which to search for likelihood-based confidence interval</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_nlm_control">nlm_control</code></td>
<td>
<p>A list of named arguments to be sent to <code>nlm</code> for the outer optimization.</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_zph">zph</code></td>
<td>
<p>Logical. Should the <code>cox.zph</code> test be performed at the maximum likelihood estimate?</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_zph_transform">zph_transform</code></td>
<td>
<p>One of <code>"km", "rank", "identity"</code> or a function of one argument to be pased on to <code>cox.zph</code>.</p>
</td></tr>
<tr><td><code id="emfrail_control_+3A_em_control">em_control</code></td>
<td>
<p>A list of parameters for the inner optimization. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nlm_control</code> argument should not overalp with <code>hessian</code>, <code>f</code> or <code>p</code>.
</p>
<p>The <code>em_control</code> argument should be a list with the following items:
</p>

<ul>
<li><p><code>eps</code> A criterion for convergence of the EM algorithm (difference between two consecutive values of the log-likelihood)
</p>
</li>
<li><p><code>maxit</code> The maximum number of iterations between the E step and the M step
</p>
</li>
<li><p><code>fast_fit</code> Logical, whether the closed form formulas should be used for the E step when available
</p>
</li>
<li><p><code>verbose</code> Logical, whether details of the optimization should be printed
</p>
</li>
<li><p><code>upper_tol</code> An upper bound for <code class="reqn">\theta</code>; after this treshold, the algorithm returns the limiting log-likelihood of the no-frailty model.
That is because the no-frailty scenario corresponds to a <code class="reqn">\theta = \infty</code>, which could lead to some numerical issues
</p>
</li>
<li><p><code>lik_tol</code> For values higher than this, the algorithm returns a warning when the log-likelihood decreases between EM steps. Technically, this should not happen, but
if the parameter <code class="reqn">\theta</code> is somewhere really far from the maximum, numerical problems might lead in very small likelihood decreases.
</p>
</li></ul>

<p>The <code>fast_fit</code> option make a difference when the distribution is gamma (with or without left truncation) or
inverse Gaussian, i.e. pvf with m = -1/2 (without left truncation). For all the other scenarios, the fast_fit option will
automatically be changed to FALSE. When the number of events in a cluster / individual is not very small, the cases for which
fast fitting is available will show an improvement in performance.
</p>
<p>The starting value of the outer optimization may be set in the <code>distribution</code> argument.
</p>


<h3>Value</h3>

<p>An object of the type <code>emfrail_control</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emfrail">emfrail</a></code>, <code><a href="#topic+emfrail_dist">emfrail_dist</a></code>, <code><a href="#topic+emfrail_pll">emfrail_pll</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emfrail_control()
emfrail_control(em_control = list(eps = 1e-7))

</code></pre>

<hr>
<h2 id='emfrail_dist'>Distribution parameters for emfrail</h2><span id='topic+emfrail_dist'></span>

<h3>Description</h3>

<p>Distribution parameters for emfrail
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emfrail_dist(dist = "gamma", theta = 2, pvfm = -1/2,
  left_truncation = FALSE, basehaz = "breslow")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emfrail_dist_+3A_dist">dist</code></td>
<td>
<p>One of 'gamma', 'stable' or 'pvf'.</p>
</td></tr>
<tr><td><code id="emfrail_dist_+3A_theta">theta</code></td>
<td>
<p>A starting value for the 'outer' maximization with respect to the frailty parameter <code class="reqn">\theta</code>. Must be &gt;0.</p>
</td></tr>
<tr><td><code id="emfrail_dist_+3A_pvfm">pvfm</code></td>
<td>
<p>Only relevant if <code>dist = 'pvf'</code> is used. It determines which PVF distribution should be used. Must be  larger than -1 and not equal to 0.</p>
</td></tr>
<tr><td><code id="emfrail_dist_+3A_left_truncation">left_truncation</code></td>
<td>
<p>Logical. Whether the data set represents left truncated survival times.</p>
</td></tr>
<tr><td><code id="emfrail_dist_+3A_basehaz">basehaz</code></td>
<td>
<p>A character string which determines how the baseline hazard is calculated. The default is &quot;breslow&quot;, but other possible options are &quot;weibull&quot;, &quot;exponential&quot; &quot;gaussian&quot;, &quot;logistic&quot;, &quot;lognormal&quot; or &quot;loglogistic&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>theta</code> argument must be positive. In the case of gamma or PVF, this is the inverse of
the frailty variance, i.e. the larger the <code>theta</code> is,
the closer the model is to a Cox model. When <code>dist = "pvf"</code> and <code>pvfm = -0.5</code>, the inverse Gaussian
distribution is obtained. For the positive stable distribution, the <code class="reqn">\gamma</code> parameter of the Laplace transform is
<code class="reqn">\theta / (1 + \theta)</code>, with the <code class="reqn">alpha</code> parameter fixed to 1.
</p>


<h3>Value</h3>

<p>An object of the type <code>emfrail_dist</code>, which is mostly used to denote the
supported frailty distributions in a consistent way.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emfrail">emfrail</a>, <a href="#topic+emfrail_control">emfrail_control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>emfrail_dist()
# Compound Poisson distribution:
emfrail_dist(dist = 'pvf', theta = 1.5, pvfm = 0.5)
# Inverse Gaussian distribution:
emfrail_dist(dist = 'pvf')
</code></pre>

<hr>
<h2 id='emfrail_pll'>Profile log-likelihood calculation</h2><span id='topic+emfrail_pll'></span>

<h3>Description</h3>

<p>Profile log-likelihood calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emfrail_pll(formula, data, distribution = emfrail_dist(), values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emfrail_pll_+3A_formula">formula</code></td>
<td>
<p>Same as in <code>emfrail</code></p>
</td></tr>
<tr><td><code id="emfrail_pll_+3A_data">data</code></td>
<td>
<p>Same as in <code>emfrail</code></p>
</td></tr>
<tr><td><code id="emfrail_pll_+3A_distribution">distribution</code></td>
<td>
<p>Same as in <code>emfrail</code></p>
</td></tr>
<tr><td><code id="emfrail_pll_+3A_values">values</code></td>
<td>
<p>A vector of values on where to calculate the profile likelihood. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to calculate the profile log-likelihood for different values of <code class="reqn">\theta</code>.
The scale is that of <code>theta</code> as defined in <code>emfrail_dist()</code>.
For the gamma and pvf frailty, that is the inverse of the frailty variance.
</p>


<h3>Value</h3>

<p>The profile log-likelihood at the specific value of the frailty parameter
</p>


<h3>Note</h3>

<p>This function is just a simple wrapper for <code>emfrail()</code> with the <code>control</code> argument
a call from <code>emfrail_control</code> with the option <code>opt_fit = FALSE</code>. More flexibility can be obtained
by calling <code>emfrail</code> with this option, especially
for setting other <code>emfrail_control</code> parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fr_var &lt;- seq(from = 0.01, to = 1.4, length.out = 20)
pll_gamma &lt;- emfrail_pll(formula = Surv(time, status) ~  rx + sex + cluster(litter),
 data =  rats,
 values = 1/fr_var )
 plot(fr_var, pll_gamma,
     type = "l",
     xlab = "Frailty variance",
     ylab = "Profile log-likelihood")

# check with coxph;
# attention: theta is the the inverse frailty variance in emfrail,
# but theta is the frailty variance in coxph.

pll_cph &lt;- sapply(fr_var, function(th)
  coxph(data =  rats, formula = Surv(time, status) ~ rx + sex + frailty(litter, theta = th),
        method = "breslow")$history[[1]][[3]])

lines(fr_var, pll_cph, col = 2)

# Same for inverse gaussian
pll_if &lt;- emfrail_pll(Surv(time, status) ~  rx + sex + cluster(litter),
                      rats,
                      distribution = emfrail_dist(dist = "pvf"),
                      values = 1/fr_var )

# Same for pvf with a positive pvfm parameter
pll_pvf &lt;- emfrail_pll(Surv(time, status) ~  rx + sex + cluster(litter),
                       rats,
                       distribution = emfrail_dist(dist = "pvf", pvfm = 1.5),
                       values = 1/fr_var )

miny &lt;- min(c(pll_gamma, pll_cph, pll_if, pll_pvf))
maxy &lt;- max(c(pll_gamma, pll_cph, pll_if, pll_pvf))

plot(fr_var, pll_gamma,
     type = "l",
     xlab = "Frailty variance",
     ylab = "Profile log-likelihood",
     ylim = c(miny, maxy))
points(fr_var, pll_cph, col = 2)
lines(fr_var, pll_if, col = 3)
lines(fr_var, pll_pvf, col = 4)

legend(legend = c("gamma (emfrail)", "gamma (coxph)", "inverse gaussian", "pvf, m=1.5"),
       col = 1:4,
       lty = 1,
       x = 0,
       y = (maxy + miny)/2)
</code></pre>

<hr>
<h2 id='Estep'>Perform the E step calculations</h2><span id='topic+Estep'></span>

<h3>Description</h3>

<p>This is an inner wrapper for the C++ functions which perform the E step and is not intended to be used directly.
This function does not check the input.
For a data set with <code>K</code> clusters,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estep(c, c_lt, delta, alpha, bbeta, pvfm, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estep_+3A_c">c</code></td>
<td>
<p>Vector of length <code>K</code> of cumulative hazards, i.e. total accumulated hazards within a cluster</p>
</td></tr>
<tr><td><code id="Estep_+3A_c_lt">c_lt</code></td>
<td>
<p>Vector of length <code>K</code> of cumulative hazard from 0 to the left truncation time</p>
</td></tr>
<tr><td><code id="Estep_+3A_delta">delta</code></td>
<td>
<p>Vector of integers of length <code>K</code> of the number of events for each cluster</p>
</td></tr>
<tr><td><code id="Estep_+3A_alpha">alpha</code>, <code id="Estep_+3A_bbeta">bbeta</code></td>
<td>
<p>Parameters of the frailty distribution</p>
</td></tr>
<tr><td><code id="Estep_+3A_pvfm">pvfm</code></td>
<td>
<p>Parameter for the PVF distribution, only matters in that case</p>
</td></tr>
<tr><td><code id="Estep_+3A_dist">dist</code></td>
<td>
<p>One of 0 (for gamma), 1 (for stable) or 2 (for PVF)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>K x 3</code> matrix where the first column and the second column are the numerators
and the denominators of the frailty fraction (without the Laplace transform) and the
last column is the log(denominator) + log-Laplace transform, i.e. the log-likelihood contribution
</p>

<hr>
<h2 id='fast_Estep'>Fast fitting of the E step</h2><span id='topic+fast_Estep'></span>

<h3>Description</h3>

<p>This function calculates the E step in a quicker way, without taking all the derivatives of the Laplace transform.
Such closed form solutions are only available for the gamma distribution (with or without left truncation) and
for the inverse Gaussian distribution (without left truncation).
For a data set with <code>K</code> clusters,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_Estep(c, c_lt = 0, delta, alpha, bbeta, pvfm, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_Estep_+3A_c">c</code></td>
<td>
<p>Vector of length <code>K</code> of cumulative hazards, i.e. total accumulated hazards within a cluster</p>
</td></tr>
<tr><td><code id="fast_Estep_+3A_c_lt">c_lt</code></td>
<td>
<p>Vector of length <code>K</code> of cumulative hazard from 0 to the left truncation time</p>
</td></tr>
<tr><td><code id="fast_Estep_+3A_delta">delta</code></td>
<td>
<p>Vector of integers of length <code>K</code> of the number of events for each cluster</p>
</td></tr>
<tr><td><code id="fast_Estep_+3A_alpha">alpha</code>, <code id="fast_Estep_+3A_bbeta">bbeta</code></td>
<td>
<p>Parameters of the frailty distribution</p>
</td></tr>
<tr><td><code id="fast_Estep_+3A_pvfm">pvfm</code></td>
<td>
<p>Parameter for the PVF distribution, only matters in that case</p>
</td></tr>
<tr><td><code id="fast_Estep_+3A_dist">dist</code></td>
<td>
<p>One of 0 (for gamma), 1 (for stable) or 2 (for PVF)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>K x 4</code> matrix where the first column and the second column are the numerators
and the denominators of the frailty fraction, the third is the log-likelihood contribution, and the
last column is the expectation of the squared frailty (only used in calculating the information matrix)
</p>

<hr>
<h2 id='frailtyEM-package'>frailtyEM: Fitting Frailty Models with the EM Algorithm</h2><span id='topic+frailtyEM'></span><span id='topic+frailtyEM-package'></span>

<h3>Description</h3>

<p>Contains functions for fitting shared frailty models with a semi-parametric
baseline hazard with the Expectation-Maximization algorithm. Supported data formats 
include clustered failures with left truncation and recurrent events in gap-time
or Andersen-Gill format. Several frailty distributions, such as the the gamma, positive stable
and the Power Variance Family are supported.
</p>


<h3>Details</h3>

<p>This is an R package for fitting semiparametric shared frailty models with the EM algorithm.
You can check the &quot;issues&quot; section Github (link below)
For the gamma frailty model, the results are identical with those from the survival pacakage,
although frailtyEM provides a more readable output, including confidence intervals for the frailty variance.
Other supported distributions include the PVF, compound Poisson, inverse Gaussian, positive stable.
Univariate and multivariate data with left truncation are supported,
including recurrent events data in Andersen-Gill formulation.
</p>
<p>For background on the methods and basic usage of the package, see the paper in the references or the package vignette.
The main fitting function is <code><a href="#topic+emfrail">emfrail</a></code>. For prediction, see <code><a href="#topic+predict.emfrail">predict.emfrail</a></code> and for
plotting, <code><a href="#topic+autoplot.emfrail">autoplot.emfrail</a></code> (recommended, uses ggplot2) or <code><a href="#topic+plot.emfrail">plot.emfrail</a></code>.
</p>


<h3>Author(s)</h3>

<p>Theodor Balan <a href="mailto:hello@tbalan.com">hello@tbalan.com</a>
</p>


<h3>References</h3>

<p>Balan TA, Putter H (2019) &quot;frailtyEM: An R Package for Estimating Semiparametric Shared Frailty Models&quot;, <em>Journal of Statistical Software</em> <strong>90</strong>(7) 1-29. doi:10.18637/jss.v090.i07
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/tbalan/frailtyEM">https://github.com/tbalan/frailtyEM</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tbalan/frailtyEM/issues">https://github.com/tbalan/frailtyEM/issues</a>
</p>
</li></ul>


<hr>
<h2 id='laplace_transform'>Laplace transform calculation</h2><span id='topic+laplace_transform'></span>

<h3>Description</h3>

<p>Laplace transform calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplace_transform(x, distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplace_transform_+3A_x">x</code></td>
<td>
<p>A vector of positive values where to calculate the Laplace transform</p>
</td></tr>
<tr><td><code id="laplace_transform_+3A_distribution">distribution</code></td>
<td>
<p>An <code>emfrail_dist</code> object. See <code>?emfrail_dist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple function which calculates the Laplace transform for the gamma, positive stable and PVF distribution.
It is intended to be used to calculate marginal quantities from an <code>emfrail</code> object.
Note that the <code>left_truncation</code> argument is ignored here;
the marginal survival or hazard are given for the Laplace transform of a baseline subject entered at time 0.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> with the Laplace transform of <code>x</code>
</p>

<hr>
<h2 id='logLik.emfrail'>Log-likelihood for <code>emfrail</code> fitted models</h2><span id='topic+logLik.emfrail'></span>

<h3>Description</h3>

<p>Log-likelihood for <code>emfrail</code> fitted models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emfrail'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.emfrail_+3A_object">object</code></td>
<td>
<p>An <code>emfrail</code> object</p>
</td></tr>
<tr><td><code id="logLik.emfrail_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula for the likelihood can be found in the manual which accompanies the package. Note that a constant
is added. If we denote <code class="reqn">\bar{n}</code> the total number of events and <code class="reqn">\bar{n_i}</code> the total number of events at time point
<code class="reqn">i</code>, for each time point where events are observed, then this is equal to
</p>
<p style="text-align: center;"><code class="reqn">\bar{n} - \sum_i \bar{n_i} \log \bar{n_i}.</code>
</p>

<p>This is mostly because of compatibility, i.e. to match the log-likelihood given by the <code>survival</code> package.
</p>
<p>The <code>df</code> attribute of this object is equal to the number of regression coefficents plus 1.
In general, the number of degrees of freedom for a frailty model is an unclear concept. For the <code>coxph</code> frailty fits,
and in general for the shared frailty models fitted by penalized likelihood, the degrees of freedom is a number
that depends on the penalization. However, even in that case, there is no straight forward interpretation or use of this
quantity. The decision made here is because this would keep the likelihood ratio test for a covariate effect valid.
</p>


<h3>Value</h3>

<p>An object of class <code>logLik</code> containing the marginal log-likelihood of the fitted model
</p>

<hr>
<h2 id='plot.emfrail'>Plots for emfrail objects</h2><span id='topic+plot.emfrail'></span>

<h3>Description</h3>

<p>Plots for emfrail objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emfrail'
plot(x, type = c("hist", "hr", "pred"),
  newdata = NULL, lp = NULL, strata = NULL, quantity = "cumhaz",
  type_pred = c("conditional", "marginal"), conf_int = "adjusted",
  conf_level = 0.95, individual = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.emfrail_+3A_x">x</code></td>
<td>
<p><code>emfrail</code> object, typically result of <code>emfrail()</code></p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_type">type</code></td>
<td>
<p>One (or more) of <code>hist</code> for a histogram of the estimated frailty values,
<code>hr</code> for a plot of the conditional and marginal hazard ratio between two cases and
<code>pred</code> for the predicted conditional and marginal cumulative hazard or survival for one case</p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> with values of the covariates. For <code>type == "hr"</code> the hazard ratio
between the first two rows of <code>newdata</code> is calculated. For <code>type == "pred"</code> the prediction
for the first row of <code>newdata</code> is calculated.</p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_lp">lp</code></td>
<td>
<p>A numeric vector of values of the linear predictor, each corresponding to a case. For <code>type == "hr"</code> the hazard ratio
between the first two values of <code>lp</code> is calculated. For <code>type == "pred"</code> the prediction
for the first value of <code>lp</code> is calculated.</p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_strata">strata</code></td>
<td>
<p>The name of the strata (if applicable) for which the prediction should be made.</p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_quantity">quantity</code></td>
<td>
<p>For <code>type == "pred"</code> the predicted quantity; see <code>quantity</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_type_pred">type_pred</code></td>
<td>
<p>For <code>type == "pred"</code> the type of predicted quantity; see <code>type</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_conf_int">conf_int</code></td>
<td>
<p>For <code>type == "pred"</code> the type of confidence intervals; see <code>conf_int</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_conf_level">conf_level</code></td>
<td>
<p>The width of the confidence interval for <code>type == "pred"</code>; see <code>conf_level</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_individual">individual</code></td>
<td>
<p>For <code>type == "pred"</code> for drawing a curve when the rows of <code>newdata</code> refer to the same individual; see
<code>individual</code> in <code><a href="#topic+predict.emfrail">predict.emfrail</a></code></p>
</td></tr>
<tr><td><code id="plot.emfrail_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the plot function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.emfrail">predict.emfrail</a></code>, <code><a href="#topic+summary.emfrail">summary.emfrail</a></code>, <code><a href="#topic+autoplot.emfrail">autoplot.emfrail</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod_rec &lt;- emfrail(Surv(start, stop, status) ~ treatment + number + cluster(id), bladder1,
control = emfrail_control(ca_test = FALSE, lik_ci = FALSE))

# Histogram of the estimated frailties
plot(mod_rec, type = "hist")

# hazard ratio between placebo and pyridoxine
newdata1 &lt;- data.frame(treatment = c("placebo", "pyridoxine"),
                       number = c(1, 3))

plot(mod_rec, type = "hr", newdata = newdata1)

# predicted cumulative hazard for placebo, and number = 1
plot(mod_rec, type = "pred", newdata = newdata1[1,])

# predicted survival for placebo, and number = 1
plot(mod_rec, type = "pred", quantity = "survival", newdata = newdata1[1,])

# predicted survival for an individual that switches from
# placebo to pyridoxine at time = 15
newdata2 &lt;- data.frame(treatment = c("placebo", "pyridoxine"),
                       number = c(1, 3),
                       tstart = c(0, 15),
                       tstop = c(15, Inf))

plot(mod_rec, type = "pred", quantity = "survival", newdata = newdata2, individual = TRUE)
</code></pre>

<hr>
<h2 id='predict.emfrail'>Predicted hazard and survival curves from an <code>emfrail</code> object</h2><span id='topic+predict.emfrail'></span>

<h3>Description</h3>

<p>Predicted hazard and survival curves from an <code>emfrail</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emfrail'
predict(object, newdata = NULL, lp = NULL,
  strata = NULL, quantity = c("cumhaz", "survival"),
  type = c("conditional", "marginal"), conf_int = NULL,
  individual = FALSE, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.emfrail_+3A_object">object</code></td>
<td>
<p>An <code>emfrail</code> fit object</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those that appear in the <code>emfrail</code> formula, used to calculate the <code>lp</code> (optional).</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_lp">lp</code></td>
<td>
<p>A vector of linear predictor values at which to calculate the curves. Default is 0 (baseline).</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_strata">strata</code></td>
<td>
<p>The name of the strata (if applicable) for which the prediction should be made.</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_quantity">quantity</code></td>
<td>
<p>Can be <code>"cumhaz"</code> and/or <code>"survival"</code>. The quantity to be calculated for the values of <code>lp</code>.</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_type">type</code></td>
<td>
<p>Can be <code>"conditional"</code> and/or <code>"marginal"</code>. The type of the quantity to be calculated.</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_conf_int">conf_int</code></td>
<td>
<p>Can be <code>"regular"</code> and/or <code>"adjusted"</code>. The type of confidence interval to be calculated.</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_individual">individual</code></td>
<td>
<p>Logical. Are the observations in <code>newdata</code> from the same individual? See details.</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_conf_level">conf_level</code></td>
<td>
<p>The width of the confidence intervals. By default, 95% confidence intervals are calculated.</p>
</td></tr>
<tr><td><code id="predict.emfrail_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates predicted cumulative hazard and survival curves for given covariate
or linear predictor values; for the first, <code>newdata</code> must be specified and for the latter
<code>lp</code> must be specified. Each row of <code>newdata</code> or element of <code>lp</code> is consiered to be
a different subject, and the desired predictions are produced for each of them separately.
</p>
<p>In <code>newdata</code> two columns may be specified with the names <code>tstart</code> and <code>tstop</code>.
In this case, each subject is assumed to be at risk only during the times specified by these two values.
If the two are not specified, the predicted curves are produced for a subject that is at risk for the
whole follow-up time.
</p>
<p>A slightly different behaviour is observed if <code>individual == TRUE</code>. In this case, all the rows of
<code>newdata</code> are assumed to come from the same individual, and <code>tstart</code> and <code>tstop</code> must
be specified, and must not overlap. This may be used for describing subjects that
are not at risk during certain periods or subjects with time-dependent covariate values.
</p>
<p>The two &quot;quantities&quot; that can be returned are
named <code>cumhaz</code> and <code>survival</code>. If we denote each quantity with <code>q</code>, then the columns with the marginal estimates
are named <code>q_m</code>. The confidence intervals contain the name of the quantity (conditional or marginal) followed by <code>_l</code> or <code>_r</code> for
the lower and upper bound. The bounds calculated with the adjusted standard errors have the name of the regular bounds followed by
<code>_a</code>. For example, the adjusted lower bound for the marginal survival is in the column named <code>survival_m_l_a</code>.
</p>
<p>The <code>emfrail</code> only gives the Breslow estimates of the  baseline hazard <code class="reqn">\lambda_0(t)</code> at the
event time points, conditional on the frailty. Let <code class="reqn">\lambda(t)</code> be the baseline hazard for a linear predictor of interest.
The estimated conditional cumulative hazard is then
<code class="reqn">\Lambda(t) = \sum_{s= 0}^t \lambda(s)</code>. The variance of <code class="reqn">\Lambda(t)</code> can be calculated from the (maybe adjusted)
variance-covariance matrix.
</p>
<p>The conditional survival is obtained by the usual expression <code class="reqn">S(t) = \exp(-\Lambda(t))</code>. The marginal survival
is given by
</p>
<p style="text-align: center;"><code class="reqn">\bar S(t) = E \left[\exp(-\Lambda(t)) \right] = \mathcal{L}(\Lambda(t)),</code>
</p>

<p>i.e. the Laplace transform of the frailty distribution calculated in <code class="reqn">\Lambda(t)</code>.
</p>
<p>The marginal hazard is obtained as </p>
<p style="text-align: center;"><code class="reqn">\bar \Lambda(t) = - \log \bar S(t).</code>
</p>

<p>The only standard errors that are available from <code>emfrail</code> are those for <code class="reqn">\lambda_0(t)</code>. From this,
standard errors of <code class="reqn">\log \Lambda(t)</code> may be calculated. On this scale, the symmetric confidence intervals are built, and then
moved to the desired scale.
</p>


<h3>Value</h3>

<p>The return value is a single data frame (if <code>lp</code> has length 1,
<code>newdata</code> has 1 row or <code>individual == TRUE</code>) or a list of data frames corresponding to each value of
<code>lp</code> or each row of <code>newdata</code> otherwise.
The names of the columns in the returned data frames are as follows: <code>time</code> represents the unique event time points
from the data set, <code>lp</code> is the value of the linear predictor (as specified in the input or as calculated from the lines of <code>newdata</code>).
By default, for each <code>lp</code> a data frame will contain the following columns: <code>cumhaz</code>, <code>survival</code>,
<code>cumhaz_m</code>, <code>survival_m</code> for the cumulative hazard and survival, conditional and marginal, with corresponding confidence
bands. The naming of the columns is explained more in the Details section.
</p>


<h3>Note</h3>

<p>The linear predictor is taken as fixed, so the variability in the estimation of the regression coefficient is not taken into account.
Does not support left truncation (at the moment). That is because, if <code>individual == TRUE</code> and <code>tstart</code> and <code>tstop</code> are
specified, for the marginal estimates the distribution of the frailty is used to calculate the integral, and not
the distribution of the frailty given the truncation.
</p>
<p>For performance reasons, consider running with <code>conf_int = NULL</code>; the reason is that the <code>deltamethod</code> function that is used
to calculate the confidence intervals easily becomes slow when there is a large number of time points
for the cumulative hazard.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.emfrail">plot.emfrail</a></code>, <code><a href="#topic+autoplot.emfrail">autoplot.emfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kidney$sex &lt;- ifelse(kidney$sex == 1, "male", "female")
m1 &lt;- emfrail(formula = Surv(time, status) ~  sex + age  + cluster(id),
              data =  kidney)

# get all the possible prediction for the value 0 of the linear predictor
predict(m1, lp = 0)

# get the cumulative hazards for two different values of the linear predictor
predict(m1, lp = c(0, 1), quantity = "cumhaz", conf_int = NULL)

# get the cumulative hazards for a female and for a male, both aged 30
newdata1 &lt;- data.frame(sex = c("female", "male"),
                       age = c(30, 30))

predict(m1, newdata = newdata1, quantity = "cumhaz", conf_int = NULL)

# get the cumulative hazards for an individual that changes
# sex from female to male at time 40.
newdata2 &lt;- data.frame(sex = c("female", "male"),
                      age = c(30, 30),
                      tstart = c(0, 40),
                      tstop = c(40, Inf))

predict(m1, newdata = newdata2,
        individual = TRUE,
        quantity = "cumhaz", conf_int = NULL)

</code></pre>

<hr>
<h2 id='residuals.emfrail'>Residuals for frailty models</h2><span id='topic+residuals.emfrail'></span>

<h3>Description</h3>

<p>Residuals for frailty models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emfrail'
residuals(object, type = "group", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.emfrail_+3A_object">object</code></td>
<td>
<p>An <code>emfrail</code> object</p>
</td></tr>
<tr><td><code id="residuals.emfrail_+3A_type">type</code></td>
<td>
<p>One of <code>cluster</code> or <code>individual</code></p>
</td></tr>
<tr><td><code id="residuals.emfrail_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For cluster <code class="reqn">i</code>, individual <code class="reqn">j</code> and observation row <code class="reqn">k</code>, we write the cumulative hazard contribution as
</p>
<p style="text-align: center;"><code class="reqn">\Lambda_{ijk} = \exp(\beta^\top \mathbf{x}_{ijk}) \Lambda_{0, ijk}</code>
</p>

<p>where <code class="reqn">\Lambda_{0, ijk}</code> is the baseline cumulative hazard correspinding to the row <code class="reqn">(i,j,k)</code>.
</p>
<p>When <code>type == "individual"</code>, the returned residuals are equal to <code class="reqn">z_i \Lambda_{ijk}</code> where <code class="reqn">z_i</code> is the estimated frailty in cluster <code class="reqn">i</code>.
When <code>type == "cluster"</code>, the returned residuals are equal to <code class="reqn">\sum_{j,k} \Lambda_{ijk}</code>,
</p>


<h3>Value</h3>

<p>A vector corresponding to the Martingale residuals, either for each cluster or for each individual (row of the data).
</p>

<hr>
<h2 id='summary.emfrail'>Summary for <code>emfrail</code> objects</h2><span id='topic+summary.emfrail'></span>

<h3>Description</h3>

<p>Summary for <code>emfrail</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emfrail'
summary(object, lik_ci = TRUE, print_opts = list(coef
  = TRUE, dist = TRUE, fit = TRUE, frailty = TRUE, adj_se = TRUE,
  verbose_frailty = TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.emfrail_+3A_object">object</code></td>
<td>
<p>An object of class <code>emfrail</code></p>
</td></tr>
<tr><td><code id="summary.emfrail_+3A_lik_ci">lik_ci</code></td>
<td>
<p>Logical. Should the confidence intervals for the frailty parameter be calculated based on the likelihood? If not, they are calculated with the delta method.</p>
</td></tr>
<tr><td><code id="summary.emfrail_+3A_print_opts">print_opts</code></td>
<td>
<p>A list with options for printing the summary object. These include <code>coef</code>, <code>dist</code>, <code>fit</code>, <code>frailty</code>, <code>adj_se</code>, <code>verbose_frailty</code>.</p>
</td></tr>
<tr><td><code id="summary.emfrail_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regardless of
the fitted model, the following fields will be present in this object: <code>est_dist</code> (an object of class <code>emfrail_distribution</code>) with the estimated
distribution, <code>loglik</code> (a named vector with the log-likelihoods of the no-frailty model, the frailty model,
the likelihood ratio test statistic and the p-value of the one-sided likelihood ratio test), <code>theta</code> (a named vector with
the estimated value of the parameter <code class="reqn">\theta</code>, the standard error, and the limits of a 95
is a data frame with the following columns: <code>id</code> (cluster identifier), <code>z</code> (empirical Bayes frailty estimates), and optional
<code>lower_q</code> and <code>upper_q</code> as the 2.5
</p>
<p>For the the PVF or gamma distributions, the field <code>fr_var</code> contains a transformation of <code>theta</code> to correspond to the
frailty variance.
The fields <code>pvf_pars</code> and <code>stable_pars</code> are for quantities that are calculated only when the distribution is PVF or stable.
If the model contains covariates, the field <code>coefmat</code> contains the corresponding estimates. The p-values are based on
the adjusted standard errors, if they have been calculated successfully (i.e. if they appear when prining the summary object).
Otherwise, they are based on the regular standard errors.
</p>


<h3>Value</h3>

<p>An object of class <code>emfrail_summary</code>,
with some more human-readable results from an <code>emfrail</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.emfrail">predict.emfrail</a>, <a href="#topic+plot.emfrail">plot.emfrail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("bladder")
mod_gamma &lt;- emfrail(Surv(start, stop, status) ~ treatment + cluster(id), bladder1)
summary(mod_gamma)
summary(mod_gamma, print_opts = list(frailty_verbose = FALSE))

# plot the Empirical Bayes estimates of the frailty
# easy way:
plot(mod_gamma, type = "hist")

# a fancy graph:
sum_mod &lt;- summary(mod_gamma)
library(dplyr)
library(ggplot2)

# Create a plot just with the points
pl1 &lt;- sum_mod$frail %&gt;%
  arrange(z) %&gt;%
  mutate(x = 1:n()) %&gt;%
  ggplot(aes(x = x, y = z)) +
  geom_point()

# If the quantiles of the posterior distribution are
# known, then error bars can be added:
if(!is.null(sum_mod$frail$lower_q))
  pl1 &lt;- pl1 + geom_errorbar(aes(ymin = lower_q, ymax = upper_q), alpha = 0.5)

pl1

# The plot can be made interactive!
# ggplot2 gives a warning about the "id" aesthetic, just ignore it
pl2 &lt;- sum_mod$frail %&gt;%
  arrange(z) %&gt;%
  mutate(x = 1:n()) %&gt;%
  ggplot(aes(x = x, y = z)) +
  geom_point(aes(id = id))

if(!is.null(sum_mod$z$lower_q))
  pl2 &lt;- pl2 + geom_errorbar(aes(ymin = lower_q, ymax = upper_q, id = id), alpha = 0.5)

library(plotly)
ggplotly(pl2)

# Proportional hazards test
off_z &lt;- log(sum_mod$frail$z)[match(bladder1$id, sum_mod$frail$id)]

zph1 &lt;- cox.zph(coxph(Surv(start, stop, status) ~ treatment + cluster(id), data = bladder1))

# no sign of non-proportionality
zph2 &lt;- cox.zph(coxph(Surv(start, stop, status) ~ treatment + offset(off_z), data = bladder1))

zph2
# the p-values are even larger; the frailty "corrects" for proportionality.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
