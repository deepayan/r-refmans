<!DOCTYPE html><html lang="en"><head><title>Help for package tidychangepoint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidychangepoint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidychangepoint-package'><p>tidychangepoint: A Tidy Framework for Changepoint Detection Analysis</p></a></li>
<li><a href='#as_year'><p>Convert a date into a year</p></a></li>
<li><a href='#as.model'><p>Convert, retrieve, or verify a model object</p></a></li>
<li><a href='#as.segmenter'><p>Convert, retrieve, or verify a segmenter object</p></a></li>
<li><a href='#as.ts.mod_cpt'><p>Objects exported from other packages</p></a></li>
<li><a href='#binary2tau'><p>Convert changepoint sets to binary strings</p></a></li>
<li><a href='#BMDL'><p>Bayesian Maximum Descriptive Length</p></a></li>
<li><a href='#bogota_pm'><p>Particulate matter in Bogotá, Colombia</p></a></li>
<li><a href='#build_gabin_population'><p>Initialize populations in genetic algorithms</p></a></li>
<li><a href='#CET'><p>Hadley Centre Central England Temperature</p></a></li>
<li><a href='#changepoints'><p>Extract changepoints</p></a></li>
<li><a href='#compare_models'><p>Compare various models or algorithms for a given changepoint set</p></a></li>
<li><a href='#cut_by_tau'><p>Use a changepoint set to break a time series into regions</p></a></li>
<li><a href='#DataCPSim'><p>Simulated time series data</p></a></li>
<li><a href='#deg_free'><p>Retrieve the degrees of freedom from a <code>logLik</code> object</p></a></li>
<li><a href='#diagnose'><p>Diagnose the fit of a segmented time series</p></a></li>
<li><a href='#evaluate_cpts'><p>Evaluate candidate changepoints sets</p></a></li>
<li><a href='#evolve_gbmdl'><p>Generate a list of candidate changepoints using a genetic algorithm</p></a></li>
<li><a href='#exceedances'><p>Compute exceedances of a threshold for a time series</p></a></li>
<li><a href='#file_name'><p>Obtain a descriptive filename for a tidycpt object</p></a></li>
<li><a href='#fit_lmshift'><p>Regression-based model fitting</p></a></li>
<li><a href='#fit_meanshift'><p>Fast implementation of meanshift model</p></a></li>
<li><a href='#fit_meanvar'><p>Fit a model for mean and variance</p></a></li>
<li><a href='#fit_nhpp'><p>Fit a non-homogeneous Poisson process model to the exceedances of a time series.</p></a></li>
<li><a href='#fit_nhpp_region'><p>Fit an NHPP model to one specific region</p></a></li>
<li><a href='#fitness'><p>Retrieve the optimal fitness (or objective function) value used by an</p>
algorithm</a></li>
<li><a href='#HQC'><p>Hannan–Quinn information criterion</p></a></li>
<li><a href='#italy_grads'><p>Italian University graduates by disciplinary groups from 1926-2013</p></a></li>
<li><a href='#iweibull'><p>Weibull distribution functions</p></a></li>
<li><a href='#log_likelihood_region_weibull'><p>Log-Likelihood functions for regions (Weibull)</p></a></li>
<li><a href='#ls_models'><p>Algorithmic coverage through tidychangepoint</p></a></li>
<li><a href='#MBIC'><p>Modified Bayesian Information Criterion</p></a></li>
<li><a href='#mcdf'><p>Cumulative distribution of the exceedances of a time series</p></a></li>
<li><a href='#mde_rain'><p>Rainfall in Medellín, Colombia</p></a></li>
<li><a href='#MDL'><p>Maximum Descriptive Length</p></a></li>
<li><a href='#mlb_diffs'><p>Differences between leagues in Major League Baseball</p></a></li>
<li><a href='#model_args'><p>Retrieve the arguments that a model-fitting function used</p></a></li>
<li><a href='#model_name'><p>Retrieve the name of the model that a segmenter or model used</p></a></li>
<li><a href='#model_variance'><p>Compute model variance</p></a></li>
<li><a href='#new_fun_cpt'><p>Class for model-fitting functions</p></a></li>
<li><a href='#new_mod_cpt'><p>Base class for changepoint models</p></a></li>
<li><a href='#new_seg_basket'><p>Default class for candidate changepoint sets</p></a></li>
<li><a href='#new_seg_cpt'><p>Base class for segmenters</p></a></li>
<li><a href='#pad_tau'><p>Pad and unpad changepoint sets with boundary points</p></a></li>
<li><a href='#plot_best_chromosome'><p>Diagnostic plots for <code>seg_basket</code> objects</p></a></li>
<li><a href='#plot_intensity'><p>Plot the intensity of an NHPP fit</p></a></li>
<li><a href='#plot.tidyga'><p>Plot GA information</p></a></li>
<li><a href='#regions'><p>Extract the regions from a tidycpt object</p></a></li>
<li><a href='#seg_params'><p>Retrieve parameters from a segmenter</p></a></li>
<li><a href='#segment'><p>Segment a time series using a variety of algorithms</p></a></li>
<li><a href='#segment_coen'><p>Algoritmo genético de Bayesian MDL a un paso</p></a></li>
<li><a href='#segment_ga'><p>Segment a time series using a genetic algorithm</p></a></li>
<li><a href='#segment_manual'><p>Manually segment a time series</p></a></li>
<li><a href='#segment_pelt'><p>Segment a time series using the PELT algorithm</p></a></li>
<li><a href='#SIC'><p>Schwarz information criterion</p></a></li>
<li><a href='#tau2time'><p>Convert changepoint sets to time indices</p></a></li>
<li><a href='#tbl_coef'><p>Format the coefficients from a linear model as a tibble</p></a></li>
<li><a href='#test_set'><p>Simulate time series with known changepoint sets</p></a></li>
<li><a href='#tidycpt-class'><p>Container class for <code>tidycpt</code> objects</p></a></li>
<li><a href='#vec_ptype2.logLik.logLik'><p>Vectors implementation for logLik</p></a></li>
<li><a href='#whomademe'><p>Recover the function that created a model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Tidy Framework for Changepoint Detection Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Changepoint detection algorithms for R are widespread but have
    different interfaces and reporting conventions. 
    This makes the comparative analysis of results difficult. 
    We solve this problem by providing a tidy, unified interface for several 
    different changepoint detection algorithms. 
    We also provide consistent numerical and graphical reporting leveraging 
    the 'broom' and 'ggplot2' packages. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, changepoint, cli, dplyr, GA, ggplot2, lifecycle,
memoise, methods, patchwork, purrr, rlang, scales, stringr,
tibble, tidyr, tsibble, vctrs, wbs, xts, zoo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, knitr, here, multitaper, readr, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://beanumber.github.io/tidychangepoint/">https://beanumber.github.io/tidychangepoint/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-31 20:37:42 UTC; bbaumer</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin S. Baumer
    <a href="https://orcid.org/0000-0002-3279-0516"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph],
  Biviana Marcela Suárez Sierra
    <a href="https://orcid.org/0000-0003-2151-3537"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Arrigo Coen <a href="https://orcid.org/0000-0001-7798-7104"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Carlos A. Taimal <a href="https://orcid.org/0000-0002-8716-1282"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Xueheng Shi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin S. Baumer &lt;ben.baumer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-31 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidychangepoint-package'>tidychangepoint: A Tidy Framework for Changepoint Detection Analysis</h2><span id='topic+tidychangepoint'></span><span id='topic+tidychangepoint-package'></span>

<h3>Description</h3>

<p>Changepoint detection algorithms for R are widespread but have different interfaces and reporting conventions. This makes the comparative analysis of results difficult. We solve this problem by providing a tidy, unified interface for several different changepoint detection algorithms. We also provide consistent numerical and graphical reporting leveraging the 'broom' and 'ggplot2' packages.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Benjamin S. Baumer <a href="mailto:ben.baumer@gmail.com">ben.baumer@gmail.com</a> (<a href="https://orcid.org/0000-0002-3279-0516">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Biviana Marcela Suárez Sierra <a href="mailto:bmsuarezs@eafit.edu.co">bmsuarezs@eafit.edu.co</a> (<a href="https://orcid.org/0000-0003-2151-3537">ORCID</a>)
</p>
</li>
<li><p> Arrigo Coen (<a href="https://orcid.org/0000-0001-7798-7104">ORCID</a>)
</p>
</li>
<li><p> Carlos A. Taimal (<a href="https://orcid.org/0000-0002-8716-1282">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Xueheng Shi [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://beanumber.github.io/tidychangepoint/">https://beanumber.github.io/tidychangepoint/</a>
</p>
</li></ul>


<hr>
<h2 id='as_year'>Convert a date into a year</h2><span id='topic+as_year'></span>

<h3>Description</h3>

<p>Convert a date into a year
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_year(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_year_+3A_x">x</code></td>
<td>
<p>an object coercible into a <a href="base.html#topic+Dates">base::Date</a>. See <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector representing the years of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve only the year
as_year("1988-01-01")

</code></pre>

<hr>
<h2 id='as.model'>Convert, retrieve, or verify a model object</h2><span id='topic+as.model'></span><span id='topic+as.model.default'></span><span id='topic+as.model.tidycpt'></span><span id='topic+is_model'></span>

<h3>Description</h3>

<p>Convert, retrieve, or verify a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.model(object, ...)

## Default S3 method:
as.model(object, ...)

## S3 method for class 'tidycpt'
as.model(object, ...)

is_model(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.model_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+tidycpt-class">tidycpt</a> object, typically returned by <code><a href="#topic+segment">segment()</a></code></p>
</td></tr>
<tr><td><code id="as.model_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
<tr><td><code id="as.model_+3A_x">x</code></td>
<td>
<p>An object, typically returned by <code style="white-space: pre;">&#8288;fit_*()&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+tidycpt-class">tidycpt</a> objects have a <code>model</code> component.
The functions documented here are convenience utility functions
for working with the <code>model</code> components.
<code><a href="#topic+as.model">as.model()</a></code> is especially useful in pipelines to avoid having to use
the <code>$</code> or <code>[</code> notation for subsetting.
</p>
<p>When applied to a <a href="#topic+tidycpt-class">tidycpt</a> object, <code><a href="#topic+as.model">as.model()</a></code> simply returns the
<code>model</code> component of that object.
However, when applied to a <code>segmenter</code> object, <code><a href="#topic+as.model">as.model()</a></code> attempts to
converts that object into a <a href="#topic+mod_cpt">mod_cpt</a> model object.
</p>
<p><code><a href="#topic+is_model">is_model()</a></code> checks to see if a model object implements all of the
S3 methods necessary to be considered a model.
</p>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+as.model">as.model()</a></code> returns a <a href="#topic+mod_cpt">mod_cpt</a> model object
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+is_model">is_model()</a></code> a <code>logical</code> vector of length 1
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tidycpt-generics: 
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+changepoints">changepoints</a>()</code>,
<code><a href="#topic+diagnose">diagnose</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
x &lt;- segment(CET, method = "pelt")

# Retrieve the model component
x |&gt; 
  as.model()

# Explicitly convert the segmenter to a model
x |&gt;
  as.segmenter() |&gt;
  as.model()

# Is that model valid? 
x |&gt;
  as.model() |&gt;
  is_model()
  

# Fit a model directly, without using [segment()]
x &lt;- fit_nhpp(CET, tau = 330)
is_model(x)
</code></pre>

<hr>
<h2 id='as.segmenter'>Convert, retrieve, or verify a segmenter object</h2><span id='topic+as.segmenter'></span><span id='topic+as.seg_cpt'></span><span id='topic+as.seg_cpt.seg_basket'></span><span id='topic+as.seg_cpt.seg_cpt'></span><span id='topic+as.segmenter.tidycpt'></span><span id='topic+as.seg_cpt.ga'></span><span id='topic+as.seg_cpt.cpt'></span><span id='topic+as.seg_cpt.wbs'></span><span id='topic+is_segmenter'></span>

<h3>Description</h3>

<p>Convert, retrieve, or verify a segmenter object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.segmenter(object, ...)

as.seg_cpt(object, ...)

## S3 method for class 'seg_basket'
as.seg_cpt(object, ...)

## S3 method for class 'seg_cpt'
as.seg_cpt(object, ...)

## S3 method for class 'tidycpt'
as.segmenter(object, ...)

## S3 method for class 'ga'
as.seg_cpt(object, ...)

## S3 method for class 'cpt'
as.seg_cpt(object, ...)

## S3 method for class 'wbs'
as.seg_cpt(object, ...)

is_segmenter(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.segmenter_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+tidycpt-class">tidycpt</a> or <code>segmenter</code> object</p>
</td></tr>
<tr><td><code id="as.segmenter_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+tidycpt-class">tidycpt</a> objects have a <code>segmenter</code> component (that is typically
created by a class to <code><a href="#topic+segment">segment()</a></code>).
The functions documented here are convenience utility functions
for working with the <code>segmenter</code> components.
<code><a href="#topic+as.segmenter">as.segmenter()</a></code> is especially useful in pipelines to avoid having to use
the <code>$</code> or <code>[</code> notation for subsetting.
</p>
<p><code><a href="#topic+as.segmenter">as.segmenter()</a></code> simply returns the segmenter of a <code>tidycpt</code> object.
</p>
<p><code><a href="#topic+as.seg_cpt">as.seg_cpt()</a></code> takes a wild-caught <code>segmenter</code> object of arbitrary class
and converts it into a <a href="#topic+seg_cpt">seg_cpt</a> object.
</p>
<p><code><a href="#topic+is_segmenter">is_segmenter()</a></code> checks to see if a segmenter object implements all of the
S3 methods necessary to be considered a segmenter.
</p>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+as.segmenter">as.segmenter()</a></code> returns the <code>segmenter</code> object of a <code>tidycpt</code> object.
Note that this could be of
any class, depending on the class returned by the segmenting function.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+as.seg_cpt">as.seg_cpt()</a></code> returns a <a href="#topic+seg_cpt">seg_cpt</a> object
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+is_segmenter">is_segmenter()</a></code> a <code>logical</code> vector of length 1
</p>
</li></ul>



<h3>See Also</h3>

<p>Other tidycpt-generics: 
<code><a href="#topic+as.model">as.model</a>()</code>,
<code><a href="#topic+changepoints">changepoints</a>()</code>,
<code><a href="#topic+diagnose">diagnose</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>
</p>
<p>Other segmenter-functions: 
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+seg_params">seg_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
x &lt;- segment(CET, method = "pelt")

# Return the segmenter component
x |&gt;
  as.segmenter()
  
# Note the class of this object could be anything
x |&gt;
  as.segmenter() |&gt;
  class()
  
# Convert the segmenter into the standardized seg_cpt class
x |&gt;
  as.segmenter() |&gt;
  as.seg_cpt()

# Is the segmenter valid?
x |&gt;
  as.segmenter() |&gt;
  is_segmenter()
</code></pre>

<hr>
<h2 id='as.ts.mod_cpt'>Objects exported from other packages</h2><span id='topic+as.ts.mod_cpt'></span><span id='topic+nobs.mod_cpt'></span><span id='topic+logLik.mod_cpt'></span><span id='topic+fitted.mod_cpt'></span><span id='topic+residuals.mod_cpt'></span><span id='topic+coef.mod_cpt'></span><span id='topic+augment.mod_cpt'></span><span id='topic+tidy.mod_cpt'></span><span id='topic+glance.mod_cpt'></span><span id='topic+plot.mod_cpt'></span><span id='topic+print.mod_cpt'></span><span id='topic+as.ts.seg_basket'></span><span id='topic+plot.seg_basket'></span><span id='topic+as.ts.seg_cpt'></span><span id='topic+glance.seg_cpt'></span><span id='topic+nobs.seg_cpt'></span><span id='topic+print.seg_cpt'></span><span id='topic+as.ts.tidycpt'></span><span id='topic+augment.tidycpt'></span><span id='topic+tidy.tidycpt'></span><span id='topic+glance.tidycpt'></span><span id='topic+plot.tidycpt'></span><span id='topic+print.tidycpt'></span><span id='topic+logLik.meanshift_lnorm'></span><span id='topic+logLik.nhpp'></span><span id='topic+glance.nhpp'></span><span id='topic+as.ts.ga'></span><span id='topic+nobs.ga'></span><span id='topic+as.ts.cpt'></span><span id='topic+logLik.cpt'></span><span id='topic+nobs.cpt'></span><span id='topic+as.ts.wbs'></span><span id='topic+nobs.wbs'></span><span id='topic+reexports'></span><span id='topic+tidy'></span><span id='topic+augment'></span><span id='topic+glance'></span><span id='topic+as.ts'></span><span id='topic+logLik'></span><span id='topic+AIC'></span><span id='topic+BIC'></span><span id='topic+nobs'></span><span id='topic+fitted'></span><span id='topic+residuals'></span><span id='topic+coef'></span><span id='topic+time'></span><span id='topic+vec_ptype2'></span><span id='topic+vec_cast'></span><span id='topic+index'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>broom</dt><dd><p><code><a href="broom.html#topic+reexports">augment</a></code>, <code><a href="broom.html#topic+reexports">glance</a></code>, <code><a href="broom.html#topic+reexports">tidy</a></code></p>
</dd>
<dt>stats</dt><dd><p><code><a href="stats.html#topic+AIC">AIC</a></code>, <code><a href="stats.html#topic+ts">as.ts</a></code>, <code><a href="stats.html#topic+AIC">BIC</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+fitted.values">fitted</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+nobs">nobs</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+time">time</a></code></p>
</dd>
<dt>vctrs</dt><dd><p><code><a href="vctrs.html#topic+vec_cast">vec_cast</a></code>, <code><a href="vctrs.html#topic+vec_ptype2">vec_ptype2</a></code></p>
</dd>
<dt>zoo</dt><dd><p><code><a href="zoo.html#topic+index">index</a></code></p>
</dd>
</dl>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mod_cpt'
as.ts(x, ...)

## S3 method for class 'mod_cpt'
nobs(object, ...)

## S3 method for class 'mod_cpt'
logLik(object, ...)

## S3 method for class 'mod_cpt'
fitted(object, ...)

## S3 method for class 'mod_cpt'
residuals(object, ...)

## S3 method for class 'mod_cpt'
coef(object, ...)

## S3 method for class 'mod_cpt'
augment(x, ...)

## S3 method for class 'mod_cpt'
tidy(x, ...)

## S3 method for class 'mod_cpt'
glance(x, ...)

## S3 method for class 'mod_cpt'
plot(x, ...)

## S3 method for class 'mod_cpt'
print(x, ...)

## S3 method for class 'seg_basket'
as.ts(x, ...)

## S3 method for class 'seg_basket'
plot(x, ...)

## S3 method for class 'seg_cpt'
as.ts(x, ...)

## S3 method for class 'seg_cpt'
glance(x, ...)

## S3 method for class 'seg_cpt'
nobs(object, ...)

## S3 method for class 'seg_cpt'
print(x, ...)

## S3 method for class 'tidycpt'
as.ts(x, ...)

## S3 method for class 'tidycpt'
augment(x, ...)

## S3 method for class 'tidycpt'
tidy(x, ...)

## S3 method for class 'tidycpt'
glance(x, ...)

## S3 method for class 'tidycpt'
plot(x, use_time_index = FALSE, ...)

## S3 method for class 'tidycpt'
print(x, ...)

## S3 method for class 'meanshift_lnorm'
logLik(object, ...)

## S3 method for class 'nhpp'
logLik(object, ...)

## S3 method for class 'nhpp'
glance(x, ...)

## S3 method for class 'ga'
as.ts(x, ...)

## S3 method for class 'ga'
nobs(object, ...)

## S3 method for class 'cpt'
as.ts(x, ...)

## S3 method for class 'cpt'
logLik(object, ...)

## S3 method for class 'cpt'
nobs(object, ...)

## S3 method for class 'wbs'
as.ts(x, ...)

## S3 method for class 'wbs'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.ts.mod_cpt_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
<tr><td><code id="as.ts.mod_cpt_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="as.ts.mod_cpt_+3A_use_time_index">use_time_index</code></td>
<td>
<p>Should the x-axis labels be the time indices? Or the
time labels?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Plot a meanshift model fit
plot(fit_meanshift_norm(CET, tau = 330))

#' # Plot a trendshift model fit
plot(fit_trendshift(CET, tau = 330))

#' # Plot a quadratic polynomial model fit
plot(fit_lmshift(CET, tau = 330, deg_poly = 2))

#' # Plot a 4th degree polynomial model fit
plot(fit_lmshift(CET, tau = 330, deg_poly = 10))

# Plot a segmented time series
plot(segment(CET, method = "pelt"))

# Plot a segmented time series and show the time labels on the x-axis
plot(segment(CET, method = "pelt"), use_time_index = TRUE)
</code></pre>

<hr>
<h2 id='binary2tau'>Convert changepoint sets to binary strings</h2><span id='topic+binary2tau'></span><span id='topic+tau2binary'></span>

<h3>Description</h3>

<p>Convert changepoint sets to binary strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary2tau(x)

tau2binary(tau, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary2tau_+3A_x">x</code></td>
<td>
<p>A binary string that encodes a changepoint set. See
<code><a href="GA.html#topic+ga_Population">GA::gabin_Population()</a></code>.</p>
</td></tr>
<tr><td><code id="binary2tau_+3A_tau">tau</code></td>
<td>
<p>a numeric vector of changepoint indices</p>
</td></tr>
<tr><td><code id="binary2tau_+3A_n">n</code></td>
<td>
<p>the length of the original time series</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use <code><a href="GA.html#topic+ga">GA::ga()</a></code> in a genetic algorithm, we need to encoude a
changepoint set as a binary string.
</p>
<p><code><a href="#topic+binary2tau">binary2tau()</a></code> takes a binary string representation of a changepoint set and
converts it into a set of changepoint indices.
</p>
<p><code><a href="#topic+tau2binary">tau2binary()</a></code> takes a set of changepoint indices the number of observations
in the time series and converts them into a binary string representation of
that changepoint set.
</p>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+binary2tau">binary2tau()</a></code>: an <code>integer</code> vector
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+tau2binary">tau2binary()</a></code>: an <code>integer</code> vector of length <code>n</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Recover changepoint set indices from binary strings
binary2tau(c(0, 0, 1, 0, 1))
binary2tau(round(runif(10)))

# Recover binary strings from changepoint set indices
tau2binary(c(7, 17), n = 24)
tau2binary(binary2tau(c(0, 0, 1, 1, 0, 1)), n = 6)

</code></pre>

<hr>
<h2 id='BMDL'>Bayesian Maximum Descriptive Length</h2><span id='topic+BMDL'></span><span id='topic+BMDL.default'></span><span id='topic+BMDL.nhpp'></span>

<h3>Description</h3>

<p>Generic function to compute the Bayesian Maximum Descriptive Length for a
changepoint detection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BMDL(object, ...)

## Default S3 method:
BMDL(object, ...)

## S3 method for class 'nhpp'
BMDL(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BMDL_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="BMDL_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the BMDL function is only defined for the NHPP model
(see <code><a href="#topic+fit_nhpp">fit_nhpp()</a></code>).
Given a changepoint set <code class="reqn">\tau</code>, the BMDL is:
</p>
<p style="text-align: center;"><code class="reqn">
   BMDL(\tau, NHPP(y | \hat{\theta}_\tau) = 
   P_{MDL}(\tau) - 2 \ln{ L_{NHPP}(y | \hat{\theta}_\tau) } 
   - 2 \ln{ g(\hat{\theta}_\tau) }
 </code>
</p>

<p>where <code class="reqn">P_{MDL}(\tau)</code> is the <code><a href="#topic+MDL">MDL()</a></code> penalty.
</p>


<h3>Value</h3>

<p>A <code>double</code> vector of length 1
</p>


<h3>See Also</h3>

<p>Other penalty-functions: 
<code><a href="#topic+HQC">HQC</a>()</code>,
<code><a href="#topic+MBIC">MBIC</a>()</code>,
<code><a href="#topic+MDL">MDL</a>()</code>,
<code><a href="#topic+SIC">SIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the BMDL
BMDL(fit_nhpp(DataCPSim, tau = NULL))
BMDL(fit_nhpp(DataCPSim, tau = c(365, 830)))
</code></pre>

<hr>
<h2 id='bogota_pm'>Particulate matter in Bogotá, Colombia</h2><span id='topic+bogota_pm'></span>

<h3>Description</h3>

<p>Particulate matter of less than 2.5 microns of diameter in Bogotá, Colombia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bogota_pm
</code></pre>


<h3>Format</h3>

<p>An object of class <code>xts</code> (inherits from <code>zoo</code>) with 1096 rows and 1 columns.
</p>


<h3>Details</h3>

<p>Daily readings from 2018-2020 are included.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(bogota_pm)

</code></pre>

<hr>
<h2 id='build_gabin_population'>Initialize populations in genetic algorithms</h2><span id='topic+build_gabin_population'></span><span id='topic+log_gabin_population'></span>

<h3>Description</h3>

<p>Build an initial population set for genetic algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_gabin_population(x, ...)

log_gabin_population(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_gabin_population_+3A_x">x</code></td>
<td>
<p>a numeric vector coercible into a <a href="stats.html#topic+ts">stats::ts</a> object</p>
</td></tr>
<tr><td><code id="build_gabin_population_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genetic algorithms require a method for randomly generating initial
populations (i.e., a first generation).
The default method used by <code><a href="GA.html#topic+ga">GA::ga()</a></code> for changepoint detection is usually
<code><a href="GA.html#topic+ga_Population">GA::gabin_Population()</a></code>, which selects candidate changepoints uniformly at
random with probability 0.5.
This leads to an initial population with excessively large candidate
changepoint sets (on the order of <code class="reqn">n/2</code>), which makes the genetic
algorithm slow.
</p>

<ul>
<li> <p><code><a href="#topic+build_gabin_population">build_gabin_population()</a></code> takes a <code>ts</code> object and runs several fast
changepoint detection algorithms on it, then sets the initial probability
to 3 times the average value of the size of the changepoint sets returned
by those algorithms. This is a conservative guess as to the likely size of
the optimal changepoint set.
</p>
</li>
<li> <p><code><a href="#topic+log_gabin_population">log_gabin_population()</a></code> takes a <code>ts</code> object and sets the initial
probability to the natural logarithm of the length of the time series.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>function</code> that can be passed to the <code>population</code> argument of
<code><a href="GA.html#topic+ga">GA::ga()</a></code> (through <code><a href="#topic+segment_ga">segment_ga()</a></code>)
</p>


<h3>See Also</h3>

<p><code><a href="GA.html#topic+ga_Population">GA::gabin_Population()</a></code>, <code><a href="#topic+segment_ga">segment_ga()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Build a function to generate the population
f &lt;- build_gabin_population(CET)

# Segment the time series using the population generation function
segment(CET, method = "ga", population = f, maxiter = 5)
f &lt;- log_gabin_population(CET)
segment(CET, method = "ga", population = f, maxiter = 10)
</code></pre>

<hr>
<h2 id='CET'>Hadley Centre Central England Temperature</h2><span id='topic+CET'></span>

<h3>Description</h3>

<p>Mean annual temperatures in Central England
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CET
</code></pre>


<h3>Format</h3>

<p>An object of class <code>xts</code> (inherits from <code>zoo</code>) with 366 rows and 1 columns.
</p>


<h3>Details</h3>

<p>The CET time series is perhaps the longest instrumental record of
surface temperatures in the world, commencing in 1659 and
spanning 362 years through 2020. The CET series is a benchmark
for European climate studies, as it is sensitive to atmospheric variability
in the North Atlantic (Parker et al. 1992). This record has been previously
analyzed for long-term changes (Plaut et al. 1995;
Harvey and Mills 2003; Hillebrand and Proietti 2017); however, to our
knowledge, no detailed changepoint analysis of it has been previously
conducted. The length of the CET record affords us the opportunity to
explore a variety of temperature features.
</p>


<h3>Source</h3>

<p><a href="https://www.metoffice.gov.uk/hadobs/hadcet/">https://www.metoffice.gov.uk/hadobs/hadcet/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Shi, et al. (2022, <a href="https://doi.org/10.1175/JCLI-D-21-0489.1">doi:10.1175/JCLI-D-21-0489.1</a>),
</p>
</li>
<li><p> Parker, et al. (1992, <a href="https://doi.org/10.1002/joc.3370120402">doi:10.1002/joc.3370120402</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="multitaper.html#topic+CETmonthly">multitaper::CETmonthly</a>
</p>

<hr>
<h2 id='changepoints'>Extract changepoints</h2><span id='topic+changepoints'></span><span id='topic+changepoints.default'></span><span id='topic+changepoints.mod_cpt'></span><span id='topic+changepoints.seg_basket'></span><span id='topic+changepoints.seg_cpt'></span><span id='topic+changepoints.tidycpt'></span><span id='topic+changepoints.ga'></span><span id='topic+changepoints.cpt'></span><span id='topic+changepoints.wbs'></span>

<h3>Description</h3>

<p>Retrieve the indices of the changepoints identified by an algorithm or model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>changepoints(x, ...)

## Default S3 method:
changepoints(x, ...)

## S3 method for class 'mod_cpt'
changepoints(x, ...)

## S3 method for class 'seg_basket'
changepoints(x, ...)

## S3 method for class 'seg_cpt'
changepoints(x, ...)

## S3 method for class 'tidycpt'
changepoints(x, use_labels = FALSE, ...)

## S3 method for class 'ga'
changepoints(x, ...)

## S3 method for class 'cpt'
changepoints(x, ...)

## S3 method for class 'wbs'
changepoints(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="changepoints_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tidycpt-class">tidycpt</a>, <code>segmenter</code>, or <a href="#topic+mod_cpt">mod_cpt</a> object</p>
</td></tr>
<tr><td><code id="changepoints_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="changepoints_+3A_use_labels">use_labels</code></td>
<td>
<p>return the time labels for the changepoints instead of the
indices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="#topic+tidycpt-class">tidycpt</a> objects, as well as their <code>segmenter</code> and <code>model</code> components,
implement <code><a href="#topic+changepoints">changepoints()</a></code> methods.
</p>
<p>Note that this function is not to be confused with <code><a href="wbs.html#topic+changepoints">wbs::changepoints()</a></code>,
which returns different information.
</p>
<p>For the <code>default</code> method, <code><a href="#topic+changepoints">changepoints()</a></code> will attempt to return the
<code>cpt_true</code> attribute, which is set by <code><a href="#topic+test_set">test_set()</a></code>.
</p>


<h3>Value</h3>

<p>a numeric vector of changepoint indices, or, if <code>use_labels</code> is
<code>TRUE</code>, a <code>character</code> of time labels.
</p>


<h3>See Also</h3>

<p><code><a href="wbs.html#topic+changepoints">wbs::changepoints()</a></code>
</p>
<p>Other tidycpt-generics: 
<code><a href="#topic+as.model">as.model</a>()</code>,
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+diagnose">diagnose</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cpts &lt;- segment(DataCPSim, method = "ga", maxiter = 5)
changepoints(cpts$segmenter)

cpts &lt;- segment(DataCPSim, method = "wbs")
changepoints(cpts$segmenter)

</code></pre>

<hr>
<h2 id='compare_models'>Compare various models or algorithms for a given changepoint set</h2><span id='topic+compare_models'></span><span id='topic+compare_algorithms'></span>

<h3>Description</h3>

<p>Compare various models or algorithms for a given changepoint set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_models(x, ...)

compare_algorithms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_models_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tidycpt-class">tidycpt</a> object</p>
</td></tr>
<tr><td><code id="compare_models_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <a href="#topic+tidycpt-class">tidycpt</a> object has a set of changepoints returned by the
algorithm that segmented the time series.
That changepoint set was obtained using a specific model.
Treating this changepoint set as fixed, the <code><a href="#topic+compare_models">compare_models()</a></code> function
fits several common changepoint models to the time series and changepoint
set, and returns the results of <code><a href="#topic+glance">glance()</a></code>.
Comparing the fits of various models could lead to improved understanding.
</p>
<p>Alternatively, <code><a href="#topic+compare_algorithms">compare_algorithms()</a></code> runs several fast changepoint detection
algorithms on the original time series, and consolidates the results.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tbl_df-class">tibble::tbl_df</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Segment a times series using PELT
x &lt;- segment(CET, method = "pelt")

# Compare models
compare_models(x)

# Compare algorithms
compare_algorithms(x)

</code></pre>

<hr>
<h2 id='cut_by_tau'>Use a changepoint set to break a time series into regions</h2><span id='topic+cut_by_tau'></span><span id='topic+split_by_tau'></span>

<h3>Description</h3>

<p>Use a changepoint set to break a time series into regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_by_tau(x, tau)

split_by_tau(x, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_by_tau_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="cut_by_tau_+3A_tau">tau</code></td>
<td>
<p>a numeric vector of changepoint indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A changepoint set <code>tau</code> of length <code class="reqn">k</code> breaks a time series of length
<code class="reqn">n</code> into <code class="reqn">k+1</code> non-empty regions.
These non-empty regions can be defined by half-open intervals, starting with
1 and ending with <code class="reqn">n+1</code>.
</p>
<p><code><a href="#topic+cut_by_tau">cut_by_tau()</a></code> splits a set of indices into a <code><a href="base.html#topic+factor">base::factor()</a></code> of
half-open intervals
</p>
<p><code><a href="#topic+split_by_tau">split_by_tau()</a></code> splits a time series into a named <code><a href="base.html#topic+list">base::list()</a></code> of numeric
vectors
</p>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+cut_by_tau">cut_by_tau()</a></code> a <code><a href="base.html#topic+factor">base::factor()</a></code> of half-open intervals
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+split_by_tau">split_by_tau()</a></code> a named <code><a href="base.html#topic+list">base::list()</a></code> of numeric
vectors
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">base::cut()</a></code>
</p>
<p><code><a href="base.html#topic+split">base::split()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- length(CET)

# Return a factor of intervals
cut_by_tau(1:n, tau = pad_tau(c(42, 81, 330), n))

# Return a list of observations
split_by_tau(DataCPSim, c(365, 826))

</code></pre>

<hr>
<h2 id='DataCPSim'>Simulated time series data</h2><span id='topic+DataCPSim'></span><span id='topic+rlnorm_ts_1'></span><span id='topic+rlnorm_ts_2'></span><span id='topic+rlnorm_ts_3'></span>

<h3>Description</h3>

<p>Randomly-generated time series data, using the <code><a href="stats.html#topic+Lognormal">stats::rlnorm()</a></code> function.
</p>

<ul>
<li><p> For <code>rlnorm_ts_1</code>, there is one changepoint located at 826.
</p>
</li>
<li><p> For <code>rlnorm_ts_2</code>, there are two changepoints, located at 366 and 731.
</p>
</li>
<li><p> For <code>rlnorm_ts_3</code>, there are three changepoints, located at 548, 823, and 973.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>DataCPSim

rlnorm_ts_1

rlnorm_ts_2

rlnorm_ts_3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 1096.
</p>
<p>An object of class <code>ts</code> of length 1096.
</p>
<p>An object of class <code>ts</code> of length 1096.
</p>
<p>An object of class <code>ts</code> of length 1096.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>DataCPSim</code>: Simulated time series of the same length as <a href="#topic+bogota_pm">bogota_pm</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+bogota_pm">bogota_pm</a>
</p>
<p><code><a href="stats.html#topic+ts">stats::ts()</a></code>, <code><a href="#topic+test_set">test_set()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(rlnorm_ts_1)
plot(rlnorm_ts_2)
plot(rlnorm_ts_3)
changepoints(rlnorm_ts_1)

</code></pre>

<hr>
<h2 id='deg_free'>Retrieve the degrees of freedom from a <code>logLik</code> object</h2><span id='topic+deg_free'></span>

<h3>Description</h3>

<p>Retrieve the degrees of freedom from a <code>logLik</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg_free(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deg_free_+3A_x">x</code></td>
<td>
<p>An object that implements a method for <code><a href="stats.html#topic+logLik">stats::logLik()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>df</code> attribute of the <code><a href="stats.html#topic+logLik">stats::logLik()</a></code> of the given object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve the degrees of freedom model a changepoint model
DataCPSim |&gt;
  segment() |&gt;
  as.model() |&gt;
  deg_free()
  
</code></pre>

<hr>
<h2 id='diagnose'>Diagnose the fit of a segmented time series</h2><span id='topic+diagnose'></span><span id='topic+diagnose.mod_cpt'></span><span id='topic+diagnose.seg_basket'></span><span id='topic+diagnose.tidycpt'></span><span id='topic+diagnose.nhpp'></span>

<h3>Description</h3>

<p>Depending on the input, this function returns a diagnostic plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose(x, ...)

## S3 method for class 'mod_cpt'
diagnose(x, ...)

## S3 method for class 'seg_basket'
diagnose(x, ...)

## S3 method for class 'tidycpt'
diagnose(x, ...)

## S3 method for class 'nhpp'
diagnose(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnose_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tidycpt-class">tidycpt</a> object, or a <code>model</code> or <code>segmenter</code></p>
</td></tr>
<tr><td><code id="diagnose_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object
</p>


<h3>See Also</h3>

<p>Other tidycpt-generics: 
<code><a href="#topic+as.model">as.model</a>()</code>,
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+changepoints">changepoints</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For meanshift models, show the distribution of the residuals by region
fit_meanshift_norm(CET, tau = 330) |&gt;
  diagnose()

# For Coen's algorithm, show the histogram of changepoint selections
x &lt;- segment(DataCPSim, method = "coen", num_generations = 3)
x |&gt;
  as.segmenter() |&gt;
  diagnose()


# Show various iterations of diagnostic plots
diagnose(segment(DataCPSim))
diagnose(segment(DataCPSim, method = "single-best"))
diagnose(segment(DataCPSim, method = "pelt"))

# Show diagnostic plots for test sets
diagnose(segment(test_set()))
diagnose(segment(test_set(n = 2, sd = 4), method = "pelt"))

# For NHPP models, show the growth in the number of exceedances
diagnose(fit_nhpp(DataCPSim, tau = 826))
diagnose(fit_nhpp(DataCPSim, tau = 826, threshold = 200))

</code></pre>

<hr>
<h2 id='evaluate_cpts'>Evaluate candidate changepoints sets</h2><span id='topic+evaluate_cpts'></span><span id='topic+evaluate_cpts.seg_basket'></span><span id='topic+evaluate_cpts.list'></span><span id='topic+evaluate_cpts.tbl_df'></span>

<h3>Description</h3>

<p>Evaluate candidate changepoints sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_cpts(x, ...)

## S3 method for class 'seg_basket'
evaluate_cpts(x, ...)

## S3 method for class 'list'
evaluate_cpts(x, .data, model_fn, ...)

## S3 method for class 'tbl_df'
evaluate_cpts(x, .data, model_fn, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_cpts_+3A_x">x</code></td>
<td>
<p>An object to evaluate</p>
</td></tr>
<tr><td><code id="evaluate_cpts_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="evaluate_cpts_+3A_.data">.data</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="evaluate_cpts_+3A_model_fn">model_fn</code></td>
<td>
<p>Name of the function to fit the model.
See, for examples, <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tbl_df-class">tibble::tbl_df</a>
</p>

<hr>
<h2 id='evolve_gbmdl'>Generate a list of candidate changepoints using a genetic algorithm</h2><span id='topic+evolve_gbmdl'></span><span id='topic+junta_1_puntos_cambio'></span><span id='topic+junta_k_puntos_cambio'></span><span id='topic+mata_1_tau_volado'></span><span id='topic+mata_k_tau_volado'></span><span id='topic+muta_1_cp_BMDL'></span><span id='topic+muta_k_cp_BMDL'></span><span id='topic+sim_1_cp_BMDL'></span><span id='topic+sim_k_cp_BMDL'></span><span id='topic+probs_vec_MDL'></span><span id='topic+selec_k_pares_de_padres'></span><span id='topic+chromo2tau'></span><span id='topic+mat_cp_2_list'></span>

<h3>Description</h3>

<p>Generate a list of candidate changepoints using a genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evolve_gbmdl(x, mat_cp, these_bmdls)

junta_1_puntos_cambio(padres, mat_cp)

junta_k_puntos_cambio(mat_padres, mat_cp)

mata_1_tau_volado(cp, prob_volado = 0.5)

mata_k_tau_volado(mat_cp)

muta_1_cp_BMDL(
  cp,
  x,
  probs_nuevos_muta0N = c(0.8, 0.1, 0.1),
  dist_extremos = 10,
  min_num_cpts = 1,
  mutation_possibilities = c(-1, 0, 1),
  mutation_probs = c(0.3, 0.4, 0.3),
  max_num_cp = 20
)

muta_k_cp_BMDL(mat_cp, x)

sim_1_cp_BMDL(x, max_num_cp = 20, prob_inicial = 0.06)

sim_k_cp_BMDL(x, generation_size = 50, max_num_cp = 20)

probs_vec_MDL(vec_MDL, probs_rank0_MDL1 = 0)

selec_k_pares_de_padres(vec_probs)

chromo2tau(chromo)

mat_cp_2_list(mat_cp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evolve_gbmdl_+3A_x">x</code></td>
<td>
<p>A time series object</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_mat_cp">mat_cp</code></td>
<td>
<p>A matrix of potential changepoints</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_these_bmdls">these_bmdls</code></td>
<td>
<p>vector of <code><a href="#topic+BMDL">BMDL()</a></code> scores</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_padres">padres</code></td>
<td>
<p>vector de longitud dos con índice de papa e índice de mama</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_mat_padres">mat_padres</code></td>
<td>
<p>matriz de kx2 la cual contiene en sus renglones las
parejas de padres</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_cp">cp</code></td>
<td>
<p>vector cromosoma que se va a poner a prueba</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_prob_volado">prob_volado</code></td>
<td>
<p>probabilidad de quitar un tiempo de cambio existente
utilizado por mata_k_tau_volado para quitar elementos de más. Se recomienda
dejar el valor de 0.5 ya que así al juntar los pc del padre y madre se
eliminará la mitad de estos</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_probs_nuevos_muta0n">probs_nuevos_muta0N</code></td>
<td>
<p>probabilidades de mutar 0,1,2,...,l hasta cierto
numero l; eg si vale c(.5,.2,.2,.1) se tiene una probabilidad 0.5 de mutar
0 (de no mutar), probabilidad 0.2 de mutar 1,, probabilidad 0.2 de mutar 2,
y, probabilidad 0.1 de mutar 3.</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_dist_extremos">dist_extremos</code></td>
<td>
<p>distancia entre el primer los puntos de cambio v_0 y v_1
al igual que entre v_m y v_{m+1}; distancia minima que debe de haber de un
punto de cambio y los valores 1 y T, donde T es la longitud total de la
serie</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_min_num_cpts">min_num_cpts</code></td>
<td>
<p>es la cota inferior del número de puntos de cambio
que puede tener un cromosoma</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_mutation_possibilities">mutation_possibilities</code></td>
<td>
<p>vector con mutaciones posibles; eg si mutaciones=c(-1,0,1)
entonces un punto de cambio puede ser movido una unidad a la izquierda,
puede quedarse igual, o moverse una unidad a la derecha</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_mutation_probs">mutation_probs</code></td>
<td>
<p>probabilidades de mutación. Las longitudes de este vector y
mutaciones tienen que ser iguales; eg si mutaciones=c(-1,0,1) y probs_muta
= c(.2, .6, .2) entonces se tiene una probabilidad .2 de que el punto de
cambio se desplace a la izquierda, probabilidad .6 de quedar igual, y
probabilidad . 2 de ser movido a la derecha</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_max_num_cp">max_num_cp</code></td>
<td>
<p>el máximo número de rebases. Este parámetro se ocupa en
particular para que todos los cromosomas quepan en una matriz.</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_prob_inicial">prob_inicial</code></td>
<td>
<p>probabilidad de que en la primera generación un punto
cualquiera sea punto de cambio. Se recomienda =.5 ya que con esto se
distribuyen relativamente uniformes los puntos de cambio</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_generation_size">generation_size</code></td>
<td>
<p>tamaño de las generaciones</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_vec_mdl">vec_MDL</code></td>
<td>
<p>vector con valores MDL
</p>
<p>OBSERVACIÓN: Esto regresa numeros negativos, los cuales mientras más negativo mejor, ya que
dará que es un mejor vector de tiempos de cambio. Es decir, un MDL de -6000 es
mejor que -4000</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_probs_rank0_mdl1">probs_rank0_MDL1</code></td>
<td>
<p>para medir obtener la probabilidad de los padres se
pueden tomar o las probabilidades con respecto a los rangos (como en el
artículo) o se pueden tomar las probabilidades con respecto a el MDL. La
diferencia radica en que si se toma con respecto al MDL se tendrá que un
cromosoma con un gran MDL este tendrá una gran ventaja de ocurrir, en
cambio cuando solo se tiene rank esta ventaja gran ventaja se reduce</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_vec_probs">vec_probs</code></td>
<td>
<p>vector de probabilidades de selección de cada uno de los
cromosomas</p>
</td></tr>
<tr><td><code id="evolve_gbmdl_+3A_chromo">chromo</code></td>
<td>
<p>Chromosome, from a row of the matrix <code>mat_cp</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>regresa un vector de tamaño <code>max_num_cp+3</code> donde la primera entrada es
m, la segunda <code class="reqn">v_0=1, ...., v_{m+1}=N,0,...,0</code>
</p>
<p>por ejemplo: <code>c(4,1,3,8,11,15,20,0,0,0,0)</code> para <code>m=4</code>, <code class="reqn">max\_num\_cp=8</code>, <code class="reqn">N=20</code>.
Se tienen <code>m</code> puntos de cambio, los cuales
<code class="reqn">\tau_0=1</code> y <code class="reqn">\tau_{m+1}= N+1</code>,
pero en nuestro caso
tenemos que los vectores <code>cp</code> tienen <code class="reqn">c(m,\tau_0=1,\tau_1,...,\tau_{m-1},\tau_m= N,0,0,0)</code>
por lo cual se nosotros:
</p>

<ul>
<li><p> empieza con el número de puntos de cambio;
</p>
</li>
<li><p> la segunda entrada es un uno;
</p>
</li>
<li><p> la tercera entrada es el primer punto de cambio;
</p>
</li>
<li><p> las siguientes son otros puntos de cambio;
</p>
</li>
<li><p> la siguiente entrada después de punto de cambio tiene el valor  <code>N</code>; y
</p>
</li>
<li><p> los siguientes son númores cero hasta llenarlo para que sea de tamaño <code>max_num_cp</code>
</p>
</li></ul>



<h3>Value</h3>

<p>regresa una matriz de las mismas dimensiones que mat_cp, pero con los
nuevos cromosomas
</p>
<p>el mismo cromosoma sin algunos de sus puntos de cambio
</p>
<p>regresa una matriz a la cual se le quitaron a sus cromosomas algunos
puntos de cambio
</p>
<p>regresa un vector mutado
</p>
<p>regreas una mat_cp mutada
</p>
<p>regresa una matriz de <code>k</code> por <code>max_num_cp+3</code>, la cual en cada renglón tiene
una simulación de un vector de tiempos de cambio
</p>
<p>regresa un vector de probabilidades
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat_cp &lt;- sim_k_cp_BMDL(DataCPSim)
bmdls &lt;- mat_cp |&gt; 
  mat_cp_2_list() |&gt; 
  evaluate_cpts(.data = as.ts(DataCPSim), model_fn = fit_nhpp) |&gt; 
  dplyr::pull(BMDL)
evolve_gbmdl(exceedances(DataCPSim), mat_cp, bmdls)
sim_1_cp_BMDL(exceedances(DataCPSim))
sim_1_cp_BMDL(exceedances(rlnorm_ts_1))
sim_1_cp_BMDL(exceedances(rlnorm_ts_2))
sim_1_cp_BMDL(exceedances(rlnorm_ts_3))
sim_1_cp_BMDL(exceedances(bogota_pm))

sim_k_cp_BMDL(DataCPSim)

chromo &lt;- c(4, 1, 557, 877 , 905, 986, 1096, 0, 0, 0)
chromo2tau(chromo)
</code></pre>

<hr>
<h2 id='exceedances'>Compute exceedances of a threshold for a time series</h2><span id='topic+exceedances'></span><span id='topic+exceedances.default'></span><span id='topic+exceedances.nhpp'></span><span id='topic+exceedances.ts'></span><span id='topic+exceedances.double'></span>

<h3>Description</h3>

<p>Compute exceedances of a threshold for a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceedances(x, ...)

## Default S3 method:
exceedances(x, ...)

## S3 method for class 'nhpp'
exceedances(x, ...)

## S3 method for class 'ts'
exceedances(x, ...)

## S3 method for class 'double'
exceedances(x, threshold = mean(x, na.rm = TRUE), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exceedances_+3A_x">x</code></td>
<td>
<p>a numeric vector coercible into a <a href="stats.html#topic+ts">stats::ts</a> object</p>
</td></tr>
<tr><td><code id="exceedances_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
<tr><td><code id="exceedances_+3A_threshold">threshold</code></td>
<td>
<p>A value above which to exceed. Default is the <code><a href="base.html#topic+mean">mean()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ordered <code>integer</code> vector giving the indices of the values of <code>x</code>
that exceed the <code>threshold</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve exceedances of the series mean
fit_nhpp(DataCPSim, tau = 826) |&gt; 
  exceedances()

# Retrieve exceedances of a supplied threshold
fit_nhpp(DataCPSim, tau = 826, threshold = 200) |&gt; 
  exceedances()
</code></pre>

<hr>
<h2 id='file_name'>Obtain a descriptive filename for a tidycpt object</h2><span id='topic+file_name'></span>

<h3>Description</h3>

<p>Obtain a descriptive filename for a tidycpt object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_name(x, data_name_slug = "data")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_name_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+tidycpt-class">tidycpt</a> object</p>
</td></tr>
<tr><td><code id="file_name_+3A_data_name_slug">data_name_slug</code></td>
<td>
<p>character string that will identify the data set used
in the file name</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+file_name">file_name()</a></code> generates a random, unique string indicating the algorithm and
<code><a href="#topic+fitness">fitness()</a></code> for a <a href="#topic+tidycpt-class">tidycpt</a> object.
</p>


<h3>Value</h3>

<p>A <code>character</code> string giving a unique file name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a unique name for the file
DataCPSim |&gt;
  segment(method = "pelt") |&gt;
  file_name()
</code></pre>

<hr>
<h2 id='fit_lmshift'>Regression-based model fitting</h2><span id='topic+fit_lmshift'></span><span id='topic+fit_lmshift_ar1'></span><span id='topic+fit_trendshift'></span><span id='topic+fit_trendshift_ar1'></span>

<h3>Description</h3>

<p>Regression-based model fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lmshift(x, tau, deg_poly = 0, ...)

fit_lmshift_ar1(x, tau, ...)

fit_trendshift(x, tau, ...)

fit_trendshift_ar1(x, tau, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_lmshift_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="fit_lmshift_+3A_tau">tau</code></td>
<td>
<p>a set of indices representing a changepoint set</p>
</td></tr>
<tr><td><code id="fit_lmshift_+3A_deg_poly">deg_poly</code></td>
<td>
<p>integer indicating the degree of the polynomial spline to be
fit. Passed to <code><a href="stats.html#topic+poly">stats::poly()</a></code>.</p>
</td></tr>
<tr><td><code id="fit_lmshift_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+lm">stats::lm()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These model-fitting functions use <code><a href="stats.html#topic+lm">stats::lm()</a></code> to fit the corresponding
regression model to a time series, using the changepoints specified by the
<code>tau</code> argument.
Each changepoint is treated as a categorical fixed-effect, while the <code>deg_poly</code>
argument controls the degree of the polynomial that interacts with those
fixed-effects.
For example, setting <code>deg_poly</code> equal to 0 will return the same model as
calling <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code>, but the latter is faster for larger changepoint
sets because it doesn't have to fit all of the regression models.
</p>
<p>Setting <code>deg_poly</code> equal to 1 fits the <code>trendshift</code> model.
</p>

<ul>
<li> <p><code><a href="#topic+fit_lmshift_ar1">fit_lmshift_ar1()</a></code>: will apply auto-regressive lag 1 errors
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+fit_trendshift">fit_trendshift()</a></code>: will fit a line in each region
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+fit_trendshift_ar1">fit_trendshift_ar1()</a></code>: will fit a line in each region and autoregress lag 1 errors
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="#topic+mod_cpt">mod_cpt</a> object
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Manually specify a changepoint set
tau &lt;- c(365, 826)

# Fit the model
mod &lt;- fit_lmshift(DataCPSim, tau)

# Retrieve model parameters
logLik(mod)
deg_free(mod)

# Manually specify a changepoint set
cpts &lt;- c(1700, 1739, 1988)
ids &lt;- time2tau(cpts, as_year(time(CET)))

# Fit the model
mod &lt;- fit_lmshift(CET, tau = ids)

# View model parameters
glance(mod)
glance(fit_lmshift(CET, tau = ids, deg_poly = 1))
glance(fit_lmshift_ar1(CET, tau = ids))
glance(fit_lmshift_ar1(CET, tau = ids, deg_poly = 1))
glance(fit_lmshift_ar1(CET, tau = ids, deg_poly = 2))

# Empty changepoint sets are allowed
fit_lmshift(CET, tau = NULL)

# Duplicate changepoints are removed
fit_lmshift(CET, tau = c(42, 42))

</code></pre>

<hr>
<h2 id='fit_meanshift'>Fast implementation of meanshift model</h2><span id='topic+fit_meanshift'></span><span id='topic+fit_meanshift_norm'></span><span id='topic+fit_meanshift_lnorm'></span><span id='topic+fit_meanshift_norm_ar1'></span>

<h3>Description</h3>

<p>Fast implementation of meanshift model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_meanshift(x, tau, distribution = "norm", ...)

fit_meanshift_norm(x, tau, ...)

fit_meanshift_lnorm(x, tau, ...)

fit_meanshift_norm_ar1(x, tau, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_meanshift_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="fit_meanshift_+3A_tau">tau</code></td>
<td>
<p>a set of indices representing a changepoint set</p>
</td></tr>
<tr><td><code id="fit_meanshift_+3A_distribution">distribution</code></td>
<td>
<p>A character indicating the distribution of the data.
Should match R distribution function naming conventions
(e.g., &quot;norm&quot; for the Normal distribution, etc.)</p>
</td></tr>
<tr><td><code id="fit_meanshift_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+lm">stats::lm()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code> returns the same model as <code><a href="#topic+fit_lmshift">fit_lmshift()</a></code> with the
<code>deg_poly</code> argument set to 0.
However, it is faster on large changepoint sets.
</p>
<p><code><a href="#topic+fit_meanshift_lnorm">fit_meanshift_lnorm()</a></code> fit the meanshift model with the assumption of
log-normally distributed data.
</p>
<p><code><a href="#topic+fit_meanshift_norm_ar1">fit_meanshift_norm_ar1()</a></code> applies autoregressive errors.
</p>


<h3>Value</h3>

<p>A <a href="#topic+mod_cpt">mod_cpt</a> object.
</p>


<h3>Author(s)</h3>

<p>Xueheng Shi, Ben Baumer
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Manually specify a changepoint set
tau &lt;- c(365, 826)

# Fit the model
mod &lt;- fit_meanshift_norm_ar1(DataCPSim, tau)

# View model parameters
logLik(mod)
deg_free(mod)

# Manually specify a changepoint set
cpts &lt;- c(1700, 1739, 1988)
ids &lt;- time2tau(cpts, as_year(time(CET)))

# Fit the model
mod &lt;- fit_meanshift_norm(CET, tau = ids)

# Review model parameters
glance(mod)

# Fit an autoregressive model
mod &lt;- fit_meanshift_norm_ar1(CET, tau = ids)

# Review model parameters
glance(mod)

</code></pre>

<hr>
<h2 id='fit_meanvar'>Fit a model for mean and variance</h2><span id='topic+fit_meanvar'></span>

<h3>Description</h3>

<p>Fit a model for mean and variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_meanvar(x, tau, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_meanvar_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="fit_meanvar_+3A_tau">tau</code></td>
<td>
<p>a set of indices representing a changepoint set</p>
</td></tr>
<tr><td><code id="fit_meanvar_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a mean-variance model, both the means and variances are allowed to vary
across regions.
Thus, this model fits a separate <code class="reqn">\mu_j</code> and <code class="reqn">\sigma_j</code> for each
region <code class="reqn">j</code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+mod_cpt">mod_cpt</a> object.
</p>


<h3>See Also</h3>

<p><code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code>
</p>
<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a mean-variance model
fit_meanvar(CET, tau = c(42, 330))

</code></pre>

<hr>
<h2 id='fit_nhpp'>Fit a non-homogeneous Poisson process model to the exceedances of a time series.</h2><span id='topic+fit_nhpp'></span>

<h3>Description</h3>

<p>Fit a non-homogeneous Poisson process model to the exceedances of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_nhpp(x, tau, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_nhpp_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="fit_nhpp_+3A_tau">tau</code></td>
<td>
<p>A vector of changepoints</p>
</td></tr>
<tr><td><code id="fit_nhpp_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any time series can be modeled as a non-homogeneous Poisson process of the
locations of the <a href="#topic+exceedances">exceedances</a> of a threshold in the series.
This function uses the <a href="#topic+BMDL">BMDL</a> criteria to determine the best fit
parameters for each
region defined by the changepoint set <code>tau</code>.
</p>


<h3>Value</h3>

<p>An <code>nhpp</code> object, which inherits from <a href="#topic+mod_cpt">mod_cpt</a>.
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit an NHPP model using the mean as a threshold
fit_nhpp(DataCPSim, tau = 826)

# Fit an NHPP model using other thresholds
fit_nhpp(DataCPSim, tau = 826, threshold = 20)
fit_nhpp(DataCPSim, tau = 826, threshold = 200)

# Fit an NHPP model using changepoints determined by PELT
fit_nhpp(DataCPSim, tau = changepoints(segment(DataCPSim, method = "pelt")))

</code></pre>

<hr>
<h2 id='fit_nhpp_region'>Fit an NHPP model to one specific region</h2><span id='topic+fit_nhpp_region'></span>

<h3>Description</h3>

<p>Fit an NHPP model to one specific region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_nhpp_region(exc, tau_left, tau_right, params = parameters_weibull(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_nhpp_region_+3A_exc">exc</code></td>
<td>
<p>Output from <code><a href="#topic+exceedances">exceedances()</a></code></p>
</td></tr>
<tr><td><code id="fit_nhpp_region_+3A_tau_left">tau_left</code></td>
<td>
<p>left-most changepoint</p>
</td></tr>
<tr><td><code id="fit_nhpp_region_+3A_tau_right">tau_right</code></td>
<td>
<p>right-most changepoint</p>
</td></tr>
<tr><td><code id="fit_nhpp_region_+3A_params">params</code></td>
<td>
<p>Output from <code><a href="#topic+parameters_weibull">parameters_weibull()</a></code></p>
</td></tr>
<tr><td><code id="fit_nhpp_region_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+optim">stats::optim()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function not to be called by users.
Use <code><a href="#topic+fit_nhpp">fit_nhpp()</a></code>.
</p>


<h3>Value</h3>

<p>Modified output from <code><a href="stats.html#topic+optim">stats::optim()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_nhpp">fit_nhpp()</a></code>
</p>

<hr>
<h2 id='fitness'>Retrieve the optimal fitness (or objective function) value used by an
algorithm</h2><span id='topic+fitness'></span><span id='topic+fitness.seg_basket'></span><span id='topic+fitness.seg_cpt'></span><span id='topic+fitness.tidycpt'></span><span id='topic+fitness.ga'></span><span id='topic+fitness.cpt'></span><span id='topic+fitness.wbs'></span>

<h3>Description</h3>

<p>Retrieve the optimal fitness (or objective function) value used by an
algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitness(object, ...)

## S3 method for class 'seg_basket'
fitness(object, ...)

## S3 method for class 'seg_cpt'
fitness(object, ...)

## S3 method for class 'tidycpt'
fitness(object, ...)

## S3 method for class 'ga'
fitness(object, ...)

## S3 method for class 'cpt'
fitness(object, ...)

## S3 method for class 'wbs'
fitness(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitness_+3A_object">object</code></td>
<td>
<p>A <code>segmenter</code> object.</p>
</td></tr>
<tr><td><code id="fitness_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Segmenting algorithms use a <strong>fitness</strong> metric, typically through the use of
a penalized objective function, to determine which changepoint sets are more
or less optimal.
This function returns the value of that metric for the changepoint set
implied by the object provided.
</p>


<h3>Value</h3>

<p>A named <code>double</code> vector with the fitness value.
</p>


<h3>See Also</h3>

<p>Other tidycpt-generics: 
<code><a href="#topic+as.model">as.model</a>()</code>,
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+changepoints">changepoints</a>()</code>,
<code><a href="#topic+diagnose">diagnose</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>
</p>
<p>Other segmenter-functions: 
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+seg_params">seg_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a times series using a genetic algorithm
x &lt;- segment(DataCPSim, method = "ga", maxiter = 10)

# Retrieve its fitness value
fitness(x)

# Segment a time series using Wild Binary Segmentation
x &lt;- segment(DataCPSim, method = "wbs")

# Retrive its fitness
fitness(x)

</code></pre>

<hr>
<h2 id='HQC'>Hannan–Quinn information criterion</h2><span id='topic+HQC'></span><span id='topic+HQC.default'></span><span id='topic+HQC.logLik'></span>

<h3>Description</h3>

<p>Hannan–Quinn information criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HQC(object, ...)

## Default S3 method:
HQC(object, ...)

## S3 method for class 'logLik'
HQC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HQC_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="HQC_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Hannan-Quinn information criterion for a model <code class="reqn">M</code>
</p>
<p style="text-align: center;"><code class="reqn">
  HQC(\tau, M(y|\hat{\theta}_{\tau})) = 2k \cdot \ln{\ln{n}} - 2 \cdot L_M(y|\hat{\theta}_\tau) \,,
</code>
</p>

<p>where <code class="reqn">k</code> is the number of parameters and <code class="reqn">n</code> is the number of observations.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">stats::BIC()</a></code>, <code><a href="stats.html#topic+AIC">stats::AIC()</a></code>
</p>
<p>Other penalty-functions: 
<code><a href="#topic+BMDL">BMDL</a>()</code>,
<code><a href="#topic+MBIC">MBIC</a>()</code>,
<code><a href="#topic+MDL">MDL</a>()</code>,
<code><a href="#topic+SIC">SIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the HQC
HQC(fit_meanvar(CET, tau = NULL))

HQC(fit_meanshift_norm_ar1(CET, tau = c(42, 330)))
HQC(fit_trendshift(CET, tau = c(42, 81, 330)))
</code></pre>

<hr>
<h2 id='italy_grads'>Italian University graduates by disciplinary groups from 1926-2013</h2><span id='topic+italy_grads'></span>

<h3>Description</h3>

<p>Italian University graduates by disciplinary groups during the years 1926-2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>italy_grads
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_ts</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 88 rows and 17 columns.
</p>


<h3>Source</h3>

<p><a href="https://seriestoriche.istat.it/">https://seriestoriche.istat.it/</a>
</p>
<p>Source: Istat- Ministero dell'istruzione pubblica, years 1926-1942
</p>
<p>Istat- Rilevazione sulle Università, years 1943-1997
</p>
<p>Miur- Rilevazione sulle Università, years 1998-2013
</p>

<hr>
<h2 id='iweibull'>Weibull distribution functions</h2><span id='topic+iweibull'></span><span id='topic+mweibull'></span><span id='topic+parameters_weibull'></span>

<h3>Description</h3>

<p>Weibull distribution functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iweibull(x, shape, scale = 1)

mweibull(x, shape, scale = 1)

parameters_weibull(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iweibull_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="iweibull_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for Weibull distribution. See <code><a href="stats.html#topic+Weibull">stats::dweibull()</a></code>.</p>
</td></tr>
<tr><td><code id="iweibull_+3A_scale">scale</code></td>
<td>
<p>Scale parameter for Weibull distribution. See <code><a href="stats.html#topic+Weibull">stats::dweibull()</a></code>.</p>
</td></tr>
<tr><td><code id="iweibull_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intensity function for the Weibull distribution.
</p>
<p style="text-align: center;"><code class="reqn">
   iweibull(x) = \left( \frac{shape}{scale} \right) \cdot 
                 \left( \frac{x}{scale} \right)^{shape - 1}
 </code>
</p>

<p>Mean intensity function for the Weibull distribution.
</p>
<p style="text-align: center;"><code class="reqn">
   mweibull(x) = \left( \frac{x}{scale} \right)^{shape}
 </code>
</p>

<p><code><a href="#topic+parameters_weibull">parameters_weibull()</a></code> returns a <code>list()</code> with two components: <code>shape</code>
and <code>scale</code>, each of which is a <code>list()</code> of distribution parameters.
These parameters are used to define the prior distributions for the
hyperparameters.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">stats::dweibull()</a></code>
</p>
<p><code><a href="stats.html#topic+GammaDist">stats::dgamma()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the intensities and plot them
iweibull(1, shape = 1, scale = 1)
plot(x = 1:10, y = iweibull(1:10, shape = 2, scale = 2))

# Compute various values of the distribution
mweibull(1, shape = 1, scale = 1)
plot(x = 1:10, y = mweibull(1:10, shape = 1, scale = 1))
plot(x = 1:10, y = mweibull(1:10, shape = 1, scale = 2))
plot(x = 1:10, y = mweibull(1:10, shape = 0.5, scale = 2))
plot(x = 1:10, y = mweibull(1:10, shape = 0.5, scale = 100))
plot(x = 1:10, y = mweibull(1:10, shape = 2, scale = 2))
plot(x = 1:10, y = mweibull(1:10, shape = 2, scale = 100))

# Generate prior distribution hyperparameters
parameters_weibull()

</code></pre>

<hr>
<h2 id='log_likelihood_region_weibull'>Log-Likelihood functions for regions (Weibull)</h2><span id='topic+log_likelihood_region_weibull'></span><span id='topic+log_prior_region_weibull'></span><span id='topic+D_log_prior_region_weibull'></span><span id='topic+D_log_likelihood_region_weibull'></span>

<h3>Description</h3>

<p>Log-Likelihood functions for regions (Weibull)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_likelihood_region_weibull(t, tau_left, tau_right, theta)

log_prior_region_weibull(theta, params = parameters_weibull())

D_log_prior_region_weibull(theta, params = parameters_weibull())

D_log_likelihood_region_weibull(t, tau_left, tau_right, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_likelihood_region_weibull_+3A_t">t</code></td>
<td>
<p>vector of <code><a href="#topic+exceedances">exceedances()</a></code></p>
</td></tr>
<tr><td><code id="log_likelihood_region_weibull_+3A_tau_left">tau_left</code></td>
<td>
<p>Left endpoint of the region</p>
</td></tr>
<tr><td><code id="log_likelihood_region_weibull_+3A_tau_right">tau_right</code></td>
<td>
<p>Right endpoint of the region</p>
</td></tr>
<tr><td><code id="log_likelihood_region_weibull_+3A_theta">theta</code></td>
<td>
<p>numeric vector of parameters for the NHPP model</p>
</td></tr>
<tr><td><code id="log_likelihood_region_weibull_+3A_params">params</code></td>
<td>
<p>Possibly modified output from <code><a href="#topic+parameters_weibull">parameters_weibull()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>

<hr>
<h2 id='ls_models'>Algorithmic coverage through tidychangepoint</h2><span id='topic+ls_models'></span><span id='topic+ls_pkgs'></span><span id='topic+ls_methods'></span><span id='topic+ls_penalties'></span><span id='topic+ls_cpt_penalties'></span><span id='topic+ls_coverage'></span>

<h3>Description</h3>

<p>Algorithmic coverage through tidychangepoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_models()

ls_pkgs()

ls_methods()

ls_penalties()

ls_cpt_penalties()

ls_coverage()
</code></pre>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> or <code>character</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+segment">segment()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List all model-fitting functions
ls_models()

# List packages supported by tidychangepoint
ls_pkgs()

# List methods supported by segment()
ls_methods()

# List penalty functions provided by tidychangepoint
ls_penalties()

# List penalty functions supported by changepoint
ls_cpt_penalties()

# List combinations of method, model, and penalty supported by tidychangepoint
ls_coverage()

</code></pre>

<hr>
<h2 id='MBIC'>Modified Bayesian Information Criterion</h2><span id='topic+MBIC'></span><span id='topic+MBIC.default'></span><span id='topic+MBIC.logLik'></span>

<h3>Description</h3>

<p>Generic function to compute the Modified Bayesian Information Criterion for a
changepoint detection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MBIC(object, ...)

## Default S3 method:
MBIC(object, ...)

## S3 method for class 'logLik'
MBIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MBIC_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="MBIC_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> vector of length 1
</p>


<h3>References</h3>

<p>Zhang and Seigmmund (2007) for MBIC: <a href="https://doi.org/10.1111/j.1541-0420.2006.00662.x">doi:10.1111/j.1541-0420.2006.00662.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">stats::BIC()</a></code>
</p>
<p>Other penalty-functions: 
<code><a href="#topic+BMDL">BMDL</a>()</code>,
<code><a href="#topic+HQC">HQC</a>()</code>,
<code><a href="#topic+MDL">MDL</a>()</code>,
<code><a href="#topic+SIC">SIC</a>()</code>
</p>

<hr>
<h2 id='mcdf'>Cumulative distribution of the exceedances of a time series</h2><span id='topic+mcdf'></span>

<h3>Description</h3>

<p>Cumulative distribution of the exceedances of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcdf(x, dist = "weibull")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcdf_+3A_x">x</code></td>
<td>
<p>An NHPP <code>model</code> returned by <code><a href="#topic+fit_nhpp">fit_nhpp()</a></code></p>
</td></tr>
<tr><td><code id="mcdf_+3A_dist">dist</code></td>
<td>
<p>Name of the distribution. Currently only <code>weibull</code> is implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length equal to the <a href="#topic+exceedances">exceedances</a> of <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_intensity">plot_intensity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit an NHPP model using the mean as a threshold
nhpp &lt;- fit_nhpp(DataCPSim, tau = 826)

# Compute the cumulative exceedances of the mean
mcdf(nhpp)

# Fit an NHPP model using another threshold
nhpp &lt;- fit_nhpp(DataCPSim, tau = 826, threshold = 200)

# Compute the cumulative exceedances of the threshold
mcdf(nhpp)

</code></pre>

<hr>
<h2 id='mde_rain'>Rainfall in Medellín, Colombia</h2><span id='topic+mde_rain'></span><span id='topic+mde_rain_monthly'></span>

<h3>Description</h3>

<p>Rainfall in Medellín, Colombia
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mde_rain

mde_rain_monthly
</code></pre>


<h3>Format</h3>

<p>An object of class <code>spec_tbl_df</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 185705 rows and 8 columns.
</p>
<p>An object of class <code>xts</code> (inherits from <code>zoo</code>) with 444 rows and 1 columns.
</p>


<h3>Details</h3>

<p>Daily rainfall measurements for 13 different weather stations positioned
around Medellín, Colombia.
Variables:
</p>

<ul>
<li> <p><code>station_id</code>:
</p>
</li>
<li> <p><code>lat</code>, <code>long</code>: latitude and longitude for the weather station
</p>
</li>
<li> <p><code>date</code>, <code>year</code>, <code>month</code>, <code>day</code>: date variables
</p>
</li>
<li> <p><code>rainfall</code>: daily rainfall (in cubic centimeters) as measured by the weather station
</p>
</li></ul>


<ul>
<li> <p><code>mean_rainfall</code>: average rainfall across all weather stations
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://www.openstreetmap.org/?mlat=6.244747&amp;mlon=-75.574828&amp;zoom=12">OpenStreetMap</a>
</p>

<hr>
<h2 id='MDL'>Maximum Descriptive Length</h2><span id='topic+MDL'></span><span id='topic+MDL.default'></span><span id='topic+MDL.logLik'></span>

<h3>Description</h3>

<p>Generic function to compute the Maximum Descriptive Length for a
changepoint detection model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDL(object, ...)

## Default S3 method:
MDL(object, ...)

## S3 method for class 'logLik'
MDL(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MDL_+3A_object">object</code></td>
<td>
<p>any object from which a log-likelihood value, or a
contribution to a log-likelihood value, can be extracted.</p>
</td></tr>
<tr><td><code id="MDL_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">
   P_{MDL}(\tau) = \frac{a(\theta_\tau)}{2} \cdot 
     \sum_{j=0}^m \log{\left(\tau_j - \tau_{j-1} \right)} + 2 \ln{m} + \sum_{j=2}^m \ln{\tau_j} + 
     \left( 2 + b(\theta_\tau) \right) \ln{n} 
 </code>
</p>

<p>where <code class="reqn">a(\theta)</code> is the number of parameters in <code class="reqn">\theta</code> that are
fit in each region, and <code class="reqn">b(\theta)</code> is the number of parameters
fit to the model as a whole.
</p>
<p>These quantities should be <code><a href="base.html#topic+attributes">base::attributes()</a></code> of the object returned by
<code><a href="#topic+logLik">logLik()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>double</code> vector of length 1
</p>


<h3>See Also</h3>

<p>Other penalty-functions: 
<code><a href="#topic+BMDL">BMDL</a>()</code>,
<code><a href="#topic+HQC">HQC</a>()</code>,
<code><a href="#topic+MBIC">MBIC</a>()</code>,
<code><a href="#topic+SIC">SIC</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MDL(fit_meanshift_norm_ar1(CET, tau = c(42, 330)))
MDL(fit_trendshift(CET, tau = c(42, 81, 330)))
</code></pre>

<hr>
<h2 id='mlb_diffs'>Differences between leagues in Major League Baseball</h2><span id='topic+mlb_diffs'></span>

<h3>Description</h3>

<p>The difference in various statistics between the
American League and the National League from 1925 to 2023.
Statistics include:
</p>

<ul>
<li> <p><code>PA</code>: The total number of plate appearances
</p>
</li>
<li> <p><code>hr_rate_diff</code>: The difference in home runs per plate appearance
</p>
</li>
<li> <p><code>bavg_dff</code>: The difference in batting average
</p>
</li>
<li> <p><code>obp_diff</code>: The difference in on-base percentage
</p>
</li>
<li> <p><code>slg_diff</code>: The difference in slugging percentage
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mlb_diffs
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_ts</code> (inherits from <code>tbl_df</code>, <code>tbl</code>, <code>data.frame</code>) with 99 rows and 6 columns.
</p>


<h3>Source</h3>

<p>The <code>Lahman</code> package
</p>

<hr>
<h2 id='model_args'>Retrieve the arguments that a model-fitting function used</h2><span id='topic+model_args'></span><span id='topic+model_args.default'></span><span id='topic+model_args.seg_cpt'></span><span id='topic+model_args.ga'></span><span id='topic+model_args.cpt'></span><span id='topic+model_args.wbs'></span>

<h3>Description</h3>

<p>Retrieve the arguments that a model-fitting function used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_args(object, ...)

## Default S3 method:
model_args(object, ...)

## S3 method for class 'seg_cpt'
model_args(object, ...)

## S3 method for class 'ga'
model_args(object, ...)

## S3 method for class 'cpt'
model_args(object, ...)

## S3 method for class 'wbs'
model_args(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_args_+3A_object">object</code></td>
<td>
<p>A <code>segmenter</code> object.</p>
</td></tr>
<tr><td><code id="model_args_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every model is fit by a model-fitting function, and these functions sometimes
take arguments.
<code><a href="#topic+model_args">model_args()</a></code> recovers the arguments that were passed to
the model fitting function when it was called.
These are especially
important when using a genetic algorithm.
</p>


<h3>Value</h3>

<p>A named <code>list</code> of arguments, or <code>NULL</code>
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>
<p>Other segmenter-functions: 
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+seg_params">seg_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using Coen's algorithm
x &lt;- segment(CET, method = "ga-coen", maxiter = 3)

# Recover the arguments passed to the model-fitting function
x |&gt;
  as.segmenter() |&gt;
  model_args()
  
</code></pre>

<hr>
<h2 id='model_name'>Retrieve the name of the model that a segmenter or model used</h2><span id='topic+model_name'></span><span id='topic+model_name.default'></span><span id='topic+model_name.character'></span><span id='topic+model_name.mod_cpt'></span><span id='topic+model_name.seg_basket'></span><span id='topic+model_name.seg_cpt'></span><span id='topic+model_name.tidycpt'></span><span id='topic+model_name.ga'></span><span id='topic+model_name.cpt'></span><span id='topic+model_name.wbs'></span>

<h3>Description</h3>

<p>Retrieve the name of the model that a segmenter or model used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_name(object, ...)

## Default S3 method:
model_name(object, ...)

## S3 method for class 'character'
model_name(object, ...)

## S3 method for class 'mod_cpt'
model_name(object, ...)

## S3 method for class 'seg_basket'
model_name(object, ...)

## S3 method for class 'seg_cpt'
model_name(object, ...)

## S3 method for class 'tidycpt'
model_name(object, ...)

## S3 method for class 'ga'
model_name(object, ...)

## S3 method for class 'cpt'
model_name(object, ...)

## S3 method for class 'wbs'
model_name(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_name_+3A_object">object</code></td>
<td>
<p>A <code>segmenter</code> object.</p>
</td></tr>
<tr><td><code id="model_name_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every segmenter works by fitting a model to the data. <code><a href="#topic+model_name">model_name()</a></code> returns
the name of a model that can be passed to <code><a href="#topic+whomademe">whomademe()</a></code> to retrieve the
model fitting function. These functions must begin with the prefix <code>fit_</code>.
Note that the model fitting functions exist in <code>tidychangepoint</code> are are
not necessarily the actual functions used by the segmenter.
</p>
<p>Models also implement <code>model_name()</code>.
</p>


<h3>Value</h3>

<p>A <code>character</code> vector of length 1.
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>
<p>Other tidycpt-generics: 
<code><a href="#topic+as.model">as.model</a>()</code>,
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+changepoints">changepoints</a>()</code>,
<code><a href="#topic+diagnose">diagnose</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
x &lt;- segment(CET, method = "pelt")

# Retrieve the name of the model from the segmenter
x |&gt;
  as.segmenter() |&gt;
  model_name()

# What function created the model? 
x |&gt;
  model_name() |&gt;
  whomademe()
model_name(x$segmenter)

# Retrieve the name of the model from the model
x |&gt;
  as.model() |&gt;
  model_name()
  
</code></pre>

<hr>
<h2 id='model_variance'>Compute model variance</h2><span id='topic+model_variance'></span>

<h3>Description</h3>

<p>Compute model variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_variance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_variance_+3A_object">object</code></td>
<td>
<p>A model object implementing <code><a href="#topic+residuals">residuals()</a></code> and <code><a href="#topic+nobs">nobs()</a></code></p>
</td></tr>
<tr><td><code id="model_variance_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the generic functions <code><a href="#topic+residuals">residuals()</a></code> and <code><a href="#topic+nobs">nobs()</a></code>, this function
computes the variance of the residuals.
</p>
<p>Note that unlike <code><a href="stats.html#topic+cor">stats::var()</a></code>, it does not use <code class="reqn">n-1</code> as the denominator.
</p>


<h3>Value</h3>

<p>A <code>double</code> vector of length 1
</p>

<hr>
<h2 id='new_fun_cpt'>Class for model-fitting functions</h2><span id='topic+new_fun_cpt'></span><span id='topic+validate_fun_cpt'></span><span id='topic+fun_cpt'></span>

<h3>Description</h3>

<p>Class for model-fitting functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_fun_cpt(x, ...)

validate_fun_cpt(x)

fun_cpt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_fun_cpt_+3A_x">x</code></td>
<td>
<p>a <code>character</code> giving the name of a model-fitting function</p>
</td></tr>
<tr><td><code id="new_fun_cpt_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All model-fitting functions must be registered through a call to <code><a href="#topic+fun_cpt">fun_cpt()</a></code>.
</p>
<p>All model-fitting functions must take at least three arguments:
</p>

<ul>
<li> <p><code>x</code>: a time series,
</p>
</li>
<li> <p><code>tau</code>: a set of changepoint indices
</p>
</li>
<li> <p><code>...</code>: other arguments passed to methods
</p>
</li></ul>

<p>See <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code>,
</p>


<h3>Value</h3>

<p>A <a href="#topic+fun_cpt">fun_cpt</a> object.
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+whomademe">whomademe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Register a model-fitting function
f &lt;- fun_cpt("fit_meanvar")

# Verify that it now has class `fun_cpt`
str(f)

# Use it
f(CET, 42)
</code></pre>

<hr>
<h2 id='new_mod_cpt'>Base class for changepoint models</h2><span id='topic+new_mod_cpt'></span><span id='topic+validate_mod_cpt'></span><span id='topic+mod_cpt'></span>

<h3>Description</h3>

<p>Create changepoint detection model objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_mod_cpt(
  x = numeric(),
  tau = integer(),
  region_params = tibble::tibble(),
  model_params = double(),
  fitted_values = double(),
  model_name = character(),
  ...
)

validate_mod_cpt(x)

mod_cpt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_mod_cpt_+3A_x">x</code></td>
<td>
<p>a numeric vector coercible into a <code>ts</code> object</p>
</td></tr>
<tr><td><code id="new_mod_cpt_+3A_tau">tau</code></td>
<td>
<p>indices of the changepoint set</p>
</td></tr>
<tr><td><code id="new_mod_cpt_+3A_region_params">region_params</code></td>
<td>
<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each region
defined by the changepoint set <code>tau</code>. Each variable represents a parameter
estimated in that region.</p>
</td></tr>
<tr><td><code id="new_mod_cpt_+3A_model_params">model_params</code></td>
<td>
<p>A numeric vector of parameters estimated by the model
across the entire data set (not just in each region).</p>
</td></tr>
<tr><td><code id="new_mod_cpt_+3A_fitted_values">fitted_values</code></td>
<td>
<p>Fitted values returned by the model on the original
data set.</p>
</td></tr>
<tr><td><code id="new_mod_cpt_+3A_model_name">model_name</code></td>
<td>
<p>A <code>character</code> vector giving the model's name.</p>
</td></tr>
<tr><td><code id="new_mod_cpt_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Changepoint detection models know how they were created, on what data set,
about the optimal changepoint set found, and the parameters that were fit
to the model.
Methods for various generic reporting functions are provided.
</p>
<p>All changepoint detection models inherit from <a href="#topic+mod_cpt">mod_cpt</a>: the
base class for changepoint detection models.
These models are created by one of the <code style="white-space: pre;">&#8288;fit_*()&#8288;</code> functions, or by
<code><a href="#topic+as.model">as.model()</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="#topic+mod_cpt">mod_cpt</a> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.model">as.model()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cpt &lt;- mod_cpt(CET)
str(cpt)
as.ts(cpt)
changepoints(cpt)
</code></pre>

<hr>
<h2 id='new_seg_basket'>Default class for candidate changepoint sets</h2><span id='topic+new_seg_basket'></span><span id='topic+seg_basket'></span>

<h3>Description</h3>

<p>Default class for candidate changepoint sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_seg_basket(
  x = numeric(),
  algorithm = NA,
  cpt_list = list(),
  seg_params = list(),
  model_name = "meanshift_norm",
  penalty = "BIC",
  ...
)

seg_basket(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_seg_basket_+3A_x">x</code></td>
<td>
<p>a numeric vector coercible into a <code><a href="stats.html#topic+ts">stats::ts()</a></code> object</p>
</td></tr>
<tr><td><code id="new_seg_basket_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm used to find the changepoints</p>
</td></tr>
<tr><td><code id="new_seg_basket_+3A_cpt_list">cpt_list</code></td>
<td>
<p>a possibly empty <code><a href="base.html#topic+list">list()</a></code> of candidate changepoints</p>
</td></tr>
<tr><td><code id="new_seg_basket_+3A_seg_params">seg_params</code></td>
<td>
<p>a possibly empty <code><a href="base.html#topic+list">list()</a></code> of segmenter parameters</p>
</td></tr>
<tr><td><code id="new_seg_basket_+3A_model_name">model_name</code></td>
<td>
<p>character indicating the model used to find the changepoints.</p>
</td></tr>
<tr><td><code id="new_seg_basket_+3A_penalty">penalty</code></td>
<td>
<p>character indicating the name of the penalty function used to
find the changepoints.</p>
</td></tr>
<tr><td><code id="new_seg_basket_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+seg_basket">seg_basket()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seg &lt;- seg_basket(DataCPSim, cpt_list = list(c(365), c(330, 839)))
str(seg)
as.ts(seg)
changepoints(seg)
fitness(seg)
</code></pre>

<hr>
<h2 id='new_seg_cpt'>Base class for segmenters</h2><span id='topic+new_seg_cpt'></span><span id='topic+seg_cpt'></span>

<h3>Description</h3>

<p>Base class for segmenters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_seg_cpt(
  x = numeric(),
  pkg = character(),
  algorithm = NA,
  changepoints = integer(),
  fitness = double(),
  seg_params = list(),
  model_name = "meanshift_norm",
  penalty = "BIC",
  ...
)

seg_cpt(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_seg_cpt_+3A_x">x</code></td>
<td>
<p>a numeric vector coercible into a <code><a href="stats.html#topic+ts">stats::ts()</a></code> object</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_pkg">pkg</code></td>
<td>
<p>name of the package providing the segmenter</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_algorithm">algorithm</code></td>
<td>
<p>Algorithm used to find the changepoints</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_changepoints">changepoints</code></td>
<td>
<p>a possibly empty <code><a href="base.html#topic+list">list()</a></code> of candidate changepoints</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_fitness">fitness</code></td>
<td>
<p>A named <code>double</code> vector whose name reflects the penalty applied</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_seg_params">seg_params</code></td>
<td>
<p>a possibly empty <code><a href="base.html#topic+list">list()</a></code> of segmenter parameters</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_model_name">model_name</code></td>
<td>
<p>character indicating the model used to find the changepoints.</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_penalty">penalty</code></td>
<td>
<p>character indicating the name of the penalty function used to
find the changepoints.</p>
</td></tr>
<tr><td><code id="new_seg_cpt_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="#topic+seg_cpt">seg_cpt</a> object.
</p>

<hr>
<h2 id='pad_tau'>Pad and unpad changepoint sets with boundary points</h2><span id='topic+pad_tau'></span><span id='topic+unpad_tau'></span><span id='topic+is_valid_tau'></span><span id='topic+regions_tau'></span><span id='topic+validate_tau'></span>

<h3>Description</h3>

<p>Pad and unpad changepoint sets with boundary points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_tau(tau, n)

unpad_tau(padded_tau)

is_valid_tau(tau, n)

regions_tau(tau, n)

validate_tau(tau, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pad_tau_+3A_tau">tau</code></td>
<td>
<p>a numeric vector of changepoint indices</p>
</td></tr>
<tr><td><code id="pad_tau_+3A_n">n</code></td>
<td>
<p>the length of the original time series</p>
</td></tr>
<tr><td><code id="pad_tau_+3A_padded_tau">padded_tau</code></td>
<td>
<p>Output from <code><a href="#topic+pad_tau">pad_tau()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a time series contains <code class="reqn">n</code> observations, we label them from 1
to <code class="reqn">n</code>.
Neither the 1st point nor the <code class="reqn">n</code>th point can be a changepoint, since the
regions they create on one side would be empty.
However, for dividing the time series into non-empty segments, we start with
1, add <code class="reqn">n+1</code>, and then divide the half-open interval <code class="reqn">[1, n+1)</code> into
half-open subintervals that define the regions.
</p>
<p><code><a href="#topic+pad_tau">pad_tau()</a></code> ensures that 1 and <code class="reqn">n+1</code> are included.
</p>
<p><code><a href="#topic+unpad_tau">unpad_tau()</a></code> removes 1 and <code class="reqn">n+1</code>, should they exist.
</p>
<p><code><a href="#topic+is_valid_tau">is_valid_tau()</a></code> checks to see if the supplied set of changepoints is valid
</p>
<p><code><a href="#topic+validate_tau">validate_tau()</a></code> removes duplicates and boundary values.
</p>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+pad_tau">pad_tau()</a></code>: an <code>integer</code> vector that starts with 0 and ends in <code class="reqn">n</code>.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+unpad_tau">unpad_tau()</a></code>: an <code>integer</code> vector stripped of its first and last entries.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+is_valid_tau">is_valid_tau()</a></code>: a <code>logical</code> if all of the entries are between 2 and
<code class="reqn">n-1</code>.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+regions_tau">regions_tau()</a></code>: A <code><a href="base.html#topic+factor">base::factor()</a></code>
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+validate_tau">validate_tau()</a></code>: an <code>integer</code> vector with only the <code><a href="base.html#topic+unique">base::unique()</a></code>
entries between 2 and <code class="reqn">n-1</code>, inclusive.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Anything less than 2 is not allowed
is_valid_tau(0, length(DataCPSim))
is_valid_tau(1, length(DataCPSim))

# Duplicates are allowed
is_valid_tau(c(42, 42), length(DataCPSim))
is_valid_tau(826, length(DataCPSim))

# Anything greater than \eqn{n} (in this case 1096) is not allowed
is_valid_tau(1096, length(DataCPSim))
is_valid_tau(1097, length(DataCPSim))

# Always return a factor with half-open intervals on the right
regions_tau(c(42, 330), 1096)
# Anything less than 2 is not allowed
validate_tau(0, length(DataCPSim))
validate_tau(1, length(DataCPSim))
validate_tau(826, length(DataCPSim))

# Duplicates are removed
validate_tau(c(826, 826), length(DataCPSim))

# Anything greater than \eqn{n} (in this case 1096) is not allowed
validate_tau(1096, length(DataCPSim))
validate_tau(1097, length(DataCPSim))

# Fix many problems
validate_tau(c(-4, 0, 1, 4, 5, 5, 824, 1096, 1097, 182384), length(DataCPSim))

</code></pre>

<hr>
<h2 id='plot_best_chromosome'>Diagnostic plots for <code>seg_basket</code> objects</h2><span id='topic+plot_best_chromosome'></span><span id='topic+plot_cpt_repeated'></span>

<h3>Description</h3>

<p>Diagnostic plots for <code>seg_basket</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_best_chromosome(x)

plot_cpt_repeated(x, i = nrow(x$basket))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_best_chromosome_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+seg_basket">seg_basket()</a></code> object</p>
</td></tr>
<tr><td><code id="plot_best_chromosome_+3A_i">i</code></td>
<td>
<p>index of basket to show</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+seg_basket">seg_basket()</a></code> objects contain baskets of candidate changepoint sets.
</p>
<p><code><a href="#topic+plot_best_chromosome">plot_best_chromosome()</a></code> shows how the size of the candidate changepoint
sets change across the generations of evolution.
</p>
<p><code><a href="#topic+plot_cpt_repeated">plot_cpt_repeated()</a></code> shows how frequently individual observations appear in
the best candidate changepoint sets in each generation.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Segment a time series using Coen's algorithm
x &lt;- segment(DataCPSim, method = "coen", num_generations = 3)

# Plot the size of the sets during the evolution
x |&gt;
  as.segmenter() |&gt;
  plot_best_chromosome()


# Segment a time series using Coen's algorithm
x &lt;- segment(DataCPSim, method = "coen", num_generations = 3)

# Plot overall frequency of appearance of changepoints
plot_cpt_repeated(x$segmenter)

# Plot frequency of appearance only up to a specific generation
plot_cpt_repeated(x$segmenter, 5)

</code></pre>

<hr>
<h2 id='plot_intensity'>Plot the intensity of an NHPP fit</h2><span id='topic+plot_intensity'></span>

<h3>Description</h3>

<p>Plot the intensity of an NHPP fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_intensity(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_intensity_+3A_x">x</code></td>
<td>
<p>An NHPP <code>model</code> returned by <code><a href="#topic+fit_nhpp">fit_nhpp()</a></code></p>
</td></tr>
<tr><td><code id="plot_intensity_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the estimated intensity function
plot_intensity(fit_nhpp(DataCPSim, tau = 826))

# Segment a time series using PELT
mod &lt;- segment(bogota_pm, method = "pelt")

# Plot the estimated intensity function for the NHPP model using the 
# changepoints found by PELT
plot_intensity(fit_nhpp(bogota_pm, tau = changepoints(mod)))

</code></pre>

<hr>
<h2 id='plot.tidyga'>Plot GA information</h2><span id='topic+plot.tidyga'></span>

<h3>Description</h3>

<p>Plot GA information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tidyga'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tidyga_+3A_x">x</code></td>
<td>
<p>A <code>tidyga</code> object</p>
</td></tr>
<tr><td><code id="plot.tidyga_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- segment(DataCPSim, method = "ga-coen", maxiter = 5)
plot(x$segmenter)

</code></pre>

<hr>
<h2 id='regions'>Extract the regions from a <a href="#topic+tidycpt-class">tidycpt</a> object</h2><span id='topic+regions'></span><span id='topic+regions.mod_cpt'></span><span id='topic+regions.tidycpt'></span>

<h3>Description</h3>

<p>Extract the regions from a <a href="#topic+tidycpt-class">tidycpt</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regions(x, ...)

## S3 method for class 'mod_cpt'
regions(x, ...)

## S3 method for class 'tidycpt'
regions(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regions_+3A_x">x</code></td>
<td>
<p>An object that has regions</p>
</td></tr>
<tr><td><code id="regions_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+factor">base::factor()</a></code> of intervals indicating the region
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cpt &lt;- fit_meanshift_norm(CET, tau = 330)
regions(cpt)

</code></pre>

<hr>
<h2 id='seg_params'>Retrieve parameters from a segmenter</h2><span id='topic+seg_params'></span><span id='topic+seg_params.seg_cpt'></span><span id='topic+seg_params.ga'></span><span id='topic+seg_params.cpt'></span><span id='topic+seg_params.wbs'></span>

<h3>Description</h3>

<p>Retrieve parameters from a segmenter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seg_params(object, ...)

## S3 method for class 'seg_cpt'
seg_params(object, ...)

## S3 method for class 'ga'
seg_params(object, ...)

## S3 method for class 'cpt'
seg_params(object, ...)

## S3 method for class 'wbs'
seg_params(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seg_params_+3A_object">object</code></td>
<td>
<p>A <code>segmenter</code> object.</p>
</td></tr>
<tr><td><code id="seg_params_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most segmenting algorithms have parameters.
This function retrieves an informative set of those parameter values.
</p>


<h3>Value</h3>

<p>A named <code>list</code> of parameters with their values.
</p>


<h3>See Also</h3>

<p>Other segmenter-functions: 
<code><a href="#topic+as.segmenter">as.segmenter</a>()</code>,
<code><a href="#topic+fitness">fitness</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
x &lt;- segment(CET, method = "pelt")
x |&gt;
  as.segmenter() |&gt;
  seg_params()

</code></pre>

<hr>
<h2 id='segment'>Segment a time series using a variety of algorithms</h2><span id='topic+segment'></span><span id='topic+segment.tbl_ts'></span><span id='topic+segment.xts'></span><span id='topic+segment.numeric'></span><span id='topic+segment.ts'></span>

<h3>Description</h3>

<p>A wrapper function that encapsulates various algorithms for detecting changepoint
sets in univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment(x, method = "null", ...)

## S3 method for class 'tbl_ts'
segment(x, method = "null", ...)

## S3 method for class 'xts'
segment(x, method = "null", ...)

## S3 method for class 'numeric'
segment(x, method = "null", ...)

## S3 method for class 'ts'
segment(x, method = "null", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_+3A_x">x</code></td>
<td>
<p>a numeric vector coercible into a <a href="stats.html#topic+ts">stats::ts</a> object</p>
</td></tr>
<tr><td><code id="segment_+3A_method">method</code></td>
<td>
<p>a character string indicating the algorithm to use. See Details.</p>
</td></tr>
<tr><td><code id="segment_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code><a href="#topic+segment">segment()</a></code> can use the following algorithms, depending
on the value of the <code>method</code> argument:
</p>

<ul>
<li> <p><code>pelt</code>: Uses the PELT algorithm as implemented in
<code><a href="#topic+segment_pelt">segment_pelt()</a></code>, which wraps either <code><a href="changepoint.html#topic+cpt.mean">changepoint::cpt.mean()</a></code> or
<code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code>. The <code>segmenter</code> is of class <code>cpt</code>.
</p>
</li>
<li> <p><code>binseg</code>: Uses the Binary Segmentation algorithm as implemented by
<code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code>. The <code>segmenter</code> is of class <code>cpt</code>.
</p>
</li>
<li> <p><code>segneigh</code>: Uses the Segmented Neighborhood algorithm as implemented by
<code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code>. The <code>segmenter</code> is of class <code>cpt</code>.
</p>
</li>
<li> <p><code>single-best</code>: Uses the AMOC criteria as implemented by
<code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code>. The <code>segmenter</code> is of class <code>cpt</code>.
</p>
</li>
<li> <p><code>wbs</code>: Uses the Wild Binary Segmentation algorithm as implemented by
<code><a href="wbs.html#topic+wbs">wbs::wbs()</a></code>. The <code>segmenter</code> is of class <code>wbs</code>.
</p>
</li>
<li> <p><code>ga</code>: Uses the Genetic algorithm implemented by <code><a href="#topic+segment_ga">segment_ga()</a></code>, which wraps
<code><a href="GA.html#topic+ga">GA::ga()</a></code>. The <code>segmenter</code> is of class <code>tidyga</code>.
</p>
</li>
<li> <p><code>ga-shi</code>: Uses the genetic algorithm implemented by <code><a href="#topic+segment_ga_shi">segment_ga_shi()</a></code>,
which wraps
<code><a href="#topic+segment_ga">segment_ga()</a></code>. The <code>segmenter</code> is of class <code>tidyga</code>.
</p>
</li>
<li> <p><code>ga-coen</code>: Uses Coen's heuristic as implemented by <code><a href="#topic+segment_ga_coen">segment_ga_coen()</a></code>.
The <code>segmenter</code> is of class <code>tidyga</code>. This implementation supersedes the
following one.
</p>
</li>
<li> <p><code>coen</code>: Uses Coen's heuristic as implemented by
<code><a href="#topic+segment_coen">segment_coen()</a></code>. The <code>segmenter</code> is of class <code><a href="#topic+seg_basket">seg_basket()</a></code>. Note that
this function is deprecated.
</p>
</li>
<li> <p><code>random</code>: Uses a random basket of changepoints as implemented by
<code><a href="#topic+segment_ga_random">segment_ga_random()</a></code>.
The <code>segmenter</code> is of class <code>tidyga</code>.
</p>
</li>
<li> <p><code>manual</code>: Uses the vector of changepoints in the <code>tau</code> argument.
The <code>segmenter</code> is of class <a href="#topic+seg_cpt">seg_cpt</a>'.
</p>
</li>
<li> <p><code>null</code>: The default. Uses no changepoints.
The <code>segmenter</code> is of class <a href="#topic+seg_cpt">seg_cpt</a>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+tidycpt-class">tidycpt</a>.
</p>


<h3>See Also</h3>

<p><code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code>, <code><a href="wbs.html#topic+wbs">wbs::wbs()</a></code>, <code><a href="GA.html#topic+ga">GA::ga()</a></code>,
<code><a href="#topic+segment_ga">segment_ga()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
segment(DataCPSim, method = "pelt")

# Segment a time series using PELT and the BIC penalty
segment(DataCPSim, method = "pelt", penalty = "BIC")

# Segment a time series using Binary Segmentation
segment(DataCPSim, method = "binseg", penalty = "BIC")

# Segment a time series using a random changepoint set
segment(DataCPSim, method = "random")

# Segment a time series using a manually-specified changepoint set
segment(DataCPSim, method = "manual", tau = c(826))

# Segment a time series using a null changepoint set
segment(DataCPSim)

</code></pre>

<hr>
<h2 id='segment_coen'>Algoritmo genético de Bayesian MDL a un paso</h2><span id='topic+segment_coen'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This implementation is deprecated. Please see <code><a href="#topic+segment_ga_coen">segment_ga_coen()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_coen(
  x,
  num_generations = 50,
  nhpp_dist = c("W", "EW", "GGO", "MO", "GO")[1],
  vec_dist_a_priori = c("Gamma", "Gamma"),
  mat_phi = matrix(c(1, 3, 2, 1.2), ncol = 2),
  generation_size = 50,
  max_num_cp = 20,
  show_progress_bar = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_coen_+3A_x">x</code></td>
<td>
<p>an object coercible into a time series object via <code><a href="stats.html#topic+ts">stats::as.ts()</a></code></p>
</td></tr>
<tr><td><code id="segment_coen_+3A_num_generations">num_generations</code></td>
<td>
<p>Number of generations to evolve</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_nhpp_dist">nhpp_dist</code></td>
<td>
<p>toma valores en c(&quot;W&quot;,&quot;EW&quot;,&quot;GGO&quot;,&quot;MO&quot;,&quot;GO&quot;) y es el nombre de
la función de tasa del NHPP</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_vec_dist_a_priori">vec_dist_a_priori</code></td>
<td>
<p>vector de los nobmres de las distribuciones a priori
que se utilizan; eg c(&quot;Gamma&quot;,&quot;Gamma&quot;) y c(&quot;Gamma&quot;,&quot;Gamma&quot;,&quot;Gamma&quot;)</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_mat_phi">mat_phi</code></td>
<td>
<p>matriz cuyos renglones tiene los parámetros de las
distribuciones a priori; cada renglón tiene todos los parametros de una
distribución</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_generation_size">generation_size</code></td>
<td>
<p>tamaño de las generaciones</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_max_num_cp">max_num_cp</code></td>
<td>
<p>el máximo número de rebases. Este parámetro se ocupa en
particular para que todos los cromosomas quepan en una matriz.</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_show_progress_bar">show_progress_bar</code></td>
<td>
<p>show the progress bar?</p>
</td></tr>
<tr><td><code id="segment_coen_+3A_...">...</code></td>
<td>
<p>arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>cpt_gbmdl</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- segment_coen(DataCPSim, num_generations = 5)


</code></pre>

<hr>
<h2 id='segment_ga'>Segment a time series using a genetic algorithm</h2><span id='topic+segment_ga'></span><span id='topic+segment_ga_shi'></span><span id='topic+segment_ga_coen'></span><span id='topic+segment_ga_random'></span>

<h3>Description</h3>

<p>Segmenting functions for various genetic algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_ga(
  x,
  model_fn = fit_meanshift_norm,
  penalty_fn = BIC,
  model_fn_args = list(),
  ...
)

segment_ga_shi(x, ...)

segment_ga_coen(x, ...)

segment_ga_random(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_ga_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="segment_ga_+3A_model_fn">model_fn</code></td>
<td>
<p>A <code>character</code> or <code>name</code> coercible into a <a href="#topic+fun_cpt">fun_cpt</a> function.
See, for example, <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code>.</p>
</td></tr>
<tr><td><code id="segment_ga_+3A_penalty_fn">penalty_fn</code></td>
<td>
<p>A function that evaluates the changepoint set returned by
<code>model_fn</code>. We provide <code><a href="#topic+AIC">AIC()</a></code>, <code><a href="#topic+BIC">BIC()</a></code>, <code><a href="#topic+MBIC">MBIC()</a></code>, <code><a href="#topic+MDL">MDL()</a></code>, and <code><a href="#topic+BMDL">BMDL()</a></code>.</p>
</td></tr>
<tr><td><code id="segment_ga_+3A_model_fn_args">model_fn_args</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list()</a></code> of parameters passed to <code>model_fn</code></p>
</td></tr>
<tr><td><code id="segment_ga_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="GA.html#topic+ga">GA::ga()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+segment_ga">segment_ga()</a></code> uses the genetic algorithm in <code><a href="GA.html#topic+ga">GA::ga()</a></code> to &quot;evolve&quot; a random
set of candidate changepoint sets, using the penalized objective function
specified by <code>penalty_fn</code>.
By default, the normal <code>meanshift</code> model is fit (see <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code>)
and the <a href="#topic+BIC">BIC</a> penalty is applied.
</p>

<ul>
<li> <p><code><a href="#topic+segment_ga_shi">segment_ga_shi()</a></code>: Shi's algorithm is the algorithm used in
<a href="https://doi.org/10.1175/JCLI-D-21-0489.1">doi:10.1175/JCLI-D-21-0489.1</a>.
Note that in order to achieve the reported results you have to run the algorithm
for a really long time.
Pass the values <code>maxiter</code> = 50000 and <code>run</code> = 10000
to <code><a href="GA.html#topic+ga">GA::ga()</a></code> using the dots.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+segment_ga_coen">segment_ga_coen()</a></code>: Coen's algorithm is the one used in
<a href="https://doi.org/10.1007/978-3-031-47372-2_20">doi:10.1007/978-3-031-47372-2_20</a>.
Note that the speed of the algorithm is highly sensitive to the size of the
changepoint sets under consideration, with large changepoint sets being slow.
Consider setting the <code>population</code> argument to <code><a href="GA.html#topic+ga">GA::ga()</a></code> to improve
performance. Coen's algorithm uses the <code><a href="#topic+build_gabin_population">build_gabin_population()</a></code> function
for this purpose by default.
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+segment_ga_random">segment_ga_random()</a></code>: Randomly select candidate changepoint sets. This
is implemented as a genetic algorithm with only one generation (i.e.,
<code>maxiter = 1</code>). Note
that this function uses <code><a href="#topic+log_gabin_population">log_gabin_population()</a></code> by default.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tidyga</code> object. This is just a <code><a href="GA.html#topic+ga">GA::ga()</a></code> object with an additional
slot for <code>data</code> (the original time series) and <code>model_fn_args</code> (captures
the <code>model_fn</code> and <code>penalty_fn</code> arguments).
</p>


<h3>References</h3>

<p>Shi, et al. (2022, <a href="https://doi.org/10.1175/JCLI-D-21-0489.1">doi:10.1175/JCLI-D-21-0489.1</a>)
</p>
<p>Taimal, et al. (2023, <a href="https://doi.org/10.1007/978-3-031-47372-2_20">doi:10.1007/978-3-031-47372-2_20</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_gabin_population">build_gabin_population()</a></code>
</p>
<p><code><a href="#topic+log_gabin_population">log_gabin_population()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using a genetic algorithm
res &lt;- segment_ga(CET, maxiter = 5)
summary(res)
str(res)
plot(res)


# Segment a time series using Shi's algorithm
x &lt;- segment(CET, method = "ga-shi", maxiter = 5)
str(x)

# Segment a time series using Coen's algorithm
y &lt;- segment(CET, method = "ga-coen", maxiter = 5)
changepoints(y)

# Segment a time series using Coen's algorithm and an arbitrary threshold
z &lt;- segment(CET, method = "ga-coen", maxiter = 5, 
             model_fn_args = list(threshold = 2))
changepoints(z)

## Not run: 
# This will take a really long time!
x &lt;- segment(CET, method = "ga-shi", maxiter = 500, run = 100)
changepoints(x)

# This will also take a really long time!
y &lt;- segment(CET, method = "ga", model_fn = fit_lmshift, penalty_fn = BIC, 
  popSize = 200, maxiter = 5000, run = 1000, 
  model_fn_args = list(trends = TRUE), 
  population = build_gabin_population(CET)
)

## End(Not run)

## Not run: 
x &lt;- segment(method = "ga-coen", maxiter = 50)

## End(Not run)

x &lt;- segment(CET, method = "random")
</code></pre>

<hr>
<h2 id='segment_manual'>Manually segment a time series</h2><span id='topic+segment_manual'></span>

<h3>Description</h3>

<p>Segment a time series by manually inputting the changepoint set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_manual(x, tau, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_manual_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="segment_manual_+3A_tau">tau</code></td>
<td>
<p>a set of indices representing a changepoint set</p>
</td></tr>
<tr><td><code id="segment_manual_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="#topic+seg_cpt">seg_cpt</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes you want to see how a manually input set of changepoints performs.
This function takes a time series and a changepoint detection set as inputs
and returns a <a href="#topic+seg_cpt">seg_cpt</a> object representing the segmenter.
Note that by default <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code> is used to fit the model and
<code><a href="#topic+BIC">BIC()</a></code> is used as the penalized objective function.
</p>


<h3>Value</h3>

<p>A <a href="#topic+seg_cpt">seg_cpt</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series manually
segment_manual(CET, tau = c(84, 330))
segment_manual(CET, tau = NULL)

</code></pre>

<hr>
<h2 id='segment_pelt'>Segment a time series using the PELT algorithm</h2><span id='topic+segment_pelt'></span>

<h3>Description</h3>

<p>Segmenting functions for the PELT algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_pelt(x, model_fn = fit_meanvar, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_pelt_+3A_x">x</code></td>
<td>
<p>A time series</p>
</td></tr>
<tr><td><code id="segment_pelt_+3A_model_fn">model_fn</code></td>
<td>
<p>A <code>character</code> or <code>name</code> coercible into a <a href="#topic+fun_cpt">fun_cpt</a> function.
See, for example, <code><a href="#topic+fit_meanshift_norm">fit_meanshift_norm()</a></code>. The default is <code><a href="#topic+fit_meanvar">fit_meanvar()</a></code>.</p>
</td></tr>
<tr><td><code id="segment_pelt_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code> or
<code><a href="changepoint.html#topic+cpt.mean">changepoint::cpt.mean()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function wraps either <code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code> or
<code><a href="changepoint.html#topic+cpt.mean">changepoint::cpt.mean()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>cpt</code> object returned by <code><a href="changepoint.html#topic+cpt.meanvar">changepoint::cpt.meanvar()</a></code> or
<code><a href="changepoint.html#topic+cpt.mean">changepoint::cpt.mean()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
res &lt;- segment_pelt(DataCPSim)
res
str(res)

# Segment as time series while specifying a penalty function
segment_pelt(DataCPSim, penalty = "BIC")

# Segment a time series while specifying a meanshift normal model
segment_pelt(DataCPSim, model_fn = fit_meanshift_norm, penalty = "BIC")

</code></pre>

<hr>
<h2 id='SIC'>Schwarz information criterion</h2><span id='topic+SIC'></span>

<h3>Description</h3>

<p>Schwarz information criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SIC_+3A_object">object</code></td>
<td>
<p>a fitted model object for which there exists a
<code>logLik</code> method to extract the corresponding log-likelihood, or
an object inheriting from class <code>logLik</code>.</p>
</td></tr>
<tr><td><code id="SIC_+3A_...">...</code></td>
<td>
<p>optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code><a href="stats.html#topic+AIC">stats::BIC()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">stats::BIC()</a></code>, <code><a href="stats.html#topic+AIC">stats::AIC()</a></code>
</p>
<p>Other penalty-functions: 
<code><a href="#topic+BMDL">BMDL</a>()</code>,
<code><a href="#topic+HQC">HQC</a>()</code>,
<code><a href="#topic+MBIC">MBIC</a>()</code>,
<code><a href="#topic+MDL">MDL</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The SIC is just the BIC
SIC(fit_meanvar(CET, tau = NULL))
BIC(fit_meanvar(CET, tau = NULL))

</code></pre>

<hr>
<h2 id='tau2time'>Convert changepoint sets to time indices</h2><span id='topic+tau2time'></span><span id='topic+time2tau'></span>

<h3>Description</h3>

<p>Convert changepoint sets to time indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau2time(tau, index)

time2tau(cpts, index)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tau2time_+3A_tau">tau</code></td>
<td>
<p>a numeric vector of changepoint indices</p>
</td></tr>
<tr><td><code id="tau2time_+3A_index">index</code></td>
<td>
<p>Index of times, typically returned by <code><a href="stats.html#topic+time">stats::time()</a></code></p>
</td></tr>
<tr><td><code id="tau2time_+3A_cpts">cpts</code></td>
<td>
<p>Time series observation labels to be converted to indices</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+tau2time">tau2time()</a></code>: a <code>character</code> of time labels
</p>
</li></ul>


<ul>
<li> <p><code><a href="#topic+time2tau">time2tau()</a></code>: an <code>integer</code> vector of changepoint indices
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+time">stats::time()</a></code>, <code><a href="#topic+as_year">as_year()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Recover the years from a set of changepoint indices
tau2time(c(42, 81, 330), index = as_year(time(CET)))

# Recover the changepoint set indices from the years
time2tau(c(1700, 1739, 1988), index = as_year(time(CET)))

</code></pre>

<hr>
<h2 id='tbl_coef'>Format the coefficients from a linear model as a tibble</h2><span id='topic+tbl_coef'></span>

<h3>Description</h3>

<p>Format the coefficients from a linear model as a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_coef(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tbl_coef_+3A_mod">mod</code></td>
<td>
<p>An <code>lm</code> model object</p>
</td></tr>
<tr><td><code id="tbl_coef_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tbl_df-class">tibble::tbl_df</a> object containing the fitted coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert a time series into a data frame with indices
ds &lt;- data.frame(y = as.ts(CET), t = 1:length(CET))

# Retrieve the coefficients from a null model
tbl_coef(lm(y ~ 1, data = ds))

# Retrieve the coefficients from a two changepoint model
tbl_coef(lm(y ~ (t &gt;= 42) + (t &gt;= 81), data = ds))

# Retrieve the coefficients from a trendshift model
tbl_coef(lm(y ~ poly(t, 1, raw = TRUE) * (t &gt;= 42) + poly(t, 1, raw = TRUE) * (t &gt;= 81), data = ds))

# Retrieve the coefficients from a quadratic model
tbl_coef(lm(y ~ poly(t, 2, raw = TRUE) * (t &gt;= 42) + poly(t, 2, raw = TRUE) * (t &gt;= 81), data = ds))
</code></pre>

<hr>
<h2 id='test_set'>Simulate time series with known changepoint sets</h2><span id='topic+test_set'></span>

<h3>Description</h3>

<p>Simulate time series with known changepoint sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_set(n = 1, sd = 1, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_set_+3A_n">n</code></td>
<td>
<p>Number of true changepoints in set</p>
</td></tr>
<tr><td><code id="test_set_+3A_sd">sd</code></td>
<td>
<p>Standard deviation passed to <code><a href="stats.html#topic+Normal">stats::rnorm()</a></code></p>
</td></tr>
<tr><td><code id="test_set_+3A_seed">seed</code></td>
<td>
<p>Value passed to <code><a href="base.html#topic+Random">base::set.seed()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+ts">stats::ts()</a></code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+DataCPSim">DataCPSim</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- test_set()
plot(x)
changepoints(x)
</code></pre>

<hr>
<h2 id='tidycpt-class'>Container class for <code>tidycpt</code> objects</h2><span id='topic+tidycpt-class'></span>

<h3>Description</h3>

<p>Container class for <code>tidycpt</code> objects
</p>


<h3>Details</h3>

<p>Every <code>tidycpt</code> object contains:
</p>

<ul>
<li> <p><code>segmenter</code>: The object returned by the underlying changepoint
detection algorithm. These can be of arbitrary class. Use <code><a href="#topic+as.segmenter">as.segmenter()</a></code>
to retrieve them.
</p>
</li>
<li> <p><code>model</code>: A model object inheriting from <a href="#topic+mod_cpt">mod_cpt</a>, as created by
<code><a href="#topic+as.model">as.model()</a></code> when called on the <code>segmenter</code>.
</p>
</li>
<li> <p><code>elapsed_time</code>: The clock time that passed while the algorithm was running.
</p>
</li>
<li> <p><code>time_index</code>: If available, the labels for the time indices of the time series.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="#topic+tidycpt-class">tidycpt</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Segment a time series using PELT
x &lt;- segment(CET, method = "pelt")
class(x)
str(x)

</code></pre>

<hr>
<h2 id='vec_ptype2.logLik.logLik'>Vectors implementation for logLik</h2><span id='topic+vec_ptype2.logLik.logLik'></span><span id='topic+vec_cast.logLik.logLik'></span>

<h3>Description</h3>

<p>Vectors implementation for logLik
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logLik.logLik'
vec_ptype2(x, y, ...)

## S3 method for class 'logLik.logLik'
vec_cast(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec_ptype2.logLik.logLik_+3A_x">x</code>, <code id="vec_ptype2.logLik.logLik_+3A_y">y</code></td>
<td>
<p>Vector types.</p>
</td></tr>
<tr><td><code id="vec_ptype2.logLik.logLik_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_ptype2.logLik.logLik_+3A_to">to</code></td>
<td>
<p>Type to cast to. If <code>NULL</code>, <code>x</code> will be returned as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+logLik">stats::logLik()</a></code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+logLik">stats::logLik()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- logLik(lm(mpg ~ disp, data = mtcars))
b &lt;- logLik(lm(mpg ~ am, data = mtcars))
vec_ptype2(a, b)
c(a, b)
vec_cast(a, b)
</code></pre>

<hr>
<h2 id='whomademe'>Recover the function that created a model</h2><span id='topic+whomademe'></span>

<h3>Description</h3>

<p>Recover the function that created a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whomademe(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whomademe_+3A_x">x</code></td>
<td>
<p>A <code>character</code> giving the name of a model. To be passed to
<code><a href="#topic+model_name">model_name()</a></code>.</p>
</td></tr>
<tr><td><code id="whomademe_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model objects (inheriting from <a href="#topic+mod_cpt">mod_cpt</a>) know the name of the function
that created them.
<code><a href="#topic+whomademe">whomademe()</a></code> returns that function.
</p>


<h3>Value</h3>

<p>A <code>function</code>
</p>


<h3>See Also</h3>

<p>Other model-fitting: 
<code><a href="#topic+fit_lmshift">fit_lmshift</a>()</code>,
<code><a href="#topic+fit_meanshift">fit_meanshift</a>()</code>,
<code><a href="#topic+fit_meanvar">fit_meanvar</a>()</code>,
<code><a href="#topic+fit_nhpp">fit_nhpp</a>()</code>,
<code><a href="#topic+model_args">model_args</a>()</code>,
<code><a href="#topic+model_name">model_name</a>()</code>,
<code><a href="#topic+new_fun_cpt">new_fun_cpt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the function that made a model
f &lt;- whomademe(fit_meanshift_norm(CET, tau = 42))
str(f)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
