<!DOCTYPE html><html lang="en"><head><title>Help for package Xcertainty</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Xcertainty}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#body_condition'><p>Compute body condition metrics for a set of measurements</p></a></li>
<li><a href='#body_condition_measurement_estimates'><p>Sample MCMC output</p></a></li>
<li><a href='#body_condition_measurements'><p>Humpback whale measurement data from Duke University's Marine Robotics and Remote Sensing (MaRRS) Lab</p></a></li>
<li><a href='#breakFun'><p>Break function (required in models)</p></a></li>
<li><a href='#calibration'><p>Calibration (training) data</p></a></li>
<li><a href='#calibration_sampler'><p>MCMC sampler for calibration data</p></a></li>
<li><a href='#calibration2'><p>Calibration (training) data from Duke University's Marine Robotics and Remote Sensing (MaRRS) Lab</p></a></li>
<li><a href='#co_data'><p>Calibration (training) data for gray whale example</p></a></li>
<li><a href='#combine_observations'><p>Combine parsed observations into a single parsed object</p></a></li>
<li><a href='#flatten_data'><p>Reformat photogrammetric data for model-based analysis</p></a></li>
<li><a href='#growth_curve_sampler'><p>MCMC sampler for measurements of individuals with replicates and age information to generate growth curve</p></a></li>
<li><a href='#gw_data'><p>Gray whale measurement data</p></a></li>
<li><a href='#independent_length_sampler'><p>MCMC sampler for individuals with independent measurements.</p></a></li>
<li><a href='#nondecreasing_length_sampler'><p>MCMC sampler for measurements of individuals with replicates but no age information.</p></a></li>
<li><a href='#parse_observations'><p>Pre-process training and experimental data from wide-format to long-format</p></a></li>
<li><a href='#whale_info'><p>Gray whale metadata</p></a></li>
<li><a href='#whales'><p>Gray whale metadata</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimating Lengths and Uncertainty from Photogrammetric Imagery</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Hewitt [aut],
  K.C. Bierlich [aut, cre],
  Enrico Pirotta [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>K.C. Bierlich &lt;bierlick@oregonstate.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Bayesian models for estimating object lengths and morphological relationships between object lengths using photographic data collected from drones.  The Bayesian model is described in "Bayesian approach for predicting photogrammetric uncertainty in morphometric measurements derived from drones" (Bierlich et al., 2021, &lt;<a href="https://doi.org/10.3354%2Fmeps13814">doi:10.3354/meps13814</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MMI-CODEX/Xcertainty">https://github.com/MMI-CODEX/Xcertainty</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MMI-CODEX/Xcertainty/issues">https://github.com/MMI-CODEX/Xcertainty/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), nimble</td>
</tr>
<tr>
<td>Imports:</td>
<td>tidyr, dplyr, coda</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, stringr, ggdist, tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-25 23:06:05 UTC; k.bierlich</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-26 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='body_condition'>Compute body condition metrics for a set of measurements</h2><span id='topic+body_condition'></span>

<h3>Description</h3>

<p>Function that post-processes posterior samples from a sampler, such as 
<code>independent_length_sampler()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>body_condition(
  data,
  output,
  length_name,
  width_names,
  width_increments,
  summary.burn = 0.5,
  height_ratios = rep(1, length(width_names)),
  metric = c("surface_area", "body_area_index", "body_volume", "standardized_widths")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="body_condition_+3A_data">data</code></td>
<td>
<p>The output from parse_observations</p>
</td></tr>
<tr><td><code id="body_condition_+3A_output">output</code></td>
<td>
<p>The return object from a sampler</p>
</td></tr>
<tr><td><code id="body_condition_+3A_length_name">length_name</code></td>
<td>
<p>The name of the total-length measurement in the dataset</p>
</td></tr>
<tr><td><code id="body_condition_+3A_width_names">width_names</code></td>
<td>
<p>Character vector with the names of the width measurements
in the dataset</p>
</td></tr>
<tr><td><code id="body_condition_+3A_width_increments">width_increments</code></td>
<td>
<p>Numeric vector indicating which perpendicular width 
segment each <code>width_names</code> entry corresponds to, reported as a 
percentage along an animal's total length (i.e., <code>5</code> for &quot;5%&quot;, etc.)</p>
</td></tr>
<tr><td><code id="body_condition_+3A_summary.burn">summary.burn</code></td>
<td>
<p>proportion of posterior samples to discard before 
computing posterior summary statistics</p>
</td></tr>
<tr><td><code id="body_condition_+3A_height_ratios">height_ratios</code></td>
<td>
<p>numeric vector used to compute <code>'body_volume'</code>
metric. the <code>'body_volume'</code> metric assumes the animal's height at a 
<code>width_increment</code> is the measured width (estimate) times the 
corresponding entry in <code>height_ratios</code>.  By default, all 
<code>height_ratios</code> are assumed to equal 1, which reflects a default 
assumption that an animal's vertical cross sections are circular rather 
than elliptical.</p>
</td></tr>
<tr><td><code id="body_condition_+3A_metric">metric</code></td>
<td>
<p>Character vector of the body condition metrics to compute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a list with five elements: 
</p>

<dl>
<dt>surface_area</dt><dd><p>a list containing the surface area samples and summaries
for each Subject</p>
</dd>
<dt>body_area_index</dt><dd><p>a list containing the body area index samples and summaries
for each Subject</p>
</dd>
<dt>body_volume</dt><dd><p>a list containing the body volume samples and summaries
for each Subject</p>
</dd>
<dt>standardized_widths</dt><dd><p>a list containing the standardized width samples and summaries
for each Subject</p>
</dd>
<dt>summaries</dt><dd><p>a list for each body condition metric containing summaries for each Subject</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(stringr)
library(dplyr)

#
# parse data for Xcertainty
#

data("calibration2")
data("body_condition_measurements")

body_condition_measurements &lt;- body_condition_measurements %&gt;% 
  select(!c(TL.10.0..Width, TL.15.0..Width, TL.5.0..Width, TL.90.0..Width,
            TL.95.0..Width))

# parse calibration study
calibration_data = parse_observations(
  x = calibration2, 
  subject_col = 'L_train',
  meas_col = 'RRR.pix', 
  tlen_col = 'L_train', 
  image_col = 'Images', 
  barometer_col = 'Baro...Ht',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal.length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'Aircraft'
)

# identify the width columns in the dataset
width_names = grep(
  pattern = 'TL\\..*', 
  x = colnames(body_condition_measurements),
  value = TRUE
)

# parse whale data
whale_data = parse_observations(
  x = body_condition_measurements, #[1:5,], 
  subject_col = 'Animal_ID', 
  meas_col = c('TL', width_names), 
  image_col = 'Image', 
  barometer_col = 'BaroAlt',
  laser_col = 'LaserAlt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw', 
  uas_col = 'Aircraft', 
  alt_conversion_col = 'BaroAlt'
)

#
# fit a basic model or load model output
# 

if(interactive()) {
  
  # build sampler
  sampler = independent_length_sampler(
    data = combine_observations(calibration_data, whale_data),
    priors = list(
      image_altitude = c(min = 0.1, max = 130),
      altimeter_bias = rbind(
        data.frame(altimeter = 'Barometer', mean = 0, sd = 1e2),
        data.frame(altimeter = 'Laser', mean = 0, sd = 1e2)
      ),
      altimeter_variance = rbind(
        data.frame(altimeter = 'Barometer', shape = .01, rate = .01),
        data.frame(altimeter = 'Laser', shape = .01, rate = .01)
      ),
      altimeter_scaling = rbind(
        data.frame(altimeter = 'Barometer', mean = 1, sd = 1e1),
        data.frame(altimeter = 'Laser', mean = 1, sd = 1e1)
      ),
      pixel_variance = c(shape = .01, rate = .01),
      object_lengths = c(min = .01, max = 20)
    )
  )
  
  # run sampler
  body_condition_measurement_estimates = sampler(niter = 1e4, thin = 100)
  
} else {
  data("body_condition_measurement_estimates")
}


#
# post-process data
#

# enumerate the width locations along the animal's length
width_increments = as.numeric(
  str_extract(
    string = width_names, 
    pattern = '[0-9]+'
  )
)

# compute body condition scores
body_condition_output = body_condition(
  data = whale_data, 
  output = body_condition_measurement_estimates,
  length_name = 'TL',
  width_names = width_names,
  width_increments = width_increments,
  summary.burn = .5
)


body_condition_output$summaries
</code></pre>

<hr>
<h2 id='body_condition_measurement_estimates'>Sample MCMC output</h2><span id='topic+body_condition_measurement_estimates'></span>

<h3>Description</h3>

<p>Posterior estimates for lengths and widths of a whale.  See 
<code>help("body_condition")</code> for computation details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>body_condition_measurement_estimates
</code></pre>


<h3>Format</h3>

<p>A list with 5 elements:
</p>

<dl>
<dt>altimeters</dt><dd><p>Posterior samples and summaries for altimeters</p>
</dd>
<dt>images</dt><dd><p>Posterior samples and summaries for images</p>
</dd>
<dt>pixel_error</dt><dd><p>Posterior samples and summaries for pixel error 
component of measurement error model</p>
</dd>
<dt>objects</dt><dd><p>Posterior samples and summaries for unknown object lengths 
that were estimated</p>
</dd>
<dt>summaries</dt><dd><p><code>data.frame</code>s with posterior summaries, collated from
all other list elements.</p>
</dd>
</dl>


<hr>
<h2 id='body_condition_measurements'>Humpback whale measurement data from Duke University's Marine Robotics and Remote Sensing (MaRRS) Lab</h2><span id='topic+body_condition_measurements'></span>

<h3>Description</h3>

<p>Photogrammetric measurements of humpback whales to estimate total body length and body condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>body_condition_measurements
</code></pre>


<h3>Format</h3>

<p>A data frame with 29 rows and 28 columns:
</p>

<dl>
<dt>Animal_ID</dt><dd><p>unique ID for the individual whale</p>
</dd>
<dt>TL</dt><dd><p>total body length measurement (m)</p>
</dd>
<dt>TL.10.0..Width</dt><dd><p>Width of whale (m), pre-computed from pixels using 
the reported laser altimeter measurement.  Width is taken at a 
cross-section perpendicular to the whale's center line, running
from the middle of the rostrum (loosely, the whale's beak/nose) to 
the middle of the peduncle (the point where the tail connects to the 
rest of the body).  The cross-section is taken 10
from the animal's rostrum to its peduncle.</p>
</dd>
<dt>TL.15.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 15
to its peduncle.</p>
</dd>
<dt>TL.20.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 20
to its peduncle.</p>
</dd>
<dt>TL.25.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 25
to its peduncle.</p>
</dd>
<dt>TL.30.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 30
to its peduncle.</p>
</dd>
<dt>TL.35.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 35
to its peduncle.</p>
</dd>
<dt>TL.40.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 40
to its peduncle.</p>
</dd>
<dt>TL.45.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 45
to its peduncle.</p>
</dd>
<dt>TL.50.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 50
to its peduncle.</p>
</dd>
<dt>TL.55.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 55
to its peduncle.</p>
</dd>
<dt>TL.60.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 60
to its peduncle.</p>
</dd>
<dt>TL.65.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 65
to its peduncle.</p>
</dd>
<dt>TL.70.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 70
to its peduncle.</p>
</dd>
<dt>TL.75.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 75
to its peduncle.</p>
</dd>
<dt>TL.80.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 80
to its peduncle.</p>
</dd>
<dt>TL.85.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 85
to its peduncle.</p>
</dd>
<dt>TL.90.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 90
to its peduncle.</p>
</dd>
<dt>TL.95.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 95
to its peduncle.</p>
</dd>
<dt>TL.5.0..Width</dt><dd><p>Same as <code>TL.10.0..Width</code>, but taken at a 
cross-section that is 5
to its peduncle.</p>
</dd>
<dt>Image</dt><dd><p>image name</p>
</dd>
<dt>BaroAlt</dt><dd><p>the barometer altitude adjusted for the launch height of the drone</p>
</dd>
<dt>LaserAlt</dt><dd><p>the altitude recorded by the laser (LiDAR) altimeter</p>
</dd>
<dt>Focal_Length</dt><dd><p>focal length of the camera (mm)</p>
</dd>
<dt>Iw</dt><dd><p>image width (px)</p>
</dd> 
<dt>Sw</dt><dd><p>sensor width (mm)</p>
</dd>
<dt>Aircraft</dt><dd><p>the unoccupied aircraft system (UAS), or drone, used in data collection</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.3389/fmars.2021.749943&gt;
</p>

<hr>
<h2 id='breakFun'>Break function (required in models)</h2><span id='topic+breakFun'></span>

<h3>Description</h3>

<p>Implements Heaviside step function for use in nimble models, H(B) = 1 if 
B &lt;= delta. For internal use only.  Not intended to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breakFun(B, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breakFun_+3A_b">B</code></td>
<td>
<p>argument to evaluate function at</p>
</td></tr>
<tr><td><code id="breakFun_+3A_delta">delta</code></td>
<td>
<p>breakpoint location</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1 if <code>B &lt;= delta</code>, and 0 otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>breakFun(B = 1, delta = 0) 

</code></pre>

<hr>
<h2 id='calibration'>Calibration (training) data</h2><span id='topic+calibration'></span>

<h3>Description</h3>

<p>Photogrammetric measurements of known-sized calibration objects to be used as training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration
</code></pre>


<h3>Format</h3>

<p>A data frame with 657 rows and 10 columns:
</p>

<dl>
<dt>CO.ID</dt><dd><p>the calibration object ID in training data</p>
</dd>
<dt>Lpix</dt><dd><p>length measurement (px)</p>
</dd>
<dt>CO.L</dt><dd><p>the true length of the calibration object (m)</p>
</dd>
<dt>image</dt><dd><p>image name</p>
</dd>
<dt>Baro_Alt</dt><dd><p>the barometer altitude adjusted for the launch height of the drone: Baro_raw + Launch_Ht</p>
</dd>
<dt>Laser_Alt</dt><dd><p>the altitude recorded by the laser (LiDAR) altimeter</p>
</dd>
<dt>Focal_Length</dt><dd><p>focal length of the camera (mm)</p>
</dd>
<dt>Iw</dt><dd><p>image width (px)</p>
</dd> 
<dt>Sw</dt><dd><p>sensor width (mm)</p>
</dd>
<dt>uas</dt><dd><p>the unoccupied aircraft system (UAS), or drone, used in data collection</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.1111/gcb.17366&gt;
</p>

<hr>
<h2 id='calibration_sampler'>MCMC sampler for calibration data</h2><span id='topic+calibration_sampler'></span>

<h3>Description</h3>

<p>Build an MCMC sampler that only uses calibration data to estimate measurement 
error parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration_sampler(data, priors, package_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calibration_sampler_+3A_data">data</code></td>
<td>
<p>Photogrammetric data formatted for Xcertainty models, required to
be an object with class <code>obs.parsed</code>, which can be obtained by running
<code>parse_observations()</code></p>
</td></tr>
<tr><td><code id="calibration_sampler_+3A_priors">priors</code></td>
<td>
<p><code>list</code> with components that define the model's prior 
distribution.  See <code>help("flatten_data")</code> for more details.</p>
</td></tr>
<tr><td><code id="calibration_sampler_+3A_package_only">package_only</code></td>
<td>
<p><code>TRUE</code> to return the formatted data used to build 
the sampler, otherwise <code>FALSE</code> to return the sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a function to run a sampler, the function arguments are: 
</p>

<dl>
<dt>niter</dt><dd><p>set the number of iterations</p>
</dd>
<dt>burn</dt><dd><p>set the number samples to discard</p>
</dd>
<dt>thin</dt><dd><p>set the thinning rate</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# build sampler
sampler_data = calibration_sampler(
  data = calibration_data,
  priors = list(
    image_altitude = c(min = 0.1, max = 130),
    altimeter_bias = rbind(
      data.frame(altimeter = 'Barometer', mean = 0, sd = 1e2),
      data.frame(altimeter = 'Laser', mean = 0, sd = 1e2)
    ),
    altimeter_variance = rbind(
      data.frame(altimeter = 'Barometer', shape = .01, rate = .01),
      data.frame(altimeter = 'Laser', shape = .01, rate = .01)
    ),
    altimeter_scaling = rbind(
      data.frame(altimeter = 'Barometer', mean = 1, sd = 1e1),
      data.frame(altimeter = 'Laser', mean = 1, sd = 1e1)
    ),
    pixel_variance = c(shape = .01, rate = .01)
  ),
  # set to false to return sampler function
  package_only = TRUE
)
</code></pre>

<hr>
<h2 id='calibration2'>Calibration (training) data from Duke University's Marine Robotics and Remote Sensing (MaRRS) Lab</h2><span id='topic+calibration2'></span>

<h3>Description</h3>

<p>Photogrammetric measurements of known-sized calibration objects to be used as training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration2
</code></pre>


<h3>Format</h3>

<p>A data frame with 46 rows and 9 columns:
</p>

<dl>
<dt>L_train</dt><dd><p>the true length of the calibration object (m)</p>
</dd>
<dt>RRR.pix</dt><dd><p>length measurement (px)</p>
</dd>
<dt>Images</dt><dd><p>image name</p>
</dd>
<dt>Baro...Ht</dt><dd><p>the barometer altitude adjusted for the launch height of the dronet</p>
</dd>
<dt>Laser_Alt</dt><dd><p>the altitude recorded by the laser (LiDAR) altimeter</p>
</dd>
<dt>Focal.length</dt><dd><p>focal length of the camera (mm)</p>
</dd>
<dt>Iw</dt><dd><p>image width (px)</p>
</dd> 
<dt>Sw</dt><dd><p>sensor width (mm)</p>
</dd>
<dt>Aircraft</dt><dd><p>the unoccupied aircraft system (UAS), or drone, used in data collection</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.3389/fmars.2021.749943&gt;
</p>

<hr>
<h2 id='co_data'>Calibration (training) data for gray whale example</h2><span id='topic+co_data'></span>

<h3>Description</h3>

<p>Photogrammetric measurements of known-sized calibration objects to be used as training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>co_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 118 rows and 15 columns:
</p>

<dl>
<dt>uas</dt><dd><p>the unoccupied aircraft system (UAS), or drone, used in data collection</p>
</dd>
<dt>CO.ID</dt><dd><p>the calibration object ID in training data</p>
</dd>
<dt>CO.L</dt><dd><p>the true length of the calibration object (m)</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>image</dt><dd><p>image name</p>
</dd>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>Sw</dt><dd><p>sensor width (mm)</p>
</dd>
<dt>Iw</dt><dd><p>image width (px)</p>
</dd>
<dt>Focal_Length</dt><dd><p>focal length of the camera (mm)</p>
</dd>
<dt>Focal_Length_adj</dt><dd><p>the adjusted focal length (mm) to account for internal processing that corrects for barrel distortion</p>
</dd>
<dt>Baro_raw</dt><dd><p>raw altitude recorded by the barometer altimeter</p>
</dd>
<dt>Launch_Ht</dt><dd><p>the launch height of the drone</p>
</dd>
<dt>Baro_Alt</dt><dd><p>the barometer altitude adjusted for the launch height of the drone: Baro_raw + Launch_Ht</p>
</dd>
<dt>Laser_Alt</dt><dd><p>the altitude recorded by the laser (LiDAR) altimeter</p>
</dd>
<dt>Lpix</dt><dd><p>length measurement (px)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.1139/dsa-2023-0051&gt;
</p>

<hr>
<h2 id='combine_observations'>Combine parsed observations into a single parsed object</h2><span id='topic+combine_observations'></span>

<h3>Description</h3>

<p>Combine parsed observations, such as calibration and observation (whale) data into a single parsed object. 
This combined, single parsed object can then be used as the data input for one of the samplers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_observations(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_observations_+3A_...">...</code></td>
<td>
<p>Parsed datasets to combine (i.e., outputs from 
<code>Xcertainty::parsed_observations</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a list with four elements: 
</p>

<dl>
<dt>pixel_counts</dt><dd><p>a tibble containing the measurements in pixels 
linked with Subject, Measurement description, Image, and the Timepoint</p>
</dd>
<dt>training_objects</dt><dd><p>a tibble containing the Subject, Measurement, Length, 
and Timepoint. NULL if no training objects were included</p>
</dd>
<dt>prediction_objects</dt><dd><p>a tibble containing the Subject, Measurement, and 
Timepoint. NULL if no prediction data included</p>
</dd>
<dt>image_info</dt><dd><p>a tibble containing the Image, Barometer, Laser, FocalLength,
ImageWidth, SensorWidth, and UAS</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")
data("whales")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer',
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS',
  timepoint_col = 'year'
)

# combine parsed calibration and observation (whale) data
combined_data = combine_observations(calibration_data, whale_data)
</code></pre>

<hr>
<h2 id='flatten_data'>Reformat photogrammetric data for model-based analysis</h2><span id='topic+flatten_data'></span>

<h3>Description</h3>

<p>For internal use only.  Not intended to be called directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_data(
  data = NULL,
  priors,
  pixel_counts = data$pixel_counts,
  training_objects = data$training_objects,
  image_info = data$image_info,
  prediction_objects = data$prediction_objects
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatten_data_+3A_data">data</code></td>
<td>
<p>A <code>list</code> object, or similar that includes components 
that describe observations to analyze.  Components are automatically
extracted into this function's other arguments.  See the remaining 
documentation for details about required components.</p>
</td></tr>
<tr><td><code id="flatten_data_+3A_priors">priors</code></td>
<td>
<p><code>list</code> with elements <code>altitude</code>, <code>lengths</code>, 
<code>bias</code>, and <code>sigma</code> that parameterize the prior distributions for 
the Bayesian model.  The bias components may specify separate priors for
each UAS/altimeter type combination, or for all barometers at once based on
the information provided for joining.</p>
</td></tr>
<tr><td><code id="flatten_data_+3A_pixel_counts">pixel_counts</code></td>
<td>
<p><code>data.frame</code> with columns <code>Subject</code>, 
<code>Measurement</code>, <code>Image</code>, and <code>PixelCount</code> that describe the 
length measurements taken from images</p>
</td></tr>
<tr><td><code id="flatten_data_+3A_training_objects">training_objects</code></td>
<td>
<p><code>data.frame</code> with columns <code>Subject</code>,
<code>Measurement</code>, and <code>Length</code> that describe the known lengths of 
the objects used to calibrate the photogrammetric model</p>
</td></tr>
<tr><td><code id="flatten_data_+3A_image_info">image_info</code></td>
<td>
<p><code>data.frame</code> with columns <code>Image</code>, 
<code>Barometer</code>, <code>Laser</code>, <code>FocalLength</code>, 
<code>ImageWidth</code>, and <code>SensorWidth</code> that describe the images used in 
the photogrammetric study</p>
</td></tr>
<tr><td><code id="flatten_data_+3A_prediction_objects">prediction_objects</code></td>
<td>
<p><code>data.frame</code> with elements <code>Subject</code>, 
<code>Measurement</code>, and <code>Timepoint</code> that describe the unknown lengths
of objects that should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assemble <code>data.frame</code> objects into a format that can be analyzed using 
numerical methods.  This function is analagous to <code>stats::model.matrix</code>,
which generates design matrices for models that are specified via formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")
data("whales")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer',
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS',
  timepoint_col = 'year'
)

# combine parsed calibration and observation (whale) data
combined_data = combine_observations(calibration_data, whale_data)
</code></pre>

<hr>
<h2 id='growth_curve_sampler'>MCMC sampler for measurements of individuals with replicates and age information to generate growth curve</h2><span id='topic+growth_curve_sampler'></span>

<h3>Description</h3>

<p>Build an MCMC sampler that uses calibration data to estimate the total 
length of animals.  The total lengths are assumed to follow a growth curve
model, so replicates across time points that include age information are 
required to fit the model.  The length model is a von-Bertalanffy-Putter 
growth model, following Pirotta &amp; Bierlich et al., (in revision).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_curve_sampler(data, priors, subject_info, package_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growth_curve_sampler_+3A_data">data</code></td>
<td>
<p>Photogrammetric data formatted for Xcertainty models, required to
be an object with class <code>obs.parsed</code>, which can be obtained by running
<code>parse_observations()</code></p>
</td></tr>
<tr><td><code id="growth_curve_sampler_+3A_priors">priors</code></td>
<td>
<p><code>list</code> with components that define the model's prior 
distribution.  See <code>help("flatten_data")</code> for more details.</p>
</td></tr>
<tr><td><code id="growth_curve_sampler_+3A_subject_info">subject_info</code></td>
<td>
<p><code>data.frame</code> with elements <code>Year</code>, 
<code>Subject</code>, <code>Group</code>, <code>ObservedAge</code>, and <code>AgeType</code>.  See
<code>help("whale_info")</code> for descriptions of <code>data.frame</code> columns.</p>
</td></tr>
<tr><td><code id="growth_curve_sampler_+3A_package_only">package_only</code></td>
<td>
<p><code>TRUE</code> to return the formatted data used to build 
the sampler, otherwise <code>FALSE</code> to return the sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a function to run a sampler, the function arguments are: 
</p>

<dl>
<dt>niter</dt><dd><p>set the number of iterations</p>
</dd>
<dt>burn</dt><dd><p>set the number samples to discard</p>
</dd>
<dt>thin</dt><dd><p>set the thinning rate</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")
data("whales")
data("whale_info")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer',
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS',
  timepoint_col = 'year'
)

# build sampler
sampler_data = growth_curve_sampler(
  data = combine_observations(calibration_data, whale_data),
  priors = list(
    image_altitude = c(min = 0.1, max = 130),
    altimeter_bias = rbind(
      data.frame(altimeter = 'Barometer', mean = 0, sd = 1e2),
      data.frame(altimeter = 'Laser', mean = 0, sd = 1e2)
    ),
    altimeter_variance = rbind(
      data.frame(altimeter = 'Barometer', shape = .01, rate = .01),
      data.frame(altimeter = 'Laser', shape = .01, rate = .01)
    ),
    altimeter_scaling = rbind(
      data.frame(altimeter = 'Barometer', mean = 1, sd = 1e1),
      data.frame(altimeter = 'Laser', mean = 1, sd = 1e1)
    ),
    pixel_variance = c(shape = .01, rate = .01),
    # priors from Agbayani et al. 
    zero_length_age = c(mean = -5.09, sd = 0.4),
    growth_rate = c(mean = .18, sd = .01),
    # additional priors
    group_asymptotic_size = rbind(
      Female = c(mean = 12, sd = .5),
      Male = c(mean = 12, sd = .5)
    ),
    group_asymptotic_size_trend = rbind(
      Female = c(mean = 0, sd = 1),
      Male = c(mean = 0, sd = 1)
    ),
    subject_group_distribution = c(Female = .5, Male = .5),
    asymptotic_size_sd = c(min = 0, max = 10),
    min_calf_length = 3.5,
    # To model break points between 1990 and 2015
    group_size_shift_start_year = c(min = 1990, max = 2015)
  ),
  subject_info = whale_info,
  # set to false to return sampler function
  package_only = TRUE
)
</code></pre>

<hr>
<h2 id='gw_data'>Gray whale measurement data</h2><span id='topic+gw_data'></span>

<h3>Description</h3>

<p>An example dataset of gray whale measurements from drone-based photogrammetry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gw_data
</code></pre>


<h3>Format</h3>

<p>A tibble with 15 rows and 34 columns:
</p>

<dl>
<dt>whale_ID</dt><dd><p>unique individual</p>
</dd>
<dt>image</dt><dd><p>image name</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>DOY</dt><dd><p>Day of Year</p>
</dd>
<dt>uas</dt><dd><p>the unoccupied aircraft system (UAS), or drone, used in data collection</p>
</dd>
<dt>Focal_Length</dt><dd><p>focal length of the camera (mm)</p>
</dd>
<dt>Focal_Length_adj</dt><dd><p>the adjusted focal length (mm) to account for internal processing that corrects for barrel distortion</p>
</dd>
<dt>Sw</dt><dd><p>sensor width (mm)</p>
</dd>
<dt>Iw</dt><dd><p>image width (px)</p>
</dd>
<dt>Baro_raw</dt><dd><p>raw altitude recorded by the barometer altimeter</p>
</dd>
<dt>Launch_Ht</dt><dd><p>the launch height of the drone</p>
</dd>
<dt>Baro_Alt</dt><dd><p>the barometer altitude adjusted for the launch height of the drone: Baro_raw + Launch_Ht</p>
</dd>
<dt>Laser_Alt</dt><dd><p>the altitude recorded by the laser (LiDAR) altimeter</p>
</dd>
<dt>CO.ID</dt><dd><p>the calibration object ID in training data</p>
</dd>
<dt>TL_px</dt><dd><p>total body length measurement (px)</p>
</dd>
<dt>TL_w05.00_px</dt><dd><p>Body width measurement (px) at 5% of total length</p>
</dd>
<dt>TL_w10.00_px</dt><dd><p>Body width measurement (px) at 10% of total length</p>
</dd>
<dt>TL_w15.00_px</dt><dd><p>Body width measurement (px) at 15% of total length</p>
</dd>
<dt>TL_w20.00_px</dt><dd><p>Body width measurement (px) at 20% of total length</p>
</dd>
<dt>TL_w25.00_px</dt><dd><p>Body width measurement (px) at 25% of total length</p>
</dd>
<dt>TL_w30.00_px</dt><dd><p>Body width measurement (px) at 30% of total length</p>
</dd>
<dt>TL_w35.00_px</dt><dd><p>Body width measurement (px) at 35% of total length</p>
</dd>
<dt>TL_w40.00_px</dt><dd><p>Body width measurement (px) at 40% of total length</p>
</dd>
<dt>TL_w45.00_px</dt><dd><p>Body width measurement (px) at 45% of total length</p>
</dd>
<dt>TL_w50.00_px</dt><dd><p>Body width measurement (px) at 50% of total length</p>
</dd>
<dt>TL_w55.00_px</dt><dd><p>Body width measurement (px) at 55% of total length</p>
</dd>
<dt>TL_w60.00_px</dt><dd><p>Body width measurement (px) at 60% of total length</p>
</dd>
<dt>TL_w65.00_px</dt><dd><p>Body width measurement (px) at 65% of total length</p>
</dd>
<dt>TL_w70.00_px</dt><dd><p>Body width measurement (px) at 70% of total length</p>
</dd>
<dt>TL_w75.00_px</dt><dd><p>Body width measurement (px) at 75% of total length</p>
</dd>
<dt>TL_w80.00_px</dt><dd><p>Body width measurement (px) at 80% of total length</p>
</dd>
<dt>TL_w85.00_px</dt><dd><p>Body width measurement (px) at 85% of total length</p>
</dd>
<dt>TL_w90.00_px</dt><dd><p>Body width measurement (px) at 90% of total length</p>
</dd>
<dt>TL_w95.00_px</dt><dd><p>Body width measurement (px) at 95% of total length</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://mmi.oregonstate.edu/gemm-lab&gt;
</p>

<hr>
<h2 id='independent_length_sampler'>MCMC sampler for individuals with independent measurements.</h2><span id='topic+independent_length_sampler'></span>

<h3>Description</h3>

<p>Build an MCMC sampler that uses calibration data to estimate independent,
unknown measurements. This model assumes all Subject/Measurement/Timepoint 
combinations are independent. So, this sample is well suited for data 
containing individuals that either have no replicate samples or 
have replicate samples that are independent over time, such as body condition 
which can increase or decrease over time, as opposed to length which should 
be stable or increase over time. It can also be used to estimate lengths 
when there are replicate measurements. However, since the model assumes all 
Subject/Measurement/Timepoint combinations are independent, no strength will 
be borrowed across temporal replication of a subject's measurements, 
for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independent_length_sampler(data, priors, package_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="independent_length_sampler_+3A_data">data</code></td>
<td>
<p>Photogrammetric data formatted for Xcertainty models, required to
be an object with class <code>obs.parsed</code>, which can be obtained by running
<code>parse_observations()</code></p>
</td></tr>
<tr><td><code id="independent_length_sampler_+3A_priors">priors</code></td>
<td>
<p><code>list</code> with components that define the model's prior 
distribution.  See <code>help("flatten_data")</code> for more details.</p>
</td></tr>
<tr><td><code id="independent_length_sampler_+3A_package_only">package_only</code></td>
<td>
<p><code>TRUE</code> to return the formatted data used to build 
the sampler, otherwise <code>FALSE</code> to return the sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a function to run a sampler, the function arguments are: 
</p>

<dl>
<dt>niter</dt><dd><p>set the number of iterations</p>
</dd>
<dt>burn</dt><dd><p>set the number samples to discard</p>
</dd>
<dt>thin</dt><dd><p>set the thinning rate</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")
data("whales")
data("whale_info")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer',
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS',
  timepoint_col = 'year'
)

# build sampler
sampler_data = independent_length_sampler(
  data = combine_observations(calibration_data, whale_data),
  priors = list(
    image_altitude = c(min = 0.1, max = 130),
    altimeter_bias = rbind(
      data.frame(altimeter = 'Barometer', mean = 0, sd = 1e2),
      data.frame(altimeter = 'Laser', mean = 0, sd = 1e2)
    ),
    altimeter_variance = rbind(
      data.frame(altimeter = 'Barometer', shape = .01, rate = .01),
      data.frame(altimeter = 'Laser', shape = .01, rate = .01)
    ),
    altimeter_scaling = rbind(
      data.frame(altimeter = 'Barometer', mean = 1, sd = 1e1),
      data.frame(altimeter = 'Laser', mean = 1, sd = 1e1)
    ),
    pixel_variance = c(shape = .01, rate = .01),
    object_lengths = c(min = .01, max = 20)
  ),
  # set to false to return sampler function
  package_only = TRUE
)
</code></pre>

<hr>
<h2 id='nondecreasing_length_sampler'>MCMC sampler for measurements of individuals with replicates but no age information.</h2><span id='topic+nondecreasing_length_sampler'></span>

<h3>Description</h3>

<p>Build an MCMC sampler that uses calibration data to estimate measurements 
that are assumed to be non-decreasing in time.  This sampler is well suited 
for when individuals have replicate measurements across time points but do 
not have age information.  The model estimates changes in unique combinations 
of Subject/Measurement pairs over Timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nondecreasing_length_sampler(data, priors, package_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nondecreasing_length_sampler_+3A_data">data</code></td>
<td>
<p>Photogrammetric data formatted for Xcertainty models, required to
be an object with class <code>obs.parsed</code>, which can be obtained by running
<code>parse_observations()</code></p>
</td></tr>
<tr><td><code id="nondecreasing_length_sampler_+3A_priors">priors</code></td>
<td>
<p><code>list</code> with components that define the model's prior 
distribution.  See <code>help("flatten_data")</code> for more details.</p>
</td></tr>
<tr><td><code id="nondecreasing_length_sampler_+3A_package_only">package_only</code></td>
<td>
<p><code>TRUE</code> to return the formatted data used to build 
the sampler, otherwise <code>FALSE</code> to return the sampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a function to run a sampler, the function arguments are: 
</p>

<dl>
<dt>niter</dt><dd><p>set the number of iterations</p>
</dd>
<dt>burn</dt><dd><p>set the number samples to discard</p>
</dd>
<dt>thin</dt><dd><p>set the thinning rate</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")
data("whales")
data("whale_info")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer',
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS',
  timepoint_col = 'year'
)

# build sampler
sampler_data = nondecreasing_length_sampler(
  data = combine_observations(calibration_data, whale_data),
  priors = list(
    image_altitude = c(min = 0.1, max = 130),
    altimeter_bias = rbind(
      data.frame(altimeter = 'Barometer', mean = 0, sd = 1e2),
      data.frame(altimeter = 'Laser', mean = 0, sd = 1e2)
    ),
    altimeter_variance = rbind(
      data.frame(altimeter = 'Barometer', shape = .01, rate = .01),
      data.frame(altimeter = 'Laser', shape = .01, rate = .01)
    ),
    altimeter_scaling = rbind(
      data.frame(altimeter = 'Barometer', mean = 1, sd = 1e1),
      data.frame(altimeter = 'Laser', mean = 1, sd = 1e1)
    ),
    pixel_variance = c(shape = .01, rate = .01),
    object_lengths = c(min = .01, max = 20)
  ),
  # set to false to return sampler function
  package_only = TRUE
)
</code></pre>

<hr>
<h2 id='parse_observations'>Pre-process training and experimental data from wide-format to long-format</h2><span id='topic+parse_observations'></span>

<h3>Description</h3>

<p>Photogrammetric data are often recorded in a wide-format <code>data.frame</code>, 
in which each row contains all measurement information for a single animal.
The row contains the image information (i.e., observed altitude and sensor 
information) as well as all measurements for a given subject. This function
parses the wide-format data into a normalized <code>list</code> of 
<code>data.frame</code> objects that separately describe the image and measurement 
data.  This function can process observations of calibration data as well as 
experimental data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_observations(
  x,
  subject_col,
  meas_col,
  tlen_col = NULL,
  image_col,
  barometer_col = NULL,
  laser_col = NULL,
  flen_col,
  iwidth_col,
  swidth_col,
  uas_col,
  timepoint_col = NULL,
  alt_conversion_col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_observations_+3A_x">x</code></td>
<td>
<p>Wide-format <code>data.frame</code> describing images and measurements</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_subject_col">subject_col</code></td>
<td>
<p>column name in <code>x</code> for subject IDs</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_meas_col">meas_col</code></td>
<td>
<p>character vector of column names in <code>x</code> with 
pixel-counts for each measurement of a subject</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_tlen_col">tlen_col</code></td>
<td>
<p>column name in <code>x</code> with the true length value (i.e., in 
meters) of a measurement; primarily used to specify the true length value 
for an observation of a calibration object.  If <code>NULL</code>, then no true 
length will be associated with the measurement.</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_image_col">image_col</code></td>
<td>
<p>column name in <code>x</code> containing names of images from 
which measurements are taken</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_barometer_col">barometer_col</code></td>
<td>
<p>column name in <code>x</code> with Barometer altimeter values</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_laser_col">laser_col</code></td>
<td>
<p>column name in <code>x</code> with Laser altimeter values</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_flen_col">flen_col</code></td>
<td>
<p>column name in <code>x</code> with camera focal lengths (mm)</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_iwidth_col">iwidth_col</code></td>
<td>
<p>column name in <code>x</code> with image widths (pixels)</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_swidth_col">swidth_col</code></td>
<td>
<p>column name in <code>x</code> with camera sensor widths (mm)</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_uas_col">uas_col</code></td>
<td>
<p>column names in <code>x</code> with UAS name or ID</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_timepoint_col">timepoint_col</code></td>
<td>
<p>column name in <code>x</code> with a timepoint value of a 
measurement.  If <code>NULL</code>, then all measurements are assumed to be at 
the same timepoint, or equivalently, that time does not matter for the 
analysis</p>
</td></tr>
<tr><td><code id="parse_observations_+3A_alt_conversion_col">alt_conversion_col</code></td>
<td>
<p>if not <code>NULL</code>, column name in <code>x</code> with 
an altitude used to convert measurement columns from lengths to pixels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>outputs a list with four elements: 
</p>

<dl>
<dt>pixel_counts</dt><dd><p>a tibble containing the measurements in pixels 
linked with Subject, Measurement description, Image, and the Timepoint</p>
</dd>
<dt>training_objects</dt><dd><p>a tibble containing the Subject, Measurement, Length, 
and Timepoint. NULL if no training objects were included</p>
</dd>
<dt>prediction_objects</dt><dd><p>a tibble containing the Subject, Measurement, and 
Timepoint. NULL if no prediction data included</p>
</dd>
<dt>image_info</dt><dd><p>a tibble containing the Image, Barometer, Laser, FocalLength,
ImageWidth, SensorWidth, and UAS</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># load example wide-format data
data("calibration")
data("whales")

# parse calibration study
calibration_data = parse_observations(
  x = calibration, 
  subject_col = 'CO.ID',
  meas_col = 'Lpix', 
  tlen_col = 'CO.L', 
  image_col = 'image', 
  barometer_col = 'Baro_Alt',
  laser_col = 'Laser_Alt', 
  flen_col = 'Focal_Length', 
  iwidth_col = 'Iw', 
  swidth_col = 'Sw',
  uas_col = 'uas'
)

# parse field study
whale_data = parse_observations(
  x = whales, 
  subject_col = 'whale_ID',
  meas_col = 'TL.pix', 
  image_col = 'Image', 
  barometer_col = 'AltitudeBarometer',
  laser_col = 'AltitudeLaser', 
  flen_col = 'FocalLength', 
  iwidth_col = 'ImageWidth', 
  swidth_col = 'SensorWidth', 
  uas_col = 'UAS',
  timepoint_col = 'year'
)

# combine parsed calibration and observation (whale) data
combined_data = combine_observations(calibration_data, whale_data)
</code></pre>

<hr>
<h2 id='whale_info'>Gray whale metadata</h2><span id='topic+whale_info'></span>

<h3>Description</h3>

<p>Gray whale information and metadata that pairs with 'whales' data by &quot;Subject&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whale_info
</code></pre>


<h3>Format</h3>

<p>A data frame with 293 rows and 5 columns:
</p>

<dl>
<dt>Year</dt><dd><p>year</p>
</dd>
<dt>Subject</dt><dd><p>unique ID for individuals</p>
</dd>
<dt>Group</dt><dd><p>sex; Male, Female (F), or NA</p>
</dd>
<dt>ObservedAge</dt><dd><p>age in years</p>
</dd>
<dt>AgeType</dt><dd><p>either 'known age' if individual was seen as a calf, or 'min age' from the date of date sighting</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.1111/gcb.17366&gt;
</p>

<hr>
<h2 id='whales'>Gray whale metadata</h2><span id='topic+whales'></span>

<h3>Description</h3>

<p>Gray whale information and metadata that pairs with 'whales' data by &quot;Subject&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whales
</code></pre>


<h3>Format</h3>

<p>A data frame with 826 rows and 14 columns:
</p>

<dl>
<dt>whale_ID</dt><dd><p>unique individual</p>
</dd>
<dt>sex</dt><dd><p>Female, Male, or NA</p>
</dd>
<dt>Age</dt><dd><p>age in years</p>
</dd>
<dt>AgeType</dt><dd><p>either 'known age' if individual was seen as a calf, or 'min age' from the date of date sighting</p>
</dd>
<dt>year</dt><dd><p>Year</p>
</dd>
<dt>date</dt><dd><p>Date</p>
</dd>
<dt>Image</dt><dd><p>image name</p>
</dd>
<dt>AltitudeBarometer</dt><dd><p>the barometer altitude adjusted for the launch height of the drone</p>
</dd>
<dt>AltitudeLaser</dt><dd><p>the altitude recorded by the laser (LiDAR) altimeter</p>
</dd>
<dt>FocalLength</dt><dd><p>focal length of the camera (mm)</p>
</dd>
<dt>ImageWidth</dt><dd><p>image width (px)</p>
</dd> 
<dt>SensorWidth</dt><dd><p>sensor width (mm)</p>
</dd>
<dt>UAS</dt><dd><p>the unoccupied aircraft system (UAS), or drone, used in data collection</p>
</dd>
<dt>TL.pix</dt><dd><p>the total body length measurement in pixels</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.1111/gcb.17366&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
