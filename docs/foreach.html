<!DOCTYPE html><html><head><title>Help for package foreach</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {foreach}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#foreach'><p>foreach</p></a></li>
<li><a href='#foreach-ext'><p>foreach extension functions</p></a></li>
<li><a href='#foreach-package'><p>The Foreach Package</p></a></li>
<li><a href='#getDoParWorkers'><p>Functions Providing Information on the doPar Backend</p></a></li>
<li><a href='#getDoSeqWorkers'><p>Functions Providing Information on the doSeq Backend</p></a></li>
<li><a href='#registerDoSEQ'><p>registerDoSEQ</p></a></li>
<li><a href='#setDoPar'><p>setDoPar</p></a></li>
<li><a href='#setDoSeq'><p>setDoSeq</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Provides Foreach Looping Construct</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for the foreach looping construct.  Foreach is an
        idiom that allows for iterating over elements in a collection,
        without the use of an explicit loop counter.  This package in
        particular is intended to be used for its return value, rather
        than for its side effects.  In that sense, it is similar to the
        standard lapply function, but doesn't require the evaluation
        of a function.  Using foreach without side effects also
        facilitates executing the loop in parallel.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RevolutionAnalytics/foreach">https://github.com/RevolutionAnalytics/foreach</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RevolutionAnalytics/foreach/issues">https://github.com/RevolutionAnalytics/foreach/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>codetools, utils, iterators</td>
</tr>
<tr>
<td>Suggests:</td>
<td>randomForest, doMC, doParallel, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'callCombine.R' 'foreach.R' 'do.R' 'foreach-ext.R'
'foreach-pkg.R' 'getDoPar.R' 'getDoSeq.R' 'getsyms.R' 'iter.R'
'nextElem.R' 'onLoad.R' 'setDoPar.R' 'setDoSeq.R' 'times.R'
'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-11 04:21:12 UTC; fdaniel</td>
</tr>
<tr>
<td>Author:</td>
<td>Folashade Daniel [cre],
  Hong Ooi [ctb],
  Rich Calaway [ctb],
  Microsoft [aut, cph],
  Steve Weston [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Folashade Daniel &lt;fdaniel@microsoft.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-02 09:20:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; ; 2023-03-28 04:49:22 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='foreach'>foreach</h2><span id='topic+foreach'></span><span id='topic++25+3A+25'></span><span id='topic+when'></span><span id='topic++25do+25'></span><span id='topic++25dopar+25'></span><span id='topic+times'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;%do%&#8288;</code> and <code style="white-space: pre;">&#8288;%dopar%&#8288;</code> are binary operators that operate
on a <code>foreach</code> object and an <code>R</code> expression.
The expression, <code>ex</code>, is evaluated multiple times in an environment
that is created by the <code>foreach</code> object, and that environment is
modified for each evaluation as specified by the <code>foreach</code> object.
<code style="white-space: pre;">&#8288;%do%&#8288;</code> evaluates the expression sequentially, while <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>
evaluates it in parallel.
The results of evaluating <code>ex</code> are returned as a list by default,
but this can be modified by means of the <code>.combine</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foreach(
  ...,
  .combine,
  .init,
  .final = NULL,
  .inorder = TRUE,
  .multicombine = FALSE,
  .maxcombine = if (.multicombine) 100 else 2,
  .errorhandling = c("stop", "remove", "pass"),
  .packages = NULL,
  .export = NULL,
  .noexport = NULL,
  .verbose = FALSE
)

e1 %:% e2

when(cond)

obj %do% ex

obj %dopar% ex

times(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreach_+3A_...">...</code></td>
<td>
<p>one or more arguments that control how <code>ex</code> is
evaluated.  Named arguments specify the name and values of variables
to be defined in the evaluation environment.
An unnamed argument can be used to specify the number of times that
<code>ex</code> should be evaluated.
At least one argument must be specified in order to define the
number of times <code>ex</code> should be executed.
</p>
<p>If multiple arguments are supplied, the number of times <code>ex</code> is
evaluated is equal to the smallest number of iterations among the supplied
arguments. See the examples.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.combine">.combine</code></td>
<td>
<p>function that is used to process the tasks results as
they generated.  This can be specified as either a function or
a non-empty character string naming the function.
Specifying 'c' is useful for concatenating the results into
a vector, for example.  The values 'cbind' and 'rbind' can combine
vectors into a matrix.  The values '+' and '*' can be used to
process numeric data.
By default, the results are returned in a list.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.init">.init</code></td>
<td>
<p>initial value to pass as the first argument of the
<code>.combine</code> function.
This should not be specified unless <code>.combine</code> is also specified.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.final">.final</code></td>
<td>
<p>function of one argument that is called to return final result.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.inorder">.inorder</code></td>
<td>
<p>logical flag indicating whether the <code>.combine</code>
function requires the task results to be combined in the same order
that they were submitted.  If the order is not important, then it
setting <code>.inorder</code> to <code>FALSE</code> can give improved performance.
The default value is 'TRUE.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.multicombine">.multicombine</code></td>
<td>
<p>logical flag indicating whether the <code>.combine</code>
function can accept more than two arguments.
If an arbitrary <code>.combine</code> function is specified, by default,
that function will always be called with two arguments.
If it can take more than two arguments, then setting <code>.multicombine</code>
to <code>TRUE</code> could improve the performance.
The default value is <code>FALSE</code> unless the <code>.combine</code>
function is <code>cbind</code>, <code>rbind</code>, or <code>c</code>, which are known
to take more than two arguments.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.maxcombine">.maxcombine</code></td>
<td>
<p>maximum number of arguments to pass to the combine function.
This is only relevant if <code>.multicombine</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.errorhandling">.errorhandling</code></td>
<td>
<p>specifies how a task evaluation error should be handled.
If the value is &quot;stop&quot;, then execution will be stopped via
the <code>stop</code> function if an error occurs.
If the value is &quot;remove&quot;, the result for that task will not be
returned, or passed to the <code>.combine</code> function.
If it is &quot;pass&quot;, then the error object generated by task evaluation
will be included with the rest of the results.  It is assumed that
the combine function (if specified) will be able to deal with the
error object.
The default value is &quot;stop&quot;.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.packages">.packages</code></td>
<td>
<p>character vector of packages that the tasks depend on.
If <code>ex</code> requires a <code>R</code> package to be loaded, this option
can be used to load that package on each of the workers.
Ignored when used with <code style="white-space: pre;">&#8288;%do%&#8288;</code>.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.export">.export</code></td>
<td>
<p>character vector of variables to export.
This can be useful when accessing a variable that isn't defined in the
current environment.
The default value in <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.noexport">.noexport</code></td>
<td>
<p>character vector of variables to exclude from exporting.
This can be useful to prevent variables from being exported that aren't
actually needed, perhaps because the symbol is used in a model formula.
The default value in <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="foreach_+3A_.verbose">.verbose</code></td>
<td>
<p>logical flag enabling verbose messages.  This can be
very useful for trouble shooting.</p>
</td></tr>
<tr><td><code id="foreach_+3A_e1">e1</code></td>
<td>
<p><code>foreach</code> object to merge.</p>
</td></tr>
<tr><td><code id="foreach_+3A_e2">e2</code></td>
<td>
<p><code>foreach</code> object to merge.</p>
</td></tr>
<tr><td><code id="foreach_+3A_cond">cond</code></td>
<td>
<p>condition to evaluate.</p>
</td></tr>
<tr><td><code id="foreach_+3A_obj">obj</code></td>
<td>
<p><code>foreach</code> object used to control the evaluation
of <code>ex</code>.</p>
</td></tr>
<tr><td><code id="foreach_+3A_ex">ex</code></td>
<td>
<p>the <code>R</code> expression to evaluate.</p>
</td></tr>
<tr><td><code id="foreach_+3A_n">n</code></td>
<td>
<p>number of times to evaluate the <code>R</code> expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>foreach</code> and <code style="white-space: pre;">&#8288;%do%&#8288;</code>/<code style="white-space: pre;">&#8288;%dopar%&#8288;</code> operators provide
a looping construct that can be viewed as a hybrid of the standard
<code>for</code> loop and <code>lapply</code> function.
It looks similar to the <code>for</code> loop, and it evaluates an expression,
rather than a function (as in <code>lapply</code>), but its purpose is to
return a value (a list, by default), rather than to cause side-effects.
This facilitates parallelization, but looks more natural to people that
prefer <code>for</code> loops to <code>lapply</code>.
</p>
<p>The <code style="white-space: pre;">&#8288;%:%&#8288;</code> operator is the <em>nesting</em> operator, used for creating
nested foreach loops. Type <code>vignette("nested")</code> at the R prompt for
more details.
</p>
<p>Parallel computation depends upon a <em>parallel backend</em> that must be
registered before performing the computation. The parallel backends available
will be system-specific, but include <code>doParallel</code>, which uses R's built-in
<span class="pkg">parallel</span> package. Each parallel backend has a specific registration function,
such as <code>registerDoParallel</code>.
</p>
<p>The <code>times</code> function is a simple convenience function that calls
<code>foreach</code>.  It is useful for evaluating an <code>R</code> expression multiple
times when there are no varying arguments.  This can be convenient for
resampling, for example.
</p>


<h3>See Also</h3>

<p><code><a href="iterators.html#topic+iter">iterators::iter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># equivalent to rnorm(3)
times(3) %do% rnorm(1)

# equivalent to lapply(1:3, sqrt)
foreach(i=1:3) %do%
  sqrt(i)

# multiple ... arguments
foreach(i=1:4, j=1:10) %do%
	sqrt(i+j)

# equivalent to colMeans(m)
m &lt;- matrix(rnorm(9), 3, 3)
foreach(i=1:ncol(m), .combine=c) %do%
  mean(m[,i])

# normalize the rows of a matrix in parallel, with parenthesis used to
# force proper operator precedence
# Need to register a parallel backend before this example will run
# in parallel
foreach(i=1:nrow(m), .combine=rbind) %dopar%
  (m[i,] / mean(m[i,]))

# simple (and inefficient) parallel matrix multiply
library(iterators)
a &lt;- matrix(1:16, 4, 4)
b &lt;- t(a)
foreach(b=iter(b, by='col'), .combine=cbind) %dopar%
  (a %*% b)

# split a data frame by row, and put them back together again without
# changing anything
d &lt;- data.frame(x=1:10, y=rnorm(10))
s &lt;- foreach(d=iter(d, by='row'), .combine=rbind) %dopar% d
identical(s, d)

# a quick sort function
qsort &lt;- function(x) {
  n &lt;- length(x)
  if (n == 0) {
    x
  } else {
    p &lt;- sample(n, 1)
    smaller &lt;- foreach(y=x[-p], .combine=c) %:% when(y &lt;= x[p]) %do% y
    larger  &lt;- foreach(y=x[-p], .combine=c) %:% when(y &gt;  x[p]) %do% y
    c(qsort(smaller), x[p], qsort(larger))
  }
}
qsort(runif(12))

</code></pre>

<hr>
<h2 id='foreach-ext'>foreach extension functions</h2><span id='topic+foreach-ext'></span><span id='topic+makeAccum'></span><span id='topic+accumulate'></span><span id='topic+getResult'></span><span id='topic+getErrorValue'></span><span id='topic+getErrorIndex'></span><span id='topic+accumulate.iforeach'></span><span id='topic+getResult.iforeach'></span><span id='topic+getErrorValue.iforeach'></span><span id='topic+getErrorIndex.iforeach'></span><span id='topic+accumulate.ixforeach'></span><span id='topic+getResult.ixforeach'></span><span id='topic+getErrorValue.ixforeach'></span><span id='topic+getErrorIndex.ixforeach'></span><span id='topic+accumulate.ifilteredforeach'></span><span id='topic+getResult.ifilteredforeach'></span><span id='topic+getErrorValue.ifilteredforeach'></span><span id='topic+getErrorIndex.ifilteredforeach'></span><span id='topic+getexports'></span>

<h3>Description</h3>

<p>These functions are used to write parallel backends for the <code>foreach</code>
package.  They should not be used from normal scripts or packages that use
the <code>foreach</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAccum(it)

accumulate(obj, result, tag, ...)

getResult(obj, ...)

getErrorValue(obj, ...)

getErrorIndex(obj, ...)

## S3 method for class 'iforeach'
accumulate(obj, result, tag, ...)

## S3 method for class 'iforeach'
getResult(obj, ...)

## S3 method for class 'iforeach'
getErrorValue(obj, ...)

## S3 method for class 'iforeach'
getErrorIndex(obj, ...)

## S3 method for class 'ixforeach'
accumulate(obj, result, tag, ...)

## S3 method for class 'ixforeach'
getResult(obj, ...)

## S3 method for class 'ixforeach'
getErrorValue(obj, ...)

## S3 method for class 'ixforeach'
getErrorIndex(obj, ...)

## S3 method for class 'ifilteredforeach'
accumulate(obj, result, tag, ...)

## S3 method for class 'ifilteredforeach'
getResult(obj, ...)

## S3 method for class 'ifilteredforeach'
getErrorValue(obj, ...)

## S3 method for class 'ifilteredforeach'
getErrorIndex(obj, ...)

getexports(ex, e, env, good = character(0), bad = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foreach-ext_+3A_it">it</code></td>
<td>
<p>foreach iterator.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_obj">obj</code></td>
<td>
<p>foreach iterator object.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_result">result</code></td>
<td>
<p>task result to accumulate.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_tag">tag</code></td>
<td>
<p>tag of task result to accumulate.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_ex">ex</code></td>
<td>
<p>call object to analyze.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_e">e</code></td>
<td>
<p>local environment of the call object.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_env">env</code></td>
<td>
<p>exported environment in which call object will be evaluated.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_good">good</code></td>
<td>
<p>names of symbols that are being exported.</p>
</td></tr>
<tr><td><code id="foreach-ext_+3A_bad">bad</code></td>
<td>
<p>names of symbols that are not being exported.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>These functions are likely to change in future versions of the
<code>foreach</code> package.  When they become more stable, they will
be documented.
</p>

<hr>
<h2 id='foreach-package'>The Foreach Package</h2><span id='topic+foreach-package'></span><span id='topic+_PACKAGE'></span><span id='topic+foreach_package'></span>

<h3>Description</h3>

<p>The foreach package provides a new looping construct for executing
R code repeatedly.  The main reason for using the foreach package
is that it supports parallel execution.  The foreach package can
be used with a variety of different parallel computing systems,
include NetWorkSpaces and snow.  In addition, foreach can be
used with iterators, which allows the data to specified in a very
flexible way.
</p>


<h3>Details</h3>

<p>Further information is available in the following help topics:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>foreach</code> </td><td style="text-align: left;"> Specify the variables to iterate over</td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;%do%&#8288;</code> </td><td style="text-align: left;"> Execute the R expression sequentially</td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;%dopar%&#8288;</code> </td><td style="text-align: left;"> Execute the R expression using the currently registered backend
</td>
</tr>

</table>

<p>To see a tutorial introduction to the foreach package,
use <code>vignette("foreach")</code>.
</p>
<p>To see a demo of foreach computing the sinc function,
use <code>demo(sincSEQ)</code>.
</p>
<p>Some examples (in addition to those in the help pages) are included in
the &quot;examples&quot; directory of the foreach package.  To list the files in
the examples directory,
use <code>list.files(system.file("examples", package="foreach"))</code>.
To run the bootstrap example, use
<code>source(system.file("examples", "bootseq.R", package="foreach"))</code>.
</p>
<p>For a complete list of functions with individual help pages,
use <code>library(help="foreach")</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michelle Wallig <a href="mailto:Michelle.Wallig@microsoft.com">Michelle.Wallig@microsoft.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Microsoft [copyright holder]
</p>
</li>
<li><p> Steve Weston
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Hong Ooi [contributor]
</p>
</li>
<li><p> Rich Calaway [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/RevolutionAnalytics/foreach">https://github.com/RevolutionAnalytics/foreach</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/RevolutionAnalytics/foreach/issues">https://github.com/RevolutionAnalytics/foreach/issues</a>
</p>
</li></ul>


<hr>
<h2 id='getDoParWorkers'>Functions Providing Information on the doPar Backend</h2><span id='topic+getDoParWorkers'></span><span id='topic+getDoParRegistered'></span><span id='topic+getDoParName'></span><span id='topic+getDoParVersion'></span>

<h3>Description</h3>

<p>The <code>getDoParWorkers</code> function returns the number of
execution workers there are in the currently registered doPar backend.
It can be useful when determining how to split up the work to be executed
in parallel.  A <code>1</code> is returned by default.
</p>
<p>The <code>getDoParRegistered</code> function returns TRUE if a doPar backend
has been registered, otherwise FALSE.
</p>
<p>The <code>getDoParName</code> function returns the name of the currently
registered doPar backend.  A <code>NULL</code> is returned if no backend is
registered.
</p>
<p>The <code>getDoParVersion</code> function returns the version of the currently
registered doPar backend.  A <code>NULL</code> is returned if no backend is
registered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDoParWorkers()

getDoParRegistered()

getDoParName()

getDoParVersion()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>cat(sprintf('%s backend is registered\n',
            if(getDoParRegistered()) 'A' else 'No'))
cat(sprintf('Running with %d worker(s)\n', getDoParWorkers()))
(name &lt;- getDoParName())
(ver &lt;- getDoParVersion())
if (getDoParRegistered())
  cat(sprintf('Currently using %s [%s]\n', name, ver))

</code></pre>

<hr>
<h2 id='getDoSeqWorkers'>Functions Providing Information on the doSeq Backend</h2><span id='topic+getDoSeqWorkers'></span><span id='topic+getDoSeqRegistered'></span><span id='topic+getDoSeqName'></span><span id='topic+getDoSeqVersion'></span>

<h3>Description</h3>

<p>The <code>getDoSeqWorkers</code> function returns the number of
execution workers there are in the currently registered doSeq backend.
A <code>1</code> is returned by default.
</p>
<p>The <code>getDoSeqRegistered</code> function returns TRUE if a doSeq backend
has been registered, otherwise FALSE.
</p>
<p>The <code>getDoSeqName</code> function returns the name of the currently
registered doSeq backend.  A <code>NULL</code> is returned if no backend is
registered.
</p>
<p>The <code>getDoSeqVersion</code> function returns the version of the currently
registered doSeq backend.  A <code>NULL</code> is returned if no backend is
registered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDoSeqRegistered()

getDoSeqWorkers()

getDoSeqName()

getDoSeqVersion()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>cat(sprintf('%s backend is registered\n',
            if(getDoSeqRegistered()) 'A' else 'No'))
cat(sprintf('Running with %d worker(s)\n', getDoSeqWorkers()))
(name &lt;- getDoSeqName())
(ver &lt;- getDoSeqVersion())
if (getDoSeqRegistered())
  cat(sprintf('Currently using %s [%s]\n', name, ver))

</code></pre>

<hr>
<h2 id='registerDoSEQ'>registerDoSEQ</h2><span id='topic+registerDoSEQ'></span>

<h3>Description</h3>

<p>The <code>registerDoSEQ</code> function is used to explicitly register
a sequential parallel backend with the foreach package.
This will prevent a warning message from being issued if the
<code style="white-space: pre;">&#8288;%dopar%&#8288;</code> function is called and no parallel backend has
been registered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerDoSEQ()
</code></pre>


<h3>See Also</h3>

<p><code><a href="doParallel.html#topic+registerDoParallel">doParallel::registerDoParallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify that %dopar% should run sequentially
registerDoSEQ()
</code></pre>

<hr>
<h2 id='setDoPar'>setDoPar</h2><span id='topic+setDoPar'></span>

<h3>Description</h3>

<p>The <code>setDoPar</code> function is used to register a parallel backend with the
foreach package.  This isn't normally executed by the user.  Instead, packages
that provide a parallel backend provide a function named <code>registerDoPar</code>
that calls <code>setDoPar</code> using the appropriate arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDoPar(fun, data = NULL, info = function(data, item) NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDoPar_+3A_fun">fun</code></td>
<td>
<p>A function that implements the functionality of <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>.</p>
</td></tr>
<tr><td><code id="setDoPar_+3A_data">data</code></td>
<td>
<p>Data to be passed to the registered function.</p>
</td></tr>
<tr><td><code id="setDoPar_+3A_info">info</code></td>
<td>
<p>Function that retrieves information about the backend.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="foreach.html#topic++25dopar+25">%dopar%</a></code>
</p>

<hr>
<h2 id='setDoSeq'>setDoSeq</h2><span id='topic+setDoSeq'></span>

<h3>Description</h3>

<p>The <code>setDoSeq</code> function is used to register a sequential backend with the
foreach package.  This isn't normally executed by the user.  Instead, packages
that provide a sequential backend provide a function named <code>registerDoSeq</code>
that calls <code>setDoSeq</code> using the appropriate arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setDoSeq(fun, data = NULL, info = function(data, item) NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setDoSeq_+3A_fun">fun</code></td>
<td>
<p>A function that implements the functionality of <code style="white-space: pre;">&#8288;%dopar%&#8288;</code>.</p>
</td></tr>
<tr><td><code id="setDoSeq_+3A_data">data</code></td>
<td>
<p>Data to be passed to the registered function.</p>
</td></tr>
<tr><td><code id="setDoSeq_+3A_info">info</code></td>
<td>
<p>Function that retrieves information about the backend.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="foreach.html#topic++25dopar+25">%dopar%</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
