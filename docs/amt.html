<!DOCTYPE html><html><head><title>Help for package amt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {amt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amt_fisher'><p>GPS tracks from four fishers</p></a></li>
<li><a href='#amt_fisher_covar'><p>Environmental data for fishers</p></a></li>
<li><a href='#append_x1'><p>Append &quot;_x1&quot;</p></a></li>
<li><a href='#as_sf_lines'><p>Export track to lines</p></a></li>
<li><a href='#as_sf_points'><p>Coerces a track to points</p></a></li>
<li><a href='#as_track'><p>Coerce to track</p></a></li>
<li><a href='#as.data.frame.uhc_data'><p>Coerce a <code>uhc_data</code> object to <code>data.frame</code></p></a></li>
<li><a href='#available_distr'><p>Display available distributions for step lengths and turn angles.</p></a></li>
<li><a href='#bandwidth_pi'><p><code>hr_kde_pi</code> wraps <code>KernSmooth::dpik</code> to select bandwidth for kernel density estimation the plug-in-the-equation method in two dimensions.</p></a></li>
<li><a href='#bandwidth_ref'><p>Reference bandwidth</p></a></li>
<li><a href='#bbox'><p>Get bounding box of a track.</p></a></li>
<li><a href='#boot1.glm'><p>Single bootstrap iteration</p></a></li>
<li><a href='#bootstrap_logrss'><p>Bootstrap log-RSS estimate</p></a></li>
<li><a href='#calc_w'><p>Calculate <code>w(x)</code></p></a></li>
<li><a href='#calculate_sdr'><p>Calculate SDR</p></a></li>
<li><a href='#centroid'><p>Calculate the centroid of a track.</p></a></li>
<li><a href='#check_factors'><p>Check factor levels</p></a></li>
<li><a href='#check_time_unit'><p>Calculate Speed</p></a></li>
<li><a href='#coercion'><p>Coerce a track to other formats.</p></a></li>
<li><a href='#conf_envelope'><p>Create confidence envelopes from a <code>uhc_data_frame</code></p></a></li>
<li><a href='#convert_angles'><p>Converts angles to radians</p></a></li>
<li><a href='#coords'><p>Coordinates of a track.</p></a></li>
<li><a href='#cum_ud'><p>Calculate a cumulative UD</p></a></li>
<li><a href='#deer'><p>Relocations of 1 red deer</p></a></li>
<li><a href='#diff'><p>Difference in x and y</p></a></li>
<li><a href='#distr_name'><p>Name of step-length distribution and turn-angle distribution</p></a></li>
<li><a href='#distributions'><p>Functions create statistical distributions</p></a></li>
<li><a href='#extent'><p>Extent of a track</p></a></li>
<li><a href='#extract_covariates'><p>Extract covariate values</p></a></li>
<li><a href='#Extract.uhc_data'><p>Subset a <code>uhc_data</code> object</p></a></li>
<li><a href='#filter_min_n_burst'><p>Filter bursts by number of relocations</p></a></li>
<li><a href='#fit_clogit'><p>Fit a conditional logistic regression</p></a></li>
<li><a href='#fit_ctmm'><p>Fit a continuous time movement model with <code>ctmm</code></p></a></li>
<li><a href='#fit_distr'><p>Fit distribution to data</p></a></li>
<li><a href='#fit_logit'><p>Fit logistic regression</p></a></li>
<li><a href='#flag_defunct_clusters'><p>Flag Defunct Clusters</p></a></li>
<li><a href='#flag_duplicates'><p>Flag Low Quality Duplicates</p></a></li>
<li><a href='#flag_fast_steps'><p>Flag Fast Steps</p></a></li>
<li><a href='#flag_roundtrips'><p>Flag Fast Round Trips</p></a></li>
<li><a href='#from_to'><p>Duration of tracks</p></a></li>
<li><a href='#get_amt_fisher_covars'><p>Helper function to get fisher covars</p></a></li>
<li><a href='#get_crs'><p>Obtains the Coordinate Reference Systems</p></a></li>
<li><a href='#get_displacement'><p>Calculate Expected Displacement</p></a></li>
<li><a href='#get_distr'><p>Obtain the step length and/or turn angle distributions from random steps or a fitted model.</p></a></li>
<li><a href='#get_max_dist'><p>Get the maximum distance</p></a></li>
<li><a href='#get_sh_forest'><p>Helper function to get forest cover</p></a></li>
<li><a href='#has_crs'><p>Check for Coordinate Reference Systems (CRS)</p></a></li>
<li><a href='#hr_akde'><p>Home ranges</p></a></li>
<li><a href='#hr_area'><p>Home-range area</p></a></li>
<li><a href='#hr_isopleths'><p>Home-range isopleths</p></a></li>
<li><a href='#hr_kde_lscv'><p>Least square cross validation bandwidth</p></a></li>
<li><a href='#hr_kde_ref_scaled'><p>Select a bandwidth for Kernel Density Estimation</p></a></li>
<li><a href='#hr_overlap_feature'><p>Calculate the overlap between a home-range estimate and a polygon</p></a></li>
<li><a href='#hr_overlaps'><p>Methods to calculate home-range overlaps</p></a></li>
<li><a href='#hr_to_sf'><p>Convert home ranges to <code>sfc</code></p></a></li>
<li><a href='#hr_ud'><p>Obtain the utilization distribution of a probabilistic home-range estimate</p></a></li>
<li><a href='#inspect'><p>Inspect a track</p></a></li>
<li><a href='#issf_w_form'><p>Create habitat formula from iSSF</p></a></li>
<li><a href='#log_rss'><p>Calculate log-RSS for a fitted model</p></a></li>
<li><a href='#make_issf_model'><p>Create an <code>issf</code>-model object from scratch</p></a></li>
<li><a href='#make_start'><p>Create an initial step for simulations</p></a></li>
<li><a href='#movement_metrics'><p>Movement metrics</p></a></li>
<li><a href='#nsd'><p>Net squared displacement (nsd)</p></a></li>
<li><a href='#od'><p>Occurrence Distribution</p></a></li>
<li><a href='#params'><p>Get parameters from a (fitted) distribution</p></a></li>
<li><a href='#plot_sl'><p>Plot step-length distribution</p></a></li>
<li><a href='#plot.hr'><p>Plot a home-range estimate</p></a></li>
<li><a href='#plot.log_rss'><p>Plot a <code>log_rss</code> object</p></a></li>
<li><a href='#plot.uhc_data'><p>Plot UHC plots</p></a></li>
<li><a href='#plot.uhc_envelopes'><p>Plot simplified UHC plots</p></a></li>
<li><a href='#prep_test_dat'><p>Prepares <code>test_dat</code> for <code>uhc_prep()</code></p></a></li>
<li><a href='#prep_uhc'><p>Prepare Data for UHC Plots for a Fitted Model</p></a></li>
<li><a href='#random_numbers'><p>Sample random numbers</p></a></li>
<li><a href='#random_points'><p>Generate random points</p></a></li>
<li><a href='#random_steps'><p>Generate Random Steps</p></a></li>
<li><a href='#random_steps_simple'><p>Simulate from an ssf model</p></a></li>
<li><a href='#range'><p>Geographic range</p></a></li>
<li><a href='#redistribution_kernel'><p>Create a redistribution kernel</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_capture'><p>Removes Capture Effects</p></a></li>
<li><a href='#remove_incomplete_strata'><p>Remove strata with missing values for observed steps</p></a></li>
<li><a href='#sampling_period'><p>Extract sampling period</p></a></li>
<li><a href='#sdr'><p>Calculate SDR for an Object</p></a></li>
<li><a href='#sh'><p>Relocations of one Red Deer</p></a></li>
<li><a href='#sh_forest'><p>Forest cover</p></a></li>
<li><a href='#simulate_path'><p>Simulate a movement trajectory.</p></a></li>
<li><a href='#site_fidelity'><p>Test for site fidelity of animal movement.</p></a></li>
<li><a href='#speed'><p>Speed</p></a></li>
<li><a href='#ssf_formula'><p>Takes a <code>clogit</code> formula and returns a formula without the <code>strata</code> and the</p>
left-hand side</a></li>
<li><a href='#ssf_weights'><p>Given a fitted ssf, and new location the weights for each location is</p>
calculated</a></li>
<li><a href='#steps'><p>Functions to create and work with steps</p></a></li>
<li><a href='#summarize_sampling_rate'><p>Returns a summary of sampling rates</p></a></li>
<li><a href='#summarize_sl'><p>Summarize step lengths</p></a></li>
<li><a href='#summarize_speed'><p>Summarize speed</p></a></li>
<li><a href='#time_of_day'><p>Time of the day when a fix was taken</p></a></li>
<li><a href='#track'><p>Create a <code style="white-space: pre;">&#8288;track_*&#8288;</code></p></a></li>
<li><a href='#track_resample'><p>Resample track</p></a></li>
<li><a href='#tracked_from_to'><p>Subset to tracking dates</p></a></li>
<li><a href='#transform_coords'><p>Transform CRS</p></a></li>
<li><a href='#trast'><p>Create a template raster layer</p></a></li>
<li><a href='#ua_distr'><p>Summarize distribution of used and available</p></a></li>
<li><a href='#uhc_hab'><p>Simulated habitat rasters for demonstrating UHC plots</p></a></li>
<li><a href='#uhc_hsf_locs'><p>Simulated HSF location data for demonstrating UHC plots</p></a></li>
<li><a href='#uhc_issf_locs'><p>Simulated iSSF location data for demonstrating UHC plots</p></a></li>
<li><a href='#update_distr_man'><p>Manually update <code>amt_distr</code></p></a></li>
<li><a href='#update_sl_distr'><p>Update movement distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Animal Movement Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Manage and analyze animal movement data. The functionality of
    'amt' includes methods to calculate home ranges, track statistics
    (e.g. step lengths, speed, or turning angles), prepare data for
    fitting habitat selection analyses, and simulation of space-use from
    fitted step-selection functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jmsigner/amt">https://github.com/jmsigner/amt</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, circular, ctmm, data.table, dplyr (&ge; 0.7.0),
fitdistrplus, FNN, graphics, grDevices, KernSmooth, lubridate,
MASS, methods, purrr, Rdpack, rlang, sf, sfheaders, stats,
survival, terra, tibble, tidyr (&ge; 1.0.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adehabitatLT, broom, ggplot2, ggraph, geosphere, knitr,
leaflet, move, moveHMM, rmarkdown, sessioninfo, suncalc, sp,
tidygraph, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 08:00:06 UTC; jsigner</td>
</tr>
<tr>
<td>Author:</td>
<td>Johannes Signer [aut, cre],
  Brian Smith [ctb],
  Bjoern Reineking [ctb],
  Ulrike Schlaegel [ctb],
  John Fieberg [ctb],
  Josh O'Brien [ctb],
  Bernardo Niebuhr [ctb],
  Alec Robitaille [ctb],
  Scott LaPoint [dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johannes Signer &lt;jsigner@gwdg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-28 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='amt_fisher'>GPS tracks from four fishers</h2><span id='topic+amt_fisher'></span>

<h3>Description</h3>

<p>This file includes spatial data from 4 fisher (<strong>Pekania pennanti</strong>). These location data were collected via a 105g GPS tracking collar (manufactured by E-obs GmbH) and programmed to record the animal's location every 10 minutes, continuously. The data re projected in NAD84 (epsg: 5070). The data usage is permitted for exploratory purposes. For other purposes please get in contact (Scott LaPoint).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amt_fisher
</code></pre>


<h3>Format</h3>

<p>A <code>tibble</code> with 14230 rows and 5 variables:
</p>

<dl>
<dt>x_</dt><dd><p>the x-coordinate</p>
</dd>
<dt>y_</dt><dd><p>the y-coordinate</p>
</dd>
<dt>t_</dt><dd><p>the timestamp</p>
</dd>
<dt>sex</dt><dd><p>the sex of the animal</p>
</dd>
<dt>id</dt><dd><p>the id of the animal</p>
</dd>
<dt>name</dt><dd><p>the name of the animal</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://www.datarepository.movebank.org/handle/10255/move.330
</p>


<h3>References</h3>

<p>For more information, contact Scott LaPoint <code>sdlapoint@gmail.com</code>
</p>

<hr>
<h2 id='amt_fisher_covar'>Environmental data for fishers</h2><span id='topic+amt_fisher_covar'></span>

<h3>Description</h3>

<p>A list with three entries that correspond to the following three layer: land
use, elevation and population density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amt_fisher_covar
</code></pre>


<h3>Format</h3>

<p>A list with three where each entry is a <code>SpatRast</code>.
</p>


<h3>Source</h3>

<p><code style="white-space: pre;">&#8288;https://lpdaac.usgs.gov/dataset_discovery/aster/aster_products_table&#8288;</code>
</p>
<p><code style="white-space: pre;">&#8288;http://dup.esrin.esa.it/page_globcover.php&#8288;</code>
</p>
<p><code style="white-space: pre;">&#8288;http://sedac.ciesin.columbia.edu/data/collection/gpw-v3/sets/browse&#8288;</code>
</p>

<hr>
<h2 id='append_x1'>Append &quot;_x1&quot;</h2><span id='topic+append_x1'></span>

<h3>Description</h3>

<p>Helper function to append <code style="white-space: pre;">&#8288;_x1&#8288;</code> to variable names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_x1(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_x1_+3A_string">string</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Variable name to possibly append to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks if &quot;_x1&quot; is already appended and adds it if
it is not. This is meant for internal use in <code style="white-space: pre;">&#8288;\link{plot.log_rss}()&#8288;</code>.
</p>


<h3>Value</h3>

<p>A string.
</p>

<hr>
<h2 id='as_sf_lines'>Export track to lines</h2><span id='topic+as_sf_lines'></span>

<h3>Description</h3>

<p>Exports a track to (multi)lines from the <code>sf</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf_lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sf_lines_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="as_sf_lines_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with a <code>sfc</code>-column
</p>

<hr>
<h2 id='as_sf_points'>Coerces a track to points</h2><span id='topic+as_sf_points'></span><span id='topic+as_sf_points.steps_xy'></span>

<h3>Description</h3>

<p>Coerces a track to points from the <code>sf</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf_points(x, ...)

## S3 method for class 'steps_xy'
as_sf_points(x, end = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_sf_points_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="as_sf_points_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="as_sf_points_+3A_end">end</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> For steps, should the end or start points be used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data <code>data.frame</code> with a <code>sfc</code>-column
</p>

<hr>
<h2 id='as_track'>Coerce to track</h2><span id='topic+as_track'></span><span id='topic+as_track.sfc_POINT'></span><span id='topic+as_track.steps_xyt'></span><span id='topic+as_track.data.frame'></span>

<h3>Description</h3>

<p>Coerce other classes to a <code>track_xy</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_track(x, ...)

## S3 method for class 'sfc_POINT'
as_track(x, ...)

## S3 method for class 'steps_xyt'
as_track(x, ...)

## S3 method for class 'data.frame'
as_track(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_track_+3A_x">x</code></td>
<td>
<p>Object to be converted to a track.</p>
</td></tr>
<tr><td><code id="as_track_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>track_xy(t)</code>
</p>

<hr>
<h2 id='as.data.frame.uhc_data'>Coerce a <code>uhc_data</code> object to <code>data.frame</code></h2><span id='topic+as.data.frame.uhc_data'></span>

<h3>Description</h3>

<p>Coerces <code>uhc_data</code> from <code>list</code> to <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uhc_data'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.uhc_data_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[uhc_data]&#8288;</code> An object of class <code>uhc_data</code>, as returned
by the function <code><a href="#topic+prep_uhc">prep_uhc</a>()</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.uhc_data_+3A_row.names">row.names</code></td>
<td>
<p>Included for consistency with generic
<code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>. Currently ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.uhc_data_+3A_optional">optional</code></td>
<td>
<p>Included for consistency with generic
<code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>. Currently ignored.</p>
</td></tr>
<tr><td><code id="as.data.frame.uhc_data_+3A_...">...</code></td>
<td>
<p>Included for consistency with generic
<code><a href="base.html#topic+as.data.frame">as.data.frame</a>()</code>. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This coercion aims to keep all of the information contained in
the <code>uhc_data</code> <code>list</code> in the resulting <code>data.frame</code> representation. Factors
are converted to numeric, but the levels are retained in the column
<code>"label"</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with columns:
</p>

<ul>
<li> <p><code>var</code>: The name of the variable
</p>
</li>
<li> <p><code>x</code>: The x-coordinate of the density plot (the value of <code>var</code>).
</p>
</li>
<li> <p><code>y</code>: The y-coordinate of the density plot (the probability density for
a numeric <code>var</code> and the proportion for a factor <code>var</code>).
</p>
</li>
<li> <p><code>dist</code>: The distribution represented. Either <code>"U"</code> for used, <code>"A"</code> for
available, or <code>"S"</code> for sampled.
</p>
</li>
<li> <p><code>iter</code>: The iteration number if <code>dist == "S"</code>.
</p>
</li>
<li> <p><code>label</code>: The label if <code>var</code> is a factor.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Brian J. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_uhc">prep_uhc</a>()</code>, <code><a href="#topic+conf_envelope">conf_envelope</a>()</code>
</p>

<hr>
<h2 id='available_distr'>Display available distributions for step lengths and turn angles.</h2><span id='topic+available_distr'></span>

<h3>Description</h3>

<p>Display available distributions for step lengths and turn angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_distr(which_dist = "all", names_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="available_distr_+3A_which_dist">which_dist</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[char(1)="all"]{"all", "ta", "sl"}&#8288;</code> <br /> Should <code>all</code>
distributions be returned, or only distributions for turn angles (<code>ta</code>) or
step lengths (<code>sl</code>).</p>
</td></tr>
<tr><td><code id="available_distr_+3A_names_only">names_only</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> Indicates if only the names of
distributions should be returned.</p>
</td></tr>
<tr><td><code id="available_distr_+3A_...">...</code></td>
<td>
<p>none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with the purpose of the distribution (turn angles [ta] or step length [sl]) and the distribution name.
</p>

<hr>
<h2 id='bandwidth_pi'><code>hr_kde_pi</code> wraps <code>KernSmooth::dpik</code> to select bandwidth for kernel density estimation the plug-in-the-equation method in two dimensions.</h2><span id='topic+bandwidth_pi'></span><span id='topic+hr_kde_pi'></span><span id='topic+hr_kde_pi.track_xy'></span>

<h3>Description</h3>

<p>This function calculates bandwidths for kernel density estimation by wrapping <code>KernSmooth::dpik</code>. If <code>correct = TURE</code>, the bandwidth is trasformed with power 5/6 to correct for using an univariate implementation for bivariate data (Gitzen et. al 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_kde_pi(x, ...)

## S3 method for class 'track_xy'
hr_kde_pi(x, rescale = "none", correct = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth_pi_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="bandwidth_pi_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="bandwidth_pi_+3A_rescale">rescale</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code> <br /> Rescaling method for reference bandwidth calculation. Must be one of &quot;unitvar&quot;, &quot;xvar&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="bandwidth_pi_+3A_correct">correct</code></td>
<td>
<p>Logical scalar that indicates whether or not the estimate should be correct for the two dimensional case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bandwidth, the standardization method and correction.
</p>


<h3>References</h3>

<p>Gitzen, R. A., Millspaugh, J. J., &amp; Kernohan, B. J. (2006). Bandwidth selection for fixed-kernel analysis of animal utilization distributions. <em>Journal of Wildlife Management</em>, 70(5), 1334-1344.
</p>


<h3>See Also</h3>

<p><code>KernSmooth::dpik</code>
</p>

<hr>
<h2 id='bandwidth_ref'>Reference bandwidth</h2><span id='topic+bandwidth_ref'></span><span id='topic+hr_kde_ref'></span><span id='topic+hr_kde_ref.track_xy'></span>

<h3>Description</h3>

<p>Calculate the reference bandwidth for kernel density home-range range estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_kde_ref(x, ...)

## S3 method for class 'track_xy'
hr_kde_ref(x, rescale = "none", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandwidth_ref_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="bandwidth_ref_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="bandwidth_ref_+3A_rescale">rescale</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code> <br /> Rescaling method for reference bandwidth calculation. Must be one of &quot;unitvar&quot;, &quot;xvar&quot;, or &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated bandwidth in x and y direction.
</p>

<hr>
<h2 id='bbox'>Get bounding box of a track.</h2><span id='topic+bbox'></span><span id='topic+bbox.track_xy'></span><span id='topic+bbox.steps_xy'></span>

<h3>Description</h3>

<p>Get bounding box of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox(x, ...)

## S3 method for class 'track_xy'
bbox(x, spatial = TRUE, buffer = NULL, ...)

## S3 method for class 'steps_xy'
bbox(x, spatial = TRUE, buffer = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="bbox_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="bbox_+3A_spatial">spatial</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> Whether or not to return an object of class <code>sf-Polygon</code>-object or not.</p>
</td></tr>
<tr><td><code id="bbox_+3A_buffer">buffer</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(0)=NULL]{NULL, &gt;0}&#8288;</code> <br /> An optional buffer of the bounding box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>spatial = FALSE</code> a named vector of length four with the extent of the bounding box. Otherwise a <code>SpatialPolygon</code> or a simple freature polygon with the bounding box.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
bbox(deer)
bbox(deer, spatial = FALSE)
bbox(deer, buffer = 100, spatial = FALSE)

# For steps
deer |&gt; steps_by_burst() |&gt; bbox(spatial = FALSE)
deer |&gt; steps_by_burst() |&gt; bbox(buffer = 100, spatial = FALSE)
deer |&gt; steps_by_burst() |&gt; random_steps() |&gt; bbox(spatial = FALSE)

# Further manipulations are possible
deer |&gt; bbox() |&gt; sf::st_transform(4326)
</code></pre>

<hr>
<h2 id='boot1.glm'>Single bootstrap iteration</h2><span id='topic+boot1.glm'></span><span id='topic+boot1.fit_clogit'></span>

<h3>Description</h3>

<p>Runs a single iteration of the empirical bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot1.glm(object, x1, x2)

boot1.fit_clogit(object, x1, x2)
</code></pre>


<h3>Details</h3>

<p>This function is meant for internal use by <code>bootstrap_logrss()</code> and
is not meant to be called by the user.
</p>

<hr>
<h2 id='bootstrap_logrss'>Bootstrap log-RSS estimate</h2><span id='topic+bootstrap_logrss'></span><span id='topic+bootstrap_logrss.glm'></span><span id='topic+bootstrap_logrss.fit_clogit'></span>

<h3>Description</h3>

<p>Use empirical bootstrap to estimate log-RSS CI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap_logrss(object, ...)

## S3 method for class 'glm'
bootstrap_logrss(object, x1, x2, ci_level, n_boot, mle)

## S3 method for class 'fit_clogit'
bootstrap_logrss(object, x1, x2, ci_level, n_boot, mle)
</code></pre>


<h3>Details</h3>

<p>This function is meant for internal use by <code>log_rss()</code> and is
not meant to be called by the user.
</p>

<hr>
<h2 id='calc_w'>Calculate <code>w(x)</code></h2><span id='topic+calc_w'></span>

<h3>Description</h3>

<p>Calculates the value of the exponential habitat selection function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_w(f, b, newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_w_+3A_f">f</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[formula]&#8288;</code> <br /> A model formula.</p>
</td></tr>
<tr><td><code id="calc_w_+3A_b">b</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> A named vector of coefficients.</p>
</td></tr>
<tr><td><code id="calc_w_+3A_newdata">newdata</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A <code>data.frame</code> to predict eHSF values.</p>
</td></tr>
</table>

<hr>
<h2 id='calculate_sdr'>Calculate SDR</h2><span id='topic+calculate_sdr'></span>

<h3>Description</h3>

<p>Calculates squared displacement rate for a given speed and duration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_sdr(speed = 50, time, speed_unit = c("km/h", "m/s"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_sdr_+3A_speed">speed</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> A speed given in either km/h or m/s.</p>
</td></tr>
<tr><td><code id="calculate_sdr_+3A_time">time</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Period]&#8288;</code> A <code>lubridate</code> <code>Period</code> for which the <code>speed</code>
can be sustained.</p>
</td></tr>
<tr><td><code id="calculate_sdr_+3A_speed_unit">speed_unit</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> The unit in which <code>speed</code> is given. Should
be either <code>"km/h"</code> or <code>"m/s"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector (of length 1) with the SDR in <code>m^2/s</code>.
</p>


<h3>Author(s)</h3>

<p>Johannes Signer and Brian J. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_displacement">get_displacement</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Assume a cheetah can sprint 100 km/h for 60 seconds
calculate_sdr(speed = 100, time = seconds(60), speed_unit = "km/h")
# 46296.3 m^2/s

# What is expected displacement in 1 h at that SDR?
get_displacement(46296.3, hours(1))
# 12909.95 m = 12.9 km/h (much slower than sprint speed!)

</code></pre>

<hr>
<h2 id='centroid'>Calculate the centroid of a track.</h2><span id='topic+centroid'></span><span id='topic+centroid.track_xy'></span>

<h3>Description</h3>

<p>Calculate the centroid of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(x, ...)

## S3 method for class 'track_xy'
centroid(x, spatial = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="centroid_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="centroid_+3A_spatial">spatial</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> Whether or not to return a <code>SpatialPoints</code>-object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centroid of a track as numeric vector if <code>spatial = FALSE</code>, otherwise as <code>SpatialPoints</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
centroid(deer)
</code></pre>

<hr>
<h2 id='check_factors'>Check factor levels</h2><span id='topic+check_factors'></span>

<h3>Description</h3>

<p>Check factor levels before log-RSS calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_factors(model, x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_factors_+3A_x1">x1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A <code>data.frame</code> representing the habitat values
at location x_1. Must contain all fitted covariates as expected by
<code>predict()</code>.</p>
</td></tr>
<tr><td><code id="check_factors_+3A_x2">x2</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A 1-row <code>data.frame</code> representing the single
hypothetical location of x_2. Must contain all fitted covariates as expected
by <code>predict()</code>.</p>
</td></tr>
<tr><td><code id="check_factors_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[glm, clogit]&#8288;</code> <br /> The model object from a fitted RSF/(i)SSF.
<em>I.e.</em>, it will be <code>object$model</code> when called within <code>log_rss()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant for internal use by <code>log_rss()</code> and is
not meant to be called by the user.
</p>

<hr>
<h2 id='check_time_unit'>Calculate Speed</h2><span id='topic+check_time_unit'></span>

<h3>Description</h3>

<p>Calculates speed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_time_unit(tu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_time_unit_+3A_tu">tu</code></td>
<td>
<p>The <code>time_unit</code> parameter to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Change in NSD
</p>
<p>Calculates change in NSD
</p>
<p>Check <code>time_unit</code> Parameter
</p>
<p>Internal function to check <code>time_unit</code> parameter in various cleaning functions.
</p>

<hr>
<h2 id='coercion'>Coerce a track to other formats.</h2><span id='topic+coercion'></span><span id='topic+as_sf'></span><span id='topic+as_sf.steps_xy'></span><span id='topic+as_sp'></span><span id='topic+as_move'></span><span id='topic+as_move.track_xyt'></span><span id='topic+as_ltraj'></span><span id='topic+as_ltraj.track_xy'></span><span id='topic+as_ltraj.track_xyt'></span><span id='topic+as_telemetry'></span><span id='topic+as_telemetry.track_xyt'></span><span id='topic+as_moveHMM'></span><span id='topic+as_moveHMM.track_xy'></span>

<h3>Description</h3>

<p>Several other packages provides methods to analyze movement data, and <code>amt</code> provides coercion methods to some packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sf(x, ...)

## S3 method for class 'steps_xy'
as_sf(x, end = TRUE, ...)

as_sp(x, ...)

as_move(x, ...)

## S3 method for class 'track_xyt'
as_move(x, id = "id", ...)

as_ltraj(x, ...)

## S3 method for class 'track_xy'
as_ltraj(x, id = "animal_1", ...)

## S3 method for class 'track_xyt'
as_ltraj(x, ...)

as_telemetry(x, ...)

## S3 method for class 'track_xyt'
as_telemetry(x, ...)

as_moveHMM(x, ...)

## S3 method for class 'track_xy'
as_moveHMM(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coercion_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="coercion_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="coercion_+3A_end">end</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> For steps, should the end or start points be used?</p>
</td></tr>
<tr><td><code id="coercion_+3A_id">id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric,character,factor]&#8288;</code> <br /> Animal id(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class to which coercion is performed to.
</p>

<hr>
<h2 id='conf_envelope'>Create confidence envelopes from a <code>uhc_data_frame</code></h2><span id='topic+conf_envelope'></span>

<h3>Description</h3>

<p>Simplifies sampled distributions in a <code>uhc_data_frame</code> to confidence envelopes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conf_envelope(x, levels = c(0.95, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conf_envelope_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[uhc_data]&#8288;</code> An object of class <code>uhc_data_frame</code>, as returned
by the function <code><a href="#topic+as.data.frame.uhc_data">as.data.frame.uhc_data</a>()</code>.</p>
</td></tr>
<tr><td><code id="conf_envelope_+3A_levels">levels</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> A numeric vector specifying the desired confidence
levels. Defaults to <code>c(0.95, 1)</code> to create 95% and 100% confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can dramatically improve plotting time for UHC plots by
simplifying the many sampled lines down to the boundaries of a polygon.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with columns:
</p>

<ul>
<li> <p><code>var</code>: The name of the variable
</p>
</li>
<li> <p><code>x</code>: The x-coordinate of the density plot (the value of <code>var</code>).
</p>
</li>
<li> <p><code>label</code>: If <code>var</code> is a <code>factor</code>, the label for the value given by <code>x</code>.
</p>
</li>
<li> <p><code>U</code>: The y-coordinate of the density plot for the use distribution.
</p>
</li>
<li> <p><code>A</code>: The y-coordinate of the density plot for the availability distribution.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;CI*_lwr&#8288;</code>: The lower bound of the confidence envelope for the corresponding
confidence level.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;CI*_upr&#8288;</code>: The upper bound of the confidence envelope for the corresponding
confidence level.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Brian J. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_uhc">prep_uhc</a>()</code>, <code><a href="#topic+plot.uhc_envelopes">plot.uhc_envelopes</a>()</code>
</p>

<hr>
<h2 id='convert_angles'>Converts angles to radians</h2><span id='topic+convert_angles'></span><span id='topic+as_rad'></span><span id='topic+as_degree'></span>

<h3>Description</h3>

<p>Converts angles to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rad(x)

as_degree(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_angles_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br /> Angles in degrees or rad.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the converted angles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_rad(seq(-180, 180, 30))

# The default unit of turning angles is rad.
data(deer)
deer |&gt; steps() |&gt; mutate(ta_ = as_degree(ta_))
</code></pre>

<hr>
<h2 id='coords'>Coordinates of a track.</h2><span id='topic+coords'></span>

<h3>Description</h3>

<p>Coordinates of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="coords_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[tibble]&#8288;</code> <br /> The coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
coords(deer)
</code></pre>

<hr>
<h2 id='cum_ud'>Calculate a cumulative UD</h2><span id='topic+cum_ud'></span><span id='topic+hr_cud'></span><span id='topic+hr_cud.SpatRaster'></span>

<h3>Description</h3>

<p>Calculate the cumulative utilization distribution (UD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_cud(x, ...)

## S3 method for class 'SpatRaster'
hr_cud(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cum_ud_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[RasterLayer]&#8288;</code> <br /> Containing the Utilization Distribution (UD).</p>
</td></tr>
<tr><td><code id="cum_ud_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[RasterLayer]&#8288;</code> <br /> The cumulative UD.
</p>


<h3>Note</h3>

<p>This function is typically used to obtain isopleths.
</p>

<hr>
<h2 id='deer'>Relocations of 1 red deer</h2><span id='topic+deer'></span>

<h3>Description</h3>

<p>826 GPS relocations of one red deer from northern Germany. The data is
already resampled to a regular time interval of 6 hours and the coordinate
reference system is transformed to <code>epsg:3035</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deer
</code></pre>


<h3>Format</h3>

<p>A track_xyt </p>
 <dl>
<dt>x_</dt><dd><p>the x-coordinate</p>
</dd> <dt>y_</dt><dd><p>the
y-coordinate</p>
</dd> <dt>t_</dt><dd><p>the timestamp</p>
</dd> <dt>burst_</dt><dd><p>the burst a particular
points belongs to.</p>
</dd> </dl>



<h3>Source</h3>

<p>Verein für Wildtierforschung Dresden und Göttingen e.V.
</p>

<hr>
<h2 id='diff'>Difference in x and y</h2><span id='topic+diff'></span><span id='topic+diff_x'></span><span id='topic+diff_y'></span>

<h3>Description</h3>

<p>Difference in x and y coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_x(x, ...)

diff_y(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_+3A_x">x</code></td>
<td>
<p>A track_xyt.</p>
</td></tr>
<tr><td><code id="diff_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector
</p>

<hr>
<h2 id='distr_name'>Name of step-length distribution and turn-angle distribution</h2><span id='topic+distr_name'></span><span id='topic+sl_distr_name'></span><span id='topic+sl_distr_name.random_steps'></span><span id='topic+sl_distr_name.fit_clogit'></span><span id='topic+ta_distr_name'></span><span id='topic+ta_distr_name.random_steps'></span><span id='topic+ta_distr_name.fit_clogit'></span>

<h3>Description</h3>

<p>Name of step-length distribution and turn-angle distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sl_distr_name(x, ...)

## S3 method for class 'random_steps'
sl_distr_name(x, ...)

## S3 method for class 'fit_clogit'
sl_distr_name(x, ...)

ta_distr_name(x, ...)

ta_distr_name(x, ...)

## S3 method for class 'random_steps'
ta_distr_name(x, ...)

## S3 method for class 'fit_clogit'
ta_distr_name(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distr_name_+3A_x">x</code></td>
<td>
<p>Random steps or fitted model</p>
</td></tr>
<tr><td><code id="distr_name_+3A_...">...</code></td>
<td>
<p>None implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of length 1.
</p>

<hr>
<h2 id='distributions'>Functions create statistical distributions</h2><span id='topic+distributions'></span><span id='topic+make_distribution'></span><span id='topic+make_exp_distr'></span><span id='topic+make_hnorm_distr'></span><span id='topic+make_lnorm_distr'></span><span id='topic+make_unif_distr'></span><span id='topic+make_vonmises_distr'></span><span id='topic+make_gamma_distr'></span>

<h3>Description</h3>

<p><code>make_distributions</code> creates a distribution suitable for using it with integrated step selection functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_distribution(name, params, vcov = NULL, ...)

make_exp_distr(rate = 1)

make_hnorm_distr(sd = 1)

make_lnorm_distr(meanlog = 0, sdlog = 1)

make_unif_distr(min = -pi, max = pi)

make_vonmises_distr(kappa = 1, vcov = NULL)

make_gamma_distr(shape = 1, scale = 1, vcov = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distributions_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[char(1)]&#8288;</code> <br /> Short name of distribution. See <code>available_distr()</code>
for all currently implemented distributions.</p>
</td></tr>
<tr><td><code id="distributions_+3A_params">params</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code> <br /> A named list with parameters of the distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_vcov">vcov</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[matrix]&#8288;</code> <br /> A matrix with variance and covariances.</p>
</td></tr>
<tr><td><code id="distributions_+3A_...">...</code></td>
<td>
<p>none implemented.</p>
</td></tr>
<tr><td><code id="distributions_+3A_rate">rate</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)&gt;0]&#8288;</code> <br /> The rate of the exponential distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_sd">sd</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)&gt;0]&#8288;</code> <br /> The standard deviation of the half-normal distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_meanlog">meanlog</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)&gt;0]&#8288;</code> <br /> The standard deviation of the half-normal distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_sdlog">sdlog</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)&gt;0]&#8288;</code> <br /> The standard deviation of the half-normal distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_min">min</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code> <br /> The minimum of the uniform distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_max">max</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code> <br /> The minimum of the uniform distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_kappa">kappa</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)&gt;=0]&#8288;</code> <br /> Concentration parameter of the von Mises distribution.</p>
</td></tr>
<tr><td><code id="distributions_+3A_shape">shape</code>, <code id="distributions_+3A_scale">scale</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)&gt;=0]&#8288;</code> <br /> Shape and scale of the Gamma distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>amt_distr</code> that contains the name (<code>name</code>) and parameters (<code>params</code>) of a distribution.
</p>

<hr>
<h2 id='extent'>Extent of a track</h2><span id='topic+extent'></span><span id='topic+extent_x'></span><span id='topic+extent_y'></span><span id='topic+extent_both'></span><span id='topic+extent_max'></span>

<h3>Description</h3>

<p>Obtain the extent of a track in <code>x</code> <code>y</code> or both directions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extent_x(x, ...)

extent_y(x, ...)

extent_both(x, ...)

extent_max(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extent_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt, steps]</code> <br /> Either a track created with <code>mk_track</code> or <code>track</code>, or <code>steps</code>.</p>
</td></tr>
<tr><td><code id="extent_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the extent.
</p>

<hr>
<h2 id='extract_covariates'>Extract covariate values</h2><span id='topic+extract_covariates'></span><span id='topic+extract_covariates.track_xy'></span><span id='topic+extract_covariates.random_points'></span><span id='topic+extract_covariates.steps_xy'></span><span id='topic+extract_covariates_along'></span><span id='topic+extract_covariates_along.steps_xy'></span><span id='topic+extract_covariates_var_time'></span><span id='topic+extract_covariates_var_time.track_xyt'></span><span id='topic+extract_covariates_var_time.steps_xyt'></span>

<h3>Description</h3>

<p>Extract the covariate values at relocations, or at the beginning or end of
steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_covariates(x, ...)

## S3 method for class 'track_xy'
extract_covariates(x, covariates, ...)

## S3 method for class 'random_points'
extract_covariates(x, covariates, ...)

## S3 method for class 'steps_xy'
extract_covariates(x, covariates, where = "end", ...)

extract_covariates_along(x, ...)

## S3 method for class 'steps_xy'
extract_covariates_along(x, covariates, ...)

extract_covariates_var_time(x, ...)

## S3 method for class 'track_xyt'
extract_covariates_var_time(
  x,
  covariates,
  when = "any",
  max_time,
  name_covar = "time_var_covar",
  ...
)

## S3 method for class 'steps_xyt'
extract_covariates_var_time(
  x,
  covariates,
  when = "any",
  max_time,
  name_covar = "time_var_covar",
  where = "end",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_covariates_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt, steps]</code> <br /> Either a track created with <code>mk_track</code> or <code>track</code>, or <code>steps</code>.</p>
</td></tr>
<tr><td><code id="extract_covariates_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>terra::extract()</code>.</p>
</td></tr>
<tr><td><code id="extract_covariates_+3A_covariates">covariates</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[SpatRaster]&#8288;</code> <br /> The
(environmental) covariates. For <code>extract_covariates_var_time</code> the argument
<code>covariates</code> need to have a <code>z</code>-column (i.e. the time stamp).</p>
</td></tr>
<tr><td><code id="extract_covariates_+3A_where">where</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)="end"]{"start", "end", "both"}&#8288;</code> <br /> For <code>steps</code>
this determines if the covariate values should be extracted at the
beginning or the end of a step. or <code>end</code>.</p>
</td></tr>
<tr><td><code id="extract_covariates_+3A_when">when</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)="any"]{"any", "before", "after"}&#8288;</code> <br /> Specifies for
for <code>extract_covariates_var_time</code> whether to look before, after or in both
direction (<code>any</code>) for the temporally closest environmental raster.</p>
</td></tr>
<tr><td><code id="extract_covariates_+3A_max_time">max_time</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Period(1)]&#8288;</code> <br /> The maximum time difference between a relocation
and the corresponding raster. If no rasters are within the specified max.
distance <code>NA</code> is returned.</p>
</td></tr>
<tr><td><code id="extract_covariates_+3A_name_covar">name_covar</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)="time_var_covar"]&#8288;</code> <br /> The name of the new column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extract_covariates_along</code> extracts the covariates along a straight line between the start and the end point of a (random) step. It returns a list, which in most cases will have to be processed further.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with additional columns for covariate values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
sh_forest &lt;- get_sh_forest()
mini_deer &lt;- deer[1:20, ]
mini_deer |&gt; extract_covariates(sh_forest)
mini_deer |&gt; steps() |&gt; extract_covariates(sh_forest)
mini_deer |&gt; steps() |&gt; extract_covariates(sh_forest, where = "start")


# Illustration of extracting covariates along the a step
mini_deer |&gt; steps() |&gt; random_steps() |&gt;
  extract_covariates(sh_forest) |&gt; # extract at the endpoint
  (\(.) mutate(., for_path = extract_covariates_along(., sh_forest)))()  |&gt;
  # 1 = forest, lets calc the fraction of forest along the path
  mutate(for_per = purrr::map_dbl(for_path, function(x) mean(x == 1)))

</code></pre>

<hr>
<h2 id='Extract.uhc_data'>Subset a <code>uhc_data</code> object</h2><span id='topic+Extract.uhc_data'></span><span id='topic++5B.uhc_data'></span>

<h3>Description</h3>

<p>Subset a <code>uhc_data</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uhc_data'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.uhc_data_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[uhc_data]&#8288;</code> A <code>uhc_data</code> object to subset.</p>
</td></tr>
<tr><td><code id="Extract.uhc_data_+3A_i">i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric&#8288;</code> or <code style="white-space: pre;">&#8288;character]&#8288;</code> A numeric vector to subset variables
by position or a character vector to subset variables by name.</p>
</td></tr>
</table>

<hr>
<h2 id='filter_min_n_burst'>Filter bursts by number of relocations</h2><span id='topic+filter_min_n_burst'></span><span id='topic+filter_min_n_burst.track_xy'></span>

<h3>Description</h3>

<p>Only retain bursts with a minimum number (= <code>min_n</code>) of relocations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_min_n_burst(x, ...)

## S3 method for class 'track_xy'
filter_min_n_burst(x, min_n = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_min_n_burst_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="filter_min_n_burst_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="filter_min_n_burst_+3A_min_n">min_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)=3]&#8288;</code> <br /> Indicating the minimum number of relocations (=fixes per burst).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> of class <code>track_xy(t)</code>.
</p>

<hr>
<h2 id='fit_clogit'>Fit a conditional logistic regression</h2><span id='topic+fit_clogit'></span><span id='topic+fit_ssf'></span><span id='topic+fit_issf'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>survival::clogit</code>, making it usable in a piped workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_clogit(data, formula, more = NULL, summary_only = FALSE, ...)

fit_ssf(data, formula, more = NULL, summary_only = FALSE, ...)

fit_issf(data, formula, more = NULL, summary_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_clogit_+3A_data">data</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> The data used to fit a model.</p>
</td></tr>
<tr><td><code id="fit_clogit_+3A_formula">formula</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[formula]&#8288;</code> <br /> The model formula.</p>
</td></tr>
<tr><td><code id="fit_clogit_+3A_more">more</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code> <br /> Optional list that is passed on the output.</p>
</td></tr>
<tr><td><code id="fit_clogit_+3A_summary_only">summary_only</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> If <code>TRUE</code> only a <code>broom::tidy</code> summary of the model is returned.</p>
</td></tr>
<tr><td><code id="fit_clogit_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code>survival::clogit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following entries
</p>

<ul>
<li><p> model: The model output.
</p>
</li>
<li><p> sl_: The step length distribution.
</p>
</li>
<li><p> ta_: The turn angle distribution.
</p>
</li></ul>


<hr>
<h2 id='fit_ctmm'>Fit a continuous time movement model with <code>ctmm</code></h2><span id='topic+fit_ctmm'></span>

<h3>Description</h3>

<p>Fit a continuous time movement model with <code>ctmm</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ctmm(x, model, uere = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_ctmm_+3A_x">x</code></td>
<td>
<p><code>[track_xyt]</code> <br /> A track created with <code>make_track</code> that includes time.</p>
</td></tr>
<tr><td><code id="fit_ctmm_+3A_model">model</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)="bm"]{"iid", "bm","ou","ouf", "auto"}&#8288;</code> <br /> The autocorrelation model that should be fit to the data. <code>iid</code> corresponds to uncorrelated independent data, <code>bm</code> to Brownian motion, <code>ou</code> to an Ornstein-Uhlenbeck process, <code>ouf</code> to an Ornstein-Uhlenbeck forage process. <code>auto</code> will use model selection with AICc to find the best model.</p>
</td></tr>
<tr><td><code id="fit_ctmm_+3A_uere">uere</code></td>
<td>
<p>User Equivalent Range Error, see <code>?ctmm::uere</code> for more details.</p>
</td></tr>
<tr><td><code id="fit_ctmm_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>ctmm::ctmm.fit</code> or <code>ctmm::ctmm.select</code> for <code>model = "auto"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ctmm</code> from the package ctmm.
</p>


<h3>References</h3>

<p>C. H. Fleming, J. M. Calabrese, T. Mueller, K.A. Olson, P. Leimgruber, W. F. Fagan, “From fine-scale foraging to home ranges: A semi-variance approach to identifying movement modes across spatiotemporal scales”, The American Naturalist, 183:5, E154-E167 (2014).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(deer)
mini_deer &lt;- deer[1:20, ]
m1 &lt;- fit_ctmm(mini_deer, "iid")
summary(m1)

</code></pre>

<hr>
<h2 id='fit_distr'>Fit distribution to data</h2><span id='topic+fit_distr'></span>

<h3>Description</h3>

<p>Wrapper to fit a distribution to data. Currently implemented distributions
are the exponential distribution (<code>exp</code>), the gamma distribution (<code>gamma</code>)
and the von Mises distribution (<code>vonmises</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_distr(x, dist_name, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_distr_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(&gt;1)]&#8288;</code> <br /> The observed data.</p>
</td></tr>
<tr><td><code id="fit_distr_+3A_dist_name">dist_name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]{"exp", "gamma", "unif", "vonmises"}&#8288;</code> <br /> The name of the
distribution.</p>
</td></tr>
<tr><td><code id="fit_distr_+3A_na.rm">na.rm</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> Indicating whether <code>NA</code> should be
removed before fitting the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>amt_distr</code> object, which consists of a list with the <code>name</code> of
the distribution and its parameters (saved in <code>params</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
dat &lt;- rexp(1e3, 2)
fit_distr(dat, "exp")
</code></pre>

<hr>
<h2 id='fit_logit'>Fit logistic regression</h2><span id='topic+fit_logit'></span><span id='topic+fit_rsf'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>stats::glm</code> for a piped workflows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_logit(data, formula, ...)

fit_rsf(data, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_logit_+3A_data">data</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> The data used to fit a model.</p>
</td></tr>
<tr><td><code id="fit_logit_+3A_formula">formula</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[formula]&#8288;</code> <br /> The model formula.</p>
</td></tr>
<tr><td><code id="fit_logit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>stats::glm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the model output.
</p>

<hr>
<h2 id='flag_defunct_clusters'>Flag Defunct Clusters</h2><span id='topic+flag_defunct_clusters'></span><span id='topic+flag_defunct_clusters.track_xyt'></span>

<h3>Description</h3>

<p>Flags defunct clusters at the end of a track
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_defunct_clusters(x, zeta, eta, theta, ...)

## S3 method for class 'track_xyt'
flag_defunct_clusters(x, zeta, eta, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_defunct_clusters_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> A <code>track_xyt</code> object.</p>
</td></tr>
<tr><td><code id="flag_defunct_clusters_+3A_zeta">zeta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> See details.</p>
</td></tr>
<tr><td><code id="flag_defunct_clusters_+3A_eta">eta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> See details.</p>
</td></tr>
<tr><td><code id="flag_defunct_clusters_+3A_theta">theta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> See details.</p>
</td></tr>
<tr><td><code id="flag_defunct_clusters_+3A_...">...</code></td>
<td>
<p>Addtional arguments. None currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locations at the end of a trajectory may represent a dropped collar
or an animal mortality. In some cases, the device may be recording locations
for quite some time that are not biologically meaningful. This function
aims to flag those locations at the end of the trajectory that belong to a
mortality (or similar) cluster. The first location at the cluster remains
unflagged, but all subsequent locations are flagged.
</p>
<p>The algorithm detects steps that represent zero movement, within a precision
threshold given by <code>zeta</code>. That is, if <code>zeta = 5</code> (units determined by CRS;
typically meters), all points that differ by less than 5 will be considered
zero movement. Consecutive steps of zero movement (within the tolerance) form
a cluster. The parameter <code>eta</code> gives the cutoff for the minimum number of
zero steps to be considered a cluster. Finally, the algorithm requires that
clusters persist without a non-zero step for a minimum amount of time, given
by <code>theta</code>.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> (a <code>track_xyt</code>) with a flagging column added
(<code>x$defunct_cluster_</code>).
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith and Johannes Signer, based on code by Tal Avgar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag_duplicates">flag_duplicates</a>()</code>,
<code><a href="#topic+flag_fast_steps">flag_fast_steps</a>()</code>,
<code><a href="#topic+flag_roundtrips">flag_roundtrips</a>()</code>
</p>

<hr>
<h2 id='flag_duplicates'>Flag Low Quality Duplicates</h2><span id='topic+flag_duplicates'></span><span id='topic+flag_duplicates.track_xyt'></span>

<h3>Description</h3>

<p>Flags locations with duplicate timestamps by DOP and distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_duplicates(x, gamma, time_unit = "mins", DOP = "dop", ...)

## S3 method for class 'track_xyt'
flag_duplicates(x, gamma, time_unit = "mins", DOP = "dop", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_duplicates_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> A <code>track_xyt</code> object.</p>
</td></tr>
<tr><td><code id="flag_duplicates_+3A_gamma">gamma</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric or Period]&#8288;</code> The temporal tolerance defining duplicates.
See details below. If <code>numeric</code>, its units are defined by <code>time_unit</code>. If
<code>Period</code>, <code>time_unit</code> is ignored.</p>
</td></tr>
<tr><td><code id="flag_duplicates_+3A_time_unit">time_unit</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Character string giving time unit for <code>gamma</code>.
Should be <code>"secs"</code>, <code>"mins"</code>, or <code>"hours"</code>. Ignored if <code style="white-space: pre;">&#8288;class(gamma) == "Period".&#8288;</code></p>
</td></tr>
<tr><td><code id="flag_duplicates_+3A_dop">DOP</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> A character string giving the name of the column
containing the dilution of precision (DOP) data. See details below.</p>
</td></tr>
<tr><td><code id="flag_duplicates_+3A_...">...</code></td>
<td>
<p>Addtional arguments. None currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locations are considered duplicates if their timestamps are within
<code>gamma</code> of each other. However, the function runs sequentially through the
track object, so that only timestamps after the focal point are flagged as
duplicates (and thus removed from further consideration). E.g., if
<code>gamma = minutes(5)</code>, then all locations with timestamp within 5 minutes
after the focal location will be considered duplicates.
</p>
<p>When duplicates are found, (1) the location with the lowest dilution of precision
(given by <code>DOP</code> column) is kept. If there are multiple duplicates with equally
low DOP, then (2) the one closest in space to previous location is kept. In
the event of exact ties in DOP and distance, (3) the first location is kept.
This is unlikely unless there are exact coordinate duplicates.
</p>
<p>In the case that the first location in a trajectory has a duplicate, there
is no previous location with which to calculate a distance. In that case,
the algorithm skips to (3) and keeps the first location.
</p>
<p>In the event your <code>data.frame</code> does not have a DOP column, you can insert a dummy
with constant values such that all duplicates will tie, and distance will be
the only criterion (e.g., <code>x$dop &lt;- 1</code>). In the event you do have an alternate
measure of precision where larger numbers are more precise (e.g., number of
satellites), simply multiply that metric by <code>-1</code> and pass it as if it were DOP.
</p>
<p>Internally, the function drops duplicates as it works sequentially through the
<code>data.frame</code>. E.g., if location 5 was considered a duplicate of location 4 &ndash;
and location 4 was higher quality &ndash; then location 5 would be dropped. The
function would then move on to location 6 (since 5 was already dropped).
However, the object returned to the user has all the original rows of <code>x</code> &ndash;
i.e., locations are flagged rather than removed.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> (a <code>track_xyt</code>) with a flagging column added (<code>x$duplicate_</code>).
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith, based on code by Johannes Signer and Tal Avgar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag_fast_steps">flag_fast_steps</a>()</code>,
<code><a href="#topic+flag_roundtrips">flag_roundtrips</a>()</code>,
<code><a href="#topic+flag_defunct_clusters">flag_defunct_clusters</a>()</code>
</p>

<hr>
<h2 id='flag_fast_steps'>Flag Fast Steps</h2><span id='topic+flag_fast_steps'></span><span id='topic+flag_fast_steps.track_xyt'></span>

<h3>Description</h3>

<p>Flags locations that imply SDR exceeding a threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_fast_steps(x, delta, time_unit = "secs", ...)

## S3 method for class 'track_xyt'
flag_fast_steps(x, delta, time_unit = "secs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_fast_steps_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> A <code>track_xyt</code> object.</p>
</td></tr>
<tr><td><code id="flag_fast_steps_+3A_delta">delta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The threshold SDR over which steps are flagged.
See details.</p>
</td></tr>
<tr><td><code id="flag_fast_steps_+3A_time_unit">time_unit</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Character string giving time unit. Should be
<code>"secs"</code>, <code>"mins"</code>, or <code>"hours"</code>. See details.</p>
</td></tr>
<tr><td><code id="flag_fast_steps_+3A_...">...</code></td>
<td>
<p>Addtional arguments. None currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locations are flagged if the SDR from the previous location to the
current location exceeds <code>delta</code>. Internally, flagged locations are dropped
from future consideration.
</p>
<p>The <code>time_unit</code> should be the same time unit with which the SDR threshold
was calculated. SDR is typically calculated in <code>m^2/s</code>, so <code>time_unit</code> defaults
to <code>"secs"</code>. The spatial unit is determined by the CRS, which should typically
be in meters.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> (a <code>track_xyt</code>) with a flagging column added
(<code>x$fast_step_</code>).
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith, based on code by Johannes Signer and Tal Avgar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag_duplicates">flag_duplicates</a>()</code>, <code><a href="#topic+flag_roundtrips">flag_roundtrips</a>()</code>,
<code><a href="#topic+flag_defunct_clusters">flag_defunct_clusters</a>()</code>
</p>

<hr>
<h2 id='flag_roundtrips'>Flag Fast Round Trips</h2><span id='topic+flag_roundtrips'></span><span id='topic+flag_roundtrips.track_xyt'></span>

<h3>Description</h3>

<p>Flags locations that imply fast round trips
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_roundtrips(x, delta, epsilon, time_unit = "secs", ...)

## S3 method for class 'track_xyt'
flag_roundtrips(x, delta, epsilon, time_unit = "secs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_roundtrips_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> A <code>track_xyt</code> object.</p>
</td></tr>
<tr><td><code id="flag_roundtrips_+3A_delta">delta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> The threshold SDR for flagging. Locations that imply
both legs of a round trip with <code>SDR &gt; delta/epsilon</code> are flagged. See details.</p>
</td></tr>
<tr><td><code id="flag_roundtrips_+3A_epsilon">epsilon</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> A scaling factor to create the threshold for
flagging.</p>
</td></tr>
<tr><td><code id="flag_roundtrips_+3A_time_unit">time_unit</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Character string giving time unit. Should be
<code>"secs"</code>, <code>"mins"</code>, or <code>"hours"</code>. See details.</p>
</td></tr>
<tr><td><code id="flag_roundtrips_+3A_...">...</code></td>
<td>
<p>Addtional arguments. None currently implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Locations implying a single fast step can be flagged using
<code><a href="#topic+flag_fast_steps">flag_fast_steps</a>()</code>. However, it is more likely that a single
location is imprecise if it implies an unrealistically fast out-and-back round
trip. In that case, the user might be willing to scale the threshold SDR.
In this function, <code>delta</code> gives the base SDR and <code>epsilon</code> is the scaling
factor, such that locations are considered for flagging if the SDR from the
previous location (location i - 1) to the focal location (i) [call it <code>sdr1</code>]
and the focal location (i) to the next location (i + 1) [call it <code>sdr2</code>] both
have <code>SDR &gt; delta/epsilon</code>.
</p>
<p>In that case, the SDR from the previous location (i - 1) to the next location
(i + 1) is computed; i.e., the SDR assuming we omit the focal location (i)
[call it <code>sdr3</code>]. The remaining locations should be closer together than
they are to the omitted location. Thus the focal location is flagged if
<code>(sdr1 &gt; epsilon * sdr3) &amp; (sdr2 &gt; epsilon * sdr3)</code>.
</p>
<p>Note that <code>epsilon</code> both <em>decreases</em> <code>delta</code> in the out-and-back case and
<em>increases</em> <code>sdr3</code> (between the remaining neighbors).
</p>
<p>Internally, flagged locations are dropped from future consideration.
</p>
<p>The <code>time_unit</code> should be the same time unit with which the SDR threshold
was calculated. SDR is typically calculated in <code>m^2/s</code>, so <code>time_unit</code> defaults
to <code>"secs"</code>. The spatial unit is determined by the CRS, which should typically
be in meters. The <code>epsilon</code> parameter is unitless.
</p>


<h3>Value</h3>

<p>Returns <code>x</code> (a <code>track_xyt</code>) with a flagging column added
(<code>x$fast_roundtrip_</code>).
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith, based on code by Johannes Signer and Tal Avgar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag_duplicates">flag_duplicates</a>()</code>,
<code><a href="#topic+flag_fast_steps">flag_fast_steps</a>()</code>,
<code><a href="#topic+flag_defunct_clusters">flag_defunct_clusters</a>()</code>
</p>

<hr>
<h2 id='from_to'>Duration of tracks</h2><span id='topic+from_to'></span><span id='topic+from_to.track_xyt'></span><span id='topic+from'></span><span id='topic+from.track_xyt'></span><span id='topic+to'></span><span id='topic+to.track_xyt'></span>

<h3>Description</h3>

<p>Function that returns the start (<code>from</code>), end (<code>to</code>), and the duration (<code>from_to</code>) of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_to(x, ...)

## S3 method for class 'track_xyt'
from_to(x, ...)

from(x, ...)

## S3 method for class 'track_xyt'
from(x, ...)

to(x, ...)

## S3 method for class 'track_xyt'
to(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_to_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="from_to_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of class <code>POSIXct</code>.
</p>

<hr>
<h2 id='get_amt_fisher_covars'>Helper function to get fisher covars</h2><span id='topic+get_amt_fisher_covars'></span>

<h3>Description</h3>

<p>The current version of <code>terra</code> (1.7.12) requires <code>SpatRast</code>ers to be wrapped in order to be saved locally. This function unwraps the covariates for the fisher data and returns a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_amt_fisher_covars()
</code></pre>


<h3>Value</h3>

<p>A list with covariates
</p>

<hr>
<h2 id='get_crs'>Obtains the Coordinate Reference Systems</h2><span id='topic+get_crs'></span>

<h3>Description</h3>

<p>Returns the <code>proj4string</code> of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_crs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_crs_+3A_x">x</code></td>
<td>
<p><code>[any]</code> <br /> Object to check.</p>
</td></tr>
<tr><td><code id="get_crs_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>proj4string</code> of the CRS.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
get_crs(deer)
</code></pre>

<hr>
<h2 id='get_displacement'>Calculate Expected Displacement</h2><span id='topic+get_displacement'></span>

<h3>Description</h3>

<p>Calculates expected displacement for a given SDR and time span
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_displacement(delta, time_span)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_displacement_+3A_delta">delta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> A squared displacement rate (SDR), such as that
returned by <code><a href="#topic+calculate_sdr">calculate_sdr</a>()</code>. Units assumed to be <code>m^2/s</code>.</p>
</td></tr>
<tr><td><code id="get_displacement_+3A_time_span">time_span</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Period]&#8288;</code> A <code>lubridate</code> <code>Period</code> giving the time span
for which to calculate expected displacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector (of length 1) with the expected displacement
in meters.
</p>


<h3>Author(s)</h3>

<p>Johannes Signer and Brian J. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_sdr">calculate_sdr</a>()</code>
</p>

<hr>
<h2 id='get_distr'>Obtain the step length and/or turn angle distributions from random steps or a fitted model.</h2><span id='topic+get_distr'></span><span id='topic+sl_distr'></span><span id='topic+sl_distr.random_steps'></span><span id='topic+sl_distr.fit_clogit'></span><span id='topic+ta_distr'></span><span id='topic+ta_distr.random_steps'></span><span id='topic+ta_distr.fit_clogit'></span>

<h3>Description</h3>

<p>Obtain the step length and/or turn angle distributions from random steps or a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sl_distr(x, ...)

## S3 method for class 'random_steps'
sl_distr(x, ...)

## S3 method for class 'fit_clogit'
sl_distr(x, ...)

ta_distr(x, ...)

## S3 method for class 'random_steps'
ta_distr(x, ...)

## S3 method for class 'fit_clogit'
ta_distr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_distr_+3A_x">x</code></td>
<td>
<p>Random steps or fitted model</p>
</td></tr>
<tr><td><code id="get_distr_+3A_...">...</code></td>
<td>
<p>None implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An amt distribution
</p>

<hr>
<h2 id='get_max_dist'>Get the maximum distance</h2><span id='topic+get_max_dist'></span><span id='topic+get_max_dist.fit_clogit'></span>

<h3>Description</h3>

<p>Helper function to get the maximum distance from a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_max_dist(x, ...)

## S3 method for class 'fit_clogit'
get_max_dist(x, p = 0.99, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_max_dist_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[fitted_issf]&#8288;</code> <br /> A fitted integrated step-selection function.</p>
</td></tr>
<tr><td><code id="get_max_dist_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="get_max_dist_+3A_p">p</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]{0.99}&#8288;</code> The quantile of the step-length distribution.</p>
</td></tr>
</table>

<hr>
<h2 id='get_sh_forest'>Helper function to get forest cover</h2><span id='topic+get_sh_forest'></span>

<h3>Description</h3>

<p>The current version of <code>terra</code> (1.7.12) requires <code>SpatRast</code>ers to be wrapped in order to be saved locally. This function unwraps the the forest layer and returns a <code>SpatRast</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sh_forest()
</code></pre>


<h3>Value</h3>

<p>A <code>SpatRast</code> with forest cover.
</p>

<hr>
<h2 id='has_crs'>Check for Coordinate Reference Systems (CRS)</h2><span id='topic+has_crs'></span>

<h3>Description</h3>

<p>Checks if an object has a CRS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_crs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_crs_+3A_x">x</code></td>
<td>
<p><code>[any]</code> <br /> Object to check.</p>
</td></tr>
<tr><td><code id="has_crs_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logic vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
has_crs(deer)
</code></pre>

<hr>
<h2 id='hr_akde'>Home ranges</h2><span id='topic+hr_akde'></span><span id='topic+hr_akde.track_xyt'></span><span id='topic+hrest'></span><span id='topic+hr_kde'></span><span id='topic+hr_kde.track_xy'></span><span id='topic+hr_locoh'></span><span id='topic+hr_locoh.track_xy'></span><span id='topic+hr_mcp'></span><span id='topic+hr_od'></span>

<h3>Description</h3>

<p>Functions to calculate animal home ranges from a <code style="white-space: pre;">&#8288;track_xy*&#8288;</code>. <code>hr_mcp</code>, <code>hr_kde</code>, and <code>hr_locoh</code> calculate the minimum convex
polygon, kernel density, and local convex hull home range respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_akde(x, ...)

## S3 method for class 'track_xyt'
hr_akde(
  x,
  model = fit_ctmm(x, "iid"),
  keep.data = TRUE,
  trast = make_trast(x),
  levels = 0.95,
  wrap = FALSE,
  ...
)

hr_kde(x, ...)

## S3 method for class 'track_xy'
hr_kde(
  x,
  h = hr_kde_ref(x),
  trast = make_trast(x),
  levels = 0.95,
  keep.data = TRUE,
  wrap = FALSE,
  ...
)

hr_locoh(x, ...)

## S3 method for class 'track_xy'
hr_locoh(
  x,
  n = 10,
  type = "k",
  levels = 0.95,
  keep.data = TRUE,
  rand_buffer = 1e-05,
  ...
)

hr_mcp(x, ...)

hr_od(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_akde_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_model">model</code></td>
<td>
<p>A continuous time movement model. This can be fitted either with <code>ctmm::ctmm.fit</code> or <code>fit_ctmm</code>.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_keep.data">keep.data</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logic(1)]&#8288;</code> <br /> Should the original tracking data be included in the estimate?</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_trast">trast</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[SpatRast]&#8288;</code> <br /> A template raster for kernel density home-ranges.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_levels">levels</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The isopleth levels used for calculating home
ranges. Should be <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_wrap">wrap</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> <br /> If <code>TRUE</code> the UD is wrapped (see <code>terra::wrap()</code>).</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_h">h</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(2)]&#8288;</code> <br /> The bandwidth for kernel density estimation.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code> <br /> The number of neighbors used when calculating
local convex hulls.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_type">type</code></td>
<td>
<p><code>k</code>, <code>r</code> or <code>a</code>. Type of LoCoH.</p>
</td></tr>
<tr><td><code id="hr_akde_+3A_rand_buffer">rand_buffer</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]&#8288;</code> <br /> Random buffer to avoid polygons with
area 0 (if coordinates are numerically identical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>hr</code>-estimate.
</p>


<h3>References</h3>

<p>Worton, B. J. (1989). Kernel methods for estimating the utilization distribution in home-range studies. <em>Ecology, 70(1)</em>, 164-168.
C. H. Fleming, W. F. Fagan, T. Mueller, K. A. Olson, P. Leimgruber, J. M. Calabrese, “Rigorous home-range estimation with movement data: A new autocorrelated kernel-density estimator”, Ecology, 96:5, 1182-1188 (2015).
</p>
<p>Fleming, C. H., Fagan, W. F., Mueller, T., Olson, K. A., Leimgruber, P., &amp; Calabrese, J. M. (2016). Estimating where and how animals travel: an optimal framework for path reconstruction from autocorrelated tracking data. Ecology, 97(3), 576-582.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(deer)
mini_deer &lt;- deer[1:100, ]

# MCP ---------------------------------------------------------------------
mcp1 &lt;- hr_mcp(mini_deer)
hr_area(mcp1)

# calculated MCP at different levels
mcp1 &lt;- hr_mcp(mini_deer, levels = seq(0.3, 1, 0.1))
hr_area(mcp1)

# CRS are inherited
get_crs(mini_deer)
mcps &lt;- hr_mcp(mini_deer, levels = c(0.5, 0.95, 1))
has_crs(mcps)

# Kernel density estimaiton (KDE) -----------------------------------------
kde1 &lt;- hr_kde(mini_deer)
hr_area(kde1)
get_crs(kde1)

# akde
data(deer)
mini_deer &lt;- deer[1:20, ]
ud1 &lt;- hr_akde(mini_deer) # uses an iid ctmm
ud2 &lt;- hr_akde(mini_deer, model = fit_ctmm(deer, "ou")) # uses an OU ctmm

# od

data(deer)
ud1 &lt;- hr_od(deer) # uses an iid ctmm
ud2 &lt;- hr_akde(deer, model = fit_ctmm(deer, "ou")) # uses an OU ctmm

</code></pre>

<hr>
<h2 id='hr_area'>Home-range area</h2><span id='topic+hr_area'></span><span id='topic+hr_area.hr'></span><span id='topic+hr_area.RasterLayer'></span><span id='topic+hr_area.akde'></span>

<h3>Description</h3>

<p>Obtain the area of a home-range estimate, possible at different isopleth levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_area(x, ...)

## S3 method for class 'hr'
hr_area(x, units = FALSE, ...)

## S3 method for class 'RasterLayer'
hr_area(x, level = 0.95, ...)

## S3 method for class 'akde'
hr_area(x, units = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_area_+3A_x">x</code></td>
<td>
<p>An object of class <code>hr</code></p>
</td></tr>
<tr><td><code id="hr_area_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="hr_area_+3A_units">units</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logic(1)]&#8288;</code> <br /> Should areas be returned as units? If <code>FALSE</code> areas are returned as numeric values.</p>
</td></tr>
<tr><td><code id="hr_area_+3A_level">level</code></td>
<td>
<p>The level at which the area will be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with the home-range level and the area.
</p>

<hr>
<h2 id='hr_isopleths'>Home-range isopleths</h2><span id='topic+hr_isopleths'></span><span id='topic+hr_isopleths.PackedSpatRaster'></span><span id='topic+hr_isopleths.SpatRaster'></span><span id='topic+hr_isopleths.mcp'></span><span id='topic+hr_isopleths.locoh'></span><span id='topic+hr_isopleths.hr_prob'></span><span id='topic+hr_isopleths.akde'></span>

<h3>Description</h3>

<p>Obtain the isopleths of a home-range estimate, possible at different isopleth levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_isopleths(x, ...)

## S3 method for class 'PackedSpatRaster'
hr_isopleths(x, levels, descending = TRUE, ...)

## S3 method for class 'SpatRaster'
hr_isopleths(x, levels, descending = TRUE, ...)

## S3 method for class 'mcp'
hr_isopleths(x, descending = TRUE, ...)

## S3 method for class 'locoh'
hr_isopleths(x, descending = TRUE, ...)

## S3 method for class 'hr_prob'
hr_isopleths(x, descending = TRUE, ...)

## S3 method for class 'akde'
hr_isopleths(x, conf.level = 0.95, descending = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_isopleths_+3A_x">x</code></td>
<td>
<p>An object of class <code>hr</code></p>
</td></tr>
<tr><td><code id="hr_isopleths_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="hr_isopleths_+3A_levels">levels</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The isopleth levels used for calculating home
ranges. Should be <code style="white-space: pre;">&#8288;0 &lt; level &lt; 1&#8288;</code>.</p>
</td></tr>
<tr><td><code id="hr_isopleths_+3A_descending">descending</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical = TRUE]&#8288;</code> <br /> Indicating if levels (and thus the polygons) should be ordered in descending (default) or not.</p>
</td></tr>
<tr><td><code id="hr_isopleths_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level for isopleths for <code>aKDE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with the home-range level and a simple feature columns with the isoploth as multipolygon.
</p>

<hr>
<h2 id='hr_kde_lscv'>Least square cross validation bandwidth</h2><span id='topic+hr_kde_lscv'></span>

<h3>Description</h3>

<p>Use least square cross validation (lscv) to estimate bandwidth for kernel home-range estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_kde_lscv(
  x,
  range = do.call(seq, as.list(c(hr_kde_ref(x) * c(0.1, 2), length.out = 100))),
  which_min = "global",
  rescale = "none",
  trast = make_trast(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_kde_lscv_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="hr_kde_lscv_+3A_range">range</code></td>
<td>
<p>numeric vector with different candidate h values.</p>
</td></tr>
<tr><td><code id="hr_kde_lscv_+3A_which_min">which_min</code></td>
<td>
<p>A character indicating if the <code>global</code> or <code>local</code> minimum should be searched for.</p>
</td></tr>
<tr><td><code id="hr_kde_lscv_+3A_rescale">rescale</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code> <br /> Rescaling method for reference bandwidth calculation. Must be one of &quot;unitvar&quot;, &quot;xvar&quot;, or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="hr_kde_lscv_+3A_trast">trast</code></td>
<td>
<p>A template raster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hr_kde_lscv</code> calculates least square cross validation bandwidth. This implementation is based on Seaman and Powell (1996).  If <code>whichMin</code> is <code>"global"</code> the global minimum is returned, else the local minimum with the largest candidate bandwidth is returned.
</p>


<h3>Value</h3>

<p><code>vector</code> of length two.
</p>


<h3>References</h3>

<p>Seaman, D. E., &amp; Powell, R. A. (1996). An evaluation of the accuracy of kernel density estimators for home range analysis. <em>Ecology, 77(7)</em>, 2075-2085.
</p>

<hr>
<h2 id='hr_kde_ref_scaled'>Select a bandwidth for Kernel Density Estimation</h2><span id='topic+hr_kde_ref_scaled'></span>

<h3>Description</h3>

<p>Use two dimensional reference bandwidth to select a bandwidth for kernel density estimation.
Find the smallest value for bandwidth (h) that results in n polygons
(usually n=1) contiguous polygons at a given level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_kde_ref_scaled(
  x,
  range = hr_kde_ref(x)[1] * c(0.01, 1),
  trast = make_trast(x),
  num.of.parts = 1,
  levels = 0.95,
  tol = 0.1,
  max.it = 500L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_kde_ref_scaled_+3A_x">x</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;track_xy*&#8288;</code>.</p>
</td></tr>
<tr><td><code id="hr_kde_ref_scaled_+3A_range">range</code></td>
<td>
<p>Numeric vector, indicating the lower and upper bound of the search range. If <code>range</code> is to large with regard to <code>trast</code>, the algorithm will fail.</p>
</td></tr>
<tr><td><code id="hr_kde_ref_scaled_+3A_trast">trast</code></td>
<td>
<p>A template <code>RasterLayer</code>.</p>
</td></tr>
<tr><td><code id="hr_kde_ref_scaled_+3A_num.of.parts">num.of.parts</code></td>
<td>
<p>Numeric numeric scalar, indicating the number of contiguous  polygons desired. This will usually be one.</p>
</td></tr>
<tr><td><code id="hr_kde_ref_scaled_+3A_levels">levels</code></td>
<td>
<p>The home range level.</p>
</td></tr>
<tr><td><code id="hr_kde_ref_scaled_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar, indicating which difference of to stop.</p>
</td></tr>
<tr><td><code id="hr_kde_ref_scaled_+3A_max.it">max.it</code></td>
<td>
<p>Numeric scalar, indicating the maximum number of acceptable iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation uses a bisection algorithm to the find the smallest value
value for the kernel bandwidth within <code>range</code> that produces an home-range
isopleth at <code>level</code> consisting of <code>n</code> polygons. Note, no difference is
is made between the two dimensions.
</p>


<h3>Value</h3>

<p><code>list</code> with the calculated bandwidth, exit status and the number of iteration.
</p>


<h3>References</h3>

<p>Kie, John G. &quot;A rule-based ad hoc method for selecting a bandwidth in kernel home-range analyses.&quot; Animal Biotelemetry 1.1 (2013): 1-12.
</p>

<hr>
<h2 id='hr_overlap_feature'>Calculate the overlap between a home-range estimate and a polygon</h2><span id='topic+hr_overlap_feature'></span>

<h3>Description</h3>

<p>Sometimes the percentage overlap between a spatial polygon an a home-range is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_overlap_feature(x, sf, direction = "hr_with_feature", feature_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_overlap_feature_+3A_x">x</code></td>
<td>
<p>A home-range estimate.</p>
</td></tr>
<tr><td><code id="hr_overlap_feature_+3A_sf">sf</code></td>
<td>
<p>An object of class <code>sf</code> containing polygons</p>
</td></tr>
<tr><td><code id="hr_overlap_feature_+3A_direction">direction</code></td>
<td>
<p>The direction.</p>
</td></tr>
<tr><td><code id="hr_overlap_feature_+3A_feature_names">feature_names</code></td>
<td>
<p>optional feature names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>

<hr>
<h2 id='hr_overlaps'>Methods to calculate home-range overlaps</h2><span id='topic+hr_overlaps'></span><span id='topic+hr_overlap'></span><span id='topic+hr_overlap.hr'></span><span id='topic+hr_overlap.list'></span>

<h3>Description</h3>

<p>Methods to calculate the overlap of two or more home-range estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_overlap(x, ...)

## S3 method for class 'hr'
hr_overlap(x, y, type = "hr", conditional = FALSE, ...)

## S3 method for class 'list'
hr_overlap(
  x,
  type = "hr",
  conditional = FALSE,
  which = "consecutive",
  labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_overlaps_+3A_x">x</code>, <code id="hr_overlaps_+3A_y">y</code></td>
<td>
<p>A home-range estimate</p>
</td></tr>
<tr><td><code id="hr_overlaps_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="hr_overlaps_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character](1)&#8288;</code> <br /> Type of index, should be one of <code>hr</code>, <code>phr</code>,
<code>vi</code>, <code>ba</code>, <code>udoi</code>, or <code>hd</code>.</p>
</td></tr>
<tr><td><code id="hr_overlaps_+3A_conditional">conditional</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical](1)&#8288;</code> <br /> Whether or not conditional UDs are
used. If <code>TRUE</code> levels from that were used to estimate home ranges will be
used.</p>
</td></tr>
<tr><td><code id="hr_overlaps_+3A_which">which</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character = "consecutive"]&#8288;</code> <br /> Should only consecutive overlaps be calculated or all combinations?</p>
</td></tr>
<tr><td><code id="hr_overlaps_+3A_labels">labels</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character=NULL]&#8288;</code> <br /> Labels for different instances. If <code>NULL</code> (the default) numbers will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the isopleth level and area in units of the
coordinate reference system.
</p>

<hr>
<h2 id='hr_to_sf'>Convert home ranges to <code>sfc</code></h2><span id='topic+hr_to_sf'></span><span id='topic+hr_to_sf.tbl_df'></span>

<h3>Description</h3>

<p>Convert a list column with many home-range estimates to a <code>tibble</code> with a geometry column (as used by the <code>sf</code>-package).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_to_sf(x, ...)

## S3 method for class 'tbl_df'
hr_to_sf(x, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_to_sf_+3A_x">x</code></td>
<td>
<p>A <code>tibble</code> with a <code style="white-space: pre;">&#8288;list column&#8288;</code> with individual home ranges.</p>
</td></tr>
<tr><td><code id="hr_to_sf_+3A_...">...</code></td>
<td>
<p>Additional columns that should be transferred to the new <code>tibble</code>.</p>
</td></tr>
<tr><td><code id="hr_to_sf_+3A_col">col</code></td>
<td>
<p>The column where the home</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with a simple feature column (from the <code>sf</code>) package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("amt_fisher")
hr &lt;- amt_fisher |&gt; nest(data = -id) |&gt;
  mutate(hr = map(data, hr_mcp), n = map_int(data, nrow)) |&gt;
  hr_to_sf(hr, id, n)

hr &lt;- amt_fisher |&gt; nest(data = -id) |&gt;
  mutate(hr = map(data, hr_kde), n = map_int(data, nrow)) |&gt;
  hr_to_sf(hr, id, n)


</code></pre>

<hr>
<h2 id='hr_ud'>Obtain the utilization distribution of a probabilistic home-range estimate</h2><span id='topic+hr_ud'></span>

<h3>Description</h3>

<p>Obtain the utilization distribution of a probabilistic home-range estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hr_ud(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hr_ud_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[hr_prob]&#8288;</code> The home-range estimate</p>
</td></tr>
<tr><td><code id="hr_ud_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatRaster</code>
</p>

<hr>
<h2 id='inspect'>Inspect a track</h2><span id='topic+inspect'></span><span id='topic+inspect.track_xy'></span>

<h3>Description</h3>

<p>Provides a very basic interface to <code>leaflet</code> and lets the user inspect relocations on an interactive map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(x, ...)

## S3 method for class 'track_xy'
inspect(x, popup = NULL, cluster = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="inspect_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="inspect_+3A_popup">popup</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(nrow(x))]&#8288;</code> <br /> Optional labels for popups.</p>
</td></tr>
<tr><td><code id="inspect_+3A_cluster">cluster</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> <br /> If <code>TRUE</code> points are clustered at lower zoom levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interactive <code>leaflet</code> map.
</p>


<h3>Note</h3>

<p>Important, <code>x</code> requires a valid coordinate reference system.
</p>


<h3>See Also</h3>

<p><code>leaflet::leaflet()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sh)
x &lt;- track(x = sh$x, y = sh$y, crs = 31467)


inspect(x)
inspect(x, cluster = FALSE)
inspect(x, popup = 1:nrow(x), cluster = FALSE)

</code></pre>

<hr>
<h2 id='issf_w_form'>Create habitat formula from iSSF</h2><span id='topic+issf_w_form'></span>

<h3>Description</h3>

<p>Creates a formula without movement variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>issf_w_form(object, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="issf_w_form_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[fit_clogit]&#8288;</code> Fitted iSSF.</p>
</td></tr>
<tr><td><code id="issf_w_form_+3A_l">l</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list]&#8288;</code> List returned by <code>prep_test_dat.fit_clogit()</code></p>
</td></tr>
</table>

<hr>
<h2 id='log_rss'>Calculate log-RSS for a fitted model</h2><span id='topic+log_rss'></span><span id='topic+log_rss.glm'></span><span id='topic+log_rss.fit_clogit'></span>

<h3>Description</h3>

<p>Calculate log-RSS(x1, x2) for a fitted RSF or (i)SSF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_rss(object, ...)

## S3 method for class 'glm'
log_rss(object, x1, x2, ci = NA, ci_level = 0.95, n_boot = 1000, ...)

## S3 method for class 'fit_clogit'
log_rss(object, x1, x2, ci = NA, ci_level = 0.95, n_boot = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_rss_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[fit_logit, fit_clogit]&#8288;</code> <br /> A fitted RSF or (i)SSF model.</p>
</td></tr>
<tr><td><code id="log_rss_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="log_rss_+3A_x1">x1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A <code>data.frame</code> representing the habitat values
at location x_1. Must contain all fitted covariates as expected by
<code>predict()</code>.</p>
</td></tr>
<tr><td><code id="log_rss_+3A_x2">x2</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A 1-row <code>data.frame</code> representing the single
hypothetical location of x_2. Must contain all fitted covariates as expected
by <code>predict()</code>.</p>
</td></tr>
<tr><td><code id="log_rss_+3A_ci">ci</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> Method for estimating confidence intervals around
log-RSS. <code>NA</code> skips calculating CIs. Character string <code>"se"</code> uses standard error
method and <code>"boot"</code> uses empirical bootstrap method.</p>
</td></tr>
<tr><td><code id="log_rss_+3A_ci_level">ci_level</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> Level for confidence interval. Defaults to 0.95
for a 95% confidence interval.</p>
</td></tr>
<tr><td><code id="log_rss_+3A_n_boot">n_boot</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code> <br /> Number of bootstrap samples to estimate confidence
intervals. Ignored if <code>ci != "boot"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the user would like to compare relative
selection strengths from at least one proposed location (<code>x1</code>) to exactly
one reference location (<code>x2</code>).
</p>
<p>The objects <code>object$model</code>, <code>x1</code>, and <code>x2</code> will be passed to
<code>predict()</code>. Therefore, the columns of <code>x1</code> and <code>x2</code> must match
the terms in the model formula exactly.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> of class <code>log_rss</code> with four entries:
</p>

<ul>
<li> <p><code>df</code>: A <code>data.frame</code> with the covariates and the <code>log_rss</code>
</p>
</li>
<li> <p><code>x1</code>: A <code>data.frame</code> with covariate values for <code>x1</code>.
</p>
</li>
<li> <p><code>x2</code>: A <code>data.frame</code> with covariate values for <code>x2</code>.
</p>
</li>
<li> <p><code>formula</code>: The formula used to fit the model.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Brian J. Smith
</p>


<h3>References</h3>


<ul>
<li><p> Avgar, T., Lele, S.R., Keim, J.L., and Boyce, M.S.. (2017). Relative Selection
Strength: Quantifying effect size in habitat- and step-selection inference.
<em>Ecology and Evolution</em>, 7, 5322–5330.
</p>
</li>
<li><p> Fieberg, J., Signer, J., Smith, B., &amp; Avgar, T. (2021). A &quot;How to&quot; guide for interpreting parameters in habitat-selection analyses. <em>Journal of Animal Ecology</em>, 90(5), 1027-1043.
</p>
</li></ul>



<h3>See Also</h3>

<p>See Avgar <em>et al.</em> 2017 for details about relative
selection strength.
</p>
<p>Default plotting method available: <code><a href="#topic+plot.log_rss">plot.log_rss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# RSF -------------------------------------------------------
# Fit an RSF, then calculate log-RSS to visualize results.

# Load packages
library(ggplot2)

# Load data
data("amt_fisher")
amt_fisher_covar &lt;- get_amt_fisher_covars()

# Prepare data for RSF
rsf_data &lt;- amt_fisher |&gt;
  filter(name == "Lupe") |&gt;
  make_track(x_, y_, t_) |&gt;
  random_points() |&gt;
  extract_covariates(amt_fisher_covar$elevation) |&gt;
  extract_covariates(amt_fisher_covar$popden) |&gt;
  extract_covariates(amt_fisher_covar$landuse) |&gt;
  mutate(lu = factor(landuse))

# Fit RSF
m1 &lt;- rsf_data |&gt;
  fit_rsf(case_ ~ lu + elevation + popden)

# Calculate log-RSS
# data.frame of x1s
x1 &lt;- data.frame(lu = factor(50, levels = levels(rsf_data$lu)),
                 elevation = seq(90, 120, length.out = 100),
                 popden = mean(rsf_data$popden))
# data.frame of x2 (note factor levels should be same as model data)
x2 &lt;- data.frame(lu = factor(50, levels = levels(rsf_data$lu)),
                 elevation = mean(rsf_data$elevation),
                 popden = mean(rsf_data$popden))
# Calculate (use se method for confidence interval)
logRSS &lt;- log_rss(object = m1, x1 = x1, x2 = x2, ci = "se")

# Plot
ggplot(logRSS$df, aes(x = elevation_x1, y = log_rss)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_ribbon(aes(ymin = lwr, ymax = upr), fill = "gray80") +
  geom_line() +
  xlab(expression("Elevation " * (x[1]))) +
  ylab("log-RSS") +
  ggtitle(expression("log-RSS" * (x[1] * ", " * x[2]))) +
  theme_bw()

# SSF -------------------------------------------------------
# Fit an SSF, then calculate log-RSS to visualize results.

# Load data
data(deer)
sh_forest &lt;- get_sh_forest()

# Prepare data for SSF
ssf_data &lt;- deer |&gt;
  steps_by_burst() |&gt;
  random_steps(n = 15) |&gt;
  extract_covariates(sh_forest) |&gt;
  mutate(forest = factor(forest, levels = 1:0,
                    labels = c("forest", "non-forest")),
  cos_ta = cos(ta_),
  log_sl = log(sl_))

# Fit an SSF (note model = TRUE necessary for predict() to work)
m2 &lt;- ssf_data |&gt;
  fit_clogit(case_ ~ forest + strata(step_id_), model = TRUE)

# Calculate log-RSS
# data.frame of x1s
x1 &lt;- data.frame(forest = factor(c("forest", "non-forest")))
# data.frame of x2
x2 &lt;- data.frame(forest = factor("forest", levels = levels(ssf_data$forest)))
# Calculate
logRSS &lt;- log_rss(object = m2, x1 = x1, x2 = x2, ci = "se")

# Plot
ggplot(logRSS$df, aes(x = forest_x1, y = log_rss)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray") +
  geom_errorbar(aes(ymin = lwr, ymax = upr), width = 0.25) +
  geom_point(size = 3) +
  xlab(expression("Forest Cover " * (x[1]))) +
  ylab("log-RSS") +
  ggtitle(expression("log-RSS" * (x[1] * ", " * x[2]))) +
  theme_bw()

</code></pre>

<hr>
<h2 id='make_issf_model'>Create an <code>issf</code>-model object from scratch</h2><span id='topic+make_issf_model'></span>

<h3>Description</h3>

<p>In order to simulate from an <code>issf</code> a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_issf_model(
  coefs = c(sl_ = 0),
  sl = make_exp_distr(),
  ta = make_unif_distr()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_issf_model_+3A_coefs">coefs</code></td>
<td>
<p>A named vector with the coefficient values.</p>
</td></tr>
<tr><td><code id="make_issf_model_+3A_sl">sl</code></td>
<td>
<p>The tentative step-length distribution.</p>
</td></tr>
<tr><td><code id="make_issf_model_+3A_ta">ta</code></td>
<td>
<p>The tentative turn-angle distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>fit_clogit</code>.
</p>

<hr>
<h2 id='make_start'>Create an initial step for simulations</h2><span id='topic+make_start'></span><span id='topic+make_start.numeric'></span><span id='topic+make_start.track_xyt'></span><span id='topic+make_start.steps_xyt'></span>

<h3>Description</h3>

<p>An initial step for simulations. This step can either be created by defining a step from
scratch or by using an observed step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_start(x, ...)

## S3 method for class 'numeric'
make_start(
  x = c(0, 0),
  ta_ = 0,
  time = Sys.time(),
  dt = hours(1),
  crs = NA,
  ...
)

## S3 method for class 'track_xyt'
make_start(x, ta_ = 0, dt = hours(1), ...)

## S3 method for class 'steps_xyt'
make_start(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_start_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[steps_xyt,numeric(2)]&#8288;</code> <br /> A step of class <code>steps_xyt</code> or the start coordinates..</p>
</td></tr>
<tr><td><code id="make_start_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="make_start_+3A_ta_">ta_</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]{0}&#8288;</code> <br /> The initial turn-angle.</p>
</td></tr>
<tr><td><code id="make_start_+3A_time">time</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[POSIXt(1)]{Sys.time()}&#8288;</code> <br /> The time stamp when the simulation
starts.</p>
</td></tr>
<tr><td><code id="make_start_+3A_dt">dt</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Period(1)]{hours(1)}&#8288;</code> <br /> The sampling rate of the
simulations.</p>
</td></tr>
<tr><td><code id="make_start_+3A_crs">crs</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[int(1)]{NA}&#8288;</code> <br /> The coordinate reference system of the start location given as EPSG code.</p>
</td></tr>
</table>

<hr>
<h2 id='movement_metrics'>Movement metrics</h2><span id='topic+movement_metrics'></span><span id='topic+straightness'></span><span id='topic+cum_dist'></span><span id='topic+tot_dist'></span><span id='topic+msd'></span><span id='topic+intensity_use'></span><span id='topic+sinuosity'></span><span id='topic+tac'></span>

<h3>Description</h3>

<p>Functions to calculate metrics such as straightness, mean squared displacement (msd), intensity use,
sinuosity, mean turn angle correlation (<code>tac</code>) of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>straightness(x, ...)

cum_dist(x, ...)

tot_dist(x, ...)

msd(x, ...)

intensity_use(x, ...)

sinuosity(x, ...)

tac(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movement_metrics_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="movement_metrics_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intensity use is calculated by dividing the total movement distance (<code>tot_dist</code>) by the square of the area of movement (= minimum convex polygon 100).
</p>


<h3>Value</h3>

<p>A numeric vector of length one.
</p>


<h3>References</h3>


<ul>
<li> <p>Abrahms B, Seidel DP, Dougherty E, Hazen EL, Bograd SJ, Wilson AM, McNutt JW, Costa DP, Blake S, Brashares JS, others (2017).
&ldquo;Suite of simple metrics reveals common movement syndromes across vertebrate taxa.&rdquo;
<em>Movement ecology</em>, <b>5</b>(1), 12.
</p>
</li>
<li> <p>Almeida PJ, Vieira MV, Kajin M, Forero-Medina G, Cerqueira R (2010).
&ldquo;Indices of movement behaviour: conceptual background, effects of scale and location errors.&rdquo;
<em>Zoologia (Curitiba)</em>, <b>27</b>(5), 674&ndash;680.
</p>
</li>
<li> <p>Swihart RK, Slade NA (1985).
&ldquo;Testing for independence of observations in animal movements.&rdquo;
<em>Ecology</em>, <b>66</b>(4), 1176&ndash;1184.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(deer)

tot_dist(deer)
cum_dist(deer)
straightness(deer)
msd(deer)
intensity_use(deer)

</code></pre>

<hr>
<h2 id='nsd'>Net squared displacement (nsd)</h2><span id='topic+nsd'></span><span id='topic+nsd.track_xy'></span><span id='topic+add_nsd'></span><span id='topic+add_nsd.track_xy'></span><span id='topic+add_nsd.steps_xy'></span>

<h3>Description</h3>

<p>The function <code>nsd()</code> calculates the net squared displacement (i.e., the squared distance from the first location of a track) for a track. The function <code>add_nsd()</code> add a new column to a track or steps object with the nsd (the column name is <code>nsd_</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsd(x, ...)

## S3 method for class 'track_xy'
nsd(x, ...)

add_nsd(x, ...)

## S3 method for class 'track_xy'
add_nsd(x, ...)

## S3 method for class 'steps_xy'
add_nsd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsd_+3A_x">x</code></td>
<td>
<p>A track_xyt.</p>
</td></tr>
<tr><td><code id="nsd_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector (for <code>nsd()</code>) and a tillbe with the original data with a new column for <code>add_nsd()</code>.
</p>

<hr>
<h2 id='od'>Occurrence Distribution</h2><span id='topic+od'></span><span id='topic+rolling_od'></span><span id='topic+rolling_od.track_xyt'></span><span id='topic+od.track_xyt'></span>

<h3>Description</h3>

<p><code>od</code> is a wrapper around <code>ctmm::occurrence</code>. See <code>help(ctmm::occurrence)</code> for more details. <code>rolling_od</code> estimates occurrence distributions for a subset of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_od(x, ...)

## S3 method for class 'track_xyt'
rolling_od(
  x,
  trast,
  model = fit_ctmm(x, "bm"),
  res.space = 10,
  res.time = 10,
  n.points = 5,
  show.progress = TRUE,
  ...
)

od(x, ...)

## S3 method for class 'track_xyt'
od(x, trast, model = fit_ctmm(x, "bm"), res.space = 10, res.time = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_+3A_x">x</code></td>
<td>
<p><code>[track_xyt]</code> <br /> A track created with <code>make_track</code> that includes time.</p>
</td></tr>
<tr><td><code id="od_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="od_+3A_trast">trast</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[SpatRaster]&#8288;</code> <br /> A template raster for the extent and resolution of the result.</p>
</td></tr>
<tr><td><code id="od_+3A_model">model</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[An output of fit_ctmm]&#8288;</code> <br /> The autocorrelation model that should be fit to the data. <code>bm</code> corresponds to Brownian motion, <code>ou</code> to an Ornstein-Uhlenbeck process, <code>ouf</code> to an Ornstein-Uhlenbeck forage process.</p>
</td></tr>
<tr><td><code id="od_+3A_res.space">res.space</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)=10]&#8288;</code> <br /> Number of grid point along each axis, relative to the average diffusion (per median timestep) from a stationary point. See also <code>help(ctmm::occurrence)</code>.</p>
</td></tr>
<tr><td><code id="od_+3A_res.time">res.time</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)=10]&#8288;</code> <br /> Number of temporal grid points per median timestep.</p>
</td></tr>
<tr><td><code id="od_+3A_n.points">n.points</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)=5]&#8288;</code> <br /> This argument is only relevant for <code>rolling_od</code> and specifies the window size for the od estimation.</p>
</td></tr>
<tr><td><code id="od_+3A_show.progress">show.progress</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> Indicates if a progress bar is used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Fleming, C. H., Fagan, W. F., Mueller, T., Olson, K. A., Leimgruber, P., &amp; Calabrese, J. M. (2016). Estimating where and how animals travel: an optimal framework for path reconstruction from autocorrelated tracking data. Ecology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(deer)
mini_deer &lt;- deer[1:100, ]
trast &lt;- make_trast(mini_deer)
md &lt;- od(mini_deer, trast = trast)
terra::plot(md)

# rolling ud
xx &lt;- rolling_od(mini_deer, trast)

</code></pre>

<hr>
<h2 id='params'>Get parameters from a (fitted) distribution</h2><span id='topic+params'></span><span id='topic+sl_distr_params'></span><span id='topic+sl_distr_params.random_steps'></span><span id='topic+sl_distr_params.fit_clogit'></span><span id='topic+ta_distr_params'></span><span id='topic+ta_distr_params.random_steps'></span><span id='topic+ta_distr_params.fit_clogit'></span>

<h3>Description</h3>

<p>Get parameters from a (fitted) distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sl_distr_params(x, ...)

## S3 method for class 'random_steps'
sl_distr_params(x, ...)

## S3 method for class 'fit_clogit'
sl_distr_params(x, ...)

ta_distr_params(x, ...)

## S3 method for class 'random_steps'
ta_distr_params(x, ...)

## S3 method for class 'fit_clogit'
ta_distr_params(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[amt_distr]&#8288;</code><br /> A (fitted) distribution</p>
</td></tr>
<tr><td><code id="params_+3A_...">...</code></td>
<td>
<p>None</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the parameters of the distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
d &lt;- deer |&gt; steps() |&gt; random_steps()
sl_distr_params(d)
ta_distr_params(d)


</code></pre>

<hr>
<h2 id='plot_sl'>Plot step-length distribution</h2><span id='topic+plot_sl'></span><span id='topic+plot_sl.fit_clogit'></span><span id='topic+plot_sl.random_steps'></span>

<h3>Description</h3>

<p>Plot step-length distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sl(x, ...)

## S3 method for class 'fit_clogit'
plot_sl(x, n = 1000, upper_quantile = 0.99, plot = TRUE, ...)

## S3 method for class 'random_steps'
plot_sl(x, n = 1000, upper_quantile = 0.99, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sl_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[fit_clogit|random_steps]&#8288;</code> <br /> A fitted step selection or random steps.</p>
</td></tr>
<tr><td><code id="plot_sl_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="plot_sl_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)=1000]{&gt;0}&#8288;</code> <br /> The number of breaks between <code>0</code> and <code>upper_quantile</code>.</p>
</td></tr>
<tr><td><code id="plot_sl_+3A_upper_quantile">upper_quantile</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[nummeric(1)=0.99]{0-1}&#8288;</code> <br /> The quantile until where the distribution should be plotted. Typically this will be <code>0.95</code> or <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="plot_sl_+3A_plot">plot</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> Indicates if a plot should be drawn or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the step-length distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)

# with random steps
deer[1:100, ] |&gt; steps_by_burst() |&gt; random_steps() |&gt; plot_sl()
deer[1:100, ] |&gt; steps_by_burst() |&gt; random_steps() |&gt; plot_sl(upper_quantile = 0.5)

</code></pre>

<hr>
<h2 id='plot.hr'>Plot a home-range estimate</h2><span id='topic+plot.hr'></span>

<h3>Description</h3>

<p>Plot a home-range estimate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hr'
plot(x, add.relocations = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hr_+3A_x">x</code></td>
<td>
<p>A home-range estimate.</p>
</td></tr>
<tr><td><code id="plot.hr_+3A_add.relocations">add.relocations</code></td>
<td>
<p><code>logical(1)</code> indicates if a relocations should be
added to the plot.</p>
</td></tr>
<tr><td><code id="plot.hr_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>

<hr>
<h2 id='plot.log_rss'>Plot a <code>log_rss</code> object</h2><span id='topic+plot.log_rss'></span>

<h3>Description</h3>

<p>Default plot method for an object of class <code>log_rss</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'log_rss'
plot(x, x_var1 = "guess", x_var2 = "guess", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.log_rss_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[log_rss]&#8288;</code> An object returned by the function <code><a href="#topic+log_rss">log_rss</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.log_rss_+3A_x_var1">x_var1</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> The variable to plot on the x-axis. A string of
either <code>"guess"</code> (default &ndash; see Details) or the variable name.</p>
</td></tr>
<tr><td><code id="plot.log_rss_+3A_x_var2">x_var2</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> A second predictor variable to include in the plot.
Either <code>"guess"</code> (default &ndash; see Details), <code>NA</code>, or the variable name.</p>
</td></tr>
<tr><td><code id="plot.log_rss_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[any]&#8288;</code> Additional arguments to be passed to <code style="white-space: pre;">&#8288;\link{plot}()&#8288;</code>.
<em>Not currently implemented</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides defaults for a basic plot, but we encourage
the user to carefully consider how to represent the patterns found in their
habitat selection model.
</p>
<p>The function <code><a href="#topic+log_rss">log_rss</a>()</code> is meant to accept a user-defined
input for <code>x1</code>. The structure of <code>x1</code> likely reflects how the user intended
to visualize the results. Therefore, it is possible to &quot;guess&quot; which covariate
the user would like to see on the x-axis by choosing the column from <code>x1</code> with
the most unique values. Similarly, if there is a second column with multiple
unique values, that could be represented by a color. Note that if the user needs
to specify <code>x_var1</code>, then we probably cannot guess <code>x_var2</code>. Therefore, if the
user specifies <code>x_var1 != "guess" &amp; x_var2 == "guess"</code>, the function will return
an error.
</p>
<p>This function uses integers to represent colors, and therefore the user can
change the default colors by specifying a custom <code><a href="grDevices.html#topic+palette">palette</a>()</code> before
calling the function.
</p>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load data
data("amt_fisher")
amt_fisher_covar &lt;- get_amt_fisher_covars()

# Prepare data for RSF
rsf_data &lt;- amt_fisher |&gt;
  filter(name == "Leroy") |&gt;
  make_track(x_, y_, t_) |&gt;
  random_points() |&gt;
  extract_covariates(amt_fisher_covar$landuse) |&gt;
  mutate(lu = factor(landuse))

# Fit RSF
m1 &lt;- rsf_data |&gt;
  fit_rsf(case_ ~ lu)

# Calculate log-RSS
# data.frame of x1s
x1 &lt;- data.frame(lu = sort(unique(rsf_data$lu)))
# data.frame of x2 (note factor levels should be same as model data)
x2 &lt;- data.frame(lu = factor(140,
levels = levels(rsf_data$lu)))
# Calculate
logRSS &lt;- log_rss(object = m1, x1 = x1, x2 = x2)

# Plot
plot(logRSS)


</code></pre>

<hr>
<h2 id='plot.uhc_data'>Plot UHC plots</h2><span id='topic+plot.uhc_data'></span>

<h3>Description</h3>

<p>Plot an object of class <code>uhc_data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uhc_data'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.uhc_data_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[uhc_data]&#8288;</code> An object of class <code>uhc_data</code>, as returned
by the function <code><a href="#topic+prep_uhc">prep_uhc</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.uhc_data_+3A_...">...</code></td>
<td>
<p>Included for consistency with generic
<code><a href="graphics.html#topic+plot">plot</a>()</code>. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makes plots mimicking those in Fieberg et al. (2018), with the
bootstrapped distribution in gray, the observed distribution in black,
and the available distribution as a dashed red line.
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_uhc">prep_uhc</a>()</code>, <code><a href="#topic+conf_envelope">conf_envelope</a>()</code>,
<code><a href="#topic+plot.uhc_envelopes">plot.uhc_envelopes</a>()</code>
</p>

<hr>
<h2 id='plot.uhc_envelopes'>Plot simplified UHC plots</h2><span id='topic+plot.uhc_envelopes'></span>

<h3>Description</h3>

<p>Plot an object of class <code>uhc_envelopes</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'uhc_envelopes'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.uhc_envelopes_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[uhc_envelopes]&#8288;</code> An object of class <code>uhc_envelopes</code>, as returned
by the function <code><a href="#topic+conf_envelope">conf_envelope</a>()</code>.</p>
</td></tr>
<tr><td><code id="plot.uhc_envelopes_+3A_...">...</code></td>
<td>
<p>Included for consistency with generic
<code><a href="graphics.html#topic+plot">plot</a>()</code>. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Makes plots mimicking those in Fieberg et al. (2018), with the
bootstrapped distribution in gray, the observed distribution in black,
and the available distribution as a dashed red line. This differs from
<code><a href="#topic+plot.uhc_data">plot.uhc_data</a>()</code> in that the bootstrapped distribution
(in gray) is drawn as a polygon rather than (many) lines, speeding up
plotting performance.
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prep_uhc">prep_uhc</a>()</code>, <code><a href="#topic+conf_envelope">conf_envelope</a>()</code>,
<code><a href="#topic+plot.uhc_data">plot.uhc_data</a>()</code>
</p>

<hr>
<h2 id='prep_test_dat'>Prepares <code>test_dat</code> for <code>uhc_prep()</code></h2><span id='topic+prep_test_dat'></span>

<h3>Description</h3>

<p>Internal function to check and format <code>test_dat</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_test_dat(object, test_dat, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_test_dat_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[glm, fit_logit, fit_clogit]&#8288;</code> <br /> A fitted RSF or (i)SSF model.
Should be fit to <em>training</em> dataset separate from the testing data.</p>
</td></tr>
<tr><td><code id="prep_test_dat_+3A_test_dat">test_dat</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A <code>data.frame</code> with <em>testing</em> data from
which to sample test points. Should be separate from the data used to train
the model passed to <code>object</code>.</p>
</td></tr>
<tr><td><code id="prep_test_dat_+3A_verbose">verbose</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Should messages be displayed (<code>TRUE</code>) or not
(<code>FALSE</code>)?</p>
</td></tr>
</table>

<hr>
<h2 id='prep_uhc'>Prepare Data for UHC Plots for a Fitted Model</h2><span id='topic+prep_uhc'></span><span id='topic+prep_uhc.glm'></span><span id='topic+prep_uhc.fit_logit'></span><span id='topic+prep_uhc.fit_clogit'></span>

<h3>Description</h3>

<p>Creates data used to make used-habitat calibration plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_uhc(object, test_dat, n_samp = 1000, n_dens = 512, verbose = TRUE)

## S3 method for class 'glm'
prep_uhc(object, test_dat, n_samp = 1000, n_dens = 512, verbose = TRUE)

## S3 method for class 'fit_logit'
prep_uhc(object, test_dat, n_samp = 1000, n_dens = 512, verbose = TRUE)

## S3 method for class 'fit_clogit'
prep_uhc(object, test_dat, n_samp = 1000, n_dens = 512, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_uhc_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[glm, fit_logit, fit_clogit]&#8288;</code> <br /> A fitted RSF or (i)SSF model.
Should be fit to <em>training</em> dataset separate from the testing data.</p>
</td></tr>
<tr><td><code id="prep_uhc_+3A_test_dat">test_dat</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> A <code>data.frame</code> with <em>testing</em> data from
which to sample test points. Should be separate from the data used to train
the model passed to <code>object</code>.</p>
</td></tr>
<tr><td><code id="prep_uhc_+3A_n_samp">n_samp</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric = 1000]&#8288;</code> A <code>vector</code> of length 1 giving the number of
samples to use to characterize the used habitat distribution under the model.</p>
</td></tr>
<tr><td><code id="prep_uhc_+3A_n_dens">n_dens</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric = 512]&#8288;</code> A <code>numeric</code> vector of length 1 giving the
number of equally spaced points at which density (used, available, and
sampled) is estimated. Passed to <code>stats::density.default()</code>, which indicates
that <code>n</code> should usually be specified as a power of 2.</p>
</td></tr>
<tr><td><code id="prep_uhc_+3A_verbose">verbose</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Should messages be displayed (<code>TRUE</code>) or not
(<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the heavy lifting of creating UHC plots.
It creates the data used later by the <code>plot()</code> method, which actually
draws the UHC plots. This function (1) creates density plots of the used
and available locations from the <em>test</em> data, and (2) resamples the (a)
fitted coefficients and (b) test data (weighted by the exponential habitat
selection function) to create the distribution of used habitat under the
model.
</p>
<p>Note that <code>test_dat</code> should contain at least all of the variables that
appear in the model <code>object</code>. Any further habitat variables in <code>test_dat</code>
will also have UHC plots generated, treating these variables as possible
candidate variables that are simply not included in this particular model.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> of class <code>uhc_data</code> with elements:
</p>

<ul>
<li> <p><code>orig</code>: List of <code>data.frame</code>s, one per variable (see <code>vars</code>). Each
<code>data.frame</code> contains the density plot data (<code>x</code> and <code>y</code>) for the original
used (<code>dist == "U"</code>) and available (<code>dist == "A"</code>) data.
</p>
</li>
<li> <p><code>samp</code>: List of <code>data.frame</code>s, one per variable (see <code>vars</code>). Each
<code>data.frame</code> contains the density plot data (<code>x</code> and <code>y</code>) for each iteration
of bootstrap resampling (<code>iter</code>).
</p>
</li>
<li> <p><code>vars</code>: Character vector with names of the habitat variables for which to
create UHC plots.
</p>
</li>
<li> <p><code>type</code>: Named character vector with the type for each of <code>vars</code> (either
<code>"numeric"</code> or <code>"factor"</code>).
</p>
</li>
<li> <p><code>resp</code>: Character vector of length 1 with the name of the response
variable.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Brian J. Smith
</p>


<h3>References</h3>

<p>Fieberg, J.R., Forester, J.D., Street, G.M., Johnson, D.H., ArchMiller, A.A.,
and Matthiopoulos, J. 2018. Used-habitat calibration plots: A new procedure
for validating species distribution, resource selection, and step-selection
models. <em>Ecography</em> 41:737–752.
</p>


<h3>See Also</h3>

<p>See Fieberg <em>et al.</em> 2018 for details about UHC plots.
</p>
<p>Default plotting method available: <code><a href="#topic+plot.uhc_data">plot.uhc_data</a>()</code>
</p>
<p>Coercion to <code>data.frame</code>: <code><a href="#topic+as.data.frame.uhc_data">as.data.frame.uhc_data</a>()</code>
</p>
<p>Subsetting method: <code><a href="#topic+Extract.uhc_data">Extract.uhc_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Load packages
library(amt)
library(dplyr)
library(terra)
library(sf)

# HSF ----------------------------------------------
# Load data
data(uhc_hsf_locs)
data(uhc_hab)
hab &lt;- rast(uhc_hab, type = "xyz", crs = "epsg:32612")
# Convert "cover" layer to factor
levels(hab[[4]]) &lt;- data.frame(id = 1:3,
                               cover = c("grass", "forest", "wetland"))

# Split into train (80%) and test (20%)
set.seed(1)
uhc_hsf_locs$train &lt;- rbinom(n = nrow(uhc_hsf_locs),
                             size = 1, prob = 0.8)
train &lt;- uhc_hsf_locs[uhc_hsf_locs$train == 1, ]
test &lt;- uhc_hsf_locs[uhc_hsf_locs$train == 0, ]

# Available locations
avail_train &lt;- random_points(st_as_sf(st_as_sfc(st_bbox(hab))),
                             n = nrow(train) * 10)

avail_test &lt;- random_points(st_as_sf(st_as_sfc(st_bbox(hab))),
                            n = nrow(test) * 10)

# Combine with used
train_dat &lt;- train |&gt;
  make_track(x, y, crs = 32612) |&gt;
  mutate(case_ = TRUE) |&gt;
  bind_rows(avail_train) |&gt;
  # Attach covariates
  extract_covariates(hab) |&gt;
  # Assign large weights to available
  mutate(weight = case_when(
    case_ ~ 1,
    !case_ ~ 5000
  ))

test_dat &lt;- test |&gt;
  make_track(x, y, crs = 32612) |&gt;
  mutate(case_ = TRUE) |&gt;
  bind_rows(avail_test) |&gt;
  # Attach covariates
  extract_covariates(hab) |&gt;
  # Assign large weights to available
  mutate(weight = case_when(
    case_ ~ 1,
    !case_ ~ 5000
  ))

# Fit (correct) HSF
hsf1 &lt;- glm(case_ ~ forage + temp + I(temp^2) + pred + cover,
            data = train_dat, family = binomial(), weights = weight)

# Drop weights from 'test_dat'
test_dat$weight &lt;- NULL

# Prep UHC plots
uhc_dat &lt;- prep_uhc(object = hsf1, test_dat = test_dat,
                    n_samp = 500, verbose = TRUE)

# Plot all variables
plot(uhc_dat)

# Plot only first variable
plot(uhc_dat[1])

# Plot only "cover" variable
plot(uhc_dat["cover"])

# Coerce to data.frame
df &lt;- as.data.frame(uhc_dat)

# Simplify sampled lines to confidence envelopes
conf &lt;- conf_envelope(df)

# Default plot for the envelopes version
plot(conf)


</code></pre>

<hr>
<h2 id='random_numbers'>Sample random numbers</h2><span id='topic+random_numbers'></span>

<h3>Description</h3>

<p>Sample radom numbers from a distribution created within the <code>amt</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_numbers(x, n = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_numbers_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[amt_distr]&#8288;</code> <br /> A distribution object.</p>
</td></tr>
<tr><td><code id="random_numbers_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)=100]{&gt;0}&#8288;</code> <br /> The number of random draws.</p>
</td></tr>
<tr><td><code id="random_numbers_+3A_...">...</code></td>
<td>
<p>none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numermic vector.
</p>

<hr>
<h2 id='random_points'>Generate random points</h2><span id='topic+random_points'></span><span id='topic+random_points.hr'></span><span id='topic+random_points.sf'></span><span id='topic+random_points.track_xy'></span>

<h3>Description</h3>

<p>Functions to generate random points within an animals home range. This is usually the first step for investigating habitat selection via Resource Selection Functions (RSF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_points(x, ...)

## S3 method for class 'hr'
random_points(x, n = 100, type = "random", presence = NULL, ...)

## S3 method for class 'sf'
random_points(x, n = 100, type = "random", presence = NULL, ...)

## S3 method for class 'track_xy'
random_points(x, level = 1, hr = "mcp", n = nrow(x) * 10, type = "random", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_points_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="random_points_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[any]&#8288;</code><br /> None implemented.</p>
</td></tr>
<tr><td><code id="random_points_+3A_n">n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code> <br /> The number of random points.</p>
</td></tr>
<tr><td><code id="random_points_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code> <br /> Argument passed to <code>sf::st_sample</code>. The default is <code>random</code>.</p>
</td></tr>
<tr><td><code id="random_points_+3A_presence">presence</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track]&#8288;</code> <br /> The presence points, that will be added to the result.</p>
</td></tr>
<tr><td><code id="random_points_+3A_level">level</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]&#8288;</code> <br /> Home-range level of the minimum convex polygon, used for generating the background samples.</p>
</td></tr>
<tr><td><code id="random_points_+3A_hr">hr</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code> <br /> The home range estimator to be used. Currently only MCP is implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with the observed and random points and a new column <code>case_</code> that indicates if a point is observed (<code>case_ = TRUE</code>) or random (<code style="white-space: pre;">&#8288;case_ TRUE&#8288;</code>).
</p>


<h3>Note</h3>

<p>For objects of class <code>track_xyt</code> the timestamp (<code>t_</code>) is lost.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(deer)

# track_xyt ---------------------------------------------------------------
# Default settings
rp1 &lt;- random_points(deer)

plot(rp1)

# Ten random points for each observed point
rp &lt;- random_points(deer, n = nrow(deer) * 10)
plot(rp)

# Within a home range -----------------------------------------------------
hr &lt;- hr_mcp(deer, level = 1)

# 100 random point within the home range
rp &lt;- random_points(hr, n = 100)
plot(rp)

# 100 regular point within the home range
rp &lt;- random_points(hr, n = 100, type = "regular")
plot(rp)
# 100 hexagonal point within the home range
rp &lt;- random_points(hr, n = 100, type = "hexagonal")
plot(rp)


</code></pre>

<hr>
<h2 id='random_steps'>Generate Random Steps</h2><span id='topic+random_steps'></span><span id='topic+random_steps.numeric'></span><span id='topic+random_steps.steps_xy'></span><span id='topic+random_steps.bursted_steps_xyt'></span>

<h3>Description</h3>

<p>Function to generate a given number of random steps for each observed step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_steps(x, ...)

## S3 method for class 'numeric'
random_steps(
  x,
  n_control = 10,
  angle = 0,
  rand_sl = random_numbers(make_exp_distr(), n = 1e+05),
  rand_ta = random_numbers(make_unif_distr(), n = 1e+05),
  ...
)

## S3 method for class 'steps_xy'
random_steps(
  x,
  n_control = 10,
  sl_distr = fit_distr(x$sl_, "gamma"),
  ta_distr = fit_distr(x$ta_, "vonmises"),
  rand_sl = random_numbers(sl_distr, n = 1e+05),
  rand_ta = random_numbers(ta_distr, n = 1e+05),
  include_observed = TRUE,
  start_id = 1,
  ...
)

## S3 method for class 'bursted_steps_xyt'
random_steps(
  x,
  n_control = 10,
  sl_distr = fit_distr(x$sl_, "gamma"),
  ta_distr = fit_distr(x$ta_, "vonmises"),
  rand_sl = random_numbers(sl_distr, n = 1e+05),
  rand_ta = random_numbers(ta_distr, n = 1e+05),
  include_observed = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_steps_+3A_x">x</code></td>
<td>
<p>Steps.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_n_control">n_control</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)=10]{&gt;1}&#8288;</code> <br /> The number of control steps paired
with each observed step.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_angle">angle</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1) = 0]{-pi &lt; rel_angle &lt; pi}&#8288;</code> <br /> Angle for the first step.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_rand_sl">rand_sl</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> Numeric vector with random step lengths an animal can make. This will usually be random numbers drawn from a suitable distribution (e.g., gamma or exponential).</p>
</td></tr>
<tr><td><code id="random_steps_+3A_rand_ta">rand_ta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> Numeric vector with relative turning angles an animal can make. This will usually be random numbers drawn from a suitable distribution (e.g., von Mises or uniform).</p>
</td></tr>
<tr><td><code id="random_steps_+3A_sl_distr">sl_distr</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[amt_distr]&#8288;</code> <br /> The step-length distribution.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_ta_distr">ta_distr</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[amt_distr]&#8288;</code> <br /> The turn-angle distribution.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_include_observed">include_observed</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1) = TRUE]&#8288;</code> <br /> Indicates if observed steps are to be included in the result.</p>
</td></tr>
<tr><td><code id="random_steps_+3A_start_id">start_id</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> Index where the numbering for step ids start.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> of class random_steps.
</p>

<hr>
<h2 id='random_steps_simple'>Simulate from an ssf model</h2><span id='topic+random_steps_simple'></span>

<h3>Description</h3>

<p>Simulate from an ssf model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_steps_simple(start, sl_model, ta_model, n.control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_steps_simple_+3A_start">start</code></td>
<td>
<p>First step</p>
</td></tr>
<tr><td><code id="random_steps_simple_+3A_sl_model">sl_model</code></td>
<td>
<p>Step length model to use</p>
</td></tr>
<tr><td><code id="random_steps_simple_+3A_ta_model">ta_model</code></td>
<td>
<p>Turning angle model to use</p>
</td></tr>
<tr><td><code id="random_steps_simple_+3A_n.control">n.control</code></td>
<td>
<p>How many alternative steps are considered each step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulated trajectory
</p>

<hr>
<h2 id='range'>Geographic range</h2><span id='topic+range'></span><span id='topic+range_x'></span><span id='topic+range_x.track_xy'></span><span id='topic+range_y'></span><span id='topic+range_y.track_xy'></span><span id='topic+range_both'></span><span id='topic+range_both.track_xy'></span>

<h3>Description</h3>

<p>The range that in either <code>x</code>, <code>y</code> or <code>both</code> directions, that a track covers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_x(x, ...)

## S3 method for class 'track_xy'
range_x(x, ...)

range_y(x, ...)

## S3 method for class 'track_xy'
range_y(x, ...)

range_both(x, ...)

## S3 method for class 'track_xy'
range_both(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="range_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the range.
</p>

<hr>
<h2 id='redistribution_kernel'>Create a redistribution kernel</h2><span id='topic+redistribution_kernel'></span>

<h3>Description</h3>

<p>From a fitted integrated step-selection function for a given position a
redistribution kernel is calculated (i.e., the product of the movement kernel
and the selection function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redistribution_kernel(
  x = make_issf_model(),
  start = make_start(),
  map,
  fun = function(xy, map) {
     extract_covariates(xy, map, where = "both")
 },
  covars = NULL,
  max.dist = get_max_dist(x),
  n.control = 1e+06,
  n.sample = 1,
  stochastic = FALSE,
  compensate.movement = !stochastic,
  normalize = TRUE,
  interpolate = FALSE,
  as.rast = FALSE,
  tolerance.outside = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redistribution_kernel_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[fit_issf]&#8288;</code> <br /> A fitted integrated step-selection function. Generated either with <code>fit_issf()</code> or make <code>make_issf_model()</code>.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_start">start</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[sim_start]&#8288;</code> <br /> The start position in space and time. See <code>make_start()</code>.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_map">map</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[SpatRaster]&#8288;</code> <br /> A SpatRaster with all covariates.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_fun">fun</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[function]&#8288;</code> <br /> A function that is executed on each location of the redistribution kernel. The default function is <code>extract_covariates()</code>.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_covars">covars</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tibble]&#8288;</code> <br /> Additional covariates that might be used in the model (e.g., time of day).</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_max.dist">max.dist</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]&#8288;</code> <br /> The maximum distance of the redistribution kernel.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_n.control">n.control</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]{1e6}&#8288;</code> <br /> The number of points of the redistribution kernel (this is only important if <code>stochastic = TRUE</code>).</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_n.sample">n.sample</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]{1}&#8288;</code> <br /> The number of points sampled from the redistribution kernel (this is only important if <code>as.rast = FALSE</code>).</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_stochastic">stochastic</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]{FALSE}&#8288;</code> <br /> If <code>TRUE</code> the redistribution kernel is sampled using a random sample of size <code>n.control</code>. Otherwise each cell in the redistribution kernel is used.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_compensate.movement">compensate.movement</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> <br /> Indicates if movement parameters are corrected or not. This only relevant if <code>stochastic = FALSE</code>.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_normalize">normalize</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]{TRUE}&#8288;</code> <br /> If <code>TRUE</code> the redistribution kernel is normalized to sum to one.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_interpolate">interpolate</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]{FALSE}&#8288;</code> <br /> If <code>TRUE</code> a stochastic redistribution kernel is interpolated to return a raster layer. Note, this is just for completeness and is computationally inefficient in most situations.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_as.rast">as.rast</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]{TRUE}&#8288;</code> <br /> If <code>TRUE</code> a <code>SpatRaster</code> should be returned.</p>
</td></tr>
<tr><td><code id="redistribution_kernel_+3A_tolerance.outside">tolerance.outside</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]{0}&#8288;</code> <br /> The proportion of the redistribution kernel that is allowed to be outside the <code>map</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+arrange'></span><span id='topic+filter'></span><span id='topic+group_by'></span><span id='topic+select'></span><span id='topic+summarise'></span><span id='topic+summarize'></span><span id='topic+ungroup'></span><span id='topic+distinct'></span><span id='topic+mutate'></span><span id='topic+pull'></span><span id='topic+hours'></span><span id='topic+minutes'></span><span id='topic+seconds'></span><span id='topic+days'></span><span id='topic+weeks'></span><span id='topic+map'></span><span id='topic+map_int'></span><span id='topic+NA_crs_'></span><span id='topic+clogit'></span><span id='topic+strata'></span><span id='topic+nest'></span><span id='topic+unnest'></span><span id='topic+tibble'></span><span id='topic+Surv'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+distinct">distinct</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+pull">pull</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+summarise">summarise</a></code>, <code><a href="dplyr.html#topic+summarise">summarize</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>lubridate</dt><dd><p><code><a href="lubridate.html#topic+period">days</a></code>, <code><a href="lubridate.html#topic+period">hours</a></code>, <code><a href="lubridate.html#topic+period">minutes</a></code>, <code><a href="lubridate.html#topic+period">seconds</a></code>, <code><a href="lubridate.html#topic+period">weeks</a></code></p>
</dd>
<dt>purrr</dt><dd><p><code><a href="purrr.html#topic+map">map</a></code>, <code><a href="purrr.html#topic+map">map_int</a></code></p>
</dd>
<dt>sf</dt><dd><p><code><a href="sf.html#topic+st_crs">NA_crs_</a></code></p>
</dd>
<dt>survival</dt><dd><p><code><a href="survival.html#topic+clogit">clogit</a></code>, <code><a href="survival.html#topic+strata">strata</a></code>, <code><a href="survival.html#topic+Surv">Surv</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+tibble">tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+nest">nest</a></code>, <code><a href="tidyr.html#topic+unnest">unnest</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_capture'>Removes Capture Effects</h2><span id='topic+remove_capture'></span><span id='topic+remove_capture_effect'></span><span id='topic+remove_capture_effect.track_xyt'></span>

<h3>Description</h3>

<p>Removing relocations at the beginning and/or end of a track, that fall within a user specified period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_capture_effect(x, ...)

## S3 method for class 'track_xyt'
remove_capture_effect(x, start, end, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_capture_+3A_x">x</code></td>
<td>
<p>An object of class <code>track_xyt</code>.</p>
</td></tr>
<tr><td><code id="remove_capture_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="remove_capture_+3A_start">start</code></td>
<td>
<p>A <code>lubirdate::Period</code>, indicating the time period to be removed at the beginning of the track.</p>
</td></tr>
<tr><td><code id="remove_capture_+3A_end">end</code></td>
<td>
<p>A <code>lubirdate::Period</code>, indicating the time period to be removed at the end of the track.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> without observations that fall within the period of the capture effect.
</p>

<hr>
<h2 id='remove_incomplete_strata'>Remove strata with missing values for observed steps</h2><span id='topic+remove_incomplete_strata'></span><span id='topic+remove_incomplete_strata.random_steps'></span>

<h3>Description</h3>

<p>Remove strata with missing values for observed steps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_incomplete_strata(x, ...)

## S3 method for class 'random_steps'
remove_incomplete_strata(x, col = "ta_", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_incomplete_strata_+3A_x">x</code></td>
<td>
<p>An object of class <code>random_steps</code>.</p>
</td></tr>
<tr><td><code id="remove_incomplete_strata_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="remove_incomplete_strata_+3A_col">col</code></td>
<td>
<p>A character with the column name that will be scanned for missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>random_steps</code>, where observed steps (<code>case_ == TRUE</code>) with missing values (<code>NA</code>) in the column <code>col</code> are removed (including all random steps).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mini_deer &lt;- deer[1:4, ]

# The first step is removed, because we have `NA` turn angles.
mini_deer |&gt; steps() |&gt; random_steps() |&gt; remove_incomplete_strata() |&gt;
  select(case_, ta_, step_id_)
</code></pre>

<hr>
<h2 id='sampling_period'>Extract sampling period</h2><span id='topic+sampling_period'></span>

<h3>Description</h3>

<p>Extracts sampling period from a <code>track_xyt</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_period(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampling_period_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> A <code>track_xyt</code> object.</p>
</td></tr>
<tr><td><code id="sampling_period_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>

<hr>
<h2 id='sdr'>Calculate SDR for an Object</h2><span id='topic+sdr'></span><span id='topic+sdr.track_xyt'></span>

<h3>Description</h3>

<p>Calculates SDR for an object of certain class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdr(x, time_unit = "secs", append_na = TRUE, ...)

## S3 method for class 'track_xyt'
sdr(x, time_unit = "secs", append_na = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdr_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> Object to calculate SDR from. Currently implemented
for <code>track_xyt</code>.</p>
</td></tr>
<tr><td><code id="sdr_+3A_time_unit">time_unit</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Character string giving time unit. Should be
<code>"secs"</code>, <code>"mins"</code>, or <code>"hours"</code>.</p>
</td></tr>
<tr><td><code id="sdr_+3A_append_na">append_na</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Should <code>NA</code> be appended to the end of the vector?
Ensures <code>length(result) == nrow(x)</code> if appending as a column of <code>x</code>.</p>
</td></tr>
<tr><td><code id="sdr_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>time_unit</code> defaults to seconds because <code><a href="#topic+calculate_sdr">calculate_sdr</a>()</code>
returns SDR in m^2/s. We assume the user is also working in a projected
CRS with units in meters, thus we expect SDR in m^2/s to be most relevant.
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith and Johannes Signer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculate_sdr">calculate_sdr</a>()</code>, <code><a href="#topic+get_displacement">get_displacement</a>()</code>
</p>

<hr>
<h2 id='sh'>Relocations of one Red Deer</h2><span id='topic+sh'></span>

<h3>Description</h3>

<p>1500 GPS fixes of one red deer from northern Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sh
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 rows and 4 variables:
</p>

<dl>
<dt>x_epsg31467</dt><dd><p>the x-coordinate</p>
</dd>
<dt>y_epsg31467</dt><dd><p>the y-coordinate</p>
</dd>
<dt>day</dt><dd><p>the day of the relocation</p>
</dd>
<dt>time</dt><dd><p>the hour of the relocation</p>
</dd>
</dl>



<h3>Source</h3>

<p>Verein für Wildtierforschung Dresden und Göttingen e.V.
</p>

<hr>
<h2 id='sh_forest'>Forest cover</h2><span id='topic+sh_forest'></span>

<h3>Description</h3>

<p>Forest cover for the home range of one red deer from northern Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sh_forest
</code></pre>


<h3>Format</h3>

<p>A <code>SpatRast</code> </p>
 <dl>
<dt>0</dt><dd><p>other</p>
</dd> <dt>1</dt><dd><p>forest</p>
</dd> </dl>



<h3>Source</h3>

<p>JRC
</p>


<h3>References</h3>

<p>A. Pekkarinen, L. Reithmaier, P. Strobl (2007): Pan-European
Forest/Non-Forest mapping with Landsat ETM+ and CORINE Land Cover 2000
data.
</p>

<hr>
<h2 id='simulate_path'>Simulate a movement trajectory.</h2><span id='topic+simulate_path'></span><span id='topic+simulate_path.default'></span><span id='topic+simulate_path.redistribution_kernel'></span>

<h3>Description</h3>

<p>Function to simulate a movement trajectory (path) from a redistribution kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_path(x, ...)

## Default S3 method:
simulate_path(x, ...)

## S3 method for class 'redistribution_kernel'
simulate_path(x, n.steps = 100, start = x$args$start, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_path_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[redstirubtion_kernel(1)]&#8288;</code> <br /> An object of class <code>redistribution_kernel</code>.</p>
</td></tr>
<tr><td><code id="simulate_path_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="simulate_path_+3A_n.steps">n.steps</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]{100}&#8288;</code> <br /> The number of simulation steps.</p>
</td></tr>
<tr><td><code id="simulate_path_+3A_start">start</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[sim_start]&#8288;</code> <br /> The starting point in time and space for the simulations (see <code>make_start()</code>).</p>
</td></tr>
<tr><td><code id="simulate_path_+3A_verbose">verbose</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]{FALSE}&#8288;</code> If <code>TRUE</code> progress of simulations is displayed.</p>
</td></tr>
</table>

<hr>
<h2 id='site_fidelity'>Test for site fidelity of animal movement.</h2><span id='topic+site_fidelity'></span><span id='topic+site_fidelity.steps_xy'></span>

<h3>Description</h3>

<p>Calculates two indices (mean squared displacement and linearity) to test for site fidelity. Significance testing is done by permuting step lengths and drawing turning angles from a uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_fidelity(x, ...)

## S3 method for class 'steps_xy'
site_fidelity(x, n = 100, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="site_fidelity_+3A_x">x</code></td>
<td>
<p>A track</p>
</td></tr>
<tr><td><code id="site_fidelity_+3A_...">...</code></td>
<td>
<p>None implemented</p>
</td></tr>
<tr><td><code id="site_fidelity_+3A_n">n</code></td>
<td>
<p>Numeric scalar. The number of simulated trajectories.</p>
</td></tr>
<tr><td><code id="site_fidelity_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar. The alpha value used for the bootstrapping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 4. <code>msd_dat</code> and <code>li_dat</code> is the mean square distance and linearity for the real date. <code>msd_sim</code> and 'li_sim&ldquo; are the mean square distances and linearities for the simulated trajectories.
</p>


<h3>References</h3>

<p>Spencer, S. R., Cameron, G. N., &amp; Swihart, R. K. (1990). Operationally defining home range: temporal dependence exhibited by hispid cotton rats. Ecology, 1817-1822.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># real data

data(deer)
ds &lt;- deer |&gt; steps_by_burst()
site_fidelity(ds)

</code></pre>

<hr>
<h2 id='speed'>Speed</h2><span id='topic+speed'></span><span id='topic+speed.track_xyt'></span>

<h3>Description</h3>

<p>Obtain the speed of a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>speed(x, ...)

## S3 method for class 'track_xyt'
speed(x, append_na = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="speed_+3A_x">x</code></td>
<td>
<p>A <code>track_xyt</code>.</p>
</td></tr>
<tr><td><code id="speed_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="speed_+3A_append_na">append_na</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> Should an <code>NA</code> be appended at the end.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The speed in <code>m/s</code>.
</p>

<hr>
<h2 id='ssf_formula'>Takes a <code>clogit</code> formula and returns a formula without the <code>strata</code> and the
left-hand side</h2><span id='topic+ssf_formula'></span>

<h3>Description</h3>

<p>Takes a <code>clogit</code> formula and returns a formula without the <code>strata</code> and the
left-hand side
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssf_formula(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssf_formula_+3A_formula">formula</code></td>
<td>
<p>A formula object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- case_ ~ x1 * x2 + strata(step_id_)
ssf_formula(f1)
</code></pre>

<hr>
<h2 id='ssf_weights'>Given a fitted ssf, and new location the weights for each location is
calculated</h2><span id='topic+ssf_weights'></span>

<h3>Description</h3>

<p>Given a fitted ssf, and new location the weights for each location is
calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssf_weights(xy, object, compensate.movement = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssf_weights_+3A_xy">xy</code></td>
<td>
<p>The new locations.</p>
</td></tr>
<tr><td><code id="ssf_weights_+3A_object">object</code></td>
<td>
<p>The the fitted (i)SSF.</p>
</td></tr>
<tr><td><code id="ssf_weights_+3A_compensate.movement">compensate.movement</code></td>
<td>
<p>Whether or not for the transformation from polar
to Cartesian coordinates is corrected.</p>
</td></tr>
</table>

<hr>
<h2 id='steps'>Functions to create and work with steps</h2><span id='topic+steps'></span><span id='topic+direction_abs'></span><span id='topic+direction_abs.track_xy'></span><span id='topic+direction_rel'></span><span id='topic+direction_rel.track_xy'></span><span id='topic+step_lengths'></span><span id='topic+step_lengths.track_xy'></span><span id='topic+steps_by_burst'></span><span id='topic+steps_by_burst.track_xyt'></span><span id='topic+steps.track_xy'></span><span id='topic+steps.track_xyt'></span>

<h3>Description</h3>

<p><code>step_lengths</code> can be use to calculate step lengths of a track. <code>direction_abs</code> and <code>direction_rel</code> calculate the absolute and relative direction of steps. <code>steps</code> converts a <code style="white-space: pre;">&#8288;track_xy*&#8288;</code> from a point representation to a step representation and automatically calculates step lengths and relative turning angles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direction_abs(x, ...)

## S3 method for class 'track_xy'
direction_abs(
  x,
  full_circle = FALSE,
  zero_dir = "E",
  clockwise = FALSE,
  append_last = TRUE,
  lonlat = FALSE,
  ...
)

direction_rel(x, ...)

## S3 method for class 'track_xy'
direction_rel(x, lonlat = FALSE, append_last = TRUE, zero_dir = "E", ...)

step_lengths(x, ...)

## S3 method for class 'track_xy'
step_lengths(x, lonlat = FALSE, append_last = TRUE, ...)

steps_by_burst(x, ...)

## S3 method for class 'track_xyt'
steps_by_burst(x, lonlat = FALSE, keep_cols = NULL, ...)

steps(x, ...)

## S3 method for class 'track_xy'
steps(x, lonlat = FALSE, keep_cols = NULL, ...)

## S3 method for class 'track_xyt'
steps(x, lonlat = FALSE, keep_cols = NULL, diff_time_units = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steps_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="steps_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented</p>
</td></tr>
<tr><td><code id="steps_+3A_full_circle">full_circle</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> If <code>TRUE</code> angles are returned between 0 and $2pi$, otherwise angles are between $-pi$ and $pi$.</p>
</td></tr>
<tr><td><code id="steps_+3A_zero_dir">zero_dir</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)='E']&#8288;</code> <br /> Indicating the zero direction. Must be either <code>N</code>, <code>E</code>, <code>S</code>, or <code>W</code>.</p>
</td></tr>
<tr><td><code id="steps_+3A_clockwise">clockwise</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> Should angles be calculated clock or anti-clockwise?</p>
</td></tr>
<tr><td><code id="steps_+3A_append_last">append_last</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> If <code>TRUE</code> an <code>NA</code> is appended at the end of all angles.</p>
</td></tr>
<tr><td><code id="steps_+3A_lonlat">lonlat</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code> <br /> Should geographical or planar coordinates be used? If <code>TRUE</code> geographic distances are calculated.</p>
</td></tr>
<tr><td><code id="steps_+3A_keep_cols">keep_cols</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)=NULL]{'start', 'end', 'both'}&#8288;</code> <br /> Should columns with attribute information be transferred to steps? If <code>keep_cols = 'start'</code> the attributes from the starting point are use, otherwise the columns from the end points are used.</p>
</td></tr>
<tr><td><code id="steps_+3A_diff_time_units">diff_time_units</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)='auto']&#8288;</code> <br /> The unit for time differences, see <code>?difftime</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;dierctions_*()&#8288;</code> returns <code>NA</code> for 0 step lengths.
</p>
<p><code>step_lengths</code> calculates the step lengths between points a long the path. The last value returned is <code>NA</code>, because no observed step is 'started' at the last point. If <code>lonlat = TRUE</code>, <code>step_lengths()</code> wraps <code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code>.
</p>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> For <code>step_lengths()</code> and <code style="white-space: pre;">&#8288;direction_*&#8288;</code> a numeric vector. <br />
<code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> For <code>steps</code> and <code>steps_by_burst</code>, containing the steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xy &lt;- tibble(
  x = c(1, 4, 8, 8, 12, 12, 8, 0, 0, 4, 2),
  y = c(0, 0, 0, 8, 12, 12, 12, 12, 8, 4, 2))
trk &lt;- make_track(xy, x, y)

# append last
direction_abs(trk, append_last = TRUE)
direction_abs(trk, append_last = FALSE)

# degrees
direction_abs(trk) |&gt; as_degree()

# full circle or not: check
direction_abs(trk, full_circle = TRUE)
direction_abs(trk, full_circle = FALSE)
direction_abs(trk, full_circle = TRUE) |&gt; as_degree()
direction_abs(trk, full_circle = FALSE) |&gt; as_degree()

# direction of 0
direction_abs(trk, full_circle = TRUE, zero_dir = "N")
direction_abs(trk, full_circle = TRUE, zero_dir = "E")
direction_abs(trk, full_circle = TRUE, zero_dir = "S")
direction_abs(trk, full_circle = TRUE, zero_dir = "W")

# clockwise or not
direction_abs(trk, full_circle = TRUE, zero_dir = "N", clockwise = FALSE)
direction_abs(trk, full_circle = TRUE, zero_dir = "N", clockwise = TRUE)

# Bearing (i.e. azimuth): only for lon/lat
direction_abs(trk, full_circle = FALSE, zero_dir = "N", lonlat = FALSE, clockwise = TRUE)
direction_abs(trk, full_circle = FALSE, zero_dir = "N", lonlat = TRUE, clockwise = TRUE)

</code></pre>

<hr>
<h2 id='summarize_sampling_rate'>Returns a summary of sampling rates</h2><span id='topic+summarize_sampling_rate'></span><span id='topic+summarize_sampling_rate.track_xyt'></span><span id='topic+summarize_sampling_rate_many'></span><span id='topic+summarize_sampling_rate_many.track_xyt'></span>

<h3>Description</h3>

<p>Returns a summary of sampling rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_sampling_rate(x, ...)

## S3 method for class 'track_xyt'
summarize_sampling_rate(
  x,
  time_unit = "auto",
  summarize = TRUE,
  as_tibble = TRUE,
  ...
)

summarize_sampling_rate_many(x, ...)

## S3 method for class 'track_xyt'
summarize_sampling_rate_many(x, cols, time_unit = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_sampling_rate_+3A_x">x</code></td>
<td>
<p>A <code>track_xyt</code>.</p>
</td></tr>
<tr><td><code id="summarize_sampling_rate_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="summarize_sampling_rate_+3A_time_unit">time_unit</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1) = "auto"]&#8288;</code> <br /> Which time unit will be used.</p>
</td></tr>
<tr><td><code id="summarize_sampling_rate_+3A_summarize">summarize</code></td>
<td>
<p>A logical. If <code>TRUE</code> a summary is returned, otherwise raw
sampling intervals are returned.</p>
</td></tr>
<tr><td><code id="summarize_sampling_rate_+3A_as_tibble">as_tibble</code></td>
<td>
<p>A logical. Should result be returned as <code>tibble</code> or as
<code>table</code>.</p>
</td></tr>
<tr><td><code id="summarize_sampling_rate_+3A_cols">cols</code></td>
<td>
<p>Columns used for grouping.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on <code>summarize</code> and <code>as_tibble</code>, a vector, table or tibble.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
amt::summarize_sampling_rate(deer)

data(amt_fisher)
# Add the month
amt_fisher |&gt; mutate(yday = lubridate::yday(t_)) |&gt;
summarize_sampling_rate_many(c("id", "yday"))

</code></pre>

<hr>
<h2 id='summarize_sl'>Summarize step lengths</h2><span id='topic+summarize_sl'></span>

<h3>Description</h3>

<p>Summarizes step lengths for a <code style="white-space: pre;">&#8288;track_xy*&#8288;</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_sl(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_sl_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xy, track_xyt]&#8288;</code> A <code style="white-space: pre;">&#8288;track_xy*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="summarize_sl_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>

<hr>
<h2 id='summarize_speed'>Summarize speed</h2><span id='topic+summarize_speed'></span>

<h3>Description</h3>

<p>Summarizes speeds for a <code>track_xyt</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_speed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_speed_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt]&#8288;</code> A <code>track_xyt</code> object.</p>
</td></tr>
<tr><td><code id="summarize_speed_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
</table>

<hr>
<h2 id='time_of_day'>Time of the day when a fix was taken</h2><span id='topic+time_of_day'></span><span id='topic+time_of_day.track_xyt'></span><span id='topic+time_of_day.steps_xyt'></span>

<h3>Description</h3>

<p>A convenience wrapper around <code>suncalc::getSunlightTimes</code> to annotate if a fix was taken during day or night (optionally also include dawn and dusk).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_of_day(x, ...)

## S3 method for class 'track_xyt'
time_of_day(x, include.crepuscule = FALSE, ...)

## S3 method for class 'steps_xyt'
time_of_day(x, include.crepuscule = FALSE, where = "end", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_of_day_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xyt,steps_xyt]&#8288;</code><br /> A track or steps.</p>
</td></tr>
<tr><td><code id="time_of_day_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="time_of_day_+3A_include.crepuscule">include.crepuscule</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=TRUE]&#8288;</code><br /> Should dawn and dusk be included.</p>
</td></tr>
<tr><td><code id="time_of_day_+3A_where">where</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)="end"]{"start", "end", "both"}&#8288;</code> For <code>steps</code>, should the start, end or both time points be used?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> with an additional column <code>tod_</code> that contains the time of the day for each relocation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
deer |&gt; time_of_day()
deer |&gt; steps_by_burst() |&gt; time_of_day()
deer |&gt; steps_by_burst() |&gt; time_of_day(where = "start")
deer |&gt; steps_by_burst() |&gt; time_of_day(where = "end")
deer |&gt; steps_by_burst() |&gt; time_of_day(where = "both")

</code></pre>

<hr>
<h2 id='track'>Create a <code style="white-space: pre;">&#8288;track_*&#8288;</code></h2><span id='topic+track'></span><span id='topic+mk_track'></span><span id='topic+make_track'></span>

<h3>Description</h3>

<p>Constructor to crate a track, the basic building block of the <code>amt</code> package. A
<code>track</code> is usually created from a set of <code>x</code> and <code>y</code> coordinates, possibly
time stamps, and any number of optional columns, such as id, sex, age, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_track(
  tbl,
  .x,
  .y,
  .t,
  ...,
  crs = NA_crs_,
  order_by_ts = TRUE,
  check_duplicates = FALSE,
  all_cols = FALSE,
  verbose = FALSE
)

make_track(
  tbl,
  .x,
  .y,
  .t,
  ...,
  crs = NA_crs_,
  order_by_ts = TRUE,
  check_duplicates = FALSE,
  all_cols = FALSE,
  verbose = FALSE
)

track(x, y, t, ..., crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_+3A_tbl">tbl</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> <br /> The <code>data.frame</code> from which a track should be
created.</p>
</td></tr>
<tr><td><code id="track_+3A_.x">.x</code>, <code id="track_+3A_.y">.y</code>, <code id="track_+3A_.t">.t</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[expression(1)]&#8288;</code> <br /> Unquoted variable names of columns
containing the x and y coordinates, and optionally a time stamp.</p>
</td></tr>
<tr><td><code id="track_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[expression]&#8288;</code> <br /> Additional columns from <code>tbl</code> to be used in a
track. Columns should be provided in the form of <code>key = val</code> (e.g., for ids
this may look like this <code style="white-space: pre;">&#8288;id = c(1, 1, 1, 2, 2, 2&#8288;</code> for three points for ids
1 and 2 each).</p>
</td></tr>
<tr><td><code id="track_+3A_crs">crs</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[crs]&#8288;</code> <br /> An optional coordinate reference system of the
points. Usually just the <code>epsg</code> code is sufficient.</p>
</td></tr>
<tr><td><code id="track_+3A_order_by_ts">order_by_ts</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> <br /> Should relocations be ordered by time
stamp, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="track_+3A_check_duplicates">check_duplicates</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> Should it be checked if there are
duplicated time stamp, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="track_+3A_all_cols">all_cols</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> Should all columns be carried over to the track object, default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="track_+3A_verbose">verbose</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)=FALSE]&#8288;</code> <br /> Inform when tracks are created.</p>
</td></tr>
<tr><td><code id="track_+3A_x">x</code>, <code id="track_+3A_y">y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The x and y coordinates.</p>
</td></tr>
<tr><td><code id="track_+3A_t">t</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[POSIXct]&#8288;</code> <br /> The time stamp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>t</code> was provided an object of class <code>track_xyt</code> is returned
otherwise a <code>track_xy</code>.
</p>

<hr>
<h2 id='track_resample'>Resample track</h2><span id='topic+track_resample'></span><span id='topic+track_resample.track_xyt'></span>

<h3>Description</h3>

<p>Function to resample a track at a predefined sampling rate within some tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>track_resample(x, ...)

## S3 method for class 'track_xyt'
track_resample(x, rate = hours(2), tolerance = minutes(15), start = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="track_resample_+3A_x">x</code></td>
<td>
<p>A <code>track_xyt</code>.</p>
</td></tr>
<tr><td><code id="track_resample_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="track_resample_+3A_rate">rate</code></td>
<td>
<p>A lubridate <code>Period</code>, that indicates the sampling rate.</p>
</td></tr>
<tr><td><code id="track_resample_+3A_tolerance">tolerance</code></td>
<td>
<p>A lubridate <code>Period</code>, that indicates the tolerance of deviations of the sampling rate.</p>
</td></tr>
<tr><td><code id="track_resample_+3A_start">start</code></td>
<td>
<p>A integer scalar, that gives the relocation at which the sampling rate starts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A resampled <code>track_xyt</code>.
</p>

<hr>
<h2 id='tracked_from_to'>Subset to tracking dates</h2><span id='topic+tracked_from_to'></span>

<h3>Description</h3>

<p>Subsets a <code>track_xyt</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracked_from_to(x, from = min(x$t_), to = max(x$t_))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracked_from_to_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[track_xy, track_xyt]&#8288;</code> A <code style="white-space: pre;">&#8288;track_xy*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="tracked_from_to_+3A_from">from</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[POSIXt]&#8288;</code> A date and time defining start of subset.</p>
</td></tr>
<tr><td><code id="tracked_from_to_+3A_to">to</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[POSIXt]&#8288;</code> A date and time defining end of subset.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_coords'>Transform CRS</h2><span id='topic+transform_coords'></span><span id='topic+transform_coords.track_xy'></span><span id='topic+transform_crs'></span>

<h3>Description</h3>

<p>Transforms the CRS for a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_coords(x, ...)

## S3 method for class 'track_xy'
transform_coords(x, crs_to, crs_from, ...)

transform_crs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_coords_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="transform_coords_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="transform_coords_+3A_crs_to">crs_to</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[crs(1)]&#8288;</code> <br /> Coordinate reference system the data should be transformed to, see <code>sf::st_crs</code>.</p>
</td></tr>
<tr><td><code id="transform_coords_+3A_crs_from">crs_from</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[crs(1)]&#8288;</code> <br /> Coordinate reference system the data are currently in, see <code>sf::sf_crs</code>. If <code>crs_from</code> is missing, the <code>crs</code>-attribute of the track is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A track with transformed coordinates.
</p>


<h3>See Also</h3>

<p><code>sf::st_transform</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(deer)
get_crs(deer)

# project to geographical coordinates (note the CRS is taken automatically from the object deer).
d1 &lt;- transform_coords(deer, crs_to = 4326)
</code></pre>

<hr>
<h2 id='trast'>Create a template raster layer</h2><span id='topic+trast'></span><span id='topic+make_trast'></span><span id='topic+make_trast.track_xy'></span>

<h3>Description</h3>

<p>For some home-range estimation methods (e.g., KDE) a template raster is needed. This functions helps to quickly create such a template raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_trast(x, ...)

## S3 method for class 'track_xy'
make_trast(x, factor = 1.5, res = max(c(extent_max(x)/100, 1e-09)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trast_+3A_x">x</code></td>
<td>
<p><code>[track_xy, track_xyt]</code> <br /> A track created with <code>make_track</code>.</p>
</td></tr>
<tr><td><code id="trast_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="trast_+3A_factor">factor</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)=1.5]{&gt;= 1}&#8288;</code><br /> Factor by which the extent of the relocations is extended.</p>
</td></tr>
<tr><td><code id="trast_+3A_res">res</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]&#8288;</code><br /> Resolution of the output raster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RastLayer</code> without values.
</p>

<hr>
<h2 id='ua_distr'>Summarize distribution of used and available</h2><span id='topic+ua_distr'></span>

<h3>Description</h3>

<p>Internal function to summarize distribution of numeric or factor variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ua_distr(name, type, data, lims, resp, n_dens, avail = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ua_distr_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Name of the column to summarize.</p>
</td></tr>
<tr><td><code id="ua_distr_+3A_type">type</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Either <code>"numeric"</code> or <code>"factor"</code> as returned by
<code><a href="#topic+prep_test_dat">prep_test_dat</a>()</code>.</p>
</td></tr>
<tr><td><code id="ua_distr_+3A_data">data</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[data.frame]&#8288;</code> The <code>data.frame</code> containing the columns and the
response variable.</p>
</td></tr>
<tr><td><code id="ua_distr_+3A_lims">lims</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(2)]&#8288;</code> A <code>numeric</code> vector of length 2 containing the
range for the density calculation for all variables where <code>type == "numeric"</code>
as returned by <code><a href="#topic+prep_test_dat">prep_test_dat</a>()</code>. Will be passed to
<code>stats::density.default()</code> arguments <code>from</code> and <code>to</code>.</p>
</td></tr>
<tr><td><code id="ua_distr_+3A_resp">resp</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> Name of the response variable.</p>
</td></tr>
<tr><td><code id="ua_distr_+3A_n_dens">n_dens</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> A <code>numeric</code> vector of length 1 giving the number of
equally spaced points at which density (used, available, and sampled) is
estimated. Passed to <code>stats::density.default()</code>, which indicates that <code>n</code>
should usually be specified as a power of 2.</p>
</td></tr>
<tr><td><code id="ua_distr_+3A_avail">avail</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code> Should distribution be calculated for the available
locations? Defaults to <code>TRUE</code>, but should be false when summarizing the
bootstrapped &quot;used&quot; samples.</p>
</td></tr>
</table>

<hr>
<h2 id='uhc_hab'>Simulated habitat rasters for demonstrating UHC plots</h2><span id='topic+uhc_hab'></span>

<h3>Description</h3>

<p>Simulated habitat rasters for demonstrating UHC plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uhc_hab
</code></pre>


<h3>Format</h3>

<p>A <code>RasterStack</code> with 1600 cells and 7 variables:
</p>

<dl>
<dt>forage</dt><dd><p>Forage biomass in g/m^2^ (resource)</p>
</dd>
<dt>temp</dt><dd><p>mean annual temperature in °C (condition)</p>
</dd>
<dt>pred</dt><dd><p>predator density in predators/100 km^2^ (risk)</p>
</dd>
<dt>cover</dt><dd><p>landcover (forest &gt; grassland &gt; wetland)</p>
</dd>
<dt>dist_to_water</dt><dd><p>distance to the wetland landcover (no effect)</p>
</dd>
<dt>dist_to_cent</dt><dd><p>distance to the centroid of the raster (no effect)</p>
</dd>
<dt>rand</dt><dd><p>random integers (no effect)</p>
</dd>
</dl>


<hr>
<h2 id='uhc_hsf_locs'>Simulated HSF location data for demonstrating UHC plots</h2><span id='topic+uhc_hsf_locs'></span>

<h3>Description</h3>

<p>Simulated HSF location data for demonstrating UHC plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uhc_hsf_locs
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2000 rows and 2 variables:
</p>

<dl>
<dt>x</dt><dd><p>x-coordinate in UTM Zone 12 (EPSG: 32612)</p>
</dd>
<dt>y</dt><dd><p>Y-coordinate in UTM Zone 12 (EPSG: 32612)</p>
</dd>
</dl>

<p>These data were simulated assuming an ordinary habitat selection function
(HSF), i.e., all points are independent rather than arising from an
underlying movement model.
</p>
<p>True parameter values are:
</p>

<ul>
<li> <p><code>forage</code> = log(5)/500 (resource)
</p>
</li>
<li> <p><code>temp^2</code> = -1 * log(2)/36 (condition; quadratic term)
</p>
</li>
<li> <p><code>temp</code> = (log(2)/36) * 26 (condition; linear term)
</p>
</li>
<li> <p><code>pred</code> = log(0.25)/5 (risk)
</p>
</li>
<li> <p><code>cover == "forest"</code> = log(2) (grassland is intercept)
</p>
</li>
<li> <p><code>cover == "wetland"</code> = log(1/2) (grassland is intercept)
</p>
</li></ul>

<p>Note: <code>temp</code> is modeled as a quadratic term, with the strongest selection
occurring at 13 °C and all other temperatures less selected.
</p>
<p>Note: <code>dist_to_water</code>, <code>dist_to_cent</code>, and <code>rand</code> have no real effect
on our animal's selection and are included for demonstration purposes.
</p>

<hr>
<h2 id='uhc_issf_locs'>Simulated iSSF location data for demonstrating UHC plots</h2><span id='topic+uhc_issf_locs'></span>

<h3>Description</h3>

<p>Simulated iSSF location data for demonstrating UHC plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uhc_issf_locs
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 371 rows and 3 variables:
</p>

<dl>
<dt>x</dt><dd><p>x-coordinate in UTM Zone 12 (EPSG: 32612)</p>
</dd>
<dt>y</dt><dd><p>Y-coordinate in UTM Zone 12 (EPSG: 32612)</p>
</dd>
<dt>t</dt><dd><p>timestamp of location (timezone &quot;US/Mountain&quot;)</p>
</dd>
</dl>

<p>These data were simulated assuming an movement model, i.e., iSSA.
</p>
<p>True movement-free habitat selection parameter values are:
</p>

<ul>
<li> <p><code>forage</code> = log(8)/500 (resource)
</p>
</li>
<li> <p><code>temp^2</code> = -1 * log(8)/36 (condition; quadratic term)
</p>
</li>
<li> <p><code>temp</code> = (log(8)/36) * 26 (condition; linear term)
</p>
</li>
<li> <p><code>pred</code> = log(0.2)/5 (risk)
</p>
</li>
<li> <p><code>cover == "forest"</code> = log(2) (grassland is intercept)
</p>
</li>
<li> <p><code>cover == "wetland"</code> = log(1/2) (grassland is intercept)
</p>
</li>
<li> <p><code>dist_to_cent</code> = -1 * log(10)/500 (keeps trajectory away from boundary)
</p>
</li></ul>

<p>Note: <code>temp</code> is modeled as a quadratic term, with the strongest selection
occurring at 13 °C and all other temperatures less selected.
</p>
<p>Note: <code>dist_to_water</code> and <code>rand</code> have no real effect
on our animal's selection and are included for demonstration purposes.
</p>
<p>True selection-free movement distributions are:
</p>

<ul>
<li><p> Step length: <code>gamma(shape = 3, scale = 25)</code>
</p>
</li>
<li><p> Turn angle: <code>vonMises(mu = 0, kappa = 0.5)</code>
</p>
</li></ul>


<hr>
<h2 id='update_distr_man'>Manually update <code>amt_distr</code></h2><span id='topic+update_distr_man'></span><span id='topic+update_gamma'></span><span id='topic+update_exp'></span><span id='topic+update_hnorm'></span><span id='topic+update_lnorm'></span><span id='topic+update_vonmises'></span>

<h3>Description</h3>

<p>Functions to update <code>amt_distr</code> from iSSF coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_gamma(dist, beta_sl, beta_log_sl)

update_exp(dist, beta_sl)

update_hnorm(dist, beta_sl_sq)

update_lnorm(dist, beta_log_sl, beta_log_sl_sq)

update_vonmises(dist, beta_cos_ta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_distr_man_+3A_dist">dist</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[amt_distr]&#8288;</code> The tentative distribution to be updated
respective distributions.</p>
</td></tr>
<tr><td><code id="update_distr_man_+3A_beta_sl">beta_sl</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The estimate of the coefficient of the step length.</p>
</td></tr>
<tr><td><code id="update_distr_man_+3A_beta_log_sl">beta_log_sl</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The estimate of the coefficient of the log of the step length.</p>
</td></tr>
<tr><td><code id="update_distr_man_+3A_beta_sl_sq">beta_sl_sq</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of the square of the step length.</p>
</td></tr>
<tr><td><code id="update_distr_man_+3A_beta_log_sl_sq">beta_log_sl_sq</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of the square of log of the step length.</p>
</td></tr>
<tr><td><code id="update_distr_man_+3A_beta_cos_ta">beta_cos_ta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code> <br /> The estimate of the coefficient of cosine of the turning angle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called internally by
<code><a href="#topic+update_sl_distr">update_sl_distr</a>()</code> and <code><a href="#topic+update_ta_distr">update_ta_distr</a>()</code>.
However, those simple functions assume that the selection-free step-length
and turn-angle distributions are constant (i.e., they do not depend on
covariates). In the case of interactions between movement parameters and
covariates, the user will want to manually access these functions to update
their selection-free movement distributions.
</p>


<h3>Value</h3>

<p>A distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  sh_forest &lt;- get_sh_forest()
#  # Fit an SSF, then update movement parameters.
#
#   #Prepare data for SSF
#  ssf_data &lt;- deer |&gt;
#    steps_by_burst() |&gt;
#    random_steps(n = 15) |&gt;
#    extract_covariates(sh_forest) |&gt;
#    mutate(forest = factor(forest, levels = 1:0,
#                      labels = c("forest", "non-forest")),
#    cos_ta_ = cos(ta_),
#    log_sl_ = log(sl_))
#
#  # Check tentative distributions
#  #    Step length
#  attr(ssf_data, "sl_")
#  #    Turning angle
#  attr(ssf_data, "ta_")
#
#  # Fit an iSSF (note model = TRUE necessary for predict() to work)
#  m1 &lt;- ssf_data |&gt;
#    fit_issf(case_ ~ forest * (sl_ + log_sl_ + cos_ta_) +
#                 strata(step_id_), model = TRUE)
#
#  # Update forest step lengths (the reference level)
#  forest_sl &lt;- update_gamma(m1$sl_,
#                            beta_sl = m1$model$coefficients["sl_"],
#                            beta_log_sl = m1$model$coefficients["log_sl_"])
#
#  # Update non-forest step lengths
#  nonforest_sl &lt;- update_gamma(m1$sl_,
#                               beta_sl = m1$model$coefficients["sl_"] +
#                                 m1$model$coefficients["forestnon-forest:sl_"],
#                               beta_log_sl = m1$model$coefficients["log_sl_"] +
#                                 m1$model$coefficients["forestnon-forest:log_sl_"])
#
#  # Update forest turn angles (the reference level)
#  forest_ta &lt;- update_vonmises(m1$ta_,
#                               beta_cos_ta = m1$model$coefficients["cos_ta_"])
#
#  # Update non-forest turn angles
#  nonforest_ta &lt;- update_vonmises(m1$ta_,
#                                  beta_cos_ta = m1$model$coefficients["cos_ta_"] +
#                                    m1$model$coefficients["forestnon-forest:cos_ta_"])
#
</code></pre>

<hr>
<h2 id='update_sl_distr'>Update movement distributions</h2><span id='topic+update_sl_distr'></span><span id='topic+update_ta_distr'></span>

<h3>Description</h3>

<p>Update tentative step length or turning angle distribution from a fitted iSSF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_sl_distr(
  object,
  beta_sl = "sl_",
  beta_log_sl = "log_sl_",
  beta_sl_sq = "sl_sq_",
  beta_log_sl_sq = "log_sl_sq_",
  ...
)

update_ta_distr(object, beta_cos_ta = "cos_ta_", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_sl_distr_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[fit_clogit]&#8288;</code> <br /> A fitted iSSF model.</p>
</td></tr>
<tr><td><code id="update_sl_distr_+3A_beta_sl">beta_sl</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of the step length.</p>
</td></tr>
<tr><td><code id="update_sl_distr_+3A_beta_log_sl">beta_log_sl</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of the log of the step length.</p>
</td></tr>
<tr><td><code id="update_sl_distr_+3A_beta_sl_sq">beta_sl_sq</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of the square of the step length.</p>
</td></tr>
<tr><td><code id="update_sl_distr_+3A_beta_log_sl_sq">beta_log_sl_sq</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of the square of log of the step length.</p>
</td></tr>
<tr><td><code id="update_sl_distr_+3A_...">...</code></td>
<td>
<p>Further arguments, none implemented.</p>
</td></tr>
<tr><td><code id="update_sl_distr_+3A_beta_cos_ta">beta_cos_ta</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code> <br /> The name of the coefficient of cosine of the turning angle.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>amt_distr</code> object, which consists of a list with the <code>name</code> of
the distribution and its parameters (saved in <code>params</code>).
</p>


<h3>Author(s)</h3>

<p>Brian J. Smith and Johannes Signer
</p>


<h3>References</h3>

<p>Fieberg J, Signer J, Smith BJ, Avgar T (2020).
&ldquo;A “How-to” Guide for Interpreting Parameters in Resource-and Step-Selection Analyses.&rdquo;
<em>bioRxiv</em>.
</p>


<h3>See Also</h3>

<p>Wrapper to fit a distribution to data <code><a href="#topic+fit_distr">fit_distr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit an SSF, then update movement parameters.
data(deer)
mini_deer &lt;- deer[1:100, ]
sh_forest &lt;- get_sh_forest()

# Prepare data for SSF
ssf_data &lt;- mini_deer |&gt;
  steps_by_burst() |&gt;
  random_steps(n = 15) |&gt;
  extract_covariates(sh_forest) |&gt;
  mutate(forest = factor(forest, levels = 1:0,
                    labels = c("forest", "non-forest")),
  cos_ta_ = cos(ta_),
  log_sl_ = log(sl_))

# Check tentative distributions
# Step length
sl_distr_params(ssf_data)
attr(ssf_data, "sl_")
#    Turning angle
ta_distr_params(ssf_data)

# Fit an iSSF
m1 &lt;- ssf_data |&gt;
  fit_issf(case_ ~ forest +
               sl_ + log_sl_ + cos_ta_ +
               strata(step_id_))

# Update step length distribution
new_gamma &lt;- update_sl_distr(m1)

# Update turning angle distribution
new_vm &lt;- update_ta_distr(m1)

# It is also possible to use different step length distributions

# exponential step-length distribution
s2 &lt;- mini_deer |&gt; steps_by_burst()
s2 &lt;- random_steps(s2, sl_distr = fit_distr(s2$sl_, "exp"))
m2 &lt;- s2 |&gt;
  fit_clogit(case_ ~ sl_ + strata(step_id_))
update_sl_distr(m2)

# half normal step-length distribution
s3 &lt;- mini_deer |&gt; steps_by_burst()
s3 &lt;- random_steps(s3, sl_distr = fit_distr(s3$sl_, "hnorm"))
m3 &lt;- s3 |&gt;
  mutate(sl_sq_ = sl_^2) |&gt;
  fit_clogit(case_ ~ sl_sq_ + strata(step_id_))
update_sl_distr(m3)

# log normal step-length distribution
s4 &lt;- mini_deer |&gt; steps_by_burst()
s4 &lt;- random_steps(s4, sl_distr = fit_distr(s4$sl_, "lnorm"))
m4 &lt;- s4 |&gt;
  mutate(log_sl_ = log(sl_), log_sl_sq_ = log(sl_)^2) |&gt;
  fit_clogit(case_ ~ log_sl_ + log_sl_sq_ + strata(step_id_))
update_sl_distr(m4)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
