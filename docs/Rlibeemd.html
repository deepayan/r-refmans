<!DOCTYPE html><html><head><title>Help for package Rlibeemd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rlibeemd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rlibeemd'><p>Rlibeemd: Ensemble empirical mode decomposition (EEMD) and its complete variant (CEEMDAN)</p></a></li>
<li><a href='#bemd'><p>Bivariate EMD decomposition</p></a></li>
<li><a href='#ceemdan'><p>CEEMDAN decomposition</p></a></li>
<li><a href='#ECG'><p>Electrocardiogram Data</p>
</p>
<p>Example ECG data from MIT-BIH Normal Sinus Rhythm Database, ECG1 of record 16265,</p>
first 2049 observations (0 to 16 seconds with sampling interval of 0.0078125 seconds)</a></li>
<li><a href='#eemd'><p>EEMD Decomposition</p></a></li>
<li><a href='#emd'><p>EMD decomposition</p></a></li>
<li><a href='#extrema'><p>Local Extrema of Time Series</p></a></li>
<li><a href='#float'><p>Float Data</p>
</p>
<p>The data are a position record from an acoustically tracked subsurface oceanographic float,</p>
used as an example data in Rilling et al (2007).</a></li>
<li><a href='#nIMFs'><p>Number of IMFs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ensemble Empirical Mode Decomposition (EEMD) and Its Complete
Variant (CEEMDAN)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface for libeemd (Luukko, Helske, Räsänen, 2016) &lt;<a href="https://doi.org/10.1007%2Fs00180-015-0603-9">doi:10.1007/s00180-015-0603-9</a>&gt;, 
    a C library of highly efficient parallelizable functions  for performing the ensemble empirical mode decomposition (EEMD), 
    its complete variant (CEEMDAN), the regular empirical mode decomposition (EMD), and bivariate EMD (BEMD). 
    Due to the possible portability issues CRAN version no longer supports OpenMP, you can install OpenMP-supported version 
    from GitHub: <a href="https://github.com/helske/Rlibeemd/">https://github.com/helske/Rlibeemd/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU GSL</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp (&ge; 0.11.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/helske/Rlibeemd/issues">https://github.com/helske/Rlibeemd/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-04 12:20:46 UTC; jvhels</td>
</tr>
<tr>
<td>Author:</td>
<td>Jouni Helske <a href="https://orcid.org/0000-0001-7130-793X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (R interface),
  Perttu Luukko <a href="https://orcid.org/0000-0003-3786-9685"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (Original libeemd C library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jouni Helske &lt;jouni.helske@iki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 12:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rlibeemd'>Rlibeemd: Ensemble empirical mode decomposition (EEMD) and its complete variant (CEEMDAN)</h2><span id='topic+Rlibeemd'></span><span id='topic+Rlibeemd-package'></span>

<h3>Description</h3>

<p>Package Rlibeemd contains functions for the ensemble empirical mode decomposition (EEMD), 
its complete variant (CEEMDAN) or the regular empirical mode decomposition (EMD).
</p>


<h3>Details</h3>

<p>Package is based on the libeemd C library: <a href="https://bitbucket.org/luukko/libeemd">https://bitbucket.org/luukko/libeemd</a>
</p>


<h3>References</h3>


<ul>
<li><p>P. Luukko, J. Helske and E. Räsänen, 
&quot;Introducing libeemd: A program package for performing the ensemble empirical mode decomposition&quot;, Computational Statistics (2015).
</p>
</li>
<li><p> Z. Wu and N. Huang, &quot;Ensemble Empirical Mode Decomposition: A 
Noise-Assisted Data Analysis Method&quot;, Advances in Adaptive Data Analysis,
Vol. 1 (2009) 1&ndash;41.
</p>
</li>
<li><p> N. E. Huang, Z. Shen and S. R. Long, &quot;A new view of nonlinear water
waves: The Hilbert spectrum&quot;, Annual Review of Fluid Mechanics, Vol. 31
(1999) 417&ndash;457.
</p>
</li>
<li><p>Torres et al, A Complete Ensemble Empirical Mode Decomposition with Adaptive Noise
IEEE Int. Conf. on Acoust., Speech and Signal Proc. ICASSP-11,
(2011) 4144&ndash;4147.
</p>
</li></ul>


<hr>
<h2 id='bemd'>Bivariate EMD decomposition</h2><span id='topic+bemd'></span>

<h3>Description</h3>

<p>Function <code>bemd</code> implements the Bivariate EMD (Scheme 2 in the cited article).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bemd(input, directions = 64L, num_imfs = 0L, num_siftings = 50L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bemd_+3A_input">input</code></td>
<td>
<p>Complex vector of length N. The input signal to decompose.</p>
</td></tr>
<tr><td><code id="bemd_+3A_directions">directions</code></td>
<td>
<p>Vector of directional angles (in radians) to use for the decomposition, 
or an integer defining the number of equally spaced angles to use.</p>
</td></tr>
<tr><td><code id="bemd_+3A_num_imfs">num_imfs</code></td>
<td>
<p>Number of Intrinsic Mode Functions (IMFs) to compute. If num_imfs is set to zero, a value of
num_imfs = emd_num_imfs(N) will be used, which corresponds to a maximal number of
IMFs. Note that the final residual is also counted as an IMF in this
respect, so you most likely want at least num_imfs=2.</p>
</td></tr>
<tr><td><code id="bemd_+3A_num_siftings">num_siftings</code></td>
<td>
<p>Use a maximum number of siftings as a stopping criterion. If
<code>num_siftings</code> is zero, this stopping criterion is ignored. Default is 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Time series object of class <code>"mts"</code> where series corresponds to
IMFs of the input signal, with the last series being the final residual.
@references
</p>

<ol>
<li><p>G. Rilling, P. Flandrin, P. Goncalves and J. M. Lilly,
&quot;Bivariate Empirical Mode Decomposition&quot;,
IEEE Signal Processing Letters, Vol. 14 (2007) 936&ndash;939
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 512 
t &lt;- 2 * pi * (0:(N-1))/N
input &lt;- cos(0.3 * t) * exp(2i * t) + 0.3 * abs(sin(2.3 * t)) * exp(17i * t)

# Use evenly spaced angles as directions
num_directions &lt;- 64
directions &lt;- 2 * pi * 1:num_directions / num_directions
imfs &lt;- bemd(input, directions, num_imfs = 4, num_siftings = 10)

# plot the data
plot(Re(input), Im(input), xlim = c(-1, 2))
# plot signal and the imfs
for(i in 1:4)
  points(Re(imfs[,i]), Im(imfs[,i]), col = 1 + i)
legend("bottomright", col = 1:5, legend = c("signal", paste0("IMF ",1:4)), pch = 1)

data("float")
plot(float, type = "l")
signal &lt;- float[, 1] + float[, 2] * 1i
imfs &lt;- bemd(signal, num_siftings = 10, num_imfs = 4)

# plot the data and the imfs
oldpar &lt;- par()
par(mfrow = c(5, 1), mar = c(0.5, 4.5, 0.5, 0.5), oma = c(4, 0, 2, 0))
ts.plot(float, col = 1:2, lty = 1:2, ylab = "signal", gpars = list(xaxt = "n"))
for(i in 1:4) {
  ts.plot(Re(imfs[, i]), Im(imfs[, i]), col = 1:2, lty = 1:2, 
    ylab = if(i &lt; 4) paste("IMF", i) else "residual", gpars = list(xaxt = "n"))
 }
axis(1)
title(xlab = "Time (days)", main = "Bivariate EMD decomposition", outer = TRUE)
par(oldpar)
</code></pre>

<hr>
<h2 id='ceemdan'>CEEMDAN decomposition</h2><span id='topic+ceemdan'></span>

<h3>Description</h3>

<p>Decompose input data to Intrinsic Mode Functions (IMFs) with the
Complete Ensemble Empirical Mode Decomposition with Adaptive Noise (CEEMDAN)
algorithm [1], a variant of EEMD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceemdan(
  input,
  num_imfs = 0,
  ensemble_size = 250L,
  noise_strength = 0.2,
  S_number = 4L,
  num_siftings = 50L,
  rng_seed = 0L,
  threads = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceemdan_+3A_input">input</code></td>
<td>
<p>Vector of length N. The input signal to decompose.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_num_imfs">num_imfs</code></td>
<td>
<p>Number of Intrinsic Mode Functions (IMFs) to compute. If num_imfs is set to zero,
a value of num_imfs = emd_num_imfs(N) will be used, which corresponds to a maximal number of 
IMFs. Note that the final residual is also counted as an IMF in this respect, so you most 
likely want at least num_imfs=2.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_ensemble_size">ensemble_size</code></td>
<td>
<p>Number of copies of the input signal to use as the ensemble.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_noise_strength">noise_strength</code></td>
<td>
<p>Standard deviation of the Gaussian random numbers used as additional noise.
<b>This value is relative</b> to the standard deviation of the input signal.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_s_number">S_number</code></td>
<td>
<p>Integer. Use the S-number stopping criterion for the EMD procedure with the given
values of $S$. That is, iterate until the number of extrema and zero crossings in the signal 
differ at most by one, and stay the same for S consecutive iterations. Typical values are in 
the range 3&ndash;8. If <code>S_number</code> is zero, this stopping criterion is ignored. Default is 4.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_num_siftings">num_siftings</code></td>
<td>
<p>Use a maximum number of siftings as a stopping criterion. If 
<code>num_siftings</code> is zero, this stopping criterion is ignored. Default is 50.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_rng_seed">rng_seed</code></td>
<td>
<p>A seed for the GSL's Mersenne twister random number generator. A value of zero 
(default) denotes an implementation-defined default value. For <code>ceemdan</code> this does not guarantee
reproducible results if multiple threads are used.</p>
</td></tr>
<tr><td><code id="ceemdan_+3A_threads">threads</code></td>
<td>
<p>Non-negative integer defining the maximum number of parallel threads (via OpenMP's
<code>omp_set_num_threads</code>. Default value 0 uses all available threads defined by OpenMP's 
<code>omp_get_max_threads</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of the ensemble and the relative magnitude of the added noise are
given by parameters <code>ensemble_size</code> and <code>noise_strength</code>, respectively.  The
stopping criterion for the decomposition is given by either a S-number [2] or
an absolute number of siftings. In the case that both are positive numbers,
the sifting ends when either of the conditions is fulfilled.
</p>


<h3>Value</h3>

<p>Time series object of class <code>"mts"</code> where series corresponds to
IMFs of the input signal, with the last series being the final residual.
</p>


<h3>References</h3>

 
<ol>
<li><p>M. Torres et al, &quot;A Complete Ensemble Empirical Mode Decomposition with Adaptive Noise&quot;
IEEE Int. Conf. on Acoust., Speech and Signal Proc. ICASSP-11,
(2011) 4144&ndash;4147
</p>
</li>
<li><p>N. E. Huang, Z. Shen and S. R. Long, &quot;A new view of nonlinear water
waves: The Hilbert spectrum&quot;, Annual Review of Fluid Mechanics, Vol. 31
(1999) 417&ndash;457
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+eemd">eemd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>imfs &lt;- ceemdan(UKgas, threads = 1)
# trend extraction
ts.plot(UKgas, imfs[, ncol(imfs)], col = 1:2, 
        main = "Quarterly UK gas consumption", ylab = "Million therms")

# CEEMDAN for logarithmic demand, note that increasing ensemble size 
# will produce smoother results
imfs &lt;- ceemdan(log(UKgas), ensemble_size = 50, threads = 1)
plot(ts.union("log(obs)" = log(UKgas), Seasonal = imfs[, 1], 
     Irregular = rowSums(imfs[, 2:5]), Trend = imfs[, 6]), 
     main = "Quarterly UK gas consumption")
</code></pre>

<hr>
<h2 id='ECG'>Electrocardiogram Data
Example ECG data from MIT-BIH Normal Sinus Rhythm Database, ECG1 of record 16265,
first 2049 observations (0 to 16 seconds with sampling interval of 0.0078125 seconds)</h2><span id='topic+ECG'></span>

<h3>Description</h3>

<p>Electrocardiogram Data
</p>
<p>Example ECG data from MIT-BIH Normal Sinus Rhythm Database, ECG1 of record 16265,
first 2049 observations (0 to 16 seconds with sampling interval of 0.0078125 seconds)
</p>


<h3>Format</h3>

<p>A time series object.
</p>


<h3>Source</h3>

<p>MIT-BIH Normal Sinus Rhythm Database, PhysioBank ATM, 
<a href="https://archive.physionet.org/cgi-bin/atm/ATM">https://archive.physionet.org/cgi-bin/atm/ATM</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ECG")
plot(ECG)
</code></pre>

<hr>
<h2 id='eemd'>EEMD Decomposition</h2><span id='topic+eemd'></span>

<h3>Description</h3>

<p>Decompose input data to Intrinsic Mode Functions (IMFs) with the Ensemble Empirical Mode 
Decomposition algorithm [1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eemd(
  input,
  num_imfs = 0,
  ensemble_size = 250L,
  noise_strength = 0.2,
  S_number = 4L,
  num_siftings = 50L,
  rng_seed = 0L,
  threads = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eemd_+3A_input">input</code></td>
<td>
<p>Vector of length N. The input signal to decompose.</p>
</td></tr>
<tr><td><code id="eemd_+3A_num_imfs">num_imfs</code></td>
<td>
<p>Number of Intrinsic Mode Functions (IMFs) to compute. If num_imfs is set to zero,
a value of num_imfs = emd_num_imfs(N) will be used, which corresponds to a maximal number of 
IMFs. Note that the final residual is also counted as an IMF in this respect, so you most 
likely want at least num_imfs=2.</p>
</td></tr>
<tr><td><code id="eemd_+3A_ensemble_size">ensemble_size</code></td>
<td>
<p>Number of copies of the input signal to use as the ensemble.</p>
</td></tr>
<tr><td><code id="eemd_+3A_noise_strength">noise_strength</code></td>
<td>
<p>Standard deviation of the Gaussian random numbers used as additional noise.
<b>This value is relative</b> to the standard deviation of the input signal.</p>
</td></tr>
<tr><td><code id="eemd_+3A_s_number">S_number</code></td>
<td>
<p>Integer. Use the S-number stopping criterion for the EMD procedure with the given
values of $S$. That is, iterate until the number of extrema and zero crossings in the signal 
differ at most by one, and stay the same for S consecutive iterations. Typical values are in 
the range 3&ndash;8. If <code>S_number</code> is zero, this stopping criterion is ignored. Default is 4.</p>
</td></tr>
<tr><td><code id="eemd_+3A_num_siftings">num_siftings</code></td>
<td>
<p>Use a maximum number of siftings as a stopping criterion. If 
<code>num_siftings</code> is zero, this stopping criterion is ignored. Default is 50.</p>
</td></tr>
<tr><td><code id="eemd_+3A_rng_seed">rng_seed</code></td>
<td>
<p>A seed for the GSL's Mersenne twister random number generator. A value of zero 
(default) denotes an implementation-defined default value.</p>
</td></tr>
<tr><td><code id="eemd_+3A_threads">threads</code></td>
<td>
<p>Non-negative integer defining the maximum number of parallel threads (via OpenMP's
<code>omp_set_num_threads</code>. Default value 0 uses all available threads defined by OpenMP's 
<code>omp_get_max_threads</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The size of the ensemble and the relative magnitude of the added noise are given by parameters 
<code>ensemble_size</code> and <code>noise_strength</code>, respectively.  The stopping criterion for the 
decomposition is given by either a S-number [2] or an absolute number of siftings. In the case 
that both are positive numbers, the sifting ends when either of the conditions is fulfilled.
</p>


<h3>Value</h3>

<p>Time series object of class <code>"mts"</code> where series corresponds to IMFs of the input 
signal, with the last series being the final residual.
</p>


<h3>References</h3>

 <ol>
<li><p>Z. Wu and N. Huang, &quot;Ensemble Empirical Mode Decomposition: A 
Noise-Assisted Data Analysis Method&quot;, Advances in Adaptive Data Analysis, Vol. 1 (2009) 1&ndash;41 
</p>
</li>
<li><p>N. E. Huang, Z. Shen and S. R. Long, &quot;A new view of nonlinear water waves: The Hilbert 
spectrum&quot;, Annual Review of Fluid Mechanics, Vol. 31 (1999) 417&ndash;457 </p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+ceemdan">ceemdan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0, 2*pi, length.out = 500)
signal &lt;- sin(4*x)
intermittent &lt;- 0.1 * sin(80 * x)
y &lt;- signal * (1 + ifelse(signal &gt; 0.7, intermittent, 0))

plot(x = x,y = y,type = "l")
# Decompose with EEMD
imfs &lt;- eemd(y, num_siftings = 10, ensemble_size = 50, threads = 1)
 
plot(imfs)
# High frequencies
ts.plot(rowSums(imfs[, 1:3]))
# Low frequencies
ts.plot(rowSums(imfs[, 4:ncol(imfs)]))
</code></pre>

<hr>
<h2 id='emd'>EMD decomposition</h2><span id='topic+emd'></span>

<h3>Description</h3>

<p>Decompose input data to Intrinsic Mode Functions (IMFs) with the
Empirical Mode Decomposition algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emd(input, num_imfs = 0, S_number = 4L, num_siftings = 50L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emd_+3A_input">input</code></td>
<td>
<p>Vector of length N. The input signal to decompose.</p>
</td></tr>
<tr><td><code id="emd_+3A_num_imfs">num_imfs</code></td>
<td>
<p>Number of Intrinsic Mode Functions (IMFs) to compute. If num_imfs is set to zero, a value of
num_imfs = emd_num_imfs(N) will be used, which corresponds to a maximal number of
IMFs. Note that the final residual is also counted as an IMF in this
respect, so you most likely want at least num_imfs=2.</p>
</td></tr>
<tr><td><code id="emd_+3A_s_number">S_number</code></td>
<td>
<p>Integer. Use the S-number stopping criterion [1] for the EMD procedure with the given values of S.
That is, iterate until the number of extrema and zero crossings in the
signal differ at most by one, and stay the same for S consecutive
iterations. Typical values are in the range 3&ndash;8. If <code>S_number</code> is
zero, this stopping criterion is ignored. Default is 4.</p>
</td></tr>
<tr><td><code id="emd_+3A_num_siftings">num_siftings</code></td>
<td>
<p>Use a maximum number of siftings as a stopping criterion. If
<code>num_siftings</code> is zero, this stopping criterion is ignored. Default is 50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper around <code>eemd</code> with <code>ensemble_size = 1</code> and <code>noise_strength = 0</code>.
</p>


<h3>Value</h3>

<p>Time series object of class <code>"mts"</code> where series corresponds to
IMFs of the input signal, with the last series being the final residual.
@references
</p>

<ol>
<li><p>N. E. Huang, Z. Shen and S. R. Long, &quot;A new view of nonlinear water
waves: The Hilbert spectrum&quot;, Annual Review of Fluid Mechanics, Vol. 31
(1999) 417&ndash;457
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+eemd">eemd</a></code>, <code><a href="#topic+ceemdan">ceemdan</a></code>
</p>

<hr>
<h2 id='extrema'>Local Extrema of Time Series</h2><span id='topic+extrema'></span>

<h3>Description</h3>

<p>Find the local minima and maxima from input data. This includes the
artificial extrema added to the ends of the data as specified in the
original EEMD article [1]. In the case of flat regions at the extrema, the center point of the flat region 
will be considered the extremal point [2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extrema(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extrema_+3A_input">input</code></td>
<td>
<p>Numeric vector or time series object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with matrices <code>minima</code> and <code>maxima</code> which give time points and values of local minima and
maxima of <code>input</code> where time points are transformed to match the sampling times of <code>input</code>.
</p>


<h3>References</h3>


<ol>
<li><p> Z. Wu and N. Huang, &quot;Ensemble Empirical Mode Decomposition: A 
Noise-Assisted Data Analysis Method&quot;, Advances in Adaptive Data Analysis,
Vol. 1 (2009) 1&ndash;41.
</p>
</li>
<li><p>P. Luukko, J. Helske and E. Räsänen, 
&quot;Introducing libeemd: A program package for performing the ensemble empirical mode decomposition&quot;, Computational Statistics (2015).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>ext &lt;- extrema(UKgas)
plot(UKgas, ylim = range(ext$maxima[, 2], ext$minima[, 2]))
points(ext$maxima, col = 2, pch = 19)
points(ext$minima, col = 2, pch = 19)

# Artificial extremas obtained by extrapolating last two extrema
# Beginning of the series
lines(ext$minima[1:3, ], col = 4) 
# This is discarded as it produces smaller extrema than the last observation:
b &lt;- lm(c(ext$maxima[2:3, 2]) ~ ext$maxima[2:3, 1])$coef[2]
points(x = ext$maxima[1, 1], y = ext$maxima[2, 2] - b, col = 4,pch = 19) 
lines(x = ext$maxima[1:3, 1], y = c(ext$maxima[2, 2] - b, ext$maxima[2:3, 2]), col = 4)
# End of the series
# These produce more extreme values than the last observation which is thus disregarded
lines(ext$minima[27:29, ],col = 4) 
lines(ext$maxima[26:28, ],col = 4) 

</code></pre>

<hr>
<h2 id='float'>Float Data
The data are a position record from an acoustically tracked subsurface oceanographic float, 
used as an example data in Rilling et al (2007).</h2><span id='topic+float'></span>

<h3>Description</h3>

<p>Float Data
</p>
<p>The data are a position record from an acoustically tracked subsurface oceanographic float, 
used as an example data in Rilling et al (2007).
</p>


<h3>Format</h3>

<p>A time series object.
</p>


<h3>Source</h3>

<p>http://wfdac.whoi.edu
</p>


<h3>References</h3>


<ol>
<li><p>G. Rilling, P. Flandrin, P. Goncalves and J. M. Lilly,
&quot;Bivariate Empirical Mode Decomposition&quot;,
IEEE Signal Processing Letters, Vol. 14 (2007) 936&ndash;939
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>data("float")
plot(float, type = "l")

</code></pre>

<hr>
<h2 id='nIMFs'>Number of IMFs</h2><span id='topic+nIMFs'></span><span id='topic+emd_num_imfs'></span>

<h3>Description</h3>

<p>Return the number of IMFs extracted from input data of length N, including
the final residual. This is just [log_2(N)] for N&gt;3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emd_num_imfs(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nIMFs_+3A_n">N</code></td>
<td>
<p>An integer defining the length of input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of IMFs which would be extracted from input data of length N, including
the final residual.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
