<!DOCTYPE html><html><head><title>Help for package autoharp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {autoharp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#adj_list_2_matrix'><p>Convert adjacency list to a matrix</p></a></li>
<li><a href='#as.matrix'><p>TreeHarp Cast a TreeHarp to Matrix.</p></a></li>
<li><a href='#autoharp'><p>autoharp: Semi-Automatic Grading of R and Rmd Scripts</p></a></li>
<li><a href='#carve_mst'><p>Carve a Minimal Spanning Tree Out</p></a></li>
<li><a href='#carve_subtree'><p>Carve out branches to form a new tree.</p></a></li>
<li><a href='#check_correctness'><p>Check correctness of student solution rmd.</p></a></li>
<li><a href='#check_rmd'><p>Check if a File is Rmd</p></a></li>
<li><a href='#check_runtime'><p>Calculate Run-time Statistics</p></a></li>
<li><a href='#clean_dir'><p>Removes md Files when no HTML Present</p></a></li>
<li><a href='#copy_e2e'><p>Copy an object from one env to another.</p></a></li>
<li><a href='#count_lints_all'><p>Lint counter</p></a></li>
<li><a href='#count_lints_one'><p>File lint counter</p></a></li>
<li><a href='#env_size'><p>Calculates the Total Memory Used</p></a></li>
<li><a href='#examplify_to_r'><p>Convert from Examplify to R</p></a></li>
<li><a href='#extract_chunks'><p>Extract chunks that match a pattern.</p></a></li>
<li><a href='#extract_non_chunks'><p>Extract non-chunks from an Rmd file.</p></a></li>
<li><a href='#fapply'><p>Apply a function to a forest of trees.</p></a></li>
<li><a href='#find_branch_num'><p>Find the branch that leads from one node to another.</p></a></li>
<li><a href='#forestharp-helpers'><p>Forestharp helpers</p></a></li>
<li><a href='#generate_all_subtrees'><p>Generate all subtrees from a tree.</p></a></li>
<li><a href='#generate_thumbnails'><p>Generate a html of thumbnails</p></a></li>
<li><a href='#get_adj_list'><p>Generic for Getting Adjacency List</p></a></li>
<li><a href='#get_child_ids'><p>Generic for Getting Child Node Ids</p></a></li>
<li><a href='#get_child_ids2'><p>Get the children node ids</p></a></li>
<li><a href='#get_levels'><p>Obtains the node levels from a tree.</p></a></li>
<li><a href='#get_libraries'><p>Extracts the Packages Used in An Rmd File.</p></a></li>
<li><a href='#get_next_depth_id'><p>Get the id and depth of a child node.</p></a></li>
<li><a href='#get_next_subtree'><p>Generate the next sub-tree.</p></a></li>
<li><a href='#get_node_types'><p>Generic for Getting Node Types</p></a></li>
<li><a href='#get_parent_call_id'><p>Get Node Id of Parent Call</p></a></li>
<li><a href='#get_parent_id'><p>Generic for Getting Parent Node Id.</p></a></li>
<li><a href='#get_parent_id2'><p>Get the parent node id</p></a></li>
<li><a href='#get_recursive_index'><p>Obtain an index to extract out a sub-call</p></a></li>
<li><a href='#get_summary_output'><p>Function to extract the summary content</p></a></li>
<li><a href='#is_connected'><p>Checks if a graph is connected.</p></a></li>
<li><a href='#is_cyclic_r'><p>Checks if a graph contains any cycles.</p></a></li>
<li><a href='#is_subtree_rooted_at'><p>Checks if a tree is rooted at a node of another tree.</p></a></li>
<li><a href='#jaccard_treeharp'><p>Computes Jaccard Index</p></a></li>
<li><a href='#join_treeharps'><p>Root a list of trees.</p></a></li>
<li><a href='#K2'><p>Compute tree similarity</p></a></li>
<li><a href='#keep_branches'><p>Keep only branches specified by node numbers</p></a></li>
<li><a href='#lang_2_tree'><p>Convert language object to tree.</p></a></li>
<li><a href='#log_summary'><p>Generate a dataframe from the log file.</p></a></li>
<li><a href='#lum_local_match'><p>Match Filenames from LumiNUS.</p></a></li>
<li><a href='#matrix_2_adj_list'><p>Convert adjacency matrix to a list.</p></a></li>
<li><a href='#path_to_root'><p>Extract a path from node to root.</p></a></li>
<li><a href='#plot,TreeHarp-method'><p>TreeHarp Plotting TreeHarp Objects</p></a></li>
<li><a href='#populate_soln_env'><p>Returns solution environment and test code from template.</p></a></li>
<li><a href='#prune_depth'><p>Prune a tree up to a specified depth.</p></a></li>
<li><a href='#rbind_to_nodes_info'><p>Update node information.</p></a></li>
<li><a href='#remove_extension'><p>Obtains the Root File Name, without Extension.</p></a></li>
<li><a href='#render_one'><p>Run a single Rmd file through autoharp.</p></a></li>
<li><a href='#replace_sp_chars_filename'><p>Replace Special Characters in File Name</p></a></li>
<li><a href='#reset_path'><p>Reset search path of current R session</p></a></li>
<li><a href='#rmd_to_forestharp'><p>Convert to TreeHarp objects</p></a></li>
<li><a href='#rmd_to_token_count'><p>Count tokens in R/Rmd</p></a></li>
<li><a href='#run_tuner'><p>Runs the student-facing feedback app</p></a></li>
<li><a href='#subtree_at'><p>Extract a sub-tree.</p></a></li>
<li><a href='#to_BFS'><p>Function to rearrage nodes in BFS</p></a></li>
<li><a href='#tree_sim'><p>Compute tree similarity</p></a></li>
<li><a href='#TreeHarp-class'><p>An R expression as a tree.</p></a></li>
<li><a href='#update_adj_list'><p>Update adjacency list.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Semi-Automatic Grading of R and Rmd Scripts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.10</td>
</tr>
<tr>
<td>Description:</td>
<td>A customisable set of tools for assessing and grading 
    R or R-markdown scripts from students. It allows for checking correctness 
    of code output, runtime statistics and static code analysis. The latter 
    feature is made possible by representing R expressions using a tree
    structure.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, dplyr, stringr, rlang, tidyr, tibble, knitr,
rmarkdown, pryr, shiny, lintr, methods, igraph</td>
</tr>
<tr>
<td>Collate:</td>
<td>'treeharp.R' 'th_getter-length.R' 'as.matrix.R' 'autoharp.R'
'check_correctness.R' 'check_rmd.R' 'check_runtime.R'
'count_lints.R' 'env_size.R' 'examplify_to_r.R' 'forestharp.R'
'forestharp_helpers.R' 'generate_thumbnails.R'
'join_treeharp.R' 'lang_2_tree.R' 'lang_2_tree_helpers.R'
'log_summary.R' 'lum_local_match.R' 'nlp_related.R'
'populate_soln_env.R' 'render_one.R' 'reset_path.R'
'run_tuner.R' 'to_BFS.R' 'tree_kernel.R' 'tree_routines.R'
'utils-pipe.R' 'utils.R' 'write_html.R' 'zzz.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>readxl, xml2, rvest, formatR, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (&gt;= 1.14) - http://pandoc.org</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://singator.github.io/autoharp-docs/">https://singator.github.io/autoharp-docs/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-12 22:39:01 UTC; viknesh</td>
</tr>
<tr>
<td>Author:</td>
<td>Vik Gopal [aut, cre],
  Samuel Seah [aut],
  Viknesh Jeya Kumar [aut],
  Gabriel Ang [aut],
  Ruofan Liu [ctb],
  National University of Singapore [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vik Gopal &lt;vik.gopal@nus.edu.sg&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-12 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='adj_list_2_matrix'>Convert adjacency list to a matrix</h2><span id='topic+adj_list_2_matrix'></span>

<h3>Description</h3>

<p>Converts a list that represents a tree into a binary matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj_list_2_matrix(adj_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_list_2_matrix_+3A_adj_list">adj_list</code></td>
<td>
<p>The adjacency list of the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remember that the list has to be for a tree, not a general graph. Please
see other help pages for more specifications.
</p>
<p>This is a low-level function, used within the S4 class TreeHarp. It is not
generally meant for use by the user.
</p>
<p>It works by filling up the upper diagonal of the matrix before reflecting it.
</p>


<h3>Value</h3>

<p>A symmetric matrix of 1's and 0's, with 1 in entry (i,j) representing
an edge between the two vertices.
</p>

<hr>
<h2 id='as.matrix'>TreeHarp Cast a TreeHarp to Matrix.</h2><span id='topic+as.matrix'></span>

<h3>Description</h3>

<p>Convert a treeharp object to an adjacency matrix.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix_+3A_from">from</code></td>
<td>
<p>A treeharp object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='autoharp'>autoharp: Semi-Automatic Grading of R and Rmd Scripts</h2><span id='topic+autoharp'></span>

<h3>Description</h3>

<p>The autoharp package provides functions for running and analysing 
R script/Rmd submissions from students.
</p>


<h3>Main functions are</h3>


<ol>
<li> <p><code><a href="#topic+populate_soln_env">populate_soln_env</a></code>
</p>
</li>
<li> <p><code><a href="#topic+render_one">render_one</a></code>
</p>
</li>
<li> <p><code><a href="#topic+run_tuner">run_tuner</a></code>
</p>
</li>
<li> <p><code><a href="#topic+TreeHarp">TreeHarp</a></code>
</p>
</li></ol>

<p>The user manuals can be found at <a href="https://singator.github.io/autoharp-docs/">https://singator.github.io/autoharp-docs/</a>
</p>

<hr>
<h2 id='carve_mst'>Carve a Minimal Spanning Tree Out</h2><span id='topic+carve_mst'></span>

<h3>Description</h3>

<p>Given node names, this function retrieves the smallest tree containing at most 
those nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carve_mst(th, node_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carve_mst_+3A_th">th</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="carve_mst_+3A_node_names">node_names</code></td>
<td>
<p>A character vector of node names. Nodes outside this set 
will not be returned in the tree. It must include the root node name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function starts from each node specified and works it's way up
to the root. If a branch contains nodes outside the list, it is shortened.
</p>
<p>In the end, the tree that is returned will try to contain all the named nodes,
but if that's not possible some will dropped to ensure a tree is returned, 
not a disconnected graph.
</p>


<h3>Value</h3>

<p>An object of class TreeHarp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex1 &lt;- quote(x &lt;- f(y, g(5)))
th1 &lt;- TreeHarp(ex1, TRUE)
carve_mst(th1, c("&lt;-", "x", "f", "5")) ## note: 5 is dropped.
carve_mst(th1, c("&lt;-", "x", "f", "y")) 
carve_mst(th1, c("&lt;-", "f", "g")) 

</code></pre>

<hr>
<h2 id='carve_subtree'>Carve out branches to form a new tree.</h2><span id='topic+carve_subtree'></span>

<h3>Description</h3>

<p>This functions keeps only the indicated nodes, returning a new sub-tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carve_subtree(obj, char_arr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carve_subtree_+3A_obj">obj</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="carve_subtree_+3A_char_arr">char_arr</code></td>
<td>
<p>A vector of 1's and 0's indicating which nodes to keep. The
vector should have length equal to the number of nodes in obj.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This returns an error if the sub-tree does not define a new tree.
</p>


<h3>Value</h3>

<p>An object of class TreeHarp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th3 &lt;- list(a= c(2L,3L,4L), b=NULL, c=c(5L, 6L), d=7L, e=NULL, f=NULL, g=NULL)
carve_subtree(TreeHarp(th3), c(1,0,0,0,0,0,0))
st &lt;- subtree_at(TreeHarp(th3), 4)
plot(st)
</code></pre>

<hr>
<h2 id='check_correctness'>Check correctness of student solution rmd.</h2><span id='topic+check_correctness'></span>

<h3>Description</h3>

<p>This will run unit tests on the students' rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_correctness(e_stud, e_soln, test_fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_correctness_+3A_e_stud">e_stud</code></td>
<td>
<p>The environment containing the output objects from running the
studnent Rmd file.</p>
</td></tr>
<tr><td><code id="check_correctness_+3A_e_soln">e_soln</code></td>
<td>
<p>The environment containing the objects from the solution
template. It will probably contain objects with the suffix &quot;_soln&quot;. These
will be tested against the versions generated by the student.</p>
</td></tr>
<tr><td><code id="check_correctness_+3A_test_fname">test_fname</code></td>
<td>
<p>The R script containing the test chunks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prior to calling this, <code><a href="#topic+populate_soln_env">populate_soln_env</a></code> should 
already have been called on the solution template, and the student 
file should already have been knitted in order to generate the students' 
objects. Of course, one could generate the test script independent of 
<code><a href="#topic+populate_soln_env">populate_soln_env</a></code>, but the solution environment that contains 
objects with a &quot;_soln&quot; suffix is also needed.
</p>
<p>The student environment, solution environment, test file and the list of 
tests and expectations are the inputs to this function.
</p>


<h3>Value</h3>

<p>A data frame with one row, and the number of columns equal to the 
number of tests run plus the number of scalars to keep.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+populate_soln_env">populate_soln_env</a></code>, <code><a href="#topic+render_one">render_one</a></code>
</p>

<hr>
<h2 id='check_rmd'>Check if a File is Rmd</h2><span id='topic+check_rmd'></span>

<h3>Description</h3>

<p>Checks if a file actually is an Rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_rmd(fname, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_rmd_+3A_fname">fname</code></td>
<td>
<p>A character string. It is the name of the student submission
file.</p>
</td></tr>
<tr><td><code id="check_rmd_+3A_verbose">verbose</code></td>
<td>
<p>A logical value that prints messages if a non-rmd file
is found.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It runs three checks. First, it checks for the file extension to be
Rmd or rmd or any such variant. Second, it checks for a YAML header at the
beginning of file. Finally, it checks if there is at least one properly
defined R chunk within the file.
</p>


<h3>Value</h3>

<p>The function will return TRUE if all the (3) checks pass, and FALSE
otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_libraries">get_libraries</a></code>
</p>

<hr>
<h2 id='check_runtime'>Calculate Run-time Statistics</h2><span id='topic+check_runtime'></span>

<h3>Description</h3>

<p>This is stand-alone function. It computes the runtime stats
without rendering the md/html/pdf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_runtime(stud_fname, knit_root_dir, return_env = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_runtime_+3A_stud_fname">stud_fname</code></td>
<td>
<p>The rmd filename of the student.</p>
</td></tr>
<tr><td><code id="check_runtime_+3A_knit_root_dir">knit_root_dir</code></td>
<td>
<p>The working directory to use when knitting the file.</p>
</td></tr>
<tr><td><code id="check_runtime_+3A_return_env">return_env</code></td>
<td>
<p>A logical value to indicate if the environment from the
rmd file should be return. If FALSE, an NA value is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is not used within any other function within the 
package. Figures are not cleaned or removed.
</p>


<h3>Value</h3>

<p>A list containing the running time in seconds, the memory used
by the final environment in bytes (as a numeric scalar), and the
environment object containing all the generated objects from the rmd file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+render_one">render_one</a></code>
</p>

<hr>
<h2 id='clean_dir'>Removes md Files when no HTML Present</h2><span id='topic+clean_dir'></span>

<h3>Description</h3>

<p>Cleans up the autoharp output directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_dir(dir_name, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_dir_+3A_dir_name">dir_name</code></td>
<td>
<p>The directory containing the files to be cleaned.</p>
</td></tr>
<tr><td><code id="clean_dir_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, then the files and directories being removed will be 
printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When batch rendering Rmd files, it is inevitable that some files fail. These
files would have their knit.md and utf.md present, but they would not have a
corresponding html file generated.
</p>
<p>This function is called for its' side-effect, to remove those lonely md files.
</p>
<p>If this clean-up is not done, when we try to re-run the files (perhaps with
some of the errors fixed), these straggling md files will cause problems. 
The most crucial one is that the Rmd files will not be re-knitted, even 
though they have been changed.
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='copy_e2e'>Copy an object from one env to another.</h2><span id='topic+copy_e2e'></span>

<h3>Description</h3>

<p>A wrapper function that uses assign and get.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_e2e(from_obj, from_env, to_obj, to_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_e2e_+3A_from_obj">from_obj</code></td>
<td>
<p>The name of the object to copy. It has to be a string.</p>
</td></tr>
<tr><td><code id="copy_e2e_+3A_from_env">from_env</code></td>
<td>
<p>The environment in which the object lives. It has to be an
object of class environment.</p>
</td></tr>
<tr><td><code id="copy_e2e_+3A_to_obj">to_obj</code></td>
<td>
<p>The name of the object to assign it to, in the new environment.
Also a string.</p>
</td></tr>
<tr><td><code id="copy_e2e_+3A_to_env">to_env</code></td>
<td>
<p>The environment to which the new object is to be assigned. It
has to be an object of class environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>There is no return value. This function is called for its' side
effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e1 &lt;- new.env(); e2 &lt;- new.env()
ls(e2)
evalq(x &lt;- 1L, e1)
copy_e2e("x", e1, "y", e2)
ls(e2)
</code></pre>

<hr>
<h2 id='count_lints_all'>Lint counter</h2><span id='topic+count_lints_all'></span>

<h3>Description</h3>

<p>Count number of lints in one folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_lints_all(file_names, lint_list, lint_labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_lints_all_+3A_file_names">file_names</code></td>
<td>
<p>The path to the rmd files that need to be checked for
lints.</p>
</td></tr>
<tr><td><code id="count_lints_all_+3A_lint_list">lint_list</code></td>
<td>
<p>List of lints to check for.</p>
</td></tr>
<tr><td><code id="count_lints_all_+3A_lint_labels">lint_labels</code></td>
<td>
<p>List of labels to name the vector to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will count the number of lints in a file. The lints to be
checked can be passed as an argument. Else, the default will be used.
The defaults are as follows:
</p>

<ul>
<li><p> T_and_F_symbol_linter
</p>
</li>
<li><p> line_length_linter
</p>
</li>
<li><p> assignment_linter
</p>
</li>
<li><p> absolute_path_linter
</p>
</li>
<li><p> pipe_continuation_linter
</p>
</li></ul>

<p>Note that labels would also need to be given if the non-default lints
are chosen.
</p>


<h3>Value</h3>

<p>Dataframe containing the lints.
</p>

<hr>
<h2 id='count_lints_one'>File lint counter</h2><span id='topic+count_lints_one'></span>

<h3>Description</h3>

<p>Count number of lints in one file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_lints_one(rmd_file, lint_list, lint_labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_lints_one_+3A_rmd_file">rmd_file</code></td>
<td>
<p>The path to the rmd file to check for lints.</p>
</td></tr>
<tr><td><code id="count_lints_one_+3A_lint_list">lint_list</code></td>
<td>
<p>List of lints to check for.</p>
</td></tr>
<tr><td><code id="count_lints_one_+3A_lint_labels">lint_labels</code></td>
<td>
<p>List of labels to name the vector to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will count the number of lints in a file. The lints to be 
checked can be passed as an argument. Else, the default will be used. 
The defaults are as follows: 
* T_and_F_symbol_linter
* line_length_linter
* assignment_linter
* absolute_path_linter
* pipe_continuation_linter
Note that labels would also need to be given if the non-default lints 
are chosen.
</p>


<h3>Value</h3>

<p>Vector containing the lints.
</p>

<hr>
<h2 id='env_size'>Calculates the Total Memory Used</h2><span id='topic+env_size'></span>

<h3>Description</h3>

<p>This function uses object_size from the pryr package to compute the total
amount of memory used by objects in an environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_size(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_size_+3A_env">env</code></td>
<td>
<p>The environment whose size is to be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names are wrapped in backticks. Otherwise, non-syntactic
names will cause problems. This function is used within
<code><a href="#topic+render_one">render_one</a></code> as part of the runtime stats assessment.
</p>


<h3>Value</h3>

<p>The size in bytes, as a numeric value (scalar).
</p>


<h3>See Also</h3>

<p><code><a href="pryr.html#topic+object_size">object_size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e1 &lt;- new.env()
env_size(e1)
evalq(x &lt;- 1:10000L, e1)
env_size(e1)
</code></pre>

<hr>
<h2 id='examplify_to_r'>Convert from Examplify to R</h2><span id='topic+examplify_to_r'></span>

<h3>Description</h3>

<p>This function converts an Examplify script (from a student,html)
into an R script.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examplify_to_r(in_fname, out_fname, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="examplify_to_r_+3A_in_fname">in_fname</code></td>
<td>
<p>A file name of a student submission html file.</p>
</td></tr>
<tr><td><code id="examplify_to_r_+3A_out_fname">out_fname</code></td>
<td>
<p>The output R script.</p>
</td></tr>
<tr><td><code id="examplify_to_r_+3A_verbose">verbose</code></td>
<td>
<p>Controls verbosity of output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The script has to be exported in html format, using a particular profile.
The questions are stored in tags nested under id = &quot;answers&quot; and tag type &quot;h2&quot;.
The answers are stored in tags nested under id = &quot;answers&quot; and class
&quot;content&quot;.
</p>
<p>Some of the student text may contain R code and text mixed up, so
tidy_source() may not work on those, since it is parsed.
</p>


<h3>Value</h3>

<p>This will return NULL, but will generate an R script as output.
</p>

<hr>
<h2 id='extract_chunks'>Extract chunks that match a pattern.</h2><span id='topic+extract_chunks'></span>

<h3>Description</h3>

<p>Extracts chunks whose labels match a pattern from the rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_chunks(rmd_name, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_chunks_+3A_rmd_name">rmd_name</code></td>
<td>
<p>A character string, the name of the rmd file to get the
chunks from.</p>
</td></tr>
<tr><td><code id="extract_chunks_+3A_pattern">pattern</code></td>
<td>
<p>The pattern to match within the label. In fact, the match is
applied to the whole chunk option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors. Each vector contains the chunk from the
file. If no pattern is specified, all chunks are returned. Remember that
the chunk header and tail are also included in the returned list.
</p>

<hr>
<h2 id='extract_non_chunks'>Extract non-chunks from an Rmd file.</h2><span id='topic+extract_non_chunks'></span>

<h3>Description</h3>

<p>Extracts non-chunks from an Rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_non_chunks(rmd_name, out_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_non_chunks_+3A_rmd_name">rmd_name</code></td>
<td>
<p>A character string, the name of the rmd file to get the
chunks from.</p>
</td></tr>
<tr><td><code id="extract_non_chunks_+3A_out_name">out_name</code></td>
<td>
<p>An output filename, to dump the text to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If out_name is missing, then a character vector is returned. If 
outfname is specified, then nothing is returned. The text is written to the 
file instead.
</p>

<hr>
<h2 id='fapply'>Apply a function to a forest of trees.</h2><span id='topic+fapply'></span>

<h3>Description</h3>

<p>A convenience function, for applying a function to many trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fapply(fharp, TFUN, combine = TRUE, combiner_fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fapply_+3A_fharp">fharp</code></td>
<td>
<p>The output of rmd_to_forestharp. It could also just be a 
list of TreeHarp objects.</p>
</td></tr>
<tr><td><code id="fapply_+3A_tfun">TFUN</code></td>
<td>
<p>A function that works on a single TreeHarp and returns an output. 
See <a href="#topic+forestharp-helpers">forestharp-helpers</a> for examples.</p>
</td></tr>
<tr><td><code id="fapply_+3A_combine">combine</code></td>
<td>
<p>A logical value that indicates if the output from all function
applications should be combined.</p>
</td></tr>
<tr><td><code id="fapply_+3A_combiner_fn">combiner_fn</code></td>
<td>
<p>A function to use to combine the individual output from 
each tree into a single scalar for each forest. It should handle NA 
values in the input vector or list. If it is missing, it defaults to 
sum, with na.rm=TRUE.</p>
</td></tr>
<tr><td><code id="fapply_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to TFUN.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input is simply a list of TreeHarp objects. First, the TFUN 
function is lapply-ed to each TreeHarp item, resulting in either a list, 
or a vector with possible NA elements.
</p>
<p>The combiner function should be aware of this sort of output, and summarise
the list or vector accordingly, handling NA's and returning a <em>scalar</em>.
</p>
<p>If you need to create a partial function out of a forestharp helper, 
use an anonymous function, as shown in the examples below.
</p>


<h3>Value</h3>

<p>A vector, list or a single value. If TFUN returned an error for a 
particular TreeHarp, that component in the list or vector would be NA. This 
input vector or list will then be combined by combiner_fn.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex1 &lt;- quote(X &lt;- rnorm(10, mean=0.9, sd=4))
ex2 &lt;- quote(Y &lt;- rbeta(10, shape1=3, shape2=5))
f1 &lt;- lapply(c(ex1, ex2), TreeHarp, quote_arg=TRUE) 

# returns all function calls that begin with "r", like rnorm and rbeta.
# calls are returned as a list.
fapply(f1, extract_fn_call, combine =FALSE, pattern="^r.*")

# list is catenated.
fapply(f1, extract_fn_call, combine =TRUE, pattern="^r.*", 
       combiner_fn = function(x) {paste0(unlist(x), collapse=",")})

</code></pre>

<hr>
<h2 id='find_branch_num'>Find the branch that leads from one node to another.</h2><span id='topic+find_branch_num'></span>

<h3>Description</h3>

<p>Given two nodes that are on the same path to the root, this function
determines the branch that leads to the child node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_branch_num(th, child_id, ancestor_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_branch_num_+3A_th">th</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="find_branch_num_+3A_child_id">child_id</code></td>
<td>
<p>An integer node id. It corresponds to the node to trace up
from.</p>
</td></tr>
<tr><td><code id="find_branch_num_+3A_ancestor_id">ancestor_id</code></td>
<td>
<p>An integer node id. It corresponds to the node to trace 
down from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used when trying to find a sub-call from a TreeHarp object.
It is useful in determining the indices to use when extracting the sub-call.
</p>


<h3>Value</h3>

<p>An integer that denotes the branch to follow down (from the ancestor)
to reach the child.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex3 &lt;- quote(x &lt;- f(y = g(3, 4), z=1L))
t1 &lt;- TreeHarp(ex3, TRUE)
find_branch_num(t1, 8, 3) # should be 1
find_branch_num(t1, 5, 3) # should be 2
</code></pre>

<hr>
<h2 id='forestharp-helpers'>Forestharp helpers</h2><span id='topic+forestharp-helpers'></span><span id='topic+count_self_fn'></span><span id='topic+count_lam_fn'></span><span id='topic+count_fn_call'></span><span id='topic+extract_fn_call'></span><span id='topic+extract_formal_args'></span><span id='topic+extract_assigned_objects'></span><span id='topic+extract_actual_args'></span><span id='topic+detect_growing'></span><span id='topic+detect_for_in_fn_def'></span><span id='topic+count_fn_in_fn'></span><span id='topic+detect_fn_call_in_for'></span><span id='topic+extract_self_fn'></span><span id='topic+detect_fn_arg'></span><span id='topic+detect_nested_for'></span>

<h3>Description</h3>

<p>Example of functions that can be <em>directly used on TreeHarp objects
individually,</em> and on forestharp objects via <code><a href="#topic+fapply">fapply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_self_fn(th)

count_lam_fn(th)

count_fn_call(th, pattern, pkg_name)

extract_fn_call(th, pattern, pkg_name)

extract_formal_args(th, fn_name)

extract_assigned_objects(th)

extract_actual_args(th)

detect_growing(th, count = FALSE, within_for = FALSE)

detect_for_in_fn_def(th, fn_name)

count_fn_in_fn(th, fn_name, sub_fn)

detect_fn_call_in_for(th, fn_name)

extract_self_fn(th)

detect_fn_arg(th, fn_name, arg)

detect_nested_for(th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forestharp-helpers_+3A_th">th</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression to pick up function names.</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_pkg_name">pkg_name</code></td>
<td>
<p>The name of a package to match functions with. This should
be an exact match for the package name. The package should be attached for
this to work. In order to avoid picking up duplicate names, for instance
<code>tolower</code> is a function in base R and in ggplot2, run
<code><a href="#topic+get_libraries">get_libraries</a></code> on the file as well, and match against it.</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_fn_name">fn_name</code></td>
<td>
<p>Function name, as a character string</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_count">count</code></td>
<td>
<p>For <code>detect_growing</code>, this is a logical value that indicates
if the number of &quot;grow&quot; expressions should be counted and returned, or if just a
logical value should be returned.</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_within_for">within_for</code></td>
<td>
<p>If TRUE, only expresssions within a for loop are included.</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_sub_fn">sub_fn</code></td>
<td>
<p>(For count_fn_in_fn), the function to count (to look for within
fn_name).</p>
</td></tr>
<tr><td><code id="forestharp-helpers_+3A_arg">arg</code></td>
<td>
<p>The argument to check for within fn_name (as a character string).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are examples of functions that be called on a list of TreeHarp
objects, which we refer to as a forestharp object. Such objects are not
formally defined yet, but can be created using
<code><a href="#topic+rmd_to_forestharp">rmd_to_forestharp</a></code> or using <code><a href="#topic+join_treeharps">join_treeharps</a></code>.
</p>


<h3>Value</h3>

<p>On their own, each of these functions should return a scalar or a
1-dimensional array. When called with <code><a href="#topic+fapply">fapply</a></code>, the scalar
numerical values can be combined (by taking the sum, any other provided
combiner function).
</p>
<p>The ultimate idea is that fapply should return a single feature for each rmd
file that it is called upon.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>count_self_fn</code>: Counts the number of self-defined functions.
</p>
<p>This helper counts the number of self-defined functions. It excludes
lambda functions. It returns an integer scalar.
</p>
<p>As long as the function <code>function</code> was called and assigned, it will be
counted.
</p>
</li>
<li> <p><code>count_lam_fn</code>: Counts the number of anonymous functions.
</p>
<p>Counts the number of anonymous functions, typically used in sapply, etc. It
returns an integer scalar. As long as the function <code>function</code> was
called but <em>not</em> assigned, it will be counted here.
</p>
</li>
<li> <p><code>count_fn_call</code>: Counts the number of function calls that match a pattern.
</p>
<p>This helper counts the number of function calls that match a pattern. It
returns a count, i.e. an integer vector of length 1.
</p>
<p>If <code>pkg_name</code> is provided instead of <code>pattern</code>, then this function
counts the number of function calls from that package.
</p>
</li>
<li> <p><code>extract_fn_call</code>: Extracts function calls as a string.
</p>
<p>Extracts the function calls that match a pattern. It returns a character
vector. Remember to set <code>combine = FALSE</code> when calling
<code><a href="#topic+fapply">fapply</a></code> with it.
</p>
</li>
<li> <p><code>extract_formal_args</code>: Extracts function formal arguments called.
</p>
<p>Extracts the function <em>formal</em> arguments from functions with a given
name. The name must match the function name exactly. This returns a character
vector or NULL, if no formal arguments are used.
</p>
</li>
<li> <p><code>extract_assigned_objects</code>: Extracts names of assigned objects
</p>
<p>Extracts the names of assigned objects. This was written to assist in
detecting missed opportunities to use the pipe operator.
</p>
</li>
<li> <p><code>extract_actual_args</code>: Extracts actual argument names
</p>
<p>Extracts the actual arguments from an expression, not the formal
arguments. It only returns syntactic literals. It should be improved
to return the actual arguments for a specified function so that something
similar to <code>extract_assigned_objects</code> could be returned.
</p>
</li>
<li> <p><code>detect_growing</code>: Detects if a vector is being grown.
</p>
<p>It detects if there is an expression of form: x &lt;- c(x, new_val). This is
generally bad programming practice
</p>
</li>
<li> <p><code>detect_for_in_fn_def</code>: Detects if a for loop is present within a function
</p>
<p>It detects if a for loop is present within a function definition.
</p>
</li>
<li> <p><code>count_fn_in_fn</code>: Count use of a function within another.
</p>
<p>It counts the number of times a function is used within another.
</p>
</li>
<li> <p><code>detect_fn_call_in_for</code>: Detect for loop to call a function
</p>
<p>Checks if a function has been called within a for loop.
</p>
</li>
<li> <p><code>extract_self_fn</code>: Extract names of functions defined by user.
</p>
<p>Extracts names of user-defined functions. They may not all look nice, because
sum functions may be anonymous functions. This function needs to be improved.
</p>
</li>
<li> <p><code>detect_fn_arg</code>: Was a function called with a particular argument?
</p>
<p>Checks if a function was called with a particular argument, which could be
the formal or actual one. The immediate child of the function call node is
checked.
</p>
</li>
<li> <p><code>detect_nested_for</code>: Was a nested &quot;for&quot; loop called anywhere within the code?
</p>
<p>Checks if a nested for-loop was called anywhere within the code. This returns
a logical scalar for each TreeHarp object given.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Dummy trees
th1 &lt;- TreeHarp(quote(X &lt;- rnorm(10, mean=0.9, sd=4)), TRUE)
th2 &lt;- TreeHarp(quote(Y &lt;- rbeta(10, shape1=3, shape2=5)), TRUE)
th3 &lt;- TreeHarp(quote(fn1 &lt;- function(x) x + 2), TRUE)
th4 &lt;- TreeHarp(quote(df1 &lt;- mutate(df1, new_col=2*old_col)), TRUE)

# Run helpers
count_self_fn(th3)
count_fn_call(th4, pkg_name="dplyr")
count_fn_call(th1, pattern="^r.*")

</code></pre>

<hr>
<h2 id='generate_all_subtrees'>Generate all subtrees from a tree.</h2><span id='topic+generate_all_subtrees'></span>

<h3>Description</h3>

<p>This routines generates all subtrees rooted at the root node for a particular
tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_all_subtrees(th)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_all_subtrees_+3A_th">th</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 0-1 matrix with n rows and m columns. n is the number of sub-trees
rooted at the root node of th. m is the number of nodes in this given tree.
The leading column will be a 1 for all the rows.
</p>


<h3>References</h3>

<p><em>Listing and counting subtrees of a tree</em>, F Ruskey, <em>SIAM Journal on Computing</em>, 1981
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_next_subtree">get_next_subtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th1 &lt;- TreeHarp(list(a=c(2,3), b=NULL, c=NULL))
generate_all_subtrees(th1)
</code></pre>

<hr>
<h2 id='generate_thumbnails'>Generate a html of thumbnails</h2><span id='topic+generate_thumbnails'></span>

<h3>Description</h3>

<p>Generate a html of thumbnails
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_thumbnails(out_dir, html_fname, html_title, anonymise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_thumbnails_+3A_out_dir">out_dir</code></td>
<td>
<p>The directory in which student html files and the figures 
are kept.</p>
</td></tr>
<tr><td><code id="generate_thumbnails_+3A_html_fname">html_fname</code></td>
<td>
<p>The name of the master html file which will contain all
thumbnails. This file will be created in <code>out_dir</code>.</p>
</td></tr>
<tr><td><code id="generate_thumbnails_+3A_html_title">html_title</code></td>
<td>
<p>The title tag of the master html page. This will be displayed 
on top of the output html page.</p>
</td></tr>
<tr><td><code id="generate_thumbnails_+3A_anonymise">anonymise</code></td>
<td>
<p>If TRUE, the original filenames will be replaced with
inocuous numbers. If FALSE, the original filenames will be retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After running <code><a href="#topic+render_one">render_one</a></code> on a set of R/Rmd files 
in a directory, this function helps to consolidate them for review.
</p>
<p>The output folder contains all the generated html files, images and a log 
file. This function will extract the images from each html file and display 
them as thumbnails on a new html page, with links to all individual files.
</p>


<h3>Value</h3>

<p>The function returns nothing, but it should create a html page 
of thumbnails of all the images that students plotted, along with links to 
their individual pages.
</p>

<hr>
<h2 id='get_adj_list'>Generic for Getting Adjacency List</h2><span id='topic+get_adj_list'></span><span id='topic+get_adj_list+2CTreeHarp-method'></span>

<h3>Description</h3>

<p>The generic method definition for getting adjacency list from a
TreeHarp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adj_list(x, ...)

## S4 method for signature 'TreeHarp'
get_adj_list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adj_list_+3A_x">x</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="get_adj_list_+3A_...">...</code></td>
<td>
<p>Unused arguments, for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjacency list for a TreeHarp object.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>TreeHarp</code>: A getter.
</p>
<p>Allows user to extract the adjacency list of a treeharp object.
</p>
</li></ul>

<hr>
<h2 id='get_child_ids'>Generic for Getting Child Node Ids</h2><span id='topic+get_child_ids'></span><span id='topic+get_child_ids+2CTreeHarp-method'></span><span id='topic+get_child_ids+2Clist-method'></span>

<h3>Description</h3>

<p>The generic method definition for getting child node ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_child_ids(x, node_num)

## S4 method for signature 'TreeHarp'
get_child_ids(x, node_num)

## S4 method for signature 'list'
get_child_ids(x, node_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_child_ids_+3A_x">x</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="get_child_ids_+3A_node_num">node_num</code></td>
<td>
<p>An integer, length 1. This the node whose children we are
after. If the specified node is a leaf, the NULL is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector, indicating the children node ids.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>TreeHarp</code>: Obtain child nodes.
</p>
<p>Allows user to extract the child nodes from a specified node from TreeHarp
object.
</p>
</li>
<li> <p><code>list</code>: Obtain child nodes.
</p>
<p>Allows user to extract the child nodes from a specified node from an 
adjacency list.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+get_parent_id">get_parent_id</a></code>
</p>

<hr>
<h2 id='get_child_ids2'>Get the children node ids</h2><span id='topic+get_child_ids2'></span>

<h3>Description</h3>

<p>This function retrieves the child node ids of a given node from an
adjacency list of a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_child_ids2(adj_list, at_node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_child_ids2_+3A_adj_list">adj_list</code></td>
<td>
<p>The adjacency list of the tree.</p>
</td></tr>
<tr><td><code id="get_child_ids2_+3A_at_node">at_node</code></td>
<td>
<p>The node whose children should be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remember that the list has to be for a tree, not a general graph. Please
see other help pages for more specifications.
</p>
<p>This is a low-level function, used within the S4 class TreeHarp. It is not
generally meant for use by the user.
</p>


<h3>Value</h3>

<p>A vector of integers specifying the children of that particular node.
If the node is a leaf, it returns NULL.
</p>

<hr>
<h2 id='get_levels'>Obtains the node levels from a tree.</h2><span id='topic+get_levels'></span>

<h3>Description</h3>

<p>This function obtains the node levels from a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_levels(adj_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_levels_+3A_adj_list">adj_list</code></td>
<td>
<p>The adjacency list of the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to check if the specification of the tree is
in BFS order. If that is indeed the case, the levels of each node should be
sorted.
</p>
<p>This function is not exported for the general user.
</p>


<h3>Value</h3>

<p>It returns a vector of integers. The length of this vector will be
the number of nodes in the tree. The root is at level 1, the next is at level
2, and so on.
</p>

<hr>
<h2 id='get_libraries'>Extracts the Packages Used in An Rmd File.</h2><span id='topic+get_libraries'></span>

<h3>Description</h3>

<p>The input filename could correspond to an R script or an Rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_libraries(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_libraries_+3A_fname">fname</code></td>
<td>
<p>The Rmd filename or R script.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file is assumed to be either an R script or an Rmd file.
If it is found to be an Rmd file using <a href="#topic+extract_chunks">extract_chunks</a>, it is purl-ed before
libraries are extracted. If it is found to be NOT an Rmd, it is assumed
to be an R script and nothing is done to process it.
</p>
<p>The file is not parsed, so even text files will work with this function.
</p>


<h3>Value</h3>

<p>A character vector containing the packages used within the Rmd
document.
</p>

<hr>
<h2 id='get_next_depth_id'>Get the id and depth of a child node.</h2><span id='topic+get_next_depth_id'></span>

<h3>Description</h3>

<p>From the parent's depth and the last labelled node, we obtain the node id 
and depth of a child.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_next_depth_id(parent_node_id, env_ni)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_next_depth_id_+3A_parent_node_id">parent_node_id</code></td>
<td>
<p>The id of the parent node we are considering.</p>
</td></tr>
<tr><td><code id="get_next_depth_id_+3A_env_ni">env_ni</code></td>
<td>
<p>An environment object, possibly containing a data frame with
columns id, name, call_status, arg_type and depth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is for internal use. It may be removed from user-view soon!
</p>


<h3>Value</h3>

<p>A list containing the id and depth of the next node.
</p>

<hr>
<h2 id='get_next_subtree'>Generate the next sub-tree.</h2><span id='topic+get_next_subtree'></span>

<h3>Description</h3>

<p>This generates the next sub-tree in the enumeration list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_next_subtree(obj, char_arr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_next_subtree_+3A_obj">obj</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="get_next_subtree_+3A_char_arr">char_arr</code></td>
<td>
<p>A vector of 1's and 0's indicating which nodes to keep. The
vector should have length equal to the number of nodes in obj.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Need to reference the paper. This generates the next sub-tree,
rooted at the root node of this tree. It will generate singletons on it's
own. It has to be used within a loop to do that.
</p>


<h3>Value</h3>

<p>A vector of 1's and 0's, which denotes the next sub-tree in the list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_all_subtrees">generate_all_subtrees</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th1 &lt;- TreeHarp(list(a=c(2,3), b=NULL, c=NULL))
get_next_subtree(th1, c(1,0,0))
get_next_subtree(th1, c(1,1,0))

</code></pre>

<hr>
<h2 id='get_node_types'>Generic for Getting Node Types</h2><span id='topic+get_node_types'></span><span id='topic+get_node_types+2CTreeHarp-method'></span>

<h3>Description</h3>

<p>The generic method definition for getting node types from a
TreeHarp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_node_types(x, ...)

## S4 method for signature 'TreeHarp'
get_node_types(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_node_types_+3A_x">x</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="get_node_types_+3A_...">...</code></td>
<td>
<p>Unused arguments, for now.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the node types for a TreeHarp object. If the 
slot is empty, NA is returned.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>TreeHarp</code>: A getter.
</p>
<p>Allows user to extract the node types of a treeharp object.
</p>
</li></ul>

<hr>
<h2 id='get_parent_call_id'>Get Node Id of Parent Call</h2><span id='topic+get_parent_call_id'></span>

<h3>Description</h3>

<p>Get the node id of the parent call for a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parent_call_id(x, node_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parent_call_id_+3A_x">x</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="get_parent_call_id_+3A_node_id">node_id</code></td>
<td>
<p>The id of the node whose parent call is to be found. An 
integer value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When we need to go up the parse tree to obtain the function that 
called this node, we use this function. It is similar to <code>get_parent_id</code>,
except that that function only returns the immediate parent.
</p>
<p>It is not useful to call this function when the TreeHarp object is not 
constructed from a language object.
</p>
<p>Perhaps this function is necessary only because of the way language objects 
are represented by the autoharp: formal arguments are included in the 
tree representation. When we wish to find the calling function, we have to 
walk up the branches till we reach a function call.
</p>


<h3>Value</h3>

<p>An integer corresponding to the node id of the calling function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_parent_id">get_parent_id</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex3 &lt;- quote(x &lt;- f(y = g(3, 4), z=1L))
t1 &lt;- TreeHarp(ex3, TRUE)

# get the function that calls g:
get_parent_call_id(t1, 6) 
#contrast with this:
get_parent_id(t1, 6)
</code></pre>

<hr>
<h2 id='get_parent_id'>Generic for Getting Parent Node Id.</h2><span id='topic+get_parent_id'></span><span id='topic+get_parent_id+2CTreeHarp-method'></span><span id='topic+get_parent_id+2Clist-method'></span>

<h3>Description</h3>

<p>The generic method definition for getting parent node id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parent_id(x, node_num)

## S4 method for signature 'TreeHarp'
get_parent_id(x, node_num)

## S4 method for signature 'list'
get_parent_id(x, node_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parent_id_+3A_x">x</code></td>
<td>
<p>An object of class TreeHarp or an adjacency list.</p>
</td></tr>
<tr><td><code id="get_parent_id_+3A_node_num">node_num</code></td>
<td>
<p>An integer, length 1. This the node whose parent we are
after. If node_num is equal to 1, then NULL is returned because that should
be the root node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer, indicating the parent node.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>TreeHarp</code>: Obtain parent node id.
</p>
<p>Extracts parent id of a node from a TreeHarp object.
</p>
</li>
<li> <p><code>list</code>: Obtain parent node id.
</p>
<p>Extracts parent id of a node from an adjacency list object.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+get_child_ids">get_child_ids</a></code>
</p>

<hr>
<h2 id='get_parent_id2'>Get the parent node id</h2><span id='topic+get_parent_id2'></span>

<h3>Description</h3>

<p>This function retrieves the parent node id of a given node from an
adjacency list of a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parent_id2(adj_list, at_node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parent_id2_+3A_adj_list">adj_list</code></td>
<td>
<p>The adjacency list of the tree.</p>
</td></tr>
<tr><td><code id="get_parent_id2_+3A_at_node">at_node</code></td>
<td>
<p>The node whose parent should be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remember that the list has to be for a tree, not a general graph. Please
see other help pages for more specifications.
</p>
<p>This is a low-level function, used within the S4 class TreeHarp. It is not
generally meant for use by the user.
</p>
<p>If there are nodes that have more than one parent, then a warning is issued.
</p>


<h3>Value</h3>

<p>A integer of length 1 should be returned for all nodes except the
root. For the latter, the function will return NULL.
</p>

<hr>
<h2 id='get_recursive_index'>Obtain an index to extract out a sub-call</h2><span id='topic+get_recursive_index'></span>

<h3>Description</h3>

<p>Obtains an index that can be used to extract a sub-call from a language object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_recursive_index(th, node_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_recursive_index_+3A_th">th</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="get_recursive_index_+3A_node_id">node_id</code></td>
<td>
<p>An integer corresponding to a call within the parse tree 
(not a literal, symbol or a formal argument).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices, that can be used (together with &quot;[[&quot;) to obtain a 
sub-call
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex3 &lt;- quote(x &lt;- f(y = g(3, 4), z=1L))
t1 &lt;- TreeHarp(ex3, TRUE)
rec_index &lt;- get_recursive_index(t1, 6)
ex3[[rec_index + 1]]
ex3[[get_recursive_index(t1, 3)+1]]
</code></pre>

<hr>
<h2 id='get_summary_output'>Function to extract the summary content</h2><span id='topic+get_summary_output'></span>

<h3>Description</h3>

<p>This function will look for the explanation for the checks being done. 
If there is an explanation, the function will return the summary in HTML 
format. If not it will return 'not found' in HTML format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary_output(
  rmd_file,
  summary_header = "# Summary Output",
  dir = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_summary_output_+3A_rmd_file">rmd_file</code></td>
<td>
<p>The path to the rmd file to search for the summary.</p>
</td></tr>
<tr><td><code id="get_summary_output_+3A_summary_header">summary_header</code></td>
<td>
<p>The header to look for.</p>
</td></tr>
<tr><td><code id="get_summary_output_+3A_dir">dir</code></td>
<td>
<p>A temporary directory to store the temporary Rmarkdown file
before extracting the html content. The temp file will be deleted
before the function exits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is used as a helper function. Returns the HTML 
formatted string.
</p>

<hr>
<h2 id='is_connected'>Checks if a graph is connected.</h2><span id='topic+is_connected'></span>

<h3>Description</h3>

<p>A tree is a graph that is connected but does not have any cycles. This
function checks if a provided adjacency list is connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_connected(adj_list, root = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_connected_+3A_adj_list">adj_list</code></td>
<td>
<p>The adjacency list of the tree.</p>
</td></tr>
<tr><td><code id="is_connected_+3A_root">root</code></td>
<td>
<p>The root node to start checking from. This defaults to the
first node in the adjacency list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used as one of the validity checks within the
definition of the TreeHarp class. It is a low-level function, not really
meant for the general user of the package. Hence it is not exported.
</p>
<p>The nodes are traversed in a BFS order. The function could actually be
combined with <a href="#topic+is_cyclic_r">is_cyclic_r</a>, but it is kept separate for modularity
reasons.
</p>
<p>An alternative was to convert the list to an adjacency matrix and check
for a row and column of zeros.
</p>


<h3>Value</h3>

<p>The function returns a TRUE if the graph is connected and FALSE
otherwise.
</p>

<hr>
<h2 id='is_cyclic_r'>Checks if a graph contains any cycles.</h2><span id='topic+is_cyclic_r'></span>

<h3>Description</h3>

<p>A tree is a graph that is connected but does not have any cycles. This
function checks if a provided adjacency matrix contains cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cyclic_r(adj_mat, node_v, parent_node = -1, visited_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_cyclic_r_+3A_adj_mat">adj_mat</code></td>
<td>
<p>A symmetric matrix of 1's and 0's, with 1 in entry (i,j)
representing an edge between the two vertices.</p>
</td></tr>
<tr><td><code id="is_cyclic_r_+3A_node_v">node_v</code></td>
<td>
<p>The node to begin searching for cycles from. An integer.</p>
</td></tr>
<tr><td><code id="is_cyclic_r_+3A_parent_node">parent_node</code></td>
<td>
<p>The parent node of node_v. Also an integer. Use -1 if
you are starting from node 1. This is in fact the default.</p>
</td></tr>
<tr><td><code id="is_cyclic_r_+3A_visited_env">visited_env</code></td>
<td>
<p>An environment containing a logical vector indicating which
nodes have already been visited. The vector has to be named &quot;visited&quot;.
See the details.
</p>
<p>The function works by traversing all the nodes, in a BFS order. If it finds
a node has a parent that has already been visited, it concludes that there
is a cycle.
</p>
<p>The function is recursive, and has to update the vector of visisted nodes
within each call. Hence the visited vector is stored in an environment
that is passed along. It will return an error if no such environment is
provided. It is a very specific input that the function requires, and this
is another reason that this function is not exported.
</p>
<p>This function is used within the validity checks for the S4 class. It is
not exported for the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if the graph contains cycles.
</p>

<hr>
<h2 id='is_subtree_rooted_at'>Checks if a tree is rooted at a node of another tree.</h2><span id='topic+is_subtree_rooted_at'></span>

<h3>Description</h3>

<p>This function checks if a given tree is a sub-tree of another tree at a
particular node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_subtree_rooted_at(x, y, at_node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_subtree_rooted_at_+3A_x">x</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="is_subtree_rooted_at_+3A_y">y</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="is_subtree_rooted_at_+3A_at_node">at_node</code></td>
<td>
<p>An integer, corresponding to a node in object y. The sub-tree
of y, rooted at at_node, is compared to x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here's how it works: The sub-tree of y, rooted at at_node is first
extracted. The tree x is then compared to this. If x is a sub-tree of it,
then this function returns FALSE. Otherwise it returns TRUE.
</p>


<h3>Value</h3>

<p>A logical value indicating if x is a sub-tree of y, rooted at
at_node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>thb1 &lt;- TreeHarp(list(b=2, d=NULL))
tha1 &lt;- TreeHarp(list(a=c(2,3), b=4, c = NULL, d=NULL))
is_subtree_rooted_at(thb1, tha1, 1) # FALSE
is_subtree_rooted_at(thb1, tha1, 2) # TRUE
</code></pre>

<hr>
<h2 id='jaccard_treeharp'>Computes Jaccard Index</h2><span id='topic+jaccard_treeharp'></span>

<h3>Description</h3>

<p>Computes the Jaccard index between two trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_treeharp(th1, th2, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_treeharp_+3A_th1">th1</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="jaccard_treeharp_+3A_th2">th2</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="jaccard_treeharp_+3A_weighted">weighted</code></td>
<td>
<p>A logical value, indicating if the weighted Jaccard 
similarity should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unweighted form is just the cardinality of the intersection 
of the two sets of tokens, divided by the union of the two sets.
</p>
<p>The weighted form is described on the WIkipedia page:
https://en.wikipedia.org/wiki/Jaccard_index#Weighted_Jaccard_similarity_and_distance
</p>


<h3>Value</h3>

<p>A real number between 0 and 1.
</p>

<hr>
<h2 id='join_treeharps'>Root a list of trees.</h2><span id='topic+join_treeharps'></span>

<h3>Description</h3>

<p>Given a list of trees, this will root them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_treeharps(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_treeharps_+3A_...">...</code></td>
<td>
<p>A list of Treeharp objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines TreeHarp objects into a single TreeHarp.
The function will root all of them at a node called &quot;script&quot;, which is 
neither a function call nor an argument nor a symbol. The BFS ordering is 
then updated.
</p>
<p>Objects that are not of class TreeHarp will be dropped from the list 
before the rooting takes place.
</p>


<h3>Value</h3>

<p>A TreeHarp object
</p>

<hr>
<h2 id='K2'>Compute tree similarity</h2><span id='topic+K2'></span>

<h3>Description</h3>

<p>Compute tree similarity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K2(t1, t2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="K2_+3A_t1">t1</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="K2_+3A_t2">t2</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="K2_+3A_verbose">verbose</code></td>
<td>
<p>A logical value, indicating if the output should be verbose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As far as possible, this function tries to do things recursively.
It sets up a n x m matrix and fills up as much as it can. Then it uses 
recursive relationships to fill in the rest. When it cannot, it uses
<code><a href="#topic+generate_all_subtrees">generate_all_subtrees</a></code> to generate and count common subtrees.
</p>


<h3>Value</h3>

<p>An integer, that counts the number of sub-trees in common between 
the two trees. Please see the reference papers for more information.
</p>


<h3>References</h3>


<ol>
<li> 
<p><em>Convolution kernels for natural language</em>, M Collins and N Duffy, 
<em>Advances in neural information processing systems</em>, 2002.
</p>
</li>
<li> 
<p><em>Convolution kernels on discrete structures</em>, D Haussler, 
<em>Technical report, Department of Computer Science, UC Santa Cruz</em>, 1999.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>tree1 &lt;- TreeHarp(quote(x &lt;- 1), TRUE)
tree2 &lt;- TreeHarp(quote(y &lt;- 1), TRUE)
K2(tree1, tree2, TRUE)

</code></pre>

<hr>
<h2 id='keep_branches'>Keep only branches specified by node numbers</h2><span id='topic+keep_branches'></span>

<h3>Description</h3>

<p>Retains only specific branches, that are identified by their node numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keep_branches(th, branch_nodes, include_lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_branches_+3A_th">th</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="keep_branches_+3A_branch_nodes">branch_nodes</code></td>
<td>
<p>An integer vector, specifying the nodes to keep.</p>
</td></tr>
<tr><td><code id="keep_branches_+3A_include_lower">include_lower</code></td>
<td>
<p>A logical value - whether or not the lower branches should 
also be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A TreeHarp object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex1 &lt;- quote(x &lt;- f(y, g(5)))
th1 &lt;- TreeHarp(ex1, TRUE)
keep_branches(th1, 3)
keep_branches(th1, 3, include_lower = FALSE)
keep_branches(th1, c(2,3), FALSE)
keep_branches(th1, c(3, 4), FALSE)
</code></pre>

<hr>
<h2 id='lang_2_tree'>Convert language object to tree.</h2><span id='topic+lang_2_tree'></span>

<h3>Description</h3>

<p>A recursive function for converting a language object to treeharp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lang_2_tree(lang_obj, node_id, ni_env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lang_2_tree_+3A_lang_obj">lang_obj</code></td>
<td>
<p>A language object.</p>
</td></tr>
<tr><td><code id="lang_2_tree_+3A_node_id">node_id</code></td>
<td>
<p>The calling node to this language object. This should only 
be greater than 0 if the <code>ni_env</code> already contains a partial adjacency 
list and corresponding node information. This will happen when this function 
is called recursively.</p>
</td></tr>
<tr><td><code id="lang_2_tree_+3A_ni_env">ni_env</code></td>
<td>
<p>An environment to store the adjacency list and node information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by TreeHarp constructors. It should not have
to be called by a user. It works by bulding up an adjacency list and node 
node information data frame within the supplied environment.
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- new.env() 
lang_2_tree(quote(X &lt;- 1), 0, e1) 
e1$adj_list 
e1$node_info
</code></pre>

<hr>
<h2 id='log_summary'>Generate a dataframe from the log file.</h2><span id='topic+log_summary'></span>

<h3>Description</h3>

<p>Generate a dataframe from the log file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_summary(log_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_summary_+3A_log_file">log_file</code></td>
<td>
<p>The name of the log file generated from 
<code><a href="#topic+render_one">render_one</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This provides a table view of the log file, which is updated 
in a more natural format by simply concatenating new updates. The output 
of this function makes it easier to group entries by filename, time, or
status, or even error message.
</p>
<p>The output table does not contain correctness output. It only contains the 
columns name, timestamp, status (SUCCESS/FAIL), error message, 
number of libraries used and number of libraries installed.
</p>


<h3>Value</h3>

<p>The function returns a dataframe summarising the details in the
log file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+render_one">render_one</a></code>
</p>

<hr>
<h2 id='lum_local_match'>Match Filenames from LumiNUS.</h2><span id='topic+lum_local_match'></span>

<h3>Description</h3>

<p>A utility function for resolving duplicate filenames on
LumiNUS. (Only useful for NUS instructors!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lum_local_match(audit_file_path, local_files_dir, skip_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lum_local_match_+3A_audit_file_path">audit_file_path</code></td>
<td>
<p>The audit file downloaded from LumiNUS. This must
be an Excel file. It comes from the &quot;Download Activity&quot; button for the
corresponding folder. It should contain columns such as &quot;Action Time&quot;,
&quot;Action&quot;, etc. In the folder settings, students should be identified by
their NAME.</p>
</td></tr>
<tr><td><code id="lum_local_match_+3A_local_files_dir">local_files_dir</code></td>
<td>
<p>The directory containing the files downloaded from
LumiNUS. It is usually downloaded as a zip-file and then extracted.</p>
</td></tr>
<tr><td><code id="lum_local_match_+3A_skip_name">skip_name</code></td>
<td>
<p>The username to skip. Usually this is the instructor's name. This 
must be present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here is how LumiNUS works to resolve duplicate filenames: It
will append the students' filenames to the end of the file (in parenthesis),
but it will only use the first 15 characters of the students' name. In
LumiNUS, filenames are not case-sensitive - test.Rmd and test.rmd are
considered duplicate filenames.
</p>
<p>Here is how the function works: From the audit trail, it retrieves the name
of the most recent upload for each student. After converting these to
lowercase, duplicate file names have their student names appended. These
new names are matched to the filenames that were downloaded.
</p>
<p>Remember to clean up the filenames after this, because knitr does not
like parentheses in file names!
</p>


<h3>Value</h3>

<p>It returns a tibble, containing the remote and local filenames, matched
to the userid of students. The columns in this tibble are
</p>

<ol>
<li><p> mod_time: file modification time, from the downloaded file.
</p>
</li>
<li><p> luminus_time: time that the file was uploaded to LumiNUS; retrieved
from audit trail.
</p>
</li>
<li><p> local_fname: The downloaded local file name.
</p>
</li>
<li><p> luminus_fname: The filename that we see on LumiNUS.
</p>
</li></ol>



<h3>See Also</h3>

<p><code><a href="#topic+replace_sp_chars_filename">replace_sp_chars_filename</a></code>
</p>

<hr>
<h2 id='matrix_2_adj_list'>Convert adjacency matrix to a list.</h2><span id='topic+matrix_2_adj_list'></span>

<h3>Description</h3>

<p>Converts a binary matrix that represents a tree into an adjacency list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_2_adj_list(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_2_adj_list_+3A_mat">mat</code></td>
<td>
<p>A symmetric matrix of 1's and 0's, with 1 in entry (i,j)
representing an edge between the two vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remember that the list that is finally output is for a tree, not a general
graph. Please see other help pages for more specifications.
</p>
<p>The input matrix should be BFS ordered. The adjacency list only notes the
child node(s) of a particular node. If a matrix denotes multiple parents,
it will not be picked up.
</p>
<p>This is a low-level function, used within the S4 class TreeHarp. It is not
generally meant for use by the user.
</p>


<h3>Value</h3>

<p>The adjacency list of the tree.
</p>

<hr>
<h2 id='path_to_root'>Extract a path from node to root.</h2><span id='topic+path_to_root'></span>

<h3>Description</h3>

<p>Identifies the nodes on the path from a node up to the root of a TreeHarp
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path_to_root(th, node_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_to_root_+3A_th">th</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="path_to_root_+3A_node_num">node_num</code></td>
<td>
<p>A node number to start tracking upwards from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to identify the branch from a node 
up to the root of a tree.
</p>


<h3>Value</h3>

<p>A vector of 1's and 0's that can be used to carve out the branch 
alone, using <code><a href="#topic+carve_subtree">carve_subtree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex1 &lt;- quote(x &lt;- f(y, g(5)))
th1 &lt;- TreeHarp(ex1, TRUE)
path_to_root(th1, 5)
</code></pre>

<hr>
<h2 id='plot+2CTreeHarp-method'>TreeHarp Plotting TreeHarp Objects</h2><span id='topic+plot+2CTreeHarp-method'></span>

<h3>Description</h3>

<p>A plot method for visualising treeharp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TreeHarp'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CTreeHarp-method_+3A_x">x</code></td>
<td>
<p>An object of class TreeHarp.</p>
</td></tr>
<tr><td><code id="plot+2B2CTreeHarp-method_+3A_y">y</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="plot+2B2CTreeHarp-method_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to plot.igraph().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The treeharp object is converted to an igraph object before it
is plotted.
</p>


<h3>Value</h3>

<p>Returns NULL, invisibly.
</p>

<hr>
<h2 id='populate_soln_env'>Returns solution environment and test code from template.</h2><span id='topic+populate_soln_env'></span>

<h3>Description</h3>

<p>Generates objects for checking solution correctness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>populate_soln_env(
  soln_fname,
  pattern,
  knit_root_dir,
  render_only = FALSE,
  output = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="populate_soln_env_+3A_soln_fname">soln_fname</code></td>
<td>
<p>An rmd file containing the checks to be
run on the student solution.</p>
</td></tr>
<tr><td><code id="populate_soln_env_+3A_pattern">pattern</code></td>
<td>
<p>The pattern that identifies which chunks in the solution are 
are testing chunks. If this argument is missing, 
the default pattern used is &quot;test&quot;.</p>
</td></tr>
<tr><td><code id="populate_soln_env_+3A_knit_root_dir">knit_root_dir</code></td>
<td>
<p>The root directory to use for knitting the rmd file. This
argument is optional. If it is missing, it uses the root directory in
knitr::opts_knit$get('root.dir').</p>
</td></tr>
<tr><td><code id="populate_soln_env_+3A_render_only">render_only</code></td>
<td>
<p>A logical value. If this is TRUE, then the solution is
run and rendered. In this case, a list of length two is returned. If this is 
FALSE (default), then then a list of length three is returned. See the
Return section for more details.</p>
</td></tr>
<tr><td><code id="populate_soln_env_+3A_output">output</code></td>
<td>
<p>The path to the knitted solution md file. This is usually 
deleted immediately, but sometimes we may want to keep it. This 
argument is passed on to <code><a href="knitr.html#topic+knit">knit</a></code>, so please refer to 
that page for the warnings about setting this argument when figures are 
involved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Test code should be written in a chunk that generates scalars 
from student objects.
</p>
<p>The solution file has to be an Rmd file (not an R script), because it 
relies on the autoharp.obj and autoharp.scalars knitr hooks being present.
</p>
<p>In addition, if it is required that a solution object is to be tested against
the analogous object within the student environment, these objects should be 
listed within the autoharp option of a code chunk. These objects will be 
copied with the &quot;.&quot; preffix.
</p>
<p>Here is an overview of how the function works:
</p>

<ol>
<li><p> Knit the solution file to generate the solution (or &quot;correct&quot;) 
objects. 
</p>
</li>
<li><p> Rename these with the &quot;.&quot; prefix in the solution environment
object.
</p>
</li>
<li><p> Extract the lines of test code into a temporary R script.
</p>
</li>
<li><p> Wrap those chunks that contain autoharp.scalars hook with tryCatch.
</p>
</li>
<li><p> Add a few lines at the bottom of the script to indicate which
scalars should be kept.
</p>
</li>
<li><p> Return the solution environment and path to the R test script.
</p>
</li></ol>

<p>Typically, the next step is to call <code><a href="#topic+check_correctness">check_correctness</a></code>.
</p>


<h3>Value</h3>

<p>If render_only is FALSE, a list containing 2 components: the
environment populated by the solution rmd and the path to an R script
containing the test code.
</p>
<p>If render_only is TRUE, then the output list contains the 
aforementioned environment, and the path to the rendered solution file
(html). This option is useful for debugging the solution file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_correctness">check_correctness</a></code>, <code><a href="#topic+render_one">render_one</a></code>
</p>

<hr>
<h2 id='prune_depth'>Prune a tree up to a specified depth.</h2><span id='topic+prune_depth'></span>

<h3>Description</h3>

<p>Prunes a tree up to a depth specified by a set of node names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_depth(th, names_to_keep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_depth_+3A_th">th</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
<tr><td><code id="prune_depth_+3A_names_to_keep">names_to_keep</code></td>
<td>
<p>The node names to keep in the pruned tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a seldom used function. It works in this way. Given a set 
of node names, it identifies the node with the greatest depth in that set.
The function then returns the sub-tree, that contains all the nodes with a
depth smaller than or equal to that depth. If the node types slot is not NA,
then that data frame is filtered and returned too.
</p>
<p>Take a look at the examples for a clearer picture.
</p>


<h3>Value</h3>

<p>An object of class TreeHarp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+carve_subtree">carve_subtree</a></code>, <code><a href="#topic+path_to_root">path_to_root</a></code>, 
<code><a href="#topic+carve_mst">carve_mst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex1 &lt;- quote(x &lt;- f(y, g(5)))
th1 &lt;- TreeHarp(ex1, TRUE)
s1 &lt;- prune_depth(th1, c("f", "y"))
s2 &lt;- prune_depth(th1, c("f", "z")) # node not present!
plot(s1)
plot(s2)
</code></pre>

<hr>
<h2 id='rbind_to_nodes_info'>Update node information.</h2><span id='topic+rbind_to_nodes_info'></span>

<h3>Description</h3>

<p>Updates the node information regarding an R expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_to_nodes_info(id, name, call_status, formal_arg, depth, env_ni)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_to_nodes_info_+3A_id">id</code></td>
<td>
<p>The id of the node to be added. This should be an integer
of length 1.</p>
</td></tr>
<tr><td><code id="rbind_to_nodes_info_+3A_name">name</code></td>
<td>
<p>The name of the node.</p>
</td></tr>
<tr><td><code id="rbind_to_nodes_info_+3A_call_status">call_status</code></td>
<td>
<p>Is the language object a call or a symbol/literal? This 
should a logical value.</p>
</td></tr>
<tr><td><code id="rbind_to_nodes_info_+3A_formal_arg">formal_arg</code></td>
<td>
<p>Is the language object a formal argument or not? This 
should be a logical value.</p>
</td></tr>
<tr><td><code id="rbind_to_nodes_info_+3A_depth">depth</code></td>
<td>
<p>An integer indicating the depth of this language object in 
the parse tree.</p>
</td></tr>
<tr><td><code id="rbind_to_nodes_info_+3A_env_ni">env_ni</code></td>
<td>
<p>An environment object, possibly containing a data frame with
columns id, name, call_status, formal_arg and depth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is for internal use. It may be removed from user-view soon!
</p>


<h3>Value</h3>

<p>TRUE is returned invisibly.
</p>

<hr>
<h2 id='remove_extension'>Obtains the Root File Name, without Extension.</h2><span id='topic+remove_extension'></span>

<h3>Description</h3>

<p>This function hard codes some of the common extensions that we deal with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_extension(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_extension_+3A_fname">fname</code></td>
<td>
<p>A character string of the filename, with the extension present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If none of the known extensions knit.md, utf8.md, R or Rmd are 
found, then the last period onwards are removed. See the examples.
</p>
<p>If no extensions are found, the original filename is returned.
</p>


<h3>Value</h3>

<p>A character string, with the extension removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
remove_extension("test.Rmd")
remove_extension("test.knit.md")
remove_extension("test.r.txt")
remove_extension("test_no_extension")

</code></pre>

<hr>
<h2 id='render_one'>Run a single Rmd file through autoharp.</h2><span id='topic+render_one'></span>

<h3>Description</h3>

<p>Renders the specified file, and collates run time, static and 
correctness checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_one(
  rmd_name,
  out_dir,
  knit_root_dir,
  log_name,
  soln_stuff,
  max_time_per_run = 120,
  permission_to_install = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_one_+3A_rmd_name">rmd_name</code></td>
<td>
<p>The path to the file to be rendered and checked.</p>
</td></tr>
<tr><td><code id="render_one_+3A_out_dir">out_dir</code></td>
<td>
<p>The directory to store all the html output, md output, and
figures.</p>
</td></tr>
<tr><td><code id="render_one_+3A_knit_root_dir">knit_root_dir</code></td>
<td>
<p>The working directory while knitting the file.</p>
</td></tr>
<tr><td><code id="render_one_+3A_log_name">log_name</code></td>
<td>
<p>A character string, denoting the log file name. It defaults to
&quot;render_one.log&quot;. If this file is already present in the directory, this
function will append to it.</p>
</td></tr>
<tr><td><code id="render_one_+3A_soln_stuff">soln_stuff</code></td>
<td>
<p>This is a list, with components env, test_fname, and
tt_list. This object is the output of <code><a href="#topic+populate_soln_env">populate_soln_env</a></code>. Set
this to be NA if you wish to skip correctness checks, and only do rendering.</p>
</td></tr>
<tr><td><code id="render_one_+3A_max_time_per_run">max_time_per_run</code></td>
<td>
<p>The maximum time to wait before aborting the
rendering of a particular file.</p>
</td></tr>
<tr><td><code id="render_one_+3A_permission_to_install">permission_to_install</code></td>
<td>
<p>If TRUE, then the function will try to install 
any packages needed. By default, this is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log file contains a record of the libraries used by the student, and if
any new libraries needed to be installed. The status will be one of SUCCESS,
FAIL or UNKNOWN.
</p>


<h3>Value</h3>

<p>A data frame with one row for each file in the input directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+populate_soln_env">populate_soln_env</a></code>, <code><a href="#topic+check_correctness">check_correctness</a></code>
</p>

<hr>
<h2 id='replace_sp_chars_filename'>Replace Special Characters in File Name</h2><span id='topic+replace_sp_chars_filename'></span>

<h3>Description</h3>

<p>Replaces special characters in the name of an R or Rmd script.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_sp_chars_filename(dir_name, return_df = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_sp_chars_filename_+3A_dir_name">dir_name</code></td>
<td>
<p>A character string, referring to the directory of Rmd
files whose names should be replaced.</p>
</td></tr>
<tr><td><code id="replace_sp_chars_filename_+3A_return_df">return_df</code></td>
<td>
<p>A logical value, indicating if the old and new names should
be returned (in a tibble).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a filename contains one of the following special characters 
(ignore the quotes here): &quot;<code>[ &lt;&gt;()|\:&amp;;#?*']</code>&quot;, the  
<a href="knitr.html#topic+knit">knit</a> function will replace 
them with underscores. Hence the filenames in the autoharp input directory 
and the output directory will not match, even allowing for the change in 
file extension. This will cause problems when we try to run 
<code><a href="#topic+render_one">render_one</a></code> again on the same input directory.
</p>
<p>This function renames the files in the input directory by replacing all 
special characters there.
</p>
<p>The NUS LMS (LumiNUS) introduces parenthesized names or numbers in order 
to make filenames unique, so this function is necessary for NUS 
instructors.
</p>


<h3>Value</h3>

<p>A tibble containing the old and new names.
</p>

<hr>
<h2 id='reset_path'>Reset search path of current R session</h2><span id='topic+reset_path'></span>

<h3>Description</h3>

<p>This function is used to detach packages that have been added by a student 
script.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_path(old_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reset_path_+3A_old_path">old_path</code></td>
<td>
<p>A character vector of package namespaces. This is usually 
the output of <code><a href="base.html#topic+search">search</a></code>, run before an R script or Rmd 
file is rendered, which could cause the search path to change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a student script is rendered using <code><a href="#topic+render_one">render_one</a></code>, 
new packages might be added to the search path. These may conflict with the 
instructors' search path order, or with subsequent runs of 
<code><a href="#topic+render_one">render_one</a></code> on students. Hence there is a need to reset the 
search path before this is done.
</p>
<p>This function does not unload namespaces. It only detaches them from the 
search path. For a difference between the two, please see Hadley's page.
</p>


<h3>Value</h3>

<p>There is no object returned. This function is called for it's side-
effect of altering the search path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opath &lt;- search()
# Load a package
reset_path(opath)
</code></pre>

<hr>
<h2 id='rmd_to_forestharp'>Convert to TreeHarp objects</h2><span id='topic+rmd_to_forestharp'></span>

<h3>Description</h3>

<p>Reads in an Rmd file or an R script and converts it to a list of TreeHarp
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmd_to_forestharp(fname, line_nums = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmd_to_forestharp_+3A_fname">fname</code></td>
<td>
<p>The filename that is to be read in.</p>
</td></tr>
<tr><td><code id="rmd_to_forestharp_+3A_line_nums">line_nums</code></td>
<td>
<p>A logical value, indicating if the line numbers of
expressions should be returned along with the expressions. By default, this 
value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TreeHarp constructor is wrapped in a tryCatch loop, so that it
does not fail if an expression could not be converted to a TreeHarp object.
</p>
<p>The object returned is not a specially defined class. It is either a list of 
length 2, or a list of TreeHarp objects. This output is meant to be used 
with <code><a href="#topic+fapply">fapply</a></code>.
</p>
<p>If the input file is an Rmd file (checked with <a href="#topic+extract_chunks">extract_chunks</a>), then the
chunks are extracted and converted to TreeHarp objects. If the input file is 
not an Rmd, it is assumed to be an R script. This script is then supplied to 
<a href="base.html#topic+parse">parse</a>. In either case, a parsing error here could cause the function to 
fail.
</p>
<p>Line numbers are extracted using <code>get_source_expressions</code> from
the lintr package.
</p>


<h3>Value</h3>

<p>A list of TreeHarp objects, or a list with 2 components containing
the TreeHarp objects and a vector of line numbers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fapply">fapply</a></code>, <code><a href="#topic+extract_chunks">extract_chunks</a></code>,
<code><a href="#topic+extract_chunks">extract_chunks</a></code>, <code><a href="lintr.html#topic+get_source_expressions">get_source_expressions</a></code>
</p>

<hr>
<h2 id='rmd_to_token_count'>Count tokens in R/Rmd</h2><span id='topic+rmd_to_token_count'></span>

<h3>Description</h3>

<p>Count the individual tokens. Part of the NLP analysis process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmd_to_token_count(fname, include_actuals = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmd_to_token_count_+3A_fname">fname</code></td>
<td>
<p>The Rmd or R file name.</p>
</td></tr>
<tr><td><code id="rmd_to_token_count_+3A_include_actuals">include_actuals</code></td>
<td>
<p>Whether actual arguments/literals should be included.
If this is FALSE, then only calls and formal arguments will be used in
the count.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble. The tibble will contain a the frequency count for all 
tokens present in the student script.
</p>

<hr>
<h2 id='run_tuner'>Runs the student-facing feedback app</h2><span id='topic+run_tuner'></span>

<h3>Description</h3>

<p>This function runs the shiny app that students submit to in order to
obtain feedback on their Rmd submission file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_tuner(
  app_title,
  soln_templates_dir,
  knit_wd,
  tabs = c("lint", "html", "correctness"),
  lint_list,
  corr_cols_to_drop = c(1, 2, 4, 5),
  max_time = 120,
  summary_header = "# Summary Output",
  permission_to_install = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_tuner_+3A_app_title">app_title</code></td>
<td>
<p>A character string of the title of the app.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_soln_templates_dir">soln_templates_dir</code></td>
<td>
<p>This should be the directory containing all
solution templates. Solution templates are Rmd files.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_knit_wd">knit_wd</code></td>
<td>
<p>The working directory for knitting (to HTML).</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_tabs">tabs</code></td>
<td>
<p>A character vector of type of check to be done</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_lint_list">lint_list</code></td>
<td>
<p>A list of lints (from lintr package) to be run on the 
uploaded script. If missing, a default list of lints is run. See the 
details section.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_corr_cols_to_drop">corr_cols_to_drop</code></td>
<td>
<p>This should be an integer vector of columns to drop 
from the correctness check. By default, the columns corresponding to filename,
timestamp, run-time timing and memory are dropped.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_max_time">max_time</code></td>
<td>
<p>The maximum time (in seconds) allocated to rendering before 
failing. This is passed on to <code>render_one</code>.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_summary_header">summary_header</code></td>
<td>
<p>This the header to search for when generating the 
description for the correctness check.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_permission_to_install">permission_to_install</code></td>
<td>
<p>This is the argument to toggle for auto 
installation of libraries. Default is set to FALSE.</p>
</td></tr>
<tr><td><code id="run_tuner_+3A_...">...</code></td>
<td>
<p>Extra arguments passed on to runApp from shiny. Useful for
specifying port, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>lint_list</code> argument is missing, the following list of 
lints is run:
</p>

<ol>
<li><p> T_and_F_symbol_linter,
</p>
</li>
<li><p> assignment_linter,
</p>
</li>
<li><p> closed_curly_linter,
</p>
</li>
<li><p> commas_linter,
</p>
</li>
<li><p> equals_na_linter,
</p>
</li>
<li><p> function_left_parentheses_linter,
</p>
</li>
<li><p> infix_spaces_linter,
</p>
</li>
<li><p> line_length_linter,
</p>
</li>
<li><p> no_tab_linter,
</p>
</li>
<li><p> open_curly_linter,
</p>
</li>
<li><p> paren_brace_linter,
</p>
</li>
<li><p> absolute_path_linter,
</p>
</li>
<li><p> pipe_continuation_linter,
</p>
</li>
<li><p> spaces_inside_linter,
</p>
</li>
<li><p> trailing_blank_lines_linter,
</p>
</li>
<li><p> trailing_whitespace_linter,
</p>
</li>
<li><p> unneeded_concatenation_linter
</p>
</li></ol>

<p>The full list of available lints can be found here: <code><a href="lintr.html#topic+linters">linters</a></code>.
</p>


<h3>Value</h3>

<p>This function is run for its side-effect.
</p>

<hr>
<h2 id='subtree_at'>Extract a sub-tree.</h2><span id='topic+subtree_at'></span>

<h3>Description</h3>

<p>Extracts a sub-tree rooted at a particular node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtree_at(obj, at_node, preserve_call = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtree_at_+3A_obj">obj</code></td>
<td>
<p>An object of class TreeHarp</p>
</td></tr>
<tr><td><code id="subtree_at_+3A_at_node">at_node</code></td>
<td>
<p>The root of the new sub-tree. An integer, not a label, that
corresponds to BFS indexing of the tree.</p>
</td></tr>
<tr><td><code id="subtree_at_+3A_preserve_call">preserve_call</code></td>
<td>
<p>A logical value that indicates if a sub-call should be 
extracted. This might be slower, but it allows you to evaluate it later.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is meant for internal use, so the nodeTypes slot is silently
dropped, unless preserve_call is set to TRUE
</p>


<h3>Value</h3>

<p>An object of class TreeHarp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th3 &lt;- list(a= c(2L,3L,4L), b=NULL, c=c(5L, 6L), d=7L, e=NULL, f=NULL, g=NULL)
subtree_at(TreeHarp(th3), 3)
st &lt;- subtree_at(TreeHarp(th3), 4)
plot(st)
</code></pre>

<hr>
<h2 id='to_BFS'>Function to rearrage nodes in BFS</h2><span id='topic+to_BFS'></span>

<h3>Description</h3>

<p>Function to rearrage nodes in BFS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_BFS(adj_list, node_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_BFS_+3A_adj_list">adj_list</code></td>
<td>
<p>The output of lang_2_tree.</p>
</td></tr>
<tr><td><code id="to_BFS_+3A_node_info">node_info</code></td>
<td>
<p>The output of lang_2_tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for an internal TreeHarp constructor use. It is
not exported.
</p>


<h3>Value</h3>

<p>An adjacency list and nodes info data frame in BFS order.
</p>

<hr>
<h2 id='tree_sim'>Compute tree similarity</h2><span id='topic+tree_sim'></span>

<h3>Description</h3>

<p>Computes similarity between two trees (non-recursively)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_sim(t1, t2, norm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_sim_+3A_t1">t1</code></td>
<td>
<p>A TreeHarp object</p>
</td></tr>
<tr><td><code id="tree_sim_+3A_t2">t2</code></td>
<td>
<p>Anothe TreeHarp object.</p>
</td></tr>
<tr><td><code id="tree_sim_+3A_norm">norm</code></td>
<td>
<p>A logical value, indicating if the kernel function should be
normalised, to account for different tree lengths.</p>
</td></tr>
<tr><td><code id="tree_sim_+3A_...">...</code></td>
<td>
<p>Unused arguments, reserved for mcmapply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical value between 0 and 1 (if normed).
</p>

<hr>
<h2 id='TreeHarp-class'>An R expression as a tree.</h2><span id='topic+TreeHarp-class'></span><span id='topic+TreeHarp'></span><span id='topic+TreeHarp+2Clogical-method'></span><span id='topic+TreeHarp+2Cmissing-method'></span><span id='topic+length+2CTreeHarp-method'></span><span id='topic+show+2CTreeHarp-method'></span><span id='topic+names+2CTreeHarp-method'></span>

<h3>Description</h3>

<p>This class is used to represent a <em>single</em> R expression as a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TreeHarp(lang_obj, quote_arg, ...)

TreeHarp(lang_obj, quote_arg, ...)

## S4 method for signature 'logical'
TreeHarp(lang_obj, quote_arg, ...)

## S4 method for signature 'missing'
TreeHarp(lang_obj, quote_arg, ...)

## S4 method for signature 'TreeHarp'
length(x)

## S4 method for signature 'TreeHarp'
show(object)

## S4 method for signature 'TreeHarp'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TreeHarp-class_+3A_lang_obj">lang_obj</code></td>
<td>
<p>This should be an adjacency list for a tree (not a graph), or the
adjacency matrix of a tree, or the expression to be parsed. If it is a list,
only child nodes should be indicated (see the examples).</p>
</td></tr>
<tr><td><code id="TreeHarp-class_+3A_quote_arg">quote_arg</code></td>
<td>
<p>If this argument is missing or FALSE, then the class of 
<code>lang_obj</code> will be evaluated, and, if it is either a list or matrix, 
the TreeHarp object will be returned. 
</p>
<p>If this argument is TRUE, the <code>lang_obj</code> argument will be quoted and a 
parse tree for the expression will be computed and used as the tree.</p>
</td></tr>
<tr><td><code id="TreeHarp-class_+3A_...">...</code></td>
<td>
<p>Unused at the moment.</p>
</td></tr>
<tr><td><code id="TreeHarp-class_+3A_x">x</code></td>
<td>
<p>A Treeharp object.</p>
</td></tr>
<tr><td><code id="TreeHarp-class_+3A_object">object</code></td>
<td>
<p>A TreeHarp object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following validity checks are conducted on the object:
</p>

<ol>
<li><p> Is the graph connected? If no, the object is invalid.
</p>
</li>
<li><p> Are there cycles? If yes, the object is invalid.
</p>
</li>
<li><p> Are the nodes labelled in a BFS ordering? If not, the object is not 
valid.
</p>
</li></ol>



<h3>Value</h3>

<p>Constructors return an object of class TreeHarp.
</p>
<p><code>length</code>: An integer of length 1.
</p>
<p><code>print</code>: Returns NULL. It prints a string representation of a 
TreeHarp object.
</p>
<p><code>names</code>: A character vector with length equal to the number of 
nodes.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>TreeHarp</code>: A constructor for TreeHarp.
</p>
<p>Converts either adjacency list or matrix into a TreeHarp object.
</p>
</li>
<li> <p><code>TreeHarp</code>: A constructor for TreeHarp.
</p>
<p>Converts language object into a TreeHarp object.
</p>
</li>
<li> <p><code>length</code>: To get the length of a tree.
</p>
<p>The length of the tree refers to the number of nodes in the tree.
</p>
</li>
<li> <p><code>show</code>: To print a tree representation.
</p>
<p>A string representation of a TreeHarp object.
</p>
</li>
<li> <p><code>names</code>: To get tree labels
</p>
<p>This function returns the node labels of the tree.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>adjList</code></dt><dd><p>The adjacency list of the tree. The list must be named. The
nodes should be labelled in Breadth-First Order. The first component must
be the root of the tree. Leaves of the tree should be NULL elements.</p>
</dd>
<dt><code>nodeTypes</code></dt><dd><p>A data frame describing the type of node. The columns in the 
data frame will be derived from the expression used to instantiate the 
object. The column names will be id (node id), name, call_status, 
formal_arg and depth. This slot can be left missing (i.e., populated with 
NA). This latter feature is useful when we just wish to test something out.
</p>
<p>This slot is only populated automatically when an R expression is provided 
as <code>lang_obj</code> and <code>quote_arg</code> is TRUE.</p>
</dd>
<dt><code>repr</code></dt><dd><p>A string representation of the tree. This will be printed when the 
show method of TreeHarp is called.</p>
</dd>
<dt><code>call</code></dt><dd><p>The language object that was used to construct the tree (if it 
was). If the object was constructed from a list/matrix, this will be NA.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>l1 &lt;- list(a=c(2,3), b=NULL, c=NULL)
# directly using new() 
treeharp1 &lt;- new("TreeHarp", adjList = l1, nodeTypes = NA)

# using one of the constructor methods (for lists)
treeharp2 &lt;- TreeHarp(l1)

# using the constructor for matrices.
m1 &lt;- matrix(0L, 3, 3)
dimnames(m1) &lt;- list(letters[1:3], letters[1:3])
m1[1, ] &lt;- c(0, 1L, 1L)
m1[, 1] &lt;- c(0, 1L, 1L)
treeharp3 &lt;- TreeHarp(m1)

# Supplying a language object to get the same tree (with nodeTypes 
# populated)
ex1 &lt;- quote(a(b,c))
TreeHarp(ex1, TRUE)

</code></pre>

<hr>
<h2 id='update_adj_list'>Update adjacency list.</h2><span id='topic+update_adj_list'></span>

<h3>Description</h3>

<p>Updates the adjacency list for an R expression parse tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_adj_list(
  update_type = c("new_node", "add_child"),
  node_id,
  node_name,
  child_node,
  env_ni
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_adj_list_+3A_update_type">update_type</code></td>
<td>
<p>This should be either &quot;new_node&quot; or &quot;add_child&quot;. If it 
is a new node, an empty list component is added. If it is add child, 
then child_node should be provided too.</p>
</td></tr>
<tr><td><code id="update_adj_list_+3A_node_id">node_id</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="update_adj_list_+3A_node_name">node_name</code></td>
<td>
<p>The name of the new node to be added. This must be provided 
if the update_type is &quot;new_node&quot;.</p>
</td></tr>
<tr><td><code id="update_adj_list_+3A_child_node">child_node</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="update_adj_list_+3A_env_ni">env_ni</code></td>
<td>
<p>An environment object, possibly containing an adjacency list 
that will later be used to construct a TreeHarp object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is for internal use. It may be removed from user-view soon!
</p>


<h3>Value</h3>

<p>An invisible TRUE is returned.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
