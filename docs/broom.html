<!DOCTYPE html><html><head><title>Help for package broom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {broom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#broom'><p>broom: Convert Statistical Objects into Tidy Tibbles</p></a></li>
<li><a href='#augment_columns'><p>Add fitted values, residuals, and other common outputs to</p>
an augment call</a></li>
<li><a href='#augment.betamfx'><p>Augment data with information from a(n) betamfx object</p></a></li>
<li><a href='#augment.betareg'><p>Augment data with information from a(n) betareg object</p></a></li>
<li><a href='#augment.clm'><p>Augment data with information from a(n) clm object</p></a></li>
<li><a href='#augment.coxph'><p>Augment data with information from a(n) coxph object</p></a></li>
<li><a href='#augment.decomposed.ts'><p>Augment data with information from a(n) decomposed.ts object</p></a></li>
<li><a href='#augment.drc'><p>Augment data with information from a(n) drc object</p></a></li>
<li><a href='#augment.factanal'><p>Augment data with information from a(n) factanal object</p></a></li>
<li><a href='#augment.felm'><p>Augment data with information from a(n) felm object</p></a></li>
<li><a href='#augment.fixest'><p>Augment data with information from a(n) fixest object</p></a></li>
<li><a href='#augment.gam'><p>Augment data with information from a(n) gam object</p></a></li>
<li><a href='#augment.glm'><p>Augment data with information from a(n) glm object</p></a></li>
<li><a href='#augment.glmrob'><p>Augment data with information from a(n) glmrob object</p></a></li>
<li><a href='#augment.glmRob'><p>Augment data with information from a(n) glmRob object</p></a></li>
<li><a href='#augment.htest'><p>Augment data with information from a(n) htest object</p></a></li>
<li><a href='#augment.ivreg'><p>Augment data with information from a(n) ivreg object</p></a></li>
<li><a href='#augment.kmeans'><p>Augment data with information from a(n) kmeans object</p></a></li>
<li><a href='#augment.lm'><p>Augment data with information from a(n) lm object</p></a></li>
<li><a href='#augment.lmrob'><p>Augment data with information from a(n) lmrob object</p></a></li>
<li><a href='#augment.lmRob'><p>Augment data with information from a(n) lmRob object</p></a></li>
<li><a href='#augment.loess'><p>Tidy a(n) loess object</p></a></li>
<li><a href='#augment.Mclust'><p>Augment data with information from a(n) Mclust object</p></a></li>
<li><a href='#augment.mfx'><p>Augment data with information from a(n) mfx object</p></a></li>
<li><a href='#augment.mjoint'><p>Augment data with information from a(n) mjoint object</p></a></li>
<li><a href='#augment.mlogit'><p>Augment data with information from a(n) mlogit object</p></a></li>
<li><a href='#augment.nlrq'><p>Tidy a(n) nlrq object</p></a></li>
<li><a href='#augment.nls'><p>Augment data with information from a(n) nls object</p></a></li>
<li><a href='#augment.pam'><p>Augment data with information from a(n) pam object</p></a></li>
<li><a href='#augment.plm'><p>Augment data with information from a(n) plm object</p></a></li>
<li><a href='#augment.poLCA'><p>Augment data with information from a(n) poLCA object</p></a></li>
<li><a href='#augment.polr'><p>Augment data with information from a(n) polr object</p></a></li>
<li><a href='#augment.prcomp'><p>Augment data with information from a(n) prcomp object</p></a></li>
<li><a href='#augment.rlm'><p>Augment data with information from a(n) rlm object</p></a></li>
<li><a href='#augment.rma'><p>Augment data with information from a(n) rma object</p></a></li>
<li><a href='#augment.rq'><p>Augment data with information from a(n) rq object</p></a></li>
<li><a href='#augment.rqs'><p>Augment data with information from a(n) rqs object</p></a></li>
<li><a href='#augment.sarlm'><p>Augment data with information from a(n) spatialreg object</p></a></li>
<li><a href='#augment.smooth.spline'><p>Tidy a(n) smooth.spline object</p></a></li>
<li><a href='#augment.speedlm'><p>Augment data with information from a(n) speedlm object</p></a></li>
<li><a href='#augment.stl'><p>Augment data with information from a(n) stl object</p></a></li>
<li><a href='#augment.survreg'><p>Augment data with information from a(n) survreg object</p></a></li>
<li><a href='#bootstrap'><p>Set up bootstrap replicates of a dplyr operation</p></a></li>
<li><a href='#confint_tidy'><p>(Deprecated) Calculate confidence interval as a tidy data frame</p></a></li>
<li><a href='#data.frame_tidiers'><p>Tidiers for data.frame objects</p></a></li>
<li><a href='#durbinWatsonTest_tidiers'><p>Tidy/glance a(n) durbinWatsonTest object</p></a></li>
<li><a href='#finish_glance'><p>(Deprecated) Add logLik, AIC, BIC, and other common measurements to a</p>
glance of a prediction</a></li>
<li><a href='#fix_data_frame'><p>Ensure an object is a data frame, with rownames moved into a column</p></a></li>
<li><a href='#glance_optim'><p>Tidy a(n) optim object masquerading as list</p></a></li>
<li><a href='#glance.aareg'><p>Glance at a(n) aareg object</p></a></li>
<li><a href='#glance.anova'><p>Glance at a(n) anova object</p></a></li>
<li><a href='#glance.aov'><p>Glance at a(n) lm object</p></a></li>
<li><a href='#glance.Arima'><p>Glance at a(n) Arima object</p></a></li>
<li><a href='#glance.betamfx'><p>Glance at a(n) betamfx object</p></a></li>
<li><a href='#glance.betareg'><p>Glance at a(n) betareg object</p></a></li>
<li><a href='#glance.biglm'><p>Glance at a(n) biglm object</p></a></li>
<li><a href='#glance.binDesign'><p>Glance at a(n) binDesign object</p></a></li>
<li><a href='#glance.cch'><p>Glance at a(n) cch object</p></a></li>
<li><a href='#glance.clm'><p>Glance at a(n) clm object</p></a></li>
<li><a href='#glance.clmm'><p>Glance at a(n) clmm object</p></a></li>
<li><a href='#glance.coeftest'><p>Glance at a(n) coeftest object</p></a></li>
<li><a href='#glance.coxph'><p>Glance at a(n) coxph object</p></a></li>
<li><a href='#glance.crr'><p>Glance at a(n) crr object</p></a></li>
<li><a href='#glance.cv.glmnet'><p>Glance at a(n) cv.glmnet object</p></a></li>
<li><a href='#glance.drc'><p>Glance at a(n) drc object</p></a></li>
<li><a href='#glance.ergm'><p>Glance at a(n) ergm object</p></a></li>
<li><a href='#glance.factanal'><p>Glance at a(n) factanal object</p></a></li>
<li><a href='#glance.felm'><p>Glance at a(n) felm object</p></a></li>
<li><a href='#glance.fitdistr'><p>Glance at a(n) fitdistr object</p></a></li>
<li><a href='#glance.fixest'><p>Glance at a(n) fixest object</p></a></li>
<li><a href='#glance.gam'><p>Glance at a(n) gam object</p></a></li>
<li><a href='#glance.Gam'><p>Glance at a(n) Gam object</p></a></li>
<li><a href='#glance.garch'><p>Tidy a(n) garch object</p></a></li>
<li><a href='#glance.geeglm'><p>Glance at a(n) geeglm object</p></a></li>
<li><a href='#glance.glm'><p>Glance at a(n) glm object</p></a></li>
<li><a href='#glance.glmnet'><p>Glance at a(n) glmnet object</p></a></li>
<li><a href='#glance.glmRob'><p>Glance at a(n) glmRob object</p></a></li>
<li><a href='#glance.gmm'><p>Glance at a(n) gmm object</p></a></li>
<li><a href='#glance.ivreg'><p>Glance at a(n) ivreg object</p></a></li>
<li><a href='#glance.kmeans'><p>Glance at a(n) kmeans object</p></a></li>
<li><a href='#glance.lavaan'><p>Glance at a(n) lavaan object</p></a></li>
<li><a href='#glance.lm'><p>Glance at a(n) lm object</p></a></li>
<li><a href='#glance.lmodel2'><p>Glance at a(n) lmodel2 object</p></a></li>
<li><a href='#glance.lmrob'><p>Glance at a(n) lmrob object</p></a></li>
<li><a href='#glance.lmRob'><p>Glance at a(n) lmRob object</p></a></li>
<li><a href='#glance.margins'><p>Glance at a(n) margins object</p></a></li>
<li><a href='#glance.Mclust'><p>Glance at a(n) Mclust object</p></a></li>
<li><a href='#glance.mfx'><p>Glance at a(n) mfx object</p></a></li>
<li><a href='#glance.mjoint'><p>Glance at a(n) mjoint object</p></a></li>
<li><a href='#glance.mlogit'><p>Glance at a(n) mlogit object</p></a></li>
<li><a href='#glance.muhaz'><p>Glance at a(n) muhaz object</p></a></li>
<li><a href='#glance.multinom'><p>Glance at a(n) multinom object</p></a></li>
<li><a href='#glance.negbin'><p>Glance at a(n) negbin object</p></a></li>
<li><a href='#glance.nlrq'><p>Glance at a(n) nlrq object</p></a></li>
<li><a href='#glance.nls'><p>Glance at a(n) nls object</p></a></li>
<li><a href='#glance.orcutt'><p>Glance at a(n) orcutt object</p></a></li>
<li><a href='#glance.pam'><p>Glance at a(n) pam object</p></a></li>
<li><a href='#glance.plm'><p>Glance at a(n) plm object</p></a></li>
<li><a href='#glance.poLCA'><p>Glance at a(n) poLCA object</p></a></li>
<li><a href='#glance.polr'><p>Glance at a(n) polr object</p></a></li>
<li><a href='#glance.pyears'><p>Glance at a(n) pyears object</p></a></li>
<li><a href='#glance.ridgelm'><p>Glance at a(n) ridgelm object</p></a></li>
<li><a href='#glance.rlm'><p>Glance at a(n) rlm object</p></a></li>
<li><a href='#glance.rma'><p>Glance at a(n) rma object</p></a></li>
<li><a href='#glance.rq'><p>Glance at a(n) rq object</p></a></li>
<li><a href='#glance.sarlm'><p>Glance at a(n) spatialreg object</p></a></li>
<li><a href='#glance.smooth.spline'><p>Tidy a(n) smooth.spine object</p></a></li>
<li><a href='#glance.speedglm'><p>Glance at a(n) speedglm object</p></a></li>
<li><a href='#glance.speedlm'><p>Glance at a(n) speedlm object</p></a></li>
<li><a href='#glance.summary.lm'><p>Glance at a(n) summary.lm object</p></a></li>
<li><a href='#glance.survdiff'><p>Glance at a(n) survdiff object</p></a></li>
<li><a href='#glance.survexp'><p>Glance at a(n) survexp object</p></a></li>
<li><a href='#glance.survfit'><p>Glance at a(n) survfit object</p></a></li>
<li><a href='#glance.survreg'><p>Glance at a(n) survreg object</p></a></li>
<li><a href='#glance.svyglm'><p>Glance at a(n) svyglm object</p></a></li>
<li><a href='#glance.svyolr'><p>Glance at a(n) svyolr object</p></a></li>
<li><a href='#glance.varest'><p>Glance at a(n) varest object</p></a></li>
<li><a href='#leveneTest_tidiers'><p>Tidy/glance a(n) leveneTest object</p></a></li>
<li><a href='#list_tidiers'><p>Tidying methods for lists / returned values that are not S3 objects</p></a></li>
<li><a href='#null_tidiers'><p>Tidiers for NULL inputs</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sp_tidiers'><p>Tidy a(n) SpatialPolygonsDataFrame object</p></a></li>
<li><a href='#summary_tidiers'><p>(Deprecated) Tidy summaryDefault objects</p></a></li>
<li><a href='#tidy_irlba'><p>Tidy a(n) irlba object masquerading as list</p></a></li>
<li><a href='#tidy_optim'><p>Tidy a(n) optim object masquerading as list</p></a></li>
<li><a href='#tidy_svd'><p>Tidy a(n) svd object masquerading as list</p></a></li>
<li><a href='#tidy_xyz'><p>Tidy a(n) xyz object masquerading as list</p></a></li>
<li><a href='#tidy.aareg'><p>Tidy a(n) aareg object</p></a></li>
<li><a href='#tidy.acf'><p>Tidy a(n) acf object</p></a></li>
<li><a href='#tidy.anova'><p>Tidy a(n) anova object</p></a></li>
<li><a href='#tidy.aov'><p>Tidy a(n) aov object</p></a></li>
<li><a href='#tidy.aovlist'><p>Tidy a(n) aovlist object</p></a></li>
<li><a href='#tidy.Arima'><p>Tidy a(n) Arima object</p></a></li>
<li><a href='#tidy.betamfx'><p>Tidy a(n) betamfx object</p></a></li>
<li><a href='#tidy.betareg'><p>Tidy a(n) betareg object</p></a></li>
<li><a href='#tidy.biglm'><p>Tidy a(n) biglm object</p></a></li>
<li><a href='#tidy.binDesign'><p>Tidy a(n) binDesign object</p></a></li>
<li><a href='#tidy.binWidth'><p>Tidy a(n) binWidth object</p></a></li>
<li><a href='#tidy.boot'><p>Tidy a(n) boot object</p></a></li>
<li><a href='#tidy.btergm'><p>Tidy a(n) btergm object</p></a></li>
<li><a href='#tidy.cch'><p>Tidy a(n) cch object</p></a></li>
<li><a href='#tidy.cld'><p>Tidy a(n) cld object</p></a></li>
<li><a href='#tidy.clm'><p>Tidy a(n) clm object</p></a></li>
<li><a href='#tidy.clmm'><p>Tidy a(n) clmm object</p></a></li>
<li><a href='#tidy.coeftest'><p>Tidy a(n) coeftest object</p></a></li>
<li><a href='#tidy.confint.glht'><p>Tidy a(n) confint.glht object</p></a></li>
<li><a href='#tidy.confusionMatrix'><p>Tidy a(n) confusionMatrix object</p></a></li>
<li><a href='#tidy.coxph'><p>Tidy a(n) coxph object</p></a></li>
<li><a href='#tidy.crr'><p>Tidy a(n) cmprsk object</p></a></li>
<li><a href='#tidy.cv.glmnet'><p>Tidy a(n) cv.glmnet object</p></a></li>
<li><a href='#tidy.density'><p>(Deprecated) Tidy density objects</p></a></li>
<li><a href='#tidy.dist'><p>(Deprecated) Tidy dist objects</p></a></li>
<li><a href='#tidy.drc'><p>Tidy a(n) drc object</p></a></li>
<li><a href='#tidy.emmGrid'><p>Tidy a(n) emmGrid object</p></a></li>
<li><a href='#tidy.epi.2by2'><p>Tidy a(n) epi.2by2 object</p></a></li>
<li><a href='#tidy.ergm'><p>Tidy a(n) ergm object</p></a></li>
<li><a href='#tidy.factanal'><p>Tidy a(n) factanal object</p></a></li>
<li><a href='#tidy.felm'><p>Tidy a(n) felm object</p></a></li>
<li><a href='#tidy.fitdistr'><p>Tidy a(n) fitdistr object</p></a></li>
<li><a href='#tidy.fixest'><p>Tidy a(n) fixest object</p></a></li>
<li><a href='#tidy.ftable'><p>(Deprecated) Tidy ftable objects</p></a></li>
<li><a href='#tidy.gam'><p>Tidy a(n) gam object</p></a></li>
<li><a href='#tidy.Gam'><p>Tidy a(n) Gam object</p></a></li>
<li><a href='#tidy.garch'><p>Tidy a(n) garch object</p></a></li>
<li><a href='#tidy.geeglm'><p>Tidy a(n) geeglm object</p></a></li>
<li><a href='#tidy.glht'><p>Tidy a(n) glht object</p></a></li>
<li><a href='#tidy.glm'><p>Tidy a(n) glm object</p></a></li>
<li><a href='#tidy.glmnet'><p>Tidy a(n) glmnet object</p></a></li>
<li><a href='#tidy.glmrob'><p>Tidy a(n) glmrob object</p></a></li>
<li><a href='#tidy.glmRob'><p>Tidy a(n) glmRob object</p></a></li>
<li><a href='#tidy.gmm'><p>Tidy a(n) gmm object</p></a></li>
<li><a href='#tidy.htest'><p>Tidy/glance a(n) htest object</p></a></li>
<li><a href='#tidy.ivreg'><p>Tidy a(n) ivreg object</p></a></li>
<li><a href='#tidy.kappa'><p>Tidy a(n) kappa object</p></a></li>
<li><a href='#tidy.kde'><p>Tidy a(n) kde object</p></a></li>
<li><a href='#tidy.Kendall'><p>Tidy a(n) Kendall object</p></a></li>
<li><a href='#tidy.kmeans'><p>Tidy a(n) kmeans object</p></a></li>
<li><a href='#tidy.lavaan'><p>Tidy a(n) lavaan object</p></a></li>
<li><a href='#tidy.lm'><p>Tidy a(n) lm object</p></a></li>
<li><a href='#tidy.lm.beta'><p>Tidy a(n) lm.beta object</p></a></li>
<li><a href='#tidy.lmodel2'><p>Tidy a(n) lmodel2 object</p></a></li>
<li><a href='#tidy.lmrob'><p>Tidy a(n) lmrob object</p></a></li>
<li><a href='#tidy.lmRob'><p>Tidy a(n) lmRob object</p></a></li>
<li><a href='#tidy.lsmobj'><p>Tidy a(n) lsmobj object</p></a></li>
<li><a href='#tidy.manova'><p>Tidy a(n) manova object</p></a></li>
<li><a href='#tidy.map'><p>Tidy a(n) map object</p></a></li>
<li><a href='#tidy.margins'><p>Tidy a(n) margins object</p></a></li>
<li><a href='#tidy.Mclust'><p>Tidy a(n) Mclust object</p></a></li>
<li><a href='#tidy.mediate'><p>Tidy a(n) mediate object</p></a></li>
<li><a href='#tidy.mfx'><p>Tidy a(n) mfx object</p></a></li>
<li><a href='#tidy.mjoint'><p>Tidy a(n) mjoint object</p></a></li>
<li><a href='#tidy.mle2'><p>Tidy a(n) mle2 object</p></a></li>
<li><a href='#tidy.mlm'><p>Tidy a(n) mlm object</p></a></li>
<li><a href='#tidy.mlogit'><p>Tidying methods for logit models</p></a></li>
<li><a href='#tidy.muhaz'><p>Tidy a(n) muhaz object</p></a></li>
<li><a href='#tidy.multinom'><p>Tidying methods for multinomial logistic regression models</p></a></li>
<li><a href='#tidy.negbin'><p>Tidy a(n) negbin object</p></a></li>
<li><a href='#tidy.nlrq'><p>Tidy a(n) nlrq object</p></a></li>
<li><a href='#tidy.nls'><p>Tidy a(n) nls object</p></a></li>
<li><a href='#tidy.numeric'><p>Tidy atomic vectors</p></a></li>
<li><a href='#tidy.orcutt'><p>Tidy a(n) orcutt object</p></a></li>
<li><a href='#tidy.pairwise.htest'><p>Tidy a(n) pairwise.htest object</p></a></li>
<li><a href='#tidy.pam'><p>Tidy a(n) pam object</p></a></li>
<li><a href='#tidy.plm'><p>Tidy a(n) plm object</p></a></li>
<li><a href='#tidy.poLCA'><p>Tidy a(n) poLCA object</p></a></li>
<li><a href='#tidy.polr'><p>Tidy a(n) polr object</p></a></li>
<li><a href='#tidy.power.htest'><p>Tidy a(n) power.htest object</p></a></li>
<li><a href='#tidy.prcomp'><p>Tidy a(n) prcomp object</p></a></li>
<li><a href='#tidy.pyears'><p>Tidy a(n) pyears object</p></a></li>
<li><a href='#tidy.rcorr'><p>Tidy a(n) rcorr object</p></a></li>
<li><a href='#tidy.ref.grid'><p>Tidy a(n) ref.grid object</p></a></li>
<li><a href='#tidy.regsubsets'><p>Tidy a(n) regsubsets object</p></a></li>
<li><a href='#tidy.ridgelm'><p>Tidy a(n) ridgelm object</p></a></li>
<li><a href='#tidy.rlm'><p>Tidy a(n) rlm object</p></a></li>
<li><a href='#tidy.rma'><p>Tidy a(n) rma object</p></a></li>
<li><a href='#tidy.roc'><p>Tidy a(n) roc object</p></a></li>
<li><a href='#tidy.rq'><p>Tidy a(n) rq object</p></a></li>
<li><a href='#tidy.rqs'><p>Tidy a(n) rqs object</p></a></li>
<li><a href='#tidy.sarlm'><p>Tidying methods for spatially autoregressive models</p></a></li>
<li><a href='#tidy.spec'><p>Tidy a(n) spec object</p></a></li>
<li><a href='#tidy.speedglm'><p>Tidy a(n) speedglm object</p></a></li>
<li><a href='#tidy.speedlm'><p>Tidy a(n) speedlm object</p></a></li>
<li><a href='#tidy.summary_emm'><p>Tidy a(n) summary_emm object</p></a></li>
<li><a href='#tidy.summary.glht'><p>Tidy a(n) summary.glht object</p></a></li>
<li><a href='#tidy.summary.lm'><p>Tidy a(n) summary.lm object</p></a></li>
<li><a href='#tidy.survdiff'><p>Tidy a(n) survdiff object</p></a></li>
<li><a href='#tidy.survexp'><p>Tidy a(n) survexp object</p></a></li>
<li><a href='#tidy.survfit'><p>Tidy a(n) survfit object</p></a></li>
<li><a href='#tidy.survreg'><p>Tidy a(n) survreg object</p></a></li>
<li><a href='#tidy.svyglm'><p>Tidy a(n) svyglm object</p></a></li>
<li><a href='#tidy.svyolr'><p>Tidy a(n) svyolr object</p></a></li>
<li><a href='#tidy.systemfit'><p>Tidy a(n) systemfit object</p></a></li>
<li><a href='#tidy.table'><p>Tidy a(n) table object</p></a></li>
<li><a href='#tidy.ts'><p>Tidy a(n) ts object</p></a></li>
<li><a href='#tidy.TukeyHSD'><p>Tidy a(n) TukeyHSD object</p></a></li>
<li><a href='#tidy.varest'><p>Tidy a(n) varest object</p></a></li>
<li><a href='#tidy.zoo'><p>Tidy a(n) zoo object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convert Statistical Objects into Tidy Tibbles</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Summarizes key information about statistical
    objects in tidy tibbles. This makes it easy to report results, create
    plots and consistently work with large numbers of models at once.
    Broom provides three verbs that each provide different types of
    information about a model. tidy() summarizes information about model
    components such as coefficients of a regression. glance() reports
    information about an entire model, such as goodness of fit measures
    like AIC and BIC. augment() adds information about individual
    observations to a dataset, such as fitted values or influence
    measures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://broom.tidymodels.org/">https://broom.tidymodels.org/</a>, <a href="https://github.com/tidymodels/broom">https://github.com/tidymodels/broom</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidymodels/broom/issues">https://github.com/tidymodels/broom/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports, dplyr (&ge; 1.0.0), generics (&ge; 0.0.2), glue,
lifecycle, purrr, rlang, stringr, tibble (&ge; 3.0.0), tidyr (&ge;
1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, AUC, bbmle, betareg, biglm, binGroup, boot, btergm (&ge;
1.10.6), car, carData, caret, cluster, cmprsk, coda, covr, drc,
e1071, emmeans, epiR, ergm (&ge; 3.10.4), fixest (&ge; 0.9.0), gam
(&ge; 1.15), gee, geepack, ggplot2, glmnet, glmnetUtils, gmm,
Hmisc, irlba, interp, joineRML, Kendall, knitr, ks, Lahman,
lavaan, leaps, lfe, lm.beta, lme4, lmodel2, lmtest (&ge; 0.9.38),
lsmeans, maps, MASS, mclust, mediation, metafor, mfx, mgcv,
mlogit, modeldata, modeltests (&ge; 0.1.6), muhaz, multcomp,
network, nnet, orcutt (&ge; 2.2), ordinal, plm, poLCA, psych,
quantreg, rmarkdown, robust, robustbase, rsample, sandwich,
spdep (&ge; 1.1), spatialreg, speedglm, spelling, survey,
survival (&ge; 3.6-4), systemfit, testthat (&ge; 2.1.0), tseries,
vars, zoo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa-documentation-helper.R' 'null-and-default-tidiers.R'
'aer-tidiers.R' 'auc-tidiers.R' 'base-tidiers.R'
'bbmle-tidiers.R' 'betareg-tidiers.R' 'biglm-tidiers.R'
'bingroup-tidiers.R' 'boot-tidiers.R' 'broom-package.R'
'broom.R' 'btergm-tidiers.R' 'car-tidiers.R' 'caret-tidiers.R'
'cluster-tidiers.R' 'cmprsk-tidiers.R' 'data-frame-tidiers.R'
'deprecated-0-7-0.R' 'drc-tidiers.R' 'emmeans-tidiers.R'
'epiR-tidiers.R' 'ergm-tidiers.R' 'fixest-tidiers.R'
'gam-tidiers.R' 'geepack-tidiers.R'
'glmnet-cv-glmnet-tidiers.R' 'glmnet-glmnet-tidiers.R'
'gmm-tidiers.R' 'hmisc-tidiers.R' 'joinerml-tidiers.R'
'kendall-tidiers.R' 'ks-tidiers.R' 'lavaan-tidiers.R'
'leaps-tidiers.R' 'lfe-tidiers.R' 'list-irlba.R'
'list-optim-tidiers.R' 'list-svd-tidiers.R' 'list-tidiers.R'
'list-xyz-tidiers.R' 'lm-beta-tidiers.R' 'lmodel2-tidiers.R'
'lmtest-tidiers.R' 'maps-tidiers.R' 'margins-tidiers.R'
'mass-fitdistr-tidiers.R' 'mass-negbin-tidiers.R'
'mass-polr-tidiers.R' 'mass-ridgelm-tidiers.R'
'stats-lm-tidiers.R' 'mass-rlm-tidiers.R' 'mclust-tidiers.R'
'mediation-tidiers.R' 'metafor-tidiers.R' 'mfx-tidiers.R'
'mgcv-tidiers.R' 'mlogit-tidiers.R' 'muhaz-tidiers.R'
'multcomp-tidiers.R' 'nnet-tidiers.R' 'nobs.R'
'orcutt-tidiers.R' 'ordinal-clm-tidiers.R'
'ordinal-clmm-tidiers.R' 'plm-tidiers.R' 'polca-tidiers.R'
'psych-tidiers.R' 'stats-nls-tidiers.R'
'quantreg-nlrq-tidiers.R' 'quantreg-rq-tidiers.R'
'quantreg-rqs-tidiers.R' 'robust-glmrob-tidiers.R'
'robust-lmrob-tidiers.R' 'robustbase-glmrob-tidiers.R'
'robustbase-lmrob-tidiers.R' 'sp-tidiers.R' 'spdep-tidiers.R'
'speedglm-speedglm-tidiers.R' 'speedglm-speedlm-tidiers.R'
'stats-anova-tidiers.R' 'stats-arima-tidiers.R'
'stats-decompose-tidiers.R' 'stats-factanal-tidiers.R'
'stats-glm-tidiers.R' 'stats-htest-tidiers.R'
'stats-kmeans-tidiers.R' 'stats-loess-tidiers.R'
'stats-mlm-tidiers.R' 'stats-prcomp-tidiers.R'
'stats-smooth.spline-tidiers.R' 'stats-summary-lm-tidiers.R'
'stats-time-series-tidiers.R' 'survey-tidiers.R'
'survival-aareg-tidiers.R' 'survival-cch-tidiers.R'
'survival-coxph-tidiers.R' 'survival-pyears-tidiers.R'
'survival-survdiff-tidiers.R' 'survival-survexp-tidiers.R'
'survival-survfit-tidiers.R' 'survival-survreg-tidiers.R'
'systemfit-tidiers.R' 'tseries-tidiers.R' 'utilities.R'
'vars-tidiers.R' 'zoo-tidiers.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-16 15:07:03 UTC; simoncouch</td>
</tr>
<tr>
<td>Author:</td>
<td>David Robinson [aut],
  Alex Hayes <a href="https://orcid.org/0000-0002-4985-5160"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Simon Couch <a href="https://orcid.org/0000-0001-5676-5107"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Posit Software, PBC [cph, fnd],
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Derek Chiu [ctb],
  Matthieu Gomez [ctb],
  Boris Demeshev [ctb],
  Dieter Menne [ctb],
  Benjamin Nutter [ctb],
  Luke Johnston [ctb],
  Ben Bolker [ctb],
  Francois Briatte [ctb],
  Jeffrey Arnold [ctb],
  Jonah Gabry [ctb],
  Luciano Selzer [ctb],
  Gavin Simpson [ctb],
  Jens Preussner [ctb],
  Jay Hesselberth [ctb],
  Hadley Wickham [ctb],
  Matthew Lincoln [ctb],
  Alessandro Gasparini [ctb],
  Lukasz Komsta [ctb],
  Frederick Novometsky [ctb],
  Wilson Freitas [ctb],
  Michelle Evans [ctb],
  Jason Cory Brunson [ctb],
  Simon Jackson [ctb],
  Ben Whalley [ctb],
  Karissa Whiting [ctb],
  Yves Rosseel [ctb],
  Michael Kuehn [ctb],
  Jorge Cimentada [ctb],
  Erle Holgersen [ctb],
  Karl Dunkle Werner
    <a href="https://orcid.org/0000-0003-0523-7309"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Ethan Christensen [ctb],
  Steven Pav [ctb],
  Paul PJ [ctb],
  Ben Schneider [ctb],
  Patrick Kennedy [ctb],
  Lily Medina [ctb],
  Brian Fannin [ctb],
  Jason Muhlenkamp [ctb],
  Matt Lehman [ctb],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Nic Crane [ctb],
  Andrew Bates [ctb],
  Vincent Arel-Bundock
    <a href="https://orcid.org/0000-0003-2042-7063"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Hideaki Hayashi [ctb],
  Luis Tobalina [ctb],
  Annie Wang [ctb],
  Wei Yang Tham [ctb],
  Clara Wang [ctb],
  Abby Smith <a href="https://orcid.org/0000-0002-3207-0375"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Jasper Cooper <a href="https://orcid.org/0000-0002-8639-3188"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  E Auden Krauska <a href="https://orcid.org/0000-0002-1466-5850"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Alex Wang [ctb],
  Malcolm Barrett <a href="https://orcid.org/0000-0003-0299-5825"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Charles Gray <a href="https://orcid.org/0000-0002-9978-011X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jared Wilber [ctb],
  Vilmantas Gegzna <a href="https://orcid.org/0000-0002-9500-5167"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Eduard Szoecs [ctb],
  Frederik Aust <a href="https://orcid.org/0000-0003-4900-788X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Angus Moore [ctb],
  Nick Williams [ctb],
  Marius Barth <a href="https://orcid.org/0000-0002-3421-6665"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Bruna Wundervald <a href="https://orcid.org/0000-0001-8163-220X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Joyce Cahoon <a href="https://orcid.org/0000-0001-7217-4702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Grant McDermott <a href="https://orcid.org/0000-0001-7883-8573"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Kevin Zarca [ctb],
  Shiro Kuriwaki <a href="https://orcid.org/0000-0002-5687-2647"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Lukas Wallrich <a href="https://orcid.org/0000-0003-2121-5177"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  James Martherus <a href="https://orcid.org/0000-0002-8285-3300"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Chuliang Xiao <a href="https://orcid.org/0000-0002-8466-9398"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Joseph Larmarange [ctb],
  Max Kuhn [ctb],
  Michal Bojanowski [ctb],
  Hakon Malmedal [ctb],
  Clara Wang [ctb],
  Sergio Oller [ctb],
  Luke Sonnet [ctb],
  Jim Hester [ctb],
  Ben Schneider [ctb],
  Bernie Gray <a href="https://orcid.org/0000-0001-9190-6032"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Mara Averick [ctb],
  Aaron Jacobs [ctb],
  Andreas Bender [ctb],
  Sven Templer [ctb],
  Paul-Christian Buerkner [ctb],
  Matthew Kay [ctb],
  Erwan Le Pennec [ctb],
  Johan Junkka [ctb],
  Hao Zhu [ctb],
  Benjamin Soltoff [ctb],
  Zoe Wilkinson Saldana [ctb],
  Tyler Littlefield [ctb],
  Charles T. Gray [ctb],
  Shabbh E. Banks [ctb],
  Serina Robinson [ctb],
  Roger Bivand [ctb],
  Riinu Ots [ctb],
  Nicholas Williams [ctb],
  Nina Jakobsen [ctb],
  Michael Weylandt [ctb],
  Lisa Lendway [ctb],
  Karl Hailperin [ctb],
  Josue Rodriguez [ctb],
  Jenny Bryan [ctb],
  Chris Jarvis [ctb],
  Greg Macfarlane [ctb],
  Brian Mannakee [ctb],
  Drew Tyre [ctb],
  Shreyas Singh [ctb],
  Laurens Geffert [ctb],
  Hong Ooi [ctb],
  Henrik Bengtsson [ctb],
  Eduard Szocs [ctb],
  David Hugh-Jones [ctb],
  Matthieu Stigler [ctb],
  Hugo Tavares <a href="https://orcid.org/0000-0001-9373-2726"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  R. Willem Vervoort [ctb],
  Brenton M. Wiernik [ctb],
  Josh Yamamoto [ctb],
  Jasme Lee [ctb],
  Taren Sanders <a href="https://orcid.org/0000-0002-4504-6008"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ilaria Prosdocimi <a href="https://orcid.org/0000-0001-8565-094X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Daniel D. Sjoberg <a href="https://orcid.org/0000-0003-0862-2018"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Alex Reinhart <a href="https://orcid.org/0000-0002-6658-514X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Couch &lt;simon.couch@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='broom'>broom: Convert Statistical Objects into Tidy Tibbles</h2><span id='topic+broom'></span><span id='topic+broom-package'></span>

<h3>Description</h3>

<p>Convert statistical analysis objects from R into tidy tibbles,
so that they can more easily be combined, reshaped and otherwise processed
with tools like dplyr, tidyr and ggplot2. The package provides three S3
generics: tidy, which summarizes a model's statistical findings such as
coefficients of a regression; augment, which adds columns to the original
data such as predictions, residuals and cluster assignments; and glance,
which provides a one-row summary of model-level statistics.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Simon Couch <a href="mailto:simon.couch@posit.co">simon.couch@posit.co</a> (<a href="https://orcid.org/0000-0001-5676-5107">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> David Robinson <a href="mailto:admiral.david@gmail.com">admiral.david@gmail.com</a>
</p>
</li>
<li><p> Alex Hayes <a href="mailto:alexpghayes@gmail.com">alexpghayes@gmail.com</a> (<a href="https://orcid.org/0000-0002-4985-5160">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) [contributor]
</p>
</li>
<li><p> Derek Chiu <a href="mailto:dchiu@bccrc.ca">dchiu@bccrc.ca</a> [contributor]
</p>
</li>
<li><p> Matthieu Gomez <a href="mailto:mattg@princeton.edu">mattg@princeton.edu</a> [contributor]
</p>
</li>
<li><p> Boris Demeshev <a href="mailto:boris.demeshev@gmail.com">boris.demeshev@gmail.com</a> [contributor]
</p>
</li>
<li><p> Dieter Menne <a href="mailto:dieter.menne@menne-biomed.de">dieter.menne@menne-biomed.de</a> [contributor]
</p>
</li>
<li><p> Benjamin Nutter <a href="mailto:nutter@battelle.org">nutter@battelle.org</a> [contributor]
</p>
</li>
<li><p> Luke Johnston <a href="mailto:luke.johnston@mail.utoronto.ca">luke.johnston@mail.utoronto.ca</a> [contributor]
</p>
</li>
<li><p> Ben Bolker <a href="mailto:bolker@mcmaster.ca">bolker@mcmaster.ca</a> [contributor]
</p>
</li>
<li><p> Francois Briatte <a href="mailto:f.briatte@gmail.com">f.briatte@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jeffrey Arnold <a href="mailto:jeffrey.arnold@gmail.com">jeffrey.arnold@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jonah Gabry <a href="mailto:jsg2201@columbia.edu">jsg2201@columbia.edu</a> [contributor]
</p>
</li>
<li><p> Luciano Selzer <a href="mailto:luciano.selzer@gmail.com">luciano.selzer@gmail.com</a> [contributor]
</p>
</li>
<li><p> Gavin Simpson <a href="mailto:ucfagls@gmail.com">ucfagls@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jens Preussner <a href="mailto:jens.preussner@mpi-bn.mpg.de">jens.preussner@mpi-bn.mpg.de</a> [contributor]
</p>
</li>
<li><p> Jay Hesselberth <a href="mailto:jay.hesselberth@gmail.com">jay.hesselberth@gmail.com</a> [contributor]
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> [contributor]
</p>
</li>
<li><p> Matthew Lincoln <a href="mailto:matthew.d.lincoln@gmail.com">matthew.d.lincoln@gmail.com</a> [contributor]
</p>
</li>
<li><p> Alessandro Gasparini <a href="mailto:ag475@leicester.ac.uk">ag475@leicester.ac.uk</a> [contributor]
</p>
</li>
<li><p> Lukasz Komsta <a href="mailto:lukasz.komsta@umlub.pl">lukasz.komsta@umlub.pl</a> [contributor]
</p>
</li>
<li><p> Frederick Novometsky [contributor]
</p>
</li>
<li><p> Wilson Freitas [contributor]
</p>
</li>
<li><p> Michelle Evans [contributor]
</p>
</li>
<li><p> Jason Cory Brunson <a href="mailto:cornelioid@gmail.com">cornelioid@gmail.com</a> [contributor]
</p>
</li>
<li><p> Simon Jackson <a href="mailto:drsimonjackson@gmail.com">drsimonjackson@gmail.com</a> [contributor]
</p>
</li>
<li><p> Ben Whalley <a href="mailto:ben.whalley@plymouth.ac.uk">ben.whalley@plymouth.ac.uk</a> [contributor]
</p>
</li>
<li><p> Karissa Whiting <a href="mailto:karissa.whiting@gmail.com">karissa.whiting@gmail.com</a> [contributor]
</p>
</li>
<li><p> Yves Rosseel <a href="mailto:yrosseel@gmail.com">yrosseel@gmail.com</a> [contributor]
</p>
</li>
<li><p> Michael Kuehn <a href="mailto:mkuehn10@gmail.com">mkuehn10@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jorge Cimentada <a href="mailto:cimentadaj@gmail.com">cimentadaj@gmail.com</a> [contributor]
</p>
</li>
<li><p> Erle Holgersen <a href="mailto:erle.holgersen@gmail.com">erle.holgersen@gmail.com</a> [contributor]
</p>
</li>
<li><p> Karl Dunkle Werner (<a href="https://orcid.org/0000-0003-0523-7309">ORCID</a>) [contributor]
</p>
</li>
<li><p> Ethan Christensen <a href="mailto:christensen.ej@gmail.com">christensen.ej@gmail.com</a> [contributor]
</p>
</li>
<li><p> Steven Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a> [contributor]
</p>
</li>
<li><p> Paul PJ <a href="mailto:pjpaul.stephens@gmail.com">pjpaul.stephens@gmail.com</a> [contributor]
</p>
</li>
<li><p> Ben Schneider <a href="mailto:benjamin.julius.schneider@gmail.com">benjamin.julius.schneider@gmail.com</a> [contributor]
</p>
</li>
<li><p> Patrick Kennedy <a href="mailto:pkqstr@protonmail.com">pkqstr@protonmail.com</a> [contributor]
</p>
</li>
<li><p> Lily Medina <a href="mailto:lilymiru@gmail.com">lilymiru@gmail.com</a> [contributor]
</p>
</li>
<li><p> Brian Fannin <a href="mailto:captain@pirategrunt.com">captain@pirategrunt.com</a> [contributor]
</p>
</li>
<li><p> Jason Muhlenkamp <a href="mailto:jason.muhlenkamp@gmail.com">jason.muhlenkamp@gmail.com</a> [contributor]
</p>
</li>
<li><p> Matt Lehman [contributor]
</p>
</li>
<li><p> Bill Denney <a href="mailto:wdenney@humanpredictions.com">wdenney@humanpredictions.com</a> (<a href="https://orcid.org/0000-0002-5759-428X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Nic Crane [contributor]
</p>
</li>
<li><p> Andrew Bates [contributor]
</p>
</li>
<li><p> Vincent Arel-Bundock <a href="mailto:vincent.arel-bundock@umontreal.ca">vincent.arel-bundock@umontreal.ca</a> (<a href="https://orcid.org/0000-0003-2042-7063">ORCID</a>) [contributor]
</p>
</li>
<li><p> Hideaki Hayashi [contributor]
</p>
</li>
<li><p> Luis Tobalina [contributor]
</p>
</li>
<li><p> Annie Wang <a href="mailto:anniewang.uc@gmail.com">anniewang.uc@gmail.com</a> [contributor]
</p>
</li>
<li><p> Wei Yang Tham <a href="mailto:weiyang.tham@gmail.com">weiyang.tham@gmail.com</a> [contributor]
</p>
</li>
<li><p> Clara Wang <a href="mailto:clara.wang.94@gmail.com">clara.wang.94@gmail.com</a> [contributor]
</p>
</li>
<li><p> Abby Smith <a href="mailto:als1@u.northwestern.edu">als1@u.northwestern.edu</a> (<a href="https://orcid.org/0000-0002-3207-0375">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jasper Cooper <a href="mailto:jaspercooper@gmail.com">jaspercooper@gmail.com</a> (<a href="https://orcid.org/0000-0002-8639-3188">ORCID</a>) [contributor]
</p>
</li>
<li><p> E Auden Krauska <a href="mailto:krauskae@gmail.com">krauskae@gmail.com</a> (<a href="https://orcid.org/0000-0002-1466-5850">ORCID</a>) [contributor]
</p>
</li>
<li><p> Alex Wang <a href="mailto:x249wang@uwaterloo.ca">x249wang@uwaterloo.ca</a> [contributor]
</p>
</li>
<li><p> Malcolm Barrett <a href="mailto:malcolmbarrett@gmail.com">malcolmbarrett@gmail.com</a> (<a href="https://orcid.org/0000-0003-0299-5825">ORCID</a>) [contributor]
</p>
</li>
<li><p> Charles Gray <a href="mailto:charlestigray@gmail.com">charlestigray@gmail.com</a> (<a href="https://orcid.org/0000-0002-9978-011X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jared Wilber [contributor]
</p>
</li>
<li><p> Vilmantas Gegzna <a href="mailto:GegznaV@gmail.com">GegznaV@gmail.com</a> (<a href="https://orcid.org/0000-0002-9500-5167">ORCID</a>) [contributor]
</p>
</li>
<li><p> Eduard Szoecs <a href="mailto:eduardszoecs@gmail.com">eduardszoecs@gmail.com</a> [contributor]
</p>
</li>
<li><p> Frederik Aust <a href="mailto:frederik.aust@uni-koeln.de">frederik.aust@uni-koeln.de</a> (<a href="https://orcid.org/0000-0003-4900-788X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Angus Moore <a href="mailto:angusmoore9@gmail.com">angusmoore9@gmail.com</a> [contributor]
</p>
</li>
<li><p> Nick Williams <a href="mailto:ntwilliams.personal@gmail.com">ntwilliams.personal@gmail.com</a> [contributor]
</p>
</li>
<li><p> Marius Barth <a href="mailto:marius.barth.uni.koeln@gmail.com">marius.barth.uni.koeln@gmail.com</a> (<a href="https://orcid.org/0000-0002-3421-6665">ORCID</a>) [contributor]
</p>
</li>
<li><p> Bruna Wundervald <a href="mailto:brunadaviesw@gmail.com">brunadaviesw@gmail.com</a> (<a href="https://orcid.org/0000-0001-8163-220X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Joyce Cahoon <a href="mailto:joyceyu48@gmail.com">joyceyu48@gmail.com</a> (<a href="https://orcid.org/0000-0001-7217-4702">ORCID</a>) [contributor]
</p>
</li>
<li><p> Grant McDermott <a href="mailto:grantmcd@uoregon.edu">grantmcd@uoregon.edu</a> (<a href="https://orcid.org/0000-0001-7883-8573">ORCID</a>) [contributor]
</p>
</li>
<li><p> Kevin Zarca <a href="mailto:kevin.zarca@gmail.com">kevin.zarca@gmail.com</a> [contributor]
</p>
</li>
<li><p> Shiro Kuriwaki <a href="mailto:shirokuriwaki@gmail.com">shirokuriwaki@gmail.com</a> (<a href="https://orcid.org/0000-0002-5687-2647">ORCID</a>) [contributor]
</p>
</li>
<li><p> Lukas Wallrich <a href="mailto:lukas.wallrich@gmail.com">lukas.wallrich@gmail.com</a> (<a href="https://orcid.org/0000-0003-2121-5177">ORCID</a>) [contributor]
</p>
</li>
<li><p> James Martherus <a href="mailto:james@martherus.com">james@martherus.com</a> (<a href="https://orcid.org/0000-0002-8285-3300">ORCID</a>) [contributor]
</p>
</li>
<li><p> Chuliang Xiao <a href="mailto:cxiao@umich.edu">cxiao@umich.edu</a> (<a href="https://orcid.org/0000-0002-8466-9398">ORCID</a>) [contributor]
</p>
</li>
<li><p> Joseph Larmarange <a href="mailto:joseph@larmarange.net">joseph@larmarange.net</a> [contributor]
</p>
</li>
<li><p> Max Kuhn <a href="mailto:max@posit.co">max@posit.co</a> [contributor]
</p>
</li>
<li><p> Michal Bojanowski <a href="mailto:michal2992@gmail.com">michal2992@gmail.com</a> [contributor]
</p>
</li>
<li><p> Hakon Malmedal <a href="mailto:hmalmedal@gmail.com">hmalmedal@gmail.com</a> [contributor]
</p>
</li>
<li><p> Clara Wang [contributor]
</p>
</li>
<li><p> Sergio Oller <a href="mailto:sergioller@gmail.com">sergioller@gmail.com</a> [contributor]
</p>
</li>
<li><p> Luke Sonnet <a href="mailto:luke.sonnet@gmail.com">luke.sonnet@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jim Hester <a href="mailto:jim.hester@posit.co">jim.hester@posit.co</a> [contributor]
</p>
</li>
<li><p> Ben Schneider <a href="mailto:benjamin.julius.schneider@gmail.com">benjamin.julius.schneider@gmail.com</a> [contributor]
</p>
</li>
<li><p> Bernie Gray <a href="mailto:bfgray3@gmail.com">bfgray3@gmail.com</a> (<a href="https://orcid.org/0000-0001-9190-6032">ORCID</a>) [contributor]
</p>
</li>
<li><p> Mara Averick <a href="mailto:mara@posit.co">mara@posit.co</a> [contributor]
</p>
</li>
<li><p> Aaron Jacobs <a href="mailto:atheriel@gmail.com">atheriel@gmail.com</a> [contributor]
</p>
</li>
<li><p> Andreas Bender <a href="mailto:bender.at.R@gmail.com">bender.at.R@gmail.com</a> [contributor]
</p>
</li>
<li><p> Sven Templer <a href="mailto:sven.templer@gmail.com">sven.templer@gmail.com</a> [contributor]
</p>
</li>
<li><p> Paul-Christian Buerkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a> [contributor]
</p>
</li>
<li><p> Matthew Kay <a href="mailto:mjskay@umich.edu">mjskay@umich.edu</a> [contributor]
</p>
</li>
<li><p> Erwan Le Pennec <a href="mailto:lepennec@gmail.com">lepennec@gmail.com</a> [contributor]
</p>
</li>
<li><p> Johan Junkka <a href="mailto:johan.junkka@umu.se">johan.junkka@umu.se</a> [contributor]
</p>
</li>
<li><p> Hao Zhu <a href="mailto:haozhu233@gmail.com">haozhu233@gmail.com</a> [contributor]
</p>
</li>
<li><p> Benjamin Soltoff <a href="mailto:soltoffbc@uchicago.edu">soltoffbc@uchicago.edu</a> [contributor]
</p>
</li>
<li><p> Zoe Wilkinson Saldana <a href="mailto:zoewsaldana@gmail.com">zoewsaldana@gmail.com</a> [contributor]
</p>
</li>
<li><p> Tyler Littlefield <a href="mailto:tylurp1@gmail.com">tylurp1@gmail.com</a> [contributor]
</p>
</li>
<li><p> Charles T. Gray <a href="mailto:charlestigray@gmail.com">charlestigray@gmail.com</a> [contributor]
</p>
</li>
<li><p> Shabbh E. Banks [contributor]
</p>
</li>
<li><p> Serina Robinson <a href="mailto:robi0916@umn.edu">robi0916@umn.edu</a> [contributor]
</p>
</li>
<li><p> Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> [contributor]
</p>
</li>
<li><p> Riinu Ots <a href="mailto:riinuots@gmail.com">riinuots@gmail.com</a> [contributor]
</p>
</li>
<li><p> Nicholas Williams <a href="mailto:ntwilliams.personal@gmail.com">ntwilliams.personal@gmail.com</a> [contributor]
</p>
</li>
<li><p> Nina Jakobsen [contributor]
</p>
</li>
<li><p> Michael Weylandt <a href="mailto:michael.weylandt@gmail.com">michael.weylandt@gmail.com</a> [contributor]
</p>
</li>
<li><p> Lisa Lendway <a href="mailto:llendway@macalester.edu">llendway@macalester.edu</a> [contributor]
</p>
</li>
<li><p> Karl Hailperin <a href="mailto:khailper@gmail.com">khailper@gmail.com</a> [contributor]
</p>
</li>
<li><p> Josue Rodriguez <a href="mailto:jerrodriguez@ucdavis.edu">jerrodriguez@ucdavis.edu</a> [contributor]
</p>
</li>
<li><p> Jenny Bryan <a href="mailto:jenny@posit.co">jenny@posit.co</a> [contributor]
</p>
</li>
<li><p> Chris Jarvis <a href="mailto:Christopher1.jarvis@gmail.com">Christopher1.jarvis@gmail.com</a> [contributor]
</p>
</li>
<li><p> Greg Macfarlane <a href="mailto:gregmacfarlane@gmail.com">gregmacfarlane@gmail.com</a> [contributor]
</p>
</li>
<li><p> Brian Mannakee <a href="mailto:bmannakee@gmail.com">bmannakee@gmail.com</a> [contributor]
</p>
</li>
<li><p> Drew Tyre <a href="mailto:atyre2@unl.edu">atyre2@unl.edu</a> [contributor]
</p>
</li>
<li><p> Shreyas Singh <a href="mailto:shreyas.singh.298@gmail.com">shreyas.singh.298@gmail.com</a> [contributor]
</p>
</li>
<li><p> Laurens Geffert <a href="mailto:laurensgeffert@gmail.com">laurensgeffert@gmail.com</a> [contributor]
</p>
</li>
<li><p> Hong Ooi <a href="mailto:hongooi@microsoft.com">hongooi@microsoft.com</a> [contributor]
</p>
</li>
<li><p> Henrik Bengtsson <a href="mailto:henrikb@braju.com">henrikb@braju.com</a> [contributor]
</p>
</li>
<li><p> Eduard Szocs <a href="mailto:eduardszoecs@gmail.com">eduardszoecs@gmail.com</a> [contributor]
</p>
</li>
<li><p> David Hugh-Jones <a href="mailto:davidhughjones@gmail.com">davidhughjones@gmail.com</a> [contributor]
</p>
</li>
<li><p> Matthieu Stigler <a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a> [contributor]
</p>
</li>
<li><p> Hugo Tavares <a href="mailto:hm533@cam.ac.uk">hm533@cam.ac.uk</a> (<a href="https://orcid.org/0000-0001-9373-2726">ORCID</a>) [contributor]
</p>
</li>
<li><p> R. Willem Vervoort <a href="mailto:Willemvervoort@gmail.com">Willemvervoort@gmail.com</a> [contributor]
</p>
</li>
<li><p> Brenton M. Wiernik <a href="mailto:brenton@wiernik.org">brenton@wiernik.org</a> [contributor]
</p>
</li>
<li><p> Josh Yamamoto <a href="mailto:joshuayamamoto5@gmail.com">joshuayamamoto5@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jasme Lee [contributor]
</p>
</li>
<li><p> Taren Sanders <a href="mailto:taren.sanders@acu.edu.au">taren.sanders@acu.edu.au</a> (<a href="https://orcid.org/0000-0002-4504-6008">ORCID</a>) [contributor]
</p>
</li>
<li><p> Ilaria Prosdocimi <a href="mailto:prosdocimi.ilaria@gmail.com">prosdocimi.ilaria@gmail.com</a> (<a href="https://orcid.org/0000-0001-8565-094X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Daniel D. Sjoberg <a href="mailto:danield.sjoberg@gmail.com">danield.sjoberg@gmail.com</a> (<a href="https://orcid.org/0000-0003-0862-2018">ORCID</a>) [contributor]
</p>
</li>
<li><p> Alex Reinhart <a href="mailto:areinhar@stat.cmu.edu">areinhar@stat.cmu.edu</a> (<a href="https://orcid.org/0000-0002-6658-514X">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://broom.tidymodels.org/">https://broom.tidymodels.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidymodels/broom">https://github.com/tidymodels/broom</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidymodels/broom/issues">https://github.com/tidymodels/broom/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augment_columns'>Add fitted values, residuals, and other common outputs to
an augment call</h2><span id='topic+augment_columns'></span>

<h3>Description</h3>

<p><code>augment_columns</code> is intended for use in the internals of <code>augment</code> methods
only and is exported for developers extending the broom package. Please
instead use <code><a href="#topic+augment">augment()</a></code> to appropriately make use of the functionality
in <code>augment_columns()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augment_columns(
  x,
  data,
  newdata = NULL,
  type,
  type.predict = type,
  type.residuals = type,
  se.fit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment_columns_+3A_x">x</code></td>
<td>
<p>a model</p>
</td></tr>
<tr><td><code id="augment_columns_+3A_data">data</code></td>
<td>
<p>original data onto which columns should be added</p>
</td></tr>
<tr><td><code id="augment_columns_+3A_newdata">newdata</code></td>
<td>
<p>new data to predict on, optional</p>
</td></tr>
<tr><td><code id="augment_columns_+3A_type">type</code></td>
<td>
<p>Type of prediction and residuals to compute</p>
</td></tr>
<tr><td><code id="augment_columns_+3A_type.predict">type.predict</code></td>
<td>
<p>Type of prediction to compute; by default
same as <code>type</code></p>
</td></tr>
<tr><td><code id="augment_columns_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Type of residuals to compute; by default
same as <code>type</code></p>
</td></tr>
<tr><td><code id="augment_columns_+3A_se.fit">se.fit</code></td>
<td>
<p>Value to pass to predict's <code>se.fit</code>, or NULL for
no value</p>
</td></tr>
<tr><td><code id="augment_columns_+3A_...">...</code></td>
<td>
<p>extra arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, in the case that a <code>residuals()</code> or <code>influence()</code> generic is
not implemented for the supplied model <code>x</code>, the function will fail quietly.
</p>

<hr>
<h2 id='augment.betamfx'>Augment data with information from a(n) betamfx object</h2><span id='topic+augment.betamfx'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betamfx'
augment(
  x,
  data = model.frame(x$fit),
  newdata = NULL,
  type.predict = c("response", "link", "precision", "variance", "quantile"),
  type.residuals = c("sweighted2", "deviance", "pearson", "response", "weighted",
    "sweighted"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.betamfx_+3A_x">x</code></td>
<td>
<p>A <code>betamfx</code>  object.</p>
</td></tr>
<tr><td><code id="augment.betamfx_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.betamfx_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.betamfx_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed to
the <code>type</code> argument of <code><a href="betareg.html#topic+predict.betareg">betareg::predict.betareg()</a></code>. Defaults to
<code>"response"</code>.</p>
</td></tr>
<tr><td><code id="augment.betamfx_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed
to the <code>type</code> argument of <code><a href="betareg.html#topic+residuals.betareg">betareg::residuals.betareg()</a></code>. Defaults to
<code style="white-space: pre;">&#8288;"sweighted2&#8288;</code>.</p>
</td></tr>
<tr><td><code id="augment.betamfx_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This augment method wraps <code><a href="#topic+augment.betareg">augment.betareg()</a></code> for
<code><a href="mfx.html#topic+betamfx">mfx::betamfx()</a></code> objects.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment.betareg">augment.betareg()</a></code>, <code><a href="mfx.html#topic+betamfx">mfx::betamfx()</a></code>
</p>
<p>Other mfx tidiers: 
<code><a href="#topic+augment.mfx">augment.mfx</a>()</code>,
<code><a href="#topic+glance.betamfx">glance.betamfx</a>()</code>,
<code><a href="#topic+glance.mfx">glance.mfx</a>()</code>,
<code><a href="#topic+tidy.betamfx">tidy.betamfx</a>()</code>,
<code><a href="#topic+tidy.mfx">tidy.mfx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(mfx)

# Simulate some data
set.seed(12345)
n &lt;- 1000
x &lt;- rnorm(n)

# Beta outcome
y &lt;- rbeta(n, shape1 = plogis(1 + 0.5 * x), shape2 = (abs(0.2 * x)))
# Use Smithson and Verkuilen correction
y &lt;- (y * (n - 1) + 0.5) / n

d &lt;- data.frame(y, x)
mod_betamfx &lt;- betamfx(y ~ x | x, data = d)

tidy(mod_betamfx, conf.int = TRUE)

# Compare with the naive model coefficients of the equivalent betareg call (not run)
# tidy(betamfx(y ~ x | x, data = d), conf.int = TRUE)

augment(mod_betamfx)
glance(mod_betamfx)

</code></pre>

<hr>
<h2 id='augment.betareg'>Augment data with information from a(n) betareg object</h2><span id='topic+augment.betareg'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict,
  type.residuals,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.betareg_+3A_x">x</code></td>
<td>
<p>A <code>betareg</code> object produced by a call to <code><a href="betareg.html#topic+betareg">betareg::betareg()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.betareg_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.betareg_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.betareg_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed
to the <code>type</code> argument of the <code><a href="stats.html#topic+predict">stats::predict()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>predict.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.betareg_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed
to the <code>type</code> argument of <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>residuals.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.betareg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For additional details on Cook's distance, see
<code><a href="stats.html#topic+influence.measures">stats::cooks.distance()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="betareg.html#topic+betareg">betareg::betareg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(betareg)

# load dats
data("GasolineYield", package = "betareg")

# fit model
mod &lt;- betareg(yield ~ batch + temp, data = GasolineYield)

mod

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)
tidy(mod, conf.int = TRUE, conf.level = .99)

augment(mod)

glance(mod)

</code></pre>

<hr>
<h2 id='augment.clm'>Augment data with information from a(n) clm object</h2><span id='topic+augment.clm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clm'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict = c("prob", "class"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.clm_+3A_x">x</code></td>
<td>
<p>A <code>clm</code> object returned from <code><a href="ordinal.html#topic+clm">ordinal::clm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.clm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.clm_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.clm_+3A_type.predict">type.predict</code></td>
<td>
<p>Which type of prediction to compute, either <code>"prob"</code>
or <code>"class"</code>, passed to <code><a href="ordinal.html#topic+predict">ordinal::predict.clm()</a></code>. Defaults to <code>"prob"</code>.</p>
</td></tr>
<tr><td><code id="augment.clm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="ordinal.html#topic+clm">ordinal::clm()</a></code>, <code><a href="ordinal.html#topic+predict">ordinal::predict.clm()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ordinal)

# fit model
fit &lt;- clm(rating ~ temp * contact, data = wine)

# summarize model fit with tidiers
tidy(fit)
tidy(fit, conf.int = TRUE, conf.level = 0.9)
tidy(fit, conf.int = TRUE, conf.type = "Wald", exponentiate = TRUE)

glance(fit)
augment(fit, type.predict = "prob")
augment(fit, type.predict = "class")

# ...and again with another model specification
fit2 &lt;- clm(rating ~ temp, nominal = ~contact, data = wine)

tidy(fit2)
glance(fit2)

</code></pre>

<hr>
<h2 id='augment.coxph'>Augment data with information from a(n) coxph object</h2><span id='topic+augment.coxph'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxph'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict = "lp",
  type.residuals = "martingale",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.coxph_+3A_x">x</code></td>
<td>
<p>A <code>coxph</code> object returned from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.coxph_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.coxph_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.coxph_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed
to the <code>type</code> argument of the <code><a href="stats.html#topic+predict">stats::predict()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>predict.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.coxph_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed
to the <code>type</code> argument of <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>residuals.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.coxph_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code><a href="#topic+augment">augment()</a></code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">stats::na.action</a>
</p>
<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
<p>Other coxph tidiers: 
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
cfit &lt;- coxph(Surv(time, status) ~ age + sex, lung)

# summarize model fit with tidiers
tidy(cfit)
tidy(cfit, exponentiate = TRUE)

lp &lt;- augment(cfit, lung)
risks &lt;- augment(cfit, lung, type.predict = "risk")
expected &lt;- augment(cfit, lung, type.predict = "expected")

glance(cfit)

# also works on clogit models
resp &lt;- levels(logan$occupation)
n &lt;- nrow(logan)
indx &lt;- rep(1:n, length(resp))
logan2 &lt;- data.frame(
  logan[indx, ],
  id = indx,
  tocc = factor(rep(resp, each = n))
)

logan2$case &lt;- (logan2$occupation == logan2$tocc)

cl &lt;- clogit(case ~ tocc + tocc:education + strata(id), logan2)

tidy(cl)
glance(cl)

library(ggplot2)

ggplot(lp, aes(age, .fitted, color = sex)) +
  geom_point()

ggplot(risks, aes(age, .fitted, color = sex)) +
  geom_point()

ggplot(expected, aes(time, .fitted, color = sex)) +
  geom_point()

</code></pre>

<hr>
<h2 id='augment.decomposed.ts'>Augment data with information from a(n) decomposed.ts object</h2><span id='topic+augment.decomposed.ts'></span><span id='topic+decompose_tidiers'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decomposed.ts'
augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.decomposed.ts_+3A_x">x</code></td>
<td>
<p>A <code>decomposed.ts</code> object returned from <code><a href="stats.html#topic+decompose">stats::decompose()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.decomposed.ts_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with one row for each observation in the
original times series:
</p>
<table>
<tr><td><code>.seasonal</code></td>
<td>
<p>The seasonal component of the decomposition.</p>
</td></tr>
<tr><td><code>.trend</code></td>
<td>
<p>The trend component of the decomposition.</p>
</td></tr>
<tr><td><code>.remainder</code></td>
<td>
<p>The remainder, or &quot;random&quot; component of the
decomposition.</p>
</td></tr>
<tr><td><code>.weight</code></td>
<td>
<p>The final robust weights (<code>stl</code> only).</p>
</td></tr>
<tr><td><code>.seasadj</code></td>
<td>
<p>The seasonally adjusted (or &quot;deseasonalised&quot;)
series.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+decompose">stats::decompose()</a></code>
</p>
<p>Other decompose tidiers: 
<code><a href="#topic+augment.stl">augment.stl</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# time series of temperatures in Nottingham, 1920-1939:
nottem

# perform seasonal decomposition on the data with both decompose
# and stl:
d1 &lt;- decompose(nottem)
d2 &lt;- stl(nottem, s.window = "periodic", robust = TRUE)

# compare the original series to its decompositions.

cbind(
  tidy(nottem), augment(d1),
  augment(d2)
)

# visually compare seasonal decompositions in tidy data frames.

library(tibble)
library(dplyr)
library(tidyr)
library(ggplot2)

decomps &lt;- tibble(
  # turn the ts objects into data frames.
  series = list(as.data.frame(nottem), as.data.frame(nottem)),
  # add the models in, one for each row.
  decomp = c("decompose", "stl"),
  model = list(d1, d2)
) %&gt;%
  rowwise() %&gt;%
  # pull out the fitted data using broom::augment.
  mutate(augment = list(broom::augment(model))) %&gt;%
  ungroup() %&gt;%
  # unnest the data frames into a tidy arrangement of
  # the series next to its seasonal decomposition, grouped
  # by the method (stl or decompose).
  group_by(decomp) %&gt;%
  unnest(c(series, augment)) %&gt;%
  mutate(index = 1:n()) %&gt;%
  ungroup() %&gt;%
  select(decomp, index, x, adjusted = .seasadj)

ggplot(decomps) +
  geom_line(aes(x = index, y = x), colour = "black") +
  geom_line(aes(
    x = index, y = adjusted, colour = decomp,
    group = decomp
  ))

</code></pre>

<hr>
<h2 id='augment.drc'>Augment data with information from a(n) drc object</h2><span id='topic+augment.drc'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drc'
augment(
  x,
  data = NULL,
  newdata = NULL,
  se_fit = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.drc_+3A_x">x</code></td>
<td>
<p>A <code>drc</code> object produced by a call to <code><a href="drc.html#topic+drm">drc::drm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.drc_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.drc_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.drc_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.drc_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.drc_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="augment.drc_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.lower</code></td>
<td>
<p>Lower bound on interval for fitted values.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.upper</code></td>
<td>
<p>Upper bound on interval for fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="drc.html#topic+drm">drc::drm()</a></code>
</p>
<p>Other drc tidiers: 
<code><a href="#topic+glance.drc">glance.drc</a>()</code>,
<code><a href="#topic+tidy.drc">tidy.drc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(drc)

# fit model
mod &lt;- drm(dead / total ~ conc, type,
  weights = total, data = selenium, fct = LL.2(), type = "binomial"
)

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)

glance(mod)

augment(mod, selenium)

</code></pre>

<hr>
<h2 id='augment.factanal'>Augment data with information from a(n) factanal object</h2><span id='topic+augment.factanal'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factanal'
augment(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.factanal_+3A_x">x</code></td>
<td>
<p>A <code>factanal</code> object created by <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.factanal_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.factanal_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>data</code> is not supplied <code>augment.factanal</code> returns one
row for each observation, with a factor score column added for each factor
X, (<code>.fsX</code>). This is because <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>, unlike other
stats methods like <code><a href="stats.html#topic+lm">stats::lm()</a></code>, does not retain the original data.
</p>
<p>When <code>data</code> is supplied, <code>augment.factanal</code> returns one row for
each observation, with a factor score column added for each factor X,
(<code>.fsX</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>
</p>
<p>Other factanal tidiers: 
<code><a href="#topic+glance.factanal">glance.factanal</a>()</code>,
<code><a href="#topic+tidy.factanal">tidy.factanal</a>()</code>
</p>

<hr>
<h2 id='augment.felm'>Augment data with information from a(n) felm object</h2><span id='topic+augment.felm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'felm'
augment(x, data = model.frame(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.felm_+3A_x">x</code></td>
<td>
<p>A <code>felm</code> object returned from <code><a href="lfe.html#topic+felm">lfe::felm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.felm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.felm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="lfe.html#topic+felm">lfe::felm()</a></code>
</p>
<p>Other felm tidiers: 
<code><a href="#topic+tidy.felm">tidy.felm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lfe)

# use built-in `airquality` dataset
head(airquality)

# no FEs; same as lm()
est0 &lt;- felm(Ozone ~ Temp + Wind + Solar.R, airquality)

# summarize model fit with tidiers
tidy(est0)
augment(est0)

# add month fixed effects
est1 &lt;- felm(Ozone ~ Temp + Wind + Solar.R | Month, airquality)

# summarize model fit with tidiers
tidy(est1)
tidy(est1, fe = TRUE)
augment(est1)
glance(est1)

# the "se.type" argument can be used to switch out different standard errors
# types on the fly. In turn, this can be useful exploring the effect of
# different error structures on model inference.
tidy(est1, se.type = "iid")
tidy(est1, se.type = "robust")

# add clustered SEs (also by month)
est2 &lt;- felm(Ozone ~ Temp + Wind + Solar.R | Month | 0 | Month, airquality)

# summarize model fit with tidiers
tidy(est2, conf.int = TRUE)
tidy(est2, conf.int = TRUE, se.type = "cluster")
tidy(est2, conf.int = TRUE, se.type = "robust")
tidy(est2, conf.int = TRUE, se.type = "iid")

</code></pre>

<hr>
<h2 id='augment.fixest'>Augment data with information from a(n) fixest object</h2><span id='topic+augment.fixest'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
augment(
  x,
  data = NULL,
  newdata = NULL,
  type.predict = c("link", "response"),
  type.residuals = c("response", "deviance", "pearson", "working"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object returned from any of the <code>fixest</code> estimators</p>
</td></tr>
<tr><td><code id="augment.fixest_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.fixest_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.fixest_+3A_type.predict">type.predict</code></td>
<td>
<p>Passed to <code><a href="fixest.html#topic+predict.fixest">predict.fixest</a></code>
<code>type</code> argument. Defaults to <code>"link"</code> (like <code>predict.glm</code>).</p>
</td></tr>
<tr><td><code id="augment.fixest_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Passed to <code><a href="fixest.html#topic+resid.fixest">predict.fixest</a></code>
<code>type</code> argument. Defaults to <code>"response"</code> (like <code>residuals.lm</code>, but unlike
<code>residuals.glm</code>).</p>
</td></tr>
<tr><td><code id="augment.fixest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>summary</code> and <code>confint</code>. Important
arguments are <code>se</code> and <code>cluster</code>. Other arguments are <code>dof</code>, <code>exact_dof</code>,
<code>forceCovariance</code>, and <code>keepBounded</code>.
See <code><a href="fixest.html#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Important note: <code>fixest</code> models do not include a copy of the input
data, so you must provide it manually.
</p>
<p>augment.fixest only works for <code><a href="fixest.html#topic+feols">fixest::feols()</a></code>, <code><a href="fixest.html#topic+feglm">fixest::feglm()</a></code>, and
<code><a href="fixest.html#topic+femlm">fixest::femlm()</a></code> models. It does not work with results from
<code><a href="fixest.html#topic+femlm">fixest::fenegbin()</a></code>, <code><a href="fixest.html#topic+feNmlm">fixest::feNmlm()</a></code>, or <code><a href="fixest.html#topic+feglm">fixest::fepois()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="fixest.html#topic+feglm">fixest::feglm()</a></code>, <code><a href="fixest.html#topic+femlm">fixest::femlm()</a></code>, <code><a href="fixest.html#topic+feols">fixest::feols()</a></code>
</p>
<p>Other fixest tidiers: 
<code><a href="#topic+tidy.fixest">tidy.fixest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(fixest)

gravity &lt;-
  feols(
    log(Euros) ~ log(dist_km) | Origin + Destination + Product + Year, trade
  )

tidy(gravity)
glance(gravity)
augment(gravity, trade)

# to get robust or clustered SEs, users can either:

# 1) specify the arguments directly in the `tidy()` call

tidy(gravity, conf.int = TRUE, cluster = c("Product", "Year"))

tidy(gravity, conf.int = TRUE, se = "threeway")

# 2) or, feed tidy() a summary.fixest object that has already accepted
# these arguments

gravity_summ &lt;- summary(gravity, cluster = c("Product", "Year"))

tidy(gravity_summ, conf.int = TRUE)

# approach (1) is preferred.

</code></pre>

<hr>
<h2 id='augment.gam'>Augment data with information from a(n) gam object</h2><span id='topic+augment.gam'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict,
  type.residuals,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.gam_+3A_x">x</code></td>
<td>
<p>A <code>gam</code> object returned from a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.gam_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.gam_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.gam_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed
to the <code>type</code> argument of the <code><a href="stats.html#topic+predict">stats::predict()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>predict.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.gam_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed
to the <code>type</code> argument of <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>residuals.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.gam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For additional details on Cook's distance, see
<code><a href="stats.html#topic+influence.measures">stats::cooks.distance()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimated residual standard deviation when corresponding observation is dropped from model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mgcv)

# fit model
g &lt;- gam(mpg ~ s(hp) + am + qsec, data = mtcars)

# summarize model fit with tidiers
tidy(g)
tidy(g, parametric = TRUE)
glance(g)
augment(g)

</code></pre>

<hr>
<h2 id='augment.glm'>Augment data with information from a(n) glm object</h2><span id='topic+augment.glm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict = c("link", "response", "terms"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.glm_+3A_x">x</code></td>
<td>
<p>A <code>glm</code> object returned from <code><a href="stats.html#topic+glm">stats::glm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.glm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.glm_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.glm_+3A_type.predict">type.predict</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+predict.glm">stats::predict.glm()</a></code> <code>type</code>
argument. Defaults to <code>"link"</code>.</p>
</td></tr>
<tr><td><code id="augment.glm_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+glm.summaries">stats::residuals.glm()</a></code> and
to <code><a href="stats.html#topic+influence.measures">stats::rstandard.glm()</a></code> <code>type</code> arguments. Defaults to <code>"deviance"</code>.</p>
</td></tr>
<tr><td><code id="augment.glm_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.glm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If the weights for any of the observations in the model
are 0, then columns &quot;.infl&quot; and &quot;.hat&quot; in the result will be 0
for those observations.
</p>
<p>A <code>.resid</code> column is not calculated when data is specified via
the <code>newdata</code> argument.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimated residual standard deviation when corresponding observation is dropped from model.</p>
</td></tr>
<tr><td><code>.std.resid</code></td>
<td>
<p>Standardised residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">stats::glm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>

<hr>
<h2 id='augment.glmrob'>Augment data with information from a(n) glmrob object</h2><span id='topic+augment.glmrob'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmrob'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict = c("link", "response"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.glmrob_+3A_x">x</code></td>
<td>
<p>A <code>glmrob</code> object returned from <code><a href="robustbase.html#topic+glmrob">robustbase::glmrob()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.glmrob_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.glmrob_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.glmrob_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed
to the <code>type</code> argument of the <code><a href="stats.html#topic+predict">stats::predict()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>predict.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.glmrob_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed
to the <code>type</code> argument of <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>residuals.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.glmrob_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.glmrob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+glmrob">robustbase::glmrob()</a></code>
</p>
<p>Other robustbase tidiers: 
<code><a href="#topic+augment.lmrob">augment.lmrob</a>()</code>,
<code><a href="#topic+glance.lmrob">glance.lmrob</a>()</code>,
<code><a href="#topic+tidy.glmrob">tidy.glmrob</a>()</code>,
<code><a href="#topic+tidy.lmrob">tidy.lmrob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("robustbase", quietly = TRUE)) {
  # load libraries for models and data
  library(robustbase)

  data(coleman)
  set.seed(0)

  m &lt;- lmrob(Y ~ ., data = coleman)
  tidy(m)
  augment(m)
  glance(m)

  data(carrots)

  Rfit &lt;- glmrob(cbind(success, total - success) ~ logdose + block,
    family = binomial, data = carrots, method = "Mqle",
    control = glmrobMqle.control(tcc = 1.2)
  )

  tidy(Rfit)
  augment(Rfit)
}
</code></pre>

<hr>
<h2 id='augment.glmRob'>Augment data with information from a(n) glmRob object</h2><span id='topic+augment.glmRob'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmRob'
augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.glmRob_+3A_x">x</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="augment.glmRob_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>

<hr>
<h2 id='augment.htest'>Augment data with information from a(n) htest object</h2><span id='topic+augment.htest'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'htest'
augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.htest_+3A_x">x</code></td>
<td>
<p>An <code>htest</code> objected, such as those created by <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code>,
<code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>, <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code>, etc.</p>
</td></tr>
<tr><td><code id="augment.htest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code> for more details on
how residuals are computed.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>.observed</code></td>
<td>
<p>Observed count.</p>
</td></tr>
<tr><td><code>.prop</code></td>
<td>
<p>Proportion of the total.</p>
</td></tr>
<tr><td><code>.row.prop</code></td>
<td>
<p>Row proportion (2 dimensions table only).</p>
</td></tr>
<tr><td><code>.col.prop</code></td>
<td>
<p>Column proportion (2 dimensions table only).</p>
</td></tr>
<tr><td><code>.expected</code></td>
<td>
<p>Expected count under the null hypothesis.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>Pearson residuals.</p>
</td></tr>
<tr><td><code>.std.resid</code></td>
<td>
<p>Standardized residual.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code>
</p>
<p>Other htest tidiers: 
<code><a href="#topic+tidy.htest">tidy.htest</a>()</code>,
<code><a href="#topic+tidy.pairwise.htest">tidy.pairwise.htest</a>()</code>,
<code><a href="#topic+tidy.power.htest">tidy.power.htest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tt &lt;- t.test(rnorm(10))

tidy(tt)

# the glance output will be the same for each of the below tests
glance(tt)

tt &lt;- t.test(mpg ~ am, data = mtcars)

tidy(tt)

wt &lt;- wilcox.test(mpg ~ am, data = mtcars, conf.int = TRUE, exact = FALSE)

tidy(wt)

ct &lt;- cor.test(mtcars$wt, mtcars$mpg)

tidy(ct)

chit &lt;- chisq.test(xtabs(Freq ~ Sex + Class, data = as.data.frame(Titanic)))

tidy(chit)
augment(chit)

</code></pre>

<hr>
<h2 id='augment.ivreg'>Augment data with information from a(n) ivreg object</h2><span id='topic+augment.ivreg'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivreg'
augment(x, data = model.frame(x), newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.ivreg_+3A_x">x</code></td>
<td>
<p>An <code>ivreg</code> object created by a call to <code><a href="AER.html#topic+ivreg">AER::ivreg()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.ivreg_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.ivreg_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.ivreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This tidier currently only supports <code>ivreg</code>-classed objects
outputted by the <code>AER</code> package. The <code>ivreg</code> package also outputs
objects of class <code>ivreg</code>, and will be supported in a later release.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="AER.html#topic+ivreg">AER::ivreg()</a></code>
</p>
<p>Other ivreg tidiers: 
<code><a href="#topic+glance.ivreg">glance.ivreg</a>()</code>,
<code><a href="#topic+tidy.ivreg">tidy.ivreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(AER)

# load data
data("CigarettesSW", package = "AER")

# fit model
ivr &lt;- ivreg(
  log(packs) ~ income | population,
  data = CigarettesSW,
  subset = year == "1995"
)

# summarize model fit with tidiers
tidy(ivr)
tidy(ivr, conf.int = TRUE)
tidy(ivr, conf.int = TRUE, instruments = TRUE)

augment(ivr)
augment(ivr, data = CigarettesSW)
augment(ivr, newdata = CigarettesSW)

glance(ivr)

</code></pre>

<hr>
<h2 id='augment.kmeans'>Augment data with information from a(n) kmeans object</h2><span id='topic+augment.kmeans'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans'
augment(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.kmeans_+3A_x">x</code></td>
<td>
<p>A <code>kmeans</code> object created by <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.kmeans_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.kmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cluster</code></td>
<td>
<p>Cluster assignment.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>
</p>
<p>Other kmeans tidiers: 
<code><a href="#topic+glance.kmeans">glance.kmeans</a>()</code>,
<code><a href="#topic+tidy.kmeans">tidy.kmeans</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(cluster)
library(modeldata)
library(dplyr)

data(hpc_data)

x &lt;- hpc_data[, 2:5]

fit &lt;- pam(x, k = 4)

tidy(fit)
glance(fit)
augment(fit, x)

</code></pre>

<hr>
<h2 id='augment.lm'>Augment data with information from a(n) lm object</h2><span id='topic+augment.lm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  se_fit = FALSE,
  interval = c("none", "confidence", "prediction"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.lm_+3A_x">x</code></td>
<td>
<p>An <code>lm</code> object created by <code><a href="stats.html#topic+lm">stats::lm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.lm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.lm_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.lm_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.lm_+3A_interval">interval</code></td>
<td>
<p>Character indicating the type of confidence interval columns
to be added to the augmented output. Passed on to <code>predict()</code> and defaults
to &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="augment.lm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the interval created if
<code>interval</code> is <code>"confidence"</code> or <code>"prediction"</code>. Must be strictly greater
than 0 and less than 1. Defaults to 0.95, which corresponds to a 95
percent confidence/prediction interval.</p>
</td></tr>
<tr><td><code id="augment.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code><a href="#topic+augment">augment()</a></code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>
<p>Some unusual <code>lm</code> objects, such as <code>rlm</code> from MASS, may omit
<code>.cooksd</code> and <code>.std.resid</code>. <code>gam</code> from mgcv omits <code>.sigma</code>.
</p>
<p>When <code>newdata</code> is supplied, only returns <code>.fitted</code>, <code>.resid</code> and
<code>.se.fit</code> columns.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix.</p>
</td></tr>
<tr><td><code>.lower</code></td>
<td>
<p>Lower bound on interval for fitted values.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimated residual standard deviation when corresponding observation is dropped from model.</p>
</td></tr>
<tr><td><code>.std.resid</code></td>
<td>
<p>Standardised residuals.</p>
</td></tr>
<tr><td><code>.upper</code></td>
<td>
<p>Upper bound on interval for fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">stats::na.action</a>
</p>
<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+predict.lm">stats::predict.lm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(dplyr)

mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)

tidy(mod)
glance(mod)

# coefficient plot
d &lt;- tidy(mod, conf.int = TRUE)

ggplot(d, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point() +
  geom_vline(xintercept = 0, lty = 4) +
  geom_errorbarh()

# aside: There are tidy() and glance() methods for lm.summary objects too.
# this can be useful when you want to conserve memory by converting large lm
# objects into their leaner summary.lm equivalents.
s &lt;- summary(mod)
tidy(s, conf.int = TRUE)
glance(s)

augment(mod)
augment(mod, mtcars, interval = "confidence")

# predict on new data
newdata &lt;- mtcars %&gt;%
  head(6) %&gt;%
  mutate(wt = wt + 1)
augment(mod, newdata = newdata)

# ggplot2 example where we also construct 95% prediction interval

# simpler bivariate model since we're plotting in 2D
mod2 &lt;- lm(mpg ~ wt, data = mtcars)

au &lt;- augment(mod2, newdata = newdata, interval = "prediction")

ggplot(au, aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper), col = NA, alpha = 0.3)

# predict on new data without outcome variable. Output does not include .resid
newdata &lt;- newdata %&gt;%
  select(-mpg)

augment(mod, newdata = newdata)

au &lt;- augment(mod, data = mtcars)

ggplot(au, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() +
  geom_smooth(se = FALSE)

plot(mod, which = 6)

ggplot(au, aes(.hat, .cooksd)) +
  geom_vline(xintercept = 0, colour = NA) +
  geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
  geom_smooth(se = FALSE) +
  geom_point()

# column-wise models
a &lt;- matrix(rnorm(20), nrow = 10)
b &lt;- a + rnorm(length(a))
result &lt;- lm(b ~ a)

tidy(result)

</code></pre>

<hr>
<h2 id='augment.lmrob'>Augment data with information from a(n) lmrob object</h2><span id='topic+augment.lmrob'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmrob'
augment(x, data = model.frame(x), newdata = NULL, se_fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.lmrob_+3A_x">x</code></td>
<td>
<p>A <code>lmrob</code> object returned from <code><a href="robustbase.html#topic+lmrob">robustbase::lmrob()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.lmrob_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.lmrob_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.lmrob_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.lmrob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+lmrob">robustbase::lmrob()</a></code>
</p>
<p>Other robustbase tidiers: 
<code><a href="#topic+augment.glmrob">augment.glmrob</a>()</code>,
<code><a href="#topic+glance.lmrob">glance.lmrob</a>()</code>,
<code><a href="#topic+tidy.glmrob">tidy.glmrob</a>()</code>,
<code><a href="#topic+tidy.lmrob">tidy.lmrob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("robustbase", quietly = TRUE)) {
  # load libraries for models and data
  library(robustbase)

  data(coleman)
  set.seed(0)

  m &lt;- lmrob(Y ~ ., data = coleman)
  tidy(m)
  augment(m)
  glance(m)

  data(carrots)

  Rfit &lt;- glmrob(cbind(success, total - success) ~ logdose + block,
    family = binomial, data = carrots, method = "Mqle",
    control = glmrobMqle.control(tcc = 1.2)
  )

  tidy(Rfit)
  augment(Rfit)
}
</code></pre>

<hr>
<h2 id='augment.lmRob'>Augment data with information from a(n) lmRob object</h2><span id='topic+augment.lmRob'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmRob'
augment(x, data = model.frame(x), newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.lmRob_+3A_x">x</code></td>
<td>
<p>A <code>lmRob</code> object returned from <code><a href="robust.html#topic+lmRob">robust::lmRob()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.lmRob_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.lmRob_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.lmRob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="robust.html#topic+lmRob">robust::lmRob()</a></code>
</p>
<p>Other robust tidiers: 
<code><a href="#topic+glance.glmRob">glance.glmRob</a>()</code>,
<code><a href="#topic+glance.lmRob">glance.lmRob</a>()</code>,
<code><a href="#topic+tidy.glmRob">tidy.glmRob</a>()</code>,
<code><a href="#topic+tidy.lmRob">tidy.lmRob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(robust)

# fit model
m &lt;- lmRob(mpg ~ wt, data = mtcars)

# summarize model fit with tidiers
tidy(m)
augment(m)
glance(m)

</code></pre>

<hr>
<h2 id='augment.loess'>Tidy a(n) loess object</h2><span id='topic+augment.loess'></span><span id='topic+loess_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loess'
augment(x, data = model.frame(x), newdata = NULL, se_fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.loess_+3A_x">x</code></td>
<td>
<p>A <code>loess</code> objects returned by <code><a href="stats.html#topic+loess">stats::loess()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.loess_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.loess_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.loess_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.loess_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When the modeling was performed with <code>na.action = "na.omit"</code>
(as is the typical default), rows with NA in the initial data are omitted
entirely from the augmented data frame. When the modeling was performed
with <code>na.action = "na.exclude"</code>, one should provide the original data
as a second argument, at which point the augmented data will contain those
rows (typically with NAs in place of the new columns). If the original data
is not provided to <code><a href="#topic+augment">augment()</a></code> and <code>na.action = "na.exclude"</code>, a
warning is raised and the incomplete rows are dropped.
</p>
<p>Note that <code>loess</code> objects by default will not predict on data
outside of a bounding hypercube defined by the training data unless the
original <code>loess</code> object was fit with
<code style="white-space: pre;">&#8288;control = loess.control(surface = \"direct\"))&#8288;</code>. See
<code><a href="stats.html#topic+predict.loess">stats::predict.loess()</a></code> for details.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="stats.html#topic+na.action">stats::na.action</a>
</p>
<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+loess">stats::loess()</a></code>, <code><a href="stats.html#topic+predict.loess">stats::predict.loess()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lo &lt;- loess(
  mpg ~ hp + wt,
  mtcars,
  control = loess.control(surface = "direct")
)

augment(lo)

# with all columns of original data
augment(lo, mtcars)

# with a new dataset
augment(lo, newdata = head(mtcars))

</code></pre>

<hr>
<h2 id='augment.Mclust'>Augment data with information from a(n) Mclust object</h2><span id='topic+augment.Mclust'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Mclust'
augment(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.Mclust_+3A_x">x</code></td>
<td>
<p>An <code>Mclust</code> object return from <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.Mclust_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.Mclust_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.class</code></td>
<td>
<p>Predicted class.</p>
</td></tr>
<tr><td><code>.uncertainty</code></td>
<td>
<p>The uncertainty associated with the classification. Equal to one minus the model class probability.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>
</p>
<p>Other mclust tidiers: 
<code><a href="#topic+tidy.Mclust">tidy.Mclust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load library for models and data
library(mclust)

# load data manipulation libraries
library(dplyr)
library(tibble)
library(purrr)
library(tidyr)

set.seed(27)

centers &lt;- tibble(
  cluster = factor(1:3),
  # number points in each cluster
  num_points = c(100, 150, 50),
  # x1 coordinate of cluster center
  x1 = c(5, 0, -3),
  # x2 coordinate of cluster center
  x2 = c(-1, 1, -2)
)

points &lt;- centers %&gt;%
  mutate(
    x1 = map2(num_points, x1, rnorm),
    x2 = map2(num_points, x2, rnorm)
  ) %&gt;%
  select(-num_points, -cluster) %&gt;%
  unnest(c(x1, x2))

# fit model
m &lt;- Mclust(points)

# summarize model fit with tidiers
tidy(m)
augment(m, points)
glance(m)

</code></pre>

<hr>
<h2 id='augment.mfx'>Augment data with information from a(n) mfx object</h2><span id='topic+augment.mfx'></span><span id='topic+augment.logitmfx'></span><span id='topic+augment.negbinmfx'></span><span id='topic+augment.poissonmfx'></span><span id='topic+augment.probitmfx'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfx'
augment(
  x,
  data = model.frame(x$fit),
  newdata = NULL,
  type.predict = c("link", "response", "terms"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)

## S3 method for class 'logitmfx'
augment(
  x,
  data = model.frame(x$fit),
  newdata = NULL,
  type.predict = c("link", "response", "terms"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)

## S3 method for class 'negbinmfx'
augment(
  x,
  data = model.frame(x$fit),
  newdata = NULL,
  type.predict = c("link", "response", "terms"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)

## S3 method for class 'poissonmfx'
augment(
  x,
  data = model.frame(x$fit),
  newdata = NULL,
  type.predict = c("link", "response", "terms"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)

## S3 method for class 'probitmfx'
augment(
  x,
  data = model.frame(x$fit),
  newdata = NULL,
  type.predict = c("link", "response", "terms"),
  type.residuals = c("deviance", "pearson"),
  se_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.mfx_+3A_x">x</code></td>
<td>
<p>A <code>logitmfx</code>, <code>negbinmfx</code>, <code>poissonmfx</code>, or <code>probitmfx</code>  object.
(Note that <code>betamfx</code> objects receive their own set of tidiers.)</p>
</td></tr>
<tr><td><code id="augment.mfx_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.mfx_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.mfx_+3A_type.predict">type.predict</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+predict.glm">stats::predict.glm()</a></code> <code>type</code> argument.
Defaults to <code>"link"</code>.</p>
</td></tr>
<tr><td><code id="augment.mfx_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+glm.summaries">stats::residuals.glm()</a></code> and
to <code><a href="stats.html#topic+influence.measures">stats::rstandard.glm()</a></code> <code>type</code> arguments. Defaults to <code>"deviance"</code>.</p>
</td></tr>
<tr><td><code id="augment.mfx_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.mfx_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic augment method wraps <code><a href="#topic+augment.glm">augment.glm()</a></code> for applicable
objects from the <code>mfx</code> package.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cooksd</code></td>
<td>
<p>Cooks distance.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimated residual standard deviation when corresponding observation is dropped from model.</p>
</td></tr>
<tr><td><code>.std.resid</code></td>
<td>
<p>Standardised residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment.glm">augment.glm()</a></code>, <code><a href="mfx.html#topic+logitmfx">mfx::logitmfx()</a></code>, <code><a href="mfx.html#topic+negbinmfx">mfx::negbinmfx()</a></code>,
<code><a href="mfx.html#topic+poissonmfx">mfx::poissonmfx()</a></code>, <code><a href="mfx.html#topic+probitmfx">mfx::probitmfx()</a></code>
</p>
<p>Other mfx tidiers: 
<code><a href="#topic+augment.betamfx">augment.betamfx</a>()</code>,
<code><a href="#topic+glance.betamfx">glance.betamfx</a>()</code>,
<code><a href="#topic+glance.mfx">glance.mfx</a>()</code>,
<code><a href="#topic+tidy.betamfx">tidy.betamfx</a>()</code>,
<code><a href="#topic+tidy.mfx">tidy.mfx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mfx)

# get the marginal effects from a logit regression
mod_logmfx &lt;- logitmfx(am ~ cyl + hp + wt, atmean = TRUE, data = mtcars)

tidy(mod_logmfx, conf.int = TRUE)

# compare with the naive model coefficients of the same logit call
tidy(
  glm(am ~ cyl + hp + wt, family = binomial, data = mtcars),
  conf.int = TRUE
)

augment(mod_logmfx)
glance(mod_logmfx)

# another example, this time using probit regression
mod_probmfx &lt;- probitmfx(am ~ cyl + hp + wt, atmean = TRUE, data = mtcars)

tidy(mod_probmfx, conf.int = TRUE)
augment(mod_probmfx)
glance(mod_probmfx)

</code></pre>

<hr>
<h2 id='augment.mjoint'>Augment data with information from a(n) mjoint object</h2><span id='topic+augment.mjoint'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
augment(x, data = x$data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.mjoint_+3A_x">x</code></td>
<td>
<p>An <code>mjoint</code> object returned from <code><a href="joineRML.html#topic+mjoint">joineRML::mjoint()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.mjoint_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.mjoint_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="joineRML.html#topic+fitted.mjoint">joineRML::fitted.mjoint()</a></code> and <code><a href="joineRML.html#topic+residuals.mjoint">joineRML::residuals.mjoint()</a></code> for
more information on the difference between population-level and
individual-level fitted values and residuals.
</p>
<p>If fitting a joint model with a single longitudinal process,
make sure you are using a named <code>list</code> to define the formula
for the fixed and random effects of the longitudinal submodel.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each original observation
with addition columns:
</p>
<table>
<tr><td><code>.fitted_j_0</code></td>
<td>
<p>population-level fitted values for the
j-th longitudinal process</p>
</td></tr>
<tr><td><code>.fitted_j_1</code></td>
<td>
<p>individuals-level fitted values for the j-th
longitudinal process</p>
</td></tr>
<tr><td><code>.resid_j_0</code></td>
<td>
<p>population-level residuals for the j-th
longitudinal process</p>
</td></tr>
<tr><td><code>.resid_j_1</code></td>
<td>
<p>individual-level residuals for the j-th
longitudinal process</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# broom only skips running these examples because the example models take a
# while to generate—they should run just fine, though!
## Not run: 


# load libraries for models and data
library(joineRML)

# fit a joint model with bivariate longitudinal outcomes
data(heart.valve)

hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp;
  !is.na(heart.valve$log.lvmi) &amp;
  heart.valve$num &lt;= 50, ]

fit &lt;- mjoint(
  formLongFixed = list(
    "grad" = log.grad ~ time + sex + hs,
    "lvmi" = log.lvmi ~ time + sex
  ),
  formLongRandom = list(
    "grad" = ~ 1 | num,
    "lvmi" = ~ time | num
  ),
  formSurv = Surv(fuyrs, status) ~ age,
  data = hvd,
  inits = list("gamma" = c(0.11, 1.51, 0.80)),
  timeVar = "time"
)

# extract the survival fixed effects
tidy(fit)

# extract the longitudinal fixed effects
tidy(fit, component = "longitudinal")

# extract the survival fixed effects with confidence intervals
tidy(fit, ci = TRUE)

# extract the survival fixed effects with confidence intervals based
# on bootstrapped standard errors
bSE &lt;- bootSE(fit, nboot = 5, safe.boot = TRUE)
tidy(fit, boot_se = bSE, ci = TRUE)

# augment original data with fitted longitudinal values and residuals
hvd2 &lt;- augment(fit)

# extract model statistics
glance(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='augment.mlogit'>Augment data with information from a(n) mlogit object</h2><span id='topic+augment.mlogit'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlogit'
augment(x, data = x$model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.mlogit_+3A_x">x</code></td>
<td>
<p>an object returned from <code><a href="mlogit.html#topic+mlogit">mlogit::mlogit()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.mlogit_+3A_data">data</code></td>
<td>
<p>Not currently used</p>
</td></tr>
<tr><td><code id="augment.mlogit_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>At the moment this only works on the estimation dataset. Need to set
it up to predict on another dataset.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.probability</code></td>
<td>
<p>Class probability of modal class.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>
</p>
<p>Other mlogit tidiers: 
<code><a href="#topic+glance.mlogit">glance.mlogit</a>()</code>,
<code><a href="#topic+tidy.mlogit">tidy.mlogit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mlogit)

data("Fishing", package = "mlogit")
Fish &lt;- dfidx(Fishing, varying = 2:9, shape = "wide", choice = "mode")

# fit model
m &lt;- mlogit(mode ~ price + catch | income, data = Fish)

# summarize model fit with tidiers
tidy(m)
augment(m)
glance(m)

</code></pre>

<hr>
<h2 id='augment.nlrq'>Tidy a(n) nlrq object</h2><span id='topic+augment.nlrq'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlrq'
augment(x, data = NULL, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.nlrq_+3A_x">x</code></td>
<td>
<p>A <code>nlrq</code> object returned from <code><a href="quantreg.html#topic+nlrq">quantreg::nlrq()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.nlrq_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.nlrq_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.nlrq_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="quantreg.html#topic+nlrq">quantreg::nlrq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit model
n &lt;- nls(mpg ~ k * e^wt, data = mtcars, start = list(k = 1, e = 2))

# summarize model fit with tidiers + visualization
tidy(n)
augment(n)
glance(n)

library(ggplot2)

ggplot(augment(n), aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted))

newdata &lt;- head(mtcars)
newdata$wt &lt;- newdata$wt + 1

augment(n, newdata = newdata)

</code></pre>

<hr>
<h2 id='augment.nls'>Augment data with information from a(n) nls object</h2><span id='topic+augment.nls'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nls'
augment(x, data = NULL, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.nls_+3A_x">x</code></td>
<td>
<p>An <code>nls</code> object returned from <code><a href="stats.html#topic+nls">stats::nls()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.nls_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.nls_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.nls_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>augment.nls does not currently support confidence intervals due to
a lack of support in stats::predict.nls().
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="stats.html#topic+nls">stats::nls()</a></code>, <code><a href="stats.html#topic+predict.nls">stats::predict.nls()</a></code>
</p>
<p>Other nls tidiers: 
<code><a href="#topic+glance.nls">glance.nls</a>()</code>,
<code><a href="#topic+tidy.nls">tidy.nls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit model
n &lt;- nls(mpg ~ k * e^wt, data = mtcars, start = list(k = 1, e = 2))

# summarize model fit with tidiers + visualization
tidy(n)
augment(n)
glance(n)

library(ggplot2)

ggplot(augment(n), aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted))

newdata &lt;- head(mtcars)
newdata$wt &lt;- newdata$wt + 1

augment(n, newdata = newdata)

</code></pre>

<hr>
<h2 id='augment.pam'>Augment data with information from a(n) pam object</h2><span id='topic+augment.pam'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pam'
augment(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.pam_+3A_x">x</code></td>
<td>
<p>An <code>pam</code> object returned from <code><a href="cluster.html#topic+pam">cluster::pam()</a></code></p>
</td></tr>
<tr><td><code id="augment.pam_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.pam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.cluster</code></td>
<td>
<p>Cluster assignment.</p>
</td></tr>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>
<p>Other pam tidiers: 
<code><a href="#topic+glance.pam">glance.pam</a>()</code>,
<code><a href="#topic+tidy.pam">tidy.pam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(dplyr)
library(ggplot2)
library(cluster)
library(modeldata)
data(hpc_data)

x &lt;- hpc_data[, 2:5]
p &lt;- pam(x, k = 4)

# summarize model fit with tidiers + visualization
tidy(p)
glance(p)
augment(p, x)

augment(p, x) %&gt;%
  ggplot(aes(compounds, input_fields)) +
  geom_point(aes(color = .cluster)) +
  geom_text(aes(label = cluster), data = tidy(p), size = 10)

</code></pre>

<hr>
<h2 id='augment.plm'>Augment data with information from a(n) plm object</h2><span id='topic+augment.plm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plm'
augment(x, data = model.frame(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.plm_+3A_x">x</code></td>
<td>
<p>A <code>plm</code> objected returned by <code><a href="plm.html#topic+plm">plm::plm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.plm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.plm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="plm.html#topic+plm">plm::plm()</a></code>
</p>
<p>Other plm tidiers: 
<code><a href="#topic+glance.plm">glance.plm</a>()</code>,
<code><a href="#topic+tidy.plm">tidy.plm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(plm)

# load data
data("Produc", package = "plm")

# fit model
zz &lt;- plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp,
  data = Produc, index = c("state", "year")
)

# summarize model fit with tidiers
summary(zz)

tidy(zz)
tidy(zz, conf.int = TRUE)
tidy(zz, conf.int = TRUE, conf.level = 0.9)

augment(zz)
glance(zz)

</code></pre>

<hr>
<h2 id='augment.poLCA'>Augment data with information from a(n) poLCA object</h2><span id='topic+augment.poLCA'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poLCA'
augment(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.poLCA_+3A_x">x</code></td>
<td>
<p>A <code>poLCA</code> object returned from <code><a href="poLCA.html#topic+poLCA">poLCA::poLCA()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.poLCA_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.poLCA_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>data</code> argument is given, those columns are included in
the output (only rows for which predictions could be made).
Otherwise, the <code>y</code> element of the poLCA object, which contains the
manifest variables used to fit the model, are used, along with any
covariates, if present, in <code>x</code>.
</p>
<p>Note that while the probability of all the classes (not just the predicted
modal class) can be found in the <code>posterior</code> element, these are not
included in the augmented output.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.class</code></td>
<td>
<p>Predicted class.</p>
</td></tr>
<tr><td><code>.probability</code></td>
<td>
<p>Class probability of modal class.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="poLCA.html#topic+poLCA">poLCA::poLCA()</a></code>
</p>
<p>Other poLCA tidiers: 
<code><a href="#topic+glance.poLCA">glance.poLCA</a>()</code>,
<code><a href="#topic+tidy.poLCA">tidy.poLCA</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(poLCA)
library(dplyr)

# generate data
data(values)

f &lt;- cbind(A, B, C, D) ~ 1

# fit model
M1 &lt;- poLCA(f, values, nclass = 2, verbose = FALSE)

M1

# summarize model fit with tidiers + visualization
tidy(M1)
augment(M1)
glance(M1)

library(ggplot2)

ggplot(tidy(M1), aes(factor(class), estimate, fill = factor(outcome))) +
  geom_bar(stat = "identity", width = 1) +
  facet_wrap(~variable)

# three-class model with a single covariate.
data(election)

f2a &lt;- cbind(
  MORALG, CARESG, KNOWG, LEADG, DISHONG, INTELG,
  MORALB, CARESB, KNOWB, LEADB, DISHONB, INTELB
) ~ PARTY

nes2a &lt;- poLCA(f2a, election, nclass = 3, nrep = 5, verbose = FALSE)

td &lt;- tidy(nes2a)
td

ggplot(td, aes(outcome, estimate, color = factor(class), group = class)) +
  geom_line() +
  facet_wrap(~variable, nrow = 2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

au &lt;- augment(nes2a)

au

count(au, .class)

# if the original data is provided, it leads to NAs in new columns
# for rows that weren't predicted
au2 &lt;- augment(nes2a, data = election)

au2

dim(au2)

</code></pre>

<hr>
<h2 id='augment.polr'>Augment data with information from a(n) polr object</h2><span id='topic+augment.polr'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'polr'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict = c("class"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.polr_+3A_x">x</code></td>
<td>
<p>A <code>polr</code> object returned from <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.polr_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.polr_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.polr_+3A_type.predict">type.predict</code></td>
<td>
<p>Which type of prediction to compute,
passed to <code>MASS:::predict.polr()</code>. Only supports <code>"class"</code> at
the moment.</p>
</td></tr>
<tr><td><code id="augment.polr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
fit &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)

# summarize model fit with tidiers
tidy(fit, exponentiate = TRUE, conf.int = TRUE)

glance(fit)
augment(fit, type.predict = "class")

fit2 &lt;- polr(factor(gear) ~ am + mpg + qsec, data = mtcars)

tidy(fit, p.values = TRUE)

</code></pre>

<hr>
<h2 id='augment.prcomp'>Augment data with information from a(n) prcomp object</h2><span id='topic+augment.prcomp'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcomp'
augment(x, data = NULL, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.prcomp_+3A_x">x</code></td>
<td>
<p>A <code>prcomp</code> object returned by <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.prcomp_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.prcomp_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.prcomp_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> containing the original data along with
additional columns containing each observation's projection into
PCA space.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, <a href="#topic+svd_tidiers">svd_tidiers</a>
</p>
<p>Other svd tidiers: 
<code><a href="#topic+tidy.prcomp">tidy.prcomp</a>()</code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>
</p>

<hr>
<h2 id='augment.rlm'>Augment data with information from a(n) rlm object</h2><span id='topic+augment.rlm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlm'
augment(x, data = model.frame(x), newdata = NULL, se_fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.rlm_+3A_x">x</code></td>
<td>
<p>An <code>rlm</code> object returned by <code><a href="MASS.html#topic+rlm">MASS::rlm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.rlm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.rlm_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.rlm_+3A_se_fit">se_fit</code></td>
<td>
<p>Logical indicating whether or not a <code>.se.fit</code> column should be
added to the augmented output. For some models, this calculation can be
somewhat time-consuming. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augment.rlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.hat</code></td>
<td>
<p>Diagonal of the hat matrix.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.sigma</code></td>
<td>
<p>Estimated residual standard deviation when corresponding observation is dropped from model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+rlm">MASS::rlm()</a></code>
</p>
<p>Other rlm tidiers: 
<code><a href="#topic+glance.rlm">glance.rlm</a>()</code>,
<code><a href="#topic+tidy.rlm">tidy.rlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
r &lt;- rlm(stack.loss ~ ., stackloss)

# summarize model fit with tidiers
tidy(r)
augment(r)
glance(r)

</code></pre>

<hr>
<h2 id='augment.rma'>Augment data with information from a(n) rma object</h2><span id='topic+augment.rma'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rma'
augment(x, interval = c("prediction", "confidence"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.rma_+3A_x">x</code></td>
<td>
<p>An <code>rma</code> object such as those created by <code><a href="metafor.html#topic+rma.uni">metafor::rma()</a></code>,
<code><a href="metafor.html#topic+rma.uni">metafor::rma.uni()</a></code>, <code><a href="metafor.html#topic+rma.glmm">metafor::rma.glmm()</a></code>, <code><a href="metafor.html#topic+rma.mh">metafor::rma.mh()</a></code>,
<code><a href="metafor.html#topic+rma.mv">metafor::rma.mv()</a></code>, or <code><a href="metafor.html#topic+rma.peto">metafor::rma.peto()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.rma_+3A_interval">interval</code></td>
<td>
<p>For <code>rma.mv</code> models, should prediction intervals
(<code>"prediction"</code>, default) or confidence intervals (<code>"confidence"</code>)
intervals be returned? For <code>rma.uni</code> models, prediction intervals are
always returned. For <code>rma.mh</code> and <code>rma.peto</code> models, confidence intervals
are always returned.</p>
</td></tr>
<tr><td><code id="augment.rma_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.lower</code></td>
<td>
<p>Lower bound on interval for fitted values.</p>
</td></tr>
<tr><td><code>.moderator</code></td>
<td>
<p>In meta-analysis, the moderators used to calculate the predicted values.</p>
</td></tr>
<tr><td><code>.moderator.level</code></td>
<td>
<p>In meta-analysis, the level of the moderators used to calculate the predicted values.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
<tr><td><code>.upper</code></td>
<td>
<p>Upper bound on interval for fitted values.</p>
</td></tr>
<tr><td><code>.observed</code></td>
<td>
<p>The observed values for the individual studies</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(metafor)

# generate data and fit
df &lt;-
  escalc(
    measure = "RR",
    ai = tpos,
    bi = tneg,
    ci = cpos,
    di = cneg,
    data = dat.bcg
  )

meta_analysis &lt;- rma(yi, vi, data = df, method = "EB")

# summarize model fit with tidiers
augment(meta_analysis)

</code></pre>

<hr>
<h2 id='augment.rq'>Augment data with information from a(n) rq object</h2><span id='topic+augment.rq'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq'
augment(x, data = model.frame(x), newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.rq_+3A_x">x</code></td>
<td>
<p>An <code>rq</code> object returned from <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.rq_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.rq_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.rq_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="quantreg.html#topic+predict.rq">quantreg::predict.rq</a></code>
</p>

<dl>
<dt><code>object</code></dt><dd><p> object of class rq or rqs or rq.process produced by <code>rq</code> </p>
</dd>
<dt><code>interval</code></dt><dd><p>type of interval desired:  default is  'none', when set to
'confidence' the function returns a matrix predictions with point predictions
for each of the 'newdata' points as well as lower and upper confidence limits.</p>
</dd>
<dt><code>level</code></dt><dd><p>converage probability for the 'confidence' intervals.</p>
</dd>
<dt><code>type</code></dt><dd><p>For <code>predict.rq</code>, the  method for 'confidence' intervals, if desired. 
If 'percentile' then one of the bootstrap methods is used to generate percentile 
intervals for each prediction, if 'direct' then a version of the Portnoy and Zhou 
(1998) method is used, and otherwise an estimated covariance matrix for the parameter
estimates is used.  Further arguments to determine the choice of bootstrap
method or covariance matrix estimate can be passed via the ... argument.
For <code>predict.rqs</code> and <code>predict.rq.process</code> when <code>stepfun = TRUE</code>,
<code>type</code> is &quot;Qhat&quot;, &quot;Fhat&quot; or &quot;fhat&quot; depending  on whether the user would
like to have estimates of the conditional quantile, distribution or density  functions
respectively.  As noted below the two former estimates can be monotonized with the 
function <code>rearrange</code>.  When the &quot;fhat&quot; option is invoked, a list of conditional
density functions is returned based on Silverman's adaptive kernel method as
implemented in <code>akj</code> and <code>approxfun</code>.</p>
</dd>
<dt><code>na.action</code></dt><dd><p> function determining what should be done with missing values
in 'newdata'.  The default is to predict 'NA'.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the arguments passed on to <code>predict.rq</code> via <code>...</code>,
a confidence interval is also calculated on the fitted values resulting in
columns <code>.lower</code> and <code>.upper</code>. Does not provide confidence
intervals when data is specified via the <code>newdata</code> argument.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.tau</code></td>
<td>
<p>Quantile.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+augment">augment</a>, <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>, <code><a href="quantreg.html#topic+predict.rq">quantreg::predict.rq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library and data
library(quantreg)

data(stackloss)

# median (l1) regression fit for the stackloss data.
mod1 &lt;- rq(stack.loss ~ stack.x, .5)

# weighted sample median
mod2 &lt;- rq(rnorm(50) ~ 1, weights = runif(50))

# summarize model fit with tidiers
tidy(mod1)
glance(mod1)
augment(mod1)

tidy(mod2)
glance(mod2)
augment(mod2)

# varying tau to generate an rqs object
mod3 &lt;- rq(stack.loss ~ stack.x, tau = c(.25, .5))

tidy(mod3)
augment(mod3)

# glance cannot handle rqs objects like `mod3`--use a purrr
# `map`-based workflow instead

</code></pre>

<hr>
<h2 id='augment.rqs'>Augment data with information from a(n) rqs object</h2><span id='topic+augment.rqs'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqs'
augment(x, data = model.frame(x), newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.rqs_+3A_x">x</code></td>
<td>
<p>An <code>rqs</code> object returned from <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.rqs_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.rqs_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.rqs_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="quantreg.html#topic+predict.rq">quantreg::predict.rq</a></code>
</p>

<dl>
<dt><code>object</code></dt><dd><p> object of class rq or rqs or rq.process produced by <code>rq</code> </p>
</dd>
<dt><code>interval</code></dt><dd><p>type of interval desired:  default is  'none', when set to
'confidence' the function returns a matrix predictions with point predictions
for each of the 'newdata' points as well as lower and upper confidence limits.</p>
</dd>
<dt><code>level</code></dt><dd><p>converage probability for the 'confidence' intervals.</p>
</dd>
<dt><code>type</code></dt><dd><p>For <code>predict.rq</code>, the  method for 'confidence' intervals, if desired. 
If 'percentile' then one of the bootstrap methods is used to generate percentile 
intervals for each prediction, if 'direct' then a version of the Portnoy and Zhou 
(1998) method is used, and otherwise an estimated covariance matrix for the parameter
estimates is used.  Further arguments to determine the choice of bootstrap
method or covariance matrix estimate can be passed via the ... argument.
For <code>predict.rqs</code> and <code>predict.rq.process</code> when <code>stepfun = TRUE</code>,
<code>type</code> is &quot;Qhat&quot;, &quot;Fhat&quot; or &quot;fhat&quot; depending  on whether the user would
like to have estimates of the conditional quantile, distribution or density  functions
respectively.  As noted below the two former estimates can be monotonized with the 
function <code>rearrange</code>.  When the &quot;fhat&quot; option is invoked, a list of conditional
density functions is returned based on Silverman's adaptive kernel method as
implemented in <code>akj</code> and <code>approxfun</code>.</p>
</dd>
<dt><code>na.action</code></dt><dd><p> function determining what should be done with missing values
in 'newdata'.  The default is to predict 'NA'.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the arguments passed on to <code>predict.rq</code> via <code>...</code>,
a confidence interval is also calculated on the fitted values resulting in
columns <code>.lower</code> and <code>.upper</code>. Does not provide confidence
intervals when data is specified via the <code>newdata</code> argument.
</p>


<h3>See Also</h3>

<p><a href="#topic+augment">augment</a>, <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>, <code><a href="quantreg.html#topic+predict.rq">quantreg::predict.rqs()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library and data
library(quantreg)

data(stackloss)

# median (l1) regression fit for the stackloss data.
mod1 &lt;- rq(stack.loss ~ stack.x, .5)

# weighted sample median
mod2 &lt;- rq(rnorm(50) ~ 1, weights = runif(50))

# summarize model fit with tidiers
tidy(mod1)
glance(mod1)
augment(mod1)

tidy(mod2)
glance(mod2)
augment(mod2)

# varying tau to generate an rqs object
mod3 &lt;- rq(stack.loss ~ stack.x, tau = c(.25, .5))

tidy(mod3)
augment(mod3)

# glance cannot handle rqs objects like `mod3`--use a purrr
# `map`-based workflow instead

</code></pre>

<hr>
<h2 id='augment.sarlm'>Augment data with information from a(n) spatialreg object</h2><span id='topic+augment.sarlm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sarlm'
augment(x, data = x$X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.sarlm_+3A_x">x</code></td>
<td>
<p>An object returned from <code><a href="spatialreg.html#topic+ML_models">spatialreg::lagsarlm()</a></code>
or <code><a href="spatialreg.html#topic+ML_models">spatialreg::errorsarlm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.sarlm_+3A_data">data</code></td>
<td>
<p>Ignored, but included for internal consistency. See the details
below.</p>
</td></tr>
<tr><td><code id="augment.sarlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The predict method for sarlm objects assumes that the response is
known. See ?predict.sarlm for more discussion. As a result, since the
original data can be recovered from the fit object, this method
currently does not take in <code>data</code> or <code>newdata</code> arguments.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>
</p>
<p>Other spatialreg tidiers: 
<code><a href="#topic+glance.sarlm">glance.sarlm</a>()</code>,
<code><a href="#topic+tidy.sarlm">tidy.sarlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# load libraries for models and data
library(spatialreg)
library(spdep)

# load data
data(oldcol, package = "spdep")

listw &lt;- nb2listw(COL.nb, style = "W")

# fit model
crime_sar &lt;-
  lagsarlm(CRIME ~ INC + HOVAL,
    data = COL.OLD,
    listw = listw,
    method = "eigen"
  )

# summarize model fit with tidiers
tidy(crime_sar)
tidy(crime_sar, conf.int = TRUE)
glance(crime_sar)
augment(crime_sar)

# fit another model
crime_sem &lt;- errorsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw)

# summarize model fit with tidiers
tidy(crime_sem)
tidy(crime_sem, conf.int = TRUE)
glance(crime_sem)
augment(crime_sem)

# fit another model
crime_sac &lt;- sacsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw)

# summarize model fit with tidiers
tidy(crime_sac)
tidy(crime_sac, conf.int = TRUE)
glance(crime_sac)
augment(crime_sac)

</code></pre>

<hr>
<h2 id='augment.smooth.spline'>Tidy a(n) smooth.spline object</h2><span id='topic+augment.smooth.spline'></span><span id='topic+smooth.spline_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth.spline'
augment(x, data = x$data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.smooth.spline_+3A_x">x</code></td>
<td>
<p>A <code>smooth.spline</code> object returned from <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.smooth.spline_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.smooth.spline_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>,
<code><a href="stats.html#topic+predict.smooth.spline">stats::predict.smooth.spline()</a></code>
</p>
<p>Other smoothing spline tidiers: 
<code><a href="#topic+glance.smooth.spline">glance.smooth.spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit model
spl &lt;- smooth.spline(mtcars$wt, mtcars$mpg, df = 4)

# summarize model fit with tidiers
augment(spl, mtcars)

# calls original columns x and y
augment(spl)

library(ggplot2)
ggplot(augment(spl, mtcars), aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted))

</code></pre>

<hr>
<h2 id='augment.speedlm'>Augment data with information from a(n) speedlm object</h2><span id='topic+augment.speedlm'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedlm'
augment(x, data = model.frame(x), newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.speedlm_+3A_x">x</code></td>
<td>
<p>A <code>speedlm</code> object returned from <code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.speedlm_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.speedlm_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.speedlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>
</p>
<p>Other speedlm tidiers: 
<code><a href="#topic+glance.speedglm">glance.speedglm</a>()</code>,
<code><a href="#topic+glance.speedlm">glance.speedlm</a>()</code>,
<code><a href="#topic+tidy.speedglm">tidy.speedglm</a>()</code>,
<code><a href="#topic+tidy.speedlm">tidy.speedlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(speedglm)

# fit model
mod &lt;- speedlm(mpg ~ wt + qsec, data = mtcars, fitted = TRUE)

# summarize model fit with tidiers
tidy(mod)
glance(mod)
augment(mod)

</code></pre>

<hr>
<h2 id='augment.stl'>Augment data with information from a(n) stl object</h2><span id='topic+augment.stl'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stl'
augment(x, data = NULL, weights = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.stl_+3A_x">x</code></td>
<td>
<p>An <code>stl</code> object returned from <code><a href="stats.html#topic+stl">stats::stl()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.stl_+3A_data">data</code></td>
<td>
<p>Ignored, included for consistency with the augment generic signature only.</p>
</td></tr>
<tr><td><code id="augment.stl_+3A_weights">weights</code></td>
<td>
<p>Logical indicating whether or not to include the robust
weights in the output.</p>
</td></tr>
<tr><td><code id="augment.stl_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with one row for each observation in the
original times series:
</p>
<table>
<tr><td><code>.seasonal</code></td>
<td>
<p>The seasonal component of the decomposition.</p>
</td></tr>
<tr><td><code>.trend</code></td>
<td>
<p>The trend component of the decomposition.</p>
</td></tr>
<tr><td><code>.remainder</code></td>
<td>
<p>The remainder, or &quot;random&quot; component of the
decomposition.</p>
</td></tr>
<tr><td><code>.weight</code></td>
<td>
<p>The final robust weights, if requested.</p>
</td></tr>
<tr><td><code>.seasadj</code></td>
<td>
<p>The seasonally adjusted (or &quot;deseasonalised&quot;)
series.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+stl">stats::stl()</a></code>
</p>
<p>Other decompose tidiers: 
<code><a href="#topic+augment.decomposed.ts">augment.decomposed.ts</a>()</code>
</p>

<hr>
<h2 id='augment.survreg'>Augment data with information from a(n) survreg object</h2><span id='topic+augment.survreg'></span>

<h3>Description</h3>

<p>Augment accepts a model object and a dataset and adds
information about each observation in the dataset. Most commonly, this
includes predicted values in the <code>.fitted</code> column, residuals in the
<code>.resid</code> column, and standard errors for the fitted values in a <code>.se.fit</code>
column. New columns always begin with a <code>.</code> prefix to avoid overwriting
columns in the original dataset.
</p>
<p>Users may pass data to augment via either the <code>data</code> argument or the
<code>newdata</code> argument. If the user passes data to the <code>data</code> argument,
it <strong>must</strong> be exactly the data that was used to fit the model
object. Pass datasets to <code>newdata</code> to augment data that was not used
during model fitting. This still requires that at least all predictor
variable columns used to fit the model are present. If the original outcome
variable used to fit the model is not included in <code>newdata</code>, then no
<code>.resid</code> column will be included in the output.
</p>
<p>Augment will often behave differently depending on whether <code>data</code> or
<code>newdata</code> is given. This is because there is often information
associated with training observations (such as influences or related)
measures that is not meaningfully defined for new observations.
</p>
<p>For convenience, many augment methods provide default <code>data</code> arguments,
so that <code>augment(fit)</code> will return the augmented training data. In these
cases, augment tries to reconstruct the original data based on the model
object with varying degrees of success.
</p>
<p>The augmented dataset is always returned as a <a href="tibble.html#topic+tibble">tibble::tibble</a> with the
<strong>same number of rows</strong> as the passed dataset. This means that the passed
data must be coercible to a tibble. If a predictor enters the model as part
of a matrix of covariates, such as when the model formula uses
<code><a href="splines.html#topic+ns">splines::ns()</a></code>, <code><a href="stats.html#topic+poly">stats::poly()</a></code>, or <code><a href="survival.html#topic+Surv">survival::Surv()</a></code>, it is represented
as a matrix column.
</p>
<p>We are in the process of defining behaviors for models fit with various
<code>na.action</code> arguments, but make no guarantees about behavior when data is
missing at this time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survreg'
augment(
  x,
  data = model.frame(x),
  newdata = NULL,
  type.predict = "response",
  type.residuals = "response",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augment.survreg_+3A_x">x</code></td>
<td>
<p>An <code>survreg</code> object returned from <code><a href="survival.html#topic+survreg">survival::survreg()</a></code>.</p>
</td></tr>
<tr><td><code id="augment.survreg_+3A_data">data</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">base::data.frame</a> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing the original
data that was used to produce the object <code>x</code>. Defaults to
<code>stats::model.frame(x)</code> so that <code>augment(my_fit)</code> returns the augmented
original data. <strong>Do not</strong> pass new data to the <code>data</code> argument.
Augment will report information such as influence and cooks distance for
data passed to the <code>data</code> argument. These measures are only defined for
the original training data.</p>
</td></tr>
<tr><td><code id="augment.survreg_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">base::data.frame()</a></code> or <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> containing all
the original predictors used to create <code>x</code>. Defaults to <code>NULL</code>, indicating
that nothing has been passed to <code>newdata</code>. If <code>newdata</code> is specified,
the <code>data</code> argument will be ignored.</p>
</td></tr>
<tr><td><code id="augment.survreg_+3A_type.predict">type.predict</code></td>
<td>
<p>Character indicating type of prediction to use. Passed
to the <code>type</code> argument of the <code><a href="stats.html#topic+predict">stats::predict()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>predict.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.survreg_+3A_type.residuals">type.residuals</code></td>
<td>
<p>Character indicating type of residuals to use. Passed
to the <code>type</code> argument of <code><a href="stats.html#topic+residuals">stats::residuals()</a></code> generic. Allowed arguments
vary with model class, so be sure to read the <code>residuals.my_class</code>
documentation.</p>
</td></tr>
<tr><td><code id="augment.survreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>.fitted</code></td>
<td>
<p>Fitted or predicted value.</p>
</td></tr>
<tr><td><code>.resid</code></td>
<td>
<p>The difference between observed and fitted values.</p>
</td></tr>
<tr><td><code>.se.fit</code></td>
<td>
<p>Standard errors of fitted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="survival.html#topic+survreg">survival::survreg()</a></code>
</p>
<p>Other survreg tidiers: 
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
sr &lt;- survreg(
  Surv(futime, fustat) ~ ecog.ps + rx,
  ovarian,
  dist = "exponential"
)

# summarize model fit with tidiers + visualization
tidy(sr)
augment(sr, ovarian)
glance(sr)

# coefficient plot
td &lt;- tidy(sr, conf.int = TRUE)

library(ggplot2)

ggplot(td, aes(estimate, term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0) +
  geom_vline(xintercept = 0)

</code></pre>

<hr>
<h2 id='bootstrap'>Set up bootstrap replicates of a dplyr operation</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>The <code>bootstrap()</code> function is deprecated and will be removed from
an upcoming release of broom. For tidy resampling, please use the rsample
package instead. Functionality is no longer supported for this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(df, m, by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_m">m</code></td>
<td>
<p>number of bootstrap replicates to perform</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_by_group">by_group</code></td>
<td>
<p>If <code>TRUE</code>, then bootstrap within each group if <code>df</code> is
a grouped tibble.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code originates from Hadley Wickham (with a few small
corrections) here:
<a href="https://github.com/tidyverse/dplyr/issues/269">https://github.com/tidyverse/dplyr/issues/269</a>
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>

<hr>
<h2 id='confint_tidy'>(Deprecated) Calculate confidence interval as a tidy data frame</h2><span id='topic+confint_tidy'></span>

<h3>Description</h3>

<p>This function is now deprecated and will be removed from a future
release of broom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint_tidy(x, conf.level = 0.95, func = stats::confint, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint_tidy_+3A_x">x</code></td>
<td>
<p>a model object for which <code><a href="stats.html#topic+confint">confint()</a></code> can be calculated</p>
</td></tr>
<tr><td><code id="confint_tidy_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="confint_tidy_+3A_func">func</code></td>
<td>
<p>A function to compute a confidence interval for <code>x</code>. Calling
<code>func(x, level = conf.level, ...)</code> must return an object coercible to a
tibble. This dataframe like object should have to columns corresponding
the lower and upper bounds on the confidence interval.</p>
</td></tr>
<tr><td><code id="confint_tidy_+3A_...">...</code></td>
<td>
<p>extra arguments passed on to <code>confint</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return a confidence interval as a tidy data frame. This directly wraps the
<code><a href="stats.html#topic+confint">confint()</a></code> function, but ensures it follows broom conventions:
column names of <code>conf.low</code> and <code>conf.high</code>, and no row names.
</p>
<p><code>confint_tidy</code>
</p>


<h3>Value</h3>

<p>A tibble with two columns: <code>conf.low</code> and <code>conf.high</code>.
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>

<hr>
<h2 id='data.frame_tidiers'>Tidiers for data.frame objects</h2><span id='topic+data.frame_tidiers'></span><span id='topic+tidy.data.frame'></span><span id='topic+augment.data.frame'></span><span id='topic+glance.data.frame'></span>

<h3>Description</h3>

<p>Data frame tidiers are deprecated and will be removed from an upcoming
release of broom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
tidy(x, ..., na.rm = TRUE, trim = 0.1)

## S3 method for class 'data.frame'
augment(x, data, ...)

## S3 method for class 'data.frame'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame_tidiers_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="data.frame_tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments for other methods.</p>
</td></tr>
<tr><td><code id="data.frame_tidiers_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether <code>NA</code> values should
be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="data.frame_tidiers_+3A_trim">trim</code></td>
<td>
<p>the fraction (0 to 0.5) of observations to be trimmed from
each end of <code>x</code> before the mean is computed.  Passed to the
<code>trim</code> argument of <code><a href="base.html#topic+mean">mean</a></code></p>
</td></tr>
<tr><td><code id="data.frame_tidiers_+3A_data">data</code></td>
<td>
<p>data, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These perform tidy summaries of data.frame objects. <code>tidy</code> produces
summary statistics about each column, while <code>glance</code> simply reports
the number of rows and columns. Note that <code>augment.data.frame</code> will
throw an error.
</p>


<h3>Value</h3>

<p><code>tidy.data.frame</code> produces a data frame with one
row per original column, containing summary statistics of each:
</p>
<table>
<tr><td><code>column</code></td>
<td>
<p>name of original column</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of valid (non-NA) values</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>median</p>
</td></tr>
<tr><td><code>trimmed</code></td>
<td>
<p>trimmed mean, with trim defaulting to .1</p>
</td></tr>
<tr><td><code>mad</code></td>
<td>
<p>median absolute deviation (from the median)</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>maximum value</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>range</p>
</td></tr>
<tr><td><code>skew</code></td>
<td>
<p>skew</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>kurtosis</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>standard error</p>
</td></tr>
</table>
<p><code>glance</code> returns a one-row data.frame with
</p>
<table>
<tr><td><code>nrow</code></td>
<td>
<p>number of rows</p>
</td></tr>
<tr><td><code>ncol</code></td>
<td>
<p>number of columns</p>
</td></tr>
<tr><td><code>complete.obs</code></td>
<td>
<p>number of rows that have no missing values</p>
</td></tr>
<tr><td><code>na.fraction</code></td>
<td>
<p>fraction of values across all rows and columns that
are missing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Robinson, Benjamin Nutter
</p>


<h3>Source</h3>

<p>Skew and Kurtosis functions are adapted from implementations in the <code>moments</code> package: <br />
Lukasz Komsta and Frederick Novomestky (2015). moments: Moments, cumulants, skewness,
kurtosis and related tests. R package version 0.14. <br />
https://CRAN.R-project.org/package=moments
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>
<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>
<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

td &lt;- tidy(mtcars)
td

glance(mtcars)

library(ggplot2)
# compare mean and standard deviation
ggplot(td, aes(mean, sd)) + geom_point() +
     geom_text(aes(label = column), hjust = 1, vjust = 1) +
     scale_x_log10() + scale_y_log10() + geom_abline()

</code></pre>

<hr>
<h2 id='durbinWatsonTest_tidiers'>Tidy/glance a(n) durbinWatsonTest object</h2><span id='topic+durbinWatsonTest_tidiers'></span><span id='topic+tidy.durbinWatsonTest'></span><span id='topic+glance.durbinWatsonTest'></span>

<h3>Description</h3>

<p>For models that have only a single component, the <code><a href="#topic+tidy">tidy()</a></code> and
<code><a href="#topic+glance">glance()</a></code> methods are identical. Please see the documentation for both
of those methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'durbinWatsonTest'
tidy(x, ...)

## S3 method for class 'durbinWatsonTest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="durbinWatsonTest_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>durbinWatsonTest</code> created by a call to
<code><a href="car.html#topic+durbinWatsonTest">car::durbinWatsonTest()</a></code>.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>alternative</code></td>
<td>
<p>Alternative hypothesis (character).</p>
</td></tr>
<tr><td><code>autocorrelation</code></td>
<td>
<p>Autocorrelation.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic for Durbin-Watson test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Always 'Durbin-Watson Test'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="#topic+glance">glance()</a></code>, <code><a href="car.html#topic+durbinWatsonTest">car::durbinWatsonTest()</a></code>
</p>
<p>Other car tidiers: 
<code><a href="#topic+leveneTest_tidiers">leveneTest_tidiers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(car)

# fit model
dw &lt;- durbinWatsonTest(lm(mpg ~ wt, data = mtcars))

# summarize model fit with tidiers
tidy(dw)

# same output for all durbinWatsonTests
glance(dw)

</code></pre>

<hr>
<h2 id='finish_glance'>(Deprecated) Add logLik, AIC, BIC, and other common measurements to a
glance of a prediction</h2><span id='topic+finish_glance'></span>

<h3>Description</h3>

<p>This function is now deprecated in favor of using custom logic and
the appropriate <code>nobs()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finish_glance(ret, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finish_glance_+3A_ret">ret</code></td>
<td>
<p>a one-row data frame (a partially complete glance)</p>
</td></tr>
<tr><td><code id="finish_glance_+3A_x">x</code></td>
<td>
<p>the prediction model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-row data frame with additional columns added, such as
</p>
<table>
<tr><td><code>logLik</code></td>
<td>
<p>log likelihoods</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike Information Criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>deviance</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>

<hr>
<h2 id='fix_data_frame'>Ensure an object is a data frame, with rownames moved into a column</h2><span id='topic+fix_data_frame'></span>

<h3>Description</h3>

<p>This function is deprecated as of broom 0.7.0 and will be removed from
a future release. Please see <code>tibble::as_tibble</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_data_frame(x, newnames = NULL, newcol = "term")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_data_frame_+3A_x">x</code></td>
<td>
<p>a data.frame or matrix</p>
</td></tr>
<tr><td><code id="fix_data_frame_+3A_newnames">newnames</code></td>
<td>
<p>new column names, not including the rownames</p>
</td></tr>
<tr><td><code id="fix_data_frame_+3A_newcol">newcol</code></td>
<td>
<p>the name of the new rownames column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame, with rownames moved into a column and new column
names assigned
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>

<hr>
<h2 id='glance_optim'>Tidy a(n) optim object masquerading as list</h2><span id='topic+glance_optim'></span><span id='topic+glance.optim'></span>

<h3>Description</h3>

<p>Broom tidies a number of lists that are effectively S3
objects without a class attribute. For example, <code><a href="stats.html#topic+optim">stats::optim()</a></code>,
<a href="base.html#topic+svd">svd()</a> and <code><a href="interp.html#topic+interp">interp::interp()</a></code> produce consistent output, but
because they do not have a class attribute, they cannot be handled by S3
dispatch.
</p>
<p>These functions look at the elements of a list and determine if there is
an appropriate tidying method to apply to the list. Those tidiers are
implemented as functions of the form <code style="white-space: pre;">&#8288;tidy_&lt;function&gt;&#8288;</code> or
<code style="white-space: pre;">&#8288;glance_&lt;function&gt;&#8288;</code> and are not exported (but they are documented!).
</p>
<p>If no appropriate tidying method is found, they throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glance_optim(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance_optim_+3A_x">x</code></td>
<td>
<p>A list returned from <code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
<tr><td><code id="glance_optim_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>convergence</code></td>
<td>
<p>Convergence code.</p>
</td></tr>
<tr><td><code>function.count</code></td>
<td>
<p>Number of calls to 'fn'.</p>
</td></tr>
<tr><td><code>gradient.count</code></td>
<td>
<p>Number of calls to 'gr'.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Minimized or maximized output value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="stats.html#topic+optim">stats::optim()</a></code>
</p>
<p>Other list tidiers: 
<code><a href="#topic+list_tidiers">list_tidiers</a></code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_optim">tidy_optim</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>,
<code><a href="#topic+tidy_xyz">tidy_xyz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(x) (x[1] - 2)^2 + (x[2] - 3)^2 + (x[3] - 8)^2
o &lt;- optim(c(1, 1, 1), f)

</code></pre>

<hr>
<h2 id='glance.aareg'>Glance at a(n) aareg object</h2><span id='topic+glance.aareg'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aareg'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.aareg_+3A_x">x</code></td>
<td>
<p>An <code>aareg</code> object returned from <code><a href="survival.html#topic+aareg">survival::aareg()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.aareg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+aareg">survival::aareg()</a></code>
</p>
<p>Other aareg tidiers: 
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
afit &lt;- aareg(
  Surv(time, status) ~ age + sex + ph.ecog,
  data = lung,
  dfbeta = TRUE
)

# summarize model fit with tidiers
tidy(afit)

</code></pre>

<hr>
<h2 id='glance.anova'>Glance at a(n) anova object</h2><span id='topic+glance.anova'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.anova_+3A_x">x</code></td>
<td>
<p>An <code>anova</code> object, such as those created by <code><a href="stats.html#topic+anova">stats::anova()</a></code>,
<code><a href="car.html#topic+Anova">car::Anova()</a></code>, <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code>, or <code><a href="car.html#topic+linearHypothesis">car::linearHypothesis()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.anova_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the output of <code>glance.anova()</code> will vary depending on the initializing
anova call. In some cases, it will just return an empty data frame. In other
cases, <code>glance.anova()</code> may return columns that are also common to
<code>tidy.anova()</code>. This is partly to preserve backwards compatibility with early
versions of <code>broom</code>, but also because the underlying anova model yields
components that could reasonably be interpreted as goodness-of-fit summaries
too.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.aov">glance.aov</a>()</code>,
<code><a href="#topic+tidy.TukeyHSD">tidy.TukeyHSD</a>()</code>,
<code><a href="#topic+tidy.anova">tidy.anova</a>()</code>,
<code><a href="#topic+tidy.aovlist">tidy.aovlist</a>()</code>,
<code><a href="#topic+tidy.aov">tidy.aov</a>()</code>,
<code><a href="#topic+tidy.manova">tidy.manova</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit models
a &lt;- lm(mpg ~ wt + qsec + disp, mtcars)
b &lt;- lm(mpg ~ wt + qsec, mtcars)

mod &lt;- anova(a, b)

# summarize model fit with tidiers
tidy(mod)
glance(mod)

# car::linearHypothesis() example
library(car)
mod_lht &lt;- linearHypothesis(a, "wt - disp")
tidy(mod_lht)
glance(mod_lht)

</code></pre>

<hr>
<h2 id='glance.aov'>Glance at a(n) lm object</h2><span id='topic+glance.aov'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aov'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.aov_+3A_x">x</code></td>
<td>
<p>An <code>aov</code> object, such as those created by <code><a href="stats.html#topic+aov">stats::aov()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.aov_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that <code>tidy.aov()</code> now contains the numerator and denominator degrees of
freedom, which were included in the output of <code>glance.aov()</code> in some
previous versions of the package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.anova">glance.anova</a>()</code>,
<code><a href="#topic+tidy.TukeyHSD">tidy.TukeyHSD</a>()</code>,
<code><a href="#topic+tidy.anova">tidy.anova</a>()</code>,
<code><a href="#topic+tidy.aovlist">tidy.aovlist</a>()</code>,
<code><a href="#topic+tidy.aov">tidy.aov</a>()</code>,
<code><a href="#topic+tidy.manova">tidy.manova</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- aov(mpg ~ wt + qsec + disp, mtcars)
tidy(a)
</code></pre>

<hr>
<h2 id='glance.Arima'>Glance at a(n) Arima object</h2><span id='topic+glance.Arima'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Arima'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.Arima_+3A_x">x</code></td>
<td>
<p>An object of class <code>Arima</code> created by <code><a href="stats.html#topic+arima">stats::arima()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.Arima_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima">stats::arima()</a></code>
</p>
<p>Other Arima tidiers: 
<code><a href="#topic+tidy.Arima">tidy.Arima</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit model
fit &lt;- arima(lh, order = c(1, 0, 0))

# summarize model fit with tidiers
tidy(fit)
glance(fit)

</code></pre>

<hr>
<h2 id='glance.betamfx'>Glance at a(n) betamfx object</h2><span id='topic+glance.betamfx'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betamfx'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.betamfx_+3A_x">x</code></td>
<td>
<p>A <code>betamfx</code> object.</p>
</td></tr>
<tr><td><code id="glance.betamfx_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This glance method wraps <code><a href="#topic+glance.betareg">glance.betareg()</a></code> for <code><a href="mfx.html#topic+betamfx">mfx::betamfx()</a></code> objects.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>
<p>Like the R squared statistic, but for situations when the R squared statistic isn't defined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance.betareg">glance.betareg()</a></code>, <code><a href="mfx.html#topic+betamfx">mfx::betamfx()</a></code>
</p>
<p>Other mfx tidiers: 
<code><a href="#topic+augment.betamfx">augment.betamfx</a>()</code>,
<code><a href="#topic+augment.mfx">augment.mfx</a>()</code>,
<code><a href="#topic+glance.mfx">glance.mfx</a>()</code>,
<code><a href="#topic+tidy.betamfx">tidy.betamfx</a>()</code>,
<code><a href="#topic+tidy.mfx">tidy.mfx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(mfx)

# Simulate some data
set.seed(12345)
n &lt;- 1000
x &lt;- rnorm(n)

# Beta outcome
y &lt;- rbeta(n, shape1 = plogis(1 + 0.5 * x), shape2 = (abs(0.2 * x)))
# Use Smithson and Verkuilen correction
y &lt;- (y * (n - 1) + 0.5) / n

d &lt;- data.frame(y, x)
mod_betamfx &lt;- betamfx(y ~ x | x, data = d)

tidy(mod_betamfx, conf.int = TRUE)

# Compare with the naive model coefficients of the equivalent betareg call (not run)
# tidy(betamfx(y ~ x | x, data = d), conf.int = TRUE)

augment(mod_betamfx)
glance(mod_betamfx)

</code></pre>

<hr>
<h2 id='glance.betareg'>Glance at a(n) betareg object</h2><span id='topic+glance.betareg'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.betareg_+3A_x">x</code></td>
<td>
<p>A <code>betareg</code> object produced by a call to <code><a href="betareg.html#topic+betareg">betareg::betareg()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.betareg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>
<p>Like the R squared statistic, but for situations when the R squared statistic isn't defined.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="betareg.html#topic+betareg">betareg::betareg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(betareg)

# load dats
data("GasolineYield", package = "betareg")

# fit model
mod &lt;- betareg(yield ~ batch + temp, data = GasolineYield)

mod

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)
tidy(mod, conf.int = TRUE, conf.level = .99)

augment(mod)

glance(mod)

</code></pre>

<hr>
<h2 id='glance.biglm'>Glance at a(n) biglm object</h2><span id='topic+glance.biglm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biglm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.biglm_+3A_x">x</code></td>
<td>
<p>A <code>biglm</code> object created by a call to <code><a href="biglm.html#topic+biglm">biglm::biglm()</a></code> or
<code><a href="biglm.html#topic+bigglm">biglm::bigglm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.biglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="biglm.html#topic+biglm">biglm::biglm()</a></code>, <code><a href="biglm.html#topic+bigglm">biglm::bigglm()</a></code>
</p>
<p>Other biglm tidiers: 
<code><a href="#topic+tidy.biglm">tidy.biglm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(biglm)

# fit model -- linear regression
bfit &lt;- biglm(mpg ~ wt + disp, mtcars)

# summarize model fit with tidiers
tidy(bfit)
tidy(bfit, conf.int = TRUE)
tidy(bfit, conf.int = TRUE, conf.level = .9)

glance(bfit)

# fit model -- logistic regression
bgfit &lt;- bigglm(am ~ mpg, mtcars, family = binomial())

# summarize model fit with tidiers
tidy(bgfit)
tidy(bgfit, exponentiate = TRUE)
tidy(bgfit, conf.int = TRUE)
tidy(bgfit, conf.int = TRUE, conf.level = .9)
tidy(bgfit, conf.int = TRUE, conf.level = .9, exponentiate = TRUE)

glance(bgfit)

</code></pre>

<hr>
<h2 id='glance.binDesign'>Glance at a(n) binDesign object</h2><span id='topic+glance.binDesign'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binDesign'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.binDesign_+3A_x">x</code></td>
<td>
<p>A <a href="binGroup.html#topic+binDesign">binGroup::binDesign</a> object.</p>
</td></tr>
<tr><td><code id="glance.binDesign_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>power</code></td>
<td>
<p>Power achieved by the analysis.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Sample size used to achieve this power.</p>
</td></tr>
<tr><td><code>power.reached</code></td>
<td>
<p>Whether the desired power was reached.</p>
</td></tr>
<tr><td><code>maxit</code></td>
<td>
<p>Number of iterations performed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="binGroup.html#topic+binDesign">binGroup::binDesign()</a></code>
</p>
<p>Other bingroup tidiers: 
<code><a href="#topic+tidy.binDesign">tidy.binDesign</a>()</code>,
<code><a href="#topic+tidy.binWidth">tidy.binWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(binGroup)

des &lt;- binDesign(
  nmax = 300, delta = 0.06,
  p.hyp = 0.1, power = .8
)

glance(des)
tidy(des)

library(ggplot2)

ggplot(tidy(des), aes(n, power)) +
  geom_line()

</code></pre>

<hr>
<h2 id='glance.cch'>Glance at a(n) cch object</h2><span id='topic+glance.cch'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cch'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.cch_+3A_x">x</code></td>
<td>
<p>An <code>cch</code> object returned from <code><a href="survival.html#topic+cch">survival::cch()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.cch_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>iter</code></td>
<td>
<p>Iterations of algorithm/fitting procedure completed.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>rscore</code></td>
<td>
<p>Robust log-rank statistic</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>Score.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of predictions</p>
</td></tr>
<tr><td><code>nevent</code></td>
<td>
<p>number of events</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+cch">survival::cch()</a></code>
</p>
<p>Other cch tidiers: 
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# examples come from cch documentation
subcoh &lt;- nwtco$in.subcohort
selccoh &lt;- with(nwtco, rel == 1 | subcoh == 1)
ccoh.data &lt;- nwtco[selccoh, ]
ccoh.data$subcohort &lt;- subcoh[selccoh]

# central-lab histology
ccoh.data$histol &lt;- factor(ccoh.data$histol, labels = c("FH", "UH"))

# tumour stage
ccoh.data$stage &lt;- factor(ccoh.data$stage, labels = c("I", "II", "III", "IV"))
ccoh.data$age &lt;- ccoh.data$age / 12 # age in years

# fit model
fit.ccP &lt;- cch(Surv(edrel, rel) ~ stage + histol + age,
  data = ccoh.data,
  subcoh = ~subcohort, id = ~seqno, cohort.size = 4028
)

# summarize model fit with tidiers + visualization
tidy(fit.ccP)

# coefficient plot
library(ggplot2)

ggplot(tidy(fit.ccP), aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0) +
  geom_vline(xintercept = 0)

</code></pre>

<hr>
<h2 id='glance.clm'>Glance at a(n) clm object</h2><span id='topic+glance.clm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.clm_+3A_x">x</code></td>
<td>
<p>A <code>clm</code> object returned from <code><a href="ordinal.html#topic+clm">ordinal::clm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.clm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The effective degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="ordinal.html#topic+clm">ordinal::clm()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ordinal)

# fit model
fit &lt;- clm(rating ~ temp * contact, data = wine)

# summarize model fit with tidiers
tidy(fit)
tidy(fit, conf.int = TRUE, conf.level = 0.9)
tidy(fit, conf.int = TRUE, conf.type = "Wald", exponentiate = TRUE)

glance(fit)
augment(fit, type.predict = "prob")
augment(fit, type.predict = "class")

# ...and again with another model specification
fit2 &lt;- clm(rating ~ temp, nominal = ~contact, data = wine)

tidy(fit2)
glance(fit2)

</code></pre>

<hr>
<h2 id='glance.clmm'>Glance at a(n) clmm object</h2><span id='topic+glance.clmm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clmm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.clmm_+3A_x">x</code></td>
<td>
<p>A <code>clmm</code> object returned from <code><a href="ordinal.html#topic+clmm">ordinal::clmm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.clmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The effective degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="ordinal.html#topic+clmm">ordinal::clmm()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ordinal)

# fit model
fit &lt;- clmm(rating ~ temp + contact + (1 | judge), data = wine)

# summarize model fit with tidiers
tidy(fit)
tidy(fit, conf.int = TRUE, conf.level = 0.9)
tidy(fit, conf.int = TRUE, exponentiate = TRUE)

glance(fit)

# ...and again with another model specification
fit2 &lt;- clmm(rating ~ temp + (1 | judge), nominal = ~contact, data = wine)

tidy(fit2)
glance(fit2)

</code></pre>

<hr>
<h2 id='glance.coeftest'>Glance at a(n) coeftest object</h2><span id='topic+glance.coeftest'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coeftest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.coeftest_+3A_x">x</code></td>
<td>
<p>A <code>coeftest</code> object returned from <code><a href="lmtest.html#topic+coeftest">lmtest::coeftest()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.coeftest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Because of the way that lmtest::coeftest() retains information about
the underlying model object, the returned columns for glance.coeftest() will
vary depending on the arguments. Specifically, four columns are returned
regardless: &quot;Loglik&quot;, &quot;AIC&quot;, &quot;BIC&quot;, and &quot;nobs&quot;. Users can obtain additional
columns (e.g. &quot;r.squared&quot;, &quot;df&quot;) by invoking the &quot;save = TRUE&quot; argument as
part of lmtest::coeftest(). See examples.
</p>
<p>As an aside, goodness-of-fit measures such as R-squared are unaffected by the
presence of heteroskedasticity. For further discussion see, e.g. chapter 8.1
of Wooldridge (2016).
</p>


<h3>References</h3>

<p>Wooldridge, Jeffrey M. (2016) <cite>Introductory econometrics: A
modern approach.</cite> (6th edition). Nelson Education.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="lmtest.html#topic+coeftest">lmtest::coeftest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lmtest)

m &lt;- lm(dist ~ speed, data = cars)

coeftest(m)
tidy(coeftest(m))
tidy(coeftest(m, conf.int = TRUE))

# a very common workflow is to combine lmtest::coeftest with alternate
# variance-covariance matrices via the sandwich package. The lmtest
# tidiers support this workflow too, enabling you to adjust the standard
# errors of your tidied models on the fly.
library(sandwich)

# "HC3" (default) robust SEs
tidy(coeftest(m, vcov = vcovHC))

# "HC2" robust SEs
tidy(coeftest(m, vcov = vcovHC, type = "HC2"))

# N-W HAC robust SEs
tidy(coeftest(m, vcov = NeweyWest))

# the columns of the returned tibble for glance.coeftest() will vary
# depending on whether the coeftest object retains the underlying model.
# Users can control this with the "save = TRUE" argument of coeftest().
glance(coeftest(m))
glance(coeftest(m, save = TRUE))

</code></pre>

<hr>
<h2 id='glance.coxph'>Glance at a(n) coxph object</h2><span id='topic+glance.coxph'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxph'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.coxph_+3A_x">x</code></td>
<td>
<p>A <code>coxph</code> object returned from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.coxph_+3A_...">...</code></td>
<td>
<p>For <code>tidy()</code>, additional arguments passed to <code>summary(x, ...)</code>.
Otherwise ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total number of observations.</p>
</td></tr>
<tr><td><code>nevent</code></td>
<td>
<p>Number of events.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>
<p>See survival::coxph.object for additional column descriptions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
<p>Other coxph tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
cfit &lt;- coxph(Surv(time, status) ~ age + sex, lung)

# summarize model fit with tidiers
tidy(cfit)
tidy(cfit, exponentiate = TRUE)

lp &lt;- augment(cfit, lung)
risks &lt;- augment(cfit, lung, type.predict = "risk")
expected &lt;- augment(cfit, lung, type.predict = "expected")

glance(cfit)

# also works on clogit models
resp &lt;- levels(logan$occupation)
n &lt;- nrow(logan)
indx &lt;- rep(1:n, length(resp))
logan2 &lt;- data.frame(
  logan[indx, ],
  id = indx,
  tocc = factor(rep(resp, each = n))
)

logan2$case &lt;- (logan2$occupation == logan2$tocc)

cl &lt;- clogit(case ~ tocc + tocc:education + strata(id), logan2)

tidy(cl)
glance(cl)

library(ggplot2)

ggplot(lp, aes(age, .fitted, color = sex)) +
  geom_point()

ggplot(risks, aes(age, .fitted, color = sex)) +
  geom_point()

ggplot(expected, aes(time, .fitted, color = sex)) +
  geom_point()

</code></pre>

<hr>
<h2 id='glance.crr'>Glance at a(n) crr object</h2><span id='topic+glance.crr'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crr'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.crr_+3A_x">x</code></td>
<td>
<p>A <code>crr</code> object returned from <code><a href="cmprsk.html#topic+crr">cmprsk::crr()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.crr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating if the model fitting procedure was succesful and converged.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="cmprsk.html#topic+crr">cmprsk::crr()</a></code>
</p>
<p>Other cmprsk tidiers: 
<code><a href="#topic+tidy.crr">tidy.crr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(cmprsk)

# time to loco-regional failure (lrf)
lrf_time &lt;- rexp(100)
lrf_event &lt;- sample(0:2, 100, replace = TRUE)
trt &lt;- sample(0:1, 100, replace = TRUE)
strt &lt;- sample(1:2, 100, replace = TRUE)

# fit model
x &lt;- crr(lrf_time, lrf_event, cbind(trt, strt))

# summarize model fit with tidiers
tidy(x, conf.int = TRUE)
glance(x)

</code></pre>

<hr>
<h2 id='glance.cv.glmnet'>Glance at a(n) cv.glmnet object</h2><span id='topic+glance.cv.glmnet'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.glmnet'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.cv.glmnet_+3A_x">x</code></td>
<td>
<p>A <code>cv.glmnet</code> object returned from <code><a href="glmnet.html#topic+cv.glmnet">glmnet::cv.glmnet()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.cv.glmnet_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The value of the penalization parameter lambda that results in the sparsest model while remaining within one standard error of the minimum loss.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The value of the penalization parameter lambda that achieved minimum loss as estimated by cross validation.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="glmnet.html#topic+cv.glmnet">glmnet::cv.glmnet()</a></code>
</p>
<p>Other glmnet tidiers: 
<code><a href="#topic+glance.glmnet">glance.glmnet</a>()</code>,
<code><a href="#topic+tidy.cv.glmnet">tidy.cv.glmnet</a>()</code>,
<code><a href="#topic+tidy.glmnet">tidy.glmnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(glmnet)

set.seed(27)

nobs &lt;- 100
nvar &lt;- 50
real &lt;- 5

x &lt;- matrix(rnorm(nobs * nvar), nobs, nvar)
beta &lt;- c(rnorm(real, 0, 1), rep(0, nvar - real))
y &lt;- c(t(beta) %*% t(x)) + rnorm(nvar, sd = 3)

cvfit1 &lt;- cv.glmnet(x, y)

tidy(cvfit1)
glance(cvfit1)

library(ggplot2)

tidied_cv &lt;- tidy(cvfit1)
glance_cv &lt;- glance(cvfit1)

# plot of MSE as a function of lambda
g &lt;- ggplot(tidied_cv, aes(lambda, estimate)) +
  geom_line() +
  scale_x_log10()
g

# plot of MSE as a function of lambda with confidence ribbon
g &lt;- g + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25)
g

# plot of MSE as a function of lambda with confidence ribbon and choices
# of minimum lambda marked
g &lt;- g +
  geom_vline(xintercept = glance_cv$lambda.min) +
  geom_vline(xintercept = glance_cv$lambda.1se, lty = 2)
g

# plot of number of zeros for each choice of lambda
ggplot(tidied_cv, aes(lambda, nzero)) +
  geom_line() +
  scale_x_log10()

# coefficient plot with min lambda shown
tidied &lt;- tidy(cvfit1$glmnet.fit)

ggplot(tidied, aes(lambda, estimate, group = term)) +
  scale_x_log10() +
  geom_line() +
  geom_vline(xintercept = glance_cv$lambda.min) +
  geom_vline(xintercept = glance_cv$lambda.1se, lty = 2)

</code></pre>

<hr>
<h2 id='glance.drc'>Glance at a(n) drc object</h2><span id='topic+glance.drc'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drc'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.drc_+3A_x">x</code></td>
<td>
<p>A <code>drc</code> object produced by a call to <code><a href="drc.html#topic+drm">drc::drm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.drc_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>AICc</code></td>
<td>
<p>AIC corrected for small samples</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="drc.html#topic+drm">drc::drm()</a></code>
</p>
<p>Other drc tidiers: 
<code><a href="#topic+augment.drc">augment.drc</a>()</code>,
<code><a href="#topic+tidy.drc">tidy.drc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(drc)

# fit model
mod &lt;- drm(dead / total ~ conc, type,
  weights = total, data = selenium, fct = LL.2(), type = "binomial"
)

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)

glance(mod)

augment(mod, selenium)

</code></pre>

<hr>
<h2 id='glance.ergm'>Glance at a(n) ergm object</h2><span id='topic+glance.ergm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm'
glance(x, deviance = FALSE, mcmc = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.ergm_+3A_x">x</code></td>
<td>
<p>An <code>ergm</code> object returned from a call to <code><a href="ergm.html#topic+ergm">ergm::ergm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.ergm_+3A_deviance">deviance</code></td>
<td>
<p>Logical indicating whether or not to report null and
residual deviance for the model, as well as degrees of freedom. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="glance.ergm_+3A_mcmc">mcmc</code></td>
<td>
<p>Logical indicating whether or not to report MCMC interval,
burn-in and sample size used to estimate the model. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="glance.ergm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="ergm.html#topic+summary.formula">ergm::summary()</a></code>.
<strong>Cautionary note</strong>: Misspecified arguments may be silently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>glance.ergm</code> returns a one-row tibble with the columns
</p>
<table>
<tr><td><code>independence</code></td>
<td>
<p>Whether the model assumed dyadic independence</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The number of MCMLE iterations performed before convergence</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>If applicable, the log-likelihood associated with the model</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>The Akaike Information Criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>The Bayesian Information Criterion</p>
</td></tr>
</table>
<p>If <code>deviance = TRUE</code>, and if the model supports it, the
tibble will also contain the columns
</p>
<table>
<tr><td><code>null.deviance</code></td>
<td>
<p>The null deviance of the model</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>The degrees of freedom of the null deviance</p>
</td></tr>
<tr><td><code>residual.deviance</code></td>
<td>
<p>The residual deviance of the model</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The degrees of freedom of the residual deviance</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="ergm.html#topic+ergm">ergm::ergm()</a></code>, <code><a href="ergm.html#topic+summary.ergm">ergm::summary.ergm()</a></code>
</p>
<p>Other ergm tidiers: 
<code><a href="#topic+tidy.ergm">tidy.ergm</a>()</code>
</p>

<hr>
<h2 id='glance.factanal'>Glance at a(n) factanal object</h2><span id='topic+glance.factanal'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factanal'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.factanal_+3A_x">x</code></td>
<td>
<p>A <code>factanal</code> object created by <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.factanal_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating if the model fitting procedure was succesful and converged.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Which method was used.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total number of observations.</p>
</td></tr>
<tr><td><code>n.factors</code></td>
<td>
<p>The number of fitted factors.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
<tr><td><code>total.variance</code></td>
<td>
<p>Total cumulative proportion of variance accounted for by all factors.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>
</p>
<p>Other factanal tidiers: 
<code><a href="#topic+augment.factanal">augment.factanal</a>()</code>,
<code><a href="#topic+tidy.factanal">tidy.factanal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# generate data
library(dplyr)
library(purrr)

m1 &lt;- tibble(
  v1 = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 4, 5, 6),
  v2 = c(1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 3, 4, 3, 3, 3, 4, 6, 5),
  v3 = c(3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 4, 6),
  v4 = c(3, 3, 4, 3, 3, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 5, 6, 4),
  v5 = c(1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 6, 4, 5),
  v6 = c(1, 1, 1, 2, 1, 3, 3, 3, 4, 3, 1, 1, 1, 2, 1, 6, 5, 4)
)

# new data
m2 &lt;- map_dfr(m1, rev)

# factor analysis objects
fit1 &lt;- factanal(m1, factors = 3, scores = "Bartlett")
fit2 &lt;- factanal(m1, factors = 3, scores = "regression")

# tidying the object
tidy(fit1)
tidy(fit2)

# augmented dataframe
augment(fit1)
augment(fit2)

# augmented dataframe (with new data)
augment(fit1, data = m2)
augment(fit2, data = m2)

</code></pre>

<hr>
<h2 id='glance.felm'>Glance at a(n) felm object</h2><span id='topic+glance.felm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'felm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.felm_+3A_x">x</code></td>
<td>
<p>A <code>felm</code> object returned from <code><a href="lfe.html#topic+felm">lfe::felm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.felm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lfe)

# use built-in `airquality` dataset
head(airquality)

# no FEs; same as lm()
est0 &lt;- felm(Ozone ~ Temp + Wind + Solar.R, airquality)

# summarize model fit with tidiers
tidy(est0)
augment(est0)

# add month fixed effects
est1 &lt;- felm(Ozone ~ Temp + Wind + Solar.R | Month, airquality)

# summarize model fit with tidiers
tidy(est1)
tidy(est1, fe = TRUE)
augment(est1)
glance(est1)

# the "se.type" argument can be used to switch out different standard errors
# types on the fly. In turn, this can be useful exploring the effect of
# different error structures on model inference.
tidy(est1, se.type = "iid")
tidy(est1, se.type = "robust")

# add clustered SEs (also by month)
est2 &lt;- felm(Ozone ~ Temp + Wind + Solar.R | Month | 0 | Month, airquality)

# summarize model fit with tidiers
tidy(est2, conf.int = TRUE)
tidy(est2, conf.int = TRUE, se.type = "cluster")
tidy(est2, conf.int = TRUE, se.type = "robust")
tidy(est2, conf.int = TRUE, se.type = "iid")

</code></pre>

<hr>
<h2 id='glance.fitdistr'>Glance at a(n) fitdistr object</h2><span id='topic+glance.fitdistr'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitdistr'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.fitdistr_+3A_x">x</code></td>
<td>
<p>A <code>fitdistr</code> object returned by <code><a href="MASS.html#topic+fitdistr">MASS::fitdistr()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.fitdistr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="MASS.html#topic+fitdistr">MASS::fitdistr()</a></code>
</p>
<p>Other fitdistr tidiers: 
<code><a href="#topic+tidy.fitdistr">tidy.fitdistr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# generate data
set.seed(2015)
x &lt;- rnorm(100, 5, 2)

#  fit models
fit &lt;- fitdistr(x, dnorm, list(mean = 3, sd = 1))

# summarize model fit with tidiers
tidy(fit)
glance(fit)

</code></pre>

<hr>
<h2 id='glance.fixest'>Glance at a(n) fixest object</h2><span id='topic+glance.fixest'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object returned from any of the <code>fixest</code> estimators</p>
</td></tr>
<tr><td><code id="glance.fixest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>summary</code> and <code>confint</code>. Important
arguments are <code>se</code> and <code>cluster</code>. Other arguments are <code>dof</code>, <code>exact_dof</code>,
<code>forceCovariance</code>, and <code>keepBounded</code>.
See <code><a href="fixest.html#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>
<p>Like the R squared statistic, but for situations when the R squared statistic isn't defined.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>within.r.squared</code></td>
<td>
<p>R squared within fixed-effect groups.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>All columns listed below will be returned, but some will be <code>NA</code>,
depending on the type of model estimated. <code>sigma</code>, <code>r.squared</code>,
<code>adj.r.squared</code>, and <code>within.r.squared</code> will be NA for any model other than
<code>feols</code>. <code>pseudo.r.squared</code> will be NA for <code>feols</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(fixest)

gravity &lt;-
  feols(
    log(Euros) ~ log(dist_km) | Origin + Destination + Product + Year, trade
  )

tidy(gravity)
glance(gravity)
augment(gravity, trade)

# to get robust or clustered SEs, users can either:

# 1) specify the arguments directly in the `tidy()` call

tidy(gravity, conf.int = TRUE, cluster = c("Product", "Year"))

tidy(gravity, conf.int = TRUE, se = "threeway")

# 2) or, feed tidy() a summary.fixest object that has already accepted
# these arguments

gravity_summ &lt;- summary(gravity, cluster = c("Product", "Year"))

tidy(gravity_summ, conf.int = TRUE)

# approach (1) is preferred.

</code></pre>

<hr>
<h2 id='glance.gam'>Glance at a(n) gam object</h2><span id='topic+glance.gam'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.gam_+3A_x">x</code></td>
<td>
<p>A <code>gam</code> object returned from a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.gam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>Number of parameters in the model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>
</p>
<p>Other mgcv tidiers: 
<code><a href="#topic+tidy.gam">tidy.gam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mgcv)

# fit model
g &lt;- gam(mpg ~ s(hp) + am + qsec, data = mtcars)

# summarize model fit with tidiers
tidy(g)
tidy(g, parametric = TRUE)
glance(g)
augment(g)

</code></pre>

<hr>
<h2 id='glance.Gam'>Glance at a(n) Gam object</h2><span id='topic+glance.Gam'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gam'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.Gam_+3A_x">x</code></td>
<td>
<p>A <code>Gam</code> object returned from a call to <code><a href="gam.html#topic+gam">gam::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.Gam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Glance at <code>gam</code> objects created by calls to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> with
<code><a href="#topic+glance.gam">glance.gam()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="gam.html#topic+gam">gam::gam()</a></code>
</p>
<p>Other gam tidiers: 
<code><a href="#topic+tidy.Gam">tidy.Gam</a>()</code>
</p>

<hr>
<h2 id='glance.garch'>Tidy a(n) garch object</h2><span id='topic+glance.garch'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garch'
glance(x, test = c("box-ljung-test", "jarque-bera-test"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.garch_+3A_x">x</code></td>
<td>
<p>A <code>garch</code> object returned by <code><a href="tseries.html#topic+garch">tseries::garch()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.garch_+3A_test">test</code></td>
<td>
<p>Character specification of which hypothesis test to use. The
<code>garch</code> function reports 2 hypothesis tests: Jarque-Bera to residuals
and Box-Ljung to squared residuals.</p>
</td></tr>
<tr><td><code id="glance.garch_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Which method was used.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Parameter field in the htest, typically degrees of
freedom.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="tseries.html#topic+garch">tseries::garch()</a></code>, []
</p>
<p>Other garch tidiers: 
<code><a href="#topic+tidy.garch">tidy.garch</a>()</code>
</p>

<hr>
<h2 id='glance.geeglm'>Glance at a(n) geeglm object</h2><span id='topic+glance.geeglm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geeglm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.geeglm_+3A_x">x</code></td>
<td>
<p>A <code>geeglm</code> object returned from a call to <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.geeglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>Estimated correlation parameter for geepack::geeglm.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Estimated scale parameter for geepack::geeglm.</p>
</td></tr>
<tr><td><code>max.cluster.size</code></td>
<td>
<p>Max number of elements in clusters.</p>
</td></tr>
<tr><td><code>n.clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(geepack)

# load data
data(state)


ds &lt;- data.frame(state.region, state.x77)

# fit model
geefit &lt;- geeglm(Income ~ Frost + Murder,
  id = state.region,
  data = ds,
  corstr = "exchangeable"
)

# summarize model fit with tidiers
tidy(geefit)
tidy(geefit, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='glance.glm'>Glance at a(n) glm object</h2><span id='topic+glance.glm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.glm_+3A_x">x</code></td>
<td>
<p>A <code>glm</code> object returned from <code><a href="stats.html#topic+glm">stats::glm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.glm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">stats::glm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- glm(am ~ mpg, mtcars, family = "binomial")
glance(g)
</code></pre>

<hr>
<h2 id='glance.glmnet'>Glance at a(n) glmnet object</h2><span id='topic+glance.glmnet'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmnet'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.glmnet_+3A_x">x</code></td>
<td>
<p>A <code>glmnet</code> object returned from <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.glmnet_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total passes over the data across all lambda values.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code>
</p>
<p>Other glmnet tidiers: 
<code><a href="#topic+glance.cv.glmnet">glance.cv.glmnet</a>()</code>,
<code><a href="#topic+tidy.cv.glmnet">tidy.cv.glmnet</a>()</code>,
<code><a href="#topic+tidy.glmnet">tidy.glmnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(glmnet)

set.seed(2014)
x &lt;- matrix(rnorm(100 * 20), 100, 20)
y &lt;- rnorm(100)
fit1 &lt;- glmnet(x, y)

# summarize model fit with tidiers + visualization
tidy(fit1)
glance(fit1)

library(dplyr)
library(ggplot2)

tidied &lt;- tidy(fit1) %&gt;% filter(term != "(Intercept)")

ggplot(tidied, aes(step, estimate, group = term)) +
  geom_line()

ggplot(tidied, aes(lambda, estimate, group = term)) +
  geom_line() +
  scale_x_log10()

ggplot(tidied, aes(lambda, dev.ratio)) +
  geom_line()

# works for other types of regressions as well, such as logistic
g2 &lt;- sample(1:2, 100, replace = TRUE)
fit2 &lt;- glmnet(x, g2, family = "binomial")
tidy(fit2)

</code></pre>

<hr>
<h2 id='glance.glmRob'>Glance at a(n) glmRob object</h2><span id='topic+glance.glmRob'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmRob'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.glmRob_+3A_x">x</code></td>
<td>
<p>A <code>glmRob</code> object returned from <code><a href="robust.html#topic+glmRob">robust::glmRob()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.glmRob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="robust.html#topic+glmRob">robust::glmRob()</a></code>
</p>
<p>Other robust tidiers: 
<code><a href="#topic+augment.lmRob">augment.lmRob</a>()</code>,
<code><a href="#topic+glance.lmRob">glance.lmRob</a>()</code>,
<code><a href="#topic+tidy.glmRob">tidy.glmRob</a>()</code>,
<code><a href="#topic+tidy.lmRob">tidy.lmRob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(robust)

# fit model
gm &lt;- glmRob(am ~ wt, data = mtcars, family = "binomial")

# summarize model fit with tidiers
tidy(gm)
glance(gm)

</code></pre>

<hr>
<h2 id='glance.gmm'>Glance at a(n) gmm object</h2><span id='topic+glance.gmm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.gmm_+3A_x">x</code></td>
<td>
<p>A <code>gmm</code> object returned from <code><a href="gmm.html#topic+gmm">gmm::gmm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.gmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="gmm.html#topic+gmm">gmm::gmm()</a></code>
</p>
<p>Other gmm tidiers: 
<code><a href="#topic+tidy.gmm">tidy.gmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(gmm)

# examples come from the "gmm" package
# CAPM test with GMM
data(Finance)
r &lt;- Finance[1:300, 1:10]
rm &lt;- Finance[1:300, "rm"]
rf &lt;- Finance[1:300, "rf"]

z &lt;- as.matrix(r - rf)
t &lt;- nrow(z)
zm &lt;- rm - rf
h &lt;- matrix(zm, t, 1)
res &lt;- gmm(z ~ zm, x = h)

# tidy result
tidy(res)
tidy(res, conf.int = TRUE)
tidy(res, conf.int = TRUE, conf.level = .99)

# coefficient plot
library(ggplot2)
library(dplyr)

tidy(res, conf.int = TRUE) %&gt;%
  mutate(variable = reorder(term, estimate)) %&gt;%
  ggplot(aes(estimate, variable)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, color = "red", lty = 2)

# from a function instead of a matrix
g &lt;- function(theta, x) {
  e &lt;- x[, 2:11] - theta[1] - (x[, 1] - theta[1]) %*% matrix(theta[2:11], 1, 10)
  gmat &lt;- cbind(e, e * c(x[, 1]))
  return(gmat)
}

x &lt;- as.matrix(cbind(rm, r))
res_black &lt;- gmm(g, x = x, t0 = rep(0, 11))

tidy(res_black)
tidy(res_black, conf.int = TRUE)

# APT test with Fama-French factors and GMM

f1 &lt;- zm
f2 &lt;- Finance[1:300, "hml"] - rf
f3 &lt;- Finance[1:300, "smb"] - rf
h &lt;- cbind(f1, f2, f3)
res2 &lt;- gmm(z ~ f1 + f2 + f3, x = h)

td2 &lt;- tidy(res2, conf.int = TRUE)
td2

# coefficient plot
td2 %&gt;%
  mutate(variable = reorder(term, estimate)) %&gt;%
  ggplot(aes(estimate, variable)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, color = "red", lty = 2)

</code></pre>

<hr>
<h2 id='glance.ivreg'>Glance at a(n) ivreg object</h2><span id='topic+glance.ivreg'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivreg'
glance(x, diagnostics = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.ivreg_+3A_x">x</code></td>
<td>
<p>An <code>ivreg</code> object created by a call to <code><a href="AER.html#topic+ivreg">AER::ivreg()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.ivreg_+3A_diagnostics">diagnostics</code></td>
<td>
<p>Logical indicating whether or not to return the
Wu-Hausman and Sargan diagnostic information.</p>
</td></tr>
<tr><td><code id="glance.ivreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This tidier currently only supports <code>ivreg</code>-classed objects
outputted by the <code>AER</code> package. The <code>ivreg</code> package also outputs
objects of class <code>ivreg</code>, and will be supported in a later release.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Wald test statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value for the Wald test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Beginning 0.7.0, <code>glance.ivreg</code> returns statistics for the
Wu-Hausman test for endogeneity and the Sargan test of
overidentifying restrictions. Sargan test values are returned as <code>NA</code>
if the number of instruments is not greater than the number of
endogenous regressors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="AER.html#topic+ivreg">AER::ivreg()</a></code>
</p>
<p>Other ivreg tidiers: 
<code><a href="#topic+augment.ivreg">augment.ivreg</a>()</code>,
<code><a href="#topic+tidy.ivreg">tidy.ivreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(AER)

# load data
data("CigarettesSW", package = "AER")

# fit model
ivr &lt;- ivreg(
  log(packs) ~ income | population,
  data = CigarettesSW,
  subset = year == "1995"
)

# summarize model fit with tidiers
tidy(ivr)
tidy(ivr, conf.int = TRUE)
tidy(ivr, conf.int = TRUE, instruments = TRUE)

augment(ivr)
augment(ivr, data = CigarettesSW)
augment(ivr, newdata = CigarettesSW)

glance(ivr)

</code></pre>

<hr>
<h2 id='glance.kmeans'>Glance at a(n) kmeans object</h2><span id='topic+glance.kmeans'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.kmeans_+3A_x">x</code></td>
<td>
<p>A <code>kmeans</code> object created by <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.kmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>betweenss</code></td>
<td>
<p>The total between-cluster sum of squares.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Iterations of algorithm/fitting procedure completed.</p>
</td></tr>
<tr><td><code>tot.withinss</code></td>
<td>
<p>The total within-cluster sum of squares.</p>
</td></tr>
<tr><td><code>totss</code></td>
<td>
<p>The total sum of squares.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>
</p>
<p>Other kmeans tidiers: 
<code><a href="#topic+augment.kmeans">augment.kmeans</a>()</code>,
<code><a href="#topic+tidy.kmeans">tidy.kmeans</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(cluster)
library(modeldata)
library(dplyr)

data(hpc_data)

x &lt;- hpc_data[, 2:5]

fit &lt;- pam(x, k = 4)

tidy(fit)
glance(fit)
augment(fit, x)

</code></pre>

<hr>
<h2 id='glance.lavaan'>Glance at a(n) lavaan object</h2><span id='topic+glance.lavaan'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lavaan'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.lavaan_+3A_x">x</code></td>
<td>
<p>A <code>lavaan</code> object, such as those returned from <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code>,
and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.lavaan_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns:
</p>
<table>
<tr><td><code>chisq</code></td>
<td>
<p>Model chi squared</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>Number of parameters in the model</p>
</td></tr>
<tr><td><code>rmsea</code></td>
<td>
<p>Root mean square error of approximation</p>
</td></tr>
<tr><td><code>rmsea.conf.high</code></td>
<td>
<p>95 percent upper bound on RMSEA</p>
</td></tr>
<tr><td><code>srmr</code></td>
<td>
<p>Standardised root mean residual</p>
</td></tr>
<tr><td><code>agfi</code></td>
<td>
<p>Adjusted goodness of fit</p>
</td></tr>
<tr><td><code>cfi</code></td>
<td>
<p>Comparative fit index</p>
</td></tr>
<tr><td><code>tli</code></td>
<td>
<p>Tucker Lewis index</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike information criterion</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion</p>
</td></tr>
<tr><td><code>ngroups</code></td>
<td>
<p>Number of groups in model</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations included</p>
</td></tr>
<tr><td><code>norig</code></td>
<td>
<p>Number of observation in the original dataset</p>
</td></tr>
<tr><td><code>nexcluded</code></td>
<td>
<p>Number of excluded observations</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical - Did the model converge</p>
</td></tr>
<tr><td><code>estimator</code></td>
<td>
<p>Estimator used</p>
</td></tr>
<tr><td><code>missing_method</code></td>
<td>
<p>Method for eliminating missing data</p>
</td></tr>
</table>
<p>For further recommendations on reporting SEM and CFA models see
Schreiber, J. B. (2017). Update to core reporting practices in
structural equation modeling. Research in Social and Administrative
Pharmacy, 13(3), 634-643. https://doi.org/10.1016/j.sapharm.2016.06.006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code>, <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>,
<code><a href="lavaan.html#topic+fitMeasures">lavaan::fitmeasures()</a></code>
</p>
<p>Other lavaan tidiers: 
<code><a href="#topic+tidy.lavaan">tidy.lavaan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(lavaan)

# fit model
cfa.fit &lt;- cfa(
  "F =~ x1 + x2 + x3 + x4 + x5",
  data = HolzingerSwineford1939, group = "school"
)

# summarize model fit with tidiers
glance(cfa.fit)

</code></pre>

<hr>
<h2 id='glance.lm'>Glance at a(n) lm object</h2><span id='topic+glance.lm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.lm_+3A_x">x</code></td>
<td>
<p>An <code>lm</code> object created by <code><a href="stats.html#topic+lm">stats::lm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees for freedom from the numerator of the overall
F-statistic. This is new in broom 0.7.0. Previously, this reported
the rank of the design matrix, which is one more than the numerator
degrees of freedom of the overall F-statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="#topic+glance.summary.lm">glance.summary.lm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(dplyr)

mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)

tidy(mod)
glance(mod)

# coefficient plot
d &lt;- tidy(mod, conf.int = TRUE)

ggplot(d, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point() +
  geom_vline(xintercept = 0, lty = 4) +
  geom_errorbarh()

# aside: There are tidy() and glance() methods for lm.summary objects too.
# this can be useful when you want to conserve memory by converting large lm
# objects into their leaner summary.lm equivalents.
s &lt;- summary(mod)
tidy(s, conf.int = TRUE)
glance(s)

augment(mod)
augment(mod, mtcars, interval = "confidence")

# predict on new data
newdata &lt;- mtcars %&gt;%
  head(6) %&gt;%
  mutate(wt = wt + 1)
augment(mod, newdata = newdata)

# ggplot2 example where we also construct 95% prediction interval

# simpler bivariate model since we're plotting in 2D
mod2 &lt;- lm(mpg ~ wt, data = mtcars)

au &lt;- augment(mod2, newdata = newdata, interval = "prediction")

ggplot(au, aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper), col = NA, alpha = 0.3)

# predict on new data without outcome variable. Output does not include .resid
newdata &lt;- newdata %&gt;%
  select(-mpg)

augment(mod, newdata = newdata)

au &lt;- augment(mod, data = mtcars)

ggplot(au, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() +
  geom_smooth(se = FALSE)

plot(mod, which = 6)

ggplot(au, aes(.hat, .cooksd)) +
  geom_vline(xintercept = 0, colour = NA) +
  geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
  geom_smooth(se = FALSE) +
  geom_point()

# column-wise models
a &lt;- matrix(rnorm(20), nrow = 10)
b &lt;- a + rnorm(length(a))
result &lt;- lm(b ~ a)

tidy(result)

</code></pre>

<hr>
<h2 id='glance.lmodel2'>Glance at a(n) lmodel2 object</h2><span id='topic+glance.lmodel2'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmodel2'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.lmodel2_+3A_x">x</code></td>
<td>
<p>A <code>lmodel2</code> object returned by <code><a href="lmodel2.html#topic+lmodel2">lmodel2::lmodel2()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.lmodel2_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Angle between OLS lines 'lm(y ~ x)' and 'lm(x ~ y)'</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>H statistic for computing confidence interval of major axis slope</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="lmodel2.html#topic+lmodel2">lmodel2::lmodel2()</a></code>
</p>
<p>Other lmodel2 tidiers: 
<code><a href="#topic+tidy.lmodel2">tidy.lmodel2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lmodel2)

data(mod2ex2)
Ex2.res &lt;- lmodel2(Prey ~ Predators, data = mod2ex2, "relative", "relative", 99)
Ex2.res

# summarize model fit with tidiers + visualization
tidy(Ex2.res)
glance(Ex2.res)

# this allows coefficient plots with ggplot2
library(ggplot2)

ggplot(tidy(Ex2.res), aes(estimate, term, color = method)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high))

</code></pre>

<hr>
<h2 id='glance.lmrob'>Glance at a(n) lmrob object</h2><span id='topic+glance.lmrob'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmrob'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.lmrob_+3A_x">x</code></td>
<td>
<p>A <code>lmrob</code> object returned from <code><a href="robustbase.html#topic+lmrob">robustbase::lmrob()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.lmrob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+lmrob">robustbase::lmrob()</a></code>
</p>
<p>Other robustbase tidiers: 
<code><a href="#topic+augment.glmrob">augment.glmrob</a>()</code>,
<code><a href="#topic+augment.lmrob">augment.lmrob</a>()</code>,
<code><a href="#topic+tidy.glmrob">tidy.glmrob</a>()</code>,
<code><a href="#topic+tidy.lmrob">tidy.lmrob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("robustbase", quietly = TRUE)) {
  # load libraries for models and data
  library(robustbase)

  data(coleman)
  set.seed(0)

  m &lt;- lmrob(Y ~ ., data = coleman)
  tidy(m)
  augment(m)
  glance(m)

  data(carrots)

  Rfit &lt;- glmrob(cbind(success, total - success) ~ logdose + block,
    family = binomial, data = carrots, method = "Mqle",
    control = glmrobMqle.control(tcc = 1.2)
  )

  tidy(Rfit)
  augment(Rfit)
}
</code></pre>

<hr>
<h2 id='glance.lmRob'>Glance at a(n) lmRob object</h2><span id='topic+glance.lmRob'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmRob'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.lmRob_+3A_x">x</code></td>
<td>
<p>A <code>lmRob</code> object returned from <code><a href="robust.html#topic+lmRob">robust::lmRob()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.lmRob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="robust.html#topic+lmRob">robust::lmRob()</a></code>
</p>
<p>Other robust tidiers: 
<code><a href="#topic+augment.lmRob">augment.lmRob</a>()</code>,
<code><a href="#topic+glance.glmRob">glance.glmRob</a>()</code>,
<code><a href="#topic+tidy.glmRob">tidy.glmRob</a>()</code>,
<code><a href="#topic+tidy.lmRob">tidy.lmRob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(robust)

# fit model
m &lt;- lmRob(mpg ~ wt, data = mtcars)

# summarize model fit with tidiers
tidy(m)
augment(m)
glance(m)

</code></pre>

<hr>
<h2 id='glance.margins'>Glance at a(n) margins object</h2><span id='topic+glance.margins'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'margins'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.margins_+3A_x">x</code></td>
<td>
<p>A <code>margins</code> object returned from <code>margins::margins()</code>.</p>
</td></tr>
<tr><td><code id="glance.margins_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>

<hr>
<h2 id='glance.Mclust'>Glance at a(n) Mclust object</h2><span id='topic+glance.Mclust'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Mclust'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.Mclust_+3A_x">x</code></td>
<td>
<p>An <code>Mclust</code> object return from <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.Mclust_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A string denoting the model type with optimal BIC</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number mixture components in optimal model</p>
</td></tr>
<tr><td><code>hypvol</code></td>
<td>
<p>If the other model contains a noise component, the
value of the hypervolume parameter. Otherwise 'NA'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# load library for models and data
library(mclust)

# load data manipulation libraries
library(dplyr)
library(tibble)
library(purrr)
library(tidyr)

set.seed(27)

centers &lt;- tibble(
  cluster = factor(1:3),
  # number points in each cluster
  num_points = c(100, 150, 50),
  # x1 coordinate of cluster center
  x1 = c(5, 0, -3),
  # x2 coordinate of cluster center
  x2 = c(-1, 1, -2)
)

points &lt;- centers %&gt;%
  mutate(
    x1 = map2(num_points, x1, rnorm),
    x2 = map2(num_points, x2, rnorm)
  ) %&gt;%
  select(-num_points, -cluster) %&gt;%
  unnest(c(x1, x2))

# fit model
m &lt;- Mclust(points)

# summarize model fit with tidiers
tidy(m)
augment(m, points)
glance(m)

</code></pre>

<hr>
<h2 id='glance.mfx'>Glance at a(n) mfx object</h2><span id='topic+glance.mfx'></span><span id='topic+glance.logitmfx'></span><span id='topic+glance.negbinmfx'></span><span id='topic+glance.poissonmfx'></span><span id='topic+glance.probitmfx'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfx'
glance(x, ...)

## S3 method for class 'logitmfx'
glance(x, ...)

## S3 method for class 'negbinmfx'
glance(x, ...)

## S3 method for class 'poissonmfx'
glance(x, ...)

## S3 method for class 'probitmfx'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.mfx_+3A_x">x</code></td>
<td>
<p>A <code>logitmfx</code>, <code>negbinmfx</code>, <code>poissonmfx</code>, or <code>probitmfx</code>  object. (Note that <code>betamfx</code> objects receive their own set of tidiers.)</p>
</td></tr>
<tr><td><code id="glance.mfx_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic glance method wraps <code><a href="#topic+glance.glm">glance.glm()</a></code> for applicable
objects from the <code>mfx</code> package.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance.glm">glance.glm()</a></code>, <code><a href="mfx.html#topic+logitmfx">mfx::logitmfx()</a></code>, <code><a href="mfx.html#topic+negbinmfx">mfx::negbinmfx()</a></code>,
<code><a href="mfx.html#topic+poissonmfx">mfx::poissonmfx()</a></code>, <code><a href="mfx.html#topic+probitmfx">mfx::probitmfx()</a></code>
</p>
<p>Other mfx tidiers: 
<code><a href="#topic+augment.betamfx">augment.betamfx</a>()</code>,
<code><a href="#topic+augment.mfx">augment.mfx</a>()</code>,
<code><a href="#topic+glance.betamfx">glance.betamfx</a>()</code>,
<code><a href="#topic+tidy.betamfx">tidy.betamfx</a>()</code>,
<code><a href="#topic+tidy.mfx">tidy.mfx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mfx)

# get the marginal effects from a logit regression
mod_logmfx &lt;- logitmfx(am ~ cyl + hp + wt, atmean = TRUE, data = mtcars)

tidy(mod_logmfx, conf.int = TRUE)

# compare with the naive model coefficients of the same logit call
tidy(
  glm(am ~ cyl + hp + wt, family = binomial, data = mtcars),
  conf.int = TRUE
)

augment(mod_logmfx)
glance(mod_logmfx)

# another example, this time using probit regression
mod_probmfx &lt;- probitmfx(am ~ cyl + hp + wt, atmean = TRUE, data = mtcars)

tidy(mod_probmfx, conf.int = TRUE)
augment(mod_probmfx)
glance(mod_probmfx)

</code></pre>

<hr>
<h2 id='glance.mjoint'>Glance at a(n) mjoint object</h2><span id='topic+glance.mjoint'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.mjoint_+3A_x">x</code></td>
<td>
<p>An <code>mjoint</code> object returned from <code><a href="joineRML.html#topic+mjoint">joineRML::mjoint()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.mjoint_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>sigma2_j</code></td>
<td>
<p>The square root of the estimated residual variance for
the j-th longitudinal process</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="joineRML.html#topic+mjoint">joineRML::mjoint()</a></code>
</p>
<p>Other mjoint tidiers: 
<code><a href="#topic+tidy.mjoint">tidy.mjoint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# broom only skips running these examples because the example models take a
# while to generate—they should run just fine, though!
## Not run: 


# load libraries for models and data
library(joineRML)

# fit a joint model with bivariate longitudinal outcomes
data(heart.valve)

hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp;
  !is.na(heart.valve$log.lvmi) &amp;
  heart.valve$num &lt;= 50, ]

fit &lt;- mjoint(
  formLongFixed = list(
    "grad" = log.grad ~ time + sex + hs,
    "lvmi" = log.lvmi ~ time + sex
  ),
  formLongRandom = list(
    "grad" = ~ 1 | num,
    "lvmi" = ~ time | num
  ),
  formSurv = Surv(fuyrs, status) ~ age,
  data = hvd,
  inits = list("gamma" = c(0.11, 1.51, 0.80)),
  timeVar = "time"
)

# extract the survival fixed effects
tidy(fit)

# extract the longitudinal fixed effects
tidy(fit, component = "longitudinal")

# extract the survival fixed effects with confidence intervals
tidy(fit, ci = TRUE)

# extract the survival fixed effects with confidence intervals based
# on bootstrapped standard errors
bSE &lt;- bootSE(fit, nboot = 5, safe.boot = TRUE)
tidy(fit, boot_se = bSE, ci = TRUE)

# augment original data with fitted longitudinal values and residuals
hvd2 &lt;- augment(fit)

# extract model statistics
glance(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='glance.mlogit'>Glance at a(n) mlogit object</h2><span id='topic+glance.mlogit'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlogit'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.mlogit_+3A_x">x</code></td>
<td>
<p>an object returned from <code><a href="mlogit.html#topic+mlogit">mlogit::mlogit()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.mlogit_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>rho2</code></td>
<td>
<p>McFadden's rho squared with respect to a market shares (constants-only) model.</p>
</td></tr>
<tr><td><code>rho20</code></td>
<td>
<p>McFadden's rho squared with respect to an equal shares (no information) model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="mlogit.html#topic+mlogit">mlogit::mlogit()</a></code>
</p>
<p>Other mlogit tidiers: 
<code><a href="#topic+augment.mlogit">augment.mlogit</a>()</code>,
<code><a href="#topic+tidy.mlogit">tidy.mlogit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mlogit)

data("Fishing", package = "mlogit")
Fish &lt;- dfidx(Fishing, varying = 2:9, shape = "wide", choice = "mode")

# fit model
m &lt;- mlogit(mode ~ price + catch | income, data = Fish)

# summarize model fit with tidiers
tidy(m)
augment(m)
glance(m)

</code></pre>

<hr>
<h2 id='glance.muhaz'>Glance at a(n) muhaz object</h2><span id='topic+glance.muhaz'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'muhaz'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.muhaz_+3A_x">x</code></td>
<td>
<p>A <code>muhaz</code> object returned by <code><a href="muhaz.html#topic+muhaz">muhaz::muhaz()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.muhaz_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>max.hazard</code></td>
<td>
<p>Maximal estimated hazard.</p>
</td></tr>
<tr><td><code>max.time</code></td>
<td>
<p>The maximum observed event or censoring time.</p>
</td></tr>
<tr><td><code>min.hazard</code></td>
<td>
<p>Minimal estimated hazard.</p>
</td></tr>
<tr><td><code>min.time</code></td>
<td>
<p>The minimum observed event or censoring time.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="muhaz.html#topic+muhaz">muhaz::muhaz()</a></code>
</p>
<p>Other muhaz tidiers: 
<code><a href="#topic+tidy.muhaz">tidy.muhaz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(muhaz)
library(survival)

# fit model
x &lt;- muhaz(ovarian$futime, ovarian$fustat)

# summarize model fit with tidiers
tidy(x)
glance(x)

</code></pre>

<hr>
<h2 id='glance.multinom'>Glance at a(n) multinom object</h2><span id='topic+glance.multinom'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multinom'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.multinom_+3A_x">x</code></td>
<td>
<p>A <code>multinom</code> object returned from <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.multinom_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The effective degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>
</p>
<p>Other multinom tidiers: 
<code><a href="#topic+tidy.multinom">tidy.multinom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(nnet)
library(MASS)

example(birthwt)

bwt.mu &lt;- multinom(low ~ ., bwt)

tidy(bwt.mu)
glance(bwt.mu)

# or, for output from a multinomial logistic regression
fit.gear &lt;- multinom(gear ~ mpg + factor(am), data = mtcars)
tidy(fit.gear)
glance(fit.gear)

</code></pre>

<hr>
<h2 id='glance.negbin'>Glance at a(n) negbin object</h2><span id='topic+glance.negbin'></span><span id='topic+glm.nb_tidiers'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'negbin'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.negbin_+3A_x">x</code></td>
<td>
<p>A <code>negbin</code> object returned by <code><a href="MASS.html#topic+glm.nb">MASS::glm.nb()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.negbin_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="MASS.html#topic+glm.nb">MASS::glm.nb()</a></code>
</p>
<p>Other glm.nb tidiers: 
<code><a href="#topic+tidy.negbin">tidy.negbin</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
r &lt;- glm.nb(Days ~ Sex / (Age + Eth * Lrn), data = quine)

# summarize model fit with tidiers
tidy(r)
glance(r)

</code></pre>

<hr>
<h2 id='glance.nlrq'>Glance at a(n) nlrq object</h2><span id='topic+glance.nlrq'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlrq'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.nlrq_+3A_x">x</code></td>
<td>
<p>A <code>nlrq</code> object returned from <code><a href="quantreg.html#topic+nlrq">quantreg::nlrq()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.nlrq_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Quantile.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="quantreg.html#topic+nlrq">quantreg::nlrq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(quantreg)

# build artificial data with multiplicative error
set.seed(1)
dat &lt;- NULL
dat$x &lt;- rep(1:25, 20)
dat$y &lt;- SSlogis(dat$x, 10, 12, 2) * rnorm(500, 1, 0.1)

# fit the median using nlrq
mod &lt;- nlrq(y ~ SSlogis(x, Asym, mid, scal),
  data = dat, tau = 0.5, trace = TRUE
)

# summarize model fit with tidiers
tidy(mod)
glance(mod)
augment(mod)

</code></pre>

<hr>
<h2 id='glance.nls'>Glance at a(n) nls object</h2><span id='topic+glance.nls'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nls'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.nls_+3A_x">x</code></td>
<td>
<p>An <code>nls</code> object returned from <code><a href="stats.html#topic+nls">stats::nls()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.nls_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>finTol</code></td>
<td>
<p>The achieved convergence tolerance.</p>
</td></tr>
<tr><td><code>isConv</code></td>
<td>
<p>Whether the fit successfully converged.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="stats.html#topic+nls">stats::nls()</a></code>
</p>
<p>Other nls tidiers: 
<code><a href="#topic+augment.nls">augment.nls</a>()</code>,
<code><a href="#topic+tidy.nls">tidy.nls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit model
n &lt;- nls(mpg ~ k * e^wt, data = mtcars, start = list(k = 1, e = 2))

# summarize model fit with tidiers + visualization
tidy(n)
augment(n)
glance(n)

library(ggplot2)

ggplot(augment(n), aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted))

newdata &lt;- head(mtcars)
newdata$wt &lt;- newdata$wt + 1

augment(n, newdata = newdata)

</code></pre>

<hr>
<h2 id='glance.orcutt'>Glance at a(n) orcutt object</h2><span id='topic+glance.orcutt'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orcutt'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.orcutt_+3A_x">x</code></td>
<td>
<p>An <code>orcutt</code> object returned from <code><a href="orcutt.html#topic+cochrane.orcutt">orcutt::cochrane.orcutt()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.orcutt_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>dw.original</code></td>
<td>
<p>Durbin-Watson statistic of original fit.</p>
</td></tr>
<tr><td><code>dw.transformed</code></td>
<td>
<p>Durbin-Watson statistic of transformed fit.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>number.interaction</code></td>
<td>
<p>Number of interactions.</p>
</td></tr>
<tr><td><code>p.value.original</code></td>
<td>
<p>P-value of original Durbin-Watson statistic.</p>
</td></tr>
<tr><td><code>p.value.transformed</code></td>
<td>
<p>P-value of autocorrelation after transformation.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Spearman's rho autocorrelation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="orcutt.html#topic+cochrane.orcutt">orcutt::cochrane.orcutt()</a></code>
</p>
<p>Other orcutt tidiers: 
<code><a href="#topic+tidy.orcutt">tidy.orcutt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(orcutt)

# fit model and summarize results
reg &lt;- lm(mpg ~ wt + qsec + disp, mtcars)
tidy(reg)


co &lt;- cochrane.orcutt(reg)
tidy(co)
glance(co)

</code></pre>

<hr>
<h2 id='glance.pam'>Glance at a(n) pam object</h2><span id='topic+glance.pam'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pam'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.pam_+3A_x">x</code></td>
<td>
<p>An <code>pam</code> object returned from <code><a href="cluster.html#topic+pam">cluster::pam()</a></code></p>
</td></tr>
<tr><td><code id="glance.pam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>avg.silhouette.width</code></td>
<td>
<p>The average silhouette width for the dataset.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>
<p>Other pam tidiers: 
<code><a href="#topic+augment.pam">augment.pam</a>()</code>,
<code><a href="#topic+tidy.pam">tidy.pam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(dplyr)
library(ggplot2)
library(cluster)
library(modeldata)
data(hpc_data)

x &lt;- hpc_data[, 2:5]
p &lt;- pam(x, k = 4)

# summarize model fit with tidiers + visualization
tidy(p)
glance(p)
augment(p, x)

augment(p, x) %&gt;%
  ggplot(aes(compounds, input_fields)) +
  geom_point(aes(color = .cluster)) +
  geom_text(aes(label = cluster), data = tidy(p), size = 10)

</code></pre>

<hr>
<h2 id='glance.plm'>Glance at a(n) plm object</h2><span id='topic+glance.plm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.plm_+3A_x">x</code></td>
<td>
<p>A <code>plm</code> objected returned by <code><a href="plm.html#topic+plm">plm::plm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.plm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>F-statistic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="plm.html#topic+plm">plm::plm()</a></code>
</p>
<p>Other plm tidiers: 
<code><a href="#topic+augment.plm">augment.plm</a>()</code>,
<code><a href="#topic+tidy.plm">tidy.plm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(plm)

# load data
data("Produc", package = "plm")

# fit model
zz &lt;- plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp,
  data = Produc, index = c("state", "year")
)

# summarize model fit with tidiers
summary(zz)

tidy(zz)
tidy(zz, conf.int = TRUE)
tidy(zz, conf.int = TRUE, conf.level = 0.9)

augment(zz)
glance(zz)

</code></pre>

<hr>
<h2 id='glance.poLCA'>Glance at a(n) poLCA object</h2><span id='topic+glance.poLCA'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poLCA'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.poLCA_+3A_x">x</code></td>
<td>
<p>A <code>poLCA</code> object returned from <code><a href="poLCA.html#topic+poLCA">poLCA::poLCA()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.poLCA_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>chi.squared</code></td>
<td>
<p>The Pearson Chi-Square goodness of fit statistic for multiway tables.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>g.squared</code></td>
<td>
<p>The likelihood ratio/deviance statistic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="poLCA.html#topic+poLCA">poLCA::poLCA()</a></code>
</p>
<p>Other poLCA tidiers: 
<code><a href="#topic+augment.poLCA">augment.poLCA</a>()</code>,
<code><a href="#topic+tidy.poLCA">tidy.poLCA</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(poLCA)
library(dplyr)

# generate data
data(values)

f &lt;- cbind(A, B, C, D) ~ 1

# fit model
M1 &lt;- poLCA(f, values, nclass = 2, verbose = FALSE)

M1

# summarize model fit with tidiers + visualization
tidy(M1)
augment(M1)
glance(M1)

library(ggplot2)

ggplot(tidy(M1), aes(factor(class), estimate, fill = factor(outcome))) +
  geom_bar(stat = "identity", width = 1) +
  facet_wrap(~variable)

# three-class model with a single covariate.
data(election)

f2a &lt;- cbind(
  MORALG, CARESG, KNOWG, LEADG, DISHONG, INTELG,
  MORALB, CARESB, KNOWB, LEADB, DISHONB, INTELB
) ~ PARTY

nes2a &lt;- poLCA(f2a, election, nclass = 3, nrep = 5, verbose = FALSE)

td &lt;- tidy(nes2a)
td

ggplot(td, aes(outcome, estimate, color = factor(class), group = class)) +
  geom_line() +
  facet_wrap(~variable, nrow = 2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

au &lt;- augment(nes2a)

au

count(au, .class)

# if the original data is provided, it leads to NAs in new columns
# for rows that weren't predicted
au2 &lt;- augment(nes2a, data = election)

au2

dim(au2)

</code></pre>

<hr>
<h2 id='glance.polr'>Glance at a(n) polr object</h2><span id='topic+glance.polr'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'polr'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.polr_+3A_x">x</code></td>
<td>
<p>A <code>polr</code> object returned from <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.polr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The effective degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
fit &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)

# summarize model fit with tidiers
tidy(fit, exponentiate = TRUE, conf.int = TRUE)

glance(fit)
augment(fit, type.predict = "class")

fit2 &lt;- polr(factor(gear) ~ am + mpg + qsec, data = mtcars)

tidy(fit, p.values = TRUE)

</code></pre>

<hr>
<h2 id='glance.pyears'>Glance at a(n) pyears object</h2><span id='topic+glance.pyears'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pyears'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.pyears_+3A_x">x</code></td>
<td>
<p>A <code>pyears</code> object returned from <code><a href="survival.html#topic+pyears">survival::pyears()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.pyears_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p>total number of person-years tabulated</p>
</td></tr>
<tr><td><code>offtable</code></td>
<td>
<p>total number of person-years off table</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+pyears">survival::pyears()</a></code>
</p>
<p>Other pyears tidiers: 
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# generate and format data
temp.yr &lt;- tcut(mgus$dxyr, 55:92, labels = as.character(55:91))
temp.age &lt;- tcut(mgus$age, 34:101, labels = as.character(34:100))
ptime &lt;- ifelse(is.na(mgus$pctime), mgus$futime, mgus$pctime)
pstat &lt;- ifelse(is.na(mgus$pctime), 0, 1)
pfit &lt;- pyears(Surv(ptime / 365.25, pstat) ~ temp.yr + temp.age + sex, mgus,
  data.frame = TRUE
)

# summarize model fit with tidiers
tidy(pfit)
glance(pfit)

# if data.frame argument is not given, different information is present in
# output
pfit2 &lt;- pyears(Surv(ptime / 365.25, pstat) ~ temp.yr + temp.age + sex, mgus)

tidy(pfit2)
glance(pfit2)

</code></pre>

<hr>
<h2 id='glance.ridgelm'>Glance at a(n) ridgelm object</h2><span id='topic+glance.ridgelm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ridgelm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.ridgelm_+3A_x">x</code></td>
<td>
<p>A <code>ridgelm</code> object returned from <code><a href="MASS.html#topic+lm.ridge">MASS::lm.ridge()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.ridgelm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to the output of <code>select.ridgelm</code>, but it is
returned rather than printed.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>kHKB</code></td>
<td>
<p>modified HKB estimate of the ridge constant</p>
</td></tr>
<tr><td><code>kLW</code></td>
<td>
<p>modified L-W estimate of the ridge constant</p>
</td></tr>
<tr><td><code>lambdaGCV</code></td>
<td>
<p>choice of lambda that minimizes GCV</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="MASS.html#topic+lm.ridge">MASS::select.ridgelm()</a></code>, <code><a href="MASS.html#topic+lm.ridge">MASS::lm.ridge()</a></code>
</p>
<p>Other ridgelm tidiers: 
<code><a href="#topic+tidy.ridgelm">tidy.ridgelm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

names(longley)[1] &lt;- "y"

# fit model and summarizd results
fit1 &lt;- lm.ridge(y ~ ., longley)
tidy(fit1)

fit2 &lt;- lm.ridge(y ~ ., longley, lambda = seq(0.001, .05, .001))
td2 &lt;- tidy(fit2)
g2 &lt;- glance(fit2)

# coefficient plot
library(ggplot2)
ggplot(td2, aes(lambda, estimate, color = term)) +
  geom_line()

# GCV plot
ggplot(td2, aes(lambda, GCV)) +
  geom_line()

# add line for the GCV minimizing estimate
ggplot(td2, aes(lambda, GCV)) +
  geom_line() +
  geom_vline(xintercept = g2$lambdaGCV, col = "red", lty = 2)

</code></pre>

<hr>
<h2 id='glance.rlm'>Glance at a(n) rlm object</h2><span id='topic+glance.rlm'></span><span id='topic+rlm_tidiers'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.rlm_+3A_x">x</code></td>
<td>
<p>An <code>rlm</code> object returned by <code><a href="MASS.html#topic+rlm">MASS::rlm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.rlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating if the model fitting procedure was succesful and converged.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="MASS.html#topic+rlm">MASS::rlm()</a></code>
</p>
<p>Other rlm tidiers: 
<code><a href="#topic+augment.rlm">augment.rlm</a>()</code>,
<code><a href="#topic+tidy.rlm">tidy.rlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
r &lt;- rlm(stack.loss ~ ., stackloss)

# summarize model fit with tidiers
tidy(r)
augment(r)
glance(r)

</code></pre>

<hr>
<h2 id='glance.rma'>Glance at a(n) rma object</h2><span id='topic+glance.rma'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rma'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.rma_+3A_x">x</code></td>
<td>
<p>An <code>rma</code> object such as those created by <code><a href="metafor.html#topic+rma.uni">metafor::rma()</a></code>,
<code><a href="metafor.html#topic+rma.uni">metafor::rma.uni()</a></code>, <code><a href="metafor.html#topic+rma.glmm">metafor::rma.glmm()</a></code>, <code><a href="metafor.html#topic+rma.mh">metafor::rma.mh()</a></code>,
<code><a href="metafor.html#topic+rma.mv">metafor::rma.mv()</a></code>, or <code><a href="metafor.html#topic+rma.peto">metafor::rma.peto()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.rma_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>cochran.qe</code></td>
<td>
<p>In meta-analysis, test statistic for the Cochran's Q_e test of residual heterogeneity.</p>
</td></tr>
<tr><td><code>cochran.qm</code></td>
<td>
<p>In meta-analysis, test statistic for the Cochran's Q_m omnibus test of coefficients.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>h.squared</code></td>
<td>
<p>Value of the H-Squared statistic.</p>
</td></tr>
<tr><td><code>i.squared</code></td>
<td>
<p>Value of the I-Squared statistic.</p>
</td></tr>
<tr><td><code>measure</code></td>
<td>
<p>The measure used in the meta-analysis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Which method was used.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value.cochran.qe</code></td>
<td>
<p>In meta-analysis, p-value for the Cochran's Q_e test of residual heterogeneity.</p>
</td></tr>
<tr><td><code>p.value.cochran.qm</code></td>
<td>
<p>In meta-analysis, p-value for the Cochran's Q_m omnibus test of coefficients.</p>
</td></tr>
<tr><td><code>tau.squared</code></td>
<td>
<p>In meta-analysis, estimated amount of residual heterogeneity.</p>
</td></tr>
<tr><td><code>tau.squared.se</code></td>
<td>
<p>In meta-analysis, standard error of residual heterogeneity.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

library(metafor)

df &lt;-
  escalc(
    measure = "RR",
    ai = tpos,
    bi = tneg,
    ci = cpos,
    di = cneg,
    data = dat.bcg
  )

meta_analysis &lt;- rma(yi, vi, data = df, method = "EB")

glance(meta_analysis)

</code></pre>

<hr>
<h2 id='glance.rq'>Glance at a(n) rq object</h2><span id='topic+glance.rq'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.rq_+3A_x">x</code></td>
<td>
<p>An <code>rq</code> object returned from <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.rq_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Only models with a single <code>tau</code> value may be passed.
For multiple values, please use a <code><a href="purrr.html#topic+map">purrr::map()</a></code> workflow instead, e.g.
</p>
<div class="sourceCode"><pre>taus %&gt;%
  map(function(tau_val) rq(y ~ x, tau = tau_val)) %&gt;%
  map_dfr(glance)
</pre></div>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Quantile.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library and data
library(quantreg)

data(stackloss)

# median (l1) regression fit for the stackloss data.
mod1 &lt;- rq(stack.loss ~ stack.x, .5)

# weighted sample median
mod2 &lt;- rq(rnorm(50) ~ 1, weights = runif(50))

# summarize model fit with tidiers
tidy(mod1)
glance(mod1)
augment(mod1)

tidy(mod2)
glance(mod2)
augment(mod2)

# varying tau to generate an rqs object
mod3 &lt;- rq(stack.loss ~ stack.x, tau = c(.25, .5))

tidy(mod3)
augment(mod3)

# glance cannot handle rqs objects like `mod3`--use a purrr
# `map`-based workflow instead

</code></pre>

<hr>
<h2 id='glance.sarlm'>Glance at a(n) spatialreg object</h2><span id='topic+glance.sarlm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sarlm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.sarlm_+3A_x">x</code></td>
<td>
<p>An object returned from <code><a href="spatialreg.html#topic+ML_models">spatialreg::lagsarlm()</a></code>
or <code><a href="spatialreg.html#topic+ML_models">spatialreg::errorsarlm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.sarlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="spatialreg.html#topic+ML_models">spatialreg::lagsarlm()</a></code>, <code><a href="spatialreg.html#topic+ML_models">spatialreg::errorsarlm()</a></code>,
<code><a href="spatialreg.html#topic+ML_models">spatialreg::sacsarlm()</a></code>
</p>
<p>Other spatialreg tidiers: 
<code><a href="#topic+augment.sarlm">augment.sarlm</a>()</code>,
<code><a href="#topic+tidy.sarlm">tidy.sarlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# load libraries for models and data
library(spatialreg)
library(spdep)

# load data
data(oldcol, package = "spdep")

listw &lt;- nb2listw(COL.nb, style = "W")

# fit model
crime_sar &lt;-
  lagsarlm(CRIME ~ INC + HOVAL,
    data = COL.OLD,
    listw = listw,
    method = "eigen"
  )

# summarize model fit with tidiers
tidy(crime_sar)
tidy(crime_sar, conf.int = TRUE)
glance(crime_sar)
augment(crime_sar)

# fit another model
crime_sem &lt;- errorsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw)

# summarize model fit with tidiers
tidy(crime_sem)
tidy(crime_sem, conf.int = TRUE)
glance(crime_sem)
augment(crime_sem)

# fit another model
crime_sac &lt;- sacsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw)

# summarize model fit with tidiers
tidy(crime_sac)
tidy(crime_sac, conf.int = TRUE)
glance(crime_sac)
augment(crime_sac)

</code></pre>

<hr>
<h2 id='glance.smooth.spline'>Tidy a(n) smooth.spine object</h2><span id='topic+glance.smooth.spline'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smooth.spline'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.smooth.spline_+3A_x">x</code></td>
<td>
<p>A <code>smooth.spline</code> object returned from <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.smooth.spline_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>crit</code></td>
<td>
<p>Minimized criterion</p>
</td></tr>
<tr><td><code>cv.crit</code></td>
<td>
<p>Cross-validation score</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Choice of lambda corresponding to 'spar'.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>pen.crit</code></td>
<td>
<p>Penalized criterion.</p>
</td></tr>
<tr><td><code>spar</code></td>
<td>
<p>Smoothing parameter.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+augment">augment()</a></code>, <code><a href="stats.html#topic+smooth.spline">stats::smooth.spline()</a></code>
</p>
<p>Other smoothing spline tidiers: 
<code><a href="#topic+augment.smooth.spline">augment.smooth.spline</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit model
spl &lt;- smooth.spline(mtcars$wt, mtcars$mpg, df = 4)

# summarize model fit with tidiers
augment(spl, mtcars)

# calls original columns x and y
augment(spl)

library(ggplot2)
ggplot(augment(spl, mtcars), aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted))

</code></pre>

<hr>
<h2 id='glance.speedglm'>Glance at a(n) speedglm object</h2><span id='topic+glance.speedglm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedglm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.speedglm_+3A_x">x</code></td>
<td>
<p>A <code>speedglm</code> object returned from <code><a href="speedglm.html#topic+speedglm">speedglm::speedglm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.speedglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>
</p>
<p>Other speedlm tidiers: 
<code><a href="#topic+augment.speedlm">augment.speedlm</a>()</code>,
<code><a href="#topic+glance.speedlm">glance.speedlm</a>()</code>,
<code><a href="#topic+tidy.speedglm">tidy.speedglm</a>()</code>,
<code><a href="#topic+tidy.speedlm">tidy.speedlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(speedglm)

# generate data
clotting &lt;- data.frame(
  u = c(5, 10, 15, 20, 30, 40, 60, 80, 100),
  lot1 = c(118, 58, 42, 35, 27, 25, 21, 19, 18)
)

# fit model
fit &lt;- speedglm(lot1 ~ log(u), data = clotting, family = Gamma(log))

# summarize model fit with tidiers
tidy(fit)
glance(fit)

</code></pre>

<hr>
<h2 id='glance.speedlm'>Glance at a(n) speedlm object</h2><span id='topic+glance.speedlm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedlm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.speedlm_+3A_x">x</code></td>
<td>
<p>A <code>speedlm</code> object returned from <code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.speedlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>F-statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>
</p>
<p>Other speedlm tidiers: 
<code><a href="#topic+augment.speedlm">augment.speedlm</a>()</code>,
<code><a href="#topic+glance.speedglm">glance.speedglm</a>()</code>,
<code><a href="#topic+tidy.speedglm">tidy.speedglm</a>()</code>,
<code><a href="#topic+tidy.speedlm">tidy.speedlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(speedglm)

# fit model
mod &lt;- speedlm(mpg ~ wt + qsec, data = mtcars, fitted = TRUE)

# summarize model fit with tidiers
tidy(mod)
glance(mod)
augment(mod)

</code></pre>

<hr>
<h2 id='glance.summary.lm'>Glance at a(n) summary.lm object</h2><span id='topic+glance.summary.lm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lm'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.summary.lm_+3A_x">x</code></td>
<td>
<p>An <code>lm</code> object created by <code><a href="stats.html#topic+lm">stats::lm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.summary.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>glance.summary.lm()</code> method is a potentially useful alternative
to <code><a href="#topic+glance.lm">glance.lm()</a></code>. For instance, if users have already converted large <code>lm</code>
objects into their leaner <code>summary.lm</code> equivalents to conserve memory. Note,
however, that this method does not return all of the columns of the
non-summary method (e.g. AIC and BIC will be missing.)
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic, which is like the R squared statistic except taking degrees of freedom into account.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model. Also known as the coefficient of determination.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Estimated standard error of the residuals.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees for freedom from the numerator of the overall
F-statistic. This is new in broom 0.7.0. Previously, this reported
the rank of the design matrix, which is one more than the numerator
degrees of freedom of the overall F-statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="#topic+glance.summary.lm">glance.summary.lm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(dplyr)

mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)

tidy(mod)
glance(mod)

# coefficient plot
d &lt;- tidy(mod, conf.int = TRUE)

ggplot(d, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point() +
  geom_vline(xintercept = 0, lty = 4) +
  geom_errorbarh()

# aside: There are tidy() and glance() methods for lm.summary objects too.
# this can be useful when you want to conserve memory by converting large lm
# objects into their leaner summary.lm equivalents.
s &lt;- summary(mod)
tidy(s, conf.int = TRUE)
glance(s)

augment(mod)
augment(mod, mtcars, interval = "confidence")

# predict on new data
newdata &lt;- mtcars %&gt;%
  head(6) %&gt;%
  mutate(wt = wt + 1)
augment(mod, newdata = newdata)

# ggplot2 example where we also construct 95% prediction interval

# simpler bivariate model since we're plotting in 2D
mod2 &lt;- lm(mpg ~ wt, data = mtcars)

au &lt;- augment(mod2, newdata = newdata, interval = "prediction")

ggplot(au, aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper), col = NA, alpha = 0.3)

# predict on new data without outcome variable. Output does not include .resid
newdata &lt;- newdata %&gt;%
  select(-mpg)

augment(mod, newdata = newdata)

au &lt;- augment(mod, data = mtcars)

ggplot(au, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() +
  geom_smooth(se = FALSE)

plot(mod, which = 6)

ggplot(au, aes(.hat, .cooksd)) +
  geom_vline(xintercept = 0, colour = NA) +
  geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
  geom_smooth(se = FALSE) +
  geom_point()

# column-wise models
a &lt;- matrix(rnorm(20), nrow = 10)
b &lt;- a + rnorm(length(a))
result &lt;- lm(b ~ a)

tidy(result)

</code></pre>

<hr>
<h2 id='glance.survdiff'>Glance at a(n) survdiff object</h2><span id='topic+glance.survdiff'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survdiff'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.survdiff_+3A_x">x</code></td>
<td>
<p>An <code>survdiff</code> object returned from <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.survdiff_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>
</p>
<p>Other survdiff tidiers: 
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
s &lt;- survdiff(
  Surv(time, status) ~ pat.karno + strata(inst),
  data = lung
)

# summarize model fit with tidiers
tidy(s)
glance(s)

</code></pre>

<hr>
<h2 id='glance.survexp'>Glance at a(n) survexp object</h2><span id='topic+glance.survexp'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survexp'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.survexp_+3A_x">x</code></td>
<td>
<p>An <code>survexp</code> object returned from <code><a href="survival.html#topic+survexp">survival::survexp()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.survexp_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>n.max</code></td>
<td>
<p>Maximum number of subjects at risk.</p>
</td></tr>
<tr><td><code>n.start</code></td>
<td>
<p>Initial number of subjects at risk.</p>
</td></tr>
<tr><td><code>timepoints</code></td>
<td>
<p>Number of timepoints.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+survexp">survival::survexp()</a></code>
</p>
<p>Other survexp tidiers: 
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
sexpfit &lt;- survexp(
  futime ~ 1,
  rmap = list(
    sex = "male",
    year = accept.dt,
    age = (accept.dt - birth.dt)
  ),
  method = "conditional",
  data = jasa
)

# summarize model fit with tidiers
tidy(sexpfit)
glance(sexpfit)

</code></pre>

<hr>
<h2 id='glance.survfit'>Glance at a(n) survfit object</h2><span id='topic+glance.survfit'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.survfit_+3A_x">x</code></td>
<td>
<p>An <code>survfit</code> object returned from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.survfit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="survival.html#topic+summary.survfit">summary.survfit()</a></code>. Important
arguments include <code>rmean</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>events</code></td>
<td>
<p>Number of events.</p>
</td></tr>
<tr><td><code>n.max</code></td>
<td>
<p>Maximum number of subjects at risk.</p>
</td></tr>
<tr><td><code>n.start</code></td>
<td>
<p>Initial number of subjects at risk.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>records</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>rmean</code></td>
<td>
<p>Restricted mean (see [survival::print.survfit()]).</p>
</td></tr>
<tr><td><code>rmean.std.error</code></td>
<td>
<p>Restricted mean standard error.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>lower end of confidence interval on median</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>upper end of confidence interval on median</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>median survival</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>
</p>
<p>Other cch tidiers: 
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
cfit &lt;- coxph(Surv(time, status) ~ age + sex, lung)
sfit &lt;- survfit(cfit)

# summarize model fit with tidiers + visualization
tidy(sfit)
glance(sfit)

library(ggplot2)

ggplot(tidy(sfit), aes(time, estimate)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25)

# multi-state
fitCI &lt;- survfit(Surv(stop, status * as.numeric(event), type = "mstate") ~ 1,
  data = mgus1, subset = (start == 0)
)

td_multi &lt;- tidy(fitCI)

td_multi

ggplot(td_multi, aes(time, estimate, group = state)) +
  geom_line(aes(color = state)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25)

</code></pre>

<hr>
<h2 id='glance.survreg'>Glance at a(n) survreg object</h2><span id='topic+glance.survreg'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survreg'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.survreg_+3A_x">x</code></td>
<td>
<p>An <code>survreg</code> object returned from <code><a href="survival.html#topic+survreg">survival::survreg()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.survreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by the model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Iterations of algorithm/fitting procedure completed.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value corresponding to the test statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Chi-squared statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="survival.html#topic+survreg">survival::survreg()</a></code>
</p>
<p>Other survreg tidiers: 
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
sr &lt;- survreg(
  Surv(futime, fustat) ~ ecog.ps + rx,
  ovarian,
  dist = "exponential"
)

# summarize model fit with tidiers + visualization
tidy(sr)
augment(sr, ovarian)
glance(sr)

# coefficient plot
td &lt;- tidy(sr, conf.int = TRUE)

library(ggplot2)

ggplot(td, aes(estimate, term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0) +
  geom_vline(xintercept = 0)

</code></pre>

<hr>
<h2 id='glance.svyglm'>Glance at a(n) svyglm object</h2><span id='topic+glance.svyglm'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyglm'
glance(x, maximal = x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.svyglm_+3A_x">x</code></td>
<td>
<p>A <code>svyglm</code> object returned from <code><a href="survey.html#topic+svyglm">survey::svyglm()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.svyglm_+3A_maximal">maximal</code></td>
<td>
<p>A <code>svyglm</code> object corresponding to the maximal
model against which to compute the BIC. See Lumley and Scott
(2015) for details. Defaults to <code>x</code>, which is equivalent
to not using a maximal model.</p>
</td></tr>
<tr><td><code id="glance.svyglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike's Information Criterion for the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criterion for the model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance of the model.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>Degrees of freedom used by the null model.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Deviance of the null model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lumley T, Scott A (2015). AIC and BIC for modelling with complex
survey data. <em>Journal of Survey Statistics and Methodology</em>, 3(1).
</p>


<h3>See Also</h3>

<p><code><a href="survey.html#topic+svyglm">survey::svyglm()</a></code>, <code><a href="stats.html#topic+glm">stats::glm()</a></code>, <a href="survey.html#topic+anova.svyglm">survey::anova.svyglm</a>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survey)

set.seed(123)
data(api)

# survey design
dstrat &lt;-
  svydesign(
    id = ~1,
    strata = ~stype,
    weights = ~pw,
    data = apistrat,
    fpc = ~fpc
  )

# model
m &lt;- svyglm(
  formula = sch.wide ~ ell + meals + mobility,
  design = dstrat,
  family = quasibinomial()
)

glance(m)

</code></pre>

<hr>
<h2 id='glance.svyolr'>Glance at a(n) svyolr object</h2><span id='topic+glance.svyolr'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyolr'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.svyolr_+3A_x">x</code></td>
<td>
<p>A <code>svyolr</code> object returned from <code><a href="survey.html#topic+svyolr">survey::svyolr()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.svyolr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The effective degrees of freedom.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="survey.html#topic+svyolr">survey::svyolr()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(broom)
library(survey)

data(api)
dclus1 &lt;- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc)
dclus1 &lt;- update(dclus1, mealcat = cut(meals, c(0, 25, 50, 75, 100)))

m &lt;- svyolr(mealcat ~ avg.ed + mobility + stype, design = dclus1)

m

tidy(m, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='glance.varest'>Glance at a(n) varest object</h2><span id='topic+glance.varest'></span>

<h3>Description</h3>

<p>Glance accepts a model object and returns a <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code>
with exactly one row of model summaries. The summaries are typically
goodness of fit measures, p-values for hypothesis tests on residuals,
or model convergence information.
</p>
<p>Glance never returns information from the original call to the modeling
function. This includes the name of the modeling function or any
arguments passed to the modeling function.
</p>
<p>Glance does not calculate summary measures. Rather, it farms out these
computations to appropriate methods and gathers the results together.
Sometimes a goodness of fit measure will be undefined. In these cases
the measure will be reported as <code>NA</code>.
</p>
<p>Glance returns the same number of columns regardless of whether the
model matrix is rank-deficient or not. If so, entries in columns
that no longer have a well-defined value are filled in with an <code>NA</code>
of the appropriate type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glance.varest_+3A_x">x</code></td>
<td>
<p>A <code>varest</code> object produced by a call to <code><a href="vars.html#topic+VAR">vars::VAR()</a></code>.</p>
</td></tr>
<tr><td><code id="glance.varest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with exactly one row and columns:
</p>
<table>
<tr><td><code>lag.order</code></td>
<td>
<p>Lag order.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The log-likelihood of the model. [stats::logLik()] may be a useful reference.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The total number of observations.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glance">glance()</a></code>, <code><a href="vars.html#topic+VAR">vars::VAR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(vars)

# load data
data("Canada", package = "vars")

# fit models
mod &lt;- VAR(Canada, p = 1, type = "both")

# summarize model fit with tidiers
tidy(mod)
glance(mod)

</code></pre>

<hr>
<h2 id='leveneTest_tidiers'>Tidy/glance a(n) leveneTest object</h2><span id='topic+leveneTest_tidiers'></span><span id='topic+tidy.leveneTest'></span>

<h3>Description</h3>

<p>For models that have only a single component, the <code><a href="#topic+tidy">tidy()</a></code> and
<code><a href="#topic+glance">glance()</a></code> methods are identical. Please see the documentation for both
of those methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'leveneTest'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leveneTest_tidiers_+3A_x">x</code></td>
<td>
<p>An object of class <code>anova</code> created by a call to
<code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code>.</p>
</td></tr>
<tr><td><code id="leveneTest_tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>Residual degrees of freedom.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="#topic+glance">glance()</a></code>, <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code>
</p>
<p>Other car tidiers: 
<code><a href="#topic+durbinWatsonTest_tidiers">durbinWatsonTest_tidiers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(car)

data(Moore)

lt &lt;- with(Moore, leveneTest(conformity, fcategory))

tidy(lt)
glance(lt)

</code></pre>

<hr>
<h2 id='list_tidiers'>Tidying methods for lists / returned values that are not S3 objects</h2><span id='topic+list_tidiers'></span><span id='topic+tidy.list'></span><span id='topic+glance.list'></span>

<h3>Description</h3>

<p>Broom tidies a number of lists that are effectively S3 objects without
a class attribute. For example, <code><a href="stats.html#topic+optim">stats::optim()</a></code>, <code><a href="base.html#topic+svd">base::svd()</a></code> and
<code><a href="interp.html#topic+interp">interp::interp()</a></code> produce consistent output, but because they do not
have a class attribute, they cannot be handled by S3 dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
tidy(x, ...)

## S3 method for class 'list'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_tidiers_+3A_x">x</code></td>
<td>
<p>A list, potentially representing an object that can be tidied.</p>
</td></tr>
<tr><td><code id="list_tidiers_+3A_...">...</code></td>
<td>
<p>Additionally, arguments passed to the tidying function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions look at the elements of a list and determine if there is
an appropriate tidying method to apply to the list. Those tidiers are
themselves are implemented as functions of the form <code style="white-space: pre;">&#8288;tidy_&lt;function&gt;&#8288;</code>
or <code style="white-space: pre;">&#8288;glance_&lt;function&gt;&#8288;</code> and are not exported (but they are documented!).
</p>
<p>If no appropriate tidying method is found, throws an error.
</p>


<h3>See Also</h3>

<p>Other list tidiers: 
<code><a href="#topic+glance_optim">glance_optim</a>()</code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_optim">tidy_optim</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>,
<code><a href="#topic+tidy_xyz">tidy_xyz</a>()</code>
</p>

<hr>
<h2 id='null_tidiers'>Tidiers for NULL inputs</h2><span id='topic+null_tidiers'></span><span id='topic+tidy.NULL'></span><span id='topic+glance.NULL'></span><span id='topic+augment.NULL'></span>

<h3>Description</h3>

<p><code>tidy(NULL)</code>, <code>glance(NULL)</code> and <code>augment(NULL)</code> all return an empty
<a href="tibble.html#topic+tibble">tibble::tibble</a>. This empty tibble can be treated a tibble with zero
rows, making it convenient to combine with other tibbles using
functions like <code><a href="purrr.html#topic+map_dfr">purrr::map_df()</a></code> on lists of potentially <code>NULL</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''NULL''
tidy(x, ...)

## S3 method for class ''NULL''
glance(x, ...)

## S3 method for class ''NULL''
augment(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_tidiers_+3A_x">x</code></td>
<td>
<p>The value <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="null_tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty <a href="tibble.html#topic+tibble">tibble::tibble</a>.
</p>


<h3>See Also</h3>

<p><a href="tibble.html#topic+tibble">tibble::tibble</a>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+augment'></span><span id='topic+tidy'></span><span id='topic+glance'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+glance">glance</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+augment.lm">augment.lm()</a></code>
</p>
<p><code><a href="#topic+tidy.lm">tidy.lm()</a></code>
</p>
<p><code><a href="#topic+glance.lm">glance.lm()</a></code>
</p>

<hr>
<h2 id='sp_tidiers'>Tidy a(n) SpatialPolygonsDataFrame object</h2><span id='topic+sp_tidiers'></span><span id='topic+tidy.SpatialPolygonsDataFrame'></span><span id='topic+tidy.SpatialPolygons'></span><span id='topic+tidy.Polygons'></span><span id='topic+tidy.Polygon'></span><span id='topic+tidy.SpatialLinesDataFrame'></span><span id='topic+tidy.Lines'></span><span id='topic+tidy.Line'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>
<p>Note that the <code>sf</code> package now defines tidy spatial objects
and is the recommended approach to spatial data. <code>sp</code> tidiers are now
deprecated in favor of <code>sf::st_as_sf()</code> and coercion methods found in
other packages. See
<a href="https://r-spatial.org/r/2023/05/15/evolution4.html">https://r-spatial.org/r/2023/05/15/evolution4.html</a> for more on
migration from retiring spatial packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
tidy(x, region = NULL, ...)

## S3 method for class 'SpatialPolygons'
tidy(x, ...)

## S3 method for class 'Polygons'
tidy(x, ...)

## S3 method for class 'Polygon'
tidy(x, ...)

## S3 method for class 'SpatialLinesDataFrame'
tidy(x, ...)

## S3 method for class 'Lines'
tidy(x, ...)

## S3 method for class 'Line'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_tidiers_+3A_x">x</code></td>
<td>
<p>A <code>SpatialPolygonsDataFrame</code>, <code>SpatialPolygons</code>, <code>Polygons</code>,
<code>Polygon</code>, <code>SpatialLinesDataFrame</code>, <code>Lines</code> or <code>Line</code> object.</p>
</td></tr>
<tr><td><code id="sp_tidiers_+3A_region">region</code></td>
<td>
<p>name of variable used to split up regions</p>
</td></tr>
<tr><td><code id="sp_tidiers_+3A_...">...</code></td>
<td>
<p>not used by this method</p>
</td></tr>
</table>

<hr>
<h2 id='summary_tidiers'>(Deprecated) Tidy summaryDefault objects</h2><span id='topic+summary_tidiers'></span><span id='topic+tidy.summaryDefault'></span><span id='topic+glance.summaryDefault'></span>

<h3>Description</h3>

<p>Tidiers for summaryDefault objects have been deprecated as of
broom 0.7.0 in favor of <code>skimr::skim()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summaryDefault'
tidy(x, ...)

## S3 method for class 'summaryDefault'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_tidiers_+3A_x">x</code></td>
<td>
<p>A <code>summaryDefault</code> object, created by calling <code><a href="base.html#topic+summary">summary()</a></code> on a
vector.</p>
</td></tr>
<tr><td><code id="summary_tidiers_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-row <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns:
</p>
<table>
<tr><td><code>minimum</code></td>
<td>
<p>Minimum value in original vector.</p>
</td></tr>
<tr><td><code>q1</code></td>
<td>
<p>First quartile of original vector.</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>Median of original vector.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean of original vector.</p>
</td></tr>
<tr><td><code>q3</code></td>
<td>
<p>Third quartile of original vector.</p>
</td></tr>
<tr><td><code>maximum</code></td>
<td>
<p>Maximum value in original vector.</p>
</td></tr>
<tr><td><code>na</code></td>
<td>
<p>Number of <code>NA</code> values in original vector. Column present only
when original vector had at least one <code>NA</code> entry.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>
<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v &lt;- rnorm(1000)
s &lt;- summary(v)
s

tidy(s)
glance(s)

v2 &lt;- c(v,NA)
tidy(summary(v2))

</code></pre>

<hr>
<h2 id='tidy_irlba'>Tidy a(n) irlba object masquerading as list</h2><span id='topic+tidy_irlba'></span><span id='topic+tidy.irlba'></span><span id='topic+irlba_tidiers'></span>

<h3>Description</h3>

<p>Broom tidies a number of lists that are effectively S3
objects without a class attribute. For example, <code><a href="stats.html#topic+optim">stats::optim()</a></code>,
<a href="base.html#topic+svd">svd()</a> and <code><a href="interp.html#topic+interp">interp::interp()</a></code> produce consistent output, but
because they do not have a class attribute, they cannot be handled by S3
dispatch.
</p>
<p>These functions look at the elements of a list and determine if there is
an appropriate tidying method to apply to the list. Those tidiers are
implemented as functions of the form <code style="white-space: pre;">&#8288;tidy_&lt;function&gt;&#8288;</code> or
<code style="white-space: pre;">&#8288;glance_&lt;function&gt;&#8288;</code> and are not exported (but they are documented!).
</p>
<p>If no appropriate tidying method is found, they throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_irlba(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_irlba_+3A_x">x</code></td>
<td>
<p>A list returned from <code><a href="irlba.html#topic+irlba">irlba::irlba()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_irlba_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>A very thin wrapper around <code><a href="#topic+tidy_svd">tidy_svd()</a></code>.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns depending on the component of
PCA being tidied.
</p>
<p>If <code>matrix</code> is <code>"u"</code>, <code>"samples"</code>, <code>"scores"</code>, or <code>"x"</code> each row in the
tidied output corresponds to the original data in PCA space. The columns
are:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>ID of the original observation (i.e. rowname from original
data).</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>Integer indicating a principal component.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The score of the observation for that particular principal
component. That is, the location of the observation in PCA space.</p>
</td></tr>
</table>
<p>If <code>matrix</code> is <code>"v"</code>, <code>"rotation"</code>, <code>"loadings"</code> or <code>"variables"</code>, each
row in the tidied output corresponds to information about the principle
components in the original space. The columns are:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>The variable labels (colnames) of the data set on
which PCA was performed.</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>An integer vector indicating the principal component.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the eigenvector (axis score) on the
indicated principal component.</p>
</td></tr>
</table>
<p>If <code>matrix</code> is <code>"d"</code>, <code>"eigenvalues"</code> or <code>"pcs"</code>, the columns are:
</p>
<table>
<tr><td><code>PC</code></td>
<td>
<p>An integer vector indicating the principal component.</p>
</td></tr>
<tr><td><code>std.dev</code></td>
<td>
<p>Standard deviation explained by this PC.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>Fraction of variation explained by this component
(a numeric value between 0 and 1).</p>
</td></tr>
<tr><td><code>cumulative</code></td>
<td>
<p>Cumulative fraction of variation explained by
principle components up to this component (a numeric value between 0 and
1).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="irlba.html#topic+irlba">irlba::irlba()</a></code>
</p>
<p>Other list tidiers: 
<code><a href="#topic+glance_optim">glance_optim</a>()</code>,
<code><a href="#topic+list_tidiers">list_tidiers</a></code>,
<code><a href="#topic+tidy_optim">tidy_optim</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>,
<code><a href="#topic+tidy_xyz">tidy_xyz</a>()</code>
</p>
<p>Other svd tidiers: 
<code><a href="#topic+augment.prcomp">augment.prcomp</a>()</code>,
<code><a href="#topic+tidy.prcomp">tidy.prcomp</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(modeldata)
data(hpc_data)

mat &lt;- scale(as.matrix(hpc_data[, 2:5]))
s &lt;- svd(mat)

tidy_u &lt;- tidy(s, matrix = "u")
tidy_u

tidy_d &lt;- tidy(s, matrix = "d")
tidy_d

tidy_v &lt;- tidy(s, matrix = "v")
tidy_v

library(ggplot2)
library(dplyr)

ggplot(tidy_d, aes(PC, percent)) +
  geom_point() +
  ylab("% of variance explained")

tidy_u %&gt;%
  mutate(class = hpc_data$class[row]) %&gt;%
  ggplot(aes(class, value)) +
  geom_boxplot() +
  facet_wrap(~PC, scale = "free_y")

</code></pre>

<hr>
<h2 id='tidy_optim'>Tidy a(n) optim object masquerading as list</h2><span id='topic+tidy_optim'></span><span id='topic+optim_tidiers'></span><span id='topic+tidy.optim'></span>

<h3>Description</h3>

<p>Broom tidies a number of lists that are effectively S3
objects without a class attribute. For example, <code><a href="stats.html#topic+optim">stats::optim()</a></code>,
<a href="base.html#topic+svd">svd()</a> and <code><a href="interp.html#topic+interp">interp::interp()</a></code> produce consistent output, but
because they do not have a class attribute, they cannot be handled by S3
dispatch.
</p>
<p>These functions look at the elements of a list and determine if there is
an appropriate tidying method to apply to the list. Those tidiers are
implemented as functions of the form <code style="white-space: pre;">&#8288;tidy_&lt;function&gt;&#8288;</code> or
<code style="white-space: pre;">&#8288;glance_&lt;function&gt;&#8288;</code> and are not exported (but they are documented!).
</p>
<p>If no appropriate tidying method is found, they throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_optim(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_optim_+3A_x">x</code></td>
<td>
<p>A list returned from <code><a href="stats.html#topic+optim">stats::optim()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_optim_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>parameter</code></td>
<td>
<p>The parameter being modeled.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value/estimate of the component. Results from data reshaping.</p>
</td></tr>
</table>
<p><code>std.error</code> is only provided as a column if the Hessian is calculated.
</p>


<h3>Note</h3>

<p>This function assumes that the provided objective function is a negative
log-likelihood function. Results will be invalid if an incorrect
function is supplied.
</p>
<p>tidy(o)
glance(o)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+optim">stats::optim()</a></code>
</p>
<p>Other list tidiers: 
<code><a href="#topic+glance_optim">glance_optim</a>()</code>,
<code><a href="#topic+list_tidiers">list_tidiers</a></code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>,
<code><a href="#topic+tidy_xyz">tidy_xyz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(x) (x[1] - 2)^2 + (x[2] - 3)^2 + (x[3] - 8)^2
o &lt;- optim(c(1, 1, 1), f)

</code></pre>

<hr>
<h2 id='tidy_svd'>Tidy a(n) svd object masquerading as list</h2><span id='topic+tidy_svd'></span><span id='topic+svd_tidiers'></span>

<h3>Description</h3>

<p>Broom tidies a number of lists that are effectively S3
objects without a class attribute. For example, <code><a href="stats.html#topic+optim">stats::optim()</a></code>,
<a href="base.html#topic+svd">svd()</a> and <code><a href="interp.html#topic+interp">interp::interp()</a></code> produce consistent output, but
because they do not have a class attribute, they cannot be handled by S3
dispatch.
</p>
<p>These functions look at the elements of a list and determine if there is
an appropriate tidying method to apply to the list. Those tidiers are
implemented as functions of the form <code style="white-space: pre;">&#8288;tidy_&lt;function&gt;&#8288;</code> or
<code style="white-space: pre;">&#8288;glance_&lt;function&gt;&#8288;</code> and are not exported (but they are documented!).
</p>
<p>If no appropriate tidying method is found, they throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_svd(x, matrix = "u", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_svd_+3A_x">x</code></td>
<td>
<p>A list with components <code>u</code>, <code>d</code>, <code>v</code> returned by <code><a href="base.html#topic+svd">base::svd()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy_svd_+3A_matrix">matrix</code></td>
<td>
<p>Character specifying which component of the PCA should be
tidied.
</p>

<ul>
<li> <p><code>"u"</code>, <code>"samples"</code>, <code>"scores"</code>, or <code>"x"</code>: returns information about
the map from the original space into principle components space.
</p>
</li>
<li> <p><code>"v"</code>, <code>"rotation"</code>, <code>"loadings"</code> or <code>"variables"</code>: returns information
about the map from principle components space back into the original
space.
</p>
</li>
<li> <p><code>"d"</code>, <code>"eigenvalues"</code> or <code>"pcs"</code>: returns information about the
eigenvalues.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tidy_svd_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca
for information on how to interpret the various tidied matrices. Note
that SVD is only equivalent to PCA on centered data.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns depending on the component of
PCA being tidied.
</p>
<p>If <code>matrix</code> is <code>"u"</code>, <code>"samples"</code>, <code>"scores"</code>, or <code>"x"</code> each row in the
tidied output corresponds to the original data in PCA space. The columns
are:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>ID of the original observation (i.e. rowname from original
data).</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>Integer indicating a principal component.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The score of the observation for that particular principal
component. That is, the location of the observation in PCA space.</p>
</td></tr>
</table>
<p>If <code>matrix</code> is <code>"v"</code>, <code>"rotation"</code>, <code>"loadings"</code> or <code>"variables"</code>, each
row in the tidied output corresponds to information about the principle
components in the original space. The columns are:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>The variable labels (colnames) of the data set on
which PCA was performed.</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>An integer vector indicating the principal component.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the eigenvector (axis score) on the
indicated principal component.</p>
</td></tr>
</table>
<p>If <code>matrix</code> is <code>"d"</code>, <code>"eigenvalues"</code> or <code>"pcs"</code>, the columns are:
</p>
<table>
<tr><td><code>PC</code></td>
<td>
<p>An integer vector indicating the principal component.</p>
</td></tr>
<tr><td><code>std.dev</code></td>
<td>
<p>Standard deviation explained by this PC.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>Fraction of variation explained by this component
(a numeric value between 0 and 1).</p>
</td></tr>
<tr><td><code>cumulative</code></td>
<td>
<p>Cumulative fraction of variation explained by
principle components up to this component (a numeric value between 0 and
1).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">base::svd()</a></code>
</p>
<p>Other svd tidiers: 
<code><a href="#topic+augment.prcomp">augment.prcomp</a>()</code>,
<code><a href="#topic+tidy.prcomp">tidy.prcomp</a>()</code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>
</p>
<p>Other list tidiers: 
<code><a href="#topic+glance_optim">glance_optim</a>()</code>,
<code><a href="#topic+list_tidiers">list_tidiers</a></code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_optim">tidy_optim</a>()</code>,
<code><a href="#topic+tidy_xyz">tidy_xyz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(modeldata)
data(hpc_data)

mat &lt;- scale(as.matrix(hpc_data[, 2:5]))
s &lt;- svd(mat)

tidy_u &lt;- tidy(s, matrix = "u")
tidy_u

tidy_d &lt;- tidy(s, matrix = "d")
tidy_d

tidy_v &lt;- tidy(s, matrix = "v")
tidy_v

library(ggplot2)
library(dplyr)

ggplot(tidy_d, aes(PC, percent)) +
  geom_point() +
  ylab("% of variance explained")

tidy_u %&gt;%
  mutate(class = hpc_data$class[row]) %&gt;%
  ggplot(aes(class, value)) +
  geom_boxplot() +
  facet_wrap(~PC, scale = "free_y")

</code></pre>

<hr>
<h2 id='tidy_xyz'>Tidy a(n) xyz object masquerading as list</h2><span id='topic+tidy_xyz'></span><span id='topic+xyz_tidiers'></span>

<h3>Description</h3>

<p>Broom tidies a number of lists that are effectively S3
objects without a class attribute. For example, <code><a href="stats.html#topic+optim">stats::optim()</a></code>,
<a href="base.html#topic+svd">svd()</a> and <code><a href="interp.html#topic+interp">interp::interp()</a></code> produce consistent output, but
because they do not have a class attribute, they cannot be handled by S3
dispatch.
</p>
<p>These functions look at the elements of a list and determine if there is
an appropriate tidying method to apply to the list. Those tidiers are
implemented as functions of the form <code style="white-space: pre;">&#8288;tidy_&lt;function&gt;&#8288;</code> or
<code style="white-space: pre;">&#8288;glance_&lt;function&gt;&#8288;</code> and are not exported (but they are documented!).
</p>
<p>If no appropriate tidying method is found, they throw an error.
</p>
<p>xyz lists (lists where <code>x</code> and <code>y</code> are vectors of coordinates
and <code>z</code> is a matrix of values) are typically used by functions such as
<code><a href="graphics.html#topic+persp">graphics::persp()</a></code> or <code><a href="graphics.html#topic+image">graphics::image()</a></code> and returned
by interpolation functions such as <code><a href="interp.html#topic+interp">interp::interp()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_xyz(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_xyz_+3A_x">x</code></td>
<td>
<p>A list with component <code>x</code>, <code>y</code> and <code>z</code>, where <code>x</code> and <code>y</code> are
vectors and <code>z</code> is a matrix. The length of <code>x</code> must equal the number of
rows in <code>z</code> and the length of <code>y</code> must equal the number of columns in <code>z</code>.</p>
</td></tr>
<tr><td><code id="tidy_xyz_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with vector columns <code>x</code>, <code>y</code> and <code>z</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="graphics.html#topic+persp">graphics::persp()</a></code>, <code><a href="graphics.html#topic+image">graphics::image()</a></code>,
<code><a href="interp.html#topic+interp">interp::interp()</a></code>
</p>
<p>Other list tidiers: 
<code><a href="#topic+glance_optim">glance_optim</a>()</code>,
<code><a href="#topic+list_tidiers">list_tidiers</a></code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_optim">tidy_optim</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- list(x = 1:5, y = 1:3, z = matrix(runif(5 * 3), nrow = 5))
image(A)
tidy(A)
</code></pre>

<hr>
<h2 id='tidy.aareg'>Tidy a(n) aareg object</h2><span id='topic+tidy.aareg'></span><span id='topic+aareg_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aareg'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.aareg_+3A_x">x</code></td>
<td>
<p>An <code>aareg</code> object returned from <code><a href="survival.html#topic+aareg">survival::aareg()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.aareg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>robust.se</code> is only present when <code>x</code> was created with
<code>dfbeta = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>robust.se</code></td>
<td>
<p>robust version of standard error estimate.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>z score.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+aareg">survival::aareg()</a></code>
</p>
<p>Other aareg tidiers: 
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
afit &lt;- aareg(
  Surv(time, status) ~ age + sex + ph.ecog,
  data = lung,
  dfbeta = TRUE
)

# summarize model fit with tidiers
tidy(afit)

</code></pre>

<hr>
<h2 id='tidy.acf'>Tidy a(n) acf object</h2><span id='topic+tidy.acf'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'acf'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.acf_+3A_x">x</code></td>
<td>
<p>An <code>acf</code> object created by <code><a href="stats.html#topic+acf">stats::acf()</a></code>, <code><a href="stats.html#topic+acf">stats::pacf()</a></code> or
<code><a href="stats.html#topic+acf">stats::ccf()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.acf_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>acf</code></td>
<td>
<p>Autocorrelation.</p>
</td></tr>
<tr><td><code>lag</code></td>
<td>
<p>Lag values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+acf">stats::acf()</a></code>, <code><a href="stats.html#topic+acf">stats::pacf()</a></code>, <code><a href="stats.html#topic+acf">stats::ccf()</a></code>
</p>
<p>Other time series tidiers: 
<code><a href="#topic+tidy.spec">tidy.spec</a>()</code>,
<code><a href="#topic+tidy.ts">tidy.ts</a>()</code>,
<code><a href="#topic+tidy.zoo">tidy.zoo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tidy(acf(lh, plot = FALSE))
tidy(ccf(mdeaths, fdeaths, plot = FALSE))
tidy(pacf(lh, plot = FALSE))
</code></pre>

<hr>
<h2 id='tidy.anova'>Tidy a(n) anova object</h2><span id='topic+tidy.anova'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.anova_+3A_x">x</code></td>
<td>
<p>An <code>anova</code> object, such as those created by <code><a href="stats.html#topic+anova">stats::anova()</a></code>,
<code><a href="car.html#topic+Anova">car::Anova()</a></code>, <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code>, or <code><a href="car.html#topic+linearHypothesis">car::linearHypothesis()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.anova_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>term</code> column of an ANOVA table can come with leading or
trailing whitespace, which this tidying method trims.
</p>
<p>For documentation on the tidier for <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code> output, see
<code><a href="#topic+tidy.leveneTest">tidy.leveneTest()</a></code>
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>meansq</code></td>
<td>
<p>Mean sum of squares. Equal to total sum of squares divided by degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>sumsq</code></td>
<td>
<p>Sum of squares explained by this term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+anova">stats::anova()</a></code>, <code><a href="car.html#topic+Anova">car::Anova()</a></code>, <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.anova">glance.anova</a>()</code>,
<code><a href="#topic+glance.aov">glance.aov</a>()</code>,
<code><a href="#topic+tidy.TukeyHSD">tidy.TukeyHSD</a>()</code>,
<code><a href="#topic+tidy.aovlist">tidy.aovlist</a>()</code>,
<code><a href="#topic+tidy.aov">tidy.aov</a>()</code>,
<code><a href="#topic+tidy.manova">tidy.manova</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit models
a &lt;- lm(mpg ~ wt + qsec + disp, mtcars)
b &lt;- lm(mpg ~ wt + qsec, mtcars)

mod &lt;- anova(a, b)

# summarize model fit with tidiers
tidy(mod)
glance(mod)

# car::linearHypothesis() example
library(car)
mod_lht &lt;- linearHypothesis(a, "wt - disp")
tidy(mod_lht)
glance(mod_lht)

</code></pre>

<hr>
<h2 id='tidy.aov'>Tidy a(n) aov object</h2><span id='topic+tidy.aov'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aov'
tidy(x, intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.aov_+3A_x">x</code></td>
<td>
<p>An <code>aov</code> object, such as those created by <code><a href="stats.html#topic+aov">stats::aov()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.aov_+3A_intercept">intercept</code></td>
<td>
<p>A logical indicating whether information on the intercept
ought to be included. Passed to <code><a href="stats.html#topic+summary.aov">stats::summary.aov()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.aov_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>term</code> column of an ANOVA table can come with leading or
trailing whitespace, which this tidying method trims.
</p>
<p>For documentation on the tidier for <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code> output, see
<code><a href="#topic+tidy.leveneTest">tidy.leveneTest()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+aov">stats::aov()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.anova">glance.anova</a>()</code>,
<code><a href="#topic+glance.aov">glance.aov</a>()</code>,
<code><a href="#topic+tidy.TukeyHSD">tidy.TukeyHSD</a>()</code>,
<code><a href="#topic+tidy.anova">tidy.anova</a>()</code>,
<code><a href="#topic+tidy.aovlist">tidy.aovlist</a>()</code>,
<code><a href="#topic+tidy.manova">tidy.manova</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- aov(mpg ~ wt + qsec + disp, mtcars)
tidy(a)
</code></pre>

<hr>
<h2 id='tidy.aovlist'>Tidy a(n) aovlist object</h2><span id='topic+tidy.aovlist'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aovlist'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.aovlist_+3A_x">x</code></td>
<td>
<p>An <code>aovlist</code> objects, such as those created by <code><a href="stats.html#topic+aov">stats::aov()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.aovlist_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>term</code> column of an ANOVA table can come with leading or
trailing whitespace, which this tidying method trims.
</p>
<p>For documentation on the tidier for <code><a href="car.html#topic+leveneTest">car::leveneTest()</a></code> output, see
<code><a href="#topic+tidy.leveneTest">tidy.leveneTest()</a></code>
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>meansq</code></td>
<td>
<p>Mean sum of squares. Equal to total sum of squares divided by degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>stratum</code></td>
<td>
<p>The error stratum.</p>
</td></tr>
<tr><td><code>sumsq</code></td>
<td>
<p>Sum of squares explained by this term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+aov">stats::aov()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.anova">glance.anova</a>()</code>,
<code><a href="#topic+glance.aov">glance.aov</a>()</code>,
<code><a href="#topic+tidy.TukeyHSD">tidy.TukeyHSD</a>()</code>,
<code><a href="#topic+tidy.anova">tidy.anova</a>()</code>,
<code><a href="#topic+tidy.aov">tidy.aov</a>()</code>,
<code><a href="#topic+tidy.manova">tidy.manova</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- aov(mpg ~ wt + qsec + Error(disp / am), mtcars)
tidy(a)
</code></pre>

<hr>
<h2 id='tidy.Arima'>Tidy a(n) Arima object</h2><span id='topic+tidy.Arima'></span><span id='topic+Arima_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Arima'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.Arima_+3A_x">x</code></td>
<td>
<p>An object of class <code>Arima</code> created by <code><a href="stats.html#topic+arima">stats::arima()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.Arima_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.Arima_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.Arima_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima">stats::arima()</a></code>
</p>
<p>Other Arima tidiers: 
<code><a href="#topic+glance.Arima">glance.Arima</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit model
fit &lt;- arima(lh, order = c(1, 0, 0))

# summarize model fit with tidiers
tidy(fit)
glance(fit)

</code></pre>

<hr>
<h2 id='tidy.betamfx'>Tidy a(n) betamfx object</h2><span id='topic+tidy.betamfx'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betamfx'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.betamfx_+3A_x">x</code></td>
<td>
<p>A <code>betamfx</code> object.</p>
</td></tr>
<tr><td><code id="tidy.betamfx_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.betamfx_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.betamfx_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mfx</code> package provides methods for calculating marginal effects
for various generalized linear models (GLMs). Unlike standard linear
models, estimated model coefficients in a GLM cannot be directly
interpreted as marginal effects (i.e., the change in the response variable
predicted after a one unit change in one of the regressors). This is
because the estimated coefficients are multiplicative, dependent on both
the link function that was used for the estimation and any other variables
that were included in the model. When calculating marginal effects, users
must typically choose whether they want to use i) the average observation
in the data, or ii) the average of the sample marginal effects. See
<code>vignette("mfxarticle")</code> from the <code>mfx</code> package for more details.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>atmean</code></td>
<td>
<p>TRUE if the marginal effects were originally calculated as the
partial effects for the average observation. If FALSE, then these were
instead calculated as average partial effects.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy.betareg">tidy.betareg()</a></code>, <code><a href="mfx.html#topic+betamfx">mfx::betamfx()</a></code>
</p>
<p>Other mfx tidiers: 
<code><a href="#topic+augment.betamfx">augment.betamfx</a>()</code>,
<code><a href="#topic+augment.mfx">augment.mfx</a>()</code>,
<code><a href="#topic+glance.betamfx">glance.betamfx</a>()</code>,
<code><a href="#topic+glance.mfx">glance.mfx</a>()</code>,
<code><a href="#topic+tidy.mfx">tidy.mfx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(mfx)

# Simulate some data
set.seed(12345)
n &lt;- 1000
x &lt;- rnorm(n)

# Beta outcome
y &lt;- rbeta(n, shape1 = plogis(1 + 0.5 * x), shape2 = (abs(0.2 * x)))
# Use Smithson and Verkuilen correction
y &lt;- (y * (n - 1) + 0.5) / n

d &lt;- data.frame(y, x)
mod_betamfx &lt;- betamfx(y ~ x | x, data = d)

tidy(mod_betamfx, conf.int = TRUE)

# Compare with the naive model coefficients of the equivalent betareg call (not run)
# tidy(betamfx(y ~ x | x, data = d), conf.int = TRUE)

augment(mod_betamfx)
glance(mod_betamfx)

</code></pre>

<hr>
<h2 id='tidy.betareg'>Tidy a(n) betareg object</h2><span id='topic+tidy.betareg'></span><span id='topic+betareg_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'betareg'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.betareg_+3A_x">x</code></td>
<td>
<p>A <code>betareg</code> object produced by a call to <code><a href="betareg.html#topic+betareg">betareg::betareg()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.betareg_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.betareg_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.betareg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The tibble has one row for each term in the regression. The
<code>component</code> column indicates whether a particular
term was used to model either the <code>"mean"</code> or <code>"precision"</code>. Here the
precision is the inverse of the variance, often referred to as <code>phi</code>.
At least one term will have been used to model the precision <code>phi</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>component</code></td>
<td>
<p>Whether a particular term was used to model the mean or the
precision in the regression. See details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="betareg.html#topic+betareg">betareg::betareg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(betareg)

# load dats
data("GasolineYield", package = "betareg")

# fit model
mod &lt;- betareg(yield ~ batch + temp, data = GasolineYield)

mod

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)
tidy(mod, conf.int = TRUE, conf.level = .99)

augment(mod)

glance(mod)

</code></pre>

<hr>
<h2 id='tidy.biglm'>Tidy a(n) biglm object</h2><span id='topic+tidy.biglm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biglm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.biglm_+3A_x">x</code></td>
<td>
<p>A <code>biglm</code> object created by a call to <code><a href="biglm.html#topic+biglm">biglm::biglm()</a></code> or
<code><a href="biglm.html#topic+bigglm">biglm::bigglm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.biglm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.biglm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.biglm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.biglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="biglm.html#topic+biglm">biglm::biglm()</a></code>, <code><a href="biglm.html#topic+bigglm">biglm::bigglm()</a></code>
</p>
<p>Other biglm tidiers: 
<code><a href="#topic+glance.biglm">glance.biglm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(biglm)

# fit model -- linear regression
bfit &lt;- biglm(mpg ~ wt + disp, mtcars)

# summarize model fit with tidiers
tidy(bfit)
tidy(bfit, conf.int = TRUE)
tidy(bfit, conf.int = TRUE, conf.level = .9)

glance(bfit)

# fit model -- logistic regression
bgfit &lt;- bigglm(am ~ mpg, mtcars, family = binomial())

# summarize model fit with tidiers
tidy(bgfit)
tidy(bgfit, exponentiate = TRUE)
tidy(bgfit, conf.int = TRUE)
tidy(bgfit, conf.int = TRUE, conf.level = .9)
tidy(bgfit, conf.int = TRUE, conf.level = .9, exponentiate = TRUE)

glance(bgfit)

</code></pre>

<hr>
<h2 id='tidy.binDesign'>Tidy a(n) binDesign object</h2><span id='topic+tidy.binDesign'></span><span id='topic+bindesign_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binDesign'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.binDesign_+3A_x">x</code></td>
<td>
<p>A <code><a href="binGroup.html#topic+binDesign">binGroup::binDesign()</a></code> object.</p>
</td></tr>
<tr><td><code id="tidy.binDesign_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>Number of trials in given iteration.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>Power achieved for given value of n.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="binGroup.html#topic+binDesign">binGroup::binDesign()</a></code>
</p>
<p>Other bingroup tidiers: 
<code><a href="#topic+glance.binDesign">glance.binDesign</a>()</code>,
<code><a href="#topic+tidy.binWidth">tidy.binWidth</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(binGroup)
des &lt;- binDesign(
  nmax = 300, delta = 0.06,
  p.hyp = 0.1, power = .8
)

glance(des)
tidy(des)

# the ggplot2 equivalent of plot(des)
library(ggplot2)
ggplot(tidy(des), aes(n, power)) +
  geom_line()

</code></pre>

<hr>
<h2 id='tidy.binWidth'>Tidy a(n) binWidth object</h2><span id='topic+tidy.binWidth'></span><span id='topic+binwidth_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binWidth'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.binWidth_+3A_x">x</code></td>
<td>
<p>A <code><a href="binGroup.html#topic+binWidth">binGroup::binWidth()</a></code> object.</p>
</td></tr>
<tr><td><code id="tidy.binWidth_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>alternative</code></td>
<td>
<p>Alternative hypothesis (character).</p>
</td></tr>
<tr><td><code>ci.width</code></td>
<td>
<p>Expected width of confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>True proportion.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Total sample size</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="binGroup.html#topic+binWidth">binGroup::binWidth()</a></code>
</p>
<p>Other bingroup tidiers: 
<code><a href="#topic+glance.binDesign">glance.binDesign</a>()</code>,
<code><a href="#topic+tidy.binDesign">tidy.binDesign</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries
library(binGroup)

# fit model
bw &lt;- binWidth(100, .1)

bw

# summarize model fit with tidiers
tidy(bw)

</code></pre>

<hr>
<h2 id='tidy.boot'>Tidy a(n) boot object</h2><span id='topic+tidy.boot'></span><span id='topic+boot_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.method = c("perc", "bca", "basic", "norm"),
  exponentiate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.boot_+3A_x">x</code></td>
<td>
<p>A <code><a href="boot.html#topic+boot">boot::boot()</a></code> object.</p>
</td></tr>
<tr><td><code id="tidy.boot_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.boot_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.boot_+3A_conf.method">conf.method</code></td>
<td>
<p>Passed to the <code>type</code> argument of <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>.
Defaults to <code>"perc"</code>. The allowed types are <code>"perc"</code>, <code>"basic"</code>,
<code>"bca"</code>, and <code>"norm"</code>. Does not support <code>"stud"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="tidy.boot_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.boot_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If weights were provided to the <code>boot</code> function, an <code>estimate</code>
column is included showing the weighted bootstrap estimate, and the
standard error is of that estimate.
</p>
<p>If there are no original statistics in the &quot;boot&quot; object, such as with a
call to <code>tsboot</code> with <code>orig.t = FALSE</code>, the <code>original</code>
and <code>statistic</code> columns are omitted, and only <code>estimate</code> and
<code>std.error</code> columns shown.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>bias</code></td>
<td>
<p>Bias of the statistic.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Original value of the statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="boot.html#topic+boot">boot::boot()</a></code>, <code><a href="boot.html#topic+tsboot">boot::tsboot()</a></code>, <code><a href="boot.html#topic+boot.ci">boot::boot.ci()</a></code>,
<code><a href="rsample.html#topic+bootstraps">rsample::bootstraps()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(boot)

clotting &lt;- data.frame(
  u = c(5, 10, 15, 20, 30, 40, 60, 80, 100),
  lot1 = c(118, 58, 42, 35, 27, 25, 21, 19, 18),
  lot2 = c(69, 35, 26, 21, 18, 16, 13, 12, 12)
)

# fit models
g1 &lt;- glm(lot2 ~ log(u), data = clotting, family = Gamma)

bootfun &lt;- function(d, i) {
  coef(update(g1, data = d[i, ]))
}

bootres &lt;- boot(clotting, bootfun, R = 999)

# summarize model fits with tidiers
tidy(g1, conf.int = TRUE)
tidy(bootres, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='tidy.btergm'>Tidy a(n) btergm object</h2><span id='topic+tidy.btergm'></span><span id='topic+btergm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>
<p>This method tidies the coefficients of a bootstrapped
temporal exponential random graph model estimated with the <span class="pkg">xergm</span>.
It simply returns the coefficients and their confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'btergm'
tidy(x, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.btergm_+3A_x">x</code></td>
<td>
<p>A <code><a href="btergm.html#topic+btergm">btergm::btergm()</a></code> object.</p>
</td></tr>
<tr><td><code id="tidy.btergm_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level for confidence intervals. Defaults to
0.95.</p>
</td></tr>
<tr><td><code id="tidy.btergm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.btergm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="btergm.html#topic+btergm">btergm::btergm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(btergm)
library(network)

set.seed(5)

# create 10 random networks with 10 actors
networks &lt;- list()
for (i in 1:10) {
  mat &lt;- matrix(rbinom(100, 1, .25), nrow = 10, ncol = 10)
  diag(mat) &lt;- 0
  nw &lt;- network(mat)
  networks[[i]] &lt;- nw
}

# create 10 matrices as covariates
covariates &lt;- list()
for (i in 1:10) {
  mat &lt;- matrix(rnorm(100), nrow = 10, ncol = 10)
  covariates[[i]] &lt;- mat
}

# fit the model
mod &lt;- btergm(networks ~ edges + istar(2) + edgecov(covariates), R = 100)

# summarize model fit with tidiers
tidy(mod)

</code></pre>

<hr>
<h2 id='tidy.cch'>Tidy a(n) cch object</h2><span id='topic+tidy.cch'></span><span id='topic+cch_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cch'
tidy(x, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.cch_+3A_x">x</code></td>
<td>
<p>An <code>cch</code> object returned from <code><a href="survival.html#topic+cch">survival::cch()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.cch_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for CI</p>
</td></tr>
<tr><td><code id="tidy.cch_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+cch">survival::cch()</a></code>
</p>
<p>Other cch tidiers: 
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# examples come from cch documentation
subcoh &lt;- nwtco$in.subcohort
selccoh &lt;- with(nwtco, rel == 1 | subcoh == 1)
ccoh.data &lt;- nwtco[selccoh, ]
ccoh.data$subcohort &lt;- subcoh[selccoh]

# central-lab histology
ccoh.data$histol &lt;- factor(ccoh.data$histol, labels = c("FH", "UH"))

# tumour stage
ccoh.data$stage &lt;- factor(ccoh.data$stage, labels = c("I", "II", "III", "IV"))
ccoh.data$age &lt;- ccoh.data$age / 12 # age in years

# fit model
fit.ccP &lt;- cch(Surv(edrel, rel) ~ stage + histol + age,
  data = ccoh.data,
  subcoh = ~subcohort, id = ~seqno, cohort.size = 4028
)

# summarize model fit with tidiers + visualization
tidy(fit.ccP)

# coefficient plot
library(ggplot2)

ggplot(tidy(fit.ccP), aes(x = estimate, y = term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0) +
  geom_vline(xintercept = 0)

</code></pre>

<hr>
<h2 id='tidy.cld'>Tidy a(n) cld object</h2><span id='topic+tidy.cld'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cld'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.cld_+3A_x">x</code></td>
<td>
<p>A <code>cld</code> object created by calling <code><a href="multcomp.html#topic+cld">multcomp::cld()</a></code> on a
<code>glht</code>, <code>confint.glht()</code> or <code>summary.glht()</code> object.</p>
</td></tr>
<tr><td><code id="tidy.cld_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>letters</code></td>
<td>
<p>Compact letter display denoting all pair-wise comparisons.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="multcomp.html#topic+cld">multcomp::cld()</a></code>, <code><a href="multcomp.html#topic+methods">multcomp::summary.glht()</a></code>,
<code><a href="multcomp.html#topic+methods">multcomp::confint.glht()</a></code>, <code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>
</p>
<p>Other multcomp tidiers: 
<code><a href="#topic+tidy.confint.glht">tidy.confint.glht</a>()</code>,
<code><a href="#topic+tidy.glht">tidy.glht</a>()</code>,
<code><a href="#topic+tidy.summary.glht">tidy.summary.glht</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(multcomp)
library(ggplot2)

amod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
wht &lt;- glht(amod, linfct = mcp(tension = "Tukey"))

tidy(wht)

ggplot(wht, aes(lhs, estimate)) +
  geom_point()

CI &lt;- confint(wht)

tidy(CI)

ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
  geom_pointrange()

tidy(summary(wht))
ggplot(mapping = aes(lhs, estimate)) +
  geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
  geom_point(aes(size = p), data = summary(wht)) +
  scale_size(trans = "reverse")

cld &lt;- cld(wht)
tidy(cld)

</code></pre>

<hr>
<h2 id='tidy.clm'>Tidy a(n) clm object</h2><span id='topic+tidy.clm'></span><span id='topic+ordinal_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clm'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  conf.type = c("profile", "Wald"),
  exponentiate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.clm_+3A_x">x</code></td>
<td>
<p>A <code>clm</code> object returned from <code><a href="ordinal.html#topic+clm">ordinal::clm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.clm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.clm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.clm_+3A_conf.type">conf.type</code></td>
<td>
<p>Whether to use <code>"profile"</code> or <code>"Wald"</code> confidence
intervals, passed to the <code>type</code> argument of <code><a href="ordinal.html#topic+confint.clm">ordinal::confint.clm()</a></code>.
Defaults to <code>"profile"</code>.</p>
</td></tr>
<tr><td><code id="tidy.clm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.clm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code style="white-space: pre;">&#8288;broom 0.7.0&#8288;</code> the <code>coefficient_type</code> column was renamed to
<code>coef.type</code>, and the contents were changed as well.
</p>
<p>Note that <code>intercept</code> type coefficients correspond to <code>alpha</code>
parameters, <code>location</code> type coefficients correspond to <code>beta</code>
parameters, and <code>scale</code> type coefficients correspond to <code>zeta</code>
parameters.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="ordinal.html#topic+clm">ordinal::clm()</a></code>, <code><a href="ordinal.html#topic+confint.clm">ordinal::confint.clm()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ordinal)

# fit model
fit &lt;- clm(rating ~ temp * contact, data = wine)

# summarize model fit with tidiers
tidy(fit)
tidy(fit, conf.int = TRUE, conf.level = 0.9)
tidy(fit, conf.int = TRUE, conf.type = "Wald", exponentiate = TRUE)

glance(fit)
augment(fit, type.predict = "prob")
augment(fit, type.predict = "class")

# ...and again with another model specification
fit2 &lt;- clm(rating ~ temp, nominal = ~contact, data = wine)

tidy(fit2)
glance(fit2)

</code></pre>

<hr>
<h2 id='tidy.clmm'>Tidy a(n) clmm object</h2><span id='topic+tidy.clmm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clmm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.clmm_+3A_x">x</code></td>
<td>
<p>A <code>clmm</code> object returned from <code><a href="ordinal.html#topic+clmm">ordinal::clmm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.clmm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.clmm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.clmm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.clmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In <code style="white-space: pre;">&#8288;broom 0.7.0&#8288;</code> the <code>coefficient_type</code> column was renamed to
<code>coef.type</code>, and the contents were changed as well.
</p>
<p>Note that <code>intercept</code> type coefficients correspond to <code>alpha</code>
parameters, <code>location</code> type coefficients correspond to <code>beta</code>
parameters, and <code>scale</code> type coefficients correspond to <code>zeta</code>
parameters.
</p>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="ordinal.html#topic+clmm">ordinal::clmm()</a></code>, <code><a href="ordinal.html#topic+confint.clm">ordinal::confint.clm()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ordinal)

# fit model
fit &lt;- clmm(rating ~ temp + contact + (1 | judge), data = wine)

# summarize model fit with tidiers
tidy(fit)
tidy(fit, conf.int = TRUE, conf.level = 0.9)
tidy(fit, conf.int = TRUE, exponentiate = TRUE)

glance(fit)

# ...and again with another model specification
fit2 &lt;- clmm(rating ~ temp + (1 | judge), nominal = ~contact, data = wine)

tidy(fit2)
glance(fit2)

</code></pre>

<hr>
<h2 id='tidy.coeftest'>Tidy a(n) coeftest object</h2><span id='topic+tidy.coeftest'></span><span id='topic+lmtest_tidiers'></span><span id='topic+coeftest_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coeftest'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.coeftest_+3A_x">x</code></td>
<td>
<p>A <code>coeftest</code> object returned from <code><a href="lmtest.html#topic+coeftest">lmtest::coeftest()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.coeftest_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.coeftest_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.coeftest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="lmtest.html#topic+coeftest">lmtest::coeftest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lmtest)

m &lt;- lm(dist ~ speed, data = cars)

coeftest(m)
tidy(coeftest(m))
tidy(coeftest(m, conf.int = TRUE))

# a very common workflow is to combine lmtest::coeftest with alternate
# variance-covariance matrices via the sandwich package. The lmtest
# tidiers support this workflow too, enabling you to adjust the standard
# errors of your tidied models on the fly.
library(sandwich)

# "HC3" (default) robust SEs
tidy(coeftest(m, vcov = vcovHC))

# "HC2" robust SEs
tidy(coeftest(m, vcov = vcovHC, type = "HC2"))

# N-W HAC robust SEs
tidy(coeftest(m, vcov = NeweyWest))

# the columns of the returned tibble for glance.coeftest() will vary
# depending on whether the coeftest object retains the underlying model.
# Users can control this with the "save = TRUE" argument of coeftest().
glance(coeftest(m))
glance(coeftest(m, save = TRUE))

</code></pre>

<hr>
<h2 id='tidy.confint.glht'>Tidy a(n) confint.glht object</h2><span id='topic+tidy.confint.glht'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'confint.glht'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.confint.glht_+3A_x">x</code></td>
<td>
<p>A <code>confint.glht</code> object created by calling
<code><a href="multcomp.html#topic+methods">multcomp::confint.glht()</a></code> on a <code>glht</code> object created with
<code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.confint.glht_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="multcomp.html#topic+methods">multcomp::confint.glht()</a></code>, <code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>
</p>
<p>Other multcomp tidiers: 
<code><a href="#topic+tidy.cld">tidy.cld</a>()</code>,
<code><a href="#topic+tidy.glht">tidy.glht</a>()</code>,
<code><a href="#topic+tidy.summary.glht">tidy.summary.glht</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(multcomp)
library(ggplot2)

amod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
wht &lt;- glht(amod, linfct = mcp(tension = "Tukey"))

tidy(wht)

ggplot(wht, aes(lhs, estimate)) +
  geom_point()

CI &lt;- confint(wht)

tidy(CI)

ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
  geom_pointrange()

tidy(summary(wht))
ggplot(mapping = aes(lhs, estimate)) +
  geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
  geom_point(aes(size = p), data = summary(wht)) +
  scale_size(trans = "reverse")

cld &lt;- cld(wht)
tidy(cld)

</code></pre>

<hr>
<h2 id='tidy.confusionMatrix'>Tidy a(n) confusionMatrix object</h2><span id='topic+tidy.confusionMatrix'></span><span id='topic+caret_tidiers'></span><span id='topic+confusionMatrix_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'confusionMatrix'
tidy(x, by_class = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.confusionMatrix_+3A_x">x</code></td>
<td>
<p>An object of class <code>confusionMatrix</code> created by a call to
<code><a href="caret.html#topic+confusionMatrix">caret::confusionMatrix()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.confusionMatrix_+3A_by_class">by_class</code></td>
<td>
<p>Logical indicating whether or not to show performance
measures broken down by class. Defaults to <code>TRUE</code>. When <code>by_class = FALSE</code>
only returns a tibble with accuracy, kappa, and McNemar statistics.</p>
</td></tr>
<tr><td><code id="tidy.confusionMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>class</code></td>
<td>
<p>The class under consideration.</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value for accuracy and kappa statistics.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="caret.html#topic+confusionMatrix">caret::confusionMatrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(caret)

set.seed(27)

# generate data
two_class_sample1 &lt;- as.factor(sample(letters[1:2], 100, TRUE))
two_class_sample2 &lt;- as.factor(sample(letters[1:2], 100, TRUE))

two_class_cm &lt;- confusionMatrix(
  two_class_sample1,
  two_class_sample2
)

# summarize model fit with tidiers
tidy(two_class_cm)
tidy(two_class_cm, by_class = FALSE)

# multiclass example
six_class_sample1 &lt;- as.factor(sample(letters[1:6], 100, TRUE))
six_class_sample2 &lt;- as.factor(sample(letters[1:6], 100, TRUE))

six_class_cm &lt;- confusionMatrix(
  six_class_sample1,
  six_class_sample2
)

# summarize model fit with tidiers
tidy(six_class_cm)
tidy(six_class_cm, by_class = FALSE)

</code></pre>

<hr>
<h2 id='tidy.coxph'>Tidy a(n) coxph object</h2><span id='topic+tidy.coxph'></span><span id='topic+coxph_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coxph'
tidy(x, exponentiate = FALSE, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.coxph_+3A_x">x</code></td>
<td>
<p>A <code>coxph</code> object returned from <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.coxph_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.coxph_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.coxph_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.coxph_+3A_...">...</code></td>
<td>
<p>For <code>tidy()</code>, additional arguments passed to <code>summary(x, ...)</code>.
Otherwise ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+coxph">survival::coxph()</a></code>
</p>
<p>Other coxph tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
cfit &lt;- coxph(Surv(time, status) ~ age + sex, lung)

# summarize model fit with tidiers
tidy(cfit)
tidy(cfit, exponentiate = TRUE)

lp &lt;- augment(cfit, lung)
risks &lt;- augment(cfit, lung, type.predict = "risk")
expected &lt;- augment(cfit, lung, type.predict = "expected")

glance(cfit)

# also works on clogit models
resp &lt;- levels(logan$occupation)
n &lt;- nrow(logan)
indx &lt;- rep(1:n, length(resp))
logan2 &lt;- data.frame(
  logan[indx, ],
  id = indx,
  tocc = factor(rep(resp, each = n))
)

logan2$case &lt;- (logan2$occupation == logan2$tocc)

cl &lt;- clogit(case ~ tocc + tocc:education + strata(id), logan2)

tidy(cl)
glance(cl)

library(ggplot2)

ggplot(lp, aes(age, .fitted, color = sex)) +
  geom_point()

ggplot(risks, aes(age, .fitted, color = sex)) +
  geom_point()

ggplot(expected, aes(time, .fitted, color = sex)) +
  geom_point()

</code></pre>

<hr>
<h2 id='tidy.crr'>Tidy a(n) cmprsk object</h2><span id='topic+tidy.crr'></span><span id='topic+cmprsk_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'crr'
tidy(x, exponentiate = FALSE, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.crr_+3A_x">x</code></td>
<td>
<p>A <code>crr</code> object returned from <code><a href="cmprsk.html#topic+crr">cmprsk::crr()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.crr_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.crr_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.crr_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.crr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="cmprsk.html#topic+crr">cmprsk::crr()</a></code>
</p>
<p>Other cmprsk tidiers: 
<code><a href="#topic+glance.crr">glance.crr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(cmprsk)

# time to loco-regional failure (lrf)
lrf_time &lt;- rexp(100)
lrf_event &lt;- sample(0:2, 100, replace = TRUE)
trt &lt;- sample(0:1, 100, replace = TRUE)
strt &lt;- sample(1:2, 100, replace = TRUE)

# fit model
x &lt;- crr(lrf_time, lrf_event, cbind(trt, strt))

# summarize model fit with tidiers
tidy(x, conf.int = TRUE)
glance(x)

</code></pre>

<hr>
<h2 id='tidy.cv.glmnet'>Tidy a(n) cv.glmnet object</h2><span id='topic+tidy.cv.glmnet'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.glmnet'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.cv.glmnet_+3A_x">x</code></td>
<td>
<p>A <code>cv.glmnet</code> object returned from <code><a href="glmnet.html#topic+cv.glmnet">glmnet::cv.glmnet()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.cv.glmnet_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>Value of penalty parameter lambda.</p>
</td></tr>
<tr><td><code>nzero</code></td>
<td>
<p>Number of non-zero coefficients for the given lambda.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>lower bound on confidence interval for cross-validation
estimated loss.</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>upper bound on confidence interval for cross-validation
estimated loss.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Median loss across all cross-validation folds for a given
lamdba</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="glmnet.html#topic+cv.glmnet">glmnet::cv.glmnet()</a></code>
</p>
<p>Other glmnet tidiers: 
<code><a href="#topic+glance.cv.glmnet">glance.cv.glmnet</a>()</code>,
<code><a href="#topic+glance.glmnet">glance.glmnet</a>()</code>,
<code><a href="#topic+tidy.glmnet">tidy.glmnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(glmnet)

set.seed(27)

nobs &lt;- 100
nvar &lt;- 50
real &lt;- 5

x &lt;- matrix(rnorm(nobs * nvar), nobs, nvar)
beta &lt;- c(rnorm(real, 0, 1), rep(0, nvar - real))
y &lt;- c(t(beta) %*% t(x)) + rnorm(nvar, sd = 3)

cvfit1 &lt;- cv.glmnet(x, y)

tidy(cvfit1)
glance(cvfit1)

library(ggplot2)

tidied_cv &lt;- tidy(cvfit1)
glance_cv &lt;- glance(cvfit1)

# plot of MSE as a function of lambda
g &lt;- ggplot(tidied_cv, aes(lambda, estimate)) +
  geom_line() +
  scale_x_log10()
g

# plot of MSE as a function of lambda with confidence ribbon
g &lt;- g + geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25)
g

# plot of MSE as a function of lambda with confidence ribbon and choices
# of minimum lambda marked
g &lt;- g +
  geom_vline(xintercept = glance_cv$lambda.min) +
  geom_vline(xintercept = glance_cv$lambda.1se, lty = 2)
g

# plot of number of zeros for each choice of lambda
ggplot(tidied_cv, aes(lambda, nzero)) +
  geom_line() +
  scale_x_log10()

# coefficient plot with min lambda shown
tidied &lt;- tidy(cvfit1$glmnet.fit)

ggplot(tidied, aes(lambda, estimate, group = term)) +
  scale_x_log10() +
  geom_line() +
  geom_vline(xintercept = glance_cv$lambda.min) +
  geom_vline(xintercept = glance_cv$lambda.1se, lty = 2)

</code></pre>

<hr>
<h2 id='tidy.density'>(Deprecated) Tidy density objects</h2><span id='topic+tidy.density'></span>

<h3>Description</h3>

<p>(Deprecated) Tidy density objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.density_+3A_x">x</code></td>
<td>
<p>A <code>density</code> object returned from <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.density_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with two columns: points <code>x</code> where the density
is estimated, and estimated density <code>y</code>.
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>

<hr>
<h2 id='tidy.dist'>(Deprecated) Tidy dist objects</h2><span id='topic+tidy.dist'></span>

<h3>Description</h3>

<p>(Deprecated) Tidy dist objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dist'
tidy(x, diagonal = attr(x, "Diag"), upper = attr(x, "Upper"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.dist_+3A_x">x</code></td>
<td>
<p>A <code>dist</code> object returned from <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.dist_+3A_diagonal">diagonal</code></td>
<td>
<p>Logical indicating whether or not to tidy the diagonal
elements of the distance matrix. Defaults to whatever was based to the
<code>diag</code> argument of <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.dist_+3A_upper">upper</code></td>
<td>
<p>Logical indicating whether or not to tidy the upper half of
the distance matrix. Defaults to whatever was based to the
<code>upper</code> argument of <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.dist_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If the distance matrix does not include an upper triangle and/or
diagonal, the tidied version will not either.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with one row for each pair of items in the
distance matrix, with columns:
</p>
<table>
<tr><td><code>item1</code></td>
<td>
<p>First item</p>
</td></tr>
<tr><td><code>item2</code></td>
<td>
<p>Second item</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>Distance between items</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cars_dist &lt;- dist(t(mtcars[, 1:4]))
cars_dist

tidy(cars_dist)
tidy(cars_dist, upper = TRUE)
tidy(cars_dist, diagonal = TRUE)

</code></pre>

<hr>
<h2 id='tidy.drc'>Tidy a(n) drc object</h2><span id='topic+tidy.drc'></span><span id='topic+drc_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drc'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.drc_+3A_x">x</code></td>
<td>
<p>A <code>drc</code> object produced by a call to <code><a href="drc.html#topic+drm">drc::drm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.drc_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.drc_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.drc_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The tibble has one row for each curve and term in the regression.
The <code>curveid</code> column indicates the curve.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>curve</code></td>
<td>
<p>Index identifying the curve.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="drc.html#topic+drm">drc::drm()</a></code>
</p>
<p>Other drc tidiers: 
<code><a href="#topic+augment.drc">augment.drc</a>()</code>,
<code><a href="#topic+glance.drc">glance.drc</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(drc)

# fit model
mod &lt;- drm(dead / total ~ conc, type,
  weights = total, data = selenium, fct = LL.2(), type = "binomial"
)

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)

glance(mod)

augment(mod, selenium)

</code></pre>

<hr>
<h2 id='tidy.emmGrid'>Tidy a(n) emmGrid object</h2><span id='topic+tidy.emmGrid'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'emmGrid'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.emmGrid_+3A_x">x</code></td>
<td>
<p>An <code>emmGrid</code> object.</p>
</td></tr>
<tr><td><code id="tidy.emmGrid_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.emmGrid_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.emmGrid_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or
<code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>. <strong>Cautionary note</strong>: misspecified arguments
may be silently ignored!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data frame with one observation for each estimated marginal
mean, and one column for each combination of factors. When the input is a
contrast, each row will contain one estimated contrast.
</p>
<p>There are a large number of arguments that can be
passed on to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or <code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Expected marginal mean</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>T-ratio statistic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code>, <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>,
<code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code>
</p>
<p>Other emmeans tidiers: 
<code><a href="#topic+tidy.lsmobj">tidy.lsmobj</a>()</code>,
<code><a href="#topic+tidy.ref.grid">tidy.ref.grid</a>()</code>,
<code><a href="#topic+tidy.summary_emm">tidy.summary_emm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(emmeans)

# linear model for sales of oranges per day
oranges_lm1 &lt;- lm(sales1 ~ price1 + price2 + day + store, data = oranges)

# reference grid; see vignette("basics", package = "emmeans")
oranges_rg1 &lt;- ref_grid(oranges_lm1)
td &lt;- tidy(oranges_rg1)
td

# marginal averages
marginal &lt;- emmeans(oranges_rg1, "day")
tidy(marginal)

# contrasts
tidy(contrast(marginal))
tidy(contrast(marginal, method = "pairwise"))

# plot confidence intervals
library(ggplot2)

ggplot(tidy(marginal, conf.int = TRUE), aes(day, estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# by multiple prices
by_price &lt;- emmeans(oranges_lm1, "day",
  by = "price2",
  at = list(
    price1 = 50, price2 = c(40, 60, 80),
    day = c("2", "3", "4")
  )
)

by_price

tidy(by_price)

ggplot(tidy(by_price, conf.int = TRUE), aes(price2, estimate, color = day)) +
  geom_line() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# joint_tests
tidy(joint_tests(oranges_lm1))

</code></pre>

<hr>
<h2 id='tidy.epi.2by2'>Tidy a(n) epi.2by2 object</h2><span id='topic+tidy.epi.2by2'></span><span id='topic+epiR_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epi.2by2'
tidy(x, parameters = c("moa", "stat"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.epi.2by2_+3A_x">x</code></td>
<td>
<p>A <code>epi.2by2</code> object produced by a call to <code><a href="epiR.html#topic+epi.2by2">epiR::epi.2by2()</a></code></p>
</td></tr>
<tr><td><code id="tidy.epi.2by2_+3A_parameters">parameters</code></td>
<td>
<p>Return measures of association (<code>moa</code>) or test statistics (<code>stat</code>),
default is <code>moa</code> (measures of association)</p>
</td></tr>
<tr><td><code id="tidy.epi.2by2_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The tibble has a column for each of the measures of association
or tests contained in <code>massoc</code> or <code>massoc.detail</code> when <code><a href="epiR.html#topic+epi.2by2">epiR::epi.2by2()</a></code> is called.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimated measure of association</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="epiR.html#topic+epi.2by2">epiR::epi.2by2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(epiR)

# generate data
dat &lt;- matrix(c(13, 2163, 5, 3349), nrow = 2, byrow = TRUE)

rownames(dat) &lt;- c("DF+", "DF-")
colnames(dat) &lt;- c("FUS+", "FUS-")

# fit model
fit &lt;- epi.2by2(
  dat = as.table(dat), method = "cross.sectional",
  conf.level = 0.95, units = 100, outcome = "as.columns"
)

# summarize model fit with tidiers
tidy(fit, parameters = "moa")
tidy(fit, parameters = "stat")

</code></pre>

<hr>
<h2 id='tidy.ergm'>Tidy a(n) ergm object</h2><span id='topic+tidy.ergm'></span><span id='topic+ergm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>
<p>The methods should work with any model that conforms to
the <span class="pkg">ergm</span> class, such as those produced from weighted networks by the
<span class="pkg">ergm.count</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ergm_+3A_x">x</code></td>
<td>
<p>An <code>ergm</code> object returned from a call to <code><a href="ergm.html#topic+ergm">ergm::ergm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.ergm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.ergm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.ergm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.ergm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="ergm.html#topic+summary.formula">ergm::summary()</a></code>.
<strong>Cautionary note</strong>: Misspecified arguments may be silently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with one row for each coefficient in the
exponential random graph model, with columns:
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>The term in the model being estimated and tested</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated coefficient</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error</p>
</td></tr>
<tr><td><code>mcmc.error</code></td>
<td>
<p>The MCMC error</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose Exponential-Family
Models for Networks. <em>Journal of Statistical Software</em>, 24(3).
<a href="https://www.jstatsoft.org/v24/i03/">https://www.jstatsoft.org/v24/i03/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="ergm.html#topic+ergm">ergm::ergm()</a></code>, <code><a href="ergm.html#topic+control.ergm">ergm::control.ergm()</a></code>,
<code><a href="ergm.html#topic+summary.formula">ergm::summary()</a></code>
</p>
<p>Other ergm tidiers: 
<code><a href="#topic+glance.ergm">glance.ergm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ergm)

# load the Florentine marriage network data
data(florentine)

# fit a model where the propensity to form ties between
# families depends on the absolute difference in wealth
gest &lt;- ergm(flomarriage ~ edges + absdiff("wealth"))

# show terms, coefficient estimates and errors
tidy(gest)

# show coefficients as odds ratios with a 99% CI
tidy(gest, exponentiate = TRUE, conf.int = TRUE, conf.level = 0.99)

# take a look at likelihood measures and other
# control parameters used during MCMC estimation
glance(gest)
glance(gest, deviance = TRUE)
glance(gest, mcmc = TRUE)

</code></pre>

<hr>
<h2 id='tidy.factanal'>Tidy a(n) factanal object</h2><span id='topic+tidy.factanal'></span><span id='topic+factanal_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factanal'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.factanal_+3A_x">x</code></td>
<td>
<p>A <code>factanal</code> object created by <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.factanal_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>variable</code></td>
<td>
<p>Variable under consideration.</p>
</td></tr>
<tr><td><code>uniqueness</code></td>
<td>
<p>Proportion of residual, or unexplained variance</p>
</td></tr>
<tr><td><code>flX</code></td>
<td>
<p>Factor loading for level X.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+factanal">stats::factanal()</a></code>
</p>
<p>Other factanal tidiers: 
<code><a href="#topic+augment.factanal">augment.factanal</a>()</code>,
<code><a href="#topic+glance.factanal">glance.factanal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# generate data
library(dplyr)
library(purrr)

m1 &lt;- tibble(
  v1 = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 4, 5, 6),
  v2 = c(1, 2, 1, 1, 1, 1, 2, 1, 2, 1, 3, 4, 3, 3, 3, 4, 6, 5),
  v3 = c(3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 4, 6),
  v4 = c(3, 3, 4, 3, 3, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 5, 6, 4),
  v5 = c(1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 6, 4, 5),
  v6 = c(1, 1, 1, 2, 1, 3, 3, 3, 4, 3, 1, 1, 1, 2, 1, 6, 5, 4)
)

# new data
m2 &lt;- map_dfr(m1, rev)

# factor analysis objects
fit1 &lt;- factanal(m1, factors = 3, scores = "Bartlett")
fit2 &lt;- factanal(m1, factors = 3, scores = "regression")

# tidying the object
tidy(fit1)
tidy(fit2)

# augmented dataframe
augment(fit1)
augment(fit2)

# augmented dataframe (with new data)
augment(fit1, data = m2)
augment(fit2, data = m2)

</code></pre>

<hr>
<h2 id='tidy.felm'>Tidy a(n) felm object</h2><span id='topic+tidy.felm'></span><span id='topic+felm_tidiers'></span><span id='topic+lfe_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'felm'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  fe = FALSE,
  se.type = c("default", "iid", "robust", "cluster"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.felm_+3A_x">x</code></td>
<td>
<p>A <code>felm</code> object returned from <code><a href="lfe.html#topic+felm">lfe::felm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.felm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.felm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.felm_+3A_fe">fe</code></td>
<td>
<p>Logical indicating whether or not to include estimates of
fixed effects. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.felm_+3A_se.type">se.type</code></td>
<td>
<p>Character indicating the type of standard errors. Defaults to
using those of the underlying felm() model object, e.g. clustered errors
for models that were provided a cluster specification. Users can override
these defaults by specifying an appropriate alternative: &quot;iid&quot; (for
homoskedastic errors), &quot;robust&quot; (for Eicker-Huber-White robust errors), or
&quot;cluster&quot; (for clustered standard errors; if the model object supports it).</p>
</td></tr>
<tr><td><code id="tidy.felm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="lfe.html#topic+felm">lfe::felm()</a></code>
</p>
<p>Other felm tidiers: 
<code><a href="#topic+augment.felm">augment.felm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lfe)

# use built-in `airquality` dataset
head(airquality)

# no FEs; same as lm()
est0 &lt;- felm(Ozone ~ Temp + Wind + Solar.R, airquality)

# summarize model fit with tidiers
tidy(est0)
augment(est0)

# add month fixed effects
est1 &lt;- felm(Ozone ~ Temp + Wind + Solar.R | Month, airquality)

# summarize model fit with tidiers
tidy(est1)
tidy(est1, fe = TRUE)
augment(est1)
glance(est1)

# the "se.type" argument can be used to switch out different standard errors
# types on the fly. In turn, this can be useful exploring the effect of
# different error structures on model inference.
tidy(est1, se.type = "iid")
tidy(est1, se.type = "robust")

# add clustered SEs (also by month)
est2 &lt;- felm(Ozone ~ Temp + Wind + Solar.R | Month | 0 | Month, airquality)

# summarize model fit with tidiers
tidy(est2, conf.int = TRUE)
tidy(est2, conf.int = TRUE, se.type = "cluster")
tidy(est2, conf.int = TRUE, se.type = "robust")
tidy(est2, conf.int = TRUE, se.type = "iid")

</code></pre>

<hr>
<h2 id='tidy.fitdistr'>Tidy a(n) fitdistr object</h2><span id='topic+tidy.fitdistr'></span><span id='topic+fitdistr_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitdistr'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.fitdistr_+3A_x">x</code></td>
<td>
<p>A <code>fitdistr</code> object returned by <code><a href="MASS.html#topic+fitdistr">MASS::fitdistr()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.fitdistr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="MASS.html#topic+fitdistr">MASS::fitdistr()</a></code>
</p>
<p>Other fitdistr tidiers: 
<code><a href="#topic+glance.fitdistr">glance.fitdistr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# generate data
set.seed(2015)
x &lt;- rnorm(100, 5, 2)

#  fit models
fit &lt;- fitdistr(x, dnorm, list(mean = 3, sd = 1))

# summarize model fit with tidiers
tidy(fit)
glance(fit)

</code></pre>

<hr>
<h2 id='tidy.fixest'>Tidy a(n) fixest object</h2><span id='topic+tidy.fixest'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fixest'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.fixest_+3A_x">x</code></td>
<td>
<p>A <code>fixest</code> object returned from any of the <code>fixest</code> estimators</p>
</td></tr>
<tr><td><code id="tidy.fixest_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.fixest_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.fixest_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>summary</code> and <code>confint</code>. Important
arguments are <code>se</code> and <code>cluster</code>. Other arguments are <code>dof</code>, <code>exact_dof</code>,
<code>forceCovariance</code>, and <code>keepBounded</code>.
See <code><a href="fixest.html#topic+summary.fixest">summary.fixest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fixest</code> package provides a family of functions for estimating
models with arbitrary numbers of fixed-effects, in both an OLS and a GLM
context. The package also supports robust (i.e. White) and clustered
standard error reporting via the generic <code>summary.fixest()</code> command. In a
similar vein, the <code>tidy()</code> method for these models allows users to specify
a desired standard error correction either 1) implicitly via the supplied
fixest object, or 2) explicitly as part of the tidy call. See examples
below.
</p>
<p>Note that fixest confidence intervals are calculated assuming a normal
distribution &ndash; this assumes infinite degrees of freedom for the CI.
(This assumption is distinct from the degrees of freedom used to calculate
the standard errors. For more on degrees of freedom with clusters and
fixed effects, see <a href="https://github.com/lrberge/fixest/issues/6">https://github.com/lrberge/fixest/issues/6</a> and
<a href="https://github.com/sgaure/lfe/issues/1#issuecomment-530646990">https://github.com/sgaure/lfe/issues/1#issuecomment-530646990</a>)
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="fixest.html#topic+feglm">fixest::feglm()</a></code>, <code><a href="fixest.html#topic+femlm">fixest::fenegbin()</a></code>,
<code><a href="fixest.html#topic+feNmlm">fixest::feNmlm()</a></code>, <code><a href="fixest.html#topic+femlm">fixest::femlm()</a></code>, <code><a href="fixest.html#topic+feols">fixest::feols()</a></code>, <code><a href="fixest.html#topic+feglm">fixest::fepois()</a></code>
</p>
<p>Other fixest tidiers: 
<code><a href="#topic+augment.fixest">augment.fixest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(fixest)

gravity &lt;-
  feols(
    log(Euros) ~ log(dist_km) | Origin + Destination + Product + Year, trade
  )

tidy(gravity)
glance(gravity)
augment(gravity, trade)

# to get robust or clustered SEs, users can either:

# 1) specify the arguments directly in the `tidy()` call

tidy(gravity, conf.int = TRUE, cluster = c("Product", "Year"))

tidy(gravity, conf.int = TRUE, se = "threeway")

# 2) or, feed tidy() a summary.fixest object that has already accepted
# these arguments

gravity_summ &lt;- summary(gravity, cluster = c("Product", "Year"))

tidy(gravity_summ, conf.int = TRUE)

# approach (1) is preferred.

</code></pre>

<hr>
<h2 id='tidy.ftable'>(Deprecated) Tidy ftable objects</h2><span id='topic+tidy.ftable'></span>

<h3>Description</h3>

<p>This function is deprecated. Please use <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ftable'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ftable_+3A_x">x</code></td>
<td>
<p>An <code>ftable</code> object returned from <code><a href="stats.html#topic+ftable">stats::ftable()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.ftable_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An ftable contains a &quot;flat&quot; contingency table. This melts it into a
<a href="tibble.html#topic+tibble">tibble::tibble</a> with one column for each variable, then a <code>Freq</code>
column.
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.numeric">tidy.numeric</a>()</code>
</p>

<hr>
<h2 id='tidy.gam'>Tidy a(n) gam object</h2><span id='topic+tidy.gam'></span><span id='topic+mgcv_tidiers'></span><span id='topic+gam_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gam'
tidy(
  x,
  parametric = FALSE,
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.gam_+3A_x">x</code></td>
<td>
<p>A <code>gam</code> object returned from a call to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.gam_+3A_parametric">parametric</code></td>
<td>
<p>Logical indicating if parametric or smooth terms should
be tidied. Defaults to <code>FALSE</code>, meaning that smooth terms are tidied
by default.</p>
</td></tr>
<tr><td><code id="tidy.gam_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.gam_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.gam_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.gam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>parametric = FALSE</code> return columns <code>edf</code> and <code>ref.df</code> rather
than <code>estimate</code> and <code>std.error</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The effective degrees of freedom. Only reported when
'parametric = FALSE'</p>
</td></tr>
<tr><td><code>ref.df</code></td>
<td>
<p>The reference degrees of freedom. Only reported when
'parametric = FALSE'</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>
</p>
<p>Other mgcv tidiers: 
<code><a href="#topic+glance.gam">glance.gam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mgcv)

# fit model
g &lt;- gam(mpg ~ s(hp) + am + qsec, data = mtcars)

# summarize model fit with tidiers
tidy(g)
tidy(g, parametric = TRUE)
glance(g)
augment(g)

</code></pre>

<hr>
<h2 id='tidy.Gam'>Tidy a(n) Gam object</h2><span id='topic+tidy.Gam'></span><span id='topic+Gam_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gam'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.Gam_+3A_x">x</code></td>
<td>
<p>A <code>Gam</code> object returned from a call to <code><a href="gam.html#topic+gam">gam::gam()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.Gam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Tidy <code>gam</code> objects created by calls to <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> with
<code><a href="#topic+tidy.gam">tidy.gam()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>meansq</code></td>
<td>
<p>Mean sum of squares. Equal to total sum of squares divided by degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>sumsq</code></td>
<td>
<p>Sum of squares explained by this term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="gam.html#topic+gam">gam::gam()</a></code>, <code><a href="#topic+tidy.anova">tidy.anova()</a></code>, <code><a href="#topic+tidy.gam">tidy.gam()</a></code>
</p>
<p>Other gam tidiers: 
<code><a href="#topic+glance.Gam">glance.Gam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(gam)

# fit model
g &lt;- gam(mpg ~ s(hp, 4) + am + qsec, data = mtcars)

# summarize model fit with tidiers
tidy(g)
glance(g)

</code></pre>

<hr>
<h2 id='tidy.garch'>Tidy a(n) garch object</h2><span id='topic+tidy.garch'></span><span id='topic+garch_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garch'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.garch_+3A_x">x</code></td>
<td>
<p>A <code>garch</code> object returned by <code><a href="tseries.html#topic+garch">tseries::garch()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.garch_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.garch_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.garch_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="tseries.html#topic+garch">tseries::garch()</a></code>
</p>
<p>Other garch tidiers: 
<code><a href="#topic+glance.garch">glance.garch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(tseries)

# load data
data(EuStockMarkets)

# fit model
dax &lt;- diff(log(EuStockMarkets))[, "DAX"]
dax.garch &lt;- garch(dax)
dax.garch

# summarize model fit with tidiers
tidy(dax.garch)
glance(dax.garch)

</code></pre>

<hr>
<h2 id='tidy.geeglm'>Tidy a(n) geeglm object</h2><span id='topic+tidy.geeglm'></span><span id='topic+geeglm_tidiers'></span><span id='topic+geepack_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geeglm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.geeglm_+3A_x">x</code></td>
<td>
<p>A <code>geeglm</code> object returned from a call to <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.geeglm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.geeglm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.geeglm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.geeglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>conf.int = TRUE</code>, the confidence interval is computed with
the an internal <code>confint.geeglm()</code> function.
</p>
<p>If you have missing values in your model data, you may need to
refit the model with <code>na.action = na.exclude</code> or deal with the
missingness in the data beforehand.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="geepack.html#topic+geeglm">geepack::geeglm()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(geepack)

# load data
data(state)


ds &lt;- data.frame(state.region, state.x77)

# fit model
geefit &lt;- geeglm(Income ~ Frost + Murder,
  id = state.region,
  data = ds,
  corstr = "exchangeable"
)

# summarize model fit with tidiers
tidy(geefit)
tidy(geefit, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='tidy.glht'>Tidy a(n) glht object</h2><span id='topic+tidy.glht'></span><span id='topic+multcomp_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glht'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.glht_+3A_x">x</code></td>
<td>
<p>A <code>glht</code> object returned by <code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.glht_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.glht_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.glht_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Value to which the estimate is compared.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>
</p>
<p>Other multcomp tidiers: 
<code><a href="#topic+tidy.cld">tidy.cld</a>()</code>,
<code><a href="#topic+tidy.confint.glht">tidy.confint.glht</a>()</code>,
<code><a href="#topic+tidy.summary.glht">tidy.summary.glht</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(multcomp)
library(ggplot2)

amod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
wht &lt;- glht(amod, linfct = mcp(tension = "Tukey"))

tidy(wht)

ggplot(wht, aes(lhs, estimate)) +
  geom_point()

CI &lt;- confint(wht)

tidy(CI)

ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
  geom_pointrange()

tidy(summary(wht))
ggplot(mapping = aes(lhs, estimate)) +
  geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
  geom_point(aes(size = p), data = summary(wht)) +
  scale_size(trans = "reverse")

cld &lt;- cld(wht)
tidy(cld)

</code></pre>

<hr>
<h2 id='tidy.glm'>Tidy a(n) glm object</h2><span id='topic+tidy.glm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.glm_+3A_x">x</code></td>
<td>
<p>A <code>glm</code> object returned from <code><a href="stats.html#topic+glm">stats::glm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.glm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">stats::glm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>

<hr>
<h2 id='tidy.glmnet'>Tidy a(n) glmnet object</h2><span id='topic+tidy.glmnet'></span><span id='topic+glmnet_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmnet'
tidy(x, return_zeros = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.glmnet_+3A_x">x</code></td>
<td>
<p>A <code>glmnet</code> object returned from <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.glmnet_+3A_return_zeros">return_zeros</code></td>
<td>
<p>Logical indicating whether coefficients with value zero
zero should be included in the results. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.glmnet_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that while this representation of GLMs is much easier
to plot and combine than the default structure, it is also much
more memory-intensive. Do not use for large, sparse matrices.
</p>
<p>No <code>augment</code> method is yet provided even though the model produces
predictions, because the input data is not tidy (it is a matrix that
may be very wide) and therefore combining predictions with it is not
logical. Furthermore, predictions make sense only with a specific
choice of lambda.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>dev.ratio</code></td>
<td>
<p>Fraction of null deviance explained at each value of lambda.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Value of penalty parameter lambda.</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>Which step of lambda choices was used.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code>
</p>
<p>Other glmnet tidiers: 
<code><a href="#topic+glance.cv.glmnet">glance.cv.glmnet</a>()</code>,
<code><a href="#topic+glance.glmnet">glance.glmnet</a>()</code>,
<code><a href="#topic+tidy.cv.glmnet">tidy.cv.glmnet</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(glmnet)

set.seed(2014)
x &lt;- matrix(rnorm(100 * 20), 100, 20)
y &lt;- rnorm(100)
fit1 &lt;- glmnet(x, y)

# summarize model fit with tidiers + visualization
tidy(fit1)
glance(fit1)

library(dplyr)
library(ggplot2)

tidied &lt;- tidy(fit1) %&gt;% filter(term != "(Intercept)")

ggplot(tidied, aes(step, estimate, group = term)) +
  geom_line()

ggplot(tidied, aes(lambda, estimate, group = term)) +
  geom_line() +
  scale_x_log10()

ggplot(tidied, aes(lambda, dev.ratio)) +
  geom_line()

# works for other types of regressions as well, such as logistic
g2 &lt;- sample(1:2, 100, replace = TRUE)
fit2 &lt;- glmnet(x, g2, family = "binomial")
tidy(fit2)

</code></pre>

<hr>
<h2 id='tidy.glmrob'>Tidy a(n) glmrob object</h2><span id='topic+tidy.glmrob'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmrob'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.glmrob_+3A_x">x</code></td>
<td>
<p>A <code>glmrob</code> object returned from <code><a href="robustbase.html#topic+glmrob">robustbase::glmrob()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.glmrob_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.glmrob_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.glmrob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+glmrob">robustbase::glmrob()</a></code>
</p>
<p>Other robustbase tidiers: 
<code><a href="#topic+augment.glmrob">augment.glmrob</a>()</code>,
<code><a href="#topic+augment.lmrob">augment.lmrob</a>()</code>,
<code><a href="#topic+glance.lmrob">glance.lmrob</a>()</code>,
<code><a href="#topic+tidy.lmrob">tidy.lmrob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("robustbase", quietly = TRUE)) {
  # load libraries for models and data
  library(robustbase)

  data(coleman)
  set.seed(0)

  m &lt;- lmrob(Y ~ ., data = coleman)
  tidy(m)
  augment(m)
  glance(m)

  data(carrots)

  Rfit &lt;- glmrob(cbind(success, total - success) ~ logdose + block,
    family = binomial, data = carrots, method = "Mqle",
    control = glmrobMqle.control(tcc = 1.2)
  )

  tidy(Rfit)
  augment(Rfit)
}
</code></pre>

<hr>
<h2 id='tidy.glmRob'>Tidy a(n) glmRob object</h2><span id='topic+tidy.glmRob'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmRob'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.glmRob_+3A_x">x</code></td>
<td>
<p>A <code>glmRob</code> object returned from <code><a href="robust.html#topic+glmRob">robust::glmRob()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.glmRob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="robust.html#topic+glmRob">robust::glmRob()</a></code>
</p>
<p>Other robust tidiers: 
<code><a href="#topic+augment.lmRob">augment.lmRob</a>()</code>,
<code><a href="#topic+glance.glmRob">glance.glmRob</a>()</code>,
<code><a href="#topic+glance.lmRob">glance.lmRob</a>()</code>,
<code><a href="#topic+tidy.lmRob">tidy.lmRob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(robust)

# fit model
gm &lt;- glmRob(am ~ wt, data = mtcars, family = "binomial")

# summarize model fit with tidiers
tidy(gm)
glance(gm)

</code></pre>

<hr>
<h2 id='tidy.gmm'>Tidy a(n) gmm object</h2><span id='topic+tidy.gmm'></span><span id='topic+gmm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.gmm_+3A_x">x</code></td>
<td>
<p>A <code>gmm</code> object returned from <code><a href="gmm.html#topic+gmm">gmm::gmm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.gmm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.gmm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.gmm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.gmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="gmm.html#topic+gmm">gmm::gmm()</a></code>
</p>
<p>Other gmm tidiers: 
<code><a href="#topic+glance.gmm">glance.gmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(gmm)

# examples come from the "gmm" package
# CAPM test with GMM
data(Finance)
r &lt;- Finance[1:300, 1:10]
rm &lt;- Finance[1:300, "rm"]
rf &lt;- Finance[1:300, "rf"]

z &lt;- as.matrix(r - rf)
t &lt;- nrow(z)
zm &lt;- rm - rf
h &lt;- matrix(zm, t, 1)
res &lt;- gmm(z ~ zm, x = h)

# tidy result
tidy(res)
tidy(res, conf.int = TRUE)
tidy(res, conf.int = TRUE, conf.level = .99)

# coefficient plot
library(ggplot2)
library(dplyr)

tidy(res, conf.int = TRUE) %&gt;%
  mutate(variable = reorder(term, estimate)) %&gt;%
  ggplot(aes(estimate, variable)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, color = "red", lty = 2)

# from a function instead of a matrix
g &lt;- function(theta, x) {
  e &lt;- x[, 2:11] - theta[1] - (x[, 1] - theta[1]) %*% matrix(theta[2:11], 1, 10)
  gmat &lt;- cbind(e, e * c(x[, 1]))
  return(gmat)
}

x &lt;- as.matrix(cbind(rm, r))
res_black &lt;- gmm(g, x = x, t0 = rep(0, 11))

tidy(res_black)
tidy(res_black, conf.int = TRUE)

# APT test with Fama-French factors and GMM

f1 &lt;- zm
f2 &lt;- Finance[1:300, "hml"] - rf
f3 &lt;- Finance[1:300, "smb"] - rf
h &lt;- cbind(f1, f2, f3)
res2 &lt;- gmm(z ~ f1 + f2 + f3, x = h)

td2 &lt;- tidy(res2, conf.int = TRUE)
td2

# coefficient plot
td2 %&gt;%
  mutate(variable = reorder(term, estimate)) %&gt;%
  ggplot(aes(estimate, variable)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_vline(xintercept = 0, color = "red", lty = 2)

</code></pre>

<hr>
<h2 id='tidy.htest'>Tidy/glance a(n) htest object</h2><span id='topic+tidy.htest'></span><span id='topic+htest_tidiers'></span><span id='topic+glance.htest'></span>

<h3>Description</h3>

<p>For models that have only a single component, the <code><a href="#topic+tidy">tidy()</a></code> and
<code><a href="#topic+glance">glance()</a></code> methods are identical. Please see the documentation for both
of those methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'htest'
tidy(x, ...)

## S3 method for class 'htest'
glance(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.htest_+3A_x">x</code></td>
<td>
<p>An <code>htest</code> objected, such as those created by <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code>,
<code><a href="stats.html#topic+t.test">stats::t.test()</a></code>, <code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>, <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code>, etc.</p>
</td></tr>
<tr><td><code id="tidy.htest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>alternative</code></td>
<td>
<p>Alternative hypothesis (character).</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>estimate1</code></td>
<td>
<p>Sometimes two estimates are computed, such as in a two-sample t-test.</p>
</td></tr>
<tr><td><code>estimate2</code></td>
<td>
<p>Sometimes two estimates are computed, such as in a two-sample t-test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>The parameter being modeled.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code>, <code><a href="stats.html#topic+t.test">stats::t.test()</a></code>,
<code><a href="stats.html#topic+wilcox.test">stats::wilcox.test()</a></code>, <code><a href="stats.html#topic+chisq.test">stats::chisq.test()</a></code>
</p>
<p>Other htest tidiers: 
<code><a href="#topic+augment.htest">augment.htest</a>()</code>,
<code><a href="#topic+tidy.pairwise.htest">tidy.pairwise.htest</a>()</code>,
<code><a href="#topic+tidy.power.htest">tidy.power.htest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tt &lt;- t.test(rnorm(10))

tidy(tt)

# the glance output will be the same for each of the below tests
glance(tt)

tt &lt;- t.test(mpg ~ am, data = mtcars)

tidy(tt)

wt &lt;- wilcox.test(mpg ~ am, data = mtcars, conf.int = TRUE, exact = FALSE)

tidy(wt)

ct &lt;- cor.test(mtcars$wt, mtcars$mpg)

tidy(ct)

chit &lt;- chisq.test(xtabs(Freq ~ Sex + Class, data = as.data.frame(Titanic)))

tidy(chit)
augment(chit)

</code></pre>

<hr>
<h2 id='tidy.ivreg'>Tidy a(n) ivreg object</h2><span id='topic+tidy.ivreg'></span><span id='topic+ivreg_tidiers'></span><span id='topic+aer_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivreg'
tidy(x, conf.int = FALSE, conf.level = 0.95, instruments = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ivreg_+3A_x">x</code></td>
<td>
<p>An <code>ivreg</code> object created by a call to <code><a href="AER.html#topic+ivreg">AER::ivreg()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.ivreg_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.ivreg_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.ivreg_+3A_instruments">instruments</code></td>
<td>
<p>Logical indicating whether to return
coefficients from the second-stage or diagnostics tests for
each endogenous regressor (F-statistics). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.ivreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This tidier currently only supports <code>ivreg</code>-classed objects
outputted by the <code>AER</code> package. The <code>ivreg</code> package also outputs
objects of class <code>ivreg</code>, and will be supported in a later release.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>p.value.Sargan</code></td>
<td>
<p>p-value for Sargan test of overidentifying restrictions.</p>
</td></tr>
<tr><td><code>p.value.weakinst</code></td>
<td>
<p>p-value for weak instruments test.</p>
</td></tr>
<tr><td><code>p.value.Wu.Hausman</code></td>
<td>
<p>p-value for Wu-Hausman weak instruments test for endogeneity.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>statistic.Sargan</code></td>
<td>
<p>Statistic for Sargan test of overidentifying restrictions.</p>
</td></tr>
<tr><td><code>statistic.weakinst</code></td>
<td>
<p>Statistic for Wu-Hausman test.</p>
</td></tr>
<tr><td><code>statistic.Wu.Hausman</code></td>
<td>
<p>Statistic for Wu-Hausman weak instruments test for endogeneity.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="AER.html#topic+ivreg">AER::ivreg()</a></code>
</p>
<p>Other ivreg tidiers: 
<code><a href="#topic+augment.ivreg">augment.ivreg</a>()</code>,
<code><a href="#topic+glance.ivreg">glance.ivreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(AER)

# load data
data("CigarettesSW", package = "AER")

# fit model
ivr &lt;- ivreg(
  log(packs) ~ income | population,
  data = CigarettesSW,
  subset = year == "1995"
)

# summarize model fit with tidiers
tidy(ivr)
tidy(ivr, conf.int = TRUE)
tidy(ivr, conf.int = TRUE, instruments = TRUE)

augment(ivr)
augment(ivr, data = CigarettesSW)
augment(ivr, newdata = CigarettesSW)

glance(ivr)

</code></pre>

<hr>
<h2 id='tidy.kappa'>Tidy a(n) kappa object</h2><span id='topic+tidy.kappa'></span><span id='topic+kappa_tidiers'></span><span id='topic+psych_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kappa'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.kappa_+3A_x">x</code></td>
<td>
<p>A <code>kappa</code> object returned from <code><a href="psych.html#topic+kappa">psych::cohen.kappa()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.kappa_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that confidence level (alpha) for the confidence interval
cannot be set in <code>tidy</code>. Instead you must set the <code>alpha</code> argument
to <code><a href="psych.html#topic+kappa">psych::cohen.kappa()</a></code> when creating the <code>kappa</code> object.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Either 'weighted' or 'unweighted'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="psych.html#topic+kappa">psych::cohen.kappa()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(psych)

# generate example data
rater1 &lt;- 1:9
rater2 &lt;- c(1, 3, 1, 6, 1, 5, 5, 6, 7)

# fit model
ck &lt;- cohen.kappa(cbind(rater1, rater2))

# summarize model fit with tidiers + visualization
tidy(ck)

# graph the confidence intervals
library(ggplot2)

ggplot(tidy(ck), aes(estimate, type)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high))

</code></pre>

<hr>
<h2 id='tidy.kde'>Tidy a(n) kde object</h2><span id='topic+tidy.kde'></span><span id='topic+kde_tidiers'></span><span id='topic+ks_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kde'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.kde_+3A_x">x</code></td>
<td>
<p>A <code>kde</code> object returned from <code><a href="ks.html#topic+kde">ks::kde()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.kde_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data frame in long format with four columns. Use
<code>tidyr::pivot_wider(..., names_from = variable, values_from = value)</code>
on the output to return to a wide format.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>weighted observed number of events in each group.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value/estimate of the component. Results from data reshaping.</p>
</td></tr>
<tr><td><code>variable</code></td>
<td>
<p>Variable under consideration.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="ks.html#topic+kde">ks::kde()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(ks)

# generate data
dat &lt;- replicate(2, rnorm(100))
k &lt;- kde(dat)

# summarize model fit with tidiers + visualization
td &lt;- tidy(k)
td

library(ggplot2)
library(dplyr)
library(tidyr)

td %&gt;%
  pivot_wider(c(obs, estimate),
    names_from = variable,
    values_from = value
  ) %&gt;%
  ggplot(aes(x1, x2, fill = estimate)) +
  geom_tile() +
  theme_void()

# also works with 3 dimensions
dat3 &lt;- replicate(3, rnorm(100))
k3 &lt;- kde(dat3)

td3 &lt;- tidy(k3)
td3

</code></pre>

<hr>
<h2 id='tidy.Kendall'>Tidy a(n) Kendall object</h2><span id='topic+tidy.Kendall'></span><span id='topic+Kendall_tidiers'></span><span id='topic+kendall_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Kendall'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.Kendall_+3A_x">x</code></td>
<td>
<p>A <code>Kendall</code> object returned from a call to <code><a href="Kendall.html#topic+Kendall">Kendall::Kendall()</a></code>,
<code><a href="Kendall.html#topic+MannKendall">Kendall::MannKendall()</a></code>, or <code><a href="Kendall.html#topic+SeasonalMannKendall">Kendall::SeasonalMannKendall()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.Kendall_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>kendall_score</code></td>
<td>
<p>Kendall score.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>var_kendall_score</code></td>
<td>
<p>Variance of the kendall_score.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>Kendall's tau statistic</p>
</td></tr>
<tr><td><code>denominator</code></td>
<td>
<p>The denominator, which is tau=kendall_score/denominator.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="Kendall.html#topic+Kendall">Kendall::Kendall()</a></code>, <code><a href="Kendall.html#topic+MannKendall">Kendall::MannKendall()</a></code>,
<code><a href="Kendall.html#topic+SeasonalMannKendall">Kendall::SeasonalMannKendall()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(Kendall)

A &lt;- c(2.5, 2.5, 2.5, 2.5, 5, 6.5, 6.5, 10, 10, 10, 10, 10, 14, 14, 14, 16, 17)
B &lt;- c(1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 2)

# fit models and summarize results
f_res &lt;- Kendall(A, B)
tidy(f_res)

s_res &lt;- MannKendall(B)
tidy(s_res)

t_res &lt;- SeasonalMannKendall(ts(A))
tidy(t_res)

</code></pre>

<hr>
<h2 id='tidy.kmeans'>Tidy a(n) kmeans object</h2><span id='topic+tidy.kmeans'></span><span id='topic+kmeans_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kmeans'
tidy(x, col.names = colnames(x$centers), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.kmeans_+3A_x">x</code></td>
<td>
<p>A <code>kmeans</code> object created by <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.kmeans_+3A_col.names">col.names</code></td>
<td>
<p>Dimension names. Defaults to the names of the variables
in x.  Set to NULL to get names <code style="white-space: pre;">&#8288;x1, x2, ...&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tidy.kmeans_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>cluster</code></td>
<td>
<p>A factor describing the cluster from 1:k.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Number of points assigned to cluster.</p>
</td></tr>
<tr><td><code>withinss</code></td>
<td>
<p>The within-cluster sum of squares.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>
</p>
<p>Other kmeans tidiers: 
<code><a href="#topic+augment.kmeans">augment.kmeans</a>()</code>,
<code><a href="#topic+glance.kmeans">glance.kmeans</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(cluster)
library(modeldata)
library(dplyr)

data(hpc_data)

x &lt;- hpc_data[, 2:5]

fit &lt;- pam(x, k = 4)

tidy(fit)
glance(fit)
augment(fit, x)

</code></pre>

<hr>
<h2 id='tidy.lavaan'>Tidy a(n) lavaan object</h2><span id='topic+tidy.lavaan'></span><span id='topic+lavaan_tidiers'></span><span id='topic+sem_tidiers'></span><span id='topic+cfa_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lavaan'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lavaan_+3A_x">x</code></td>
<td>
<p>A <code>lavaan</code> object, such as those returned from <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code>,
and <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.lavaan_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.lavaan_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.lavaan_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>.
<strong>Cautionary note</strong>: Misspecified arguments may be silently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each estimated parameter and
columns:
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>The result of paste(lhs, op, rhs)</p>
</td></tr>
<tr><td><code>op</code></td>
<td>
<p>The operator in the model syntax (e.g. <code style="white-space: pre;">&#8288;~~&#8288;</code> for covariances, or
<code>~</code> for regression parameters)</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The group (if specified) in the lavaan model</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The parameter estimate (may be standardized)</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The z value returned by <code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code></p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
</td></tr>
<tr><td><code>std.lv</code></td>
<td>
<p>Standardized estimates based on the variances of the
(continuous) latent variables only</p>
</td></tr>
<tr><td><code>std.all</code></td>
<td>
<p>Standardized estimates based on both the variances
of both (continuous) observed and latent variables.</p>
</td></tr>
<tr><td><code>std.nox</code></td>
<td>
<p>Standardized estimates based on both the variances
of both (continuous) observed and latent variables, but not the
variances of exogenous covariates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="lavaan.html#topic+cfa">lavaan::cfa()</a></code>, <code><a href="lavaan.html#topic+sem">lavaan::sem()</a></code>,
<code><a href="lavaan.html#topic+parameterEstimates">lavaan::parameterEstimates()</a></code>
</p>
<p>Other lavaan tidiers: 
<code><a href="#topic+glance.lavaan">glance.lavaan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lavaan)

cfa.fit &lt;- cfa("F =~ x1 + x2 + x3 + x4 + x5 + x6 + x7 + x8 + x9",
  data = HolzingerSwineford1939, group = "school"
)

tidy(cfa.fit)

</code></pre>

<hr>
<h2 id='tidy.lm'>Tidy a(n) lm object</h2><span id='topic+tidy.lm'></span><span id='topic+lm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lm_+3A_x">x</code></td>
<td>
<p>An <code>lm</code> object created by <code><a href="stats.html#topic+lm">stats::lm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.lm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.lm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.lm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If the linear model is an <code>mlm</code> object (multiple linear model),
there is an additional column <code>response</code>. See <code><a href="#topic+tidy.mlm">tidy.mlm()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+summary.lm">stats::summary.lm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(ggplot2)
library(dplyr)

mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)

tidy(mod)
glance(mod)

# coefficient plot
d &lt;- tidy(mod, conf.int = TRUE)

ggplot(d, aes(estimate, term, xmin = conf.low, xmax = conf.high, height = 0)) +
  geom_point() +
  geom_vline(xintercept = 0, lty = 4) +
  geom_errorbarh()

# aside: There are tidy() and glance() methods for lm.summary objects too.
# this can be useful when you want to conserve memory by converting large lm
# objects into their leaner summary.lm equivalents.
s &lt;- summary(mod)
tidy(s, conf.int = TRUE)
glance(s)

augment(mod)
augment(mod, mtcars, interval = "confidence")

# predict on new data
newdata &lt;- mtcars %&gt;%
  head(6) %&gt;%
  mutate(wt = wt + 1)
augment(mod, newdata = newdata)

# ggplot2 example where we also construct 95% prediction interval

# simpler bivariate model since we're plotting in 2D
mod2 &lt;- lm(mpg ~ wt, data = mtcars)

au &lt;- augment(mod2, newdata = newdata, interval = "prediction")

ggplot(au, aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted)) +
  geom_ribbon(aes(ymin = .lower, ymax = .upper), col = NA, alpha = 0.3)

# predict on new data without outcome variable. Output does not include .resid
newdata &lt;- newdata %&gt;%
  select(-mpg)

augment(mod, newdata = newdata)

au &lt;- augment(mod, data = mtcars)

ggplot(au, aes(.hat, .std.resid)) +
  geom_vline(size = 2, colour = "white", xintercept = 0) +
  geom_hline(size = 2, colour = "white", yintercept = 0) +
  geom_point() +
  geom_smooth(se = FALSE)

plot(mod, which = 6)

ggplot(au, aes(.hat, .cooksd)) +
  geom_vline(xintercept = 0, colour = NA) +
  geom_abline(slope = seq(0, 3, by = 0.5), colour = "white") +
  geom_smooth(se = FALSE) +
  geom_point()

# column-wise models
a &lt;- matrix(rnorm(20), nrow = 10)
b &lt;- a + rnorm(length(a))
result &lt;- lm(b ~ a)

tidy(result)

</code></pre>

<hr>
<h2 id='tidy.lm.beta'>Tidy a(n) lm.beta object</h2><span id='topic+tidy.lm.beta'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm.beta'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lm.beta_+3A_x">x</code></td>
<td>
<p>An <code>lm.beta</code> object created by <a href="lm.beta.html#topic+lm.beta">lm.beta::lm.beta</a>.</p>
</td></tr>
<tr><td><code id="tidy.lm.beta_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.lm.beta_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.lm.beta_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If the linear model is an <code>mlm</code> object (multiple linear model),
there is an additional column <code>response</code>.
</p>
<p>If you have missing values in your model data, you may need to refit
the model with <code>na.action = na.exclude</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lm.beta)

# fit models
mod &lt;- stats::lm(speed ~ ., data = cars)
std &lt;- lm.beta(mod)

# summarize model fit with tidiers
tidy(std, conf.int = TRUE)

# generate data
ctl &lt;- c(4.17, 5.58, 5.18, 6.11, 4.50, 4.61, 5.17, 4.53, 5.33, 5.14)
trt &lt;- c(4.81, 4.17, 4.41, 3.59, 5.87, 3.83, 6.03, 4.89, 4.32, 4.69)
group &lt;- gl(2, 10, 20, labels = c("Ctl", "Trt"))
weight &lt;- c(ctl, trt)

# fit models
mod2 &lt;- lm(weight ~ group)
std2 &lt;- lm.beta(mod2)

# summarize model fit with tidiers
tidy(std2, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='tidy.lmodel2'>Tidy a(n) lmodel2 object</h2><span id='topic+tidy.lmodel2'></span><span id='topic+lmodel2_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmodel2'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lmodel2_+3A_x">x</code></td>
<td>
<p>A <code>lmodel2</code> object returned by <code><a href="lmodel2.html#topic+lmodel2">lmodel2::lmodel2()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.lmodel2_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>There are always only two terms in an <code>lmodel2</code>: <code>"Intercept"</code>
and <code>"Slope"</code>. These are computed by four methods: OLS
(ordinary least squares), MA (major axis), SMA (standard major
axis), and RMA (ranged major axis).
</p>
<p>The returned p-value is one-tailed and calculated via a permutation test.
A permutational test is used because distributional assumptions may not
be valid. More information can be found in
<code>vignette("mod2user", package = "lmodel2")</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Either OLS/MA/SMA/RMA</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="lmodel2.html#topic+lmodel2">lmodel2::lmodel2()</a></code>
</p>
<p>Other lmodel2 tidiers: 
<code><a href="#topic+glance.lmodel2">glance.lmodel2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(lmodel2)

data(mod2ex2)
Ex2.res &lt;- lmodel2(Prey ~ Predators, data = mod2ex2, "relative", "relative", 99)
Ex2.res

# summarize model fit with tidiers + visualization
tidy(Ex2.res)
glance(Ex2.res)

# this allows coefficient plots with ggplot2
library(ggplot2)

ggplot(tidy(Ex2.res), aes(estimate, term, color = method)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high)) +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high))

</code></pre>

<hr>
<h2 id='tidy.lmrob'>Tidy a(n) lmrob object</h2><span id='topic+tidy.lmrob'></span><span id='topic+robustbase_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmrob'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lmrob_+3A_x">x</code></td>
<td>
<p>A <code>lmrob</code> object returned from <code><a href="robustbase.html#topic+lmrob">robustbase::lmrob()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.lmrob_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.lmrob_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.lmrob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+lmrob">robustbase::lmrob()</a></code>
</p>
<p>Other robustbase tidiers: 
<code><a href="#topic+augment.glmrob">augment.glmrob</a>()</code>,
<code><a href="#topic+augment.lmrob">augment.lmrob</a>()</code>,
<code><a href="#topic+glance.lmrob">glance.lmrob</a>()</code>,
<code><a href="#topic+tidy.glmrob">tidy.glmrob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("robustbase", quietly = TRUE)) {
  # load libraries for models and data
  library(robustbase)

  data(coleman)
  set.seed(0)

  m &lt;- lmrob(Y ~ ., data = coleman)
  tidy(m)
  augment(m)
  glance(m)

  data(carrots)

  Rfit &lt;- glmrob(cbind(success, total - success) ~ logdose + block,
    family = binomial, data = carrots, method = "Mqle",
    control = glmrobMqle.control(tcc = 1.2)
  )

  tidy(Rfit)
  augment(Rfit)
}
</code></pre>

<hr>
<h2 id='tidy.lmRob'>Tidy a(n) lmRob object</h2><span id='topic+tidy.lmRob'></span><span id='topic+robust_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmRob'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lmRob_+3A_x">x</code></td>
<td>
<p>A <code>lmRob</code> object returned from <code><a href="robust.html#topic+lmRob">robust::lmRob()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.lmRob_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For tidiers for robust models from the <span class="pkg">MASS</span> package see
<code><a href="#topic+tidy.rlm">tidy.rlm()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="robust.html#topic+lmRob">robust::lmRob()</a></code>
</p>
<p>Other robust tidiers: 
<code><a href="#topic+augment.lmRob">augment.lmRob</a>()</code>,
<code><a href="#topic+glance.glmRob">glance.glmRob</a>()</code>,
<code><a href="#topic+glance.lmRob">glance.lmRob</a>()</code>,
<code><a href="#topic+tidy.glmRob">tidy.glmRob</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(robust)

# fit model
m &lt;- lmRob(mpg ~ wt, data = mtcars)

# summarize model fit with tidiers
tidy(m)
augment(m)
glance(m)

</code></pre>

<hr>
<h2 id='tidy.lsmobj'>Tidy a(n) lsmobj object</h2><span id='topic+tidy.lsmobj'></span><span id='topic+emmeans_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lsmobj'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.lsmobj_+3A_x">x</code></td>
<td>
<p>An <code>lsmobj</code> object.</p>
</td></tr>
<tr><td><code id="tidy.lsmobj_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.lsmobj_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.lsmobj_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or
<code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>. <strong>Cautionary note</strong>: misspecified arguments
may be silently ignored!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data frame with one observation for each estimated marginal
mean, and one column for each combination of factors. When the input is a
contrast, each row will contain one estimated contrast.
</p>
<p>There are a large number of arguments that can be
passed on to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or <code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Value to which the estimate is compared.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Expected marginal mean</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>T-ratio statistic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code>, <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>,
<code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code>
</p>
<p>Other emmeans tidiers: 
<code><a href="#topic+tidy.emmGrid">tidy.emmGrid</a>()</code>,
<code><a href="#topic+tidy.ref.grid">tidy.ref.grid</a>()</code>,
<code><a href="#topic+tidy.summary_emm">tidy.summary_emm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(emmeans)

# linear model for sales of oranges per day
oranges_lm1 &lt;- lm(sales1 ~ price1 + price2 + day + store, data = oranges)

# reference grid; see vignette("basics", package = "emmeans")
oranges_rg1 &lt;- ref_grid(oranges_lm1)
td &lt;- tidy(oranges_rg1)
td

# marginal averages
marginal &lt;- emmeans(oranges_rg1, "day")
tidy(marginal)

# contrasts
tidy(contrast(marginal))
tidy(contrast(marginal, method = "pairwise"))

# plot confidence intervals
library(ggplot2)

ggplot(tidy(marginal, conf.int = TRUE), aes(day, estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# by multiple prices
by_price &lt;- emmeans(oranges_lm1, "day",
  by = "price2",
  at = list(
    price1 = 50, price2 = c(40, 60, 80),
    day = c("2", "3", "4")
  )
)

by_price

tidy(by_price)

ggplot(tidy(by_price, conf.int = TRUE), aes(price2, estimate, color = day)) +
  geom_line() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# joint_tests
tidy(joint_tests(oranges_lm1))

</code></pre>

<hr>
<h2 id='tidy.manova'>Tidy a(n) manova object</h2><span id='topic+tidy.manova'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'manova'
tidy(x, test = "Pillai", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.manova_+3A_x">x</code></td>
<td>
<p>A <code>manova</code> object return from <code><a href="stats.html#topic+manova">stats::manova()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.manova_+3A_test">test</code></td>
<td>
<p>One of &quot;Pillai&quot; (Pillai's trace), &quot;Wilks&quot; (Wilk's lambda),
&quot;Hotelling-Lawley&quot; (Hotelling-Lawley trace) or &quot;Roy&quot; (Roy's greatest root)
indicating which test statistic should be used. Defaults to &quot;Pillai&quot;.</p>
</td></tr>
<tr><td><code id="tidy.manova_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="stats.html#topic+summary.manova">stats::summary.manova</a></code>
</p>

<dl>
<dt><code>object</code></dt><dd><p>An object of class <code>"manova"</code> or an <code>aov</code>
object with multiple responses.</p>
</dd>
<dt><code>intercept</code></dt><dd><p>logical.  If <code>TRUE</code>, the intercept term is
included in the table.</p>
</dd>
<dt><code>tol</code></dt><dd><p>tolerance to be used in deciding if the residuals are
rank-deficient: see <code><a href="base.html#topic+qr">qr</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on which test statistic is specified only one of <code>pillai</code>,
<code>wilks</code>, <code>hl</code> or <code>roy</code> is included.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>den.df</code></td>
<td>
<p>Degrees of freedom of the denominator.</p>
</td></tr>
<tr><td><code>num.df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>pillai</code></td>
<td>
<p>Pillai's trace.</p>
</td></tr>
<tr><td><code>wilks</code></td>
<td>
<p>Wilk's lambda.</p>
</td></tr>
<tr><td><code>hl</code></td>
<td>
<p>Hotelling-Lawley trace.</p>
</td></tr>
<tr><td><code>roy</code></td>
<td>
<p>Roy's greatest root.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+summary.manova">stats::summary.manova()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.anova">glance.anova</a>()</code>,
<code><a href="#topic+glance.aov">glance.aov</a>()</code>,
<code><a href="#topic+tidy.TukeyHSD">tidy.TukeyHSD</a>()</code>,
<code><a href="#topic+tidy.anova">tidy.anova</a>()</code>,
<code><a href="#topic+tidy.aovlist">tidy.aovlist</a>()</code>,
<code><a href="#topic+tidy.aov">tidy.aov</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
npk2 &lt;- within(npk, foo &lt;- rnorm(24))
m &lt;- manova(cbind(yield, foo) ~ block + N * P * K, npk2)
tidy(m)
</code></pre>

<hr>
<h2 id='tidy.map'>Tidy a(n) map object</h2><span id='topic+tidy.map'></span><span id='topic+maps_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.map_+3A_x">x</code></td>
<td>
<p>A <code>map</code> object returned from <code><a href="maps.html#topic+map">maps::map()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.map_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>long</code></td>
<td>
<p>Longitude.</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>Latitude.</p>
</td></tr>
</table>
<p>Remaining columns give information on geographic attributes
and depend on the inputted map object. See ?maps::map for more information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="maps.html#topic+map">maps::map()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(maps)
library(ggplot2)

ca &lt;- map("county", "ca", plot = FALSE, fill = TRUE)

tidy(ca)

qplot(long, lat, data = ca, geom = "polygon", group = group)

tx &lt;- map("county", "texas", plot = FALSE, fill = TRUE)
tidy(tx)
qplot(long, lat,
  data = tx, geom = "polygon", group = group,
  colour = I("white")
)

</code></pre>

<hr>
<h2 id='tidy.margins'>Tidy a(n) margins object</h2><span id='topic+tidy.margins'></span><span id='topic+margins_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'margins'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.margins_+3A_x">x</code></td>
<td>
<p>A <code>margins</code> object returned from <code>margins::margins()</code>.</p>
</td></tr>
<tr><td><code id="tidy.margins_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.margins_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.margins_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>margins</code> package provides a way to obtain coefficient marginal
effects for a variety of (non-linear) models, such as logit or models with
multiway interaction terms. Note that the <code>glance.margins()</code> method
requires rerunning the underlying model again, which can take some time.
Similarly, an <code>augment.margins()</code> method is not currently supported, but
users can simply run the underlying model to obtain the same information.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code>margins::margins()</code>
</p>

<hr>
<h2 id='tidy.Mclust'>Tidy a(n) Mclust object</h2><span id='topic+tidy.Mclust'></span><span id='topic+mclust_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Mclust'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.Mclust_+3A_x">x</code></td>
<td>
<p>An <code>Mclust</code> object return from <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.Mclust_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>proportion</code></td>
<td>
<p>The mixing proportion of each component</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Number of points assigned to cluster.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>The mean for each component. In case of 2+ dimensional models,
a column with the mean is added for each dimension. NA for noise
component</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>In case of one-dimensional and spherical models,
the variance for each component, omitted otherwise. NA for noise
component</p>
</td></tr>
<tr><td><code>component</code></td>
<td>
<p>Cluster id as a factor.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>
</p>
<p>Other mclust tidiers: 
<code><a href="#topic+augment.Mclust">augment.Mclust</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load library for models and data
library(mclust)

# load data manipulation libraries
library(dplyr)
library(tibble)
library(purrr)
library(tidyr)

set.seed(27)

centers &lt;- tibble(
  cluster = factor(1:3),
  # number points in each cluster
  num_points = c(100, 150, 50),
  # x1 coordinate of cluster center
  x1 = c(5, 0, -3),
  # x2 coordinate of cluster center
  x2 = c(-1, 1, -2)
)

points &lt;- centers %&gt;%
  mutate(
    x1 = map2(num_points, x1, rnorm),
    x2 = map2(num_points, x2, rnorm)
  ) %&gt;%
  select(-num_points, -cluster) %&gt;%
  unnest(c(x1, x2))

# fit model
m &lt;- Mclust(points)

# summarize model fit with tidiers
tidy(m)
augment(m, points)
glance(m)

</code></pre>

<hr>
<h2 id='tidy.mediate'>Tidy a(n) mediate object</h2><span id='topic+tidy.mediate'></span><span id='topic+mediate_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mediate'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mediate_+3A_x">x</code></td>
<td>
<p>A <code>mediate</code> object produced by a call to <code><a href="mediation.html#topic+mediate">mediation::mediate()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.mediate_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.mediate_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.mediate_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The tibble has four rows. The first two indicate the mediated
effect in the control and treatment groups, respectively. And the last
two the direct effect in each group.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="mediation.html#topic+mediate">mediation::mediate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mediation)

data(jobs)

# fit models
b &lt;- lm(job_seek ~ treat + econ_hard + sex + age, data = jobs)
c &lt;- lm(depress2 ~ treat + job_seek + econ_hard + sex + age, data = jobs)
mod &lt;- mediate(b, c, sims = 50, treat = "treat", mediator = "job_seek")

# summarize model fit with tidiers
tidy(mod)
tidy(mod, conf.int = TRUE)
tidy(mod, conf.int = TRUE, conf.level = .99)

</code></pre>

<hr>
<h2 id='tidy.mfx'>Tidy a(n) mfx object</h2><span id='topic+tidy.mfx'></span><span id='topic+tidy.logitmfx'></span><span id='topic+tidy.negbinmfx'></span><span id='topic+tidy.poissonmfx'></span><span id='topic+tidy.probitmfx'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>
<p>The particular functions below provide generic tidy methods for
objects returned by the <code>mfx</code> package, preserving the calculated marginal
effects instead of the naive model coefficients. The returned tidy tibble
will also include an additional &quot;atmean&quot; column indicating how the marginal
effects were originally calculated (see Details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfx'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'logitmfx'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'negbinmfx'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'poissonmfx'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'probitmfx'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mfx_+3A_x">x</code></td>
<td>
<p>A <code>logitmfx</code>, <code>negbinmfx</code>, <code>poissonmfx</code>, or <code>probitmfx</code>  object.
(Note that <code>betamfx</code> objects receive their own set of tidiers.)</p>
</td></tr>
<tr><td><code id="tidy.mfx_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.mfx_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.mfx_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>mfx</code> package provides methods for calculating marginal effects
for various generalized linear models (GLMs). Unlike standard linear
models, estimated model coefficients in a GLM cannot be directly
interpreted as marginal effects (i.e., the change in the response variable
predicted after a one unit change in one of the regressors). This is
because the estimated coefficients are multiplicative, dependent on both
the link function that was used for the estimation and any other variables
that were included in the model. When calculating marginal effects, users
must typically choose whether they want to use i) the average observation
in the data, or ii) the average of the sample marginal effects. See
<code>vignette("mfxarticle")</code> from the <code>mfx</code> package for more details.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>atmean</code></td>
<td>
<p>TRUE if the marginal effects were originally calculated as
the partial effects for the average observation. If FALSE, then these
were instead calculated as average partial effects.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="mfx.html#topic+logitmfx">mfx::logitmfx()</a></code>, <code><a href="mfx.html#topic+negbinmfx">mfx::negbinmfx()</a></code>, <code><a href="mfx.html#topic+poissonmfx">mfx::poissonmfx()</a></code>, <code><a href="mfx.html#topic+probitmfx">mfx::probitmfx()</a></code>
</p>
<p>Other mfx tidiers: 
<code><a href="#topic+augment.betamfx">augment.betamfx</a>()</code>,
<code><a href="#topic+augment.mfx">augment.mfx</a>()</code>,
<code><a href="#topic+glance.betamfx">glance.betamfx</a>()</code>,
<code><a href="#topic+glance.mfx">glance.mfx</a>()</code>,
<code><a href="#topic+tidy.betamfx">tidy.betamfx</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mfx)

# get the marginal effects from a logit regression
mod_logmfx &lt;- logitmfx(am ~ cyl + hp + wt, atmean = TRUE, data = mtcars)

tidy(mod_logmfx, conf.int = TRUE)

# compare with the naive model coefficients of the same logit call
tidy(
  glm(am ~ cyl + hp + wt, family = binomial, data = mtcars),
  conf.int = TRUE
)

augment(mod_logmfx)
glance(mod_logmfx)

# another example, this time using probit regression
mod_probmfx &lt;- probitmfx(am ~ cyl + hp + wt, atmean = TRUE, data = mtcars)

tidy(mod_probmfx, conf.int = TRUE)
augment(mod_probmfx)
glance(mod_probmfx)

</code></pre>

<hr>
<h2 id='tidy.mjoint'>Tidy a(n) mjoint object</h2><span id='topic+tidy.mjoint'></span><span id='topic+mjoint_tidiers'></span><span id='topic+joinerml_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mjoint'
tidy(
  x,
  component = "survival",
  conf.int = FALSE,
  conf.level = 0.95,
  boot_se = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mjoint_+3A_x">x</code></td>
<td>
<p>An <code>mjoint</code> object returned from <code><a href="joineRML.html#topic+mjoint">joineRML::mjoint()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.mjoint_+3A_component">component</code></td>
<td>
<p>Character specifying whether to tidy the survival or
the longitudinal component of the model. Must be either <code>"survival"</code> or
<code>"longitudinal"</code>. Defaults to <code>"survival"</code>.</p>
</td></tr>
<tr><td><code id="tidy.mjoint_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.mjoint_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.mjoint_+3A_boot_se">boot_se</code></td>
<td>
<p>Optionally a <code>bootSE</code> object from <code><a href="joineRML.html#topic+bootSE">joineRML::bootSE()</a></code>. If
specified, calculates confidence intervals via the bootstrap. Defaults to
<code>NULL</code>, in which case standard errors are calculated from the
empirical information matrix.</p>
</td></tr>
<tr><td><code id="tidy.mjoint_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="joineRML.html#topic+mjoint">joineRML::mjoint()</a></code>, <code><a href="joineRML.html#topic+bootSE">joineRML::bootSE()</a></code>
</p>
<p>Other mjoint tidiers: 
<code><a href="#topic+glance.mjoint">glance.mjoint</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# broom only skips running these examples because the example models take a
# while to generate—they should run just fine, though!
## Not run: 


# load libraries for models and data
library(joineRML)

# fit a joint model with bivariate longitudinal outcomes
data(heart.valve)

hvd &lt;- heart.valve[!is.na(heart.valve$log.grad) &amp;
  !is.na(heart.valve$log.lvmi) &amp;
  heart.valve$num &lt;= 50, ]

fit &lt;- mjoint(
  formLongFixed = list(
    "grad" = log.grad ~ time + sex + hs,
    "lvmi" = log.lvmi ~ time + sex
  ),
  formLongRandom = list(
    "grad" = ~ 1 | num,
    "lvmi" = ~ time | num
  ),
  formSurv = Surv(fuyrs, status) ~ age,
  data = hvd,
  inits = list("gamma" = c(0.11, 1.51, 0.80)),
  timeVar = "time"
)

# extract the survival fixed effects
tidy(fit)

# extract the longitudinal fixed effects
tidy(fit, component = "longitudinal")

# extract the survival fixed effects with confidence intervals
tidy(fit, ci = TRUE)

# extract the survival fixed effects with confidence intervals based
# on bootstrapped standard errors
bSE &lt;- bootSE(fit, nboot = 5, safe.boot = TRUE)
tidy(fit, boot_se = bSE, ci = TRUE)

# augment original data with fitted longitudinal values and residuals
hvd2 &lt;- augment(fit)

# extract model statistics
glance(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='tidy.mle2'>Tidy a(n) mle2 object</h2><span id='topic+tidy.mle2'></span><span id='topic+mle2_tidiers'></span><span id='topic+bbmle_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mle2'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mle2_+3A_x">x</code></td>
<td>
<p>An <code>mle2</code> object created by a call to <code><a href="bbmle.html#topic+mle2">bbmle::mle2()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.mle2_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.mle2_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.mle2_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="bbmle.html#topic+mle2">bbmle::mle2()</a></code>, <code><a href="#topic+tidy_optim">tidy_optim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(bbmle)

# generate data
x &lt;- 0:10
y &lt;- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
d &lt;- data.frame(x, y)

# fit model
fit &lt;- mle2(y ~ dpois(lambda = ymean),
  start = list(ymean = mean(y)), data = d
)

# summarize model fit with tidiers
tidy(fit)

</code></pre>

<hr>
<h2 id='tidy.mlm'>Tidy a(n) mlm object</h2><span id='topic+tidy.mlm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mlm_+3A_x">x</code></td>
<td>
<p>An <code>mlm</code> object created by <code><a href="stats.html#topic+lm">stats::lm()</a></code> with a matrix as the
response.</p>
</td></tr>
<tr><td><code id="tidy.mlm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.mlm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.mlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code>lm</code> object (simple linear model), tidy output for
<code>mlm</code> (multiple linear model) objects contain an additional column
<code>response</code>.
</p>
<p>If you have missing values in your model data, you may need to refit
the model with <code>na.action = na.exclude</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.summary.lm">tidy.summary.lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit model
mod &lt;- lm(cbind(mpg, disp) ~ wt, mtcars)

# summarize model fit with tidiers
tidy(mod, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='tidy.mlogit'>Tidying methods for logit models</h2><span id='topic+tidy.mlogit'></span><span id='topic+mlogit_tidiers'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of mnl and nl models generated
by the functions of the <code>mlogit</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlogit'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.mlogit_+3A_x">x</code></td>
<td>
<p>an object returned from <code><a href="mlogit.html#topic+mlogit">mlogit::mlogit()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.mlogit_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.mlogit_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.mlogit_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="mlogit.html#topic+mlogit">mlogit::mlogit()</a></code>
</p>
<p>Other mlogit tidiers: 
<code><a href="#topic+augment.mlogit">augment.mlogit</a>()</code>,
<code><a href="#topic+glance.mlogit">glance.mlogit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(mlogit)

data("Fishing", package = "mlogit")
Fish &lt;- dfidx(Fishing, varying = 2:9, shape = "wide", choice = "mode")

# fit model
m &lt;- mlogit(mode ~ price + catch | income, data = Fish)

# summarize model fit with tidiers
tidy(m)
augment(m)
glance(m)

</code></pre>

<hr>
<h2 id='tidy.muhaz'>Tidy a(n) muhaz object</h2><span id='topic+tidy.muhaz'></span><span id='topic+muhaz_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'muhaz'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.muhaz_+3A_x">x</code></td>
<td>
<p>A <code>muhaz</code> object returned by <code><a href="muhaz.html#topic+muhaz">muhaz::muhaz()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.muhaz_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Point in time.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimated hazard rate.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="muhaz.html#topic+muhaz">muhaz::muhaz()</a></code>
</p>
<p>Other muhaz tidiers: 
<code><a href="#topic+glance.muhaz">glance.muhaz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(muhaz)
library(survival)

# fit model
x &lt;- muhaz(ovarian$futime, ovarian$fustat)

# summarize model fit with tidiers
tidy(x)
glance(x)

</code></pre>

<hr>
<h2 id='tidy.multinom'>Tidying methods for multinomial logistic regression models</h2><span id='topic+tidy.multinom'></span><span id='topic+multinom_tidiers'></span><span id='topic+nnet_tidiers'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of multinomial logistic regression
models generated by <code>multinom</code> of the <code>nnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multinom'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.multinom_+3A_x">x</code></td>
<td>
<p>A <code>multinom</code> object returned from <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.multinom_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.multinom_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.multinom_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.multinom_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>y.value</code></td>
<td>
<p>The response level.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="nnet.html#topic+multinom">nnet::multinom()</a></code>
</p>
<p>Other multinom tidiers: 
<code><a href="#topic+glance.multinom">glance.multinom</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(nnet)
library(MASS)

example(birthwt)

bwt.mu &lt;- multinom(low ~ ., bwt)

tidy(bwt.mu)
glance(bwt.mu)

# or, for output from a multinomial logistic regression
fit.gear &lt;- multinom(gear ~ mpg + factor(am), data = mtcars)
tidy(fit.gear)
glance(fit.gear)

</code></pre>

<hr>
<h2 id='tidy.negbin'>Tidy a(n) negbin object</h2><span id='topic+tidy.negbin'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'negbin'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.negbin_+3A_x">x</code></td>
<td>
<p>A <code>glm.nb</code> object returned by <code><a href="MASS.html#topic+glm.nb">MASS::glm.nb()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.negbin_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.negbin_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.negbin_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.negbin_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+glm.nb">MASS::glm.nb()</a></code>
</p>
<p>Other glm.nb tidiers: 
<code><a href="#topic+glance.negbin">glance.negbin</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
r &lt;- glm.nb(Days ~ Sex / (Age + Eth * Lrn), data = quine)

# summarize model fit with tidiers
tidy(r)
glance(r)

</code></pre>

<hr>
<h2 id='tidy.nlrq'>Tidy a(n) nlrq object</h2><span id='topic+tidy.nlrq'></span><span id='topic+nlrq_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlrq'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.nlrq_+3A_x">x</code></td>
<td>
<p>A <code>nlrq</code> object returned from <code><a href="quantreg.html#topic+nlrq">quantreg::nlrq()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.nlrq_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.nlrq_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.nlrq_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="quantreg.html#topic+nlrq">quantreg::nlrq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(quantreg)

# build artificial data with multiplicative error
set.seed(1)
dat &lt;- NULL
dat$x &lt;- rep(1:25, 20)
dat$y &lt;- SSlogis(dat$x, 10, 12, 2) * rnorm(500, 1, 0.1)

# fit the median using nlrq
mod &lt;- nlrq(y ~ SSlogis(x, Asym, mid, scal),
  data = dat, tau = 0.5, trace = TRUE
)

# summarize model fit with tidiers
tidy(mod)
glance(mod)
augment(mod)

</code></pre>

<hr>
<h2 id='tidy.nls'>Tidy a(n) nls object</h2><span id='topic+tidy.nls'></span><span id='topic+nls_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nls'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.nls_+3A_x">x</code></td>
<td>
<p>An <code>nls</code> object returned from <code><a href="stats.html#topic+nls">stats::nls()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.nls_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.nls_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.nls_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="stats.html#topic+nls">stats::nls()</a></code>, <code><a href="stats.html#topic+summary.nls">stats::summary.nls()</a></code>
</p>
<p>Other nls tidiers: 
<code><a href="#topic+augment.nls">augment.nls</a>()</code>,
<code><a href="#topic+glance.nls">glance.nls</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit model
n &lt;- nls(mpg ~ k * e^wt, data = mtcars, start = list(k = 1, e = 2))

# summarize model fit with tidiers + visualization
tidy(n)
augment(n)
glance(n)

library(ggplot2)

ggplot(augment(n), aes(wt, mpg)) +
  geom_point() +
  geom_line(aes(y = .fitted))

newdata &lt;- head(mtcars)
newdata$wt &lt;- newdata$wt + 1

augment(n, newdata = newdata)

</code></pre>

<hr>
<h2 id='tidy.numeric'>Tidy atomic vectors</h2><span id='topic+tidy.numeric'></span><span id='topic+tidy.character'></span><span id='topic+tidy.logical'></span>

<h3>Description</h3>

<p>Vector tidiers are deprecated and will be removed from an upcoming release
of broom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
tidy(x, ...)

## S3 method for class 'character'
tidy(x, ...)

## S3 method for class 'logical'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.numeric_+3A_x">x</code></td>
<td>
<p>An object of class &quot;numeric&quot;, &quot;integer&quot;, &quot;character&quot;, or &quot;logical&quot;.
Most likely a named vector</p>
</td></tr>
<tr><td><code id="tidy.numeric_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Turn atomic vectors into data frames, where the names of the vector (if they
exist) are a column and the values of the vector are a column.
</p>


<h3>See Also</h3>

<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>
</p>
<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>
</p>
<p>Other deprecated: 
<code><a href="#topic+bootstrap">bootstrap</a>()</code>,
<code><a href="#topic+confint_tidy">confint_tidy</a>()</code>,
<code><a href="#topic+data.frame_tidiers">data.frame_tidiers</a></code>,
<code><a href="#topic+finish_glance">finish_glance</a>()</code>,
<code><a href="#topic+fix_data_frame">fix_data_frame</a>()</code>,
<code><a href="#topic+summary_tidiers">summary_tidiers</a></code>,
<code><a href="#topic+tidy.density">tidy.density</a>()</code>,
<code><a href="#topic+tidy.dist">tidy.dist</a>()</code>,
<code><a href="#topic+tidy.ftable">tidy.ftable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
x &lt;- 1:5
names(x) &lt;- letters[1:5]
tidy(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='tidy.orcutt'>Tidy a(n) orcutt object</h2><span id='topic+tidy.orcutt'></span><span id='topic+orcutt_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orcutt'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.orcutt_+3A_x">x</code></td>
<td>
<p>An <code>orcutt</code> object returned from <code><a href="orcutt.html#topic+cochrane.orcutt">orcutt::cochrane.orcutt()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.orcutt_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="orcutt.html#topic+cochrane.orcutt">orcutt::cochrane.orcutt()</a></code>
</p>
<p>Other orcutt tidiers: 
<code><a href="#topic+glance.orcutt">glance.orcutt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(orcutt)

# fit model and summarize results
reg &lt;- lm(mpg ~ wt + qsec + disp, mtcars)
tidy(reg)


co &lt;- cochrane.orcutt(reg)
tidy(co)
glance(co)

</code></pre>

<hr>
<h2 id='tidy.pairwise.htest'>Tidy a(n) pairwise.htest object</h2><span id='topic+tidy.pairwise.htest'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pairwise.htest'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.pairwise.htest_+3A_x">x</code></td>
<td>
<p>A <code>pairwise.htest</code> object such as those returned from
<code><a href="stats.html#topic+pairwise.t.test">stats::pairwise.t.test()</a></code> or <code><a href="stats.html#topic+pairwise.wilcox.test">stats::pairwise.wilcox.test()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.pairwise.htest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in one-sided tests, the alternative hypothesis of each
test can be stated as &quot;group1 is greater/less than group2&quot;.
</p>
<p>Note also that the columns of group1 and group2 will always be a factor,
even if the original input is (e.g.) numeric.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>group1</code></td>
<td>
<p>First group being compared.</p>
</td></tr>
<tr><td><code>group2</code></td>
<td>
<p>Second group being compared.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pairwise.t.test">stats::pairwise.t.test()</a></code>, <code><a href="stats.html#topic+pairwise.wilcox.test">stats::pairwise.wilcox.test()</a></code>,
<code><a href="#topic+tidy">tidy()</a></code>
</p>
<p>Other htest tidiers: 
<code><a href="#topic+augment.htest">augment.htest</a>()</code>,
<code><a href="#topic+tidy.htest">tidy.htest</a>()</code>,
<code><a href="#topic+tidy.power.htest">tidy.power.htest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

attach(airquality)
Month &lt;- factor(Month, labels = month.abb[5:9])
ptt &lt;- pairwise.t.test(Ozone, Month)
tidy(ptt)

library(modeldata)
data(hpc_data)
attach(hpc_data)
ptt2 &lt;- pairwise.t.test(compounds, class)
tidy(ptt2)

tidy(pairwise.t.test(compounds, class, alternative = "greater"))
tidy(pairwise.t.test(compounds, class, alternative = "less"))

tidy(pairwise.wilcox.test(compounds, class))

</code></pre>

<hr>
<h2 id='tidy.pam'>Tidy a(n) pam object</h2><span id='topic+tidy.pam'></span><span id='topic+pam_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pam'
tidy(x, col.names = paste0("x", 1:ncol(x$medoids)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.pam_+3A_x">x</code></td>
<td>
<p>An <code>pam</code> object returned from <code><a href="cluster.html#topic+pam">cluster::pam()</a></code></p>
</td></tr>
<tr><td><code id="tidy.pam_+3A_col.names">col.names</code></td>
<td>
<p>Column names in the input data frame.
Defaults to the names of the variables in x.</p>
</td></tr>
<tr><td><code id="tidy.pam_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For examples, see the pam vignette.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>size</code></td>
<td>
<p>Size of each cluster.</p>
</td></tr>
<tr><td><code>max.diss</code></td>
<td>
<p>Maximal dissimilarity between the observations in the
cluster and that cluster's medoid.</p>
</td></tr>
<tr><td><code>avg.diss</code></td>
<td>
<p>Average dissimilarity between the observations in the
cluster and that cluster's medoid.</p>
</td></tr>
<tr><td><code>diameter</code></td>
<td>
<p>Diameter of the cluster.</p>
</td></tr>
<tr><td><code>separation</code></td>
<td>
<p>Separation of the cluster.</p>
</td></tr>
<tr><td><code>avg.width</code></td>
<td>
<p>Average silhouette width of the cluster.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>A factor describing the cluster from 1:k.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>
<p>Other pam tidiers: 
<code><a href="#topic+augment.pam">augment.pam</a>()</code>,
<code><a href="#topic+glance.pam">glance.pam</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(dplyr)
library(ggplot2)
library(cluster)
library(modeldata)
data(hpc_data)

x &lt;- hpc_data[, 2:5]
p &lt;- pam(x, k = 4)

# summarize model fit with tidiers + visualization
tidy(p)
glance(p)
augment(p, x)

augment(p, x) %&gt;%
  ggplot(aes(compounds, input_fields)) +
  geom_point(aes(color = .cluster)) +
  geom_text(aes(label = cluster), data = tidy(p), size = 10)

</code></pre>

<hr>
<h2 id='tidy.plm'>Tidy a(n) plm object</h2><span id='topic+tidy.plm'></span><span id='topic+plm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.plm_+3A_x">x</code></td>
<td>
<p>A <code>plm</code> objected returned by <code><a href="plm.html#topic+plm">plm::plm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.plm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.plm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.plm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="plm.html#topic+plm">plm::plm()</a></code>, <code><a href="#topic+tidy.lm">tidy.lm()</a></code>
</p>
<p>Other plm tidiers: 
<code><a href="#topic+augment.plm">augment.plm</a>()</code>,
<code><a href="#topic+glance.plm">glance.plm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(plm)

# load data
data("Produc", package = "plm")

# fit model
zz &lt;- plm(log(gsp) ~ log(pcap) + log(pc) + log(emp) + unemp,
  data = Produc, index = c("state", "year")
)

# summarize model fit with tidiers
summary(zz)

tidy(zz)
tidy(zz, conf.int = TRUE)
tidy(zz, conf.int = TRUE, conf.level = 0.9)

augment(zz)
glance(zz)

</code></pre>

<hr>
<h2 id='tidy.poLCA'>Tidy a(n) poLCA object</h2><span id='topic+tidy.poLCA'></span><span id='topic+poLCA_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poLCA'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.poLCA_+3A_x">x</code></td>
<td>
<p>A <code>poLCA</code> object returned from <code><a href="poLCA.html#topic+poLCA">poLCA::poLCA()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.poLCA_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>class</code></td>
<td>
<p>The class under consideration.</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>Outcome of manifest variable.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>variable</code></td>
<td>
<p>Manifest variable</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimated class-conditional response probability</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="poLCA.html#topic+poLCA">poLCA::poLCA()</a></code>
</p>
<p>Other poLCA tidiers: 
<code><a href="#topic+augment.poLCA">augment.poLCA</a>()</code>,
<code><a href="#topic+glance.poLCA">glance.poLCA</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(poLCA)
library(dplyr)

# generate data
data(values)

f &lt;- cbind(A, B, C, D) ~ 1

# fit model
M1 &lt;- poLCA(f, values, nclass = 2, verbose = FALSE)

M1

# summarize model fit with tidiers + visualization
tidy(M1)
augment(M1)
glance(M1)

library(ggplot2)

ggplot(tidy(M1), aes(factor(class), estimate, fill = factor(outcome))) +
  geom_bar(stat = "identity", width = 1) +
  facet_wrap(~variable)

# three-class model with a single covariate.
data(election)

f2a &lt;- cbind(
  MORALG, CARESG, KNOWG, LEADG, DISHONG, INTELG,
  MORALB, CARESB, KNOWB, LEADB, DISHONB, INTELB
) ~ PARTY

nes2a &lt;- poLCA(f2a, election, nclass = 3, nrep = 5, verbose = FALSE)

td &lt;- tidy(nes2a)
td

ggplot(td, aes(outcome, estimate, color = factor(class), group = class)) +
  geom_line() +
  facet_wrap(~variable, nrow = 2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

au &lt;- augment(nes2a)

au

count(au, .class)

# if the original data is provided, it leads to NAs in new columns
# for rows that weren't predicted
au2 &lt;- augment(nes2a, data = election)

au2

dim(au2)

</code></pre>

<hr>
<h2 id='tidy.polr'>Tidy a(n) polr object</h2><span id='topic+tidy.polr'></span><span id='topic+polr_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'polr'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  p.values = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.polr_+3A_x">x</code></td>
<td>
<p>A <code>polr</code> object returned from <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.polr_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.polr_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.polr_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.polr_+3A_p.values">p.values</code></td>
<td>
<p>Logical. Should p-values be returned,
based on chi-squared tests from <code><a href="MASS.html#topic+dropterm">MASS::dropterm()</a></code>. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="tidy.polr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code style="white-space: pre;">&#8288;broom 0.7.0&#8288;</code> the <code>coefficient_type</code> column was renamed to
<code>coef.type</code>, and the contents were changed as well. Now the contents
are <code>coefficient</code> and <code>scale</code>, rather than <code>coefficient</code> and <code>zeta</code>.
</p>
<p>Calculating p.values with the <code>dropterm()</code> function is the approach
suggested by the MASS package author. This
approach is computationally intensive so that p.values are only
returned if requested explicitly. Additionally, it only works for
models containing no variables with more than two categories. If this
condition is not met, a message is shown and NA is returned instead of
p-values.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="MASS.html#topic+polr">MASS::polr()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.svyolr">tidy.svyolr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

# fit model
fit &lt;- polr(Sat ~ Infl + Type + Cont, weights = Freq, data = housing)

# summarize model fit with tidiers
tidy(fit, exponentiate = TRUE, conf.int = TRUE)

glance(fit)
augment(fit, type.predict = "class")

fit2 &lt;- polr(factor(gear) ~ am + mpg + qsec, data = mtcars)

tidy(fit, p.values = TRUE)

</code></pre>

<hr>
<h2 id='tidy.power.htest'>Tidy a(n) power.htest object</h2><span id='topic+tidy.power.htest'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'power.htest'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.power.htest_+3A_x">x</code></td>
<td>
<p>A <code>power.htest</code> object such as those returned from
<code><a href="stats.html#topic+power.t.test">stats::power.t.test()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.power.htest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p>True difference in means.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations by component.</p>
</td></tr>
<tr><td><code>power</code></td>
<td>
<p>Power achieved for given value of n.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Standard deviation.</p>
</td></tr>
<tr><td><code>sig.level</code></td>
<td>
<p>Significance level (Type I error probability).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power.t.test">stats::power.t.test()</a></code>
</p>
<p>Other htest tidiers: 
<code><a href="#topic+augment.htest">augment.htest</a>()</code>,
<code><a href="#topic+tidy.htest">tidy.htest</a>()</code>,
<code><a href="#topic+tidy.pairwise.htest">tidy.pairwise.htest</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

ptt &lt;- power.t.test(n = 2:30, delta = 1)
tidy(ptt)

library(ggplot2)

ggplot(tidy(ptt), aes(n, power)) +
  geom_line()

</code></pre>

<hr>
<h2 id='tidy.prcomp'>Tidy a(n) prcomp object</h2><span id='topic+tidy.prcomp'></span><span id='topic+prcomp_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcomp'
tidy(x, matrix = "u", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.prcomp_+3A_x">x</code></td>
<td>
<p>A <code>prcomp</code> object returned by <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.prcomp_+3A_matrix">matrix</code></td>
<td>
<p>Character specifying which component of the PCA should be
tidied.
</p>

<ul>
<li> <p><code>"u"</code>, <code>"samples"</code>, <code>"scores"</code>, or <code>"x"</code>: returns information about
the map from the original space into principle components space.
</p>
</li>
<li> <p><code>"v"</code>, <code>"rotation"</code>, <code>"loadings"</code> or <code>"variables"</code>: returns information
about the map from principle components space back into the original
space.
</p>
</li>
<li> <p><code>"d"</code>, <code>"eigenvalues"</code> or <code>"pcs"</code>: returns information about the
eigenvalues.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tidy.prcomp_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See https://stats.stackexchange.com/questions/134282/relationship-between-svd-and-pca-how-to-use-svd-to-perform-pca
for information on how to interpret the various tidied matrices. Note
that SVD is only equivalent to PCA on centered data.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> with columns depending on the component of
PCA being tidied.
</p>
<p>If <code>matrix</code> is <code>"u"</code>, <code>"samples"</code>, <code>"scores"</code>, or <code>"x"</code> each row in the
tidied output corresponds to the original data in PCA space. The columns
are:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>ID of the original observation (i.e. rowname from original
data).</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>Integer indicating a principal component.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The score of the observation for that particular principal
component. That is, the location of the observation in PCA space.</p>
</td></tr>
</table>
<p>If <code>matrix</code> is <code>"v"</code>, <code>"rotation"</code>, <code>"loadings"</code> or <code>"variables"</code>, each
row in the tidied output corresponds to information about the principle
components in the original space. The columns are:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>The variable labels (colnames) of the data set on
which PCA was performed.</p>
</td></tr>
<tr><td><code>PC</code></td>
<td>
<p>An integer vector indicating the principal component.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the eigenvector (axis score) on the
indicated principal component.</p>
</td></tr>
</table>
<p>If <code>matrix</code> is <code>"d"</code>, <code>"eigenvalues"</code> or <code>"pcs"</code>, the columns are:
</p>
<table>
<tr><td><code>PC</code></td>
<td>
<p>An integer vector indicating the principal component.</p>
</td></tr>
<tr><td><code>std.dev</code></td>
<td>
<p>Standard deviation explained by this PC.</p>
</td></tr>
<tr><td><code>percent</code></td>
<td>
<p>Fraction of variation explained by this component
(a numeric value between 0 and 1).</p>
</td></tr>
<tr><td><code>cumulative</code></td>
<td>
<p>Cumulative fraction of variation explained by
principle components up to this component (a numeric value between 0 and
1).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>, <a href="#topic+svd_tidiers">svd_tidiers</a>
</p>
<p>Other svd tidiers: 
<code><a href="#topic+augment.prcomp">augment.prcomp</a>()</code>,
<code><a href="#topic+tidy_irlba">tidy_irlba</a>()</code>,
<code><a href="#topic+tidy_svd">tidy_svd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

pc &lt;- prcomp(USArrests, scale = TRUE)

# information about rotation
tidy(pc)

# information about samples (states)
tidy(pc, "samples")

# information about PCs
tidy(pc, "pcs")

# state map
library(dplyr)
library(ggplot2)
library(maps)

pc %&gt;%
  tidy(matrix = "samples") %&gt;%
  mutate(region = tolower(row)) %&gt;%
  inner_join(map_data("state"), by = "region") %&gt;%
  ggplot(aes(long, lat, group = group, fill = value)) +
  geom_polygon() +
  facet_wrap(~PC) +
  theme_void() +
  ggtitle("Principal components of arrest data")

au &lt;- augment(pc, data = USArrests)

au

ggplot(au, aes(.fittedPC1, .fittedPC2)) +
  geom_point() +
  geom_text(aes(label = .rownames), vjust = 1, hjust = 1)

</code></pre>

<hr>
<h2 id='tidy.pyears'>Tidy a(n) pyears object</h2><span id='topic+tidy.pyears'></span><span id='topic+pyears_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pyears'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.pyears_+3A_x">x</code></td>
<td>
<p>A <code>pyears</code> object returned from <code><a href="survival.html#topic+pyears">survival::pyears()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.pyears_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>expected</code> is only present in the output when if a <code>ratetable</code>
term is present.
</p>
<p>If the <code>data.frame = TRUE</code> argument is supplied to <code>pyears</code>,
this is simply the contents of <code>x$data</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>expected</code></td>
<td>
<p>Expected number of events.</p>
</td></tr>
<tr><td><code>pyears</code></td>
<td>
<p>Person-years of exposure.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of subjects contributing time</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>observed number of events</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+pyears">survival::pyears()</a></code>
</p>
<p>Other pyears tidiers: 
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# generate and format data
temp.yr &lt;- tcut(mgus$dxyr, 55:92, labels = as.character(55:91))
temp.age &lt;- tcut(mgus$age, 34:101, labels = as.character(34:100))
ptime &lt;- ifelse(is.na(mgus$pctime), mgus$futime, mgus$pctime)
pstat &lt;- ifelse(is.na(mgus$pctime), 0, 1)
pfit &lt;- pyears(Surv(ptime / 365.25, pstat) ~ temp.yr + temp.age + sex, mgus,
  data.frame = TRUE
)

# summarize model fit with tidiers
tidy(pfit)
glance(pfit)

# if data.frame argument is not given, different information is present in
# output
pfit2 &lt;- pyears(Surv(ptime / 365.25, pstat) ~ temp.yr + temp.age + sex, mgus)

tidy(pfit2)
glance(pfit2)

</code></pre>

<hr>
<h2 id='tidy.rcorr'>Tidy a(n) rcorr object</h2><span id='topic+tidy.rcorr'></span><span id='topic+rcorr_tidiers'></span><span id='topic+Hmisc_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rcorr'
tidy(x, diagonal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.rcorr_+3A_x">x</code></td>
<td>
<p>An <code>rcorr</code> object returned from <code><a href="Hmisc.html#topic+rcorr">Hmisc::rcorr()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.rcorr_+3A_diagonal">diagonal</code></td>
<td>
<p>Logical indicating whether or not to include diagonal
elements of the correlation matrix, or the correlation of a column with
itself. For the elements, <code>estimate</code> is always 1 and <code>p.value</code> is always
<code>NA</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rcorr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose the original data has columns A and B. In the correlation
matrix from <code>rcorr</code> there may be entries for both the <code>cor(A, B)</code> and
<code>cor(B, A)</code>. Only one of these pairs will ever be present in the tidy
output.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>column1</code></td>
<td>
<p>Name or index of the first column being described.</p>
</td></tr>
<tr><td><code>column2</code></td>
<td>
<p>Name or index of the second column being described.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Number of observations used to compute the correlation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="Hmisc.html#topic+rcorr">Hmisc::rcorr()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(Hmisc)

mat &lt;- replicate(52, rnorm(100))

# add some NAs
mat[sample(length(mat), 2000)] &lt;- NA

# also, column names
colnames(mat) &lt;- c(LETTERS, letters)

# fit model
rc &lt;- rcorr(mat)

# summarize model fit with tidiers  + visualization
td &lt;- tidy(rc)
td

library(ggplot2)
ggplot(td, aes(p.value)) +
  geom_histogram(binwidth = .1)

ggplot(td, aes(estimate, p.value)) +
  geom_point() +
  scale_y_log10()

</code></pre>

<hr>
<h2 id='tidy.ref.grid'>Tidy a(n) ref.grid object</h2><span id='topic+tidy.ref.grid'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ref.grid'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ref.grid_+3A_x">x</code></td>
<td>
<p>A <code>ref.grid</code> object created by <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.ref.grid_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.ref.grid_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.ref.grid_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or
<code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>. <strong>Cautionary note</strong>: misspecified arguments
may be silently ignored!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data frame with one observation for each estimated marginal
mean, and one column for each combination of factors. When the input is a
contrast, each row will contain one estimated contrast.
</p>
<p>There are a large number of arguments that can be
passed on to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or <code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Expected marginal mean</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>T-ratio statistic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code>, <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>,
<code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code>
</p>
<p>Other emmeans tidiers: 
<code><a href="#topic+tidy.emmGrid">tidy.emmGrid</a>()</code>,
<code><a href="#topic+tidy.lsmobj">tidy.lsmobj</a>()</code>,
<code><a href="#topic+tidy.summary_emm">tidy.summary_emm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(emmeans)

# linear model for sales of oranges per day
oranges_lm1 &lt;- lm(sales1 ~ price1 + price2 + day + store, data = oranges)

# reference grid; see vignette("basics", package = "emmeans")
oranges_rg1 &lt;- ref_grid(oranges_lm1)
td &lt;- tidy(oranges_rg1)
td

# marginal averages
marginal &lt;- emmeans(oranges_rg1, "day")
tidy(marginal)

# contrasts
tidy(contrast(marginal))
tidy(contrast(marginal, method = "pairwise"))

# plot confidence intervals
library(ggplot2)

ggplot(tidy(marginal, conf.int = TRUE), aes(day, estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# by multiple prices
by_price &lt;- emmeans(oranges_lm1, "day",
  by = "price2",
  at = list(
    price1 = 50, price2 = c(40, 60, 80),
    day = c("2", "3", "4")
  )
)

by_price

tidy(by_price)

ggplot(tidy(by_price, conf.int = TRUE), aes(price2, estimate, color = day)) +
  geom_line() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# joint_tests
tidy(joint_tests(oranges_lm1))

</code></pre>

<hr>
<h2 id='tidy.regsubsets'>Tidy a(n) regsubsets object</h2><span id='topic+tidy.regsubsets'></span><span id='topic+leaps_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regsubsets'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.regsubsets_+3A_x">x</code></td>
<td>
<p>A <code>regsubsets</code> object created by <code><a href="leaps.html#topic+regsubsets">leaps::regsubsets()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.regsubsets_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>r.squared</code></td>
<td>
<p>R squared statistic, or the percent of variation explained by the model.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>Adjusted R squared statistic</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian information criterion for the component.</p>
</td></tr>
<tr><td><code>mallows_cp</code></td>
<td>
<p>Mallow's Cp statistic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="leaps.html#topic+regsubsets">leaps::regsubsets()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(leaps)

# fit model
all_fits &lt;- regsubsets(hp ~ ., mtcars)

# summarize model fit with tidiers
tidy(all_fits)

</code></pre>

<hr>
<h2 id='tidy.ridgelm'>Tidy a(n) ridgelm object</h2><span id='topic+tidy.ridgelm'></span><span id='topic+ridgelm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ridgelm'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ridgelm_+3A_x">x</code></td>
<td>
<p>A <code>ridgelm</code> object returned from <code><a href="MASS.html#topic+lm.ridge">MASS::lm.ridge()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.ridgelm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized cross validation error estimate.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Value of penalty parameter lambda.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimate of scaled coefficient using this lambda</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>Scaling factor of estimated coefficient</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="MASS.html#topic+lm.ridge">MASS::lm.ridge()</a></code>
</p>
<p>Other ridgelm tidiers: 
<code><a href="#topic+glance.ridgelm">glance.ridgelm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(MASS)

names(longley)[1] &lt;- "y"

# fit model and summarizd results
fit1 &lt;- lm.ridge(y ~ ., longley)
tidy(fit1)

fit2 &lt;- lm.ridge(y ~ ., longley, lambda = seq(0.001, .05, .001))
td2 &lt;- tidy(fit2)
g2 &lt;- glance(fit2)

# coefficient plot
library(ggplot2)
ggplot(td2, aes(lambda, estimate, color = term)) +
  geom_line()

# GCV plot
ggplot(td2, aes(lambda, GCV)) +
  geom_line()

# add line for the GCV minimizing estimate
ggplot(td2, aes(lambda, GCV)) +
  geom_line() +
  geom_vline(xintercept = g2$lambdaGCV, col = "red", lty = 2)

</code></pre>

<hr>
<h2 id='tidy.rlm'>Tidy a(n) rlm object</h2><span id='topic+tidy.rlm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.rlm_+3A_x">x</code></td>
<td>
<p>An <code>rlm</code> object returned by <code><a href="MASS.html#topic+rlm">MASS::rlm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.rlm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rlm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.rlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+rlm">MASS::rlm()</a></code>
</p>
<p>Other rlm tidiers: 
<code><a href="#topic+augment.rlm">augment.rlm</a>()</code>,
<code><a href="#topic+glance.rlm">glance.rlm</a>()</code>
</p>

<hr>
<h2 id='tidy.rma'>Tidy a(n) rma object</h2><span id='topic+tidy.rma'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rma'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  include_studies = FALSE,
  measure = "GEN",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.rma_+3A_x">x</code></td>
<td>
<p>An <code>rma</code> object such as those created by <code><a href="metafor.html#topic+rma.uni">metafor::rma()</a></code>,
<code><a href="metafor.html#topic+rma.uni">metafor::rma.uni()</a></code>, <code><a href="metafor.html#topic+rma.glmm">metafor::rma.glmm()</a></code>, <code><a href="metafor.html#topic+rma.mh">metafor::rma.mh()</a></code>,
<code><a href="metafor.html#topic+rma.mv">metafor::rma.mv()</a></code>, or <code><a href="metafor.html#topic+rma.peto">metafor::rma.peto()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.rma_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rma_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.rma_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rma_+3A_include_studies">include_studies</code></td>
<td>
<p>Logical. Should individual studies be included in the
output? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rma_+3A_measure">measure</code></td>
<td>
<p>Measure type. See <code><a href="metafor.html#topic+escalc">metafor::escalc()</a></code></p>
</td></tr>
<tr><td><code id="tidy.rma_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the individual study</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The estimate type  (summary vs individual study)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(metafor)

df &lt;-
  escalc(
    measure = "RR",
    ai = tpos,
    bi = tneg,
    ci = cpos,
    di = cneg,
    data = dat.bcg
  )

meta_analysis &lt;- rma(yi, vi, data = df, method = "EB")

tidy(meta_analysis)

</code></pre>

<hr>
<h2 id='tidy.roc'>Tidy a(n) roc object</h2><span id='topic+tidy.roc'></span><span id='topic+auc_tidiers'></span><span id='topic+roc_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'roc'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.roc_+3A_x">x</code></td>
<td>
<p>An <code>roc</code> object returned from a call to <code><a href="AUC.html#topic+roc">AUC::roc()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.roc_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>cutoff</code></td>
<td>
<p>The cutoff used for classification. Observations with predicted probabilities above this value were assigned class 1, and observations with predicted probabilities below this value were assigned class 0.</p>
</td></tr>
<tr><td><code>fpr</code></td>
<td>
<p>False positive rate.</p>
</td></tr>
<tr><td><code>tpr</code></td>
<td>
<p>The true positive rate at the given cutoff.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="AUC.html#topic+roc">AUC::roc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(AUC)

# load data
data(churn)

# fit model
r &lt;- roc(churn$predictions, churn$labels)

# summarize with tidiers + visualization
td &lt;- tidy(r)
td

library(ggplot2)

ggplot(td, aes(fpr, tpr)) +
  geom_line()

# compare the ROC curves for two prediction algorithms
library(dplyr)
library(tidyr)

rocs &lt;- churn %&gt;%
  pivot_longer(contains("predictions"),
    names_to = "algorithm",
    values_to = "value"
  ) %&gt;%
  nest(data = -algorithm) %&gt;%
  mutate(tidy_roc = purrr::map(data, ~ tidy(roc(.x$value, .x$labels)))) %&gt;%
  unnest(tidy_roc)

ggplot(rocs, aes(fpr, tpr, color = algorithm)) +
  geom_line()

</code></pre>

<hr>
<h2 id='tidy.rq'>Tidy a(n) rq object</h2><span id='topic+tidy.rq'></span><span id='topic+rq_tidiers'></span><span id='topic+quantreg_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rq'
tidy(x, se.type = NULL, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.rq_+3A_x">x</code></td>
<td>
<p>An <code>rq</code> object returned from <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.rq_+3A_se.type">se.type</code></td>
<td>
<p>Character specifying the method to use to calculate
standard errors. Passed to <code><a href="quantreg.html#topic+summary.rq">quantreg::summary.rq()</a></code> <code>se</code> argument.
Defaults to <code>"rank"</code> if the sample size is less than 1000,
otherwise defaults to <code>"nid"</code>.</p>
</td></tr>
<tr><td><code id="tidy.rq_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rq_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.rq_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="quantreg.html#topic+summary.rq">quantreg::summary.rq()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>se.type = "rank"</code> confidence intervals are calculated by
<code>summary.rq</code> and <code>statistic</code> and <code>p.value</code> values are not returned.
When only a single predictor is included in the model,
no confidence intervals are calculated and the confidence limits are
set to NA.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rqs">tidy.rqs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library and data
library(quantreg)

data(stackloss)

# median (l1) regression fit for the stackloss data.
mod1 &lt;- rq(stack.loss ~ stack.x, .5)

# weighted sample median
mod2 &lt;- rq(rnorm(50) ~ 1, weights = runif(50))

# summarize model fit with tidiers
tidy(mod1)
glance(mod1)
augment(mod1)

tidy(mod2)
glance(mod2)
augment(mod2)

# varying tau to generate an rqs object
mod3 &lt;- rq(stack.loss ~ stack.x, tau = c(.25, .5))

tidy(mod3)
augment(mod3)

# glance cannot handle rqs objects like `mod3`--use a purrr
# `map`-based workflow instead

</code></pre>

<hr>
<h2 id='tidy.rqs'>Tidy a(n) rqs object</h2><span id='topic+tidy.rqs'></span><span id='topic+rqs_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqs'
tidy(x, se.type = "rank", conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.rqs_+3A_x">x</code></td>
<td>
<p>An <code>rqs</code> object returned from <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.rqs_+3A_se.type">se.type</code></td>
<td>
<p>Character specifying the method to use to calculate
standard errors. Passed to <code><a href="quantreg.html#topic+summary.rq">quantreg::summary.rq()</a></code> <code>se</code> argument.
Defaults to <code>"rank"</code>.</p>
</td></tr>
<tr><td><code id="tidy.rqs_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rqs_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.rqs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="quantreg.html#topic+summary.rq">quantreg::summary.rqs()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>se.type = "rank"</code> confidence intervals are calculated by
<code>summary.rq</code>. When only a single predictor is included in the model,
no confidence intervals are calculated and the confidence limits are
set to NA.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>Linear conditional quantile.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="quantreg.html#topic+rq">quantreg::rq()</a></code>
</p>
<p>Other quantreg tidiers: 
<code><a href="#topic+augment.nlrq">augment.nlrq</a>()</code>,
<code><a href="#topic+augment.rqs">augment.rqs</a>()</code>,
<code><a href="#topic+augment.rq">augment.rq</a>()</code>,
<code><a href="#topic+glance.nlrq">glance.nlrq</a>()</code>,
<code><a href="#topic+glance.rq">glance.rq</a>()</code>,
<code><a href="#topic+tidy.nlrq">tidy.nlrq</a>()</code>,
<code><a href="#topic+tidy.rq">tidy.rq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library and data
library(quantreg)

data(stackloss)

# median (l1) regression fit for the stackloss data.
mod1 &lt;- rq(stack.loss ~ stack.x, .5)

# weighted sample median
mod2 &lt;- rq(rnorm(50) ~ 1, weights = runif(50))

# summarize model fit with tidiers
tidy(mod1)
glance(mod1)
augment(mod1)

tidy(mod2)
glance(mod2)
augment(mod2)

# varying tau to generate an rqs object
mod3 &lt;- rq(stack.loss ~ stack.x, tau = c(.25, .5))

tidy(mod3)
augment(mod3)

# glance cannot handle rqs objects like `mod3`--use a purrr
# `map`-based workflow instead

</code></pre>

<hr>
<h2 id='tidy.sarlm'>Tidying methods for spatially autoregressive models</h2><span id='topic+tidy.sarlm'></span><span id='topic+spatialreg_tidiers'></span>

<h3>Description</h3>

<p>These methods tidy the coefficients of spatial autoregression
models generated by functions in the <code>spatialreg</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sarlm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.sarlm_+3A_x">x</code></td>
<td>
<p>An object returned from <code><a href="spatialreg.html#topic+ML_models">spatialreg::lagsarlm()</a></code>
or <code><a href="spatialreg.html#topic+ML_models">spatialreg::errorsarlm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.sarlm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.sarlm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.sarlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="spatialreg.html#topic+ML_models">spatialreg::lagsarlm()</a></code>, <code><a href="spatialreg.html#topic+ML_models">spatialreg::errorsarlm()</a></code>,
<code><a href="spatialreg.html#topic+ML_models">spatialreg::sacsarlm()</a></code>
</p>
<p>Other spatialreg tidiers: 
<code><a href="#topic+augment.sarlm">augment.sarlm</a>()</code>,
<code><a href="#topic+glance.sarlm">glance.sarlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# load libraries for models and data
library(spatialreg)
library(spdep)

# load data
data(oldcol, package = "spdep")

listw &lt;- nb2listw(COL.nb, style = "W")

# fit model
crime_sar &lt;-
  lagsarlm(CRIME ~ INC + HOVAL,
    data = COL.OLD,
    listw = listw,
    method = "eigen"
  )

# summarize model fit with tidiers
tidy(crime_sar)
tidy(crime_sar, conf.int = TRUE)
glance(crime_sar)
augment(crime_sar)

# fit another model
crime_sem &lt;- errorsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw)

# summarize model fit with tidiers
tidy(crime_sem)
tidy(crime_sem, conf.int = TRUE)
glance(crime_sem)
augment(crime_sem)

# fit another model
crime_sac &lt;- sacsarlm(CRIME ~ INC + HOVAL, data = COL.OLD, listw)

# summarize model fit with tidiers
tidy(crime_sac)
tidy(crime_sac, conf.int = TRUE)
glance(crime_sac)
augment(crime_sac)

</code></pre>

<hr>
<h2 id='tidy.spec'>Tidy a(n) spec object</h2><span id='topic+tidy.spec'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spec'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.spec_+3A_x">x</code></td>
<td>
<p>A <code>spec</code> object created by <code><a href="stats.html#topic+spectrum">stats::spectrum()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.spec_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>Vector of frequencies at which the spectral density is estimated.</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>Vector (for univariate series) or matrix (for multivariate series) of estimates of the spectral density at frequencies corresponding to freq.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+spectrum">stats::spectrum()</a></code>
</p>
<p>Other time series tidiers: 
<code><a href="#topic+tidy.acf">tidy.acf</a>()</code>,
<code><a href="#topic+tidy.ts">tidy.ts</a>()</code>,
<code><a href="#topic+tidy.zoo">tidy.zoo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

spc &lt;- spectrum(lh)
tidy(spc)

library(ggplot2)
ggplot(tidy(spc), aes(freq, spec)) +
  geom_line()

</code></pre>

<hr>
<h2 id='tidy.speedglm'>Tidy a(n) speedglm object</h2><span id='topic+tidy.speedglm'></span><span id='topic+speedglm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedglm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.speedglm_+3A_x">x</code></td>
<td>
<p>A <code>speedglm</code> object returned from <code><a href="speedglm.html#topic+speedglm">speedglm::speedglm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.speedglm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.speedglm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.speedglm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.speedglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="speedglm.html#topic+speedglm">speedglm::speedglm()</a></code>
</p>
<p>Other speedlm tidiers: 
<code><a href="#topic+augment.speedlm">augment.speedlm</a>()</code>,
<code><a href="#topic+glance.speedglm">glance.speedglm</a>()</code>,
<code><a href="#topic+glance.speedlm">glance.speedlm</a>()</code>,
<code><a href="#topic+tidy.speedlm">tidy.speedlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(speedglm)

# generate data
clotting &lt;- data.frame(
  u = c(5, 10, 15, 20, 30, 40, 60, 80, 100),
  lot1 = c(118, 58, 42, 35, 27, 25, 21, 19, 18)
)

# fit model
fit &lt;- speedglm(lot1 ~ log(u), data = clotting, family = Gamma(log))

# summarize model fit with tidiers
tidy(fit)
glance(fit)

</code></pre>

<hr>
<h2 id='tidy.speedlm'>Tidy a(n) speedlm object</h2><span id='topic+tidy.speedlm'></span><span id='topic+speedlm_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedlm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.speedlm_+3A_x">x</code></td>
<td>
<p>A <code>speedlm</code> object returned from <code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.speedlm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.speedlm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.speedlm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="speedglm.html#topic+speedlm">speedglm::speedlm()</a></code>, <code><a href="#topic+tidy.lm">tidy.lm()</a></code>
</p>
<p>Other speedlm tidiers: 
<code><a href="#topic+augment.speedlm">augment.speedlm</a>()</code>,
<code><a href="#topic+glance.speedglm">glance.speedglm</a>()</code>,
<code><a href="#topic+glance.speedlm">glance.speedlm</a>()</code>,
<code><a href="#topic+tidy.speedglm">tidy.speedglm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load modeling library
library(speedglm)

# fit model
mod &lt;- speedlm(mpg ~ wt + qsec, data = mtcars, fitted = TRUE)

# summarize model fit with tidiers
tidy(mod)
glance(mod)
augment(mod)

</code></pre>

<hr>
<h2 id='tidy.summary_emm'>Tidy a(n) summary_emm object</h2><span id='topic+tidy.summary_emm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_emm'
tidy(x, null.value = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.summary_emm_+3A_x">x</code></td>
<td>
<p>A <code>summary_emm</code> object.</p>
</td></tr>
<tr><td><code id="tidy.summary_emm_+3A_null.value">null.value</code></td>
<td>
<p>Value to which estimate is compared.</p>
</td></tr>
<tr><td><code id="tidy.summary_emm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or
<code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>. <strong>Cautionary note</strong>: misspecified arguments
may be silently ignored!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a data frame with one observation for each estimated marginal
mean, and one column for each combination of factors. When the input is a
contrast, each row will contain one estimated contrast.
</p>
<p>There are a large number of arguments that can be
passed on to <code><a href="emmeans.html#topic+summary.emmGrid">emmeans::summary.emmGrid()</a></code> or <code><a href="lsmeans.html#topic+ref.grid">lsmeans::summary.ref.grid()</a></code>.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>den.df</code></td>
<td>
<p>Degrees of freedom of the denominator.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom used by this term in the model.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Value to which the estimate is compared.</p>
</td></tr>
<tr><td><code>num.df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>level1</code></td>
<td>
<p>One level of the factor being contrasted</p>
</td></tr>
<tr><td><code>level2</code></td>
<td>
<p>The other level of the factor being contrasted</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>Model term in joint tests</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Expected marginal mean</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>T-ratio statistic or F-ratio statistic</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="emmeans.html#topic+ref_grid">emmeans::ref_grid()</a></code>, <code><a href="emmeans.html#topic+emmeans">emmeans::emmeans()</a></code>,
<code><a href="emmeans.html#topic+contrast">emmeans::contrast()</a></code>
</p>
<p>Other emmeans tidiers: 
<code><a href="#topic+tidy.emmGrid">tidy.emmGrid</a>()</code>,
<code><a href="#topic+tidy.lsmobj">tidy.lsmobj</a>()</code>,
<code><a href="#topic+tidy.ref.grid">tidy.ref.grid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(emmeans)

# linear model for sales of oranges per day
oranges_lm1 &lt;- lm(sales1 ~ price1 + price2 + day + store, data = oranges)

# reference grid; see vignette("basics", package = "emmeans")
oranges_rg1 &lt;- ref_grid(oranges_lm1)
td &lt;- tidy(oranges_rg1)
td

# marginal averages
marginal &lt;- emmeans(oranges_rg1, "day")
tidy(marginal)

# contrasts
tidy(contrast(marginal))
tidy(contrast(marginal, method = "pairwise"))

# plot confidence intervals
library(ggplot2)

ggplot(tidy(marginal, conf.int = TRUE), aes(day, estimate)) +
  geom_point() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# by multiple prices
by_price &lt;- emmeans(oranges_lm1, "day",
  by = "price2",
  at = list(
    price1 = 50, price2 = c(40, 60, 80),
    day = c("2", "3", "4")
  )
)

by_price

tidy(by_price)

ggplot(tidy(by_price, conf.int = TRUE), aes(price2, estimate, color = day)) +
  geom_line() +
  geom_errorbar(aes(ymin = conf.low, ymax = conf.high))

# joint_tests
tidy(joint_tests(oranges_lm1))

</code></pre>

<hr>
<h2 id='tidy.summary.glht'>Tidy a(n) summary.glht object</h2><span id='topic+tidy.summary.glht'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.glht'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.summary.glht_+3A_x">x</code></td>
<td>
<p>A <code>summary.glht</code> object created by calling
<code><a href="multcomp.html#topic+methods">multcomp::summary.glht()</a></code> on a <code>glht</code> object created with
<code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.summary.glht_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Value to which the estimate is compared.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="multcomp.html#topic+methods">multcomp::summary.glht()</a></code>, <code><a href="multcomp.html#topic+glht">multcomp::glht()</a></code>
</p>
<p>Other multcomp tidiers: 
<code><a href="#topic+tidy.cld">tidy.cld</a>()</code>,
<code><a href="#topic+tidy.confint.glht">tidy.confint.glht</a>()</code>,
<code><a href="#topic+tidy.glht">tidy.glht</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(multcomp)
library(ggplot2)

amod &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
wht &lt;- glht(amod, linfct = mcp(tension = "Tukey"))

tidy(wht)

ggplot(wht, aes(lhs, estimate)) +
  geom_point()

CI &lt;- confint(wht)

tidy(CI)

ggplot(CI, aes(lhs, estimate, ymin = lwr, ymax = upr)) +
  geom_pointrange()

tidy(summary(wht))
ggplot(mapping = aes(lhs, estimate)) +
  geom_linerange(aes(ymin = lwr, ymax = upr), data = CI) +
  geom_point(aes(size = p), data = summary(wht)) +
  scale_size(trans = "reverse")

cld &lt;- cld(wht)
tidy(cld)

</code></pre>

<hr>
<h2 id='tidy.summary.lm'>Tidy a(n) summary.lm object</h2><span id='topic+tidy.summary.lm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lm'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.summary.lm_+3A_x">x</code></td>
<td>
<p>A <code>summary.lm</code> object created by <code><a href="stats.html#topic+summary.lm">stats::summary.lm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.summary.lm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.summary.lm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.summary.lm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tidy.summary.lm()</code> method is a potentially useful alternative
to <code><a href="#topic+tidy.lm">tidy.lm()</a></code>. For instance, if users have already converted large <code>lm</code>
objects into their leaner <code>summary.lm</code> equivalents to conserve memory.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+summary.lm">stats::summary.lm()</a></code>
</p>
<p>Other lm tidiers: 
<code><a href="#topic+augment.glm">augment.glm</a>()</code>,
<code><a href="#topic+augment.lm">augment.lm</a>()</code>,
<code><a href="#topic+glance.glm">glance.glm</a>()</code>,
<code><a href="#topic+glance.lm">glance.lm</a>()</code>,
<code><a href="#topic+glance.summary.lm">glance.summary.lm</a>()</code>,
<code><a href="#topic+glance.svyglm">glance.svyglm</a>()</code>,
<code><a href="#topic+tidy.glm">tidy.glm</a>()</code>,
<code><a href="#topic+tidy.lm.beta">tidy.lm.beta</a>()</code>,
<code><a href="#topic+tidy.lm">tidy.lm</a>()</code>,
<code><a href="#topic+tidy.mlm">tidy.mlm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit model
mod &lt;- lm(mpg ~ wt + qsec, data = mtcars)
modsumm &lt;- summary(mod)

# summarize model fit with tidiers
tidy(mod, conf.int = TRUE)

# equivalent to the above
tidy(modsumm, conf.int = TRUE)

glance(mod)

# mostly the same, except for a few missing columns
glance(modsumm)

</code></pre>

<hr>
<h2 id='tidy.survdiff'>Tidy a(n) survdiff object</h2><span id='topic+tidy.survdiff'></span><span id='topic+survdiff_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survdiff'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.survdiff_+3A_x">x</code></td>
<td>
<p>An <code>survdiff</code> object returned from <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.survdiff_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>exp</code></td>
<td>
<p>Weighted expected number of events in each group.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of subjects in each group.</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>
<p>weighted observed number of events in each group.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+survdiff">survival::survdiff()</a></code>
</p>
<p>Other survdiff tidiers: 
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
s &lt;- survdiff(
  Surv(time, status) ~ pat.karno + strata(inst),
  data = lung
)

# summarize model fit with tidiers
tidy(s)
glance(s)

</code></pre>

<hr>
<h2 id='tidy.survexp'>Tidy a(n) survexp object</h2><span id='topic+tidy.survexp'></span><span id='topic+sexpfit_tidiers'></span><span id='topic+survexp_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survexp'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.survexp_+3A_x">x</code></td>
<td>
<p>An <code>survexp</code> object returned from <code><a href="survival.html#topic+survexp">survival::survexp()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.survexp_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>n.risk</code></td>
<td>
<p>Number of individuals at risk at time zero.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Point in time.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Estimate survival</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+survexp">survival::survexp()</a></code>
</p>
<p>Other survexp tidiers: 
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
sexpfit &lt;- survexp(
  futime ~ 1,
  rmap = list(
    sex = "male",
    year = accept.dt,
    age = (accept.dt - birth.dt)
  ),
  method = "conditional",
  data = jasa
)

# summarize model fit with tidiers
tidy(sexpfit)
glance(sexpfit)

</code></pre>

<hr>
<h2 id='tidy.survfit'>Tidy a(n) survfit object</h2><span id='topic+tidy.survfit'></span><span id='topic+survfit_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.survfit_+3A_x">x</code></td>
<td>
<p>An <code>survfit</code> object returned from <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.survfit_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>n.censor</code></td>
<td>
<p>Number of censored events.</p>
</td></tr>
<tr><td><code>n.event</code></td>
<td>
<p>Number of events at time t.</p>
</td></tr>
<tr><td><code>n.risk</code></td>
<td>
<p>Number of individuals at risk at time zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Point in time.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimate of survival or cumulative incidence rate when
multistate</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p>state if multistate survfit object input</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>strata if stratified survfit object input</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+survfit">survival::survfit()</a></code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survreg">tidy.survreg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
cfit &lt;- coxph(Surv(time, status) ~ age + sex, lung)
sfit &lt;- survfit(cfit)

# summarize model fit with tidiers + visualization
tidy(sfit)
glance(sfit)

library(ggplot2)

ggplot(tidy(sfit), aes(time, estimate)) +
  geom_line() +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25)

# multi-state
fitCI &lt;- survfit(Surv(stop, status * as.numeric(event), type = "mstate") ~ 1,
  data = mgus1, subset = (start == 0)
)

td_multi &lt;- tidy(fitCI)

td_multi

ggplot(td_multi, aes(time, estimate, group = state)) +
  geom_line(aes(color = state)) +
  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = .25)

</code></pre>

<hr>
<h2 id='tidy.survreg'>Tidy a(n) survreg object</h2><span id='topic+tidy.survreg'></span><span id='topic+survreg_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survreg'
tidy(x, conf.level = 0.95, conf.int = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.survreg_+3A_x">x</code></td>
<td>
<p>An <code>survreg</code> object returned from <code><a href="survival.html#topic+survreg">survival::survreg()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.survreg_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.survreg_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.survreg_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="survival.html#topic+survreg">survival::survreg()</a></code>
</p>
<p>Other survreg tidiers: 
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>
</p>
<p>Other survival tidiers: 
<code><a href="#topic+augment.coxph">augment.coxph</a>()</code>,
<code><a href="#topic+augment.survreg">augment.survreg</a>()</code>,
<code><a href="#topic+glance.aareg">glance.aareg</a>()</code>,
<code><a href="#topic+glance.cch">glance.cch</a>()</code>,
<code><a href="#topic+glance.coxph">glance.coxph</a>()</code>,
<code><a href="#topic+glance.pyears">glance.pyears</a>()</code>,
<code><a href="#topic+glance.survdiff">glance.survdiff</a>()</code>,
<code><a href="#topic+glance.survexp">glance.survexp</a>()</code>,
<code><a href="#topic+glance.survfit">glance.survfit</a>()</code>,
<code><a href="#topic+glance.survreg">glance.survreg</a>()</code>,
<code><a href="#topic+tidy.aareg">tidy.aareg</a>()</code>,
<code><a href="#topic+tidy.cch">tidy.cch</a>()</code>,
<code><a href="#topic+tidy.coxph">tidy.coxph</a>()</code>,
<code><a href="#topic+tidy.pyears">tidy.pyears</a>()</code>,
<code><a href="#topic+tidy.survdiff">tidy.survdiff</a>()</code>,
<code><a href="#topic+tidy.survexp">tidy.survexp</a>()</code>,
<code><a href="#topic+tidy.survfit">tidy.survfit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(survival)

# fit model
sr &lt;- survreg(
  Surv(futime, fustat) ~ ecog.ps + rx,
  ovarian,
  dist = "exponential"
)

# summarize model fit with tidiers + visualization
tidy(sr)
augment(sr, ovarian)
glance(sr)

# coefficient plot
td &lt;- tidy(sr, conf.int = TRUE)

library(ggplot2)

ggplot(td, aes(estimate, term)) +
  geom_point() +
  geom_errorbarh(aes(xmin = conf.low, xmax = conf.high), height = 0) +
  geom_vline(xintercept = 0)

</code></pre>

<hr>
<h2 id='tidy.svyglm'>Tidy a(n) svyglm object</h2><span id='topic+tidy.svyglm'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyglm'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.svyglm_+3A_x">x</code></td>
<td>
<p>A <code>svyglm</code> object returned from <code><a href="survey.html#topic+svyglm">survey::svyglm()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.svyglm_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.svyglm_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.svyglm_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.svyglm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="survey.html#topic+svyglm">survey::svyglm()</a></code>, <code><a href="stats.html#topic+glm">stats::glm()</a></code>
</p>

<hr>
<h2 id='tidy.svyolr'>Tidy a(n) svyolr object</h2><span id='topic+tidy.svyolr'></span><span id='topic+svyolr_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svyolr'
tidy(x, conf.int = FALSE, conf.level = 0.95, exponentiate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.svyolr_+3A_x">x</code></td>
<td>
<p>A <code>svyolr</code> object returned from <code><a href="survey.html#topic+svyolr">survey::svyolr()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.svyolr_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.svyolr_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.svyolr_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.svyolr_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tidy.svyolr()</code> tidier is a light wrapper around
<code><a href="#topic+tidy.polr">tidy.polr()</a></code>. However, the implementation for p-value calculation
in <code><a href="#topic+tidy.polr">tidy.polr()</a></code> is both computationally intensive and specific to that
model, so the <code>p.values</code> argument to <code>tidy.svyolr()</code> is currently ignored,
and will raise a warning when passed.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+tidy">tidy</a>, <code><a href="survey.html#topic+svyolr">survey::svyolr()</a></code>
</p>
<p>Other ordinal tidiers: 
<code><a href="#topic+augment.clm">augment.clm</a>()</code>,
<code><a href="#topic+augment.polr">augment.polr</a>()</code>,
<code><a href="#topic+glance.clmm">glance.clmm</a>()</code>,
<code><a href="#topic+glance.clm">glance.clm</a>()</code>,
<code><a href="#topic+glance.polr">glance.polr</a>()</code>,
<code><a href="#topic+glance.svyolr">glance.svyolr</a>()</code>,
<code><a href="#topic+tidy.clmm">tidy.clmm</a>()</code>,
<code><a href="#topic+tidy.clm">tidy.clm</a>()</code>,
<code><a href="#topic+tidy.polr">tidy.polr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(broom)
library(survey)

data(api)
dclus1 &lt;- svydesign(id = ~dnum, weights = ~pw, data = apiclus1, fpc = ~fpc)
dclus1 &lt;- update(dclus1, mealcat = cut(meals, c(0, 25, 50, 75, 100)))

m &lt;- svyolr(mealcat ~ avg.ed + mobility + stype, design = dclus1)

m

tidy(m, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='tidy.systemfit'>Tidy a(n) systemfit object</h2><span id='topic+tidy.systemfit'></span><span id='topic+systemfit_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'systemfit'
tidy(x, conf.int = TRUE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.systemfit_+3A_x">x</code></td>
<td>
<p>A <code>systemfit</code> object produced by a call to <code><a href="systemfit.html#topic+systemfit">systemfit::systemfit()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.systemfit_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.systemfit_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.systemfit_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This tidy method works with any model objects of class <code>systemfit</code>.
Default returns a tibble of six columns.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="systemfit.html#topic+systemfit">systemfit::systemfit()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(27)

# load libraries for models and data
library(systemfit)

# generate data
df &lt;- data.frame(
  X = rnorm(100),
  Y = rnorm(100),
  Z = rnorm(100),
  W = rnorm(100)
)

# fit model
fit &lt;- systemfit(formula = list(Y ~ Z, W ~ X), data = df, method = "SUR")

# summarize model fit with tidiers
tidy(fit)
tidy(fit, conf.int = TRUE)

</code></pre>

<hr>
<h2 id='tidy.table'>Tidy a(n) table object</h2><span id='topic+tidy.table'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>
<p>Deprecated. Please use <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.table_+3A_x">x</code></td>
<td>
<p>A <a href="base.html#topic+table">base::table</a> object.</p>
</td></tr>
<tr><td><code id="tidy.table_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Directly calls <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> on a <a href="base.html#topic+table">base::table</a> object.
</p>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble::tibble</a> in long-form containing frequency information
for the table in a <code>Freq</code> column. The result is much like what you get
from <code><a href="tidyr.html#topic+pivot_longer">tidyr::pivot_longer()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+as_tibble">tibble::as_tibble.table()</a></code>
</p>

<hr>
<h2 id='tidy.ts'>Tidy a(n) ts object</h2><span id='topic+tidy.ts'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.ts_+3A_x">x</code></td>
<td>
<p>A univariate or multivariate <code>ts</code> times series object.</p>
</td></tr>
<tr><td><code id="tidy.ts_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>series</code> column is only present for multivariate <code>ts</code> objects.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>Index (i.e. date or time) for a 'ts' or 'zoo' object.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>Name of the series (present only for multivariate time series).</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value/estimate of the component. Results from data reshaping.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+ts">stats::ts()</a></code>
</p>
<p>Other time series tidiers: 
<code><a href="#topic+tidy.acf">tidy.acf</a>()</code>,
<code><a href="#topic+tidy.spec">tidy.spec</a>()</code>,
<code><a href="#topic+tidy.zoo">tidy.zoo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(678)

tidy(ts(1:10, frequency = 4, start = c(1959, 2)))

z &lt;- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)
colnames(z) &lt;- c("Aa", "Bb", "Cc")

tidy(z)
</code></pre>

<hr>
<h2 id='tidy.TukeyHSD'>Tidy a(n) TukeyHSD object</h2><span id='topic+tidy.TukeyHSD'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TukeyHSD'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.TukeyHSD_+3A_x">x</code></td>
<td>
<p>A <code>TukeyHSD</code> object return from <code><a href="stats.html#topic+TukeyHSD">stats::TukeyHSD()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.TukeyHSD_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>adj.p.value</code></td>
<td>
<p>P-value adjusted for multiple comparisons.</p>
</td></tr>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>Levels being compared.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>Value to which the estimate is compared.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="stats.html#topic+TukeyHSD">stats::TukeyHSD()</a></code>
</p>
<p>Other anova tidiers: 
<code><a href="#topic+glance.anova">glance.anova</a>()</code>,
<code><a href="#topic+glance.aov">glance.aov</a>()</code>,
<code><a href="#topic+tidy.anova">tidy.anova</a>()</code>,
<code><a href="#topic+tidy.aovlist">tidy.aovlist</a>()</code>,
<code><a href="#topic+tidy.aov">tidy.aov</a>()</code>,
<code><a href="#topic+tidy.manova">tidy.manova</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm1 &lt;- aov(breaks ~ wool + tension, data = warpbreaks)
thsd &lt;- TukeyHSD(fm1, "tension", ordered = TRUE)
tidy(thsd)

# may include comparisons on multiple terms
fm2 &lt;- aov(mpg ~ as.factor(gear) * as.factor(cyl), data = mtcars)
tidy(TukeyHSD(fm2))
</code></pre>

<hr>
<h2 id='tidy.varest'>Tidy a(n) varest object</h2><span id='topic+tidy.varest'></span><span id='topic+vars_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'varest'
tidy(x, conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.varest_+3A_x">x</code></td>
<td>
<p>A <code>varest</code> object produced by a call to <code><a href="vars.html#topic+VAR">vars::VAR()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.varest_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.varest_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.varest_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The tibble has one row for each term in the regression. The
<code>component</code> column indicates whether a particular
term was used to model either the <code>"mean"</code> or <code>"precision"</code>. Here the
precision is the inverse of the variance, often referred to as <code>phi</code>.
At least one term will have been used to model the precision <code>phi</code>.
</p>
<p>The <code>vars</code> package does not include a <code>confint</code> method and does not report
confidence intervals for <code>varest</code> objects. Setting the <code>tidy</code> argument
<code>conf.int = TRUE</code> will return a warning.
</p>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>conf.high</code></td>
<td>
<p>Upper bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>conf.low</code></td>
<td>
<p>Lower bound on the confidence interval for the estimate.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The estimated value of the regression term.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The two-sided p-value associated with the observed statistic.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The value of a T-statistic to use in a hypothesis that the regression term is non-zero.</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>The standard error of the regression term.</p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>The name of the regression term.</p>
</td></tr>
<tr><td><code>component</code></td>
<td>
<p>Whether a particular term was used to model the mean or the
precision in the regression. See details.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="vars.html#topic+VAR">vars::VAR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(vars)

# load data
data("Canada", package = "vars")

# fit models
mod &lt;- VAR(Canada, p = 1, type = "both")

# summarize model fit with tidiers
tidy(mod)
glance(mod)

</code></pre>

<hr>
<h2 id='tidy.zoo'>Tidy a(n) zoo object</h2><span id='topic+tidy.zoo'></span><span id='topic+zoo_tidiers'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model.
A model component might be a single term in a regression, a single
hypothesis, a cluster, or a class. Exactly what tidy considers to be a
model component varies across models but is usually self-evident.
If a model has several distinct types of components, you will need to
specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zoo'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.zoo_+3A_x">x</code></td>
<td>
<p>A <code>zoo</code> object such as those created by <code><a href="zoo.html#topic+zoo">zoo::zoo()</a></code>.</p>
</td></tr>
<tr><td><code id="tidy.zoo_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with columns:
</p>
<table>
<tr><td><code>index</code></td>
<td>
<p>Index (i.e. date or time) for a 'ts' or 'zoo' object.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>Name of the series (present only for multivariate time series).</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value/estimate of the component. Results from data reshaping.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+tidy">tidy()</a></code>, <code><a href="zoo.html#topic+zoo">zoo::zoo()</a></code>
</p>
<p>Other time series tidiers: 
<code><a href="#topic+tidy.acf">tidy.acf</a>()</code>,
<code><a href="#topic+tidy.spec">tidy.spec</a>()</code>,
<code><a href="#topic+tidy.ts">tidy.ts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load libraries for models and data
library(zoo)
library(ggplot2)

set.seed(1071)

# generate data
Z.index &lt;- as.Date(sample(12450:12500, 10))
Z.data &lt;- matrix(rnorm(30), ncol = 3)
colnames(Z.data) &lt;- c("Aa", "Bb", "Cc")
Z &lt;- zoo(Z.data, Z.index)

# summarize model fit with tidiers + visualization
tidy(Z)

ggplot(tidy(Z), aes(index, value, color = series)) +
  geom_line()

ggplot(tidy(Z), aes(index, value)) +
  geom_line() +
  facet_wrap(~series, ncol = 1)

Zrolled &lt;- rollmean(Z, 5)
ggplot(tidy(Zrolled), aes(index, value, color = series)) +
  geom_line()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
