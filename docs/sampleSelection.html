<!DOCTYPE html><html><head><title>Help for package sampleSelection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sampleSelection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.selection'><p>Extract Coefficients from Selection Models</p></a></li>
<li><a href='#fitted.selection'><p>Fitted Values of Selection Models</p></a></li>
<li><a href='#heckit2fit'><p>2-step Heckman (heckit) estimation</p></a></li>
<li><a href='#heckitVcov'><p>Heckit Variance Covariance Matrix</p></a></li>
<li><a href='#invMillsRatio'><p>Inverse Mill's Ratio of probit models</p></a></li>
<li><a href='#linearPredictors'><p>Calculates linear predictors for different models</p></a></li>
<li><a href='#model.frame.binaryChoice'><p>Data of Binary Choice Models</p></a></li>
<li><a href='#model.frame.selection'><p>Data of Selection Models</p></a></li>
<li><a href='#model.matrix.binaryChoice'><p>Design Matrix of Binary Choice Models</p></a></li>
<li><a href='#model.matrix.selection'><p>Design Matrix of Selection Models</p></a></li>
<li><a href='#Mroz87'><p>U.S. Women's Labor Force Participation</p></a></li>
<li><a href='#nlswork'><p>National Longitudinal Survey of Young Working Women</p></a></li>
<li><a href='#predict.probit'><p>Predict method for fitted probit models</p></a></li>
<li><a href='#predict.selection'><p>Predict method for fitted sample selection models</p></a></li>
<li><a href='#probit'><p>Binary choice models.</p></a></li>
<li><a href='#probit-methods'><p>probit-methods</p></a></li>
<li><a href='#RandHIE'><p>RAND Health Insurance Experiment</p></a></li>
<li><a href='#residuals.probit'><p>Residuals of probit models</p></a></li>
<li><a href='#residuals.selection'><p>Residuals of Selection Models</p></a></li>
<li><a href='#sampleSelection-internal'><p> Internal sampleSelection Functions</p></a></li>
<li><a href='#selection'><p>Heckman-style selection and treatment effect models</p></a></li>
<li><a href='#selection-methods'><p>selection-methods</p></a></li>
<li><a href='#Smoke'><p>Survey Responses on Smoking Behaviour</p></a></li>
<li><a href='#summary.probit'><p>Summarizing Probit Estimations</p></a></li>
<li><a href='#summary.selection'><p>Summarizing Selection Estimations</p></a></li>
<li><a href='#tobit2fit'><p>Fitting Parametric Sample Selection Models</p></a></li>
<li><a href='#vcov.selection'><p>Extract Variance Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-12</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Sample Selection Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Arne Henningsen [aut, cre],
  Ott Toomet [aut],
  Sebastian Petersen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), maxLik (&ge; 0.7-3), stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>miscTools (&ge; 0.6-3), systemfit (&ge; 1.0-0), Formula (&ge;
1.1-1), VGAM (&ge; 1.1-1), mvtnorm (&ge; 0.9-9994)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lmtest, Ecdat</td>
</tr>
<tr>
<td>Description:</td>
<td>Two-step
   and maximum likelihood estimation
   of Heckman-type sample selection models:
   standard sample selection models (Tobit-2),
   endogenous switching regression models (Tobit-5),
   sample selection models with binary dependent outcome variable,
   interval regression with sample selection (only ML estimation),
   and endogenous treatment effects models.
   These methods are described in the three vignettes
   that are included in this package 
   and in econometric textbooks such as
   Greene (2011, Econometric Analysis, 7th edition, Pearson).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.sampleSelection.org">http://www.sampleSelection.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-14 22:31:03 UTC; gsl324</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-15 07:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.selection'>Extract Coefficients from Selection Models</h2><span id='topic+coef.selection'></span><span id='topic+coef.summary.selection'></span><span id='topic+print.coef.selection'></span>

<h3>Description</h3>

<p>This function extracts coefficients
from sample selection models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
coef(object, part = "full", ...)
## S3 method for class 'summary.selection'
coef(object, part = "full", ...)
## S3 method for class 'coef.selection'
print( x, prefix = TRUE,
      digits = max(3, getOption("digits") - 3), ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.selection_+3A_object">object</code></td>
<td>
<p>object of class <code>selection</code>
or <code>summary.selection</code>.</p>
</td></tr>
<tr><td><code id="coef.selection_+3A_part">part</code></td>
<td>
<p>character string indicating
which parts of the coefficients to extract:
<code>"full"</code> for all parameters (selection estimates,
outcome estimates, error variance and correlation,
including parameters that were calculated based on estimated parameters),
<code>"outcome"</code> for the outcome estimates only
(including the coefficient of the inverse Mill's ratio
in case of a two-step estimation), or
<code>"est"</code> for all estimated parameters.</p>
</td></tr>
<tr><td><code id="coef.selection_+3A_x">x</code></td>
<td>
<p>object returned by <code>coef.selection</code>.</p>
</td></tr>
<tr><td><code id="coef.selection_+3A_prefix">prefix</code></td>
<td>
<p>logical. Add a prefix to the names of the coefficients
that indicates to which equation the coefficient belongs.</p>
</td></tr>
<tr><td><code id="coef.selection_+3A_digits">digits</code></td>
<td>
<p>numeric, (suggested) number of significant digits.</p>
</td></tr>
<tr><td><code id="coef.selection_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef.selection</code> returns a vector of the estimated coefficients.
</p>
<p><code>coef.summary.selection</code> returns a matrix of the estimated coefficients,
their standard errors, t-values, and p-values.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen,
Ott Toomet (<a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a>)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+selection">selection</a></code>, <code><a href="#topic+vcov.selection">vcov.selection</a></code>,
and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate a simple female wage model taking into account the labour
## force participation
   data(Mroz87)
   a &lt;- heckit(lfp ~ huswage + kids5 + mtr + fatheduc + educ + city,
               log(wage) ~ educ + city, data=Mroz87)
## extract all coefficients of the model:
coef( a )

## now extract the coefficients of the outcome model only:
coef( a, part="outcome")

## extract all coefficients, standard errors, t-values
## and p-values of the model:
coef( summary( a ) )

## now extract the coefficients, standard errors, t-values
## and p-values of the outcome model only:
coef( summary( a ), part="outcome")
</code></pre>

<hr>
<h2 id='fitted.selection'>Fitted Values of Selection Models</h2><span id='topic+fitted.selection'></span>

<h3>Description</h3>

<p>Calculate fitted values of sample selection models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
fitted(object, part = "outcome", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.selection_+3A_object">object</code></td>
<td>
<p>object of class <code>selection</code>.</p>
</td></tr>
<tr><td><code id="fitted.selection_+3A_part">part</code></td>
<td>
<p>character string indication which fitted values to extract:
&quot;outcome&quot; for the fitted values of the outcome equation(s) or
&quot;selection&quot; for the fitted values of the selection equation.</p>
</td></tr>
<tr><td><code id="fitted.selection_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods
(e.g. <code><a href="#topic+fitted.probit">fitted.probit</a></code> or <code><a href="stats.html#topic+fitted">fitted</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model was estimated by the 2-step method,
the fitted values of the outcome equation are calculated
using all regressors of this equation
including the inverse Mill's ratios,
i.e. the fitted values correspond to the conditional expectations
(see <code><a href="#topic+predict.selection">predict.selection</a></code>).
</p>
<p>If the model was estimated by the maximum likelihood method,
the fitted values of the outcome equation are calculated
by disregarding the selection equation,
i.e. the fitted values correspond to the unconditional expectations
(see <code><a href="#topic+predict.selection">predict.selection</a></code>).
</p>
<p>The fitted values of the selection equation are probabilities.
If the dependent variable of the outcome equation is binary,
also the fitted values of the outcome equation are probabilities.
</p>


<h3>Value</h3>

<p>A numeric vector of the fitted values.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fitted">fitted</a></code>, <code><a href="#topic+selection">selection</a></code>,
<code><a href="#topic+residuals.selection">residuals.selection</a></code>, and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>

<hr>
<h2 id='heckit2fit'>2-step Heckman (heckit) estimation</h2><span id='topic+heckit2fit'></span><span id='topic+heckit5fit'></span><span id='topic+heckitTfit'></span>

<h3>Description</h3>

<p>These functions do the actual fitting of tobit-2
(sample selection), tobit-5 (switching regression) and
normal-disturbance treatment effect
models by the 2-step Heckman (heckit) estimation.
They are called by <code><a href="#topic+selection">selection</a></code> or
<code><a href="#topic+heckit">heckit</a></code> and
they are intended for <code>sampleSelection</code> internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heckit2fit( selection, outcome, data=sys.frame(sys.parent()),
   weights = NULL, inst = NULL,
   printLevel=print.level, print.level = 0,
   maxMethod = "Newton-Raphson" )

heckit5fit( selection, outcome1, outcome2, data = sys.frame(sys.parent()),
   ys = FALSE, yo = FALSE, xs = FALSE, xo = FALSE, mfs = FALSE,
   mfo = FALSE,
   printLevel=print.level, print.level = 0, maxMethod = "Newton-Raphson", ... )

heckitTfit(selection, outcome, data=sys.frame(sys.parent()),
   ys=FALSE, yo=FALSE, xs=FALSE, xo=FALSE, mfs=FALSE, mfo=FALSE,
   printLevel=0, maxMethod="Newton-Raphson", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heckit2fit_+3A_selection">selection</code></td>
<td>
<p>formula for the probit estimation (1st step)
(see <code><a href="#topic+selection">selection</a></code>).</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_outcome">outcome</code></td>
<td>
<p>formula to be estimated (2nd step).  In case of
treatment effect model, it may include the response indicator from
selection equation.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_outcome1">outcome1</code></td>
<td>
<p>formula, the first outcome equation.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_outcome2">outcome2</code></td>
<td>
<p>formula, the second outcome equation.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_data">data</code></td>
<td>
<p>a data frame containing the data.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; 
to be used in the fitting process. Should be NULL or a numeric vector.
Weights are currently only supported in type-2 models.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_inst">inst</code></td>
<td>
<p>an optional one-sided formula specifying instrumental variables
for a 2SLS/IV estimation on the 2nd step.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_ys">ys</code>, <code id="heckit2fit_+3A_yo">yo</code>, <code id="heckit2fit_+3A_xs">xs</code>, <code id="heckit2fit_+3A_xo">xo</code>, <code id="heckit2fit_+3A_mfs">mfs</code>, <code id="heckit2fit_+3A_mfo">mfo</code></td>
<td>
<p>logicals.  If true, the response (<code>y</code>),
model matrix (<code>x</code>) or the model frame (<code>mf</code>)
of the selection (<code>s</code>) or outcome
(<code>o</code>) equation(s) are returned.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_print.level">print.level</code></td>
<td>
<p>numeric, values greater than 0 will produce
increasingly more debugging information.</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_maxmethod">maxMethod</code></td>
<td>
<p>character string,
a maximisation method supported by <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>
that is used for estimating the probit model (1st stage).</p>
</td></tr>
<tr><td><code id="heckit2fit_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="#topic+selection">selection</a></code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen,
Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a></p>


<h3>References</h3>

<p>see <code><a href="#topic+selection">selection</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selection">selection</a></code>, <code><a href="#topic+heckit">heckit</a></code></p>

<hr>
<h2 id='heckitVcov'>Heckit Variance Covariance Matrix</h2><span id='topic+heckitVcov'></span>

<h3>Description</h3>

<p>Calculate the asymptotic covariance matrix
for the coefficients of a Heckit estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   heckitVcov( xMat, wMat, vcovProbit, rho, delta, sigma,
   saveMemory = TRUE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heckitVcov_+3A_xmat">xMat</code></td>
<td>
<p>model matrix of the 2nd step estimation.</p>
</td></tr>
<tr><td><code id="heckitVcov_+3A_wmat">wMat</code></td>
<td>
<p>model matrix of the 1st step probit estimation.</p>
</td></tr>
<tr><td><code id="heckitVcov_+3A_vcovprobit">vcovProbit</code></td>
<td>
<p>variance covariance matrix of the 1st step
probit estimation.</p>
</td></tr>
<tr><td><code id="heckitVcov_+3A_rho">rho</code></td>
<td>
<p>the estimated <code class="reqn">\rho</code>, see Greene (2003, p. 784).</p>
</td></tr>
<tr><td><code id="heckitVcov_+3A_delta">delta</code></td>
<td>
<p>the estimated <code class="reqn">\delta</code>s, see Greene (2003, p. 784).</p>
</td></tr>
<tr><td><code id="heckitVcov_+3A_sigma">sigma</code></td>
<td>
<p>the estimated <code class="reqn">\sigma</code>, see Greene (2003, p. 784).</p>
</td></tr>
<tr><td><code id="heckitVcov_+3A_savememory">saveMemory</code></td>
<td>
<p>logical. Save memory by using a different implementation
of the formula? (this should not influence the results).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula implemented in <code>heckitVcov</code> is available,
e.g., in Greene (2003), last formula on page 785.
</p>


<h3>Value</h3>

<p>the variance covariance matrix of the coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W. H. (2003)
<em>Econometric Analysis, Fifth Edition</em>, Prentice Hall.
</p>
<p>Lee, L., G. Maddala and R. Trost (1980)
Asymetric covariance matrices of two-stage probit and two-stage tobit
methods for simultaneous equations models with selectivity.
<em>Econometrica</em>, 48, p. 491-503.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+heckit">heckit</a></code>.</p>

<hr>
<h2 id='invMillsRatio'>Inverse Mill's Ratio of probit models</h2><span id='topic+invMillsRatio'></span>

<h3>Description</h3>

<p>Calculates the 'Inverse Mill's Ratios' of univariate and bivariate
probit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   invMillsRatio( x, all = FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invMillsRatio_+3A_x">x</code></td>
<td>
<p>probit model estimated by <code><a href="#topic+probit">probit</a></code>, <code><a href="stats.html#topic+glm">glm</a></code> or
<code><a href="VGAM.html#topic+vglm">vglm</a></code>.</p>
</td></tr>
<tr><td><code id="invMillsRatio_+3A_all">all</code></td>
<td>
<p>a logical value indicating whether the inverse Mill's Ratios
should be calculated for all observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula to calculate the inverse Mill's ratios for univariate probit
models is taken from Greene (2003, p. 785),
whereas the formulas for bivariate probit models are derived in
Henning and Henningsen (2005).
</p>


<h3>Value</h3>

<p>A data frame that contains the Inverse Mill's Ratios (IMR) and the delta
values (see Greene, 2003, p. 784).
</p>
<p>If a univariate probit estimation is provided, the variables
<code>IMR1</code> and <code>IMR0</code> are the Inverse Mill's Ratios to correct
for a sample selection bias of y = 1 and y = 0, respectively.
Accordingly, 'delta1' and 'delta0' are the corresponding delta values.
</p>
<p>If a bivariate probit estimation is provided, the variables
<code>IMRa1</code>, <code>IMRa0</code>, <code>IMRb1</code>, and <code>IMRb0</code> are the
Inverse Mills Ratios to correct for a sample selection bias
of y = 1 and y = 0 in equations 'a' and 'b', respectively.
Accordingly, 'deltaa1', 'deltaa0', 'deltab1' and 'deltab0' are the
corresponding delta values.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Greene, W. H. (2003)
<em>Econometric Analysis, Fifth Edition</em>, Prentice Hall.
</p>
<p>Henning, C.H.C.A and A. Henningsen (2005)
Modeling Price Response of Farm Households in Imperfect
Labor Markets in Poland:
Incorporating Transaction Costs and Heterogeneity into a Farm
Household Approach.
Unpublished, University of Kiel, Germany.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Wooldridge( 2003 ): example 17.5, page 590
data(Mroz87)
myProbit &lt;- glm( lfp ~ nwifeinc + educ + exper + I( exper^2 ) + age +
   kids5 + kids618, family = binomial( link = "probit" ), data=Mroz87 )
Mroz87$IMR &lt;- invMillsRatio( myProbit )$IMR1
myHeckit &lt;- lm( log( wage ) ~ educ + exper + I( exper^2 ) + IMR,
   data = Mroz87[ Mroz87$lfp == 1, ] )

# using NO labor force participation as endogenous variable
Mroz87$nolfp &lt;- 1 - Mroz87$lfp
myProbit2 &lt;- glm( nolfp ~ nwifeinc + educ + exper + I( exper^2 ) + age +
   kids5 + kids618, family = binomial( link = "probit" ), data=Mroz87 )
all.equal( invMillsRatio( myProbit )$IMR1, invMillsRatio( myProbit2 )$IMR0 )
   # should be true

# example for bivariate probit
library( "mvtnorm" )
library( "VGAM" )

nObs &lt;- 1000

# error terms (trivariate normal)
sigma &lt;- symMatrix( c( 2, 0.7, 1.2, 1, 0.5, 1 ) )
myData &lt;- as.data.frame( rmvnorm( nObs, c( 0, 0, 0 ), sigma ) )
names( myData ) &lt;- c( "e0", "e1", "e2" )

# exogenous variables (indepently normal)
myData$x0 &lt;- rnorm( nObs )
myData$x1 &lt;- rnorm( nObs )
myData$x2 &lt;- rnorm( nObs )

# endogenous variables
myData$y0 &lt;-   -1.5 + 0.8 * myData$x1 + myData$e0
myData$y1 &lt;- (  0.3 + 0.4 * myData$x1 + 0.3 * myData$x2 + myData$e1 ) &gt; 0
myData$y2 &lt;- ( -0.1 + 0.6 * myData$x1 + 0.7 * myData$x2 + myData$e2 ) &gt; 0

# bivariate probit (using rhobit transformation)
bProbit &lt;- vglm( cbind( y1, y2 ) ~ x1 + x2, family = binom2.rho,
   data = myData )
summary( bProbit )

# bivariate probit (NOT using rhobit transformation)
bProbit2 &lt;- vglm( cbind( y1, y2 ) ~ x1 + x2, family = binom2.rho(
   lrho = "identitylink" ), data = myData )
summary( bProbit2 )

# inverse Mills Ratios
imr  &lt;- invMillsRatio( bProbit )
imr2 &lt;- invMillsRatio( bProbit2 )
all.equal( imr, imr2, tolerance = .Machine$double.eps ^ 0.25)

# tests
# E[ e0 | y1* &gt; 0 &amp; y2* &gt; 0 ]
mean( myData$e0[ myData$y1 &amp; myData$y2 ] )
mean( sigma[1,2] * imr$IMR11a + sigma[1,3] * imr$IMR11b, na.rm = TRUE )
# E[ e0 | y1* &gt; 0 &amp; y2* &lt;= 0 ]
mean( myData$e0[ myData$y1 &amp; !myData$y2 ] )
mean( sigma[1,2] * imr$IMR10a + sigma[1,3] * imr$IMR10b, na.rm = TRUE )
# E[ e0 | y1* &lt;= 0 &amp; y2* &gt; 0 ]
mean( myData$e0[ !myData$y1 &amp; myData$y2 ] )
mean( sigma[1,2] * imr$IMR01a + sigma[1,3] * imr$IMR01b, na.rm = TRUE )
# E[ e0 | y1* &lt;= 0 &amp; y2* &lt;= 0 ]
mean( myData$e0[ !myData$y1 &amp; !myData$y2 ] )
mean( sigma[1,2] * imr$IMR00a + sigma[1,3] * imr$IMR00b, na.rm = TRUE )
# E[ e0 | y1* &gt; 0 ]
mean( myData$e0[ myData$y1 ] )
mean( sigma[1,2] * imr$IMR1X, na.rm = TRUE )
# E[ e0 | y1* &lt;= 0 ]
mean( myData$e0[ !myData$y1 ] )
mean( sigma[1,2] * imr$IMR0X, na.rm = TRUE )
# E[ e0 | y2* &gt; 0 ]
mean( myData$e0[ myData$y2 ] )
mean( sigma[1,3] * imr$IMRX1, na.rm = TRUE )
# E[ e0 | y2* &lt;= 0 ]
mean( myData$e0[ !myData$y2 ] )
mean( sigma[1,3] * imr$IMRX0, na.rm = TRUE )

# estimation for y1* &gt; 0 and y2* &gt; 0
selection &lt;- myData$y1 &amp; myData$y2
# OLS estimation
ols11 &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( ols11 )
# heckman type estimation
heckit11 &lt;- lm( y0 ~ x1 + IMR11a + IMR11b, data = cbind( myData, imr ),
   subset = selection )
summary( heckit11 )

# estimation for y1* &gt; 0 and y2* &lt;= 0
selection &lt;- myData$y1 &amp; !myData$y2
# OLS estimation
ols10 &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( ols10 )
# heckman type estimation
heckit10 &lt;- lm( y0 ~ x1 + IMR10a + IMR10b, data = cbind( myData, imr ),
   subset = selection )
summary( heckit10 )

# estimation for y1* &lt;= 0 and y2* &gt; 0
selection &lt;- !myData$y1 &amp; myData$y2
# OLS estimation
ols01 &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( ols01 )
# heckman type estimation
heckit01 &lt;- lm( y0 ~ x1 + IMR01a + IMR01b, data = cbind( myData, imr ),
   subset = selection )
summary( heckit01 )

# estimation for y1* &lt;= 0 and y2* &lt;= 0
selection &lt;- !myData$y1 &amp; !myData$y2
# OLS estimation
ols00 &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( ols00 )
# heckman type estimation
heckit00 &lt;- lm( y0 ~ x1 + IMR00a + IMR00b, data = cbind( myData, imr ),
   subset = selection )
summary( heckit00 )

# estimation for y1* &gt; 0
selection &lt;- myData$y1
# OLS estimation
ols1X &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( ols1X )
# heckman type estimation
heckit1X &lt;- lm( y0 ~ x1 + IMR1X, data = cbind( myData, imr ),
   subset = selection )
summary( heckit1X )

# estimation for y1* &lt;= 0
selection &lt;- !myData$y1
# OLS estimation
ols0X &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( ols0X )
# heckman type estimation
heckit0X &lt;- lm( y0 ~ x1 + IMR0X, data = cbind( myData, imr ),
   subset = selection )
summary( heckit0X )

# estimation for y2* &gt; 0
selection &lt;- myData$y2
# OLS estimation
olsX1 &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( olsX1 )
# heckman type estimation
heckitX1 &lt;- lm( y0 ~ x1 + IMRX1, data = cbind( myData, imr ),
   subset = selection )
summary( heckitX1 )

# estimation for y2* &lt;= 0
selection &lt;- !myData$y2
# OLS estimation
olsX0 &lt;- lm( y0 ~ x1, data = myData, subset = selection )
summary( olsX0 )
# heckman type estimation
heckitX0 &lt;- lm( y0 ~ x1 + IMRX0, data = cbind( myData, imr ),
   subset = selection )
summary( heckitX0 )
</code></pre>

<hr>
<h2 id='linearPredictors'>Calculates linear predictors for different models</h2><span id='topic+linearPredictors'></span><span id='topic+linearPredictors.probit'></span>

<h3>Description</h3>

<p>Calculates the (unobservable) linear predictors for probability models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearPredictors(x, ...)

## S3 method for class 'probit'
linearPredictors( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearPredictors_+3A_x">x</code></td>
<td>
<p>model of an appropriate class</p>
</td></tr>
<tr><td><code id="linearPredictors_+3A_...">...</code></td>
<td>
<p>other arguments depending on the method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a generic function with a method for 'probit'.
</p>


<h3>Value</h3>

<p>A matrix with nrow equal to the number of observations and one column:
the linear predictors for observations
</p>


<h3>Author(s)</h3>

<p>Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a>, Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+probit">probit</a></code> and <code><a href="#topic+probit-methods">probit-methods</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mroz87)
Mroz87$kids  &lt;- ( Mroz87$kids5 + Mroz87$kids618 &gt; 0 )
a &lt;- probit(lfp ~ kids + educ + hushrs + huseduc + huswage + mtr +
 motheduc, data=Mroz87)
b &lt;- linearPredictors(a)
cor(Mroz87$lfp, b) # should be positive and highly significant
</code></pre>

<hr>
<h2 id='model.frame.binaryChoice'>Data of Binary Choice Models</h2><span id='topic+model.frame.binaryChoice'></span>

<h3>Description</h3>

<p>Return the variables used for estimating a binary choice model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binaryChoice'
model.frame( formula, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.binaryChoice_+3A_formula">formula</code></td>
<td>
<p>object of class <code>binaryChoice</code>.</p>
</td></tr>
<tr><td><code id="model.frame.binaryChoice_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods
(e.g. <code><a href="stats.html#topic+model.frame">model.frame</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing all variables used for the estimation.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen,
Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+binaryChoice">binaryChoice</a></code>, <code><a href="#topic+probit">probit</a></code>,
<code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="#topic+model.matrix.binaryChoice">model.matrix.binaryChoice</a></code>,
and <code><a href="#topic+probit-methods">probit-methods</a></code>.</p>

<hr>
<h2 id='model.frame.selection'>Data of Selection Models</h2><span id='topic+model.frame.selection'></span>

<h3>Description</h3>

<p>Return the variables used for estimating a sample selection model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
model.frame(formula, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.selection_+3A_formula">formula</code></td>
<td>
<p>object of class <code>selection</code>.</p>
</td></tr>
<tr><td><code id="model.frame.selection_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods
(e.g. <code><a href="stats.html#topic+model.frame">model.frame</a></code> or <code><a href="#topic+model.frame.binaryChoice">model.frame.binaryChoice</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing all variables used for the estimation.  The
&ldquo;terms&rdquo; attribute contains the terms for the selection equation.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="#topic+selection">selection</a></code>,
<code><a href="#topic+model.matrix.selection">model.matrix.selection</a></code>, and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>

<hr>
<h2 id='model.matrix.binaryChoice'>Design Matrix of Binary Choice Models</h2><span id='topic+model.matrix.binaryChoice'></span>

<h3>Description</h3>

<p>Create design matrix of binary choice models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binaryChoice'
model.matrix( object, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.binaryChoice_+3A_object">object</code></td>
<td>
<p>object of class <code>binaryChoice</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.binaryChoice_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The design matrix of binary choice models.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen,
Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+binaryChoice">binaryChoice</a></code>, <code><a href="#topic+probit">probit</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+model.frame.binaryChoice">model.frame.binaryChoice</a></code>,
and <code><a href="#topic+probit-methods">probit-methods</a></code>.</p>

<hr>
<h2 id='model.matrix.selection'>Design Matrix of Selection Models</h2><span id='topic+model.matrix.selection'></span>

<h3>Description</h3>

<p>Create design matrix of sample selection models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
model.matrix(object, part = "outcome", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.selection_+3A_object">object</code></td>
<td>
<p>object of class <code>selection</code>.</p>
</td></tr>
<tr><td><code id="model.matrix.selection_+3A_part">part</code></td>
<td>
<p>character string indication which design matrix/matrices to extract:
&quot;outcome&quot; for the design matrix/matrices of the outcome equation(s) or
&quot;selection&quot; for the design matrix of the selection equation.</p>
</td></tr>
<tr><td><code id="model.matrix.selection_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods
(e.g. <code><a href="#topic+model.matrix.binaryChoice">model.matrix.binaryChoice</a></code> or <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If argument <code>part</code> is <code>"selection"</code>,
the design matrix of the selection equation is returned.
</p>
<p>If argument <code>part</code> is <code>"outcome"</code>,
the design matrix of the outcome equation (tobit-2 or treatment
model)
or a list of two outcome matrices (tobit-5 model) is returned.
All unobserved outcomes, including the corresponding explanatory
variables
are set to <code>NA</code>, even in case where
valid values were supplied
for estimation.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+selection">selection</a></code>,
<code><a href="#topic+model.frame.selection">model.frame.selection</a></code>, and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>

<hr>
<h2 id='Mroz87'>U.S. Women's Labor Force Participation</h2><span id='topic+Mroz87'></span>

<h3>Description</h3>

<p>The <code>Mroz87</code> data frame contains data about 753 married women.
These data are collected within the &quot;Panel Study of Income Dynamics&quot; (PSID).
Of the 753 observations, the first 428 are for women with positive hours
worked in 1975, while the remaining 325 observations are for women who
did not work for pay in 1975.  A more complete discussion of the data is
found in Mroz (1987), Appendix 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mroz87)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>lfp</dt><dd><p>Dummy variable for labor-force participation.</p>
</dd>
<dt>hours</dt><dd><p>Wife's hours of work in 1975.</p>
</dd>
<dt>kids5</dt><dd><p>Number of children 5 years old or younger.</p>
</dd>
<dt>kids618</dt><dd><p>Number of children 6 to 18 years old.</p>
</dd>
<dt>age</dt><dd><p>Wife's age.</p>
</dd>
<dt>educ</dt><dd><p>Wife's educational attainment, in years.</p>
</dd>
<dt>wage</dt><dd><p>Wife's average hourly earnings, in 1975 dollars.</p>
</dd>
<dt>repwage</dt><dd><p>Wife's wage reported at the time of the 1976 interview.</p>
</dd>
<dt>hushrs</dt><dd><p>Husband's hours worked in 1975.</p>
</dd>
<dt>husage</dt><dd><p>Husband's age.</p>
</dd>
<dt>huseduc</dt><dd><p>Husband's educational attainment, in years.</p>
</dd>
<dt>huswage</dt><dd><p>Husband's wage, in 1975 dollars.</p>
</dd>
<dt>faminc</dt><dd><p>Family income, in 1975 dollars.</p>
</dd>
<dt>mtr</dt><dd><p>Marginal tax rate facing the wife.</p>
</dd>
<dt>motheduc</dt><dd><p>Wife's mother's educational attainment, in years.</p>
</dd>
<dt>fatheduc</dt><dd><p>Wife's father's educational attainment, in years.</p>
</dd>
<dt>unem</dt><dd><p>Unemployment rate in county of residence, in percentage points.</p>
</dd>
<dt>city</dt><dd><p>Dummy variable = 1 if live in large city, else 0.</p>
</dd>
<dt>exper</dt><dd><p>Actual years of wife's previous labor market experience.</p>
</dd>
<dt>nwifeinc</dt><dd><p>Non-wife income.</p>
</dd>
<dt>wifecoll</dt><dd><p>Dummy variable for wife's college attendance.</p>
</dd>
<dt>huscoll</dt><dd><p>Dummy variable for husband's college attendance.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mroz, T. A. (1987)
The sensitivity of an empirical model of married women's hours of work to
economic and statistical assumptions.
<em>Econometrica</em> <b>55</b>, 765&ndash;799.
</p>
<p>PSID Staff, The Panel Study of Income Dynamics,
Institute for Social ResearchPanel Study of Income Dynamics,
University of Michigan, <a href="https://psidonline.isr.umich.edu">https://psidonline.isr.umich.edu</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Wooldridge( 2003 ): example 17.5, page 590
data( Mroz87 )
# Two-step estimation
summary( heckit( lfp ~ nwifeinc + educ + exper + I( exper^2 ) + age +
   kids5 + kids618, log( wage ) ~ educ + exper + I( exper^2 ), Mroz87,
   method = "2step" ) )
</code></pre>

<hr>
<h2 id='nlswork'>National Longitudinal Survey of Young Working Women</h2><span id='topic+nlswork'></span>

<h3>Description</h3>

<p>The <code>nlswork</code> data frame contains data about 4711 young working women
who had an age of 14&ndash;26 years in 1968.
These data are collected within the &quot;National Longitudinal Survey&quot;
over the years 1968-1988 (with gaps).
There are 28534 observations in total.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nlswork)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>idcode</dt><dd><p>NLS ID.</p>
</dd>
<dt>year</dt><dd><p>interview year.</p>
</dd>
<dt>birth_yr</dt><dd><p>birth year.</p>
</dd>
<dt>age</dt><dd><p>age in current year.</p>
</dd>
<dt>race</dt><dd><p>1=white, 2=black, 3=other.</p>
</dd>
<dt>msp</dt><dd><p>1 if married, spouse present.</p>
</dd>
<dt>nev_mar</dt><dd><p>1 if never married.</p>
</dd>
<dt>grade</dt><dd><p>current grade completed.</p>
</dd>
<dt>collgrad</dt><dd><p>1 if college graduate.</p>
</dd>
<dt>not_smsa</dt><dd><p>1 if not SMSA.</p>
</dd>
<dt>c_city</dt><dd><p>1 if central city.</p>
</dd>
<dt>south</dt><dd><p>1 if south.</p>
</dd>
<dt>ind_code</dt><dd><p>industry of employment.</p>
</dd>
<dt>occ_code</dt><dd><p>occupation.</p>
</dd>
<dt>union</dt><dd><p>1 if union.</p>
</dd>
<dt>wks_ue</dt><dd><p>weeks unemployed last year.</p>
</dd>
<dt>ttl_exp</dt><dd><p>total work experience.</p>
</dd>
<dt>tenure</dt><dd><p>job tenure, in years.</p>
</dd>
<dt>hours</dt><dd><p>usual hours worked.</p>
</dd>
<dt>wks_work</dt><dd><p>weeks worked last year.</p>
</dd>
<dt>ln_wage</dt><dd><p>ln(wage/GNP deflator).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Two different versions of this data set are available on the internet.
They are slighly different:
The variable <code>wks_work</code> (weeks worked last year)
is <code>101</code> in this version (from Stata),
but <code>NA</code> in the version provided by the Boston College
for the observation with <code>idcode = 1</code> and <code>year = 83</code>.
Moreover, this variable
is <code>NA</code> in this version (from Stata),
but <code>104</code> in the version provided by the Boston College
for the observation with <code>idcode = 2</code> and <code>year = 87</code>.
</p>


<h3>Source</h3>

<p>Datasets for Stata Longitudinal/Panel-Data Reference Manual, Release 10:
National Longitudinal Survey. Young Women 14-26 years of age in 1968,
<a href="https://www.stata-press.com/data/r10/nlswork.dta">https://www.stata-press.com/data/r10/nlswork.dta</a>.
</p>


<h3>References</h3>

<p>Boston College,
National Longitudinal Survey. Young Women 14-26 years of age in 1968,
<a href="https://fmwww.bc.edu/ec-p/data/stata/nlswork.dta">https://fmwww.bc.edu/ec-p/data/stata/nlswork.dta</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( "nlswork" )
summary( nlswork )

## Not run: 
library( "plm" )
nlswork &lt;- plm.data( nlswork, c( "idcode", "year" ) )
plmResult &lt;- plm( ln_wage ~ union + age + grade + not_smsa + south + occ_code,
   data = nlswork, model = "random" )
summary( plmResult )

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.probit'>Predict method for fitted probit models</h2><span id='topic+predict.probit'></span>

<h3>Description</h3>

<p>Calculate predicted values for fitted <code><a href="#topic+probit">probit</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'probit'
predict( object, newdata = NULL, type = "link", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.probit_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>probit</code>.</p>
</td></tr>
<tr><td><code id="predict.probit_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables
with which to predict.
If omitted, the fitted linear predictors or the fitted response values
are returned.</p>
</td></tr>
<tr><td><code id="predict.probit_+3A_type">type</code></td>
<td>
<p>the type of prediction.
If this argument is <code>"link"</code> (the default),
the predicted linear predictors are returned.
If this argument is <code>"response"</code>,
the predicted probabilities are returned.</p>
</td></tr>
<tr><td><code id="predict.probit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the predicted values.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen and the R Core Team (the code of <code>predict.probit</code>
is partly based on the code of <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>
and <code><a href="stats.html#topic+predict.glm">predict.glm</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probit">probit</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>,
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>, <code><a href="#topic+residuals.probit">residuals.probit</a></code>,
and <code><a href="#topic+probit-methods">probit-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## female labour force participation probability
data( "Mroz87" )
m &lt;- probit( lfp ~ kids5 + kids618 + educ + hushrs +
   huseduc + huswage + mtr + motheduc, data=Mroz87 )
predict( m )                            # equal to linearPredictors(m)
predict( m, type = "response" )         # equal to fitted(m)
predict( m, newdata = Mroz87[ 3:9, ] )  # equal to linearPredictors(m)[3:9]
predict( m, newdata = Mroz87[ 3:9, ], type = "response" ) # equal to fitted(m)[3:9]
</code></pre>

<hr>
<h2 id='predict.selection'>Predict method for fitted sample selection models</h2><span id='topic+predict.selection'></span>

<h3>Description</h3>

<p>Calculate predicted values for sample selection models
fitted with function <code><a href="#topic+selection">selection</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'selection'
predict( object, newdata = NULL,
   part = ifelse( type %in% c( "unconditional", "conditional" ),
      "outcome", "selection" ),
   type = "unconditional", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.selection_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>selection</code>.</p>
</td></tr>
<tr><td><code id="predict.selection_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables
with which to predict.
If omitted, the fitted linear predictors or the fitted response values
are returned.</p>
</td></tr>
<tr><td><code id="predict.selection_+3A_part">part</code></td>
<td>
<p>character string indicating for which equation
the predicted variables should be calculated:
<code>"selection"</code> for the predicted values of the selection equation and
<code>"outcome"</code> for the predicted values of the outcome equation;
this argument is automatically chosen depending on the value
of argument <code>type</code>.</p>
</td></tr>
<tr><td><code id="predict.selection_+3A_type">type</code></td>
<td>
<p>if argument <code>type</code> is <code>"link"</code>
and argument <code>part</code> is <code>"selection"</code>,
the linear predictors of the selection equation are returned;
if argument <code>type</code> is <code>"response"</code>
and argument <code>part</code> is <code>"selection"</code>,
the predicted probabilities of the selection equation are returned;
if argument <code>type</code> is <code>"unconditional"</code>
and argument <code>part</code> is <code>"outcome"</code>,
the unconditional expectations are returned,
i.e. <code>E[y|X] = X %*% beta</code>;
if argument <code>type</code> is <code>"conditional"</code>
and argument <code>part</code> is <code>"outcome"</code>,
the conditional expectations are returned,
i.e. <code>E[y|X,Z,w=1] = X %*% beta
      + rho * sigma * dnorm( Z %*% gamma ) / pnorm( Z %*% gamma )</code>.</p>
</td></tr>
<tr><td><code id="predict.selection_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In most cases, a numeric vector of the predicted values is returned.
However, there are three exceptions:
(i) when predicting the unconditional expectations of a Tobit-5 model,
a matrix with two columns is returned,
where the two columns correspond to the two outcome equations
(E[yo1] and E[yo2]);
(ii) when predicting the conditional expectations of a Tobit-2 model,
a matrix with two columns is returned,
where the first column returns the expectations
conditional on the observation being not selected (E[yo|ys=0]),
while the second column returns the expectations
conditional on the observation being selected (E[yo|ys=1]);
(iii) when predicting the conditional expectations of a Tobit-5 model,
a matrix with four columns is returned,
where the first two columns return the conditional expectations
of the first outcome equation (E[yo1|ys=0] and E[yo1|ys=1])
and the last two columns return the conditional expectations
of the second outcome equation (E[yo2|ys=0] and E[yo2|ys=1]).
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen and &lsquo;fg nu&rsquo;
(the code is partly based on the code posted by &lsquo;fg nu&rsquo; at
<a href="https://stackoverflow.com/questions/14005788/predict-function-for-heckman-model">https://stackoverflow.com/questions/14005788/predict-function-for-heckman-model</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selection">selection</a></code>, <code><a href="stats.html#topic+predict">predict</a></code>,
<code><a href="#topic+predict.probit">predict.probit</a></code>, <code><a href="#topic+residuals.selection">residuals.selection</a></code>,
and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Greene( 2003 ): example 22.8, page 786
data( Mroz87 )
Mroz87$kids  &lt;- ( Mroz87$kids5 + Mroz87$kids618 &gt; 0 )

# ML estimation
m &lt;- selection( lfp ~ age + I( age^2 ) + faminc + kids + educ,
   wage ~ exper + I( exper^2 ) + educ + city, Mroz87 )
   
predict( m )
predict( m, type = "conditional" ) 
predict( m, type = "link" ) 
predict( m, type = "response" ) 
predict( m, newdata = Mroz87[ 3:9, ] ) 
</code></pre>

<hr>
<h2 id='probit'>Binary choice models.</h2><span id='topic+binaryChoice'></span><span id='topic+probit'></span>

<h3>Description</h3>

<p>Binary Choice models.  These models are estimated by
<code>binaryChoice</code>, intended to be called by wrappers like
<code>probit</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probit(formula, weights = NULL, ...)
binaryChoice(formula, subset, na.action, start = NULL, data = sys.frame(sys.parent()),
             x=FALSE, y = FALSE, model = FALSE, method="ML",
userLogLik=NULL,
             cdfLower, cdfUpper=function(x) 1 - cdfLower(x),
logCdfLower=NULL, logCdfUpper=NULL,
pdf, logPdf=NULL, gradPdf,
maxMethod="Newton-Raphson",
             ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probit_+3A_formula">formula</code></td>
<td>
<p>a symbolic description of the model to be fit, in the
form <code>response ~ explanatory variables</code>
(see also details).</p>
</td></tr>
<tr><td><code id="probit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; 
to be used in the fitting process. Should be NULL or a numeric vector.</p>
</td></tr>
<tr><td><code id="probit_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="probit_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  The default is set by the 'na.action' setting
of 'options', and is 'na.fail' if that is unset.  The
'factory-fresh' default is 'na.omit'.  Another possible value
is 'NULL', no action.  Value 'na.exclude' can be useful.</p>
</td></tr>
<tr><td><code id="probit_+3A_start">start</code></td>
<td>
<p>inital value of parameters.</p>
</td></tr>
<tr><td><code id="probit_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the
model. If not found in data, the
variables are taken from environment(formula), typically the
environment from which <code>probit</code> is called.</p>
</td></tr>
<tr><td><code id="probit_+3A_x">x</code>, <code id="probit_+3A_y">y</code>, <code id="probit_+3A_model">model</code></td>
<td>
<p>logicals. If TRUE the corresponding components of
the fit (the
model matrix, the response, the model frame) are returned.</p>
</td></tr>
<tr><td><code id="probit_+3A_method">method</code></td>
<td>
<p>the method to use; for fitting,
currently only method = &quot;ML&quot; (Maximum Likelihood) is supported;
method = &quot;model.frame&quot; returns the model frame (the same as
with model = TRUE, see below).</p>
</td></tr>
<tr><td><code id="probit_+3A_userloglik">userLogLik</code></td>
<td>
<p>log-likelihood function.  A function of the
parameter to be estimated, which computes
the log likelihood.  If supplied, it will be used instead of
<code>cdfLower</code> and similar parameters.  This allows user to
fine-tune the likelihood function such as introducing robust
approximations.  It might return the corresponding gradient and
Hessian as approximations, see <code><a href="maxLik.html#topic+maxNR">maxNR</a></code>.
</p>
</td></tr>
<tr><td><code id="probit_+3A_cdflower">cdfLower</code>, <code id="probit_+3A_cdfupper">cdfUpper</code>, <code id="probit_+3A_pdf">pdf</code>, <code id="probit_+3A_gradpdf">gradPdf</code></td>
<td>
<p>function, lower and upper tail of the
cumulative distribution function of the disturbance term,
corresponding probability density function, and gradient of the
density function.  These
functions must take a numeric vector as the argument, and return
numeric vector of the probability/gradient values.</p>
</td></tr>
<tr><td><code id="probit_+3A_logcdflower">logCdfLower</code>, <code id="probit_+3A_logcdfupper">logCdfUpper</code>, <code id="probit_+3A_logpdf">logPdf</code></td>
<td>
<p>logs of the corresponding
functions.  Providing these may improve precision in extreme tail.
If not provided, simply logs are takes of the corresponding non-log
values.</p>
</td></tr>
<tr><td><code id="probit_+3A_maxmethod">maxMethod</code></td>
<td>
<p>character, a maximisation method supported by
<code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.  This is only useful if using
a user-supplied likelihood function.
</p>
</td></tr>
<tr><td><code id="probit_+3A_...">...</code></td>
<td>
<p>further arguments for <code>binaryChoice</code> and
<code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependent variable for the binary choice models must have exactly
two levels (e.g. '0' and '1', 'FALSE' and 'TRUE', or 'no' and 'yes').
Internally, the first level is always coded '0' ('failure') and
the second level as '1' ('success'), no matter of the actual value.
However, by default the levels are ordered alphabetically and this
makes puts '1' after '0', 'TRUE' after 'FALSE' nad 'yes' after 'no'.
</p>
<p>Via the distribution function parameters, <code>binaryChoice</code>
supports generic latent linear index binary choice models with
additive disturbance terms.  It is intended to be called by wrappers
like <code>probit</code>.  However, it is also visible in the namespace as
the user may want to implement her own models using another
distribution of the disturbance term.
</p>
<p>The model is estimated using Maximum Likelihood and Newton-Raphson
optimizer.
</p>
<p><code>probit</code> implements an outlier-robust log-likelihood (Demidenko,
2001).  In case of large outliers the analytic Hessian is
singular while Fisher scoring approximation (used, for instance, by
<code><a href="stats.html#topic+glm">glm</a></code>) is invertible.  Those values are not
reliable in case of outliers.
</p>
<p>No attempt is made to establish the existence of the
estimator. 
</p>


<h3>Value</h3>

<p>An object of class &quot;binaryChoice&quot;.  It is a list with following components:
</p>
<table>
<tr><td><code>LRT</code></td>
<td>
<p>Likelihood ration test.  The full model is tested against
H0: the parameters (besides constant) have no effect on the result.  This is a list
with components
</p>

<ul>
<li><p>LRTThe LRT value
</p>
</li>
<li><p>dfDegrees of freedom for LRT (= df of the model - 1)
</p>
</li></ul>

<p>LRT is distributed by chi2(df) under H0.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A list with following background information:
</p>

<ul>
<li><p>nParamNumber of parameters of the model including constant
</p>
</li>
<li><p>nObsNumber of the observations
</p>
</li>
<li><p>N1Number of observations with non-zero (true) response
</p>
</li>
<li><p>N0Number of observations with zero (false) response
</p>
</li></ul>

</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>degrees of freedom of the residuals.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the model response used.  The
response is represented internally as 0/1 integer vector.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model frame, only if <code>model = TRUE</code> or
<code>method = "model.frame"</code>.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>information returned by <code><a href="stats.html#topic+model.frame">model.frame</a></code> on
the special handling of  NA s.</p>
</td></tr>
</table>
<p>Other components are inherited from <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.
</p>
<p><code>probit</code> adds class &quot;probit&quot; and following components to
the &quot;binaryChoice&quot; object:
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>the family object used (<code><a href="stats.html#topic+binomial">binomial</a></code> with
<code>link="probit"</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a>, Arne Henningsen</p>


<h3>References</h3>

<p>Demidenko, Eugene (2001) &ldquo;Computational aspects of probit
model&rdquo;, Mathematical Communications 6, 233-247
</p>


<h3>See Also</h3>

<p><code><a href="maxLik.html#topic+maxLik">maxLik</a></code> for ready-packaged likelihood maximisation
routines and methods, <code><a href="stats.html#topic+glm">glm</a></code> for generalised linear models,
including probit, <code><a href="stats.html#topic+binomial">binomial</a></code>, and <code><a href="#topic+probit-methods">probit-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple MC trial: note probit assumes normal errors
x &lt;- runif(100)
e &lt;- 0.5*rnorm(100)
y &lt;- x + e
summary(probit((y &gt; 0) ~ x))
## female labour force participation probability
data(Mroz87)
Mroz87$kids &lt;- Mroz87$kids5 &gt; 0 | Mroz87$kids618 &gt; 0
Mroz87$age30.39 &lt;- Mroz87$age &lt; 40
Mroz87$age50.60 &lt;- Mroz87$age &gt;= 50
summary(probit(lfp ~ kids + age30.39 + age50.60 + educ + hushrs +
               huseduc + huswage + mtr + motheduc, data=Mroz87))
</code></pre>

<hr>
<h2 id='probit-methods'>probit-methods</h2><span id='topic+probit-methods'></span><span id='topic+fitted.probit'></span><span id='topic+logLik.probit'></span><span id='topic+nobs.probit'></span><span id='topic+nObs.probit'></span><span id='topic+print.probit'></span>

<h3>Description</h3>

<p>Methods for probit models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'probit'
fitted(object, ... )

## S3 method for class 'probit'
logLik(object, ... )

## S3 method for class 'probit'
nobs(object, ... )
             
## S3 method for class 'probit'
nObs(x, ... )
             
## S3 method for class 'probit'
print( x, digits = max(3, getOption("digits") - 3), ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probit-methods_+3A_object">object</code>, <code id="probit-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>probit</code>.</p>
</td></tr>
<tr><td><code id="probit-methods_+3A_digits">digits</code></td>
<td>
<p>the minimum number of significant digits of the coefficients
to be printed.</p>
</td></tr>
<tr><td><code id="probit-methods_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fitted</code> method returns a vector of fitted values (probabilities).
The <code>logLik</code> method returns the log likelihood value of the model.
The <code>nobs</code> and <code>nObs</code> methods return the number of observations.
The <code>print</code> method prints the call and the estimated coefficients.
</p>
<p>Furthermore, some standard methods can be applied to probit models:
the <code><a href="stats.html#topic+coef">coef</a></code> method returns the vector
of the estimated parameters.
The <code><a href="stats.html#topic+df.residual">df.residual</a></code> method returns the degrees of freedom
of the residuals.
The <code><a href="lmtest.html#topic+lrtest">lrtest</a></code> method can be used to perform
likelihood-ratio tests.
The <code><a href="miscTools.html#topic+stdEr">stdEr</a></code> method returns the vector
of the standard errors of the estimated parameters.
The <code><a href="stats.html#topic+vcov">vcov</a></code> method returns the variance covariance matrix
of the estimated coefficients.
</p>
<p>The methods <code><a href="#topic+linearPredictors.probit">linearPredictors.probit</a></code>,
<code><a href="#topic+model.frame.binaryChoice">model.frame.binaryChoice</a></code>,
<code><a href="#topic+model.matrix.binaryChoice">model.matrix.binaryChoice</a></code>,
<code><a href="#topic+residuals.probit">residuals.probit</a></code>, and <code><a href="#topic+summary.probit">summary.probit</a></code>
are described at seperate help pages.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probit">probit</a></code>, <code><a href="#topic+summary.probit">summary.probit</a></code>,
and <code><a href="#topic+selection-methods">selection-methods</a></code>.</p>

<hr>
<h2 id='RandHIE'>RAND Health Insurance Experiment</h2><span id='topic+RandHIE'></span>

<h3>Description</h3>

<p>'The RAND Health Insurance Experiment (RAND HIE) was a comprehensive study
of health care cost, utilization and outcome in the United States.
It is the only randomized study of health insurance,
and the only study which can give definitive evidence as to the causal effects
of different health insurance plans.
[...]
Although the fieldwork of the study was conducted between 1974 and 1982,
the results are still highly relevant,
since RAND HIE is the only study which can make causal statements.'
(Wikipedia, RAND Health Insurance Experiment, <a href="https://en.wikipedia.org/w/index.php?title=RAND_Health_Insurance_Experiment&amp;oldid=110166949">https://en.wikipedia.org/w/index.php?title=RAND_Health_Insurance_Experiment&amp;oldid=110166949</a>, accessed April 8, 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RandHIE)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>plan</dt><dd><p>HIE plan number.</p>
</dd>
<dt>site</dt><dd><p>Participant's  place of residence
when the participant was initially enrolled.</p>
</dd>
<dt>coins</dt><dd><p>Coinsurance rate.</p>
</dd>
<dt>tookphys</dt><dd><p>Took baseline physical.</p>
</dd>
<dt>year</dt><dd><p>Study year.</p>
</dd>
<dt>zper</dt><dd><p>Person identifier.</p>
</dd>
<dt>black</dt><dd><p>1 if race of household head is black.</p>
</dd>
<dt>income</dt><dd><p>Family income.</p>
</dd>
<dt>xage</dt><dd><p>Age in years.</p>
</dd>
<dt>female</dt><dd><p>1 if person is female.</p>
</dd>
<dt>educdec</dt><dd><p>Education of household head in years.</p>
</dd>
<dt>time</dt><dd><p>Time eligible during the year.</p>
</dd>
<dt>outpdol</dt><dd><p>Outpatient expenses:
all covered outpatient medical services
excluding dental care, outpatient psychotherapy,
outpatient drugs or supplies.</p>
</dd>
<dt>drugdol</dt><dd><p>Drug expenses:
all covered outpatient and dental drugs.</p>
</dd>
<dt>suppdol</dt><dd><p>Supply expenses:
all covered outpatient supplies including dental.</p>
</dd>
<dt>mentdol</dt><dd><p>Psychotherapy expenses:
all covered outpatient psychotherapy services including injections
excluding charges for visits in excess of 52 per year,
prescription drugs, and inpatient care.</p>
</dd>
<dt>inpdol</dt><dd><p>Inpatient expenses:
all covered inpatient expenses in a hospital, mental hospital,
or nursing home,
excluding outpatient care and renal dialysis.</p>
</dd>
<dt>meddol</dt><dd><p>Medical expenses:
all covered inpatient and outpatient services,
including drugs, supplies, and inpatient costs of newborns
excluding dental care and outpatient psychotherapy.</p>
</dd>
<dt>totadm</dt><dd><p>Hospital admissions:
annual number of covered hospitalizations.</p>
</dd>
<dt>inpmis</dt><dd><p>Incomplete Hospital Records:
missing inpatient records.</p>
</dd>
<dt>mentvis</dt><dd><p>Psychotherapy visits:
indicates the annual number of outpatient visits for psychotherapy.
It includes billed visits only.
The limit was 52 covered visits per person per year.
The count includes an initial visit to a psychiatrist or psychologist.</p>
</dd>
<dt>mdvis</dt><dd><p>Face-to-Face visits to physicians:
annual covered outpatient visits with physician providers
(excludes dental, psychotherapy, and
radiology/anesthesiology/pathology-only visits).</p>
</dd>
<dt>notmdvis</dt><dd><p>Face-to-Face visits to nonphysicians:
annual covered outpatient visits with nonphysician providers
such as speech and physical therapists, chiropractors,
podiatrists, acupuncturists, Christian Science etc.
(excludes dental, healers, psychotherapy,
and radiology/anesthesiology/pathology-only visits).</p>
</dd>
<dt>num</dt><dd><p>Family size.</p>
</dd>
<dt>mhi</dt><dd><p>Mental health index.</p>
</dd>
<dt>disea</dt><dd><p>Number of chronic diseases.</p>
</dd>
<dt>physlm</dt><dd><p>Physical limitations.</p>
</dd>
<dt>ghindx</dt><dd><p>General health index.</p>
</dd>
<dt>mdeoff</dt><dd><p>Maximum expenditure offer.</p>
</dd>
<dt>pioff</dt><dd><p>Participation incentive payment.</p>
</dd>
<dt>child</dt><dd><p>1 if age is less than 18 years.</p>
</dd>
<dt>fchild</dt><dd><p><code>female * child</code>.</p>
</dd>
<dt>lfam</dt><dd><p>log of <code>num</code> (family size).</p>
</dd>
<dt>lpi</dt><dd><p>log of <code>pioff</code> (participation incentive payment).</p>
</dd>
<dt>idp</dt><dd><p>1 if individual deductible plan.</p>
</dd>
<dt>logc</dt><dd><p><code>log(coins+1)</code>.</p>
</dd>
<dt>fmde</dt><dd><p>0 if <code>idp=1</code>,
<code>ln(max(1,mdeoff/(0.01*coins)))</code> otherwise.</p>
</dd>
<dt>hlthg</dt><dd><p>1 if self-rated health is good
&ndash; baseline is excellent self-rated health.</p>
</dd>
<dt>hlthf</dt><dd><p>1 if self-rated health is fair
&ndash; baseline is excellent self-rated health.</p>
</dd>
<dt>hlthp</dt><dd><p>1 if self-rated health is poor
&ndash; baseline is excellent self-rated health.</p>
</dd>
<dt>xghindx</dt><dd><p><code>ghindx</code> (general healt index)
with imputations of missing values.</p>
</dd>
<dt>linc</dt><dd><p>log of <code>income</code> (family income).</p>
</dd>
<dt>lnum</dt><dd><p>log of <code>num</code> (family size).</p>
</dd>
<dt>lnmeddol</dt><dd><p>log of <code>meddol</code> (medical expenses).</p>
</dd>
<dt>binexp</dt><dd><p>1 if <code>meddol</code> &gt; 0.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data sets of Cameron and Trivedi (2005),
<a href="http://cameron.econ.ucdavis.edu/mmabook/mmadata.html">http://cameron.econ.ucdavis.edu/mmabook/mmadata.html</a>.
</p>
<p>Additional information of variables
from Table 20.4 of Cameron and Trivedi (2005)
and from Newhouse (1999).
</p>


<h3>References</h3>

<p>Cameron, A. C. and Trivedi, P. K. (2005)
<em>Microeconometrics: Methods and Applications</em>,
Cambridge University Press.
</p>
<p>Newhouse, J. P. (1999)
<em>RAND Health Insurance Experiment [in Metropolitan and Non-Metropolitan
Areas of the United States], 1974&ndash;1982</em>,
ICPSR Inter-university Consortium for Political and Social Research,
Aggregated Claims Series,
Volume 1: Codebook for Fee-for-Service Annual Expenditures and Visit Counts,
ICPSR 6439.
</p>
<p>Wikipedia, <em>RAND Health Insurance Experiment</em>,
<a href="https://en.wikipedia.org/wiki/RAND_Health_Insurance_Experiment">https://en.wikipedia.org/wiki/RAND_Health_Insurance_Experiment</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Cameron and Trivedi (2005): Section 16.6, page 553ff
data( RandHIE )
subsample &lt;- RandHIE$year == 2 &amp; !is.na( RandHIE$educdec )
selectEq &lt;- binexp ~ logc + idp + lpi + fmde + physlm + disea +
   hlthg + hlthf + hlthp + linc + lfam + educdec + xage + female +
   child + fchild + black
outcomeEq &lt;- lnmeddol ~ logc + idp + lpi + fmde + physlm + disea +
   hlthg + hlthf + hlthp + linc + lfam + educdec + xage + female +
   child + fchild + black
# ML estimation
cameron &lt;- selection( selectEq, outcomeEq, data = RandHIE[ subsample, ] )
summary( cameron )
</code></pre>

<hr>
<h2 id='residuals.probit'>Residuals of probit models</h2><span id='topic+residuals.probit'></span>

<h3>Description</h3>

<p>Calculate residuals of <code><a href="#topic+probit">probit</a></code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'probit'
residuals( object, type = "deviance", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.probit_+3A_object">object</code></td>
<td>
<p>an object of class <code>probit</code>.</p>
</td></tr>
<tr><td><code id="residuals.probit_+3A_type">type</code></td>
<td>
<p>the type of residuals which should be returned.
The alternatives are: &quot;deviance&quot; (default), &quot;pearson&quot;, and &quot;response&quot;
(see details).</p>
</td></tr>
<tr><td><code id="residuals.probit_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The residuals are calculated with following formulas:
</p>
<p>Response residuals:
<code class="reqn">r_i = y_i - \hat{y}_i</code>
</p>
<p>Pearson residuals:
<code class="reqn">r_i = ( y_i - \hat{y}_i ) / \sqrt{ \hat{y}_i ( 1 - \hat{y}_i ) }</code>
</p>
<p>Deviance residuals:
<code class="reqn">r_i = \sqrt{ -2 \log( \hat{y}_i ) }</code> if <code class="reqn">y_i = 1</code>,
<code class="reqn">r_i = - \sqrt{ -2 \log( 1 - \hat{y}_i ) }</code> if <code class="reqn">y_i = 0</code>
</p>
<p>Here, <code class="reqn">r_i</code> is the <code class="reqn">i</code>th residual,
<code class="reqn">y_i</code> is the <code class="reqn">i</code>th response,
<code class="reqn">\hat{y}_i = \Phi( x_i' \hat{\beta} )</code> is the estimated probability
that <code class="reqn">y_i</code> is one,
<code class="reqn">\Phi</code> is the cumulative distribution function of the standard normal
distribution,
<code class="reqn">x_i</code> is the vector of regressors of the <code class="reqn">i</code>th observation, and
<code class="reqn">\hat{\beta}</code> is the vector of estimated coefficients.
</p>
<p>More details are available in Davison &amp; Snell (1991).
</p>


<h3>Value</h3>

<p>A numeric vector of the residuals.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen
</p>


<h3>References</h3>

<p>Davison, A. C. and Snell, E. J. (1991)
<em>Residuals and diagnostics.</em>
In: Statistical Theory and Modelling. In Honour of Sir David Cox,
edited by Hinkley, D. V., Reid, N. and Snell, E. J.,
Chapman &amp; Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+probit">probit</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>,
<code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>, and <code><a href="#topic+probit-methods">probit-methods</a></code>.</p>

<hr>
<h2 id='residuals.selection'>Residuals of Selection Models</h2><span id='topic+residuals.selection'></span>

<h3>Description</h3>

<p>Calculate residuals of sample selection models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
residuals(object, part = "outcome",
   type = "deviance", ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.selection_+3A_object">object</code></td>
<td>
<p>object of class <code>selection</code>.</p>
</td></tr>
<tr><td><code id="residuals.selection_+3A_part">part</code></td>
<td>
<p>character string indication which residuals to extract:
&quot;outcome&quot; for the fitted values of the outcome equation(s) or
&quot;selection&quot; for the fitted values of the selection equation.</p>
</td></tr>
<tr><td><code id="residuals.selection_+3A_type">type</code></td>
<td>
<p>the type of residuals (see section &lsquo;Details&rsquo;).
The alternatives are: &quot;deviance&quot; (default), &quot;pearson&quot;, and &quot;response&quot;
(see <code><a href="#topic+residuals.probit">residuals.probit</a></code>).</p>
</td></tr>
<tr><td><code id="residuals.selection_+3A_...">...</code></td>
<td>
<p>further arguments passed to other methods
(e.g. <code><a href="#topic+residuals.probit">residuals.probit</a></code> or <code><a href="stats.html#topic+residuals">residuals</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of the fitted values
that are used to calculate the residuals
is described in the details section of the documentation
of <code><a href="#topic+fitted.selection">fitted.selection</a></code>.
</p>
<p>Argument <code>type</code> is only used for binary dependent variables,
i.e. if argument <code>part</code> is equal <code>"selection"</code>
or the dependent variable of the outcome model is binary.
Hence, argument <code>type</code> is ignored
if argument <code>part</code> is equal <code>"outcome"</code>
and the dependent variable of the outcome model is numeric.
</p>


<h3>Value</h3>

<p>A numeric vector of the residuals.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="#topic+selection">selection</a></code>,
<code><a href="#topic+fitted.selection">fitted.selection</a></code>, <code><a href="#topic+residuals.probit">residuals.probit</a></code>,
and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>

<hr>
<h2 id='sampleSelection-internal'> Internal sampleSelection Functions </h2><span id='topic+sampleSelection-internal'></span><span id='topic+tobitTfit'></span><span id='topic+lambda'></span><span id='topic+CB'></span>

<h3>Description</h3>

<p>Internal <code>sampleSelection</code> Functions
</p>


<h3>Details</h3>

<p>Currently, there are no internal functions in the sampleSelection package.
</p>

<hr>
<h2 id='selection'>Heckman-style selection and treatment effect models</h2><span id='topic+selection'></span><span id='topic+heckit'></span><span id='topic+treatReg'></span>

<h3>Description</h3>

<p>This is the frontend for estimating Heckman-style selection
models either with
one or two outcomes (also known as generalized tobit models).  It
supports binary outcomes and interval outcomes in the single-outcome case.
It also supports normal-distribution based treatment effect models.
</p>
<p>For model specification and more details, see Toomet and Henningsen
(2008) and the included vignettes &ldquo;Sample Selection Models&rdquo;,
&ldquo;Interval Regression with Sample Selection&rdquo;, and
&ldquo;All-Normal Treatment Effects&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selection(selection, outcome, data = sys.frame(sys.parent()),
   weights = NULL, subset, method = "ml",
   type = NULL,
   start = NULL,
   boundaries = NULL,
   ys = FALSE, xs = FALSE, yo = FALSE, xo = FALSE,
   mfs = FALSE, mfo = FALSE,
   printLevel = print.level, print.level=0,
   ...)

heckit( selection, outcome, data = sys.frame(sys.parent()),
   method = "2step", ... )

treatReg(selection, outcome,
   data=sys.frame(sys.parent()),
   mfs=TRUE, mfo=TRUE,
   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection_+3A_selection">selection</code></td>
<td>
<p>formula, the selection equation.</p>
</td></tr>
<tr><td><code id="selection_+3A_outcome">outcome</code></td>
<td>
<p>the outcome equation(s).  Either a single equation (for
tobit 2 models), or a list of two equations (tobit 5 models).</p>
</td></tr>
<tr><td><code id="selection_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>, typically
the environment from which <code>selection</code> is called.</p>
</td></tr>
<tr><td><code id="selection_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; 
to be used in the fitting process. Should be NULL or a numeric vector.
Weights are currently only supported in type-2 models.</p>
</td></tr>
<tr><td><code id="selection_+3A_subset">subset</code></td>
<td>
<p>an optional index vector specifying a subset of
observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="selection_+3A_method">method</code></td>
<td>
<p>how to estimate the model.  Either <code>"ml"</code> for Maximum
Likelihood, <code>"2step"</code> for 2-step estimation,
or <code>"model.frame"</code> for returning the model frame (only).</p>
</td></tr>
<tr><td><code id="selection_+3A_type">type</code></td>
<td>
<p>model type.  <code>NULL</code> will automatically detect the
type, but one may also manually determine it.  Numeric &lsquo;2&rsquo; and &lsquo;5&rsquo; are
tobit-2 and tobit-5 models respectively, and character &ldquo;treatment&rdquo; is treatment
effect model.</p>
</td></tr>
<tr><td><code id="selection_+3A_start">start</code></td>
<td>
<p>vector, initial values for the ML estimation.  If
<code>start</code> does not have names, names are constructed based on the
model frame.</p>
</td></tr>
<tr><td><code id="selection_+3A_boundaries">boundaries</code></td>
<td>
<p>an optional vector of boundaries of the intervals
of the dependent variable of the outcome equation
for sample selection models with interval regression
of the outcome equation.</p>
</td></tr>
<tr><td><code id="selection_+3A_ys">ys</code>, <code id="selection_+3A_yo">yo</code>, <code id="selection_+3A_xs">xs</code>, <code id="selection_+3A_xo">xo</code>, <code id="selection_+3A_mfs">mfs</code>, <code id="selection_+3A_mfo">mfo</code></td>
<td>
<p>logicals.  If true, the response (<code>y</code>),
model matrix (<code>x</code>) or the model frame (<code>mf</code>)
of the selection (<code>s</code>) or outcome
(<code>o</code>) equation(s) are returned.</p>
</td></tr>
<tr><td><code id="selection_+3A_printlevel">printLevel</code>, <code id="selection_+3A_print.level">print.level</code></td>
<td>
<p>integer.  Various debugging information, higher
value gives more information.  The preferred option is &lsquo;printLevel&rsquo;.</p>
</td></tr>
<tr><td><code id="selection_+3A_...">...</code></td>
<td>
<p>additional parameters for the corresponding fitting
functions <code><a href="#topic+tobit2fit">tobit2fit</a></code>, <code><a href="#topic+tobit5fit">tobit5fit</a></code>,
<code><a href="#topic+heckit2fit">heckit2fit</a></code>, <code><a href="#topic+heckit5fit">heckit5fit</a></code>,
and <code><a href="#topic+tobit2Bfit">tobit2Bfit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dependent variable of of the selection equation
(specified by argument <code>selection</code>) must have exactly
two levels (e.g., 'FALSE' and 'TRUE', or '0' and '1').
By default the levels are sorted in increasing order
('FALSE' is before 'TRUE', and '0' is before '1').
If the dependent variable of the outcome equation
(specified by argument <code>outcome</code>) has exactly two levels,
this variable is modelled as a binary variable.
If argument <code>boundaries</code> is specified,
the outcome equation is estimated as interval regression model
and the dependent variable of the outcome equation
must be a categorical (factor) variable
or a variable of strictly positive integer values,
whereas the vector specified by argument <code>boundaries</code>
must have one more element than the number of levels
or the largest integer, respectively.
In all other cases, it is assumed
that the dependent variable of the outcome equation is continuous
and an ordinary sample selection model is estimated. 
</p>
<p>For tobit-2 (sample selection) models,
only those observations are included in the second step estimation
(argument 'outcome'),
where the dependent variable variable of the selection equation
equals the second element of its levels (e.g., 'TRUE' or '1').  
</p>
<p>For tobit-5 (switching regression) models,
in the second step the first outcome equation
(first element of argument 'outcome') is estimated
only for those observations,
where the dependent variable of the selection equation
equals the first element of its levels (e.g., 'FALSE' or '0').
The second outcome equation is estimated
only for those observations,
where this variable equals the second element of its levels
(e.g., 'TRUE' or '1').
</p>
<p>Treatment effect models are a version of tobit-5 models where the two
outcomes are &ldquo;participation&rdquo; and &ldquo;non-participation&rdquo;.
<code>treatReg</code>
takes an equal set of explanatory variables for both of these choices
and assumes that the corresponding parameters are equal.  In typical
treatment effect model the selection outcome variable (participation
decision) is included as an explanatory variable for the outcome.
If this is not done, <code>treatReg</code> amounts to estimating two
equations with correlated error structure.
</p>
<p><code>NA</code>-s are allowed in the data.  These are ignored if the
corresponding outcome is unobserved, otherwise observations which
contain <code>NA</code> (either in selection or outcome) are
removed.
</p>
<p>These selection models assume a known (multivariate normal)
distribution
of error terms.  Because of this, the instruments (exclusion
restrictions) are not necessary.  However, if no instruments are
supplied, the results are based solely on the assumption on
multivariate normality.  This may or may not be an appropriate
assumption for a particular problem.  Note also that standard errors
tend to be large without a strong
exclusion restriction.
</p>
<p>If argument <code>method</code> is equal to <code>"ml"</code> (the default),
the estimation is done by the maximum likelihood method,
where the Newton-Raphson algorithm is used by default.
Argument <code>maxMethod</code> (see <code><a href="#topic+tobit2fit">tobit2fit</a></code>) 
can be used to chose other algorithms for the maximisation 
of the (log) likelihood function.
</p>
<p>If argument <code>method</code> is equal to <code>"ml"</code> (the default)
and argument <code>start</code> is <code>NULL</code> (the default),
the starting values for the maximum-likelihood (ML) estimation
of a tobit-2 or tobit-5 model
are obtained by an initial two-step estimation of this model.
</p>
<p>The two-step estimation of interval-regression models with sample-selection
has not yet been implemented.
If no starting values for a maximum-likelihood (ML) estimation
of an interval-regression model with sample-selection
are specified (i.e., argument <code>start</code> is <code>NULL</code>, the default),
starting values are obtained by an initial estimation of a tobit-2 model,
where the dependent variable of the outcome equation
is set to the mid points of the boudaries of the intervals.
By default, the starting values are obtained
by a maximum-likelihood (ML) estimation of the tobit-2 model,
whereas the starting values
for the maximum-likelihood (ML) estimation of the tobit-2 model
are obtained by a 2-step estimation of the tobit-2 model.
If argument <code>start</code> is set to <code>"2step"</code>,
the starting values for the maximum-likelihood (ML) estimation
of an interval-regression model with sample-selection
are directly obtained by a 2-step estimation of the tobit-2 model
(i.e., without a subsequent ML estimation of the tobit-2 model).
</p>
<p>Methods that can be applied to objects returned by <code>selection()</code>
are described on the help page <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>


<h3>Value</h3>

<p>'selection' returns an object of class &quot;selection&quot;.
If the model estimated by Maximum Likelihood (argument method = &quot;ml&quot;),
this object is a list, which has all the components of a 'maxLik' object, and in
addition the elements 'twoStep', 'start, 'param', 'termS', 'termO',
'outcomeVar', and if requested 'ys', 'xs', 'yo', 'xo', 'mfs', and 'mfo'.
If a tobit-2 (sample selection) model is estimated by the
two-step method (argument method = &quot;2step&quot;),
the returned object is a list with components
'probit', 'coefficients', 'param', 'vcov', 'lm', 'sigma', 'rho',
'invMillsRatio', and 'imrDelta'.
If a tobit-5 (switching regression) model is estimated by the
two-step method (argument method = &quot;2step&quot;),
the returned object is a list with components
'coefficients', 'vcov', 'probit', 'lm1', 'lm2', 'rho1', 'rho2',
'sigma1', 'sigma2', 'termsS', 'termsO', 'param',
and if requested 'ys', 'xs', 'yo', 'xo', 'mfs', and 'mfo'.
</p>
<table>
<tr><td><code>probit</code></td>
<td>
<p>object of class 'probit' that contains the results of the
1st step (probit estimation) (only for two-step estimations).</p>
</td></tr>
<tr><td><code>twoStep</code></td>
<td>
<p>(only if initial values not given)
results of the 2-step estimation, used for initial values</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>initial values for ML estimation</p>
</td></tr>
<tr><td><code>termsS</code>, <code>termsO</code></td>
<td>
<p>terms for the selection and outcome equation</p>
</td></tr>
<tr><td><code>ys</code>, <code>xs</code>, <code>yo</code>, <code>xo</code>, <code>mfs</code>, <code>mfo</code></td>
<td>
<p>response, matrix and frame of the
selection- and outcome equations (as a list of two for the latter).
NULL, if not requested.  The
response is represented internally as 0/1 integer vector with 0
denoting either the unobservable outcome (tobit 2) or the first
selection (tobit 5).</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>estimated coefficients, the complete model.
coefficient for the Inverse Mills ratio is treated as a parameter
(<code class="reqn">=\varrho \sigma</code>).</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>variance covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>a list with following components: <code>index</code>, a list of
numeric vectors: where in the <code>coef</code> the component are
located;
<code>oIntercept</code>, a logical: whether the outcome equation includes
intercept;
<code>N0, N1</code>, integer, number of observations with unobserved and
observed outcomes;
<code>nObs</code>, integer, number of valid observations;
<code>nParam</code>, integer, number of the parameters in the model (not
all are independent);
<code>df</code>, integer, degrees of freedom.  Note this is not equal to
<code>nObs - nParam</code> because of the parameters are not independent
in all the cases;
<code>levels</code> levels for the response of the selection equation.
<code>levels[1]</code> corresponds to the outcome 1, <code>levels[2]</code> to
the outcome 2.
</p>
</td></tr>
<tr><td><code>lm</code>, <code>lm1</code>, <code>lm2</code></td>
<td>
<p>objects of class 'lm' that contain the results
of the 2nd step estimation(s) of the outcome equation(s).
Note: the standard errors of this
estimation are biased, because they do not account for the
estimation of <code class="reqn">\gamma</code> in the 1st step estimation
(the correct standard errors are returned by <code>summary</code> and they
are contained in <code>vcov</code> component).</p>
</td></tr>
<tr><td><code>sigma</code>, <code>sigma1</code>, <code>sigma2</code></td>
<td>
<p>the standard error(s)
of the error terms of the outcome equation(s).</p>
</td></tr>
<tr><td><code>rho</code>, <code>rho1</code>, <code>rho2</code></td>
<td>
<p>the estimated correlation coefficient(s)
between the error term of the selection equation
and the outcome equation(s).</p>
</td></tr>
<tr><td><code>invMillsRatio</code></td>
<td>
<p>the inverse Mills Ratios calculated from the results of
the 1st step probit estimation.</p>
</td></tr>
<tr><td><code>imrDelta</code></td>
<td>
<p>the <code class="reqn">\delta</code>s calculated from the inverse Mills Ratios and
the results of the 1st step probit estimation.</p>
</td></tr>
<tr><td><code>outcomeVar</code></td>
<td>
<p>character string indicating whether the dependent variable
of the outcome equation is <code>"continuous"</code> or <code>"binary"</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The 2-step estimate of 'rho' may be outside of the
<code class="reqn">[-1,1]</code> interval.  In that case the standard errors of
invMillsRatio may be meaningless.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen,
Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a></p>


<h3>References</h3>

<p>Cameron, A. C. and Trivedi, P. K. (2005)
<em>Microeconometrics: Methods and Applications</em>,
Cambridge University Press.
</p>
<p>Greene, W. H. (2003)
<em>Econometric Analysis, Fifth Edition</em>, Prentice Hall.
</p>
<p>Heckman, J. (1976)
The common structure of statistical models of
truncation, sample selection and limited dependent
variables and a simple estimator for such models,
<em>Annals of Economic and Social Measurement</em>,
5(4), p. 475-492.
</p>
<p>Johnston, J. and J. DiNardo (1997)
<em>Econometric Methods, Fourth Edition</em>, McGraw-Hill.
</p>
<p>Lee, L., G. Maddala and R. Trost (1980)
Asymetric covariance matrices of two-stage probit and two-stage tobit
methods for simultaneous equations models with selectivity.
<em>Econometrica</em>, 48, p. 491-503.
</p>
<p>Petersen, S., G. Henningsen and A. Henningsen (2017)
<em>Which Households Invest in Energy-Saving Home Improvements?
Evidence From a Danish Policy Intervention</em>.
Unpublished Manuscript.
Department of Management Engineering, Technical University of Denmark.
</p>
<p>Toomet, O. and A. Henningsen, (2008)
Sample Selection Models in R: Package sampleSelection.
<em>Journal of Statistical Software</em> 27(7),
<a href="https://www.jstatsoft.org/v27/i07/">https://www.jstatsoft.org/v27/i07/</a>
</p>
<p>Wooldridge, J. M. (2003)
<em>Introductory Econometrics: A Modern Approach, 2e</em>, Thomson South-Western.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.selection">summary.selection</a></code>, <code><a href="#topic+selection-methods">selection-methods</a></code>,
<code><a href="#topic+probit">probit</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>,
and <code><a href="#topic+Mroz87">Mroz87</a></code> and <code><a href="#topic+RandHIE">RandHIE</a></code>
for further examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Greene( 2003 ): example 22.8, page 786
data( Mroz87 )
Mroz87$kids  &lt;- ( Mroz87$kids5 + Mroz87$kids618 &gt; 0 )
# Two-step estimation
summary( heckit( lfp ~ age + I( age^2 ) + faminc + kids + educ,
   wage ~ exper + I( exper^2 ) + educ + city, Mroz87 ) )
# ML estimation
summary( selection( lfp ~ age + I( age^2 ) + faminc + kids + educ,
   wage ~ exper + I( exper^2 ) + educ + city, Mroz87 ) )

## Example using binary outcome for selection model.
## We estimate the probability of womens' education on their
## chances to get high wage (&gt; $5/hr in 1975 USD), using PSID data
## We use education as explanatory variable
## and add age, kids, and non-work income as exclusion restrictions.
data(Mroz87)
m &lt;- selection(lfp ~ educ + age + kids5 + kids618 + nwifeinc,
   wage &gt;= 5 ~ educ, data = Mroz87 )
summary(m)


## example using random numbers
library( "mvtnorm" )
nObs &lt;- 1000
sigma &lt;- matrix( c( 1, -0.7, -0.7, 1 ), ncol = 2 )
errorTerms &lt;- rmvnorm( nObs, c( 0, 0 ), sigma )
myData &lt;- data.frame( no = c( 1:nObs ), x1 = rnorm( nObs ), x2 = rnorm( nObs ),
   u1 = errorTerms[ , 1 ], u2 =  errorTerms[ , 2 ] )
myData$y &lt;- 2 + myData$x1 + myData$u1
myData$s &lt;- ( 2 * myData$x1 + myData$x2 + myData$u2 - 0.2 ) &gt; 0
myData$y[ !myData$s ] &lt;- NA
myOls &lt;- lm( y ~ x1, data = myData)
summary( myOls )
myHeckit &lt;- heckit( s ~ x1 + x2, y ~ x1, myData, print.level = 1 )
summary( myHeckit )

## example using random numbers with IV/2SLS estimation
library( "mvtnorm" )
nObs &lt;- 1000
sigma &lt;- matrix( c( 1, 0.5, 0.1, 0.5, 1, -0.3, 0.1, -0.3, 1 ), ncol = 3 )
errorTerms &lt;- rmvnorm( nObs, c( 0, 0, 0 ), sigma )
myData &lt;- data.frame( no = c( 1:nObs ), x1 = rnorm( nObs ), x2 = rnorm( nObs ),
   u1 = errorTerms[ , 1 ], u2 = errorTerms[ , 2 ], u3 = errorTerms[ , 3 ] )
myData$w &lt;- 1 + myData$x1 + myData$u1
myData$y &lt;- 2 + myData$w + myData$u2
myData$s &lt;- ( 2 * myData$x1 + myData$x2 + myData$u3 - 0.2 ) &gt; 0
myData$y[ !myData$s ] &lt;- NA
myHeckit &lt;- heckit( s ~ x1 + x2, y ~ w, data = myData )
summary( myHeckit )  # biased!
myHeckitIv &lt;- heckit( s ~ x1 + x2, y ~ w, data = myData, inst = ~ x1 )
summary( myHeckitIv ) # unbiased

## tobit-5 example
N &lt;- 500
   library(mvtnorm)
   vc &lt;- diag(3)
   vc[lower.tri(vc)] &lt;- c(0.9, 0.5, 0.6)
   vc[upper.tri(vc)] &lt;- vc[lower.tri(vc)]
   eps &lt;- rmvnorm(N, rep(0, 3), vc)
   xs &lt;- runif(N)
   ys &lt;- xs + eps[,1] &gt; 0
   xo1 &lt;- runif(N)
   yo1 &lt;- xo1 + eps[,2]
   xo2 &lt;- runif(N)
   yo2 &lt;- xo2 + eps[,3]
   a &lt;- selection(ys~xs, list(yo1 ~ xo1, yo2 ~ xo2))
   summary(a)

## tobit2 example
   vc &lt;- diag(2)
   vc[2,1] &lt;- vc[1,2] &lt;- -0.7
   eps &lt;- rmvnorm(N, rep(0, 2), vc)
   xs &lt;- runif(N)
   ys &lt;- xs + eps[,1] &gt; 0
   xo &lt;- runif(N)
   yo &lt;- (xo + eps[,2])*(ys &gt; 0)
   a &lt;- selection(ys~xs, yo ~xo)
   summary(a)

## Example for treatment regressions
## Estimate the effect of treatment on income
## selection outcome: treatment participation, logical (treatment)
## selection explanatory variables: age, education (years)
##   unemployment in 1974, 1975, race
## outcome: log real income 1978
## outcome explanatory variables: treatment, age, education, race.
## unemployment variables are treated as exclusion restriction
data(Treatment, package="Ecdat")
a &lt;- treatReg(treat~poly(age,2) + educ + u74 + u75 + ethn,
              log(re78)~treat + poly(age,2) + educ + ethn,
              data=Treatment)
print(summary(a))
</code></pre>

<hr>
<h2 id='selection-methods'>selection-methods</h2><span id='topic+selection-methods'></span><span id='topic+logLik.selection'></span><span id='topic+nobs.selection'></span><span id='topic+nObs.selection'></span><span id='topic+print.selection'></span>

<h3>Description</h3>

<p>Methods for selection models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
logLik(object, ... )

## S3 method for class 'selection'
nobs(object, ... )
             
## S3 method for class 'selection'
nObs(x, ... )
             
## S3 method for class 'selection'
print( x, digits = max(3, getOption("digits") - 3), ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selection-methods_+3A_object">object</code>, <code id="selection-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>selection</code>.</p>
</td></tr>
<tr><td><code id="selection-methods_+3A_digits">digits</code></td>
<td>
<p>the minimum number of significant digits of the coefficients
to be printed.</p>
</td></tr>
<tr><td><code id="selection-methods_+3A_...">...</code></td>
<td>
<p>further arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>logLik</code> method returns the log likelihood value of the model.
The <code>nobs</code> and <code>nObs</code> methods return the number of observations.
The <code>print</code> method prints the call and the estimated coefficients.
</p>
<p>Furthermore, some standard methods can be applied to selection models:
The <code><a href="lmtest.html#topic+lrtest">lrtest</a></code> method can be used to perform
likelihood-ratio tests.
The <code><a href="miscTools.html#topic+stdEr">stdEr</a></code> method returns the vector
of the standard errors of the estimated parameters.
</p>
<p>The methods <code><a href="#topic+coef.selection">coef.selection</a></code>,
<code><a href="#topic+fitted.selection">fitted.selection</a></code>
<code><a href="#topic+model.frame.selection">model.frame.selection</a></code>,
<code><a href="#topic+model.matrix.selection">model.matrix.selection</a></code>,
<code><a href="#topic+residuals.selection">residuals.selection</a></code>,
<code><a href="#topic+summary.selection">summary.selection</a></code>,
and <code><a href="#topic+vcov.selection">vcov.selection</a></code>
are described at seperate help pages.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selection">selection</a></code>, <code><a href="#topic+summary.selection">summary.selection</a></code>,
and <code><a href="#topic+probit-methods">probit-methods</a></code>.</p>

<hr>
<h2 id='Smoke'>Survey Responses on Smoking Behaviour</h2><span id='topic+Smoke'></span>

<h3>Description</h3>

<p>'Instructional dataset, N=807, cross-sectional individual data on smoking 
accompanying Introductory Econometrics: A Modern Approach, 
Jeffrey M. Wooldridge, South-Western College Publishing, (c) 2000 and Jeffrey 
M. Wooldridge, Econometric Analysis of Cross Section and Panel Data, MIT Press,
(c) 2001.'
(<a href="https://ideas.repec.org/p/boc/bocins/smoke.html#biblio">https://ideas.repec.org/p/boc/bocins/smoke.html#biblio</a>, accessed 
February 27, 2017).
This dataset is a subset of data used in Mullahy (1997).
Data was collected in 1979 and 1980 through the Smoking Supplement to the
US National Health Interview Survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Smoke)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>educ</dt><dd><p>Years of schooling.</p>
</dd>
<dt>age</dt><dd><p>Respondents age in years.</p>
</dd>
<dt>cigpric</dt><dd><p>State cigarette price, cents per pack.</p>
</dd>
<dt>income</dt><dd><p>Annual income in USD.</p>
</dd>
<dt>restaurn</dt><dd><p>Dummy variable indicating if state restaurant smoking 
restrictions are in place.</p>
</dd>
<dt>smoker</dt><dd><p>Dummy variable indicating if person has smoked at least
one cigarette.</p>
</dd>
<dt>cigs_intervals</dt><dd><p>Number of cigarettes smoked per day, coded in 
intervals with intervals boundaries: (0,5,10,20,50)</p>
</dd>
<dt>cigs</dt><dd><p>Number of cigarettes smoked per day.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wooldridge(2009)'s dataset also available in other formats at
<a href="https://ideas.repec.org/p/boc/bocins/smoke.html#biblio">https://ideas.repec.org/p/boc/bocins/smoke.html#biblio</a>.
</p>
<p>Original data used in
Mullahy (1985) and Mullahy (1997).
</p>


<h3>References</h3>

<p>Jeffrey, M. Wooldridge (2009), <em>Introductory Econometrics: A modern 
approach</em>, Canada: South-Western Cengage Learning.
</p>
<p>Mullahy, John (1997), <em>Instrumental-Variable Estimation of Count Data Models:  
Applications to Models of Cigarette Smoking Behavior</em>, Review of Economics 
and Statistics 79, 596-593.
</p>
<p>Mullahy, John (1985) <em>Cigarette Smoking: Habits, Health Concerns, and 
Heterogeneous Unobservables in a Microeconometric Analysis of Consumer 
Demand</em>, Ph.D. dissertation, University of Virginia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data( Smoke )
# boundaries of the intervals
bounds &lt;- c(0,5,10,20,50,Inf)
## Not run: 
# estimation with starting values obtained by a ML estimation 
# of a standard tobit-2 model with the dependent variable 
# of the outcome equation equal to the mid-points of the intervals
res &lt;- selection( smoker ~ educ + age, cigs_intervals ~ educ, 
  data = Smoke, boundaries = bounds )
summary( res )

# estimation with starting values obtained by a two-step estimation 
# of a standard tobit-2 model with the dependent variable 
# of the outcome equation equal to the mid-points of the intervals
res2 &lt;- selection( smoker ~ educ + age, cigs_intervals ~ educ, 
  data = Smoke, boundaries = bounds, start = "2step" )
summary( res2 )

## End(Not run)

# estimation with starting values that are very close to the estimates
# (in order to reduce the execution time of running this example) 
resS &lt;- selection( smoker ~ educ + age, cigs_intervals ~ educ, 
  data = Smoke, boundaries = bounds, 
  start = c( 0.527, -0.0482, -0.0057, 4.23, -0.319, 2.97, 2.245 ) )
summary( resS )
</code></pre>

<hr>
<h2 id='summary.probit'>Summarizing Probit Estimations</h2><span id='topic+summary.probit'></span><span id='topic+print.summary.probit'></span>

<h3>Description</h3>

<p>Print or return a summary of a probit estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'probit'
summary( object, ... )
   ## S3 method for class 'summary.probit'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.probit_+3A_object">object</code></td>
<td>
<p>an object of class <code>probit</code>.</p>
</td></tr>
<tr><td><code id="summary.probit_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.probit</code>.</p>
</td></tr>
<tr><td><code id="summary.probit_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> method returns an object of class <code>summary.probit</code>;
the <code>print</code> method prints summary results and returns
the argument invisibly.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+probit">probit</a></code> and <code><a href="#topic+probit-methods">probit-methods</a></code>.</p>

<hr>
<h2 id='summary.selection'>Summarizing Selection Estimations</h2><span id='topic+summary.selection'></span><span id='topic+print.summary.selection'></span>

<h3>Description</h3>

<p>Print or return a summary of a selection estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'selection'
summary(object, ...)
   ## S3 method for class 'summary.selection'
print(x,
      digits = max(3, getOption("digits") - 3),
      part = "full", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.selection_+3A_object">object</code></td>
<td>
<p>an object of class '<code>selection</code>'.</p>
</td></tr>
<tr><td><code id="summary.selection_+3A_x">x</code></td>
<td>
<p>an object of class '<code>summary.selection</code>'.</p>
</td></tr>
<tr><td><code id="summary.selection_+3A_part">part</code></td>
<td>
<p>character string: which parts of the summary to print:
&quot;full&quot; for all the estimated parameters
(probit selection, outcome estimates, correlation and residual variance),
or &quot;outcome&quot; for the outcome results only.</p>
</td></tr>
<tr><td><code id="summary.selection_+3A_digits">digits</code></td>
<td>
<p>numeric, (suggested) number of significant digits.</p>
</td></tr>
<tr><td><code id="summary.selection_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix of the two-step estimator is currently
implemented only for tobit-2 (sample selection) models,
but not for the tobit-5 (switching regression) model.
</p>


<h3>Value</h3>

<p>Summary methods return an object of class <code>summary.selection</code>.
Print methods return the argument invisibly.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen, Ott
Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+selection">selection</a></code>,
and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Wooldridge( 2003 ): example 17.5, page 590
data( Mroz87 )
wooldridge &lt;- selection( lfp ~ nwifeinc + educ + exper + I( exper^2 ) +
   age + kids5 + kids618, log( wage ) ~ educ + exper + I( exper^2 ),
   data = Mroz87, method = "2step" )

# summary of the 1st step probit estimation (Example 17.1, p. 562f)
# and the 2nd step OLS regression (example 17.5, page 590)
summary( wooldridge )

# summary of the outcome equation only
print(summary(wooldridge), part="outcome")
</code></pre>

<hr>
<h2 id='tobit2fit'>Fitting Parametric Sample Selection Models</h2><span id='topic+tobit2fit'></span><span id='topic+tobit2Bfit'></span><span id='topic+tobit5fit'></span>

<h3>Description</h3>

<p>These functions do the actual fitting of tobit-2
(sample selection) and tobit-5 (switching regression)
models by Maximum Likelihood (ML) estimation.
The arguments must be given as numeric vectors/matrices,
initial value of parameters must be specified.
These functions are called by <code><a href="#topic+selection">selection</a></code> and
are intended for <code>sampleSelection</code> internal use.
The function <code>tobit2Bfit</code> does the actual fitting of tobit-2
(sample selection) models with a binary dependent variable
of the outcome model (<code>YO</code>) using a double-probit specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tobit2fit( YS, XS, YO, XO, start, weights = NULL, print.level = 0,
   maxMethod = "Newton-Raphson", ... )

tobit2Bfit( YS, XS, YO, XO, start, weights = NULL, print.level = 0,
   maxMethod = "BHHH", ... )

tobit5fit( YS, XS, YO1, XO1, YO2, XO2, start, print.level = 0,
   maxMethod = "Newton-Raphson", ... ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tobit2fit_+3A_ys">YS</code></td>
<td>
<p>numeric 0/1 vector, where 0 denotes unobserved outcome
(tobit 2) or outcome 1 observed (tobit 5).</p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_xs">XS</code>, <code id="tobit2fit_+3A_xo">XO</code>, <code id="tobit2fit_+3A_xo1">XO1</code>, <code id="tobit2fit_+3A_xo2">XO2</code></td>
<td>
<p>numeric matrix, model matrix for selection and
outcome equations.</p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_yo">YO</code></td>
<td>
<p>numeric vector, observed outcomes.  Values for unobserved
outcomes are ignored (they may or may not be NA).</p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_start">start</code></td>
<td>
<p>numeric vector of initial values.  The order is: betaS,
betaO(1), sigma(1), rho(1), betaO2, sigma2, rho2.</p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; 
to be used in the fitting process. Should be NULL or a numeric vector.
Weights are currently only supported in type-2 models.</p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_print.level">print.level</code></td>
<td>
<p>numeric, values greater than 0 will produce
increasingly more debugging information.</p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_maxmethod">maxMethod</code></td>
<td>
<p>character, a maximisation method supported by <code><a href="maxLik.html#topic+maxLik">maxLik</a></code></p>
</td></tr>
<tr><td><code id="tobit2fit_+3A_...">...</code></td>
<td>
<p>Additional parameters to <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"selection"</code>.  It inherits from class <code>"maxLik"</code> and
includes two additional components: <code>$tobitType</code>, numeric
tobit model classifier (see Amemiya, 1985), and <code>$method</code>, either <code>"ml"</code>
or <code>"2step"</code>, specifying the estimation method.
</p>


<h3>Author(s)</h3>

<p>Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a>, Arne Henningsen</p>


<h3>References</h3>

<p>Amemiya, T. (1985) <em>Advanced Econometrics</em>, Harvard
University Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selection">selection</a></code>, <code><a href="maxLik.html#topic+maxLik">maxLik</a></code></p>

<hr>
<h2 id='vcov.selection'>Extract Variance Covariance Matrix</h2><span id='topic+vcov.selection'></span>

<h3>Description</h3>

<p>This function extracts the coefficient variance-covariance matrix
from sample selection models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'selection'
vcov(object, part = "full", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.selection_+3A_object">object</code></td>
<td>
<p>object of class &quot;selection&quot;.</p>
</td></tr>
<tr><td><code id="vcov.selection_+3A_part">part</code></td>
<td>
<p>character string indicating which parts
of the variance-covariance matrix to extract:
<code>"full"</code> for all parameters (selection estimates,
outcome estimates, error variance and correlation,
including parameters that were calculated based on estimated parameters),
<code>"outcome"</code> for the outcome estimates only
(including the coefficient of the inverse Mill's ratio
in case of a two-step estimation), or
<code>"est"</code> for all estimated parameters.</p>
</td></tr>
<tr><td><code id="vcov.selection_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance-covariance matrix of a two-step estimate
is currently only partly implemented.
The unimplemented part of the matrix is filled with NAs.
</p>


<h3>Value</h3>

<p>the estimated variance covariance matrix of the coefficients.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen,
Ott Toomet <a href="mailto:otoomet@ut.ee">otoomet@ut.ee</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="#topic+selection">selection</a></code>,
<code><a href="#topic+coef.selection">coef.selection</a></code>, and <code><a href="#topic+selection-methods">selection-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate a simple female wage model taking into account the labour
## force participation
   data(Mroz87)
   a &lt;- heckit(lfp ~ huswage + kids5 + mtr + fatheduc + educ + city,
               log(wage) ~ educ + city, data=Mroz87)
## extract the full variance-covariance matrix:
vcov( a )
## now extract the variance-covariance matrix of the outcome model only:
vcov( a, part = "outcome" )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
