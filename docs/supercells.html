<!DOCTYPE html><html><head><title>Help for package supercells</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {supercells}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#supercells-package'><p>supercells: Superpixels of Spatial Data</p></a></li>
<li><a href='#supercells'><p>Creates supercells</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Superpixels of Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates superpixels based on input spatial data. 
  This package works on spatial data with one variable (e.g., continuous raster), many variables (e.g., RGB rasters), and spatial patterns (e.g., areas in categorical rasters).
  It is based on the SLIC algorithm (Achanta et al. (2012) &lt;<a href="https://doi.org/10.1109%2FTPAMI.2012.120">doi:10.1109/TPAMI.2012.120</a>&gt;), and readapts it to work with arbitrary dissimilarity measures. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, terra (&ge; 1.4-21), philentropy (&ge; 0.6.0), future.apply</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jakubnowosad.com/supercells/">https://jakubnowosad.com/supercells/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Nowosad/supercells/issues">https://github.com/Nowosad/supercells/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, covr, testthat (&ge; 3.0.0), rmarkdown, stars</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-11 14:01:06 UTC; jn</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakub Nowosad <a href="https://orcid.org/0000-0002-1057-3721"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pascal Mettes [ctb] (Author of the initial C++ implementation of the
    SLIC Superpixel algorithm for image data),
  Charles Jekel [ctb] (Author of underlying C++ code for dtw)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakub Nowosad &lt;nowosad.jakub@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-11 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='supercells-package'>supercells: Superpixels of Spatial Data</h2><span id='topic+supercells-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Creates superpixels based on input spatial data. This package works on spatial data with one variable (e.g., continuous raster), many variables (e.g., RGB rasters), and spatial patterns (e.g., areas in categorical rasters). It is based on the SLIC algorithm (Achanta et al. (2012) <a href="https://doi.org/10.1109/TPAMI.2012.120">doi:10.1109/TPAMI.2012.120</a>), and readapts it to work with arbitrary dissimilarity measures.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jakub Nowosad <a href="mailto:nowosad.jakub@gmail.com">nowosad.jakub@gmail.com</a> (<a href="https://orcid.org/0000-0002-1057-3721">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Pascal Mettes (Author of the initial C++ implementation of the SLIC Superpixel algorithm for image data) [contributor]
</p>
</li>
<li><p> Charles Jekel (Author of underlying C++ code for dtw) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jakubnowosad.com/supercells/">https://jakubnowosad.com/supercells/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Nowosad/supercells/issues">https://github.com/Nowosad/supercells/issues</a>
</p>
</li></ul>


<hr>
<h2 id='supercells'>Creates supercells</h2><span id='topic+supercells'></span>

<h3>Description</h3>

<p>Creates supercells based on single- or multi-band spatial raster data. It uses a modified version of the SLIC Superpixel algorithm by Achanta et al. (2012), allowing specification of a distance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supercells(
  x,
  k,
  compactness,
  dist_fun = "euclidean",
  avg_fun = "mean",
  clean = TRUE,
  iter = 10,
  transform = NULL,
  step,
  minarea,
  metadata = TRUE,
  chunks = FALSE,
  future = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supercells_+3A_x">x</code></td>
<td>
<p>An object of class SpatRaster (terra) or class stars (stars)</p>
</td></tr>
<tr><td><code id="supercells_+3A_k">k</code></td>
<td>
<p>The number of supercells desired by the user (the output number can be slightly different!).
You can use either <code>k</code> or <code>step</code>.
It is also possible to provide a set of points (an <code>sf</code> object) as <code>k</code> together with the <code>step</code> value to create custom cluster centers.</p>
</td></tr>
<tr><td><code id="supercells_+3A_compactness">compactness</code></td>
<td>
<p>A compactness value. Larger values cause clusters to be more compact/even (square).
A compactness value depends on the range of input cell values and selected distance measure.</p>
</td></tr>
<tr><td><code id="supercells_+3A_dist_fun">dist_fun</code></td>
<td>
<p>A distance function. Currently implemented distance functions are <code>"euclidean"</code>, <code>"jsd"</code>, <code>"dtw"</code> (dynamic time warping), name of any distance function from the <code>philentropy</code> package (see <code><a href="philentropy.html#topic+getDistMethods">philentropy::getDistMethods()</a></code>; &quot;log2&quot; is used in this case), or any user defined function accepting two vectors and returning one value. Default: <code>"euclidean"</code></p>
</td></tr>
<tr><td><code id="supercells_+3A_avg_fun">avg_fun</code></td>
<td>
<p>An averaging function - how the values of the supercells' centers are calculated?
It accepts any fitting R function (e.g., <code>base::mean()</code> or <code>stats::median()</code>) or one of internally implemented <code>"mean"</code> and <code>"median"</code>. Default: <code>"mean"</code></p>
</td></tr>
<tr><td><code id="supercells_+3A_clean">clean</code></td>
<td>
<p>Should connectivity of the supercells be enforced?</p>
</td></tr>
<tr><td><code id="supercells_+3A_iter">iter</code></td>
<td>
<p>The number of iterations performed to create the output.</p>
</td></tr>
<tr><td><code id="supercells_+3A_transform">transform</code></td>
<td>
<p>Transformation to be performed on the input. By default, no transformation is performed. Currently available transformation is &quot;to_LAB&quot;: first, the conversion from RGB to the LAB color space is applied, then the supercells algorithm is run, and afterward, a reverse transformation is performed on the obtained results. (This argument is experimental and may be removed in the future).</p>
</td></tr>
<tr><td><code id="supercells_+3A_step">step</code></td>
<td>
<p>The distance (number of cells) between initial supercells' centers. You can use either <code>k</code> or <code>step</code>.</p>
</td></tr>
<tr><td><code id="supercells_+3A_minarea">minarea</code></td>
<td>
<p>Specifies the minimal size of a supercell (in cells). Only works when <code>clean = TRUE</code>.
By default, when <code>clean = TRUE</code>, average area (A) is calculated based on the total number of cells divided by a number of supercells
Next, the minimal size of a supercell equals to A/(2^2) (A is being right shifted)</p>
</td></tr>
<tr><td><code id="supercells_+3A_metadata">metadata</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the output object will have metadata columns (&quot;supercells&quot;, &quot;x&quot;, &quot;y&quot;). If <code>FALSE</code>, the output object will not have metadata columns.</p>
</td></tr>
<tr><td><code id="supercells_+3A_chunks">chunks</code></td>
<td>
<p>Should the input (<code>x</code>) be split into chunks before deriving supercells? Either <code>FALSE</code> (default), <code>TRUE</code> (only large input objects are split), or a numeric value (representing the side length of the chunk in the number of cells).</p>
</td></tr>
<tr><td><code id="supercells_+3A_future">future</code></td>
<td>
<p>Should the future package be used for parallelization of the calculations? Default: <code>FALSE</code>. If <code>TRUE</code>, you also need to specify <code>future::plan()</code>.</p>
</td></tr>
<tr><td><code id="supercells_+3A_verbose">verbose</code></td>
<td>
<p>An integer specifying the level of text messages printed during calculations. 0 means no messages (default), 1 provides basic messages (e.g., calculation stage).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with several columns: (1) supercells - an id of each supercell, (2) y and x coordinates, (3) one or more columns with average values of given variables in each supercell
</p>


<h3>References</h3>

<p>Achanta, R., Shaji, A., Smith, K., Lucchi, A., Fua, P., &amp; Süsstrunk, S. (2012). SLIC Superpixels Compared to State-of-the-Art Superpixel Methods. IEEE Transactions on Pattern Analysis and Machine Intelligence, 34(11), 2274–2282. https://doi.org/10.1109/tpami.2012.120
</p>
<p>Nowosad, J. Motif: an open-source R tool for pattern-based spatial analysis. Landscape Ecol (2021). https://doi.org/10.1007/s10980-020-01135-0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(supercells)
# One variable

vol = terra::rast(system.file("raster/volcano.tif", package = "supercells"))
vol_slic1 = supercells(vol, k = 50, compactness = 1)
terra::plot(vol)
plot(sf::st_geometry(vol_slic1), add = TRUE, lwd = 0.2)

# RGB variables
# ortho = terra::rast(system.file("raster/ortho.tif", package = "supercells"))
# ortho_slic1 = supercells(ortho, k = 1000, compactness = 10, transform = "to_LAB")
# terra::plot(ortho)
# plot(sf::st_geometry(ortho_slic1), add = TRUE)
#
# ### RGB variables - colored output
#
# rgb_to_hex = function(x){
#   apply(t(x), 2, function(x) rgb(x[1], x[2], x[3], maxColorValue = 255))
# }
# avg_colors = rgb_to_hex(sf::st_drop_geometry(ortho_slic1[4:6]))
#
# terra::plot(ortho)
# plot(sf::st_geometry(ortho_slic1), add = TRUE, col = avg_colors)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
