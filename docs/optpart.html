<!DOCTYPE html><html><head><title>Help for package optpart</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optpart}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#archi'><p>Archipelago Analysis</p></a></li>
<li><a href='#bestfit'><p>Identify the Goodness-of-Fit of Cluster Members</p></a></li>
<li><a href='#bestopt'><p>Best Of Set Optimal Partitions From Random Starts</p></a></li>
<li><a href='#classmatch'><p>Classification Matching and Differencing</p></a></li>
<li><a href='#clique'><p>Maximal Clique Analysis</p></a></li>
<li><a href='#clique.test'><p>Clique Test</p></a></li>
<li><a href='#clustering'><p>Clustering Object</p></a></li>
<li><a href='#compare'><p>Compare Species Constancy for Specified Clusters</p></a></li>
<li><a href='#confus'><p>(Fuzzy) Confusion Matrix</p></a></li>
<li><a href='#consider'><p>Recommendations for Possible Merging of Clusters</p></a></li>
<li><a href='#disdiam'><p>Dissimilarity Diameters of a Partition</p></a></li>
<li><a href='#extract'><p>Extract A Specific Cluster Solution From A Stride</p></a></li>
<li><a href='#flexbeta'><p>Calculate a Flexible-Beta Dendrogram</p></a></li>
<li><a href='#gensilwidth'><p>Generalized Silhouette Width</p></a></li>
<li><a href='#lambda'><p>Goodman- Kruskal Lambda Index of Classification Association</p></a></li>
<li><a href='#maxsimset'><p>Maximally Similar Sets Analysis</p></a></li>
<li><a href='#mergeclust'><p>Merge Specified Clusters in a Classification</p></a></li>
<li><a href='#murdoch'><p>Indicator Species Analysis by Murdoch Preference Function</p></a></li>
<li><a href='#neighbor'><p>Neighbor Analysis of Partitions</p></a></li>
<li><a href='#optimclass'><p>Optimum Classification by Counts of Indicator Species</p></a></li>
<li><a href='#optindval'><p>Optimizing Classification by Maximizing Dufrene and Legendre's Indicator Value</p></a></li>
<li><a href='#optpart'><p>Optimal Partitioning of Dissimilarity/Distance Matrices</p></a></li>
<li><a href='#optpart.internal'><p>Internal Optpart Functions</p></a></li>
<li><a href='#optsil'><p>Clustering by Optimizing Silhouette Widths</p></a></li>
<li><a href='#opttdev'><p>Optimizing Classification by Minimizing Table Deviance</p></a></li>
<li><a href='#partana'><p>Partition Analysis</p></a></li>
<li><a href='#partition'><p>Convert Object to Partition Object</p></a></li>
<li><a href='#phi'><p>Calculating the phi Statistic on Taxon Classifications</p></a></li>
<li><a href='#refine'><p>Refining a Classification by Re-Assigning Memberships</p></a></li>
<li><a href='#reordclust'><p>Re-order Clusters in a Classification</p></a></li>
<li><a href='#shoshsite'><p>Site Data for the Shoshone National Forest, Wyoming, USA</p></a></li>
<li><a href='#shoshveg'><p>Vascular Plant Species Cover for the Shoshone National Forest, Wyoming, USA</p></a></li>
<li><a href='#silhouette.partana'><p>Produce a Silhouette Object From a Partana, Clustering, or Stride Object</p></a></li>
<li><a href='#slice'><p>Slice a Hierarchical Clustering Dendrogram with a Mouse</p></a></li>
<li><a href='#stride'><p>Stride: Producing a Sequence of Clusterings</p></a></li>
<li><a href='#tabdev'><p>Classification Validity Assessment by Table Deviance</p></a></li>
<li><a href='#testpart'><p>Identify Misclassified Plots in a Partition</p></a></li>
<li><a href='#typal'><p>Identification of Typal Samples in a Partition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.0-3</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Partitioning of Similarity Relations</td>
</tr>
<tr>
<td>Author:</td>
<td>David W. Roberts &lt;droberts@montana.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David W. Roberts &lt;droberts@montana.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>cluster, labdsv, MASS, plotrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tree</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains a set of algorithms for creating
        partitions and coverings of objects largely based on operations
        on (dis)similarity relations (or matrices). There are several
        iterative re-assignment algorithms optimizing different
        goodness-of-clustering criteria.  In addition, there are
        covering algorithms 'clique' which derives maximal cliques, and
        'maxpact' which creates a covering of maximally compact sets.
        Graphical analyses and conversion routines are also included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-17 13:31:54 UTC; dvrbts</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-19 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='archi'>Archipelago Analysis</h2><span id='topic+archi'></span>

<h3>Description</h3>

<p>Archipelago analysis finds connected clusters in a dissimilarity
matrix.  Samples in the same cluster are at most alpha dissimilar to at least
one other sample in the cluster, and are more than alpha dissimilar to all
samples in all other clusters.  The solution is equivalent to slicing a nearest
neighbor cluster analysis at alpha, but does not require (or produce) a
hierarchical structure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>archi(dist,alpha)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="archi_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>, or <code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code></p>
</td></tr>
<tr><td><code id="archi_+3A_alpha">alpha</code></td>
<td>
<p>the dissimilarity threshold to establish the relationship</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Archipelago analysis is a topological, as opposed to metric space,
cluster routine that returns connected clusters.  Every sample in a  cluster is
connected by a path with step lengths of at most alpha dissimilarity to every
other sample in the cluster, and is more than alpha dissimilar to all other
samples in all other clusters.</p>


<h3>Value</h3>

<p>produces an object of class &lsquo;clustering&rsquo;, a list with a vector
&lsquo;clustering&rsquo; of cluster memberships</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg) # produces a vegetation dataframe
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis') 
               # produces a Bray/Curtis dissimilarity matrix
arc.50 &lt;- archi(dis.bc,0.5) # clusters at 0.5 dissimilarity 
table(arc.50$clustering)
</code></pre>

<hr>
<h2 id='bestfit'>Identify the Goodness-of-Fit of Cluster Members</h2><span id='topic+bestfit'></span>

<h3>Description</h3>

<p>Sorts the members of clusters by maximum similarity
goodness-of-fit</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestfit(x,cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestfit_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;partana&rsquo; or &lsquo;silhouette&rsquo;</p>
</td></tr>
<tr><td><code id="bestfit_+3A_cluster">cluster</code></td>
<td>
<p>a specific cluster number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply finds all members of a specific cluster and lists them in order
of (1) mean similarity to their cluster (if x is an object of class &lsquo;partana&rsquo;) or
silhouette width (if x is an object of class &lsquo;silhouette&rsquo; as produced by
functions in package &lsquo;cluster&rsquo;)
</p>


<h3>Value</h3>

<p>returns a data.frame with cluster members in column &lsquo;ID&rsquo; and goodness-of-fit 
in column &lsquo;fit&rsquo;
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/">http://ecology.msu.montana.edu/labdsv/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+typal">typal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)                      # returns vegetation matrix
dis.bc &lt;- dsvdis(shoshveg,'bray')   # Bray/Curtis dissimilarity matrix 
opt.5 &lt;- optpart(5,dis.bc)          # 5 cluster partition
print(class(opt.5))
fit &lt;- bestfit(opt.5,1)             # goodness-of-fit for cluster 1
sil.5 &lt;- silhouette(opt.5,dis.bc)   # calculate silhouette widths
fit2 &lt;- bestfit(sil.5,1)            # goodness-of-fit for cluster 1
</code></pre>

<hr>
<h2 id='bestopt'>Best Of Set Optimal Partitions From Random Starts</h2><span id='topic+bestopt'></span>

<h3>Description</h3>

<p>Produces a specified number of <code><a href="#topic+optpart">optpart</a></code>
solutions from random starts, keeping the best result of the set</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestopt(dist,numclu,numrep,maxitr=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestopt_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>, or <code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code>,
or a symmetric dissimilarity matrix</p>
</td></tr>
<tr><td><code id="bestopt_+3A_numclu">numclu</code></td>
<td>
<p>the number of clusters desired</p>
</td></tr>
<tr><td><code id="bestopt_+3A_numrep">numrep</code></td>
<td>
<p>the number of random starts requested</p>
</td></tr>
<tr><td><code id="bestopt_+3A_maxitr">maxitr</code></td>
<td>
<p>the maximum number of iterations per replicate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calls function <code>optpart</code> with an random initial
assignment of items to clusters &lsquo;numitr&rsquo; times, keeping the best result
(highest within/among ratio observed).  See <code><a href="#topic+optpart">optpart</a></code> for more details.
</p>


<h3>Value</h3>

<p>an object of class partana, with components:
</p>
<table>
<tr><td><code>ptc</code></td>
<td>
<p>the mean similarity of each item to each cluster</p>
</td></tr>
<tr><td><code>ctc</code></td>
<td>
<p>the mean similarity of each cluster to other clusters</p>
</td></tr>
<tr><td><code>musubx</code></td>
<td>
<p>the membership of each item in each cluster</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>the best &lsquo;crisp&rsquo; partition from musubx</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>the within-cluster/among-cluster similarity ratio achieved at each iteration
of the selected result.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a simple wrapper function to automate independent random 
starts of function <a href="#topic+optpart">optpart</a>.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optpart">optpart</a></code>,
<code><a href="#topic+partana">partana</a></code>,
<code><a href="cluster.html#topic+pam">pam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
x &lt;- bestopt(dis.bc,5,10)
summary(x)
## Not run: plot(x) 
</code></pre>

<hr>
<h2 id='classmatch'>Classification Matching and Differencing</h2><span id='topic+classmatch'></span>

<h3>Description</h3>

<p>Compares two classifications by cross-tabulating the assignment
of objects to classes, and (optionally) produces a new classification to
reflect the congruences and differences</p>


<h3>Usage</h3>

<pre><code class='language-R'>classmatch(x,y,type='full')</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classmatch_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;clustering&rsquo;, &lsquo;partana&rsquo;,
&lsquo;partition&rsquo; or a vector identifying membership
of objects in classes</p>
</td></tr>
<tr><td><code id="classmatch_+3A_y">y</code></td>
<td>
<p>an object of class &lsquo;clustering&rsquo;, &lsquo;partana&rsquo;,
&lsquo;partition&rsquo; or a vector identifying membership
of objects in classes</p>
</td></tr>
<tr><td><code id="classmatch_+3A_type">type</code></td>
<td>
<p>a switch, either &lsquo;full&rsquo; or &lsquo;direct&rsquo;,
to control the parameters of the algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>classmatch first calculates a cross-tabulation of the two classifications.
Then, if &lsquo;type==&quot;full&quot;&rsquo;, the default, it finds all cases of agreement in order of number
of objects.  Objects are assigned to new clusters to reflect that order.
It's important to note that a single class may be partitioned into
several new classes, and the the number of new classes produced may be higher than
either of the classifications considered.
</p>
<p>If &lsquo;type==&quot;direct&quot;&rsquo; classmatch assumes a one-to-one relation between the
two classifications compared.  Classmatch finds the largest case of agreement,
and assigns that match to class 1.  It then zeros out the rows and columns
corresponding to those classes, and iterates.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>tab</code></td>
<td>
<p>the cross-tabulation analyzed</p>
</td></tr>
<tr><td><code>pairs</code></td>
<td>
<p>the x and y values considered matched in order of solution</p>
</td></tr>
<tr><td><code>partial</code></td>
<td>
<p>a cumulative fraction of agreement as a function of number of clusters</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>a table showing the order of new clusters</p>
</td></tr>
<tr><td><code>combo</code></td>
<td>
<p>a new vector of assignment of objects to clusters, only produced if
&lsquo;type==&quot;full&quot;&rsquo;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+partition">partition</a></code>, <code><a href="#topic+optpart">optpart</a></code>,
<code><a href="#topic+slice">slice</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
opt.5 &lt;- optpart(5,dis.bc)
pam.5 &lt;- pam(dis.bc,5)
classmatch(opt.5,pam.5)
</code></pre>

<hr>
<h2 id='clique'>Maximal Clique Analysis</h2><span id='topic+clique'></span><span id='topic+plot.clique'></span><span id='topic+summary.clique'></span>

<h3>Description</h3>

<p>Maximal clique analysis produces the set of maximal cliques of a
dissimilarity or distance matrix.  Maximal cliques are sets where every member
of the set is &lt;= alpha-dissimilar to every other member.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clique(dist,alphac,minsize=1,mult=100)
## S3 method for class 'clique'
summary(object, ...)
## S3 method for class 'clique'
plot(x, panel = 'all', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clique_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>, or <code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code></p>
</td></tr>
<tr><td><code id="clique_+3A_alphac">alphac</code></td>
<td>
<p>the dissimilarity threshold to establish the relationship</p>
</td></tr>
<tr><td><code id="clique_+3A_minsize">minsize</code></td>
<td>
<p>the minimum size clique to list in the results</p>
</td></tr>
<tr><td><code id="clique_+3A_mult">mult</code></td>
<td>
<p>scratch space multiplier to control stack size (see below)</p>
</td></tr>
<tr><td><code id="clique_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;clique&rsquo;</p>
</td></tr>
<tr><td><code id="clique_+3A_...">...</code></td>
<td>
<p>ancillary arguments to <code>summary</code> or <code>plot</code></p>
</td></tr>
<tr><td><code id="clique_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;clique&rsquo;</p>
</td></tr>
<tr><td><code id="clique_+3A_panel">panel</code></td>
<td>
<p>an integer switch to indicate which panel to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximal clique analysis produces a covering, as opposed to a partition,
i.e. objects can belong to more than one clique, and every object belongs to at
least one clique.  The maximal clique solution is solved for by symbolic
computation, as opposed to numerical computation, and produces a unique
solution.  The number of cliques produced cannot be known beforehand,
and can significantly exceed the number of objects.  The &lsquo;mult&rsquo; argument controls the
size of the stack to hold intermediate terms in the equation as the solution
proceeds.  At each iteration, the algorithm simplifies the equation to the
extent possible, and recovers space used to hold terms that have been
eliminated.  Nonetheless, it is possible for the equation to grow quite large at
intermediate steps.  The initial value of &lsquo;mult=100&rsquo; sets the stack to
100 times the number of objects in the dissimilarity/distance matrix.  If the
memory allocated is exceeded, the output is set to NULL, and a message is printed
to increase the &lsquo;mult&rsquo; argument to a higher value.
</p>


<h3>Value</h3>

<p>produces a list with elements:
</p>
<table>
<tr><td><code>alphac</code></td>
<td>
<p>the threshold value used to establish the cliques</p>
</td></tr>
<tr><td><code>musubx</code></td>
<td>
<p>a matrix of object membership in each of the maximal cliques</p>
</td></tr>
<tr><td><code>member</code></td>
<td>
<p>a list of members of each clique</p>
</td></tr>
</table>


<h3>Note</h3>

<p>WARNING.  The run time of maximal clique analysis is approximately <code class="reqn">2^n+n</code>
for <code class="reqn">n</code> objects.  The number of cliques generated, and the run time, is sensitive
to &lsquo;alpha&rsquo;, as values of &lsquo;alpha&rsquo; close to the mean dissimilarity
of the matrix are likely to produce the most cliques and longest run time.  A
solution for 1200 objects once took approximately 20 CPU days on a SparcStation.
The example shown below (100 objects) runs in a few seconds on a modern computer.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg) # produces a vegetation dataframe
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis') 
    # produces a Bray/Curtis dissimilarity matrix
cli.50 &lt;- clique(dis.bc,0.5) # clusters at 0.5 dissimilarity, likely
    # to run for a few seconds in most PCs
summary(cli.50)
</code></pre>

<hr>
<h2 id='clique.test'>Clique Test</h2><span id='topic+clique.test'></span>

<h3>Description</h3>

<p>The &lsquo;clique.test&rsquo; function analyzes within-clique
variability in attributes of objects other than those used to calculate the
similarity relation.  If the cliques exhibit a narrower range of values than
expected at random it may be that the variable analyzed has an underlying role
in determining the attributes on which the similarity is calculated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>clique.test(cliq,env,minsize=2,plotit=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clique.test_+3A_cliq">cliq</code></td>
<td>
<p>an object of class &lsquo;clique&rsquo;</p>
</td></tr>
<tr><td><code id="clique.test_+3A_env">env</code></td>
<td>
<p>a continuous environmental variable to test</p>
</td></tr>
<tr><td><code id="clique.test_+3A_minsize">minsize</code></td>
<td>
<p>the minimum size clique to test for range</p>
</td></tr>
<tr><td><code id="clique.test_+3A_plotit">plotit</code></td>
<td>
<p>a switch to control plotting each clique individually</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a vector of probabilities, one for each clique that expresses the
probability of obtaining a range of &lsquo;env&rsquo; as small as observed.  Also
produces a plot of the sorted probabilities on the current device.</p>


<h3>Note</h3>

<p>The &lsquo;clique.test&rsquo; function actually calls the
<code><a href="labdsv.html#topic+envrtest">envrtest</a></code> function once for each clique and stores the
associated probability as determined by <code><a href="labdsv.html#topic+envrtest">envrtest</a></code> </p>


<h3>Author(s)</h3>

<p>David W. Roberts <a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clique">clique</a></code>, <code><a href="#topic+mss.test">mss.test</a></code>,
<code><a href="labdsv.html#topic+envrtest">envrtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
data(shoshsite)
dis.bc &lt;- dsvdis(shoshveg,'bray')
## Not run: cli.60 &lt;- clique(dis.bc,0.60)             # will run for several
## Not run: print(clique.test(cli.60,shoshsite$swb))  # minutes
</code></pre>

<hr>
<h2 id='clustering'>Clustering Object</h2><span id='topic+clustering'></span>

<h3>Description</h3>

<p>A clustering object is a list with a component 
called &lsquo;clustering&rsquo; which is an integer vector of length n
where n is the number of elements in a classification.
</p>


<h3>Details</h3>

<p>The clustering object is defined simply to allow a cleaner
interface to functions in package &lsquo;cluster&rsquo;.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>

<hr>
<h2 id='compare'>Compare Species Constancy for Specified Clusters</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Extracts specified columns from a constancy table
(see <code><a href="labdsv.html#topic+const">const</a></code>) and identifies species which
occur in one of the two clusters (potential diagnostic species) 
or in both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(const,left,right,thresh=0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_const">const</code></td>
<td>
<p>a constancy table produced by function <code><a href="labdsv.html#topic+const">const</a></code></p>
</td></tr>
<tr><td><code id="compare_+3A_left">left</code></td>
<td>
<p>a numeric cluster</p>
</td></tr>
<tr><td><code id="compare_+3A_right">right</code></td>
<td>
<p>a cluster number</p>
</td></tr>
<tr><td><code id="compare_+3A_thresh">thresh</code></td>
<td>
<p>a minimum differential abundance to list in the table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>compare extracts two columns (left and right) from a constancy table produced by
<code><a href="labdsv.html#topic+const">const</a></code>, and calculates the pairwise differences.  
Differences greater than the specified threshold appear in the set &lsquo;left&rsquo;; 
negative differences less then minus one times the threshold appear in the set &lsquo;right&rsquo;,
and species which occur in both columns but with an absolute value of difference less 
than the threshold appear in set &lsquo;both&rsquo;.
</p>


<h3>Value</h3>

<p>a list with elements
</p>
<table>
<tr><td><code>left</code></td>
<td>
<p>a data.frame of species diagnostic of set &lsquo;left&rsquo;</p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p>a data.frame of species diagnostic of set &lsquo;right&rsquo;</p>
</td></tr>
<tr><td><code>both</code></td>
<td>
<p>species occuring in both sets and diagnostic of neither</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)        # returns vegetation data set
data(shoshsite)       # returns site data
elev.clust &lt;- as.numeric(factor(cut(shoshsite$elevation,5)))
                      # 5 elevation bands
elev.const &lt;- const(shoshveg,elev.clust)
compare(elev.const,1,2)   # identify diagnostic species 
</code></pre>

<hr>
<h2 id='confus'>(Fuzzy) Confusion Matrix</h2><span id='topic+confus'></span><span id='topic+fuzconfus'></span>

<h3>Description</h3>

<p>A confusion matrix is a cross-tabulation of actual class
membership with memberships predicted by a discriminant function,
classification tree, or other predictive model.
A fuzzy confusion
matrix is a confusion matrix that corrects for &lsquo;near misses&rsquo;
in prediction by comparing the similarity of the predicted type to
the actual type and giving credit for the similarity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>confus(clustering,model,diss=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confus_+3A_clustering">clustering</code></td>
<td>
<p>an object of class &lsquo;clustering&rsquo; or
a vector of (integer or factor) class membership values</p>
</td></tr>
<tr><td><code id="confus_+3A_model">model</code></td>
<td>
<p>a predictive model of class &lsquo;tree&rsquo; or &lsquo;randomForest&rsquo;</p>
</td></tr>
<tr><td><code id="confus_+3A_diss">diss</code></td>
<td>
<p>optionally, a dissimilarity object of class &lsquo;dist&rsquo; from
&lsquo;dist&rsquo;, &lsquo;dsvdis&rsquo;, or &lsquo;vegdist&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cross-classifies each sample by actual class membership and
predicted membership, computing overall accuracy, and the Kappa
statistic of agreement.  If a dissimilarity matrix is passed, calculates a 
fuzzy confusion matrix.
In this case, correct predictions are assigned values of 1.0, and other predictions are given the value of the
similarity of the two types an placed on the diagonal.  The dissimilarity of the two types is added off
the diagonal as fuzzy error.
</p>


<h3>Value</h3>

<p>produces a list with elements
</p>
<table>
<tr><td><code>matrix</code></td>
<td>
<p>the (fuzzy) cross-tabulation matrix as a data.frame</p>
</td></tr>
<tr><td><code>correct</code></td>
<td>
<p>the fraction of (fuzzily) correctly predicted samples</p>
</td></tr>
<tr><td><code>kappa</code></td>
<td>
<p>the value of the Kappa statistic</p>
</td></tr>
<tr><td><code>legend</code></td>
<td>
<p>the text legend for the cross-tabulation matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Confusion matrices are commonly computed in remote sensing
applications, but are equally suited to the evaluation of any
predictive methods of class membership or factors.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg) # returns a data frame of vegetation data
data(shoshsite) # returns a data frame of site data
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.5 &lt;- optpart(5,dis.bc)
library(tree)
mod &lt;- tree(factor(opt.5$clustering)~ elevation+slope+av,
            data=shoshsite)
confus(opt.5,mod)
confus(opt.5,mod,dis.bc)
</code></pre>

<hr>
<h2 id='consider'>Recommendations for Possible Merging of Clusters</h2><span id='topic+consider'></span>

<h3>Description</h3>

<p>Presents an ordered list of possible cluster combinations
to consider for merging to simplify a classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consider(part)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consider_+3A_part">part</code></td>
<td>
<p>an object of class &lsquo;partana&rsquo; from functions
<code>partana</code>, <code>optpart</code> or <code>bestopt</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply sorts the cluster-to-cluster mean similarity matrix of a
&lsquo;partana&rsquo; object into a list sorted by mean similarity.
</p>


<h3>Value</h3>

<p>a data.frame with three elements:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p>the current cluster number</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>the cluster to which it is most similar</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>the mean similarity of the two clusters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The listed combinations are not suggested to be optimal by any specific
criterion.  In fact, if the &lsquo;partana&rsquo; object was generated by <code>optpart</code> 
or <code>bestopt</code> it is known that the suggested combinations are sub-optimal.
Nevertheless, sometimes it is desirable to simplify a classification for other reasons.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code>optpart</code>, <code>bestopt</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)                    # returns a vegetation data.frame
dis.bc &lt;- dsvdis(shoshveg,'bray') # calculates a Bray/Curtis
                                  # dissimilarity matrix
opt.5 &lt;- optpart(5,dis.bc)        # generates a 5 cluster partition
consider(opt.5)                   # recommends possible clusters to merge
</code></pre>

<hr>
<h2 id='disdiam'>Dissimilarity Diameters of a Partition</h2><span id='topic+disdiam'></span><span id='topic+disdiam.default'></span><span id='topic+disdiam.stride'></span><span id='topic+print.disdiam'></span>

<h3>Description</h3>

<p>Calculates the diameter (maximum within-cluster dissimilarity) of
all clusters in a partition, as well as the average diameter across all
clusters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>disdiam(x,dist,digits)
## S3 method for class 'stride'
disdiam(x,dist,digits=3)
## S3 method for class 'disdiam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disdiam_+3A_x">x</code></td>
<td>
<p>a vector of integers or an object of class &lsquo;clustering&rsquo;,
&lsquo;partition&rsquo;, &lsquo;partana&rsquo;, or &lsquo;stride&rsquo;</p>
</td></tr>
<tr><td><code id="disdiam_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code>, or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="disdiam_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits reported in the output</p>
</td></tr>
<tr><td><code id="disdiam_+3A_...">...</code></td>
<td>
<p>ancillary arguments to the print function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>disdiam is a cluster validation routine, and calculates the diameter 
(maximum within-cluster dissimilarity) of each cluster, as well as the average
diameter of across all clusters of size greater than one.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>diameters</code></td>
<td>
<p>a data.frame with clusters as rows, and
cluster ID, cluster size, and diameter as cols</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the weighted mean diameter of clusters of size greater than one.  The mean is
weighted for cluster size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.5 &lt;- optpart(5,dis.bc)
disdiam(opt.5,dis.bc)
</code></pre>

<hr>
<h2 id='extract'>Extract A Specific Cluster Solution From A Stride</h2><span id='topic+extract'></span><span id='topic+extract.stride'></span>

<h3>Description</h3>

<p>Extracts a specified cluster solution from an object of class
&lsquo;stride&rsquo;.  The desired solution is specified by the number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stride'
extract(stride,k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_stride">stride</code></td>
<td>
<p>an object of class &lsquo;stride&rsquo; from function
<code><a href="#topic+stride">stride</a></code></p>
</td></tr>
<tr><td><code id="extract_+3A_k">k</code></td>
<td>
<p>the number of clusters desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A stride object consists of a list with a data.frame of cluster solutions for
varying numbers of clusters.  Extract simply selects one column of this
data.frame (specified by number of clusters desired, not column number) and
returns that solution as an object of class &lsquo;clustering&rsquo;.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;clustering&rsquo;.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)		                # get vegetation data
dis.bc &lt;- dsvdis(shoshveg,'bray')   # calculate dissimilarity 
                                    #   matrix
avg.hcl &lt;- hclust(dis.bc,'average') # average linkage cluster 
                                    #   analysis
avg.2.10 &lt;- stride(2:10,avg.hcl)    # compute stride
res &lt;- extract(avg.2.10,8)          # extract 8-cluster solution
</code></pre>

<hr>
<h2 id='flexbeta'>Calculate a Flexible-Beta Dendrogram</h2><span id='topic+flexbeta'></span>

<h3>Description</h3>

<p>Calculates Lance and Williams flexible-beta dendrogram with simplified argument</p>


<h3>Usage</h3>

<pre><code class='language-R'>flexbeta(dis,beta=-0.25,alpha=(1-beta)/2,gamma=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flexbeta_+3A_dis">dis</code></td>
<td>
<p>a distance or dissimilarity object of class &lsquo;dist&rsquo;</p>
</td></tr>
<tr><td><code id="flexbeta_+3A_beta">beta</code></td>
<td>
<p>the Beta coefficient</p>
</td></tr>
<tr><td><code id="flexbeta_+3A_alpha">alpha</code></td>
<td>
<p>the Alpha coefficients (assumed equal)</p>
</td></tr>
<tr><td><code id="flexbeta_+3A_gamma">gamma</code></td>
<td>
<p>the gamma coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a flexible-beta dendrogram from a dissimilarity matrix specifying
minimum parameters.  The routine is simply a wrapper for the 
<code><a href="cluster.html#topic+agnes">agnes</a></code> function from package cluster 
with suitable arguments specified to
achieve desired results.  Ecologist in particular (but many others) find beta = -0.25 
a good default.</p>


<h3>Value</h3>

<p>An object of class &lsquo;hclust&rsquo; for plotting and analysis like other
hclust objects, as compared to objects of class &lsquo;agnes&rsquo; as generated by the 
<code><a href="cluster.html#topic+agnes">agnes</a></code> function in package cluster.</p>


<h3>Author(s)</h3>

<p>for the agnes function, Peter Rousseeuw for the original Fortran,
Martin Maechler  for the R code
</p>
<p>for this function, David W. Roberts 
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p>Lance, G.N., and W.T. Williams (1966).  A General Theory of
Classifactory Sorting Strategies, I. Hierarchical Systems.
Computer J. *9*, 373-380.</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+agnes">agnes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
flexb &lt;- flexbeta(dis.bc)
</code></pre>

<hr>
<h2 id='gensilwidth'>Generalized Silhouette Width</h2><span id='topic+gensilwidth'></span>

<h3>Description</h3>

<p>Calculates mean cluster silhouette widths using a generalized
mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gensilwidth(clust, dist, p=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gensilwidth_+3A_clust">clust</code></td>
<td>
<p>an integer vector of cluster memberships or a classification 
object of class &lsquo;clustering&rsquo;</p>
</td></tr>
<tr><td><code id="gensilwidth_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo;</p>
</td></tr>
<tr><td><code id="gensilwidth_+3A_p">p</code></td>
<td>
<p>the scaling parameter of the analysis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gensilwidth calculates mean cluster silhouette widths using a generalized
mean.  The scaling parameter can be set between <code class="reqn">[-\infty,\infty]</code> where values 
less than one emphasize connectivity, and values greater than one emphasize 
compactedness.   Individual sample unit silhouette widths are still calculated as 
<code class="reqn">s _i = (b_i - a_i) / \max(b_i,a_i)</code> where <code class="reqn">a_i</code> is the mean dissimilarity of a
sample unit to the cluster to which it is assigned, and <code class="reqn">b_i</code> is the mean 
dissimilarity to the nearest neighbor cluster.  Given <code class="reqn">s_i</code> for all members of a cluster,
the generalized mean is calculated as 
</p>
<p style="text-align: center;"><code class="reqn">\bar s = \left( {1\over n} \sum_{k=1}^n s_k^p \right)^{1/p}</code>
</p>

<p>Exceptions exist for specific values:
</p>
<p>for p=0 </p>
<p style="text-align: center;"><code class="reqn">s_i = \left( \prod_{k=1}^n s_k \right)^{1/n}</code>
</p>

<p>for p=<code class="reqn">-\infty</code> </p>
<p style="text-align: center;"><code class="reqn">s_i = \min_{k=1}^n s_k</code>
</p>

<p>for p=<code class="reqn">\infty</code> </p>
<p style="text-align: center;"><code class="reqn">s_i = \max_{k=1}^n s_k</code>
</p>

<p><code class="reqn">p=-1</code> = harmonic mean, <code class="reqn">p=0</code> = geometric mean, and <code class="reqn">p=1</code> = arithmetic mean.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;silhouette&rsquo;, a list with components
</p>
<table>
<tr><td><code>cluster</code></td>
<td>
<p>the assigned cluster for each sample unit</p>
</td></tr>
<tr><td><code>neighbor</code></td>
<td>
<p>the identity of the nearest neighbor cluster for each sample unit</p>
</td></tr>
<tr><td><code>sil_width</code></td>
<td>
<p>the silhouette width for each sample unit</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Attila Lengyel and Zoltan Botta-Dukat wrote the algorithm
</p>
<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>References</h3>

<p>Lengyel, A. and Z. Botta-Dukat.  2019.  
Silhouette width using generalized mean: A flexible method for assessing clustering efficiency.
Ecology and Evolution https://doi.org/10.1002/ece3.5774</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+silhouette">silhouette</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.5 &lt;- optpart(5,dis.bc)
gensilwidth(opt.5,dis.bc)
</code></pre>

<hr>
<h2 id='lambda'>Goodman- Kruskal Lambda Index of Classification Association</h2><span id='topic+lambda'></span>

<h3>Description</h3>

<p>Compares two classifications by calculating the Goodman-Kruskal Index
of association</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(x,y,digits=5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;clustering&rsquo;, &lsquo;partana&rsquo;,
&lsquo;partition&rsquo; or a vector identifying membership
of objects in classes with names attribute</p>
</td></tr>
<tr><td><code id="lambda_+3A_y">y</code></td>
<td>
<p>an object of class &lsquo;clustering&rsquo;, &lsquo;partana&rsquo;,
&lsquo;partition&rsquo; or a vector identifying membership
of objects in classes with names attribute</p>
</td></tr>
<tr><td><code id="lambda_+3A_digits">digits</code></td>
<td>
<p>the number of digits of the statsitic to report</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lambda calculates the Goodman-Kruskal index of association:
</p>
<p><code class="reqn">\sum_i max_j (n_{ij}) + \sum_j max_i (n_{ij}) - max(n_{i,}) - max(n{_.j})
\over
2*\sum_i\sum_j n_{ij} - max(n_{i,}) - max(n{_.j)}</code>
</p>


<h3>Value</h3>

<p>Prints a cross-tabulated table and the lambda statistic, and 
(invisibly) returns the lambda statistic</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+partition">partition</a></code>, <code><a href="#topic+optpart">optpart</a></code>,
<code><a href="#topic+slice">slice</a></code>,<code><a href="#topic+classmatch">classmatch</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
opt.5 &lt;- optpart(5,dis.bc)
pam.5 &lt;- pam(dis.bc,5)
lambda(opt.5,pam.5)
</code></pre>

<hr>
<h2 id='maxsimset'>Maximally Similar Sets Analysis</h2><span id='topic+maxsimset'></span><span id='topic+maxpact'></span><span id='topic+mss.test'></span><span id='topic+plot.mss'></span><span id='topic+getsets'></span><span id='topic+getsets.mss'></span>

<h3>Description</h3>

<p>Maximally similar sets is an approach to deriving relatively homogeneous
subsets of objects as determined by similarity of the composition of the objects.  Maximally
similar sets are a covering, as opposed to a partition, of objects.  The sets
so derived can be tested against random sets of the same size to determine whether a
vector of independent data exhibits an improbably restricted distribution within the sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxsimset(dist,size=NULL,alphac=NULL,mean=FALSE)
mss.test(mss, env, panel = 'all', main = deparse(substitute(env)), 
         ...)
## S3 method for class 'mss'
plot(x, ...)
## S3 method for class 'mss'
getsets(mss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxsimset_+3A_dist">dist</code></td>
<td>
<p>a dist object from <code>dist</code>, <code>dsvdis</code>, or <code>vegdist</code></p>
</td></tr>
<tr><td><code id="maxsimset_+3A_size">size</code></td>
<td>
<p>the size of desired sets</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_alphac">alphac</code></td>
<td>
<p>the alpha-cut to specify maximum dissimilarity for inclusion in a set</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_mean">mean</code></td>
<td>
<p>if mean is FALSE (the default), the algorithm uses a furthest neighbor
criterion; if mean is TRUE, it uses a mean similarity criterion</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_mss">mss</code></td>
<td>
<p>an object of class &lsquo;mss&rsquo;</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_env">env</code></td>
<td>
<p>a quantitative environmental variable for analysis</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_main">main</code></td>
<td>
<p>a title for the plot of mss.test</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_panel">panel</code></td>
<td>
<p>an integer switch to indicate which panel to draw</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;mss&rsquo; from maxsimset</p>
</td></tr>
<tr><td><code id="maxsimset_+3A_...">...</code></td>
<td>
<p>ancillary arguments for &lsquo;plot&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>maxsimset starts with each sample as a seed, and adds the most similar
plot to the set.  Plots are added in turn to the set (up to the size specified,
or to the maximum dissimilarity specified)
in order of maximum similarity.  If mean is FALSE, the sample most similar to
set is the sample with the max-min similarity, that is, the sample whose minimum
similarity to the set if highest, equivalent to furthest-neighbor or
complete-linkage in cluster analysis.  If mean is TRUE, the sample most similar
to a set is the sample with highest mean similarity to the set.  Once the sets
are determined for each seed, the list is examined for duplicate sets, which are
deleted, to return the list of unique sets.
</p>
<p>If &lsquo;alphac&rsquo; is specified, sets are grown to maximum size, or to maximum
dissimilarity as specified by alphac, whichever is smaller.
</p>
<p>The &lsquo;mss.test&rsquo; function analyzes within-set variability in attributes
of the objects other than those used to calculate the similarity relation.  If maximally similar 
sets exhibit a narrower range of values than expected at random it may be that the
variable analyzed has an underlying role in determining the attributes on which the similarity
is calculated.  The function &lsquo;plot&rsquo; plots the sorted within-set range of values in red,
and the sorted
range of values of random sets of the same size in black.  This followed by a boxplot of
within-set values for the random replicates versus the observed sets, and calculates a
Wilcoxon rank sum test of the difference.
</p>
<p>&lsquo;getsets&rsquo; expands and pulls out the maximally similar sets as a list of 
logical membership vectors for use in other analyses.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;mss&rsquo;, a list with elements:
</p>
<table>
<tr><td><code>musubx</code></td>
<td>
<p>a matrix of sample membership in the sets where membership is given by the
similarity with which a sample joined the set</p>
</td></tr>
<tr><td><code>member</code></td>
<td>
<p>a list of set members in the order they were added to the set</p>
</td></tr>
<tr><td><code>numset</code></td>
<td>
<p>the number of unique sets derived</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>the number of members in each set</p>
</td></tr>
<tr><td><code>distname</code></td>
<td>
<p>the name of the dissimilarity/distance object employed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
data(shoshsite)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
mss.10 &lt;- maxsimset(dis.bc,10)
## Not run: mss.test(mss.10,shoshsite$elevation) 
      # plots graph and produces summary
</code></pre>

<hr>
<h2 id='mergeclust'>Merge Specified Clusters in a Classification</h2><span id='topic+mergeclust'></span>

<h3>Description</h3>

<p>Re-assigns members of one cluster to another specified cluster,
reducing the number of clusters by one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeclust(clustering,from,to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeclust_+3A_clustering">clustering</code></td>
<td>
<p>a vector of (integer) cluster memberships, or an
object of class&lsquo;partition&rsquo;, &lsquo;partana&rsquo;, or &lsquo;clustering&rsquo;</p>
</td></tr>
<tr><td><code id="mergeclust_+3A_from">from</code></td>
<td>
<p> the cluster number to be vacated</p>
</td></tr>
<tr><td><code id="mergeclust_+3A_to">to</code></td>
<td>
<p>the cluster to which members will be re-assigned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply renumbers members of one cluster with the number of another,
but greatly simplifies managing the list objects class&lsquo;partition&rsquo;, &lsquo;partana&rsquo;, 
or &lsquo;clustering&rsquo; and simplifes the syntax.
</p>


<h3>Value</h3>

<p>A list object of class &lsquo;clustering&rsquo; specifying cluster membership for 
every object.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+partition">partition</a></code>, <code><a href="#topic+partana">partana</a></code>, and 
<code><a href="#topic+clustering">clustering</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)                   # returns a vegetation data.frame
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')   # returns a Bray/Curtis 
                                 # dissimilarity matrix
opt.5 &lt;- optpart(5,dis.bc)       # five cluster partition
opt.5a &lt;- mergeclust(opt.5,5,4)  # reassigns member from cluster 
                                 #   5 to 4
</code></pre>

<hr>
<h2 id='murdoch'>Indicator Species Analysis by Murdoch Preference Function</h2><span id='topic+murdoch'></span><span id='topic+summary.murdoch'></span><span id='topic+plot.murdoch'></span><span id='topic+print.murdoch'></span>

<h3>Description</h3>

<p>Calculates the indicator value 
of species in a single cluster or environment type using the Murdoch Preference Function</p>


<h3>Usage</h3>

<pre><code class='language-R'>murdoch(comm,type,minval=0,minplt=10)
## S3 method for class 'murdoch'
summary(object,pval=0.05,digits=3,...)
## S3 method for class 'murdoch'
plot(x,axtype=1,pval=0.05,...)
## S3 method for class 'murdoch'
print(x,digits = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="murdoch_+3A_comm">comm</code></td>
<td>
<p>a matrix or data.frame of samples with species as columns and
samples as rows</p>
</td></tr>
<tr><td><code id="murdoch_+3A_type">type</code></td>
<td>
<p>a logical vector with values of TRUE for samples in a specific cluster
or type</p>
</td></tr>
<tr><td><code id="murdoch_+3A_minval">minval</code></td>
<td>
<p>a threshold minimum abundance value to count as a presence</p>
</td></tr>
<tr><td><code id="murdoch_+3A_minplt">minplt</code></td>
<td>
<p>the minimum number of presences to include a species in the calculation</p>
</td></tr>
<tr><td><code id="murdoch_+3A_object">object</code></td>
<td>
<p>and object of class &lsquo;murdoch&rsquo;</p>
</td></tr>
<tr><td><code id="murdoch_+3A_pval">pval</code></td>
<td>
<p>the maximum probability to include a species in the summary table</p>
</td></tr>
<tr><td><code id="murdoch_+3A_digits">digits</code></td>
<td>
<p>the number of digits to report</p>
</td></tr>
<tr><td><code id="murdoch_+3A_...">...</code></td>
<td>
<p>ancillary arguments to maintain compatibility with the generic summary function</p>
</td></tr>
<tr><td><code id="murdoch_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;murdoch&rsquo;</p>
</td></tr>
<tr><td><code id="murdoch_+3A_axtype">axtype</code></td>
<td>
<p>a switch to control scaling of the x axis in the plot.  1=number of plots in the 
data set, other = number of presences in the type</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the indicator value of species for a specific type using the modified Murdoch
statistic:
</p>
<p style="text-align: center;"><code class="reqn">log((p/a) * (n-p_i)/n_i)</code>
</p>

<p>where:
<code class="reqn">p</code> = number of samples where species is present,
<code class="reqn">a</code> = number of samples where species is absent,
<code class="reqn">n</code> = total number of samples (p+a),
<code class="reqn">p_i</code> = number of samples in type i where species is present,
<code class="reqn">n_i</code> = number of samples in type i.
</p>
<p>Probabilities are based on the hypergeometric distribution calculation of 
having as many or more presences in a type as observed.</p>


<h3>Value</h3>

<p>a list object of class &lsquo;murdoch&rsquo; with components:
</p>
<table>
<tr><td><code>minplt</code></td>
<td>
<p>the minimum number of presences to be included</p>
</td></tr>
<tr><td><code>nplots</code></td>
<td>
<p>the number of plots a species occurs in</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the plot membership vector for the type</p>
</td></tr>
<tr><td><code>pres</code></td>
<td>
<p>the number of presences for species in the type</p>
</td></tr> 
<tr><td><code>abs</code></td>
<td>
<p>the number of absences of species in the type</p>
</td></tr>
<tr><td><code>murdoch</code></td>
<td>
<p>the Murdoch value for species in the type</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>the probability of getting such a high murdoch value</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Indicator value analysis is a set of techniques designed to identify
species of special interest in clusters or types.  The most widely used indicator species
analysis was proposed by Dufrene and Legendre (1997), and is included in package
&lsquo;labdsv&rsquo; as <code><a href="labdsv.html#topic+indval">indval</a></code>. murdoch differs significantly from
indval in assumption and objective, seeking to identify species that have improbable occurrences
in types, regardless of their relative frequency in the type</p>


<h3>Author(s)</h3>

<p>David W. Roberts with help from Ken Aho
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>See Also</h3>

<p><code><a href="labdsv.html#topic+indval">indval</a></code>, <code><a href="#topic+tabdev">tabdev</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)                           # returns a vegetation dataframe
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis') # returns a dissimilarity 
                                         #   matrix
opt.5 &lt;- optpart(5,dis.bc)
plot(murdoch(shoshveg,opt.5$clustering==1))
</code></pre>

<hr>
<h2 id='neighbor'>Neighbor Analysis of Partitions</h2><span id='topic+neighbor'></span>

<h3>Description</h3>

<p>Calculates the nearest neighbor (least dissimilar cluster) for each
item in partition to identify the topology of the partition.</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbor(x,all=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbor_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;pam&rsquo; or class &lsquo;partana&rsquo;</p>
</td></tr>
<tr><td><code id="neighbor_+3A_all">all</code></td>
<td>
<p>a logical switch to control which items are included in the
calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each item in a partition has membership in a cluster.  The nearest
neighbor of an item is the cluster to which the item is least dissimilar, other
than the one to which it it belongs.  If &lsquo;all&rsquo; is TRUE, then every item
is included in the analysis.  If &lsquo;all&rsquo; is FALSE, only &lsquo;misfits&rsquo;
are included in the calculation.  If the first argument is an object of class
&lsquo;pam&rsquo;, then a misfit is an item with a negative silhouette width (see
<code><a href="cluster.html#topic+silhouette">silhouette</a></code>).  If the first argument is an object of class
&lsquo;partana&rsquo;, a misfit is an item with lower mean dissimilarity to another
cluster than to the one to which it belongs.
</p>


<h3>Value</h3>

<p>A table with clusters as rows, and neighbors as columns.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.5 &lt;- optpart(5,dis.bc)
neighbor(opt.5,all=TRUE)
</code></pre>

<hr>
<h2 id='optimclass'>Optimum Classification by Counts of Indicator Species</h2><span id='topic+optimclass'></span>

<h3>Description</h3>

<p>Calculates the number of indicator species/cluster across a 
range of partitions</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimclass(comm, stride, pval = 0.01, counts = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimclass_+3A_comm">comm</code></td>
<td>
<p>a community matrix with sample units as rows and species as columns</p>
</td></tr>
<tr><td><code id="optimclass_+3A_stride">stride</code></td>
<td>
<p>an object of class &lsquo;stride&rsquo;from function 
<code><a href="#topic+stride">stride</a></code></p>
</td></tr>
<tr><td><code id="optimclass_+3A_pval">pval</code></td>
<td>
<p>the minimum probability for inclusion in the list of indicators</p>
</td></tr>
<tr><td><code id="optimclass_+3A_counts">counts</code></td>
<td>
<p>the minimum number of clusters for inclusion in the list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the number of indicator species/cluster and the number of
clusters with at least &lsquo;counts&rsquo; indicators, using the <code class="reqn">\phi</code> index to
identify indicators with probabilities less than or equal to &lsquo;pval&rsquo;.
Arguably the optimal partition is the one with the most indicator species and
the most clusters with adequate indicators.</p>


<h3>Value</h3>

<p>A data.frame of 
</p>
<table>
<tr><td><code>clusters</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code>sig.spc</code></td>
<td>
<p>the number of species with significant indicator value</p>
</td></tr>
<tr><td><code>sig.clust</code></td>
<td>
<p>the number of clusters with at least &lsquo;counts&rsquo; indicator species</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The concept and first
implementation were by Tichy in software package &lsquo;Juice&rsquo;, and this is a
simple port of the algorithm to R.</p>


<h3>Author(s)</h3>

<p>Lubomir Tichy wrote the original algorithm
</p>
<p>David W. Roberts <a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p>Tichy, L., M. Chytry, M. Hajek, S. Talbot, and Z. Botta-Dukat.  2010.
OptimClass: Using species-to-cluster fidelity to determine the
optimal partition in classification of ecological communities.  J. Veg. Sci.
21:287-299.</p>


<h3>See Also</h3>

<p><code><a href="labdsv.html#topic+indval">indval</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.2.10 &lt;- stride(2:20,dis.bc)
## Not run: optimclass(shoshveg,opt.2.10)
</code></pre>

<hr>
<h2 id='optindval'>Optimizing Classification by Maximizing Dufrene and Legendre's Indicator Value</h2><span id='topic+optindval'></span>

<h3>Description</h3>

<p>optindval is a iterative re-assignment classification algorithm
that assigns samples to clusters to maximize the sum of indicator values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>optindval(comm,clustering,maxitr=100,minsiz=5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optindval_+3A_comm">comm</code></td>
<td>
<p>a vegetation or other taxon table with samples as rows and taxa as columns</p>
</td></tr>
<tr><td><code id="optindval_+3A_clustering">clustering</code></td>
<td>
<p>an index of cluster membership for each sample. May be either
a numeric vector of length equal to the number of samples, or
an object that inherits from class &lsquo;cluster&rsquo;</p>
</td></tr>
<tr><td><code id="optindval_+3A_maxitr">maxitr</code></td>
<td>
<p>the maximum number of iterations to attempt</p>
</td></tr>
<tr><td><code id="optindval_+3A_minsiz">minsiz</code></td>
<td>
<p>the minimum size cluster to consider reassigning a sample out of</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterative re-allocation algorithms temporarily re-assign each sample to each 
of the other possible clusters and calculate a goodness-of-clustering statistic for each
re-assignment.  The best of all possible re-assignments is then executed and the algorithm 
iterates until there are no more good re-assignments or the maximum number of iterations
is reached.  In optindval, the goodness-of-clustering statistic is the sum of Dufrene and Legendre
indicator values</p>


<h3>Value</h3>

<p>a list of class &quot;optindval&quot;,&quot;clustering&quot; with components:
</p>
<table>
<tr><td><code>numitr</code></td>
<td>
<p>the number of iterations performed</p>
</td></tr> 
<tr><td><code>sums</code></td>
<td>
<p>a vector of indicator value probability sums</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>the vector of cluster memberships (as integers) for each sample</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Like many iterative re-assignment algorithms, optindval is likely to be
VERY slow from a random start or poor initial condition.  optindval is maybe better
used to polish existing classifications</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code>optpart</code>, <code>opttdev</code>, <code>optsil</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg) # returns a data.frame of vegetation data called shoshveg
dis.bc &lt;- dsvdis(shoshveg,'bray') # generate Bray/Curtis dissimilarity 
                                  # matrix
opt.5 &lt;- optpart(5,dis.bc) # generate 5-cluster optpart
## Not run: res &lt;- optindval(shoshveg,opt.5) # polish the optpart result
## Not run: classmatch(opt.5,res) # see the plot re-assignments
</code></pre>

<hr>
<h2 id='optpart'>Optimal Partitioning of Dissimilarity/Distance Matrices</h2><span id='topic+optpart'></span><span id='topic+optpart.default'></span><span id='topic+optpart.clustering'></span><span id='topic+optpart.partana'></span><span id='topic+optpart.partition'></span><span id='topic+optpart.stride'></span>

<h3>Description</h3>

<p>Optimal partitioning is an
iterative re-allocation algorithm to maximize the ratio of within-cluster 
similarity/among-cluster similarity for a given number of clusters.  Optpart can operate as either
a crisp (classical) partitioning, or a fuzzy partitioning algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>optpart(x, dist, maxitr = 100, mininc = 0.001, maxdmu = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optpart_+3A_x">x</code></td>
<td>
<p>an integer, integer vector, factor vector, or objects of class &lsquo;clustering&rsquo;,
&lsquo;partana&rsquo;, &lsquo;partition&rsquo; or &lsquo;stride&rsquo;</p>
</td></tr> 
<tr><td><code id="optpart_+3A_dist">dist</code></td>
<td>
<p>a object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>, 
<code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code>, or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="optpart_+3A_maxitr">maxitr</code></td>
<td>
<p>the maximum number of iterations to perform</p>
</td></tr>
<tr><td><code id="optpart_+3A_mininc">mininc</code></td>
<td>
<p>the minimum increment in the within/among similarity ratio to
continue iterating</p>
</td></tr>
<tr><td><code id="optpart_+3A_maxdmu">maxdmu</code></td>
<td>
<p>the &lsquo;maximum delta mu&rsquo;.  If 1, a crisp (non-fuzzy) partition
results.  If (0,1) a fuzzy partition results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>optpart produces a partition, or clustering, of items into clusters by
iterative reallocation of items to clusters so as to maximize the within cluster/
among cluster similarity ratio.  At each iteration optpart ranks all possible
re-allocations of a sample from one cluster to another.  The re-allocation that maximizes
the change in the within-cluster/among-cluster ratio is performed.  The next best
reallocation is considered, and if it does not include any clusters already modified, it is
also performed, as re-allocations of independent clusters are independent and additive in
effect.  When no further re-allocations can be performed in that iteration, the algorithm
recalculates all possible re-allocations and iterates again.  When no re-allocations exist that
improve the within/among ratio greater than &lsquo;mininc&rsquo;, 
or the maximum number of iterations is reached, the algorithm stops.
</p>
<p>optpart is designed to run from a random start or the levels of a factor, or
preferably from existing initial partitions.  Specifying a single integer gives the number of clusters
desired using a random start.  Specifying an integer vector gives the initial assignments of
items to clusters.   Initial assignments can also be extracted from a number of objects.
Specific
methods exist for objects of class &lsquo;clustering&rsquo; from functions
<code><a href="#topic+slice">slice</a></code> or <code><a href="#topic+archi">archi</a></code>, class &lsquo;partana&rsquo; from function
<code><a href="#topic+partana">partana</a></code>, class &lsquo;stride&rsquo; from <code><a href="#topic+stride">stride</a></code>, or 
class &lsquo;partition&rsquo; from functions
<code><a href="cluster.html#topic+pam">pam</a></code> or <code><a href="cluster.html#topic+diana">diana</a></code>.  optpart is deterministic from a
given initial condition.  To get good results from a random start, multiple
random starts should be attempted, using function <code><a href="#topic+bestopt">bestopt</a></code>.
</p>
<p>Optpart is an unweighted algorithm, i.e. each of the <code class="reqn">(n^2-n)/2</code> pairwise distances or
dissimilarities is included in the calculation of the ratio exactly once.  Optpart
somewhat penalizes small clusters, as small clusters contribute only <code class="reqn">(n_i^2-n_i)/2</code> values
to the numerator; the extreme case is that a cluster with a single member does not
contribute anything to the numerator.
</p>
<p>It is an interesting characteristic of optpart that no minimum cluster size is enforced,
and it is common for partitions of a large number of clusters to contain null clusters, i.e.
clusters with no members.  This is not a bug or error, but rather an indication that a
partition with a fewer number of clusters achieves a better within/among similarity ratio
than does a larger number.  It is also somewhat common that for solutions with a small or
intermediate number of clusters, optpart places outliers in a small &lsquo;trash&rsquo; cluster.
</p>
<p>When optpart is run as a fuzzy partitioning algorithm, it often achieves a surprisingly low
entropy, with many items assigned completely to a single cluster.
</p>


<h3>Value</h3>

<p>an object of class <code>partana</code>, a list with elements:
</p>
<table>
<tr><td><code>ptc</code></td>
<td>
<p>a matrix of item mean similarity to each cluster</p>
</td></tr>
<tr><td><code>ctc</code></td>
<td>
<p>a matrix of mean cluster-to-cluster similarity</p>
</td></tr>
<tr><td><code>musubx</code></td>
<td>
<p>a matrix of membership of each item to each cluster.  If <code>maxdmu</code>
is 1, this will be a single 1 in the appropriate cluster and 0 in all others.  If
<code>maxdmu</code> is (0,1) then the musubx represent fuzzy memberships in each cluster.</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>a vector giving the cluster each item is assigned to.  If optpart
is run as a fuzzy partitioning, this is determined by the maximum membership observed.</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>the vector of within/among similarities achieved at each iteration.  The final
non-zero value is the final ratio achieved.</p>
</td></tr>
<tr><td><code>numitr</code></td>
<td>
<p>the number of iterations performed</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>the names of the items clustered</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>See Also</h3>

<p><code>partana</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
opt.5 &lt;- optpart(5,dis.bc)
summary(opt.5)
</code></pre>

<hr>
<h2 id='optpart.internal'>Internal Optpart Functions</h2><span id='topic+opt.core'></span><span id='topic+opts.core'></span><span id='topic+clustify'></span>

<h3>Description</h3>

<p>These functions establish generic functions or connections
to other packages and are not intended to be called directly</p>

<hr>
<h2 id='optsil'>Clustering by Optimizing Silhouette Widths</h2><span id='topic+optsil'></span><span id='topic+optsil.default'></span><span id='topic+optsil.clustering'></span><span id='topic+optsil.partana'></span><span id='topic+optsil.partition'></span><span id='topic+optsil.stride'></span>

<h3>Description</h3>

<p>Silhouette width is a measurement of the mean similarity of each
object to the other objects in its cluster, compared to its mean similarity to
the most similar cluster (see <code><a href="cluster.html#topic+silhouette">silhouette</a></code>).  Optsil is an
iterative re-allocation algorithm to maximize the mean silhouette width of a
clustering for a given number of clusters.</p>


<h3>Usage</h3>

<pre><code class='language-R'>optsil(x,dist,maxitr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optsil_+3A_x">x</code></td>
<td>
<p>an integer, a vector of integers, an object of class &lsquo;clustering&rsquo;,
&lsquo;partana&rsquo;, &lsquo;partition&rsquo;, or &lsquo;stride&rsquo;</p>
</td></tr>
<tr><td><code id="optsil_+3A_dist">dist</code></td>
<td>
<p>a object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>, 
<code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code>,
or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="optsil_+3A_maxitr">maxitr</code></td>
<td>
<p>the maximum number of iterations to perform</p>
</td></tr>
</table>


<h3>Details</h3>

<p>optsil produces a partition, or clustering, of items into clusters by
iterative reallocation of items to clusters so as to maximize the mean
silhouette width of the classification.  At each iteration optsil ranks all
possible re-allocations of a item from one cluster to another.  The
reallocation that maximizes the change in the mean silhouette width is performed.
Because silhouette widths are not independent of clusters that are not modified,
only a single reallocation can be preformed in a single iteration.  When no
further re-allocations result in an improvement, or the maximum number of
iterations is achieved, the algorithm stops.
</p>
<p>Optsil is an unweighted algorithm, i.e. each of the objects is
included in the calculation exactly once.
</p>
<p>Optsil can be extremely slow to converge, and is best used to &lsquo;polish&rsquo; an
existing partition or clusterings resulting from slicing an <code><a href="stats.html#topic+hclust">hclust</a></code> or 
from functions <code><a href="#topic+optpart">optpart</a></code>, <code><a href="cluster.html#topic+pam">pam</a></code>,
<code><a href="cluster.html#topic+diana">diana</a></code> or other initial clusterings.  It is possible 
to run optsil from a random start, but is EXTREMELY SLOW to converge, and should be 
done only with caution.
</p>


<h3>Value</h3>

<p>a list with elements:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>a vector of integers giving the cluster assignment for each
object</p>
</td></tr>
<tr><td><code>sils</code></td>
<td>
<p>a vector of the silhouette widths achieved at each iteration</p>
</td></tr>
<tr><td><code>numitr</code></td>
<td>
<p>the number of iterations performed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optpart">optpart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
opt.5 &lt;- optpart(5,dis.bc)
sil.5 &lt;- optsil(opt.5,dis.bc,100) # make take a few minutes
summary(silhouette(sil.5,dis.bc))
## Not run: plot(silhouette(sil.5,dis.bc))
</code></pre>

<hr>
<h2 id='opttdev'>Optimizing Classification by Minimizing Table Deviance</h2><span id='topic+opttdev'></span>

<h3>Description</h3>

<p>opttdev is a iterative re-assignment classification algorithm
that assigns samples to clusters to minimize the total deviance of a table
with respect to the row-wise relative abundance of the elements</p>


<h3>Usage</h3>

<pre><code class='language-R'>opttdev(comm,clustering,maxitr=100,minsiz=5)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opttdev_+3A_comm">comm</code></td>
<td>
<p>a vegetation or other taxon table with samples as rows and taxa as columns</p>
</td></tr>
<tr><td><code id="opttdev_+3A_clustering">clustering</code></td>
<td>
<p>an index of cluster membership for each sample. May be either
a numeric vector of length equal to the number of samples, or
an object that inherits from class &lsquo;cluster&rsquo;</p>
</td></tr>
<tr><td><code id="opttdev_+3A_maxitr">maxitr</code></td>
<td>
<p>the maximum number of iterations to attempt</p>
</td></tr>
<tr><td><code id="opttdev_+3A_minsiz">minsiz</code></td>
<td>
<p>the minimum size cluster to consider reassigning a sample out of</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iterative re-allocation algorithms temporarily re-assign each sample to each 
of the other possible clusters and calculate a goodness-of-clustering statistic for each
re-assignment.  The best of all possible re-assignments is then executed and the algorithm 
iterates until there are no more good re-assignments or the maximum number of iterations
is reached.  In opttdev, the goodness-of-clustering statistic is total table deviance
as calculated by <code><a href="#topic+tabdev">tabdev</a></code>.  See the help file for 
<code><a href="#topic+tabdev">tabdev</a></code> for more detail.</p>


<h3>Value</h3>

<p>a list which inherits from class &lsquo;opttdev&rsquo;, &lsquo;clustering&rsquo; with components:
</p>
<table>
<tr><td><code>numitr</code></td>
<td>
<p>the number of iterations performed</p>
</td></tr> 
<tr><td><code>dev</code></td>
<td>
<p>a vector of total table deviance at each iteration of length &lsquo;numitr&rsquo;</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>the vector of cluster memberships (as integers) for each sample</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Like many iterative re-assignment algorithms, opttdev is likely to be
VERY slow from a random start or poor initial condition.  opttdev is maybe better
used to polish existing classifications</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+optpart">optpart</a></code>, <code><a href="#topic+optindval">optindval</a></code>, <code><a href="#topic+optsil">optsil</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(shoshveg) # returns a data.frame of vegetation
## Not run: data(shoshsite)
## Not run: res &lt;- opttdev(shoshveg,
                  as.numeric(cut(shoshsite$elevation,5)))
## End(Not run) 
## Not run: # likely to be VERY slow
</code></pre>

<hr>
<h2 id='partana'>Partition Analysis</h2><span id='topic+partana'></span><span id='topic+partana.default'></span><span id='topic+partana.partition'></span><span id='topic+partana.clustering'></span><span id='topic+partana.stride'></span><span id='topic+summary.partana'></span><span id='topic+plot.partana'></span>

<h3>Description</h3>

<p>Partition analysis evaluates the within-cluster to among-cluster
similarity of classifications as a measure of cluster validity</p>


<h3>Usage</h3>

<pre><code class='language-R'>partana(c,dist)
## S3 method for class 'partana'
summary(object, ...)
## S3 method for class 'partana'
plot(x,panel='all',zlim=range(x$ptc),col=heat.colors(12),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partana_+3A_c">c</code></td>
<td>
<p>an integer or factor vector, or an object of class &lsquo;clustering&rsquo;,
&lsquo;partana&rsquo;, &lsquo;partition&rsquo;, or &lsquo;stride&rsquo;</p>
</td></tr>
<tr><td><code id="partana_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from functions <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code> or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr></table>
<p>.  
</p>
<table>
<tr><td><code id="partana_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;partana&rsquo;</p>
</td></tr>
<tr><td><code id="partana_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;partana&rsquo;</p>
</td></tr>
<tr><td><code id="partana_+3A_panel">panel</code></td>
<td>
<p>an integer switch to indicate which panel to draw</p>
</td></tr>
<tr><td><code id="partana_+3A_zlim">zlim</code></td>
<td>
<p>the min and max values for the color map</p>
</td></tr>
<tr><td><code id="partana_+3A_col">col</code></td>
<td>
<p>a color map name (heat.colors(12) is the default)</p>
</td></tr>
<tr><td><code id="partana_+3A_...">...</code></td>
<td>
<p>ancillary arguments to pass to summary or plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates mean object-to-cluster similarity, mean cluster-to-cluster
similarity, and mean within-cluster to among-cluster similarity.  partana operates
on partitions or clusterings produced by a wide range of algorithms, including specific 
methods for the products of functions <code><a href="#topic+optpart">optpart</a></code>, <code><a href="#topic+slice">slice</a></code>, 
<code><a href="cluster.html#topic+pam">pam</a></code> and <code><a href="cluster.html#topic+diana">diana</a></code>.
</p>
<p><code>summary</code> produces a matrix of the mean cluster-to-cluster similarities,
and the overall within-cluster/among-cluster similarity ratio.
</p>
<p><code>plot</code> plots two panels in sequence in the current device. The first shows
the mean similarity of every object to each cluster, sorted by mean similarity
to the other members of its own cluster, with objects as columns and clusters
as rows. The second panel shows the mean similarity of every cluster to every
other cluster and mean within-cluster similarity, ignoring cluster size. These
plots are known as &lsquo;Mondriaan&rsquo; plots, where the similarities are given by lines
colored from min to max.  If the &lsquo;partana&rsquo; object was produced by optpart, a
third panel is plotted showing the trace of the optimization.  
</p>


<h3>Value</h3>

<p>an object of class &lsquo;partana&rsquo; with components:
</p>
<table>
<tr><td><code>ptc</code></td>
<td>
<p>matrix of mean object-to-cluster similarity</p>
</td></tr>
<tr><td><code>ctc</code></td>
<td>
<p>matrix of mean cluster-to-cluster similarity</p>
</td></tr>
<tr><td><code>clustering</code></td>
<td>
<p>vector of numeric cluster assignments</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>within-cluster to among-cluster similarity ratio</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition">partition</a></code>, <code><a href="#topic+optpart">optpart</a></code>,
<code><a href="#topic+plot.partana">plot.partana</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
data(shoshsite)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
demo.part &lt;- partana(cut(shoshsite$elev,5),dis.bc)
summary(demo.part)
</code></pre>

<hr>
<h2 id='partition'>Convert Object to Partition Object</h2><span id='topic+partition'></span><span id='topic+partition.partana'></span><span id='topic+partition.clustering'></span>

<h3>Description</h3>

<p>Convert an object of class &lsquo;partana&rsquo; or class &lsquo;clustering&rsquo;
to an object of class &lsquo;partition&rsquo;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(x, dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_+3A_x">x</code></td>
<td>
<p>an object which inherits from class &lsquo;clustering&rsquo;</p>
</td></tr>
<tr><td><code id="partition_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo;</p>
</td></tr>
<tr><td><code id="partition_+3A_...">...</code></td>
<td>
<p>ancillary arguments to pass to &lsquo;partition&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &lsquo;partition&rsquo; object is the output of several functions
in package &lsquo;cluster&rsquo;.  This utility function converts objects
from package &lsquo;optpart&rsquo; to &lsquo;partitions&rsquo; so that
functions in that library are available.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;partition&rsquo; with components (and possibly others):
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>vector of numeric cluster assignments</p>
</td></tr>
<tr><td><code>silinfo</code></td>
<td>
<p>a list with all silhouette information, only available when
the number of clusters is non-trivial, i.e., <code class="reqn">1 &lt; k &lt; n</code>.
See &lsquo;silhouette&rsquo;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+silhouette">silhouette</a></code>, <code><a href="#topic+partition">partition</a></code>,
<code><a href="#topic+optpart">optpart</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
part &lt;- partana(sample(1:5,nrow(shoshveg),replace=TRUE),dis.bc)
result &lt;- partition(part,dis.bc)
</code></pre>

<hr>
<h2 id='phi'>Calculating the phi Statistic on Taxon Classifications</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>Calculates the <code class="reqn">phi</code> statistic on a classified 
table of taxa</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(comm,clustering,minplt=10,p.adjust=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_+3A_comm">comm</code></td>
<td>
<p>a data.frame with samples as rows and attributes as columns</p>
</td></tr>
<tr><td><code id="phi_+3A_clustering">clustering</code></td>
<td>
<p>a vector of integers or an object of class &lsquo;clustering&rsquo;,
&lsquo;partition&rsquo;, or &lsquo;partana&rsquo;</p>
</td></tr>
<tr><td><code id="phi_+3A_minplt">minplt</code></td>
<td>
<p>the minimum number of samples a species must occur in to be included 
in the calculation</p>
</td></tr>
<tr><td><code id="phi_+3A_p.adjust">p.adjust</code></td>
<td>
<p>switch to control adjusting probabilities for simultaneous inference 
by Hochberg correction</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">phi</code> is a statistic of agreement between two vectors.  In this case
the function calculates the distribution of each species within clusters of a partition, 
calculates the <code class="reqn">phi</code> statistic for each species in each cluster. 
</p>
<p style="text-align: center;"><code class="reqn">\phi = \frac{ad - bc}{\sqrt{(a+b)\times(c+d)\times(a+c)\times(b+c)}}</code>
</p>

<p>where:
</p>

<table>
<tr>
 <td style="text-align: left;">
a </td><td style="text-align: left;"> sample is in specified type and species is present</td>
</tr>
<tr>
 <td style="text-align: left;">
b </td><td style="text-align: left;"> sample is not in group and species is present</td>
</tr>
<tr>
 <td style="text-align: left;">
c </td><td style="text-align: left;"> sample is in type but species is not present</td>
</tr>
<tr>
 <td style="text-align: left;">
d </td><td style="text-align: left;"> sample is not in type and species is not present</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A data.frame of <code class="reqn">\phi</code> values with species as rows and clusters as columns</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p>Tichy, L. and M. Chytry.  2006.  Statistical determination of
diagnostic species for site groups of unequal size.  Journal of Vegetation Science
17:809-818.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.5 &lt;- optpart(5,dis.bc)
phi(shoshveg,opt.5)
</code></pre>

<hr>
<h2 id='refine'>Refining a Classification by Re-Assigning Memberships</h2><span id='topic+refine'></span><span id='topic+refine.default'></span><span id='topic+refine.dsvord'></span><span id='topic+refine.nmds'></span><span id='topic+refine.pco'></span>

<h3>Description</h3>

<p>Refine allows you to re-assign specific elements of a
classification from one class or cluster to another.  In the default case, you
simply interactively enter sample IDs and give a new cluster assignment.  For
PCO and NMDS ordinations, you do the assignments with a mouse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
refine(comm,clustering,...)
## S3 method for class 'dsvord'
refine(x,clustering,ax=1,ay=2,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refine_+3A_comm">comm</code></td>
<td>
<p>a community data.frame</p>
</td></tr>
<tr><td><code id="refine_+3A_x">x</code></td>
<td>
<p>an ordination of class &lsquo;dsvord&rsquo;</p>
</td></tr>
<tr><td><code id="refine_+3A_clustering">clustering</code></td>
<td>
<p>a clustering identity or membership vector</p>
</td></tr>
<tr><td><code id="refine_+3A_ax">ax</code></td>
<td>
<p>the X axis of the ordination</p>
</td></tr>
<tr><td><code id="refine_+3A_ay">ay</code></td>
<td>
<p>the Y axis of the ordination</p>
</td></tr>
<tr><td><code id="refine_+3A_...">...</code></td>
<td>
<p>ancillary arguments to allow differing numbers of arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object of class &lsquo;clustering&rsquo; with one component.
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>a numeric vector giving the cluster assignment for each
sample</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There are many, many ways to produce classifications in R, including
several in package &lsquo;optpart&rsquo;.  refine is designed to take one of these
classifications and polish it by making relatively few transfers.  The
ordination-based routines allow visual assessment of cluster validity, although
in reduced dimensionality, which can be misleading.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data(shoshveg)
## Not run: dis.bc &lt;- dsvdis(shoshveg,'bray')
## Not run: opt.5 &lt;- optpart(5,dis.bc)
## Not run: nmds.bc &lt;- nmds(dis.bc)
## Not run: plot(nmds.bc)
## Not run: res &lt;- refine(nmds.bc,opt.5)
</code></pre>

<hr>
<h2 id='reordclust'>Re-order Clusters in a Classification</h2><span id='topic+reordclust'></span>

<h3>Description</h3>

<p>In it's simplest form simply reassigns cluster numbers 
in an existing classification to re-order tables and graphs.  Can also
be used to combine clusters into a fewer number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reordclust(clustering,from,to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reordclust_+3A_clustering">clustering</code></td>
<td>
<p>a vector of (interger) cluster mmeberships, or an object
of class &lsquo;clustering&rsquo;, &lsquo;partana&rsquo;, or &lsquo;partition&rsquo;</p>
</td></tr>
<tr><td><code id="reordclust_+3A_from">from</code></td>
<td>
<p>an integer vector equal in length to the number of clusters
that specifies the current clusters</p>
</td></tr>
<tr><td><code id="reordclust_+3A_to">to</code></td>
<td>
<p>an integer vector equal in length to the number of clusters
that specifies the clusters the current clusters map to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simply maps cluster numbers in the &lsquo;from&rsquo; 
vector to the respective cluster number in the &lsquo;to&rsquo; vector.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;clustering&rsquo;</p>


<h3>Note</h3>

<p>As demonstrated in the examples below, reordclass can also combine existing
clusters into fewer clusters while reordering if more than one cluster in the 
&lsquo;from&rsquo; vector maps to the same cluster in the &lsquo;to&rsquo; cluster.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code>mergeclust</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.10 &lt;- optpart(10,dis.bc)
new &lt;- reordclust(opt.10,1:10,c(1,3,5,7,9,2,4,6,8,10))
           # simply re-ordered
new2 &lt;- reordclust(opt.10,1:10,c(1,1,2,2,3,3,4,4,5,5))
           # merge 1 and 2 into 1, 3 and 4 into 2, etc.
</code></pre>

<hr>
<h2 id='shoshsite'>Site Data for the Shoshone National Forest, Wyoming, USA</h2><span id='topic+shoshsite'></span>

<h3>Description</h3>

<p>The coniferous forests of the Shoshone National Forest range from lower
elevation woodlands dominated by <em>Pinus flexilis</em>, through forests of <em>
Pseudotsuga menziesii, Pinus contorta, Picea engelmannii, Abies lasiocarpa</em> and
<em>Pinus albicaulis</em> with increasing elevation (Steele et al. 1983).  One
hundred and fifty sample plots were chosen at random from a larger set for this
data set; the larger set was stratified by elevation, exposure, surficial
geology, and geographic distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shoshsite)</code></pre>


<h3>Format</h3>

<p>A data.frame with sample plots as rows, and site variable as columns.  Variables
comprise:
</p>

<table>
<tr>
 <td style="text-align: left;">
elevation </td><td style="text-align: left;"> elevation above sea level in meters</td>
</tr>
<tr>
 <td style="text-align: left;">
aspect </td><td style="text-align: left;"> compass orientation of the site in degrees</td>
</tr>
<tr>
 <td style="text-align: left;">
slope </td><td style="text-align: left;"> slope steepness in percent</td>
</tr>
<tr>
 <td style="text-align: left;">
av </td><td style="text-align: left;"> aspect value:  (cosd(aspect-30)+1)/2</td>
</tr>
<tr>
 <td style="text-align: left;">
swb </td><td style="text-align: left;"> site water balance: a tipping bucket model of water-year soil water</td>
</tr>
<tr>
 <td style="text-align: left;">
sprppt </td><td style="text-align: left;"> spring precipitation in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
sumppt </td><td style="text-align: left;"> summer precipitation in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
autppt </td><td style="text-align: left;"> autumn precipitation in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
winppt </td><td style="text-align: left;"> winter precipitation in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
sprtmp </td><td style="text-align: left;"> spring mean temperature degrees C</td>
</tr>
<tr>
 <td style="text-align: left;">
sumtmp </td><td style="text-align: left;"> summer mean temperature degrees C</td>
</tr>
<tr>
 <td style="text-align: left;"> 
auttmp </td><td style="text-align: left;"> autumn mean temperature degrees C</td>
</tr>
<tr>
 <td style="text-align: left;">
winppt </td><td style="text-align: left;"> winter mean temperature degrees C</td>
</tr>
<tr>
 <td style="text-align: left;">
sprpet </td><td style="text-align: left;"> spring potential evapotranspiration in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
sumpet </td><td style="text-align: left;"> summer potential evapotranspiration in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
autpet </td><td style="text-align: left;"> autumn potential evapotranspiration in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
winpet </td><td style="text-align: left;"> winter potential evapotranspiration in cm</td>
</tr>
<tr>
 <td style="text-align: left;">
sprrad </td><td style="text-align: left;"> spring direct and diffuse solar radiation (correcting for topographic
shading)</td>
</tr>
<tr>
 <td style="text-align: left;">
sumrad </td><td style="text-align: left;"> summer direct and diffuse solar radiation (correcting for topographic
shading)</td>
</tr>
<tr>
 <td style="text-align: left;">
autrad </td><td style="text-align: left;"> autumn direct and diffuse solar radiation (correcting for topographic
shading)</td>
</tr>
<tr>
 <td style="text-align: left;">
win </td><td style="text-align: left;"> winter direct and diffuse solar radiation (correcting for topographic
shading)</td>
</tr>
<tr>
 <td style="text-align: left;">
ffd </td><td style="text-align: left;"> frost free days</td>
</tr>
<tr>
 <td style="text-align: left;">
dday </td><td style="text-align: left;"> degree days heat sum</td>
</tr>
<tr>
 <td style="text-align: left;">
tcol </td><td style="text-align: left;"> mean monthly temperature of the coldest month</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>The data were derived from a multi-year effort by numerous scientists and
field technicians.  The project was directed by Kent Houston, Soil Scientist and
Ecologist, Shoshone National Forest.  The site data were calculated primarily
by Dr. Niklaus Zimmermann, WSL, Birmensdorf, Switzerland 
<a href="http://www.wsl.ch/staff/niklaus.zimmermann/biophys.html">http://www.wsl.ch/staff/niklaus.zimmermann/biophys.html</a>
</p>


<h3>Source</h3>

<p>Roberts, D.W.  2008.  Statistical Analysis of Multidimensional
Fuzzy Set Ordinations.  Ecology 89:1246-1260</p>

<hr>
<h2 id='shoshveg'>Vascular Plant Species Cover for the Shoshone National Forest, Wyoming, USA</h2><span id='topic+shoshveg'></span>

<h3>Description</h3>

<p>Percent cover (in codes) for 368 vascular plants on 150 <code class="reqn">375m^2</code> sample plots 
stratified across the Shoshone National Forest, Wyoming, USA.  Plots were chosen at
random from a larger dataset.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shoshveg)</code></pre>


<h3>Format</h3>

<p>A data.frame with sample plots as rows and species as columns.  Sample plots
match the &lsquo;shoshsite&rsquo; dataset.
</p>
<p>The cover of all vascular plant species was recorded according to the
following scale: present but &lt; 1% = 0.1, 1-5% = 0.5, 5-15% = 1.0, 15-25% =
2.0, 25-35% = 3.0, 35-45% = 4.0, 45-55% = 5.0, 55-65% = 6.0, 65=75% = 7.0,
75-85% = 8.0.  No species exhibited greater than 80% cover in the data set.
</p>


<h3>Note</h3>

<p>The data were derived from a multi-year effort by numerous scientists and
field technicians.  The project was directed by Kent Houston, Soil Scientist and
Ecologist, Shoshone National Forest</p>


<h3>Source</h3>

<p>Roberts, D.W.  2008.  Statistical Analysis of Multidimensional 
Fuzzy Set Ordinations.  Ecology 89:1246-1260.</p>

<hr>
<h2 id='silhouette.partana'>Produce a Silhouette Object From a Partana, Clustering, or Stride Object</h2><span id='topic+silhouette.partana'></span><span id='topic+silhouette.clustering'></span><span id='topic+silhouette.stride'></span><span id='topic+testsil'></span>

<h3>Description</h3>

<p>Extracts components from a <code>partana</code>, <code>clustering</code>, or <code>stride</code> object,
and passes the values to the <code><a href="cluster.html#topic+silhouette">silhouette</a></code> function to
produce an object of class silhouette.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partana'
silhouette(x, dist, ...)
## S3 method for class 'clustering'
silhouette(x, dist, ...)
## S3 method for class 'stride'
silhouette(x, dist, ...)
testsil(sil)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="silhouette.partana_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;partana&rsquo;, &lsquo;clustering&rsquo;, or &lsquo;stride&rsquo;</p>
</td></tr>
<tr><td><code id="silhouette.partana_+3A_dist">dist</code></td>
<td>
<p>an object of class dist</p>
</td></tr>
<tr><td><code id="silhouette.partana_+3A_...">...</code></td>
<td>
<p>miscellaneous arguments to pass to function silhouette</p>
</td></tr>
<tr><td><code id="silhouette.partana_+3A_sil">sil</code></td>
<td>
<p>an object of class &lsquo;silhouette&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For &lsquo;partana&rsquo; and &lsquo;clustering&rsquo; objects the advantage over
calling <code><a href="cluster.html#topic+silhouette">silhouette</a></code> directly is that the row.names of the resulting 
object are added to the results, as opposed to consecutive integers.
</p>
<p>For objects of class &lsquo;stride&rsquo; the function extracts the component
&lsquo;clustering&rsquo; for each level of a stride object, and calls function
<code><a href="cluster.html#topic+silhouette">silhouette</a></code> in library &lsquo;cluster&rsquo; 
returniung the mean silhouette width for each case.
</p>
<p><code>testsil</code> identifies &lsquo;misfits&rsquo; in a partition, defined as plots with
a negative silhouette width, and prints them out in a sorted list.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="cluster.html#topic+silhouette">silhouette</a></code>
</p>


<h3>Note</h3>

<p>This is a a simple conversion routine to allow plotting a silhouette plot
for an object of class partana.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>References</h3>

<p><a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a></p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+silhouette">silhouette</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)             # produces a data frame of vegetation data, 
                           #samples as rows, attributes as columns
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis') # produces a Bray/Curtis 
                                         # dissimilarity matrix
opt.5 &lt;- optpart(5,dis.bc) # produces an optimal partitioning into 
                           # 5 clusters
silhouette(opt.5,dis.bc)   # calculates the silhouette values
## Not run: plot(silhouette(opt.5,dis.bc)) # produce silhouette 
                                         # plot on current device
</code></pre>

<hr>
<h2 id='slice'>Slice a Hierarchical Clustering Dendrogram with a Mouse</h2><span id='topic+slice'></span>

<h3>Description</h3>

<p>Allows a simple classification of objects by slicing a dendrogram of a
hierarchical cluster analysis graphically with a mouse, or by simply
giving a number.</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(clust, k=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_clust">clust</code></td>
<td>
<p>an object of class &lsquo;hclust&rsquo; produced by <code>hclust</code></p>
</td></tr>
<tr><td><code id="slice_+3A_k">k</code></td>
<td>
<p>a desired number of clusters.  If null, the function waits
on a mouse click</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &lsquo;clustering&rsquo;, a list with a vector of cluster memberships</p>


<h3>Note</h3>

<p>This function is a simple wrapper for <code>cutree</code> that allows users
to click their mouse at the height they desire to slice the dendrogram, and to establish
the result with a class of &lsquo;clustering&rsquo; for ease of use in other functions.  If you
want to use the mouse, the dendrogram must have been previously plotted in the current
graphic device.</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>See Also</h3>

<p><code><a href="labdsv.html#topic+ordpart">ordpart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
demo &lt;- hclust(dis.bc,'ave')
ave.5 &lt;- slice(demo,5)
## Not run: plot(demo)
## Not run: ave.clust &lt;- slice(demo)
</code></pre>

<hr>
<h2 id='stride'>Stride: Producing a Sequence of Clusterings</h2><span id='topic+stride'></span><span id='topic+plot.stride'></span>

<h3>Description</h3>

<p>stride proceeds along a specified sequence creating clusterings or
partitions of a dissimilarity matrix for each value of the sequence.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stride(seq,arg2,type='pam',numrep=10,maxitr=100)
## S3 method for class 'stride'
plot(x, dist, col2=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stride_+3A_seq">seq</code></td>
<td>
<p>a sequence, in either a:b or seq(a,b,c) form</p>
</td></tr>
<tr><td><code id="stride_+3A_arg2">arg2</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from 
<code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code> or 
<code><a href="vegan.html#topic+vegdist">vegdist</a></code> among other
sources, or of class &lsquo;hclust&rsquo;</p>
</td></tr>
<tr><td><code id="stride_+3A_type">type</code></td>
<td>
<p>if arg2 is an object of class &lsquo;dist&rsquo;, type specifies the
algorithm to produce clusters, and can be either &lsquo;pam&rsquo; or &lsquo;optpart&rsquo;.</p>
</td></tr>
<tr><td><code id="stride_+3A_numrep">numrep</code></td>
<td>
<p>if arg2 is an object of class &lsquo;dist&rsquo; and type =
&lsquo;optpart&rsquo;, numrep specifies the number of replicates to run in function 
<code><a href="#topic+optpart">optpart</a></code>.</p>
</td></tr>
<tr><td><code id="stride_+3A_maxitr">maxitr</code></td>
<td>
<p>if arg2 is an object of class &lsquo;dist&rsquo; and type = 
&lsquo;optpart&rsquo; numrep specifies the maximum number of iterations per replicate 
in function
<code><a href="#topic+optpart">optpart</a></code></p>
</td></tr>
<tr><td><code id="stride_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;stride&rsquo;</p>
</td></tr>
<tr><td><code id="stride_+3A_dist">dist</code></td>
<td>
<p>an object of class &lsquo;dist&rsquo; from <code><a href="stats.html#topic+dist">dist</a></code>, 
<code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code>, or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="stride_+3A_col2">col2</code></td>
<td>
<p>the color code for the second line in the graph</p>
</td></tr>
<tr><td><code id="stride_+3A_...">...</code></td>
<td>
<p>ancillary arguments to the plot function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specific action of function stride depends on the class of the second
argument.  If arg2 is of class &lsquo;dist&rsquo;, then clusters are generated by
a fixed cluster algorithm.  In this case, if type is &lsquo;pam&rsquo;, the 
function <code><a href="cluster.html#topic+pam">pam</a></code> is called to
produce the clusters.  If type is &lsquo;optpart&rsquo; the function
<code><a href="#topic+optpart">optpart</a></code> is called to produce the clusters.
If arg2 is of class &lsquo;hclust&rsquo;, then the hlcust object is successively
&lsquo;sliced&rsquo; at levels specified by the sequence.  The object of class
&lsquo;hclust&rsquo; can result from the function <code>hclust</code> using any of the
methods provided, or by casting an object of class &lsquo;partition&rsquo; to class
&lsquo;hlcust&rsquo; with the <code>as.hclust</code> function.
</p>
<p>The default plot method for a stride plots the partana ratios 
(see <code><a href="#topic+partana">partana</a></code>) of each partition of the sequence on the left Y axis, 
and the silhouette widths of the same partitions on the right Y axis.
</p>


<h3>Value</h3>

<p>an object of class &lsquo;stride&rsquo;, which is a list with components:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>a data.frame with items as rows, and cluster IDs as columns,
with one column for each value of the sequence</p>
</td></tr>
<tr><td><code>seq</code></td>
<td>
<p>a copy of the sequence employed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts <a href="mailto:droberts@montana.edu">droberts@montana.edu</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
results &lt;- stride(2:5,dis.bc)
</code></pre>

<hr>
<h2 id='tabdev'>Classification Validity Assessment by Table Deviance</h2><span id='topic+tabdev'></span><span id='topic+summary.tabdev'></span><span id='topic+tabdev.stride'></span><span id='topic+tabdev.default'></span>

<h3>Description</h3>

<p>Table deviance is a method to assess the quality of classifications
by calculating the clarity of the classification with respect to the original
data, as opposed to a dissimilarity or distance matrix representation</p>


<h3>Usage</h3>

<pre><code class='language-R'>    ## Default S3 method:
tabdev(x,clustering,nitr=999,...)
    ## S3 method for class 'stride'
tabdev(x,taxa,...)
    ## S3 method for class 'tabdev'
summary(object,p=0.05,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabdev_+3A_x">x</code></td>
<td>
<p>a matrix or data.frame of multivariate observations, with objects as rows,
and attributes as columns</p>
</td></tr>
<tr><td><code id="tabdev_+3A_clustering">clustering</code></td>
<td>
<p>a vector of integer cluster assignments, or an object of
class &lsquo;clustering&rsquo; or &lsquo;partana&rsquo;</p>
</td></tr>
<tr><td><code id="tabdev_+3A_nitr">nitr</code></td>
<td>
<p>number of iterations to perform in calculating the probability of
obtaining as effective a classification as observed</p>
</td></tr>
<tr><td><code id="tabdev_+3A_taxa">taxa</code></td>
<td>
<p>a data.frame with samples as rows and species as columns</p>
</td></tr>
<tr><td><code id="tabdev_+3A_object">object</code></td>
<td>
<p>and object of class &lsquo;tabdev&rsquo;</p>
</td></tr>
<tr><td><code id="tabdev_+3A_p">p</code></td>
<td>
<p>the maximum probability threshold to list species in the summary table</p>
</td></tr>
<tr><td><code id="tabdev_+3A_...">...</code></td>
<td>
<p>ancillary arguments to maintain compatibility with generic summary function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tabdev calculates the concentration of values within clusters.  For each
column, tabdev calculates the sum of values within classes and the sum within classes
divided by the sum of that column to get fractional sums by class.  These values are
used to calculate the deviance of each row.  Attributes that are widely dispersed
among classes exhibit high deviance; attributes that are concentrated within a single
class contribute zero deviance.  An effective classification should exhibit low
deviance.
</p>
<p>Tabdev then permutes the values within columns and calculates the probability of
observing as low a deviance as observed as
$$ (m+1)/(niter + 1)$$
where $m$ is the number of cases with as low or lower deviance as observed.
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table>
<tr><td><code>spcdev</code></td>
<td>
<p>a data.frame with species, deviance, and probability as columns</p>
</td></tr>
<tr><td><code>totdev</code></td>
<td>
<p>the total deviance of the entire table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
<a href="http://ecology.msu.montana.edu/labdsv/R">http://ecology.msu.montana.edu/labdsv/R</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
opt.5 &lt;- optpart(5,dis.bc)
tabdev(shoshveg,opt.5)
</code></pre>

<hr>
<h2 id='testpart'>Identify Misclassified Plots in a Partition</h2><span id='topic+testpart'></span>

<h3>Description</h3>

<p>testopt analyzes 
the mean similarity of each sample to the cluster to which it is assigned to all 
other clusters, and lists those samples which have similarity higher to another
cluster than to the one to which they are assigned.</p>


<h3>Usage</h3>

<pre><code class='language-R'>testpart(part,ord=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testpart_+3A_part">part</code></td>
<td>
<p>a object of class &lsquo;partana&rsquo; from <code>partana</code> or  <code>optpart</code></p>
</td></tr> 
<tr><td><code id="testpart_+3A_ord">ord</code></td>
<td>
<p>a switch to control whether the output is ordered</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply examines each sample plot, comparing the mean similarity of that 
sample to all other samples in the cluster to which it is assigned as compared to its
mean similarity to all other clusters.  Samples which are more similar to other
clusters than to the one to which they are assigned are listed in a table which gives
their current cluster assignment, the cluster to which they are more similar, and 
the mean similarities of that sample to all clusters.
</p>
<p>If &lsquo;ord=TRUE&rsquo; then the output is ordered to reflect target clusters.
</p>


<h3>Value</h3>

<p>a table of values</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partana">partana</a></code>, <code><a href="#topic+partana">partana</a></code>, <code><a href="cluster.html#topic+silhouette">silhouette</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray/curtis')
opt.5 &lt;- optpart(5,dis.bc)
testpart(opt.5)
</code></pre>

<hr>
<h2 id='typal'>Identification of Typal Samples in a Partition</h2><span id='topic+typal'></span>

<h3>Description</h3>

<p>Identifies samples that typify clusters in a partition based on dissimilarity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>typal(clustering,dist,k=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="typal_+3A_clustering">clustering</code></td>
<td>
<p>a vector of integers or an object of class &lsquo;clustering&rsquo;,
&lsquo;partition&rsquo;, or &lsquo;partana&rsquo;</p>
</td></tr>
<tr><td><code id="typal_+3A_dist">dist</code></td>
<td>
<p>and object of class &lsquo;dist&rsquo; from <code>dist</code>, <code><a href="labdsv.html#topic+dsvdis">dsvdis</a></code>,
or <code><a href="vegan.html#topic+vegdist">vegdist</a></code></p>
</td></tr>
<tr><td><code id="typal_+3A_k">k</code></td>
<td>
<p>number of typal species/cluster to identify</p>
</td></tr>
</table>


<h3>Details</h3>

<p>typal calculates two versions of typal species based on silhouette analysis 
(see <code><a href="cluster.html#topic+silhouette">silhouette</a></code>) and partana analysis 
(see <code><a href="#topic+partana">partana</a></code>).  With respect to silhouette analysis, the 
function returns k species with the largest positive silhouette width for each 
cluster.  With respect to the partana analysis the function returns the k species
with the highest mean similarity to the cluster.
</p>


<h3>Value</h3>

<p>Returns a list with two data.frames.  The first, partana, gives the 
clusters as rows and typal samples as columns from the perspective of
the partana ratio.  The second, silhouette,
also gives the clusters as rows and typal samples as columns but from the perspective
of silhouette widths.
</p>


<h3>Author(s)</h3>

<p>David W. Roberts
<a href="mailto:droberts@montana.edu">droberts@montana.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(shoshveg)
dis.bc &lt;- dsvdis(shoshveg,'bray')
opt.5 &lt;- bestopt(dis.bc,5,20)
typal(opt.5,dis.bc,3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
