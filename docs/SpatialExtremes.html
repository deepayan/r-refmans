<!DOCTYPE html><html><head><title>Help for package SpatialExtremes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialExtremes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova'><p>Anova Tables</p></a></li>
<li><a href='#concprob'><p>Pairwise empirical and extremal concurrence probabilities</p></a></li>
<li><a href='#concurrencemap'><p>Maps of concurrence probabilities/expected concurrence cell area</p></a></li>
<li><a href='#condmap'><p>Produces a conditional 2D map from a fitted max-stable process</p></a></li>
<li><a href='#condrgp'>
<p>Conditional simulation of Gaussian random fields</p></a></li>
<li><a href='#condrmaxlin'>
<p>Conditional simulation of max-linear random fields</p></a></li>
<li><a href='#condrmaxstab'>
<p>Conditional simulation of max-stable processes</p></a></li>
<li><a href='#covariance'><p>Defines and computes covariance functions</p></a></li>
<li><a href='#cv'><p>Estimates the penalty coefficient from the cross-validation</p>
criterion</a></li>
<li><a href='#DIC'><p>Deviance Information Criterion</p></a></li>
<li><a href='#distance'><p>Computes distance between pairs of locations</p></a></li>
<li><a href='#extcoeff'><p>Plots the extremal coefficient</p></a></li>
<li><a href='#fitcopula'>
<p>Fit a copula-based model to spatial extremes</p></a></li>
<li><a href='#fitcovariance'><p>Estimates the covariance function for the Schlather's model</p></a></li>
<li><a href='#fitcovmat'><p>Estimates the covariance matrix for the Smith's model</p></a></li>
<li><a href='#fitextcoeff'><p>Non parametric estimators of the extremal coefficient function</p></a></li>
<li><a href='#fitmaxstab'><p>Fits a max-stable process to data</p></a></li>
<li><a href='#fitspatgev'><p>MLE for a spatial GEV model</p></a></li>
<li><a href='#fmadogram'><p>Computes the F-madogram</p></a></li>
<li><a href='#gcv'><p>Estimates the penalty coefficient from the generalized</p>
cross-validation criterion</a></li>
<li><a href='#Generalized Extreme Value Distribution'><p>The Generalized Extreme Value Distribution</p></a></li>
<li><a href='#Generalized Pareto Distribution'><p>The Generalized Pareto Distribution</p></a></li>
<li><a href='#gev2frech'><p>Transforms GEV data to unit Frechet ones and vice versa</p></a></li>
<li><a href='#Internal functions and methods'><p>Internal functions and methods for the maxstable package.</p></a></li>
<li><a href='#kriging'>
<p>Simple kriging interpolation</p></a></li>
<li><a href='#latent'>
<p>Bayesian hierarchical models for spatial extremes</p></a></li>
<li><a href='#lmadogram'><p>Computes the lambda-madogram</p></a></li>
<li><a href='#logLik'><p>Extracts Log-Likelihood</p></a></li>
<li><a href='#lsmaxstab'><p>Estimates the spatial dependence parameter of a max-stable</p>
process by minimizing least squares.</a></li>
<li><a href='#madogram'><p>Computes madograms</p></a></li>
<li><a href='#map'><p>Produces a 2D map from a fitted max-stable process</p></a></li>
<li><a href='#map.latent'><p>Two dimensional map from a Bayesian hierarchical model</p></a></li>
<li><a href='#margin fits'><p>Fits univariate extreme value distributions to data</p></a></li>
<li><a href='#modeldef'><p>Define a model for the spatial behaviour of the GEV parameters</p></a></li>
<li><a href='#plot.copula'>
<p>Model checking of a fitted copula based model.</p></a></li>
<li><a href='#plot.maxstab'>
<p>Model checking of a fitted max-stable model</p></a></li>
<li><a href='#predict'><p>Prediction of the marginal parameters for various models</p></a></li>
<li><a href='#print'><p>Printing objects of classes defined in the SpatialExtreme packages</p></a></li>
<li><a href='#profile'><p>Method for profiling fitted max-stable objects</p></a></li>
<li><a href='#profile2d'><p>Method for profiling (in 2d) fitted max-stable objects</p></a></li>
<li><a href='#qqextcoeff'><p>QQ-plot for the extremal coefficient</p></a></li>
<li><a href='#qqgev'><p>QQ-plot for the GEV parameters</p></a></li>
<li><a href='#rainfall'><p>Summer annual maxima precipitation in Switzerland</p></a></li>
<li><a href='#rb'><p>Creates a model using penalized smoothing splines</p></a></li>
<li><a href='#rbpspline'><p>Fits a penalized spline with radial basis functions to data</p></a></li>
<li><a href='#rcopula'><p>Simulation from copula based models with unit Frechet margins</p></a></li>
<li><a href='#rgp'>
<p>Gaussian Random Fields Simulation</p></a></li>
<li><a href='#rmaxlin'><p>Simulation from max-linear models</p></a></li>
<li><a href='#rmaxstab'><p>Simulation of Max-Stable Random Fields</p></a></li>
<li><a href='#SpatialExtremes'><p>Analysis of Spatial Extremes</p></a></li>
<li><a href='#swiss'>
<p>Map of the Switzerland.</p></a></li>
<li><a href='#swissalt'><p>Elevation in Switzerland</p></a></li>
<li><a href='#symbolplot'><p>Detecting spatial trends graphically</p></a></li>
<li><a href='#TIC'><p>Takeuchi's information criterion</p></a></li>
<li><a href='#USHCNTemp'><p>Summer/Winter annual maxima/minima temperature in continental US.</p></a></li>
<li><a href='#variogram'>
<p>Empirical variogram</p></a></li>
<li><a href='#vdc'>
<p>Van der Corput Sequence</p></a></li>
<li><a href='#wind'><p>Annual maxima wind gusts in the Netherlands.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Modelling Spatial Extremes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.8.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>maps, fields</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the statistical modelling of spatial extremes using max-stable processes, copula or Bayesian hierarchical models. More precisely, this package allows (conditional) simulations from various parametric max-stable models, analysis of the extremal spatial dependence, the fitting of such processes using composite likelihoods or least square (simple max-stable processes only), model checking and selection and prediction. Other approaches (although not completely in agreement with the extreme value theory) are available such as the use of (spatial) copula and Bayesian hierarchical models assuming the so-called conditional assumptions. The latter approaches is handled through an (efficient) Gibbs sampler. Some key references: Davison et al. (2012) &lt;<a href="https://doi.org/10.1214%2F11-STS376">doi:10.1214/11-STS376</a>&gt;, Padoan et al. (2010) &lt;<a href="https://doi.org/10.1198%2Fjasa.2009.tm08577">doi:10.1198/jasa.2009.tm08577</a>&gt;, Dombry et al. (2013) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fass067">doi:10.1093/biomet/ass067</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://spatialextremes.r-forge.r-project.org/">http://spatialextremes.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-19 07:58:44 UTC; mathieu</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathieu Ribatet [aut, cre],
  Richard Singleton [ctb],
  R Core team [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mathieu Ribatet &lt;mathieu.ribatet@ec-nantes.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-19 10:22:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova'>Anova Tables</h2><span id='topic+anova'></span><span id='topic+anova.maxstab'></span><span id='topic+anova.spatgev'></span>

<h3>Description</h3>

<p>Computes analysis of deviance for objects of class 'maxstab' or 'spatgev'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxstab'
anova(object, object2, method = "RJ", square = "chol", ...)
## S3 method for class 'spatgev'
anova(object, object2, method = "RJ", square = "chol", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_+3A_object">object</code>, <code id="anova_+3A_object2">object2</code></td>
<td>
<p>Two objects of class 'maxstab' or 'spatgev'.</p>
</td></tr>
<tr><td><code id="anova_+3A_method">method</code></td>
<td>
<p>Character string. Must be one of &quot;CB&quot; or &quot;RJ&quot; for the
Chandler and Bate or the Rotnitzky and Jewell approaches
respectively. See function
<code><a href="#topic+profile.maxstab">profile</a></code>.</p>
</td></tr>
<tr><td><code id="anova_+3A_square">square</code></td>
<td>
<p>The choice for the matrix square root. This is only
useful for the 'CB' method. Must be one of 'chol' (Cholesky) or
'svd' (Singular Value Decomposition).</p>
</td></tr>
<tr><td><code id="anova_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="#topic+anova">anova</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As &rdquo;maxstab&rdquo; objects are fitted using pairwise likelihood, the model
is misspecified. As a consequence, the likelihood ratio statistic is
no longer <code class="reqn">\chi^2</code> distributed. To compute the anova
table, we use the methodology proposed by Rotnitzky and Jewell to
adjust the distribution of the likelihood ratio statistic.
</p>


<h3>Value</h3>

<p>This function returns an object of class anova. These objects
represent analysis-of-deviance tables. 
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Chandler, R. E. and Bate, S. (2007) Inference for clustered data using
the independence loglikelihood <em>Biometrika</em>, <b>94</b>,
167&ndash;183.
</p>
<p>Rotnitzky, A. and Jewell, N. (1990) Hypothesis testing of regression
parameters in semiparametric generalized linear models for cluster
correlated data. <em>Biometrika</em> <b>77</b>, 485&ndash;497.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+fitspatgev">fitspatgev</a></code>,
<code><a href="#topic+profile.maxstab">profile</a></code>, <code><a href="#topic+TIC">TIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinates of each location
n.site &lt;- 30
locations &lt;- matrix(rnorm(2*n.site, sd = sqrt(.2)), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 100, cov12 =
25, cov22 = 220)

##Now define the spatial model for the GEV parameters
param.loc &lt;- -10 + 2 * locations[,2]
param.scale &lt;- 5 + 2 * locations[,1] + locations[,2]^2
param.shape &lt;- rep(0.2, n.site)

##Transform the unit Frechet margins to GEV 
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

##Define three models for the GEV margins to be fitted
loc.form &lt;- loc ~ lat
scale.form &lt;- scale ~ lon + I(lat^2)
shape.form &lt;- shape ~ lon

M0 &lt;- fitspatgev(data, locations, loc.form, scale.form, shape.form)
M1 &lt;- fitspatgev(data, locations, loc.form, scale.form, shape.form,
shapeCoeff2 = 0)

##Model selection
anova(M0, M1)
anova(M0, M1, method = "CB", square = "svd")
</code></pre>

<hr>
<h2 id='concprob'>Pairwise empirical and extremal concurrence probabilities</h2><span id='topic+concprob'></span>

<h3>Description</h3>

<p>This function computes the pairwise empirical or the pairwise extremal
concurrence probability estimates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>concprob(data, coord, fitted, n.bins, add = FALSE, xlim = c(0,
max(dist)), ylim = c(min(0, concProb), max(1, concProb)), col = 1:2,
which = "kendall", xlab, ylab, block.size = floor(nrow(data)^(1/3)),
plot = TRUE, compute.std.err = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concprob_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="concprob_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="concprob_+3A_fitted">fitted</code></td>
<td>
<p>An object of class maxstab - usually the output of the
<code><a href="#topic+fitmaxstab">fitmaxstab</a></code> function. May be missing.</p>
</td></tr>
<tr><td><code id="concprob_+3A_n.bins">n.bins</code></td>
<td>
<p>The number of bins to be used. If missing, pairwise
F-madogram estimates will be computed.</p>
</td></tr>
<tr><td><code id="concprob_+3A_xlim">xlim</code>, <code id="concprob_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 specifying the x/y coordinate
ranges.</p>
</td></tr>
<tr><td><code id="concprob_+3A_col">col</code></td>
<td>
<p>The colors used for the points and optionnaly the fitted
curve.</p>
</td></tr>
<tr><td><code id="concprob_+3A_which">which</code></td>
<td>
<p>A character string specifying which estimator should be
used. Should be one of &quot;emp&quot; (empirical), &quot;boot&quot; (bootstrap version)
and &quot;kendall&quot; (kendall based).</p>
</td></tr>
<tr><td><code id="concprob_+3A_xlab">xlab</code>, <code id="concprob_+3A_ylab">ylab</code></td>
<td>
<p>The labels for the x/y-axis (may be missing).</p>
</td></tr>
<tr><td><code id="concprob_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plot is added to the current
figure; otherwhise (default) a new plot is computed.</p>
</td></tr>
<tr><td><code id="concprob_+3A_block.size">block.size</code></td>
<td>
<p>Integer specifying the block size for the empirical
and bootstrap estimator.</p>
</td></tr>
<tr><td><code id="concprob_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) a plot is produced.</p>
</td></tr>
<tr><td><code id="concprob_+3A_compute.std.err">compute.std.err</code></td>
<td>
<p>Logical. If <code>TRUE</code>, standard errors are
estimated using a jackknife procedure. It is currently only
available for the Kendall estimator.</p>
</td></tr>
<tr><td><code id="concprob_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns invisibly a matrix containing the pairwise
distances and the concurrence probability estimates.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Dombry, C., Ribatet, M. and Stoev, S. (2017) Probabilities of
concurrent extremes. <em>To appear in JASA</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmadogram">fmadogram</a></code>, <code><a href="#topic+lmadogram">lmadogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 25
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
n.obs &lt;- 100
data &lt;- rmaxstab(n.obs, locations, cov.mod = "whitmat", nugget = 0, range = 1,
smooth = 1.75)

##Compute the F-madogram
concprob(data, locations)

##Compare the F-madogram with a fitted max-stable process
fitted &lt;- fitmaxstab(data, locations, "whitmat", nugget = 0)
concprob(fitted = fitted)
</code></pre>

<hr>
<h2 id='concurrencemap'>Maps of concurrence probabilities/expected concurrence cell area</h2><span id='topic+concurrencemap'></span>

<h3>Description</h3>

<p>This function produces maps for concurrence probabilities or expected
concurrence cell areas.</p>


<h3>Usage</h3>

<pre><code class='language-R'>concurrencemap(data, coord, which = "kendall", type = "cell", n.grid =
100, col = cm.colors(64), plot = TRUE, plot.border = NULL,
compute.std.err = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concurrencemap_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_which">which</code></td>
<td>
<p>A character string specifying which estimator should be
used. Should be one of &quot;emp&quot; (empirical), &quot;boot&quot; (bootstrap version)
and &quot;kendall&quot; (kendall based).</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_type">type</code></td>
<td>
<p>Either &quot;cell&quot; for cell areas or a integer between 1 and
the number of locations specifying which site should be used as
reference location&mdash;see Details.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_n.grid">n.grid</code></td>
<td>
<p>Integer specifying the size of the prediction grid.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_col">col</code></td>
<td>
<p>The colors used to produce the map.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a map is produced;
otherwise results are invisibly returned.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_plot.border">plot.border</code></td>
<td>
<p>The name of an R function that can be used to plot
the border of the study region. If <code>NULL</code>, no border are
plotted.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_compute.std.err">compute.std.err</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a map of standard
errors is also produced. It is currently only available for
concurrence probability maps.</p>
</td></tr>
<tr><td><code id="concurrencemap_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the
<code><a href="Matrix.html#topic+image">image</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns invisibly a list with the x and y coordinates
and the corresponding values for the estimated concurrence
probabilities or expected concurrence cell area.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Dombry, C., Ribatet, M. and Stoev, S. (2015) Probabilities of
concurrent extremes. <em>Submitted</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concprob">concprob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##require(maps) ## &lt;&lt;-- to plot US borders
data(USHCNTemp)
coord &lt;- as.matrix(metadata[,2:3])

## Subset the station to have a fast example
n.site &lt;- 30
chosen.site &lt;- sample(nrow(coord), n.site)
coord &lt;- coord[chosen.site,]
maxima.summer &lt;- maxima.summer[,chosen.site]

## Define a function to plot the border
border &lt;- function(add = FALSE) maps::map("usa", add = add)

par(mar = rep(0, 4))
## Produce a pairwise concurrence probability map w.r.t. station number 15
concurrencemap(maxima.summer, coord, type = 15, plot.border = border,
 compute.std.err = TRUE)

## Produce the expected concurrence cell area
concurrencemap(maxima.summer, coord, plot.border = border)
</code></pre>

<hr>
<h2 id='condmap'>Produces a conditional 2D map from a fitted max-stable process</h2><span id='topic+condmap'></span>

<h3>Description</h3>

<p>Produces a conditional 2D map from a fitted max-stable process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condmap(fitted, fix.coord, x, y, covariates = NULL, ret.per1 = 100,
ret.per2 = ret.per1, col = terrain.colors(64), plot.contour = TRUE,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condmap_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>maxstab</code>. Most often, it will
be the output of the function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="condmap_+3A_fix.coord">fix.coord</code></td>
<td>
<p>The spatial coordinates of the location from which
the conditional quantile is computed.</p>
</td></tr>
<tr><td><code id="condmap_+3A_x">x</code>, <code id="condmap_+3A_y">y</code></td>
<td>
<p>Numeric vector defining the grid at which the levels are
computed.</p>
</td></tr>
<tr><td><code id="condmap_+3A_covariates">covariates</code></td>
<td>
<p>An array specifying the covariates at each grid
point defined by <code>x</code> and <code>y</code>. If <code>NULL</code>, no covariate
is needed. See <code><a href="#topic+map">map</a></code> to see how to build it.</p>
</td></tr>
<tr><td><code id="condmap_+3A_ret.per1">ret.per1</code>, <code id="condmap_+3A_ret.per2">ret.per2</code></td>
<td>
<p>Numerics giving the return period for which
the quantile map is plotted. See details.</p>
</td></tr>
<tr><td><code id="condmap_+3A_col">col</code></td>
<td>
<p>A list of colors such as that generated by 'rainbow',
'heat.colors', 'topo.colors', 'terrain.colors' or similar
functions.</p>
</td></tr>
<tr><td><code id="condmap_+3A_plot.contour">plot.contour</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), contour lines
are added to the plot.</p>
</td></tr>
<tr><td><code id="condmap_+3A_...">...</code></td>
<td>
<p>Several arguments to be passed to the <code><a href="Matrix.html#topic+image">image</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function solves the following equation:
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left[Z(x_2) &gt; z_2 | Z(x_1) &gt; z_1 \right] =
    \frac{1}{T_2}</code>
</p>

<p>where <code class="reqn">z_1 = -1 / \log(1 - 1/T_1)</code>.
</p>
<p>In other words, it computes, given that at location <code class="reqn">x_1</code> we
exceed the level <code class="reqn">z_1</code>, the levels which is expected to be
exceeded in average every <code class="reqn">T_2</code> year.
</p>


<h3>Value</h3>

<p>A plot. Additionally, a list with the details for plotting the map is
returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+map">map</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>,
<code><a href="stats.html#topic+heatmap">heatmap</a></code>, <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>,
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>,
<code><a href="grDevices.html#topic+rainbow">rainbow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinate of each location
n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "whitmat", nugget = 0, range =
2, smooth = 1)

##Now define the spatial model for the GEV parameters
param.loc &lt;- -10 - 4 * locations[,1] + locations[,2]^2
param.scale &lt;- 5 + locations[,2] + locations[,1]^2 / 10
param.shape &lt;- rep(.2, n.site)

##Transform the unit Frechet margins to GEV
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

##Define a model for the GEV margins to be fitted
##shape ~ 1 stands for the GEV shape parameter is constant
##over the region
loc.form &lt;- loc ~ lon + I(lat^2)
scale.form &lt;- scale ~ lat + I(lon^2)
shape.form &lt;- shape ~ 1

##  1- Fit a max-stable process
fitted &lt;- fitmaxstab(data, locations, "whitmat", loc.form, scale.form,
                     shape.form, nugget = 0)

cond.coord &lt;- c(5.1, 5.1)
condmap(fitted, cond.coord, seq(0, 10, length = 25), seq(0,10, length
 =25), ret.per1 = 100, ret.per2 = 1.5)
points(t(cond.coord), pch = "*", col = 2, cex = 2)
</code></pre>

<hr>
<h2 id='condrgp'>
Conditional simulation of Gaussian random fields
</h2><span id='topic+condrgp'></span>

<h3>Description</h3>

<p>This function generates conditional simulation of Gaussian random fields
from the simple kriging predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condrgp(n, coord, data.coord, data, cov.mod = "powexp", mean = 0, sill =
1, range = 1, smooth = 1, grid = FALSE, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condrgp_+3A_n">n</code></td>
<td>
<p>Integer. The number of conditional simulations.</p>
</td></tr>
<tr><td><code id="condrgp_+3A_coord">coord</code></td>
<td>
<p>A numeric vector or matrix specifying the coordinates
where the process has to be generated. If <code>coord</code> is a matrix,
each row specifies one location.</p>
</td></tr>
<tr><td><code id="condrgp_+3A_data.coord">data.coord</code></td>
<td>
<p>A numeric vector or matrix specifying the
coordinates where the process is conditioned.</p>
</td></tr>
<tr><td><code id="condrgp_+3A_data">data</code></td>
<td>
<p>A numeric vector giving the conditioning observations.</p>
</td></tr>
<tr><td><code id="condrgp_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string specifying the covariance function
family. Must be one of &quot;whitmat&quot;, &quot;powexp&quot;, &quot;cauchy&quot; or &quot;bessel&quot; for
the Whittle-Mater, the powered exponential, the Cauchy or Bessel
covariance families.</p>
</td></tr>
<tr><td><code id="condrgp_+3A_mean">mean</code>, <code id="condrgp_+3A_sill">sill</code>, <code id="condrgp_+3A_range">range</code>, <code id="condrgp_+3A_smooth">smooth</code></td>
<td>
<p>The mean, sill, range and
smooth of the Gaussian process.</p>
</td></tr>
<tr><td><code id="condrgp_+3A_grid">grid</code></td>
<td>
<p>Logical. Does <code>coord</code> specifies a grid?</p>
</td></tr>
<tr><td><code id="condrgp_+3A_control">control</code></td>
<td>
<p>A named list passing options to the simulation method
of Gaussian processes &mdash; see <code><a href="#topic+rgp">rgp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>coord</code></td>
<td>
<p>The coordinates at which the process was simulated;</p>
</td></tr>
<tr><td><code>cond.sim</code></td>
<td>
<p>The simulated process;</p>
</td></tr>
<tr><td><code>data.coord</code></td>
<td>
<p>The coordinates of the conditioning locations;</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The conditioning observations;</p>
</td></tr>
<tr><td><code>cov.mod</code></td>
<td>
<p>The covariance function family;</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>Does <code>coord</code> specifies a grid?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+kriging">kriging</a></code>, <code><a href="#topic+rgp">rgp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Several conditional simulations
n.site &lt;- 50
n.sim &lt;- 512

x.obs &lt;- runif(n.site, -100, 100)
x.sim &lt;- seq(-100, 100, length = n.sim)

data &lt;- rgp(1, x.obs, "whitmat", sill = 1, range = 10, smooth = 0.75)

sim &lt;- condrgp(5, x.sim, x.obs, data, "whitmat", sill = 1, range =
10, smooth = 0.75)

matplot(x.sim, t(sim$cond.sim),  type = "l", lty = 1, xlab = "x", ylab =
expression(Y[cond](x)))
points(x.obs, data, pch = 21, bg = 1)
title("Five conditional simulations")

## Comparison between one conditional simulations and the kriging
## predictor on a grid
x.obs &lt;- matrix(runif(2 * n.site, -100, 100), ncol = 2)
x &lt;- y &lt;- seq(-100, 100, length = 100)
x.sim &lt;- cbind(x, y)

data &lt;- rgp(1, x.obs, "whitmat", sill = 1, range = 50, smooth = 0.75)

krig &lt;- kriging(data, x.obs, x.sim, "whitmat", sill = 1, range = 50,
smooth = 0.75, grid = TRUE)
sim &lt;- condrgp(1, x.sim, x.obs, data, "whitmat", sill = 1, range = 50,
smooth = 0.75, grid = TRUE)

z.lim &lt;- range(c(sim$cond.sim, data, krig$krig.est))
breaks &lt;- seq(z.lim[1], z.lim[2], length = 65)
col &lt;- heat.colors(64)
idx &lt;- as.numeric(cut(data, breaks))

op &lt;- par(mfrow = c(1,2))
image(x, y, krig$krig.est, col = col, breaks = breaks)
points(x.obs, bg = col[idx], pch = 21)
title("Kriging predictor")
image(x, y, sim$cond.sim, col = col, breaks = breaks)
points(x.obs, bg = col[idx], pch = 21)
title("Conditional simulation")
## Note how the background colors of the above points matches the ones
## returned by the image function
par(op)
</code></pre>

<hr>
<h2 id='condrmaxlin'>
Conditional simulation of max-linear random fields
</h2><span id='topic+condrmaxlin'></span>

<h3>Description</h3>

<p>This function generates (approximate) conditional simulation of unit
Frechet max-linear random fields. It can be used to get approximate
conditional simulation for max-stable processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condrmaxlin(n, coord, data.coord, data, cov.mod = "gauss", ..., grid =
FALSE, p = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condrmaxlin_+3A_n">n</code></td>
<td>
<p>Integer. The number of conditional simulations.</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_coord">coord</code></td>
<td>
<p>A numeric vector or matrix specifying the coordinates
where the process has to be generated. If <code>coord</code> is a matrix,
each row specifies one locations.</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_data.coord">data.coord</code></td>
<td>
<p>A numeric vector or matrix specifying the
coordinates where the process is conditioned.</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_data">data</code></td>
<td>
<p>A numeric vector giving the conditioning observations.</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string specifying the max-stable model. See
section Details.</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_...">...</code></td>
<td>
<p>The parameters of the max-stable model. See section
Details.</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_grid">grid</code></td>
<td>
<p>Logical. Does <code>coord</code> defines a grid?</p>
</td></tr>
<tr><td><code id="condrmaxlin_+3A_p">p</code></td>
<td>
<p>An integer. The number of unit Frechet random variables used
in the max-linear approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any unit Frechet max-stable processes <code class="reqn">\{Z(x)\}</code> can be
approximated by a unit Frechet max-linear process, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">Z(x) \approx \max_{j=1, \ldots, p} f_j(x) Z_j,</code>
</p>

<p>where <code class="reqn">f_j</code> are non-negative deterministic functions,
<code class="reqn">p</code> is a sufficiently large integer and <code class="reqn">Z_j</code> are
independent unit Frechet random variables. Note that to ensure unit
Frechet margins, the following condition has to be satisfied
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1, \ldots, p} f_j(x) = 1,</code>
</p>

<p>for all <code class="reqn">x</code>.
</p>
<p>Currently only the discretized Smith model is implemented for which
<code class="reqn">f_j(x) = c(p) \varphi(x - u_j ; \Sigma)</code> where <code class="reqn">\varphi(\cdot; \Sigma)</code>
is the zero mean (multivariate) normal density with covariance matrix
<code class="reqn">\Sigma</code>, <code class="reqn">u_j</code> is a sequence of deterministic
points appropriately chosen and <code class="reqn">c(p)</code> is a constant
ensuring unit Frechet margins.
</p>


<h3>Value</h3>

<p>A matrix containing observations from the required max-stable
model. Each column represents one stations. If <code>grid = TRUE</code>, the
function returns an array of dimension nrow(coord) x nrow(coord) x n.
</p>


<h3>Warnings</h3>

<p>It may happen that some conditional observations are not honored
because the approximation of a max-stable process by a max-linear one
isn't accurate enough! Sometimes taking a larger <code>p</code> solves the
issue.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet
</p>


<h3>References</h3>

<p>Wang, Y. and Stoev, S. A. (2011) Conditional Sampling for Max-Stable
Random Fields. <em>Advances in Applied Probability</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmaxstab">rmaxstab</a></code>, <code><a href="#topic+condrmaxlin">condrmaxlin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One dimensional conditional simulations
n.cond.site &lt;- 10
cond.coord &lt;- runif(n.cond.site, -10, 10)
data &lt;- rmaxlin(1, cond.coord, var = 3, p = 10000)

x &lt;- seq(-10, 10, length = 250)
cond.sim &lt;- condrmaxlin(5, x, cond.coord, data, var = 3)

matplot(x, t(log(cond.sim)), type = "l", lty = 1, pch = 1)
points(cond.coord, log(data))

## Two dimensional conditional simulation
cond.coord &lt;- matrix(runif(2 * n.cond.site, -10, 10), ncol = 2)
data &lt;- rmaxstab(1, cond.coord, "gauss", cov11 = 4, cov12 = 0, cov22 = 4)

x &lt;- y &lt;- seq(-10, 10, length = 75)
cond.sim &lt;- condrmaxlin(4, cbind(x, y), cond.coord, data, cov11 = 4,
cov12 = 0, cov22 = 4, grid = TRUE, p = 2000)
## Note p is set to 2000 for CPU reasons but is likely to be too small

op &lt;- par(mfrow = c(2, 2), mar = rep(1, 4))
for (i in 1:4){
image(x, y, log(cond.sim[,,i]), col = heat.colors(64), xaxt = "n", yaxt
= "n", bty = "n")
contour(x, y, log(cond.sim[,,i]), add = TRUE)
text(cond.coord[,1], cond.coord[,2], round(log(data), 2), col = 3)
}
par(op)
</code></pre>

<hr>
<h2 id='condrmaxstab'>
Conditional simulation of max-stable processes
</h2><span id='topic+condrmaxstab'></span>

<h3>Description</h3>

<p>This function performs conditional simulation of various max-stable processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condrmaxstab(k = 1, coord, cond.coord, cond.data, cov.mod = "powexp",
..., do.sim = TRUE, thin = n.cond, burnin = 50, parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condrmaxstab_+3A_k">k</code></td>
<td>
<p>An integer. The number of conditional simulations to be generated.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_coord">coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of each
location. Each row corresponds to one location - if any.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_cond.coord">cond.coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of
each conditional location. Each row corresponds to one location - if
any.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_cond.data">cond.data</code></td>
<td>
<p>A vector that gives the conditional values at the
corresponding conditioning locations. Each row corresponds to one
location - if any.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string that gives the max-stable
model. This must be one of &quot;brown&quot; for the Brown-Resnick model, or
&quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot; and &quot;bessel&quot; for the Schlather model
with the given correlation family.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_...">...</code></td>
<td>
<p>The parameters of the max-stable model. See
<code><a href="#topic+rmaxstab">rmaxstab</a></code> for more details.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_do.sim">do.sim</code></td>
<td>
<p>A logical value. If <code>TRUE</code> (the default), the
conditional simulations are performed; otherwise only the simulated
random partitions, i.e., the hitting scenarios, are returned.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_thin">thin</code></td>
<td>
<p>A positive integer giving by which amount the generated Markov
chain should be thinned. This is only useful when the number of
conditioning locations is greater than 7.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_burnin">burnin</code></td>
<td>
<p>A positive integer giving the duration of the burnin
period of the Markov chain.</p>
</td></tr>
<tr><td><code id="condrmaxstab_+3A_parts">parts</code></td>
<td>
<p>A matrix giving the hitting scenarios. Each row
corresponds to one hitting scenarios. If missing then a Gibbs
sampler will  be used to generate such hitting scenarios.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm consists in three steps:
</p>

<ol>
<li><p> Draw a random partition <code class="reqn">\theta</code> from
</p>
<p style="text-align: center;"><code class="reqn">\Pr\{\theta = \tau \mid Z(x) = z\}</code>
</p>

</li>
<li><p> Given the random partition, draw the extremal functions from
</p>
<p style="text-align: center;"><code class="reqn">\Pr\{\varphi^+ \in \cdot \mid Z(x) = z, \theta =
      \tau\}</code>
</p>

</li>
<li><p> Independently, draw the sub-extremal functions, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\max_{i \ge 1} \varphi_i 1_{\{\varphi_i(x) &lt; z\}}</code>
</p>

</li></ol>

<p>The distribution in Step 1 is usually intractable and in such cases a
random scan Gibbs sampler will be used to sample from this
distribution.
</p>


<h3>Value</h3>

<p>This function returns a list whose components are
</p>
<table>
<tr><td><code>sim</code></td>
<td>
<p>The conditional simulations. Beware the first values
corresponds to the conditioning values.</p>
</td></tr>
<tr><td><code>sub.ext.fct</code></td>
<td>
<p>The values of the sub-extremal functions.</p>
</td></tr>
<tr><td><code>ext.fct</code></td>
<td>
<p>The values of the extremal functions.</p>
</td></tr>
<tr><td><code>timings</code></td>
<td>
<p>The timings in seconds for each step of the algorithm.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This function can be extremely time consuming when the number of
conditioning locations is large.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Dombry, C. and Eyi-Minko, F. (2012) Regular conditional distributions
of max infinitely divisible processes. <em>Submitted</em>.
</p>
<p>Dombry, C., Eyi-Minko, F. and Ribatet, M. (2012) Conditional
simulation of max-stable processes. To appear in <em>Biometrika</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rmaxstab">rmaxstab</a></code>, <code><a href="#topic+condrgp">condrgp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.sim &lt;- 50
n.cond &lt;- 5

range &lt;- 10
smooth &lt;- 1.5

n.site &lt;- 200
coord &lt;- seq(-5, 5, length = n.site)
cond.coord &lt;- seq(-4, 4, length = n.cond)
all.coord &lt;- c(cond.coord, coord)

all.cond.data &lt;- rmaxstab(1, all.coord, "powexp", nugget = 0, range = range,
                      smooth = smooth)
cond.data &lt;- all.cond.data[1:n.cond]

ans &lt;- condrmaxstab(n.sim, coord, cond.coord, cond.data, range = range,
                    smooth = smooth, cov.mod = "powexp")

idx &lt;- order(all.coord)
matplot(coord, t(log(ans$sim)), type = "l", col = "grey", lty = 1,
        xlab = expression(x), ylab = expression(Z(x)))
lines(all.coord[idx], log(all.cond.data)[idx])
points(cond.coord, log(cond.data), pch = 15, col = 2)
</code></pre>

<hr>
<h2 id='covariance'>Defines and computes covariance functions</h2><span id='topic+covariance'></span>

<h3>Description</h3>

<p>This function defines and computes several covariance
function either from a fitted &ldquo;max-stable&rdquo; model; either by
specifying directly the covariance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariance(fitted, nugget, sill, range, smooth, smooth2 = NULL, cov.mod =
"whitmat", plot = TRUE, dist, xlab, ylab, col = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariance_+3A_fitted">fitted</code></td>
<td>
<p>An object of class &ldquo;maxstab&rdquo;. Most often this will be
the output of the <code><a href="#topic+fitmaxstab">fitmaxstab</a></code> function. May be missing
if <code>sill</code>, <code>range</code>, <code>smooth</code> and <code>cov.mod</code> are
given.</p>
</td></tr>
<tr><td><code id="covariance_+3A_nugget">nugget</code>, <code id="covariance_+3A_sill">sill</code>, <code id="covariance_+3A_range">range</code>, <code id="covariance_+3A_smooth">smooth</code>, <code id="covariance_+3A_smooth2">smooth2</code></td>
<td>
<p>The nugget, sill, scale and smooth parameters
for the covariance function. May be missing if <code>fitted</code> is
given.</p>
</td></tr>
<tr><td><code id="covariance_+3A_cov.mod">cov.mod</code></td>
<td>
<p>Character string. The name of the covariance
model. Must be one of &quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot;, &quot;bessel&quot; or
&quot;caugen&quot; for the Whittle-Matern, Cauchy, Powered Exponential, Bessel
and Generalized Cauchy models. May be missing if <code>fitted</code> is
given.</p>
</td></tr>
<tr><td><code id="covariance_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) the covariance function
is plotted.</p>
</td></tr>
<tr><td><code id="covariance_+3A_dist">dist</code></td>
<td>
<p>A numeric vector corresponding to the distance at which
the covariance function should be evaluated. May be missing.</p>
</td></tr>
<tr><td><code id="covariance_+3A_xlab">xlab</code>, <code id="covariance_+3A_ylab">ylab</code></td>
<td>
<p>The x-axis and y-axis labels. May be missing.</p>
</td></tr>
<tr><td><code id="covariance_+3A_col">col</code></td>
<td>
<p>The color to be used for the plot.</p>
</td></tr>
<tr><td><code id="covariance_+3A_...">...</code></td>
<td>
<p>Several option to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, four covariance functions are defined: the Whittle-Matern,
powered exponential (also known as &quot;stable&quot;), Cauchy and Bessel
models. These covariance functions are defined as follows for <code class="reqn">h &gt;
    0</code>
</p>

<dl>
<dt>Whittle-Matern</dt><dd><p><code class="reqn">\gamma(h) = \sigma
	\frac{2^{1-\kappa}}{\Gamma(\kappa)} \left(\frac{h}{\lambda}
	\right)^{\kappa} K_{\kappa}\left(\frac{h}{\lambda} \right)</code></p>
</dd>
<dt>Powered Exponential</dt><dd><p><code class="reqn">\gamma(h) = \sigma \exp \left[-
	\left(\frac{h}{\lambda} \right)^{\kappa} \right]</code></p>
</dd>
<dt>Cauchy</dt><dd><p><code class="reqn">\gamma(h) = \sigma \left[1 + \left(\frac{h}{\lambda}
	\right)^2 \right]^{-\kappa}</code></p>
</dd>
<dt>Bessel</dt><dd><p><code class="reqn">\gamma(h) = \sigma \left(\frac{2
	  \lambda}{h}\right)^{\kappa} \Gamma(\kappa + 1)
	J_{\kappa}\left(\frac{h}{\lambda} \right)</code></p>
</dd>
<dt>Generalized Cauchy</dt><dd><p><code class="reqn">\gamma(h) = \sigma \left\{1 +
    \left(\frac{h}{\lambda} \right)^{\kappa_2} \right\}^{-\kappa /
    \kappa_2}</code></p>
</dd>
</dl>

<p>where <code class="reqn">\sigma</code>, <code class="reqn">\lambda</code> and
<code class="reqn">\kappa</code> are the sill, the range and shape parameters,
<code class="reqn">\Gamma</code> is the gamma function,
<code class="reqn">K_{\kappa}</code> and  <code class="reqn">J_\kappa</code> are both
modified Bessel functions of order <code class="reqn">\kappa</code>. In addition
a nugget effect can be set that is there is a jump at the origin,
i.e., <code class="reqn">\gamma(o) = \nu + \sigma</code>, where
<code class="reqn">\nu</code> is the nugget effect.
</p>


<h3>Value</h3>

<p>This function returns the covariance function. Eventually, if
<code>dist</code> is given, the covariance function is computed for each
distance given by <code>dist</code>. If <code>plot = TRUE</code>, the covariance
function is plotted.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1- Calling covariance using fixed covariance parameters
covariance(nugget = 0, sill = 1, range = 1, smooth = 0.5, cov.mod = "whitmat")
covariance(nugget = 0, sill = 0.5, range = 1, smooth = 0.5, cov.mod = "whitmat",
  dist = seq(0,5, 0.2), plot = FALSE)

## 2- Calling covariance from a fitted model
##Define the coordinate of each location
n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(30, locations, cov.mod = "whitmat", nugget = 0, range =
3, smooth = 1)

##Fit a max-stable model
fitted &lt;- fitmaxstab(data, locations, "whitmat", nugget = 0)
covariance(fitted, ylim = c(0, 1))
covariance(nugget = 0, sill = 1, range = 3, smooth = 1, cov.mod = "whitmat", add =
TRUE, col = 3)
title("Whittle-Matern covariance function")
legend("topright", c("Theo.", "Fitted"), lty = 1, col = c(3,1), inset =
.05)
</code></pre>

<hr>
<h2 id='cv'>Estimates the penalty coefficient from the cross-validation
criterion</h2><span id='topic+cv'></span>

<h3>Description</h3>

<p>Estimates the penalty coefficient from the cross-validation
criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(y, x, knots, degree, plot = TRUE, n.points = 150, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_y">y</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code id="cv_+3A_x">x</code></td>
<td>
<p>A vector/matrix giving the values of the predictor
variable(s). If <code>x</code> is a matrix, each row corresponds to one
observation.</p>
</td></tr>
<tr><td><code id="cv_+3A_knots">knots</code></td>
<td>
<p>A vector givint the coordinates of the knots.</p>
</td></tr>
<tr><td><code id="cv_+3A_degree">degree</code></td>
<td>
<p>The degree of the penalized smoothing spline.</p>
</td></tr>
<tr><td><code id="cv_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the evolution of the CV
score as the penalty increases is plotted.</p>
</td></tr>
<tr><td><code id="cv_+3A_n.points">n.points</code></td>
<td>
<p>A numeric giving the number of CV computations needed
to produce the plot.</p>
</td></tr>
<tr><td><code id="cv_+3A_...">...</code></td>
<td>
<p>Options to be passed to the <code><a href="stats.html#topic+nlm">nlm</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every linear smoother e.g. <code class="reqn">\hat{y} = S_\lambda y</code>, the cross-validation criterion consists in minimizing
the following quantity:
</p>
<p style="text-align: center;"><code class="reqn">CV(\lambda) = \sum_{i=1}^n \left(\frac{y_i - \hat{y}_i}{1 -
      S_{\lambda,ii}} \right)^2</code>
</p>

<p>where <code class="reqn">\lambda</code> is the penalty coefficient, <code class="reqn">n</code> the
number of observations and <code class="reqn">S_{\lambda,ii}</code> the
i-th diagonal element of the matrix <code class="reqn">S_\lambda</code>.
</p>


<h3>Value</h3>

<p>A list with components 'penalty', 'cv' and 'nlm.code' which give the
location of the minimum, the value of the cross-validation
criterion at that point and the code returned by the <code><a href="stats.html#topic+nlm">nlm</a></code>
function - useful to assess for convergence issues.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Ruppert, D. Wand, M.P. and Carrol, R.J. (2003) <em>Semiparametric
Regression</em> Cambridge Series in Statistical and Probabilistic
Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv">cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
x &lt;- runif(n)
fun &lt;- function(x) sin(3 * pi * x)
y &lt;- fun(x) + rnorm(n, 0, sqrt(0.4))
knots &lt;- quantile(x, prob = 1:(n/4) / (n/4 + 1))
cv(y, x, knots = knots, degree = 3)
</code></pre>

<hr>
<h2 id='DIC'>Deviance Information Criterion</h2><span id='topic+DIC'></span>

<h3>Description</h3>

<p>This function computes the Deviance Information Criterion (DIC), and
related quantities, which is
a hierarchical modeling generalization of the Akaike Information
Criterion. It is useful for Bayesian model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(object, ..., fun = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_object">object</code></td>
<td>
<p>An object of class <code>latent</code> &mdash; typically this will
be the output of <code><a href="#topic+latent">latent</a></code>.</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>Optional arguments. Not implemented.</p>
</td></tr>
<tr><td><code id="DIC_+3A_fun">fun</code></td>
<td>
<p>A chararcter string giving the name of the function to be
used to summarize the Markov chain. The default is to consider the
posterior mean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deviance is
</p>
<p style="text-align: center;"><code class="reqn">D(\theta) = -2 \log \pi(y \mid \theta),</code>
</p>

<p>where <code class="reqn">y</code> are the data, <code class="reqn">\theta</code> are the unknown
parameters of the models and <code class="reqn">\pi(y \mid \theta)</code> is
the likelihood function. Thus the expected deviance, a measure of how
well the model fits the data, is given by
</p>
<p style="text-align: center;"><code class="reqn">\overline{D} = {\rm E}_{\theta}[D(\theta)],</code>
</p>

<p>while the effective number of parameters is
</p>
<p style="text-align: center;"><code class="reqn">p_D = \overline{D} - D(\theta^*),</code>
</p>

<p>where <code class="reqn">\theta^*</code> is point estimate of the posterior
distribution, e.g., the posterior mean. Finally the DIC is given by
</p>
<p style="text-align: center;"><code class="reqn">{\rm DIC} = p_D + \overline{D}.</code>
</p>

<p>In accordance with the AIC, models with smaller DIC should be
preferred to models with larger DIC. Roughly speaking, differences of
more than 10 might rule out the model with the higher DIC, differences
between 5 and 10 are substantial.
</p>


<h3>Value</h3>

<p>A vector of length 3 that returns the DIC, effective number of
parameters <code>eNoP</code> and an estimate of the expected deviance
<code>Dbar</code>.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Spiegelhalter, D. J., Best, N. G., Carlin, B. P. and Van Der Linde,
A. (2002) Bayesian measures of model complexity and fit. <em>Journal
of the Royal Statistical Society: Series B</em> <b>64</b>, 583&ndash;639.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+AIC">AIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate realizations from the model
n.site &lt;- 15
n.obs &lt;- 35
coord &lt;- cbind(lon = runif(n.site, -10, 10), lat = runif(n.site, -10 , 10))

gp.loc &lt;- rgp(1, coord, "powexp", sill = 4, range = 20, smooth = 1)
gp.scale &lt;- rgp(1, coord, "powexp", sill = 0.4, range = 5, smooth = 1)
gp.shape &lt;- rgp(1, coord, "powexp", sill = 0.01, range = 10, smooth = 1)

locs &lt;- 26 + 0.5 * coord[,"lon"] + gp.loc
scales &lt;- 10 + 0.2 * coord[,"lat"] + gp.scale
shapes &lt;- 0.15 + gp.shape

data &lt;- matrix(NA, n.obs, n.site)
for (i in 1:n.site)
  data[,i] &lt;- rgev(n.obs, locs[i], scales[i], shapes[i])

loc.form &lt;- y ~ lon
scale.form &lt;- y ~ lat
shape.form &lt;- y ~ 1

hyper &lt;- list()
hyper$sills &lt;- list(loc = c(1,8), scale = c(1,1), shape = c(1,0.02))
hyper$ranges &lt;- list(loc = c(2,20), scale = c(1,5), shape = c(1, 10))
hyper$smooths &lt;- list(loc = c(1,1/3), scale = c(1,1/3), shape = c(1, 1/3))
hyper$betaMeans &lt;- list(loc = rep(0, 2), scale = c(9, 0), shape = 0)
hyper$betaIcov &lt;- list(loc = solve(diag(c(400, 100))),
                       scale = solve(diag(c(400, 100))),
                       shape = solve(diag(c(10), 1, 1)))

## We will use an exponential covariance function so the jump sizes for
## the shape parameter of the covariance function are null.
prop &lt;- list(gev = c(2.5, 1.5, 0.3), ranges = c(40, 20, 20), smooths = c(0,0,0))
start &lt;- list(sills = c(4, .36, 0.009), ranges = c(24, 17, 16), smooths
              = c(1, 1, 1),  beta = list(loc = c(26, 0), scale = c(10, 0),
                               shape = c(0.15)))

mc &lt;- latent(data, coord, loc.form = loc.form, scale.form = scale.form,
             shape.form = shape.form, hyper = hyper, prop = prop, start = start,
             n = 500)
DIC(mc)
</code></pre>

<hr>
<h2 id='distance'>Computes distance between pairs of locations</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>This function computes euclidean distance or distance
vector for each pair of  a set of spatial locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(coord, vec = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_coord">coord</code></td>
<td>
<p>A matrix representing the coordinates of each
locations. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="distance_+3A_vec">vec</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the euclidean distance
is computed. Otherwise, &ldquo;distance vectors&rdquo; are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>vec = FALSE</code>, this function returns a vector that gives the
euclidean distance for each pair of locations. Otherwise, this is a
matrix where each column correspond to one dimension -
i.e. longitude, latitude, ...
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coords &lt;- cbind(seq(0, 10, by = 2), seq(10, 0, by = -2))
distance(coords)
distance(coords, vec = TRUE)
</code></pre>

<hr>
<h2 id='extcoeff'>Plots the extremal coefficient</h2><span id='topic+extcoeff'></span>

<h3>Description</h3>

<p>Plots the extremal coefficient evolution as the coordinates evolves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extcoeff(fitted, cov.mod, param, n = 200, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extcoeff_+3A_fitted">fitted</code></td>
<td>
<p>A object of class &quot;<code>maxstab</code>&quot;. Most often, it will
be the output of the function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>. If missing,
then <code>cov.mod</code> and <code>param</code> should be supplied.</p>
</td></tr>
<tr><td><code id="extcoeff_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string corresponding the the covariance
model in the max-stable representation. Must be one of &quot;gauss&quot; for
the Smith's model; or &quot;whitmat&quot;, &quot;cauchy&quot; or &quot;powexp&quot; for
the Whittle-Matern, the Cauchy and the Powered Exponential
covariance family with the Schlather's model. May be missing if
<code>fitted</code> is given.</p>
</td></tr>
<tr><td><code id="extcoeff_+3A_param">param</code></td>
<td>
<p>Numeric vector of length 3. The parameters for the
Smith's or Schlather model - i.e. c(cov11, cov12, cov22) or c(nugget,
range, smooth). Please respect this order.</p>
</td></tr>
<tr><td><code id="extcoeff_+3A_n">n</code></td>
<td>
<p>Numeric. <code>n^2</code> corresponds to the total number of
estimated extremal coefficients for the contour plot.</p>
</td></tr>
<tr><td><code id="extcoeff_+3A_xlab">xlab</code>, <code id="extcoeff_+3A_ylab">ylab</code></td>
<td>
<p>The x-axis and y-axis labels. May be missing.</p>
</td></tr>
<tr><td><code id="extcoeff_+3A_...">...</code></td>
<td>
<p>Several options to be passed to the <code><a href="graphics.html#topic+contour">contour</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1- Random field generation
n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

data &lt;- rmaxstab(60, locations, cov.mod = "whitmat", nugget = 0, range =
3, smooth = 1)

## 2- Fit a max-stable processes
schlather &lt;- fitmaxstab(data, locations, "whitmat", nugget = 0)

## 3- Plot the extremal coefficient
extcoeff(schlather)
</code></pre>

<hr>
<h2 id='fitcopula'>
Fit a copula-based model to spatial extremes
</h2><span id='topic+fitcopula'></span>

<h3>Description</h3>

<p>This function fits various copula-based models to spatial extremes
data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitcopula(data, coord, copula = "gaussian", cov.mod = "whitmat",
loc.form, scale.form, shape.form, marg.cov = NULL, temp.cov = NULL,
temp.form.loc = NULL, temp.form.scale = NULL, temp.form.shape = NULL,
..., start, control = list(maxit = 10000), method = "Nelder", std.err =
TRUE, warn = TRUE, corr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitcopula_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_copula">copula</code></td>
<td>
<p>A character string. Must be one of &quot;gaussian&quot; and
&quot;student&quot; for a Gaussian and Student copula.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string corresponding to the correlation
function family used in the copula. Must be one of &quot;whitmat&quot;,
&quot;cauchy&quot;, &quot;powexp&quot;, &quot;bessel&quot; or &quot;caugen&quot; for the Whittle-Matern, the
Cauchy, the Powered Exponential, the Bessel and the Generalized
Cauchy correlation families.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_loc.form">loc.form</code>, <code id="fitcopula_+3A_scale.form">scale.form</code>, <code id="fitcopula_+3A_shape.form">shape.form</code></td>
<td>
<p>R formulas defining the
spatial linear model for the GEV parameters. May be missing. See
section Details of function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_marg.cov">marg.cov</code></td>
<td>
<p>Matrix with named columns giving additional covariates
for the GEV parameters. If <code>NULL</code>, no extra covariates are
used.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_temp.cov">temp.cov</code></td>
<td>
<p>Matrix with names columns giving additional *temporal*
covariates for the GEV parameters. If <code>NULL</code>, no temporal trend
are assume for the GEV parameters &mdash; see section Details of
function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_temp.form.loc">temp.form.loc</code>, <code id="fitcopula_+3A_temp.form.scale">temp.form.scale</code>, <code id="fitcopula_+3A_temp.form.shape">temp.form.shape</code></td>
<td>
<p>R formulas
defining the temporal trends for the GEV parameters. May be
missing. See section Details of function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_...">...</code></td>
<td>
<p>Several arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code>
functions.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the pairwise likelihood is to be minimized. If
<code>start</code> is omitted the routine attempts to find good starting
values - but might fail.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_control">control</code></td>
<td>
<p>A list giving the control parameters to be passed to
the <code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_method">method</code></td>
<td>
<p>The method used for the numerical optimisation
procedure. Must be one of <code>BFGS</code>, <code>Nelder-Mead</code>,
<code>CG</code>, <code>L-BFGS-B</code>, <code>SANN</code>, <code>nlm</code> or
<code>nlminb</code>. See <code><a href="stats.html#topic+optim">optim</a></code> for details. Please note that
passing <code>nlm</code> or <code>nlminb</code> will use the <code><a href="stats.html#topic+nlm">nlm</a></code>
or <code><a href="stats.html#topic+nlminb">nlminb</a></code> functions instead of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_std.err">std.err</code></td>
<td>
<p>Logical. Should the standard errors be computed ? The
default is to return the standard errors, i.e.,  <code>std.err =
      TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), users are warned if
the log-likelihood is infinite at starting values and/or problems
arised while computing the standard errors.</p>
</td></tr>
<tr><td><code id="fitcopula_+3A_corr">corr</code></td>
<td>
<p>Logical. If <code>TRUE</code> (non default), the asymptotic
correlation matrix is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a object of class <code>copula</code>.
</p>


<h3>Warning</h3>

<p>This function does not use max-stable copula and the use of non
max-stable copula for modelling spatial extreme is highly
questionable. This function was mainly implemented for educational
purposes and <b>not</b> for concrete modelling purposes. 
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet
</p>


<h3>References</h3>

<p>Davison, A.C., Padoan, S.A., Ribatet, M. (2010) Statistical Modelling
of Spatial Extremes. <em>Submitted to Statistical Science</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+latent">latent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.site &lt;- 30
n.obs &lt;- 50

coord &lt;- matrix(runif(2 * n.site, -10, 10), ncol = 2)
colnames(coord) &lt;- c("lon", "lat")

## Generate data from a Gaussian copula model
data &lt;- rcopula(n.obs, coord, "gaussian", "powexp", nugget = 0, range = 4, smooth = 1.2)

## Transform the margins to GEV
locs &lt;- -5 + coord[,"lon"] / 10
scales &lt;- 10 + coord[,"lat"] / 2
shapes &lt;- rep(0.2, n.site)

for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], locs[i], scales[i], shapes[i])

## Fit a Gaussian copula model

## 1. Define trend surfaces
loc.form &lt;- y ~ lon
scale.form &lt;- y ~ lat
shape.form &lt;- y ~ 1

## 2. Fit
M0 &lt;- fitcopula(data, coord, "gaussian", "powexp", loc.form, scale.form,
                shape.form, nugget = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitcovariance'>Estimates the covariance function for the Schlather's model</h2><span id='topic+fitcovariance'></span>

<h3>Description</h3>

<p>Estimates the covariance function for the Schlather's model using
non-parametric estimates of the pairwise extremal coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitcovariance(data, coord, cov.mod, marge = "emp", control = list(),
..., start, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitcovariance_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string corresponding the the covariance
model in the Schlather's model. Must be one of &quot;whitmat&quot;, &quot;cauchy&quot;,
&quot;powexp&quot;, &quot;bessel&quot; or &quot;caugen&quot; for the Whittle-Matern, the Cauchy,
the Powered Exponential, the Bessel and the Generalized Cauchy
correlation families.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_marge">marge</code></td>
<td>
<p>Character string specifying how margins are transformed
to unit Frechet. Must be one of &quot;emp&quot;, &quot;frech&quot; or &quot;mle&quot; - see
function <code><a href="#topic+fitextcoeff">fitextcoeff</a></code>.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_control">control</code></td>
<td>
<p>The control arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the <code><a href="stats.html#topic+optim">optim</a></code>
function.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the weighted sum of square is to be
minimized. If <code>start</code> is omitted the routine attempts to find
good starting values.</p>
</td></tr>
<tr><td><code id="fitcovariance_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should weighted least squares be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitting procedure is based on weighted least squares. More
precisely, the fitting criteria is to minimize:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i,j} \left(\frac{\tilde{\theta}_{i,j} -
      \hat{\theta}_{i,j}}{s_{i,j}}\right)^2</code>
</p>

<p>where <code class="reqn">\tilde{\theta}_{i,j}</code> is a non
parametric estimate of the extremal coefficient related to location
<code>i</code> and <code>j</code>, <code class="reqn">\hat{\theta}_{i,j}</code> is
the fitted extremal coefficient derived from the Schlather's model and
<code class="reqn">s_{i,j}</code> are the standard errors related to the
estimates <code class="reqn">\tilde{\theta}_{i,j}</code>.
</p>


<h3>Value</h3>

<p>An object of class maxstab.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitcovmat">fitcovmat</a></code>, <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>,
<code><a href="#topic+fitextcoeff">fitextcoeff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 50
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulating a max-stable process using RandomFields
##This is the Schlather's approach
data &lt;- rmaxstab(50, locations, cov.mod = "whitmat", nugget = 0, range =
30, smooth = 1)

fitcovariance(data, locations, "whitmat")
</code></pre>

<hr>
<h2 id='fitcovmat'>Estimates the covariance matrix for the Smith's model</h2><span id='topic+fitcovmat'></span>

<h3>Description</h3>

<p>Estimates the covariance matrix for the Smith's model using
non-parametric estimates of the pairwise extremal coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitcovmat(data, coord, marge = "emp", iso = FALSE, control = list(),
..., start, weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitcovmat_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_marge">marge</code></td>
<td>
<p>Character string specifying how margins are transformed
to unit Frechet. Must be one of &quot;emp&quot;, &quot;frech&quot; or &quot;mle&quot; - see
function <code><a href="#topic+fitextcoeff">fitextcoeff</a></code>.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_iso">iso</code></td>
<td>
<p>Logical. If <code>TRUE</code>, isotropy is supposed. Otherwise
(default), anisotropy is allowed.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_control">control</code></td>
<td>
<p>The control arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the <code><a href="stats.html#topic+optim">optim</a></code>
function.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the weighted sum of square is to be
minimized. If <code>start</code> is omitted the routine attempts to find
good starting values.</p>
</td></tr>
<tr><td><code id="fitcovmat_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should weighted least squares be used?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitting procedure is based on weighted least squares. More
precisely, the fitting criteria is to minimize:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i,j} \left(\frac{\tilde{\theta}_{i,j} -
      \hat{\theta}_{i,j}}{s_{i,j}}\right)^2</code>
</p>

<p>where <code class="reqn">\tilde{\theta}_{i,j}</code> is a non
parametric estimate of the extremal coefficient related to location
<code>i</code> and <code>j</code>, <code class="reqn">\hat{\theta}_{i,j}</code> is
the fitted extremal coefficient derived from the Smith's model and
<code class="reqn">s_{i,j}</code> are the standard errors related to the
estimates <code class="reqn">\tilde{\theta}_{i,j}</code>.
</p>


<h3>Value</h3>

<p>An object of class maxstab.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitcovariance">fitcovariance</a></code>, <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>,
<code><a href="#topic+fitextcoeff">fitextcoeff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 50
n.obs &lt;- 100
locations &lt;- matrix(runif(2*n.site, 0, 40), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

## Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 200, cov12 =
0, cov22 = 200)

fitcovmat(data, locations)

##Force an isotropic model
fitcovmat(data, locations, iso = TRUE)
</code></pre>

<hr>
<h2 id='fitextcoeff'>Non parametric estimators of the extremal coefficient function</h2><span id='topic+fitextcoeff'></span>

<h3>Description</h3>

<p>Estimates non parametrically the extremal coefficient
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitextcoeff(data, coord, ..., estim = "ST", marge = "emp", prob = 0,
plot = TRUE, loess = TRUE, method = "BFGS", std.err = TRUE, xlab,
ylab, angles = NULL, identify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitextcoeff_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_estim">estim</code></td>
<td>
<p>Character string specifying the estimator to be
used. Must be one of &quot;ST&quot; (Schlather and Tawn) or &quot;Smith&quot;.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_marge">marge</code></td>
<td>
<p>Character string specifying how margins are transformed
to unit Frechet. Must be one of &quot;emp&quot;, &quot;mle&quot; or &quot;none&quot; - see
Details</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_prob">prob</code></td>
<td>
<p>The probability related to the threshold. Only useful with
the <code>ST</code> estimator.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the extremal
coefficient function is plotted</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_loess">loess</code></td>
<td>
<p>If <code>TRUE</code> (default), a local polynomial curve is
plotted - see function <code><a href="stats.html#topic+loess">loess</a></code>.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_method">method</code></td>
<td>
<p>The optimizer used when fitting the GEV distribution to
data. See function <code><a href="#topic+gevmle">gevmle</a></code>.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_std.err">std.err</code></td>
<td>
<p>Logical. If <code>TRUE</code>, standard errors are
computed. Note that standard errors are not available with the &quot;ST&quot;
estimator.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_xlab">xlab</code>, <code id="fitextcoeff_+3A_ylab">ylab</code></td>
<td>
<p>The x-axis and y-axis labels. May be missing.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_angles">angles</code></td>
<td>
<p>A numeric vector. A partition of the interval
<code class="reqn">(-\pi, \pi)</code> to help detecting anisotropy.</p>
</td></tr>
<tr><td><code id="fitextcoeff_+3A_identify">identify</code></td>
<td>
<p>Logical. If <code>TRUE</code>, users can use the
<code><a href="graphics.html#topic+identify">identify</a></code> function to identify pairs of stations on the
plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the estimation procedure, data need to be transformed to unit
Frechet margins firts. This can be done in two different ways ; by
using the empirical CDF or the GEV ML estimates.
</p>
<p>If <code>marge = "emp"</code>, then the data are transformed using the
following relation:  
</p>
<p style="text-align: center;"><code class="reqn">z_i = - \frac{1}{\log (F(y_i))}</code>
</p>

<p>where <code class="reqn">y_i</code> are the observations available at location
<code class="reqn">i</code>, <code class="reqn">F</code> is the empirical CDF and <code class="reqn">z_i</code> are the
observations transformed to unit Frechet scale.
</p>
<p>If <code>marge = "mle"</code>, then the data are transformed using the MLE
of the GEV distribution - see function <code><a href="#topic+gev2frech">gev2frech</a></code>.
</p>
<p>Lastly, if data are already supposed to be unit Frechet, then no
transformation is performed if one passed the option <code>marge =
  "frech"</code>.
</p>
<p>If <code>data</code> are already componentwise maxima, <code>prob</code> should be
zero. Otherwise, users have to define a threshold <code class="reqn">z</code> (large
enough) where univariate extreme value arguments are relevant. We
define <code>prob</code> such that <code class="reqn">\Pr[Z \leq z] = prob</code>.
</p>


<h3>Value</h3>

<p>Plots the extremal coefficient function and returns the points used
for the plot. If <code>loess = TRUE</code>, the output is a list with
argument &quot;ext.coeff&quot; and &quot;loess&quot;.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Schlather, M. and Tawn, J. A. (2003) A dependence measure for
multivariate and spatial extreme values: Properties and
inference. Biometrika <b>90</b>(1):139&ndash;156.
</p>
<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+madogram">madogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 10, cov12 =
40, cov22 = 220)

##Plot the extremal coefficient function
op &lt;- par(mfrow=c(1,2))
fitextcoeff(data, locations, estim = "Smith")
fitextcoeff(data, locations, angles = seq(-pi, pi, length = 4), estim = "Smith")
par(op)
</code></pre>

<hr>
<h2 id='fitmaxstab'>Fits a max-stable process to data</h2><span id='topic+fitmaxstab'></span>

<h3>Description</h3>

<p>This function fits max-stable processes to data using
pairwise likelihood. Two max-stable characterisations are available:
the Smith and Schlather representations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitmaxstab(data,  coord, cov.mod, loc.form, scale.form,
shape.form, marg.cov = NULL, temp.cov = NULL, temp.form.loc = NULL,
temp.form.scale = NULL, temp.form.shape = NULL, iso = FALSE, ...,
fit.marge = FALSE, warn = TRUE, method = "Nelder", start, control =
list(), weights = NULL, corr = FALSE, check.grad
= FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitmaxstab_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string corresponding to the covariance
model in the max-stable representation. Must be one of &quot;gauss&quot; for
the Smith's model; &quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot;, &quot;bessel&quot; or
&quot;caugen&quot; for the Whittle-Matern, the Cauchy, the Powered Exponential, the
Bessel and the Generalized Cauchy correlation families with the
Schlather's model; &quot;brown&quot; for Brown-Resnick processes. The
geometric Gaussian and Extremal-t models with a Whittle-Matern
correlation function can be fitted by passing respectively
&quot;gwhitmat&quot; or &quot;twhitmat&quot;. Other correlation function families are
considered in a similar way.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_loc.form">loc.form</code>, <code id="fitmaxstab_+3A_scale.form">scale.form</code>, <code id="fitmaxstab_+3A_shape.form">shape.form</code></td>
<td>
<p>R formulas defining the
spatial linear model for the GEV parameters. May be missing. See
section Details.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_marg.cov">marg.cov</code></td>
<td>
<p>Matrix with named columns giving additional covariates
for the GEV parameters. If <code>NULL</code>, no extra covariates are
used.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_temp.cov">temp.cov</code></td>
<td>
<p>Matrix with names columns giving additional *temporal*
covariates for the GEV parameters. If <code>NULL</code>, no temporal trend
are assume for the GEV parameters &mdash; see section Details.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_temp.form.loc">temp.form.loc</code>, <code id="fitmaxstab_+3A_temp.form.scale">temp.form.scale</code>, <code id="fitmaxstab_+3A_temp.form.shape">temp.form.shape</code></td>
<td>
<p>R formulas
defining the temporal trends for the GEV parameters. May be
missing. See section Details.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_iso">iso</code></td>
<td>
<p>Logical. If <code>TRUE</code> an isotropic model is fitted to
data. Otherwise (default), anisotropy is allowed. Currently, this is
only implemented for the Smith's model.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_...">...</code></td>
<td>
<p>Several arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code>
functions. See section details.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_fit.marge">fit.marge</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the GEV parameters
are estimated pointwise or using the formulas given by
<code>loc.form</code>, <code>scale.form</code> and <code>shape.form</code>. If
<code>FALSE</code>, observations are supposed to be unit Frechet
distributed. Note that when formulas are given, <code>fit.marge</code> is
automatically set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), users are warned if
the log-likelihood is infinite at starting values and/or problems
arised while computing the standard errors.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_method">method</code></td>
<td>
<p>The method used for the numerical optimisation
procedure. Must be one of <code>BFGS</code>, <code>Nelder-Mead</code>,
<code>CG</code>, <code>L-BFGS-B</code>, <code>SANN</code>, <code>nlm</code> or
<code>nlminb</code>. See <code><a href="stats.html#topic+optim">optim</a></code> for details. Please note that
passing <code>nlm</code> or <code>nlminb</code> will use the <code><a href="stats.html#topic+nlm">nlm</a></code>
or <code><a href="stats.html#topic+nlminb">nlminb</a></code> functions instead of <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the pairwise likelihood is to be minimized. If
<code>start</code> is omitted the routine attempts to find good starting
values - but might fail.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_control">control</code></td>
<td>
<p>A list giving the control parameters to be passed to
the <code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_weights">weights</code></td>
<td>
<p>A numeric vector specifying the weights in the pairwise
likelihood - and so has length the number of pairs. If <code>NULL</code>
(default), no weighting scheme is used.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_corr">corr</code></td>
<td>
<p>Logical. If <code>TRUE</code> (non default), the asymptotic
correlation matrix is computed.</p>
</td></tr>
<tr><td><code id="fitmaxstab_+3A_check.grad">check.grad</code></td>
<td>
<p>Logical. If <code>TRUE</code> (non default), the analytic
gradient of the pairwise likelihood will be compared to the
numerical one. Such a checking might be usefull for ill-conditionned
situation diagnosis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As spatial data often deal with a large number of locations, it is
impossible to write analytically the joint distribution. Consequently,
the fitting procedure substitutes the &quot;full likelihood&quot; for the
pairwise likelihood.
</p>
<p>Let define <code class="reqn">L_{i,j}(x_{i,j}, \theta)</code> the
likelihood for site <code class="reqn">i</code> and <code class="reqn">j</code>, where <code class="reqn">i = 1,
  \dots, N-1</code>, <code class="reqn">j = i+1, \dots, N</code>, <code class="reqn">N</code> is the number of site within the region and
<code class="reqn">x_{i,j}</code> are the joint observations for site <code class="reqn">i</code>
and <code class="reqn">j</code>. Then the pairwise likelihood
<code class="reqn">PL(\theta)</code> is defined by:
</p>
<p style="text-align: center;"><code class="reqn">\ell_P = \log PL(\theta) = \sum_{i = 1}^{N-1} \sum_{j=i+1}^{N} \log
  L_{i,j} (x_{i,j}, \theta)</code>
</p>

<p>As pairwise likelihood is an approximation of the &ldquo;full likelihood&rdquo;,
standard errors cannot be computed directly by the inverse of the
Fisher information matrix. Instead, a sandwich estimate must be used
to account for model mispecification e.g.
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta} \sim N(\theta, H^{-1} J H^{-1})</code>
</p>

<p>where <code class="reqn">H</code> is the Fisher information matrix (computed from the
misspecified model) and <code class="reqn">J</code> is the variance of the score
function.
</p>














<p>There are two different kind of covariates : &quot;spatial&quot; and
&quot;temporal&quot;.
</p>
<p>A &quot;spatial&quot; covariate may have different values accross station but
does not depend on time. For example the coordinates of the stations
are obviously &quot;spatial&quot;. These &quot;spatial&quot; covariates should be used
with the <code>marg.cov</code> and <code>loc.form, scale.form, shape.form</code>.
</p>
<p>A &quot;temporal&quot; covariates may have different values accross time but
does not depend on space. For example the years where the annual
maxima were recorded is &quot;temporal&quot;. These &quot;temporal&quot; covariates should
be used with the <code>temp.cov</code> and <code>temp.form.loc,
    temp.form.scale, temp.form.shape</code>.
</p>
<p>As a consequence note that <code>marg.cov</code> must have K rows (K being
the number of sites) while <code>temp.cov</code> must have n rows (n being
the number of observations).
</p>


<h3>Value</h3>

<p>This function returns a object of class <code>maxstab</code>. Such objects
are list with components:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A vector containing the estimated parameters.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>A vector containing the standard errors.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector containing the parameters of the model that
have been held fixed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>A vector containing all parameters (optimised and fixed).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The (pairwise) deviance at the maximum pairwise
likelihood estimates.</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>The correlation matrix.</p>
</td></tr>
<tr><td><code>convergence</code>, <code>counts</code>, <code>message</code></td>
<td>
<p>Components taken from the
list returned by <code><a href="stats.html#topic+optim">optim</a></code> - for the <code>mle</code> method.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The data analysed.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The max-stable characterisation used.</p>
</td></tr>
<tr><td><code>fit.marge</code></td>
<td>
<p>A logical that specifies if the GEV margins were
estimated.</p>
</td></tr>
<tr><td><code>cov.fun</code></td>
<td>
<p>The estimated covariance function - for the Schlather
model only.</p>
</td></tr>
<tr><td><code>extCoeff</code></td>
<td>
<p>The estimated extremal coefficient function.</p>
</td></tr>
<tr><td><code>cov.mod</code></td>
<td>
<p>The covariance model for the spatial structure.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>When using reponse surfaces to model spatially the GEV parameters, the
likelihood is pretty rough so that the general purpose optimization
routines may fail. It is your responsability to check if the
numerical optimization succeeded or not. I tried, as best as I can, to
provide warning messages if the optimizers failed but in some cases,
no warning will appear!
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Cox, D. R. and Reid, N. (2004) A note on pseudo-likelihood constructed
from marginal densities. <em>Biometrika</em> <b>91</b>, 729&ndash;737.
</p>
<p>Demarta, S. and McNeil, A. (2005) The t copula and Related Copulas
<em>International Statistical Review</em> <b>73</b>, 111-129.
</p>
<p>Gholam&ndash;Rezaee, M. (2009) Spatial extreme value: A composite
likelihood. PhD Thesis. Ecole Polytechnique Federale de Lausanne.
</p>
<p>Kabluchko, Z., Schlather, M. and de Haan, L. (2009) Stationary
max-stable fields associated to negative definite functions
<em>Annals of Probability</em> <b>37</b>:5, 2042&ndash;2065.
</p>
<p>Padoan, S. A. (2008) Computational Methods for Complex Problems in
Extreme Value Theory. PhD Thesis. University of Padova.
</p>
<p>Padoan, S. A., Ribatet, M. and Sisson, S. A. (2010) Likelihood-based
inference for max-stable processes. <em>Journal of the American
Statistical Association (Theory and Methods)</em> <b>105</b>:489,
263-277.
</p>
<p>Schlather, M. (2002) Models for Stationary Max-Stable Random
Fields. <em>Extremes</em> <b>5</b>:1, 33&ndash;44.
</p>
<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Define the coordinate of each location
n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(40, locations, cov.mod = "whitmat", nugget = 0, range = 3,
smooth = 0.5)

##Now define the spatial model for the GEV parameters
param.loc &lt;- -10 + 2 * locations[,2]
param.scale &lt;- 5 + 2 * locations[,1] + locations[,2]^2
param.shape &lt;- rep(0.2, n.site)

##Transform the unit Frechet margins to GEV
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

##Define a model for the GEV margins to be fitted
##shape ~ 1 stands for the GEV shape parameter is constant
##over the region
loc.form &lt;- loc ~ lat
scale.form &lt;- scale ~ lon + I(lat^2)
shape.form &lt;- shape ~ 1

##Fit a max-stable process using the Schlather's model
fitmaxstab(data, locations, "whitmat", loc.form, scale.form,
           shape.form)

## Model without any spatial structure for the GEV parameters
## Be careful this could be *REALLY* time consuming
fitmaxstab(data, locations, "whitmat")

##  Fixing the smooth parameter of the Whittle-Matern family
##  to 0.5 - e.g. considering exponential family. We suppose the data
##  are unit Frechet here.
fitmaxstab(data, locations, "whitmat", smooth = 0.5, fit.marge = FALSE)

##  Fitting a penalized smoothing splines for the margins with the
##     Smith's model
data &lt;- rmaxstab(40, locations, cov.mod = "gauss", cov11 = 100, cov12 =
                 25, cov22 = 220)

##     And transform it to ordinary GEV margins with a non-linear
##     function
fun &lt;- function(x)
  2 * sin(pi * x / 4) + 10
fun2 &lt;- function(x)
  (fun(x) - 7 ) / 15

param.loc &lt;- fun(locations[,2])
param.scale &lt;- fun(locations[,2])
param.shape &lt;- fun2(locations[,1])

##Transformation from unit Frechet to common GEV margins
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

##Defining the knots, penalty, degree for the splines
n.knots &lt;- 5
knots &lt;- quantile(locations[,2], prob = 1:n.knots/(n.knots+1))
knots2 &lt;- quantile(locations[,1], prob = 1:n.knots/(n.knots+1))

##Be careful the choice of the penalty (i.e. the smoothing parameter)
##may strongly affect the result Here we use p-splines for each GEV
##parameter - so it's really CPU demanding but one can use 1 p-spline
##and 2 linear models.
##A simple linear model will be clearly faster...
loc.form &lt;- y ~ rb(lat, knots = knots, degree = 3, penalty = .5)
scale.form &lt;- y ~ rb(lat, knots = knots, degree = 3, penalty = .5)
shape.form &lt;- y ~ rb(lon, knots = knots2, degree = 3, penalty = .5)

fitted &lt;- fitmaxstab(data, locations, "gauss", loc.form, scale.form, shape.form,
                     control = list(ndeps = rep(1e-6, 24), trace = 10),
                     method = "BFGS")
fitted
op &lt;- par(mfrow=c(1,3))
plot(locations[,2], param.loc, col = 2, ylim = c(7, 14),
     ylab = "location parameter", xlab = "latitude")
plot(fun, from = 0, to = 10, add = TRUE, col = 2)
points(locations[,2], predict(fitted)[,"loc"], col = "blue", pch = 5)
new.data &lt;- cbind(lon = seq(0, 10, length = 100), lat = seq(0, 10, length = 100))
lines(new.data[,1], predict(fitted, new.data)[,"loc"], col = "blue")
legend("topleft", c("true values", "predict. values", "true curve", "predict. curve"),
       col = c("red", "blue", "red", "blue"), pch = c(1, 5, NA, NA), inset = 0.05,
       lty = c(0, 0, 1, 1), ncol = 2)

plot(locations[,2], param.scale, col = 2, ylim = c(7, 14),
     ylab = "scale parameter", xlab = "latitude")
plot(fun, from = 0, to = 10, add = TRUE, col = 2)
points(locations[,2], predict(fitted)[,"scale"], col = "blue", pch = 5)
lines(new.data[,1], predict(fitted, new.data)[,"scale"], col = "blue")
legend("topleft", c("true values", "predict. values", "true curve", "predict. curve"),
       col = c("red", "blue", "red", "blue"), pch = c(1, 5, NA, NA), inset = 0.05,
       lty = c(0, 0, 1, 1), ncol = 2)

plot(locations[,1], param.shape, col = 2,
     ylab = "shape parameter", xlab = "longitude")
plot(fun2, from = 0, to = 10, add = TRUE, col = 2)
points(locations[,1], predict(fitted)[,"shape"], col = "blue", pch = 5)
lines(new.data[,1], predict(fitted, new.data)[,"shape"], col = "blue")
legend("topleft", c("true values", "predict. values", "true curve", "predict. curve"),
       col = c("red", "blue", "red", "blue"), pch = c(1, 5, NA, NA), inset = 0.05,
       lty = c(0, 0, 1, 1), ncol = 2)
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='fitspatgev'>MLE for a spatial GEV model</h2><span id='topic+fitspatgev'></span>

<h3>Description</h3>

<p>This function derives the MLE of a spatial GEV model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitspatgev(data, covariables, loc.form, scale.form, shape.form,
temp.cov = NULL, temp.form.loc = NULL, temp.form.scale = NULL,
temp.form.shape = NULL, ..., start, control = list(maxit = 10000),
method = "Nelder", warn = TRUE, corr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitspatgev_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_covariables">covariables</code></td>
<td>
<p>Matrix with named columns giving required
covariates for the GEV parameter models.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_loc.form">loc.form</code>, <code id="fitspatgev_+3A_scale.form">scale.form</code>, <code id="fitspatgev_+3A_shape.form">shape.form</code></td>
<td>
<p>R formulas defining the
spatial  models for the GEV parameters. See section Details.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_temp.cov">temp.cov</code></td>
<td>
<p>Matrix with names columns giving additional *temporal*
covariates for the GEV parameters. If <code>NULL</code>, no temporal trend
are assume for the GEV parameters &mdash; see section Details.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_temp.form.loc">temp.form.loc</code>, <code id="fitspatgev_+3A_temp.form.scale">temp.form.scale</code>, <code id="fitspatgev_+3A_temp.form.shape">temp.form.shape</code></td>
<td>
<p>R formulas
defining the temporal trends for the GEV parameters. May be
missing. See section Details.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values for the
parameters over which the pairwise likelihood is to be minimized. If
<code>start</code> is omitted the routine attempts to find good starting
values - but might fail.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_...">...</code></td>
<td>
<p>Several arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> functions. See section details.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_control">control</code></td>
<td>
<p>The control argument to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_method">method</code></td>
<td>
<p>The method used for the numerical optimisation
procedure. Must be one of <code>BFGS</code>, <code>Nelder-Mead</code>,
<code>CG</code>, <code>L-BFGS-B</code> or <code>SANN</code>. See <code><a href="stats.html#topic+optim">optim</a></code>
for details.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_warn">warn</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), users will be warned if
the starting values lie in a zero density region.</p>
</td></tr>
<tr><td><code id="fitspatgev_+3A_corr">corr</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the asymptotic correlation matrix
is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A kind of &quot;spatial&quot; GEV model can be defined by using response
surfaces for the GEV parameters. For instance, the GEV location
parameters are defined through the following equation:
</p>
<p style="text-align: center;"><code class="reqn">\mu = X_\mu \beta_\mu</code>
</p>

<p>where <code class="reqn">X_\mu</code> is the design matrix and
<code class="reqn">\beta_\mu</code> is the vector parameter to be
estimated. The GEV scale and shape parameters are defined accordingly
to the above equation.
</p>
<p>The log-likelihood for the GEV spatial model is consequently defined
as follows:
</p>
<p style="text-align: center;"><code class="reqn">\ell(\beta) = \sum_{i=1}^{n.site} \sum_{j=1}^{n.obs} \log
    f(y_{i,j}; \theta_i)</code>
</p>

<p>where <code class="reqn">\theta_i</code> is the vector of the GEV parameters for
the <code class="reqn">i</code>-th site.
</p>
<p>Most often, there will be some dependence between stations. However,
it can be seen from the log-likelihood definition that we supposed
that the stations are mutually independent. Consequently, to get
reliable standard error estimates, these standard errors are estimated
with their sandwich estimates.
</p>
<p>There are two different kind of covariates : &quot;spatial&quot; and
&quot;temporal&quot;.
</p>
<p>A &quot;spatial&quot; covariate may have different values accross station but
does not depend on time. For example the coordinates of the stations
are obviously &quot;spatial&quot;. These &quot;spatial&quot; covariates should be used
with the <code>marg.cov</code> and <code>loc.form, scale.form, shape.form</code>.
</p>
<p>A &quot;temporal&quot; covariates may have different values accross time but
does not depend on space. For example the years where the annual
maxima were recorded is &quot;temporal&quot;. These &quot;temporal&quot; covariates should
be used with the <code>temp.cov</code> and <code>temp.form.loc,
    temp.form.scale, temp.form.shape</code>.
</p>
<p>As a consequence note that <code>marg.cov</code> must have K rows (K being
the number of sites) while <code>temp.cov</code> must have n rows (n being
the number of observations).
</p>


<h3>Value</h3>

<p>An object of class <code>spatgev</code>. Namely, this is a list with the
following arguments:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>The parameter estimates.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>All the parameters e.g. parameter estimates and fixed
parameters.</p>
</td></tr>
<tr><td><code>std.err</code></td>
<td>
<p>The standard errors.</p>
</td></tr>
<tr><td><code>var.cov</code></td>
<td>
<p>The asymptotic MLE variance covariance matrix.</p>
</td></tr>
<tr><td><code>counts</code>, <code>message</code>, <code>convergence</code></td>
<td>
<p>Some information about the
optimization procedure.</p>
</td></tr>
<tr><td><code>logLik</code>, <code>deviance</code></td>
<td>
<p>The log-likelihood and deviance values.</p>
</td></tr>
<tr><td><code>loc.form</code>, <code>scale.form</code>, <code>shape.form</code></td>
<td>
<p>The formulas defining the
spatial models for the GEV parameters.</p>
</td></tr>
<tr><td><code>covariables</code></td>
<td>
<p>The covariables used for the spatial models.</p>
</td></tr>
<tr><td><code>ihessian</code></td>
<td>
<p>The inverse of the Hessian matrix of the negative
log-likelihood.</p>
</td></tr>
<tr><td><code>jacobian</code></td>
<td>
<p>The variance covariance matrix of the score.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1- Simulate a max-stable random field
n.site &lt;- 35
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")
data &lt;- rmaxstab(50, locations, cov.mod = "whitmat", nugget = 0, range =
  3, smooth = 0.5)

## 2- Transformation to non unit Frechet margins
param.loc &lt;- -10 + 2 * locations[,2]
param.scale &lt;- 5 + 2 * locations[,1]
param.shape &lt;- rep(0.2, n.site)
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

## 3- Fit a ''spatial GEV'' mdoel to data with the following models for
##    the GEV parameters
form.loc &lt;- loc ~ lat
form.scale &lt;- scale ~ lon
form.shape &lt;- shape ~ 1

fitspatgev(data, locations, form.loc, form.scale, form.shape)
</code></pre>

<hr>
<h2 id='fmadogram'>Computes the F-madogram</h2><span id='topic+fmadogram'></span>

<h3>Description</h3>

<p>Computes the F-madogram for max-stable processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmadogram(data, coord, fitted, n.bins, which = c("mado", "ext"), xlab,
ylab, col = c(1, 2), angles = NULL, marge = "emp", add = FALSE, xlim =
c(0, max(dist)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmadogram_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_fitted">fitted</code></td>
<td>
<p>An object of class maxstab - usually the output of the
<code><a href="#topic+fitmaxstab">fitmaxstab</a></code> function. May be missing.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_n.bins">n.bins</code></td>
<td>
<p>The number of bins to be used. If missing, pairwise
F-madogram estimates will be computed.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_which">which</code></td>
<td>
<p>A character vector of maximum size 2. It specifies if the
madogram and/or the extremal coefficient functions have to be
plotted.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_xlab">xlab</code>, <code id="fmadogram_+3A_ylab">ylab</code></td>
<td>
<p>The x-axis and y-axis labels. May be missing. Note
that <code>ylab</code> must have the same length has <code>which</code>.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_col">col</code></td>
<td>
<p>The colors used for the points and optionnaly the fitted
curve.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_angles">angles</code></td>
<td>
<p>A numeric vector. A partition of the interval
<code class="reqn">(-\pi, \pi)</code> to help detecting anisotropy.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_marge">marge</code></td>
<td>
<p>Character string. If 'emp', the probabilities of non
exceedances are estimated using the empirical CDF. If 'mle'
(default), maximum likelihood estimates are used.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plot is added to the current
figure; otherwhise (default) a new plot is computed.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 specifying the x coordinate
range.</p>
</td></tr>
<tr><td><code id="fmadogram_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z(x)</code> be a stationary process. The F-madogram is
defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">\nu(h) = \frac{1}{2}\mbox{E}\left[|F(Z(x+h)) - F(Z(x))|
    \right]</code>
</p>

<p>The extremal coefficient <code class="reqn">\theta(h)</code> satisfies:
</p>
<p style="text-align: center;"><code class="reqn">\theta(h) = \frac{1 + 2 \nu(h)}{1 - 2 \nu(h)}</code>
</p>
 


<h3>Value</h3>

<p>A graphic and (invisibly) a matrix with the lag distances, the
F-madogram  and extremal coefficient estimates. 
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Cooley, D., Naveau, P. and Poncet, P. (2006) Variograms for
spatial max-stable random fields. <em>Dependence in Probability and
Statistics</em>, 373&ndash;390.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+madogram">madogram</a></code>, <code><a href="#topic+lmadogram">lmadogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 15
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(40, locations, cov.mod = "whitmat", nugget = 0, range = 1,
smooth = 2)

##Compute the F-madogram
fmadogram(data, locations)

##Compare the F-madogram with a fitted max-stable process
fitted &lt;- fitmaxstab(data, locations, "whitmat", nugget = 0)
fmadogram(fitted = fitted, which = "ext")
</code></pre>

<hr>
<h2 id='gcv'>Estimates the penalty coefficient from the generalized
cross-validation criterion</h2><span id='topic+gcv'></span>

<h3>Description</h3>

<p>Estimates the penalty coefficient from the generalized
cross-validation criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcv(y, x, knots, degree, plot = TRUE, n.points = 150, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcv_+3A_y">y</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code id="gcv_+3A_x">x</code></td>
<td>
<p>A vector/matrix giving the values of the predictor
variable(s). If <code>x</code> is a matrix, each row corresponds to one
observation.</p>
</td></tr>
<tr><td><code id="gcv_+3A_knots">knots</code></td>
<td>
<p>A vector givint the coordinates of the knots.</p>
</td></tr>
<tr><td><code id="gcv_+3A_degree">degree</code></td>
<td>
<p>The degree of the penalized smoothing spline.</p>
</td></tr>
<tr><td><code id="gcv_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the evolution of the CV
score as the penalty increases is plotted.</p>
</td></tr>
<tr><td><code id="gcv_+3A_n.points">n.points</code></td>
<td>
<p>A numeric giving the number of CV computations needed
to produce the plot.</p>
</td></tr>
<tr><td><code id="gcv_+3A_...">...</code></td>
<td>
<p>Options to be passed to the <code><a href="stats.html#topic+nlm">nlm</a></code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For every linear smoother e.g. <code class="reqn">\hat{y} = S_\lambda y</code>, the cross-validation criterion consists in minimizing
the following quantity:
</p>
<p style="text-align: center;"><code class="reqn">GCV(\lambda) = \frac{n ||y - \hat{y}||^2}{(n -
      tr(S_\lambda))^2}</code>
</p>

<p>where <code class="reqn">\lambda</code> is the penalty coefficient, <code class="reqn">n</code> the
number of observations and <code class="reqn">tr(S_\lambda)</code> is the
trace of the matrix <code class="reqn">S_\lambda</code>.
</p>


<h3>Value</h3>

<p>A list with components 'penalty', 'gcv' and 'nlm.code' which give the
location of the minimum, the value of the cross-validation
criterion at that point and the code returned by the <code>link{nlm}</code>
function - useful to assess for convergence issues.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Ruppert, D. Wand, M.P. and Carrol, R.J. (2003) <em>Semiparametric
Regression</em> Cambridge Series in Statistical and Probabilistic
Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv">cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
x &lt;- runif(n)
fun &lt;- function(x) sin(3 * pi * x)
y &lt;- fun(x) + rnorm(n, 0, sqrt(0.4))
knots &lt;- quantile(x, prob = 1:(n/4) / (n/4 + 1))
gcv(y, x, knots = knots, degree = 3)
</code></pre>

<hr>
<h2 id='Generalized+20Extreme+20Value+20Distribution'>The Generalized Extreme Value Distribution</h2><span id='topic+rgev'></span><span id='topic+dgev'></span><span id='topic+qgev'></span><span id='topic+pgev'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the GP distribution with location equal to 'loc',
scale equal to 'scale' and shape equal to 'shape'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgev(n, loc = 0, scale = 1, shape = 0)
pgev(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE)
qgev(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE)
dgev(x, loc = 0, scale = 1, shape = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_x">x</code>, <code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_loc">loc</code></td>
<td>
<p>vector of the location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_scale">scale</code></td>
<td>
<p>vector of the scale parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_shape">shape</code></td>
<td>
<p>a numeric of the shape parameter.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">\Pr[ X
      \le x]</code>, otherwise, <code class="reqn">\Pr[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Extreme+2B20Value+2B20Distribution_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'loc', 'scale' and 'shape' are not specified they assume the default
values of '0', '1' and '0', respectively.
</p>
<p>The GEV distribution function for loc = <code class="reqn">u</code>, scale =
<code class="reqn">\sigma</code> and shape = <code class="reqn">\xi</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(x) = \exp\left[-\left\{1 + \xi \frac{x - u}{\sigma}
    \right\}^{-1 / \xi} \right]</code>
</p>
  
<p>for <code class="reqn">1 + \xi ( x - u ) / \sigma &gt; 0</code>
and <code class="reqn">x &gt; u</code>, where <code class="reqn">\sigma &gt; 0</code>. If
<code class="reqn">\xi = 0</code>, the distribution is defined by continuity
corresponding to the Gumbel distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgev(0.1)
rgev(100, 1, 2, 0.2)
qgev(seq(0.1, 0.9, 0.1), 1, 0.5, -0.2)
pgev(12.6, 2, 0.5, 0.1)
</code></pre>

<hr>
<h2 id='Generalized+20Pareto+20Distribution'>The Generalized Pareto Distribution</h2><span id='topic+rgpd'></span><span id='topic+dgpd'></span><span id='topic+qgpd'></span><span id='topic+pgpd'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the GP distribution with location equal to 'loc',
scale equal to 'scale' and shape equal to 'shape'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgpd(n, loc = 0, scale = 1, shape = 0)
pgpd(q, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, lambda = 0)
qgpd(p, loc = 0, scale = 1, shape = 0, lower.tail = TRUE, lambda = 0)
dgpd(x, loc = 0, scale = 1, shape = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_x">x</code>, <code id="Generalized+2B20Pareto+2B20Distribution_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_loc">loc</code></td>
<td>
<p>vector of the location parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_scale">scale</code></td>
<td>
<p>vector of the scale parameters.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_shape">shape</code></td>
<td>
<p>a numeric of the shape parameter.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">\Pr[ X
      \le x]</code>, otherwise, <code class="reqn">\Pr[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Generalized+2B20Pareto+2B20Distribution_+3A_lambda">lambda</code></td>
<td>
<p>a single probability - see the &quot;value&quot; section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'loc', 'scale' and 'shape' are not specified they assume the default
values of '0', '1' and '0', respectively.
</p>
<p>The GP distribution function for loc = <code class="reqn">u</code>, scale =
<code class="reqn">\sigma</code> and shape = <code class="reqn">\xi</code> is
</p>
<p style="text-align: center;"><code class="reqn">G(x) = 1 - \left[ 1 + \frac{\xi (x - u )}{ \sigma } \right] ^ { - 1 /
      \xi}</code>
</p>

<p>for <code class="reqn">1 + \xi ( x - u ) / \sigma &gt; 0</code>
and <code class="reqn">x &gt; u</code>, where <code class="reqn">\sigma &gt; 0</code>. If
<code class="reqn">\xi = 0</code>, the distribution is defined by continuity
corresponding to the exponential distribution.
</p>
<p>By definition, the GP distribution models exceedances above a
threshold. In particular, the <code class="reqn">G</code> function is a suited
candidate to model
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left[ X \geq x | X &gt; u \right] = 1 - G(x)</code>
</p>

<p>for <code class="reqn">u</code> large enough.
</p>
<p>However, it may be usefull to model the &quot;non conditional&quot; quantiles,
that is the ones related to <code class="reqn">\Pr[ X \leq x]</code>. Using
the conditional probability definition, one have :
</p>
<p style="text-align: center;"><code class="reqn">\Pr\left[ X \geq x \right] = \left(1 - \lambda\right) \left( 1 +
    \xi \frac{x - u}{\sigma}\right)^{-1/\xi}</code>
</p>

<p>where <code class="reqn">\lambda = \Pr[ X \leq u]</code>.
</p>
<p>When <code class="reqn">\lambda = 0</code>, the &quot;conditional&quot; distribution
is equivalent to the &quot;non conditional&quot; distribution. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgpd(0.1)
rgpd(100, 1, 2, 0.2)
qgpd(seq(0.1, 0.9, 0.1), 1, 0.5, -0.2)
pgpd(12.6, 2, 0.5, 0.1)
##for non conditional quantiles
qgpd(seq(0.9, 0.99, 0.01), 1, 0.5, -0.2, lambda = 0.9)
pgpd(2.6, 2, 2.5, 0.25, lambda = 0.5)
</code></pre>

<hr>
<h2 id='gev2frech'>Transforms GEV data to unit Frechet ones and vice versa</h2><span id='topic+gev2frech'></span><span id='topic+frech2gev'></span>

<h3>Description</h3>

<p>Transforms GEV data to unit Frechet ones and vice versa
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gev2frech(x, loc, scale, shape, emp = FALSE)
frech2gev(x, loc, scale, shape)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gev2frech_+3A_x">x</code></td>
<td>
<p>The data to be transformed to unit Frechet or ordinary GEV
margins</p>
</td></tr>
<tr><td><code id="gev2frech_+3A_loc">loc</code>, <code id="gev2frech_+3A_scale">scale</code>, <code id="gev2frech_+3A_shape">shape</code></td>
<td>
<p>The location, scale and shape parameters of
the GEV.</p>
</td></tr>
<tr><td><code id="gev2frech_+3A_emp">emp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, data are transformed to unit
Frechet margins using the empirical CDF.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If Y is a random variable with a GEV distribution with location
<code class="reqn">\mu</code>, scale <code class="reqn">\sigma</code> and shape
<code class="reqn">\xi</code>. Then,
</p>
<p style="text-align: center;"><code class="reqn">Z = \left[1 + \xi \frac{Y - \mu}{\sigma} \right]_+^{1/\xi}</code>
</p>

<p>is unit Frechet distributed - where <code class="reqn">x_+ = \max(0, x)</code>.
</p>
<p>If Z is a unit Frechet random variable. Then,
</p>
<p style="text-align: center;"><code class="reqn">Y = \mu + \sigma \frac{Z_+^{\xi} - 1}{\xi}</code>
</p>

<p>is unit GEV distributed with location, scale and shape parameters
equal to <code class="reqn">\mu</code>, <code class="reqn">\sigma</code> and <code class="reqn">\xi</code>
respectively.
</p>


<h3>Value</h3>

<p>Returns a numeric vector with the same length of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2.2975896, 1.6448808, 1.3323833, -0.4464904, 2.2737603,
    -0.2581876, 9.5184398, -0.5899699, 0.4974283, -0.8152157)
y &lt;- gev2frech(x, 1, 2, .2)
y
frech2gev(y, 1, 2, .2)
</code></pre>

<hr>
<h2 id='Internal+20functions+20and+20methods'>Internal functions and methods for the maxstable package.</h2><span id='topic+schlatherfull'></span><span id='topic+smithfull'></span><span id='topic+dpostmaxstab'></span><span id='topic+dpriormaxstab'></span><span id='topic+smithform'></span><span id='topic+schlatherform'></span><span id='topic+schlatherindform'></span><span id='topic+schlatherindfull'></span><span id='topic+geomgaussform'></span><span id='topic+geomgaussfull'></span><span id='topic+fitnsmaxstab'></span><span id='topic+nsgeomgaussfull'></span><span id='topic+nsgeomgaussform'></span><span id='topic+brownresnickfull'></span><span id='topic+brownresnickform'></span><span id='topic+extremaltform'></span><span id='topic+extremaltfull'></span><span id='topic+getsubregions'></span><span id='topic+logit'></span><span id='topic+maxima.summer'></span><span id='topic+minima.winter'></span><span id='topic+metadata'></span><span id='topic+coord'></span><span id='topic+rain'></span><span id='topic+alt.mat'></span><span id='topic+lon.vec'></span><span id='topic+lat.vec'></span>

<h3>Description</h3>

<p>A set of functions that should not be used directly by the
user or are not documented yet. For methods, user should usually used
the generic functions which calls the appropriate method.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>

<hr>
<h2 id='kriging'>
Simple kriging interpolation
</h2><span id='topic+kriging'></span>

<h3>Description</h3>

<p>This function interpolates a zero mean Gaussian random field using the
simple kriging predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kriging(data, data.coord, krig.coord, cov.mod = "whitmat", sill, range,
smooth, smooth2 = NULL, grid = FALSE, only.weights = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kriging_+3A_data">data</code></td>
<td>
<p>A numeric vector or matrix. If <code>data</code> is a matrix
then the simple kriging predictor is given for each realisation,
i.e., each row of <code>data</code>.</p>
</td></tr>
<tr><td><code id="kriging_+3A_data.coord">data.coord</code></td>
<td>
<p>A numeric vector or matrix specifying the
coordinates of the observed data. If <code>data.coord</code> is a matrix,
each row must corresponds to one location.</p>
</td></tr>
<tr><td><code id="kriging_+3A_krig.coord">krig.coord</code></td>
<td>
<p>A numeric vector or matrix specifying the
coordinates where the kriging predictor has to be computed. If
<code>krig.coord</code> is a matrix, each row must correspond to one
location.</p>
</td></tr>
<tr><td><code id="kriging_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string specifying the covariance function
family. Must be one of &quot;whitmat&quot;, &quot;powexp&quot;, &quot;cauchy&quot;, &quot;bessel&quot; or
&quot;caugen&quot; for the Whittle-Matern, the powered exponential, the
Cauchy, the Bessel or the generalized Cauchy covariance families.</p>
</td></tr>
<tr><td><code id="kriging_+3A_sill">sill</code>, <code id="kriging_+3A_range">range</code>, <code id="kriging_+3A_smooth">smooth</code>, <code id="kriging_+3A_smooth2">smooth2</code></td>
<td>
<p>Numerics specifiying the sill, range,
smooth and, if any, the second smooth parameters of the covariance
function.</p>
</td></tr> 
<tr><td><code id="kriging_+3A_grid">grid</code></td>
<td>
<p>Logical. Does <code>krig.coord</code> specifies a grid?</p>
</td></tr>
<tr><td><code id="kriging_+3A_only.weights">only.weights</code></td>
<td>
<p>Logical. Should only the kriging weights be
computed? If <code>FALSE</code>, the kriging predictor isn't computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>coord</code></td>
<td>
<p>The coordinates where the kriging predictor has been
computed;</p>
</td></tr>
<tr><td><code>krig.est</code></td>
<td>
<p>The kriging predictor estimates;</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>Does <code>coord</code> define a grid?;</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>A matrix giving the kriging weights: each column
corresponds to one prediction location.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mathieu Ribatet
</p>


<h3>References</h3>

<p>Chiles, J.-P. and Delfiner, P. (1999) <em>Geostatistics, Modeling
Spatial Uncertainty</em> Wiley Series in Probability and Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condrgp">condrgp</a></code>, <code><a href="#topic+rgp">rgp</a></code>, <code><a href="#topic+covariance">covariance</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Kriging from a single realisation
n.site &lt;- 50
n.pred &lt;- 512

x.obs &lt;- runif(n.site, -100, 100)
x.pred &lt;- seq(-100, 100, length = n.pred)

data &lt;- rgp(1, x.obs, "whitmat", sill = 1, range = 10, smooth = 0.75)

krig &lt;- kriging(data, x.obs, x.pred, "whitmat", sill = 1, range = 10,
smooth = 0.75)

plot(krig$coord, krig$krig.est, type = "l", xlab = "x", ylab =
expression(hat(Y)(x)))
points(x.obs, data, col = 2, pch = 21, bg = 2)

## Kriging from several realisations
n.real &lt;- 3
data &lt;- rgp(n.real, x.obs, "whitmat", sill = 1, range = 10, smooth = 0.75)

krig &lt;- kriging(data, x.obs, x.pred, "whitmat", sill = 1, range = 10,
smooth = 0.75)

matplot(krig$coord, t(krig$krig.est), type = "l", xlab = "x", ylab =
expression(hat(Y)(x)), lty = 1)
matpoints(x.obs, t(data), pch = 21, col = 1:n.real, bg = 1:n.real)
title("Three kriging predictors in one shot")

## Two dimensional kriging on a grid
x.obs &lt;- matrix(runif(2 * n.site, -100, 100), ncol = 2)
x &lt;- y &lt;- seq(-100, 100, length = 100)
x.pred &lt;- cbind(x, y)

data &lt;- rgp(1, x.obs, "whitmat", sill = 1, range = 10, smooth = 0.75)

krig &lt;- kriging(data, x.obs, x.pred, "whitmat", sill = 1, range = 10,
smooth = 0.75, grid = TRUE)

z.lim &lt;- range(c(data, krig$krig.est))
breaks &lt;- seq(z.lim[1], z.lim[2], length = 65)
col &lt;- heat.colors(64)
idx &lt;- as.numeric(cut(data, breaks))

image(x, y, krig$krig.est, col = col, breaks = breaks)
points(x.obs, bg = col[idx], pch = 21)
## Note how the background colors of the above points matches the ones
## returned by the image function
</code></pre>

<hr>
<h2 id='latent'>
Bayesian hierarchical models for spatial extremes
</h2><span id='topic+latent'></span>

<h3>Description</h3>

<p>This function generates a Markov chain from a Bayesian hierarchical
model for block maxima assuming conditional independence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latent(data, coord, cov.mod = "powexp", loc.form, scale.form,
shape.form, marg.cov = NULL, hyper, prop, start, n = 5000, thin = 1,
burn.in = 0, use.log.link = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latent_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="latent_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="latent_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string corresponding to the covariance
model for the Gaussian latent processes. Must be one of &quot;gauss&quot; for
the Smith's model; &quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot; or &quot;bessel&quot; or
for the Whittle-Matern, the Cauchy, the Powered Exponential and the
Bessel correlation families.</p>
</td></tr> 
<tr><td><code id="latent_+3A_loc.form">loc.form</code>, <code id="latent_+3A_scale.form">scale.form</code>, <code id="latent_+3A_shape.form">shape.form</code></td>
<td>
<p>R formulas defining the
spatial linear model for the mean of the latent processes.</p>
</td></tr>
<tr><td><code id="latent_+3A_marg.cov">marg.cov</code></td>
<td>
<p>Matrix with named columns giving additional covariates
for the latent processes means. If <code>NULL</code>, no extra covariates are
used.</p>
</td></tr>
<tr><td><code id="latent_+3A_hyper">hyper</code></td>
<td>
<p>A named list specifying the hyper-parameters &mdash; see Details.</p>
</td></tr>
<tr><td><code id="latent_+3A_prop">prop</code></td>
<td>
<p>A named list specifying the jump sizes when a
Metropolis&ndash;Hastings move is needed &mdash; see Details.</p>
</td></tr>
<tr><td><code id="latent_+3A_start">start</code></td>
<td>
<p>A named list specifying the starting values &mdash; see Details.</p>
</td></tr>
<tr><td><code id="latent_+3A_n">n</code></td>
<td>
<p>The effective length of the simulated Markov chain i.e., once
the burnin period has been discarded and after thinning.</p>
</td></tr>
<tr><td><code id="latent_+3A_thin">thin</code></td>
<td>
<p>An integer specifying the thinning length. The default is
1, i.e., no thinning.</p>
</td></tr>
<tr><td><code id="latent_+3A_burn.in">burn.in</code></td>
<td>
<p>An integer specifying the burnin period. The default is
0, i.e., no burnin.</p>
</td></tr>
<tr><td><code id="latent_+3A_use.log.link">use.log.link</code></td>
<td>
<p>An integer. Should a log-link function should be
use for the GEV scale parameters, i.e., assuming that the GEV scale
parameters a drawn from a log-normal process rather than a gaussian
process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a Markov chain from the following model. For
each <code class="reqn">x \in R^d</code>, suppose that
<code class="reqn">Y(x)</code> is GEV distributed whose parameters <code class="reqn">\{\mu(x),
    \sigma(x), \xi(x)\}</code> vary smoothly for
<code class="reqn">x \in R^d</code> according to a stochastic process
<code class="reqn">S(x)</code>. We assume that the processes for each GEV
parameters are mutually independent Gaussian processes. For instance,
we take for the location parameter <code class="reqn">\mu(x)</code>
</p>
<p style="text-align: center;"><code class="reqn">\mu(x) = f_{\mu(x)}(x;\beta_\mu) + S_\mu(x;\alpha_{\mu},
    \lambda_\mu, \kappa_\mu)</code>
</p>

<p>where <code class="reqn">f_\mu</code> is a deterministic function depending on
regression parameters <code class="reqn">\beta_\mu</code>, and
<code class="reqn">S_\mu</code> is a zero mean, stationary Gaussian process with a
prescribed covariance function with sill <code class="reqn">\alpha_\mu</code>,
range <code class="reqn">\lambda_\mu</code> and shape parameters
<code class="reqn">\kappa_\mu</code>. Similar formulations for the scale
<code class="reqn">\sigma(x)</code> and the shape <code class="reqn">\xi(x)</code> parameters
are used. Then conditional on the values of the three Gaussian
processes at the sites <code class="reqn">(x_1, \ldots, x_K)</code>,
the maxima are assumed to follow GEV distributions
</p>
<p style="text-align: center;"><code class="reqn">Y_i(x_j) \mid \{\mu(x_j), \sigma(x_j), \xi(x_j)\} \sim
    \mbox{GEV}\{\mu(x_j), \sigma(x_j), \xi(x_j)\},</code>
</p>

<p>independently for each location <code class="reqn">(x_1, \ldots, x_K)</code>.
</p>
<p>A joint prior density must be defined for the sills, ranges, shapes
parameters of the covariance functions as well as for the regression
parameters <code class="reqn">\beta_\mu</code>,<code class="reqn">\beta_\sigma</code>
and <code class="reqn">\beta_\xi</code>. Conjugate priors are used whenever
possible, taking independent inverse Gamma and multivariate normal
distributions for the sills and the regression parameters. No
conjugate prior exist for <code class="reqn">\lambda</code> and
<code class="reqn">\kappa</code>, for wich a Gamma distribution is assumed.
</p>
<p>Consequently <code>hyper</code> is a named list with named components
</p>

<dl>
<dt>sills</dt><dd><p>A list with three components named 'loc', 'scale'
and 'shape' each of these is a 2-length vector specifying the shape
and the scale of the inverse Gamma prior distribution for the sill
parameter of the covariance functions;</p>
</dd>
<dt>ranges</dt><dd><p>A list with three components named 'loc', 'scale' and
'shape' each of these is a 2-length vector specifying the shape and
the scale of the Gamma prior distribution for the range parameter of
the covariance functions.</p>
</dd>
<dt>smooths</dt><dd><p>A list with three components named 'loc', 'scale' and
'shape' each of these is a 2-length vector specifying the shape and
the scale of the Gamma prior distribution for the shape parameter of
the covariance functions;</p>
</dd>
<dt>betaMean</dt><dd><p>A list with three components named 'loc', 'scale'
and 'shape' each of these is a vector specifying the mean vector of
the multivariate normal prior distribution for the regression
parameters;</p>
</dd>
<dt>betaIcov</dt><dd><p>A list with three components named 'loc', 'scale'
and 'shape' each of these is a matrix specifying the inverse of
the covariance matrix of the multivariate normal prior distribution
for the regression parameters.</p>
</dd>
</dl>

<p>As no conjugate prior exists for the GEV parameters and the range and
shape parameters of the covariance functions, Metropolis&ndash;Hastings
steps are needed. The proposals <code class="reqn">\theta_{prop}</code> are
drawn from a proposal density <code class="reqn">q(\cdot \mid \theta_{cur},
    s)</code> where <code class="reqn">\theta_{cur}</code> is
the current state of the parameter and <code class="reqn">s</code> is a parameter of
the proposal density to be defined. These proposals are driven by
<code>prop</code> which is a list with three named components 
</p>

<dl>
<dt>gev</dt><dd><p>A vector of length 3 specifying the standard deviations
of the proposal distributions. These are taken to be normal
distribution for the location and shape GEV parameters and a
log-normal distribution for the scale GEV parameters;</p>
</dd>
<dt>ranges</dt><dd><p>A vector of length 3 specifying the jump sizes for the
range parameters of the covariance functions &mdash; <code class="reqn">q(\cdot |
	\theta_{cur}, s)</code> is the log-normal density
with mean <code class="reqn">\theta_{cur}</code> and standard deviation
<code class="reqn">s</code> both on the log-scale;</p>
</dd>
<dt>smooths</dt><dd><p>A vector of length 3 specifying the jump sizes for
the shape parameters of the covariance functions &mdash; <code class="reqn">q(\cdot |
	\theta_{cur}, s)</code> is the log-normal density
with mean <code class="reqn">\theta_{cur}</code> and standard deviation
<code class="reqn">s</code> both on the log-scale.</p>
</dd>
</dl>

<p>If one want to held fixed a parameter this can be done by setting a null
jump size then the parameter will be held fixed to its starting value.
</p>
<p>Finally <code>start</code> must be a named list with 4 named components
</p>

<dl>
<dt>sills</dt><dd><p>A vector of length 3 specifying the starting values for
the sill of the covariance functions;</p>
</dd>
<dt>ranges</dt><dd><p>A vector of length 3 specifying the starting values
for the range of the covariance functions;</p>
</dd>
<dt>smooths</dt><dd><p>A vector of length 3 specifying the starting values
for the shape of the covariance functions;</p>
</dd>
<dt>beta</dt><dd><p>A named list with 3 components 'loc', 'scale' and
'shape' each of these is a numeric vector specifying the starting
values for the regression coefficients.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list</p>


<h3>Warning</h3>

<p>This function can be time consuming and makes an intensive use of BLAS
routines so it is (much!) faster if you have an optimized BLAS.
</p>
<p>The starting values will never be stored in the generated Markov chain
even when <code>burn.in=0</code>.
</p>


<h3>Note</h3>

<p>If you want to analyze the convergence ans mixing properties of the
Markov chain, it is recommended to use the library <span class="pkg">coda</span>.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Banerjee, S., Carlin, B. P., and Gelfand, A. E. (2004). Hierarchical
Modeling and Analysis for Spatial Data. Chapman &amp; Hall/CRC, New
York.
</p>
<p>Casson, E. and Coles, S. (1999) Spatial regression models for
extremes. <em>Extremes</em> <b>1</b>,449&ndash;468.
</p>
<p>Cooley, D., Nychka, D. and Naveau, P. (2007) Bayesian spatial
modelling of extreme precipitation return levels <em>Journal of the
American Statistical Association</em> <b>102</b>:479, 824&ndash;840.
</p>
<p>Davison, A.C., Padoan, S.A. and Ribatet, M. Statistical Modelling of
Spatial Extremes. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Generate realizations from the model
n.site &lt;- 30
n.obs &lt;- 50
coord &lt;- cbind(lon = runif(n.site, -10, 10), lat = runif(n.site, -10 , 10))

gp.loc &lt;- rgp(1, coord, "powexp", sill = 4, range = 20, smooth = 1)
gp.scale &lt;- rgp(1, coord, "powexp", sill = 0.4, range = 5, smooth = 1)
gp.shape &lt;- rgp(1, coord, "powexp", sill = 0.01, range = 10, smooth = 1)

locs &lt;- 26 + 0.5 * coord[,"lon"] + gp.loc
scales &lt;- 10 + 0.2 * coord[,"lat"] + gp.scale
shapes &lt;- 0.15 + gp.shape

data &lt;- matrix(NA, n.obs, n.site)
for (i in 1:n.site)
  data[,i] &lt;- rgev(n.obs, locs[i], scales[i], shapes[i])

loc.form &lt;- y ~ lon
scale.form &lt;- y ~ lat
shape.form &lt;- y ~ 1

hyper &lt;- list()
hyper$sills &lt;- list(loc = c(1,8), scale = c(1,1), shape = c(1,0.02))
hyper$ranges &lt;- list(loc = c(2,20), scale = c(1,5), shape = c(1, 10))
hyper$smooths &lt;- list(loc = c(1,1/3), scale = c(1,1/3), shape = c(1, 1/3))
hyper$betaMeans &lt;- list(loc = rep(0, 2), scale = c(9, 0), shape = 0)
hyper$betaIcov &lt;- list(loc = solve(diag(c(400, 100))),
                       scale = solve(diag(c(400, 100))),
                       shape = solve(diag(c(10), 1, 1)))

## We will use an exponential covariance function so the jump sizes for
## the shape parameter of the covariance function are null.
prop &lt;- list(gev = c(1.2, 0.08, 0.08), ranges = c(0.7, 0.8, 0.7), smooths = c(0,0,0))
start &lt;- list(sills = c(4, .36, 0.009), ranges = c(24, 17, 16), smooths
              = c(1, 1, 1),  beta = list(loc = c(26, 0.5), scale = c(10, 0.2),
                               shape = c(0.15)))

mc &lt;- latent(data, coord, loc.form = loc.form, scale.form = scale.form,
             shape.form = shape.form, hyper = hyper, prop = prop, start = start,
             n = 10000, burn.in = 5000, thin = 15)
mc

## End(Not run)
</code></pre>

<hr>
<h2 id='lmadogram'>Computes the lambda-madogram</h2><span id='topic+lmadogram'></span>

<h3>Description</h3>

<p>Computes the lambda-madogram for max-stable processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmadogram(data, coord, n.bins, xlab, ylab, zlab, n.lambda = 11, marge =
"emp", col = terrain.colors(50, alpha = 0.5), theta = 90, phi = 20,
border = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmadogram_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_n.bins">n.bins</code></td>
<td>
<p>The number of bins to be used. If missing, pairwise
lambda-madogram estimates will be computed.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_xlab">xlab</code>, <code id="lmadogram_+3A_ylab">ylab</code>, <code id="lmadogram_+3A_zlab">zlab</code></td>
<td>
<p>The x-axis, y-axis and z-axis labels. May be
missing.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_n.lambda">n.lambda</code></td>
<td>
<p>Integer giving the number of lambda values.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_marge">marge</code></td>
<td>
<p>Character string. If 'emp', probabilities of non
exceedances are estimated using the empirical CDF. If 'mle'
(default),  maximum likelihood estimates are used.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_col">col</code></td>
<td>
<p>The colors used to emphasize the gradient of the
lambda-madogram.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_theta">theta</code>, <code id="lmadogram_+3A_phi">phi</code>, <code id="lmadogram_+3A_border">border</code></td>
<td>
<p>Options to be passed to the
<code><a href="graphics.html#topic+persp">persp</a></code> function.</p>
</td></tr>
<tr><td><code id="lmadogram_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="graphics.html#topic+persp">persp</a></code>
function.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z(x)</code> be a stationary process. The
<code class="reqn">\lambda</code>-madogram is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">\nu_{\lambda}(h) = \frac{1}{2}\mbox{E}\left[|F^\lambda(Z(x+h)) -
    F^{1-\lambda}(Z(x))| \right]</code>
</p>



<h3>Value</h3>

<p>A graphic and (invisibly) a matrix with the lag distances, the
<code class="reqn">\lambda</code>-madogram estimate.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Naveau, P., Guillou, A., Cooley, D. and Diebolt, J. (2009) Modelling
Pairwise Dependence of Maxima in Space. To appear in
<em>Biometrika</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+madogram">madogram</a></code>, <code><a href="#topic+fmadogram">fmadogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 50
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(40, locations, cov.mod = "whitmat", nugget = 0, range = 1,
smooth = 2)

##Compute the lambda-madogram
lmadogram(data, locations, n.bins = 80)
</code></pre>

<hr>
<h2 id='logLik'>Extracts Log-Likelihood</h2><span id='topic+logLik'></span><span id='topic+logLik.maxstab'></span><span id='topic+logLik.copula'></span>

<h3>Description</h3>

<p>Extract the pairwise log-likelihood for objects of class
&ldquo;maxstab&rdquo; and &ldquo;copula&rdquo;</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxstab'
logLik(object, ...)
## S3 method for class 'copula'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>An object of class &ldquo;maxstab&rdquo; or &ldquo;copula&rdquo;. Most often
this will be the output of the <code><a href="#topic+fitmaxstab">fitmaxstab</a></code> of
<code><a href="#topic+fitcopula">fitcopula</a></code> functions.</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to the <code><a href="#topic+logLik">logLik</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard <code>logLik</code> object (see <code><a href="#topic+logLik">logLik</a></code>) except that
it might actually correspond to the pairwise log-likelihood, e.g., for
the class &ldquo;maxstab&rdquo;! 
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+logLik">logLik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinates of each location
n.site &lt;- 30
locations &lt;- matrix(5 + runif(2*n.site, 0, 10), ncol = 2)

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(30, locations, cov.mod = "whitmat", nugget = 0, range = 3,
smooth = 0.5)
fit &lt;- fitmaxstab(data, locations, "whitmat")
logLik(fit)
</code></pre>

<hr>
<h2 id='lsmaxstab'>Estimates the spatial dependence parameter of a max-stable
process by minimizing least squares.</h2><span id='topic+lsmaxstab'></span>

<h3>Description</h3>

<p>Estimates the spatial dependence parameter of a max-stable
process by minimizing least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsmaxstab(data, coord, cov.mod = "gauss", marge = "emp", control =
list(), iso = FALSE, ..., weighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsmaxstab_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_cov.mod">cov.mod</code></td>
<td>
<p>Character string specifying the max-stable process
considered. Must be one of &quot;gauss&quot; (Smith's model), &quot;whitmat&quot;,
&quot;cauchy&quot;, &quot;powexp&quot;, &quot;bessel&quot;, &quot;caugen&quot; for the Schlather model with
the corresponding correlation function.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_marge">marge</code></td>
<td>
<p>Character string specifying how margins are transformed
to unit Frechet. Must be one of &quot;emp&quot;, &quot;frech&quot; or &quot;mle&quot; - see
function <code><a href="#topic+fitextcoeff">fitextcoeff</a></code>.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_control">control</code></td>
<td>
<p>The control arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_iso">iso</code></td>
<td>
<p>Logical. If <code>TRUE</code>, isotropy is supposed. Otherwise
(default), anisotropy is allowed. Currently this is only useful for
the Smith model.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
<tr><td><code id="lsmaxstab_+3A_weighted">weighted</code></td>
<td>
<p>Logical. Should weighted least squares be used? See
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitting procedure is based on weighted least squares. More
precisely, the fitting criteria is to minimize:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i,j} \left(\frac{\tilde{\theta}_{i,j} -
      \hat{\theta}_{i,j}}{s_{i,j}}\right)^2</code>
</p>

<p>where <code class="reqn">\tilde{\theta}_{i,j}</code> is a non
parametric estimate of the extremal coefficient related to location
<code>i</code> and <code>j</code>, <code class="reqn">\hat{\theta}_{i,j}</code> is
the fitted extremal coefficient derived from the maxstable model
considered and <code class="reqn">s_{i,j}</code> are the standard errors related
to the estimates <code class="reqn">\tilde{\theta}_{i,j}</code>.
</p>


<h3>Value</h3>

<p>An object of class maxstab.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitcovariance">fitcovariance</a></code>, <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>,
<code><a href="#topic+fitextcoeff">fitextcoeff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 50
n.obs &lt;- 100
locations &lt;- matrix(runif(2*n.site, 0, 40), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

## Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 200, cov12 =
0, cov22 = 200)

lsmaxstab(data, locations, "gauss")

##Force an isotropic model and do not use weights
lsmaxstab(data, locations, "gauss", iso = TRUE, weighted = FALSE)
</code></pre>

<hr>
<h2 id='madogram'>Computes madograms</h2><span id='topic+madogram'></span>

<h3>Description</h3>

<p>Computes the madogram for max-stable processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>madogram(data, coord, fitted, n.bins, gev.param = c(0, 1, 0), which =
c("mado", "ext"), xlab, ylab, col = c(1, 2), angles = NULL, marge =
"emp", add = FALSE, xlim = c(0, max(dist)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="madogram_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="madogram_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="madogram_+3A_fitted">fitted</code></td>
<td>
<p>An object of class maxstab - usually the output of the
<code><a href="#topic+fitmaxstab">fitmaxstab</a></code> function. May be missing.</p>
</td></tr>
<tr><td><code id="madogram_+3A_n.bins">n.bins</code></td>
<td>
<p>The number of bins to be used. If missing, pairwise
madogram estimates will be computed.</p>
</td></tr>
<tr><td><code id="madogram_+3A_gev.param">gev.param</code></td>
<td>
<p>Numeric vector of length 3 specifying the location,
scale and shape parameters for the GEV.</p>
</td></tr>
<tr><td><code id="madogram_+3A_which">which</code></td>
<td>
<p>A character vector of maximum size 2. It specifies if the
madogram and/or the extremal coefficient functions have to be
plotted.</p>
</td></tr>
<tr><td><code id="madogram_+3A_xlab">xlab</code>, <code id="madogram_+3A_ylab">ylab</code></td>
<td>
<p>The x-axis and y-axis labels. May be missing. Note
that <code>ylab</code> must have the same length has <code>which</code>.</p>
</td></tr>
<tr><td><code id="madogram_+3A_col">col</code></td>
<td>
<p>The colors used for the points and optionnaly for the
fitted curve.</p>
</td></tr>
<tr><td><code id="madogram_+3A_angles">angles</code></td>
<td>
<p>A numeric vector. A partition of the interval
<code class="reqn">(0, \pi)</code> to help detecting anisotropy.</p>
</td></tr>
<tr><td><code id="madogram_+3A_marge">marge</code></td>
<td>
<p>Character string. If 'emp', the observation are first
transformed to the unit Frechet scale by using the empirical CDF. If
'mle' (default), maximum likelihood estimates are used.</p>
</td></tr>
<tr><td><code id="madogram_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plot is added to the current
figure; otherwhise (default) a new plot is computed.</p>
</td></tr>
<tr><td><code id="madogram_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 specifying the x coordinate
range.</p>
</td></tr> 
<tr><td><code id="madogram_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z(x)</code> be a stationary process. The madogram is defined
as follows:
</p>
<p style="text-align: center;"><code class="reqn">\nu(h) = \frac{1}{2}\mbox{E}\left[|Z(x+h) - Z(x)|
    \right]</code>
</p>

<p>If now <code class="reqn">Z(x)</code> is a stationary max-stable random field with
GEV marginals. Provided the GEV shape parameter <code class="reqn">\xi</code> is such
that <code class="reqn">\xi &lt; 1</code>. The extremal coefficient
<code class="reqn">\theta(h)</code> satisfies:
</p>
<p style="text-align: center;"><code class="reqn">\theta(h) =
    \left\{
    \begin{array}{ll}
    u_\beta \left(\mu +  \frac{\nu(h)}{\Gamma(1 - \xi)} \right), &amp;\xi
    \neq 0\\
    \exp\left(\frac{\nu(h)}{\sigma}\right), &amp;\xi = 0
    \end{array}
    \right.</code>
</p>

<p>where <code class="reqn">\Gamma</code> is the gamma function and
<code class="reqn">u_\beta</code> is defined as follows: 
</p>
<p style="text-align: center;"><code class="reqn">u_\beta(u) = \left(1 + \xi \frac{u - \mu}{\sigma}
    \right)_+^{1/\xi}</code>
</p>
<p> and
<code class="reqn">\beta = (\mu, \sigma, \xi)</code>, i.e,
the vector of the GEV parameters.
</p>


<h3>Value</h3>

<p>A graphic and (invisibly) a matrix with the lag distances, the
madogram and extremal coefficient estimates. 
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Cooley, D., Naveau, P. and Poncet, P. (2006) Variograms for
spatial max-stable random fields. <em>Dependence in Probability and
Statistics</em>, 373&ndash;390.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmadogram">fmadogram</a></code>, <code><a href="#topic+lmadogram">lmadogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 15
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(40, locations, cov.mod = "whitmat", nugget = 0, range = 1,
smooth = 2)

##Compute the madogram
madogram(data, locations)

##Compare the madogram with a fitted max-stable model
fitted &lt;- fitmaxstab(data, locations, "whitmat", nugget = 0)
madogram(fitted = fitted, which = "ext")
</code></pre>

<hr>
<h2 id='map'>Produces a 2D map from a fitted max-stable process</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Produces a 2D map from a fitted max-stable process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(fitted, x, y, covariates = NULL, param = "quant", ret.per = 100, col
= terrain.colors(64), plot.contour = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>maxstab</code>. Most often, it will
be the output of the function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="map_+3A_x">x</code>, <code id="map_+3A_y">y</code></td>
<td>
<p>Numeric vector that gives the coordinates of the grid.</p>
</td></tr>
<tr><td><code id="map_+3A_covariates">covariates</code></td>
<td>
<p>An array specifying the covariates at each grid
point defined by <code>x</code> and <code>y</code>. If <code>NULL</code>, no covariate
is needed. See the example to see how to build it.</p>
</td></tr>
<tr><td><code id="map_+3A_param">param</code></td>
<td>
<p>A character string. Must be one of &quot;loc&quot;, &quot;scale&quot;,
&quot;shape&quot; or &quot;quant&quot; for a map of the location, scale, shape
parameters or for a map of a specified quantile.</p>
</td></tr>
<tr><td><code id="map_+3A_ret.per">ret.per</code></td>
<td>
<p>A numeric giving the return period for which the
quantile map is plotted. It is only required if <code>param =
      "quant"</code>.</p>
</td></tr>
<tr><td><code id="map_+3A_col">col</code></td>
<td>
<p>A list of colors such as that generated by 'rainbow',
'heat.colors', 'topo.colors', 'terrain.colors' or similar
functions.</p>
</td></tr>
<tr><td><code id="map_+3A_plot.contour">plot.contour</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), contour lines
are added to the plot.</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Several arguments to be passed to the <code><a href="Matrix.html#topic+image">image</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot. Additionally, a list with the details for plotting the map is
returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+condmap">condmap</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>,
<code><a href="stats.html#topic+heatmap">heatmap</a></code>, <code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>,
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code>,
<code><a href="grDevices.html#topic+rainbow">rainbow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##We run an artifical example using the volcano data set as a study
##region
dim &lt;- dim(volcano)
n.x &lt;- dim[1]
n.y &lt;- dim[2]

x &lt;- 10 * 1:n.x
y &lt;- 10 * 1:n.y

n.site &lt;- 15
idx.x &lt;- sample(n.x, n.site)
idx.y &lt;- sample(n.y, n.site)
locations &lt;- cbind(lon = x[idx.x], lat = y[idx.y])
alt &lt;- diag(volcano[idx.x, idx.y])

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(40, locations, cov.mod = "whitmat", nugget = 0, range = 750,
smooth = 1)

##Now define the spatial model for the GEV parameters
param.loc &lt;- -10 - 0.04 * locations[,1] + alt / 5
param.scale &lt;- 5 - locations[,2] / 30 + alt / 4
param.shape &lt;- rep(.2, n.site)

##Transform the unit Frechet margins to GEV
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

##Define a model for the GEV margins to be fitted
##shape ~ 1 stands for the GEV shape parameter is constant
##over the region
loc.form &lt;- loc ~ lon + alt
scale.form &lt;- scale ~ lat + alt
shape.form &lt;- shape ~ 1

##  1- Fit a max-stable process
schlather &lt;- fitmaxstab(data, locations, "whitmat", loc.form, scale.form,
                        shape.form, marg.cov = cbind(alt = alt), nugget
= 0)

##  2- Produce a map of the pointwise 50-year return level

##Here we have only one covariate i.e. alt
n.cov &lt;- 1
covariates &lt;- array(volcano, dim = c(n.x, n.y, n.cov), dimnames =
list(NULL, NULL, "alt"))

par(mfrow = c(1,2))
image(x, y, volcano, col = terrain.colors(64), main = "Elevation map")
map(schlather, x, y, covariates, ret.per = 50, plot.contour = FALSE,
main = "50-year return level")
</code></pre>

<hr>
<h2 id='map.latent'>Two dimensional map from a Bayesian hierarchical model</h2><span id='topic+map.latent'></span>

<h3>Description</h3>

<p>This function plots 2D maps from a Markov chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.latent(fitted, x, y, covariates = NULL, param = "quant", ret.per =
100, col = terrain.colors(64), plot.contour = TRUE, fun = mean, level =
0.95, show.data = TRUE, control = list(nlines = 500), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.latent_+3A_fitted">fitted</code></td>
<td>
<p>An object of class &quot;latent&quot;. Typically this will be the
output of <code><a href="#topic+latent">latent</a></code>.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_x">x</code>, <code id="map.latent_+3A_y">y</code></td>
<td>
<p>Numeric vector specifying the coordinates of the grid points.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_covariates">covariates</code></td>
<td>
<p>An array specifying the covariates at each grid
point defined by <code>x</code> and <code>y</code>. If <code>NULL</code>, no covariate
is needed.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_param">param</code></td>
<td>
<p>A character string. Must be one of &quot;loc&quot;, &quot;scale&quot;,
&quot;shape&quot; or &quot;quant&quot; for a map of the location, scale, shape
parameters or for a map of a specified quantile.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_ret.per">ret.per</code></td>
<td>
<p>A numeric giving the return period for which the
quantile map is plotted. It is only required if <code>param =
      "quant"</code>.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_col">col</code></td>
<td>
<p>A list of colors such as that generated by 'rainbow',
'heat.colors', 'topo.colors', 'terrain.colors' or similar
functions.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_plot.contour">plot.contour</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), contour lines
are added to the plot.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_fun">fun</code></td>
<td>
<p>A character string specifying the function to be used to
get posterior point estimates. The default is to take posterior
means.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_level">level</code></td>
<td>
<p>A numeric specifying the significance level for the
pointwise credible intervals.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_show.data">show.data</code></td>
<td>
<p>Logical. Should the locations where have observed the
process have to be plotted?</p>
</td></tr>
<tr><td><code id="map.latent_+3A_control">control</code></td>
<td>
<p>A list with named components specifying options to be
passed to <code><a href="#topic+rgp">rgp</a></code>. Typically one might want specify
<code>nlines</code> to reduce the computational demand.</p>
</td></tr>
<tr><td><code id="map.latent_+3A_...">...</code></td>
<td>
<p>Several arguments to be passed to the <code><a href="Matrix.html#topic+image">image</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot and a invisible list containing all the data required to do the
plot.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+condrgp">condrgp</a></code>, <code><a href="#topic+map">map</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Generate realizations from the model
n.site &lt;- 30
n.obs &lt;- 50
coord &lt;- cbind(lon = runif(n.site, -10, 10), lat = runif(n.site, -10 , 10))

gp.loc &lt;- rgp(1, coord, "powexp", sill = 4, range = 20, smooth = 1)
gp.scale &lt;- rgp(1, coord, "powexp", sill = 0.4, range = 5, smooth = 1)
gp.shape &lt;- rgp(1, coord, "powexp", sill = 0.01, range = 10, smooth = 1)

locs &lt;- 26 + 0.5 * coord[,"lon"] + gp.loc
scales &lt;- 10 + 0.2 * coord[,"lat"] + gp.scale
shapes &lt;- 0.15 + gp.shape

data &lt;- matrix(NA, n.obs, n.site)
for (i in 1:n.site)
  data[,i] &lt;- rgev(n.obs, locs[i], scales[i], shapes[i])

loc.form &lt;- y ~ lon
scale.form &lt;- y ~ lat
shape.form &lt;- y ~ 1

hyper &lt;- list()
hyper$sills &lt;- list(loc = c(1,8), scale = c(1,1), shape = c(1,0.02))
hyper$ranges &lt;- list(loc = c(2,20), scale = c(1,5), shape = c(1, 10))
hyper$smooths &lt;- list(loc = c(1,1/3), scale = c(1,1/3), shape = c(1, 1/3))
hyper$betaMeans &lt;- list(loc = rep(0, 2), scale = c(9, 0), shape = 0)
hyper$betaIcov &lt;- list(loc = solve(diag(c(400, 100))),
                       scale = solve(diag(c(400, 100))),
                       shape = solve(diag(c(10), 1, 1)))

## We will use an exponential covariance function so the jump sizes for
## the shape parameter of the covariance function are null.
prop &lt;- list(gev = c(2.5, 1.5, 0.2), ranges = c(0.7, 0.75, 0.9), smooths = c(0,0,0))
start &lt;- list(sills = c(4, .36, 0.009), ranges = c(24, 17, 16), smooths
              = c(1, 1, 1),  beta = list(loc = c(26, 0.5), scale = c(10, 0.2),
                               shape = c(0.15)))

## Generate a Markov chain
mc &lt;- latent(data, coord, loc.form = loc.form, scale.form = scale.form,
             shape.form = shape.form, hyper = hyper, prop = prop, start = start,
             n = 100)

x.grid &lt;- y.grid &lt;- seq(-10, 10, length = 50)
map.latent(mc, x.grid, y.grid, param = "shape")

## End(Not run)
</code></pre>

<hr>
<h2 id='margin+20fits'>Fits univariate extreme value distributions to data</h2><span id='topic+gevmle'></span><span id='topic+gpdmle'></span>

<h3>Description</h3>

<p>These functions fit the generalised extreme value and
generalised Pareto distribution to data using maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gevmle(x, ..., method = "Nelder")
gpdmle(x, threshold, ..., method = "Nelder")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margin+2B20fits_+3A_x">x</code></td>
<td>
<p>Numeric vector of observations</p>
</td></tr>
<tr><td><code id="margin+2B20fits_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the
<code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
<tr><td><code id="margin+2B20fits_+3A_threshold">threshold</code></td>
<td>
<p>Numeric. The threshold value.</p>
</td></tr>
<tr><td><code id="margin+2B20fits_+3A_method">method</code></td>
<td>
<p>The numerical optimisation method to be used.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>These two functions are &ldquo;extremely light&rdquo; functions to fit the
GEV/GPD. These functions are mainly useful to compute starting values
for the Schlather and Smith model - see <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.
</p>
<p>If more refined (univariate) analysis have to be performed, users should
use more specialised packages - e.g. POT, evd, ismev, ....
</p>


<h3>Value</h3>

<p>A vector for the estimated parameters of the GEV/GPD.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1 - GEV fit
x &lt;- rep(NA, 100)
for (i in 1:100)
  x[i] &lt;- max(rnorm(365))

gevmle(x)

## 2- GPD fit
x &lt;- rnorm(10000)
##we need to fix a threshold
u &lt;- quantile(x, 0.99)
gpdmle(x, u)
</code></pre>

<hr>
<h2 id='modeldef'>Define a model for the spatial behaviour of the GEV parameters</h2><span id='topic+modeldef'></span><span id='topic+modeldef.lm'></span><span id='topic+modeldef.rb'></span>

<h3>Description</h3>

<p>This function defines the model for the spatial behaviour
of the GEV parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeldef(data, formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeldef_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="modeldef_+3A_formula">formula</code></td>
<td>
<p>A R formula. See details for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><b>need to be documented</b>
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1- A design matrix from a classical linear model 
n.site &lt;- 5
coord &lt;- matrix(rnorm(2*n.site, sd = sqrt(.2)), ncol = 2)
colnames(coord) &lt;- c("lon", "lat")
loc.form &lt;- loc ~ lat + I(lon^2)
modeldef(coord, loc.form)

## 2- A design and penalization matrix from a penalized smoothin spline
x &lt;- sort(runif(10, -2, 10))
n.knots &lt;- 3
knots &lt;- quantile(x, prob = 1:n.knots / (n.knots + 2))
modeldef(x, y ~ rb(x, knots = knots, degree = 3, penalty = 1))
</code></pre>

<hr>
<h2 id='plot.copula'>
Model checking of a fitted copula based model.
</h2><span id='topic+plot.copula'></span>

<h3>Description</h3>

<p>This function produces several plots to assess the goodness of fit of a
fitted copula based model for spatial extremes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'copula'
plot(x, ..., sites)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.copula_+3A_x">x</code></td>
<td>
<p>An object of class <code>copula</code>. Most often, this will be
the output of <code><a href="#topic+fitcopula">fitcopula</a></code>.</p>
</td></tr>
<tr><td><code id="plot.copula_+3A_...">...</code></td>
<td>
<p>Here for compatibility reasons but not yet implemented.</p>
</td></tr>
<tr><td><code id="plot.copula_+3A_sites">sites</code></td>
<td>
<p>A vector of integer of length 4 specifying the locations
to be used for the model checking. If missing, locations will be
choosen randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diagonal plots are return level plots. The lower ones are qq-plots
(on the Gumbel scale) between observed pairwise maxima for each block,
e.g. year, and the ones obtained by simulations from the fitted
model. The upper plot compares the fitted extremal coefficient
functions to semi-empirical estimates from the F-madogram - see
<code><a href="#topic+fmadogram">fmadogram</a></code>. The two remaining plots are the stations
locations and a qq-plot of blockwise maxima where the block size is 4.
</p>


<h3>Value</h3>

<p>Several diagnostic plots.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n.site &lt;- 20
n.obs &lt;- 50
coord &lt;- matrix(runif(2 * n.site, 0, 10), ncol = 2)
colnames(coord) &lt;- c("lon", "lat")
data &lt;- rmaxstab(n.obs, coord, "powexp", nugget = 0, range = 3, smooth =
1)
fitted &lt;- fitcopula(log(data), coord, "student", "powexp", y ~ 1, y ~ 1, y ~ 1,
nugget = 0)
plot(fitted)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.maxstab'>
Model checking of a fitted max-stable model
</h2><span id='topic+plot.maxstab'></span>

<h3>Description</h3>

<p>This function produces several plots to assess the goodness of fit of a
fitted max-stable model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxstab'
plot(x, ..., sites)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.maxstab_+3A_x">x</code></td>
<td>
<p>An object of class <code>maxstab</code>. Most often, this will be
the output of <code><a href="#topic+fitmaxstab">fitmaxstab</a></code> or <code><a href="#topic+lsmaxstab">lsmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="plot.maxstab_+3A_...">...</code></td>
<td>
<p>Here for compatibility reasons but not yet implemented.</p>
</td></tr>
<tr><td><code id="plot.maxstab_+3A_sites">sites</code></td>
<td>
<p>A vector of integer of length 4 specifying the locations
to be used for the model checking. If missing, locations will be
choosen randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diagonal plots are return level plots. The lower ones are qq-plots
(on the Gumbel scale) between observed pairwise maxima for each block,
e.g. year, and the ones obtained by simulations from the fitted
model. The upper plot compares the fitted extremal coefficient
functions to semi-empirical estimates from the F-madogram - see
<code><a href="#topic+fmadogram">fmadogram</a></code>. The two remaining plots are the stations
locations and a qq-plot of blockwise maxima where the block size is 4.
</p>


<h3>Value</h3>

<p>Several diagnostic plots.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 20
n.obs &lt;- 50
coord &lt;- matrix(runif(2 * n.site, 0, 10), ncol = 2)
colnames(coord) &lt;- c("lon", "lat")
data &lt;- rmaxstab(n.obs, coord, "powexp", nugget = 0, range = 3, smooth =
1)
fitted &lt;- fitmaxstab(log(data), coord, "powexp", y ~ 1, y ~ 1, y ~ 1,
nugget = 0)
plot(fitted)
</code></pre>

<hr>
<h2 id='predict'>Prediction of the marginal parameters for various models</h2><span id='topic+predict'></span><span id='topic+predict.maxstab'></span><span id='topic+predict.copula'></span><span id='topic+predict.pspline2'></span><span id='topic+predict.spatgev'></span>

<h3>Description</h3>

<p>This function predicts the marginal GEV parameters from a
fitted max-stable process, copula, penalized spline or spatial GEV model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxstab'
predict(object, newdata, ret.per = NULL, std.err =
TRUE, ...)
## S3 method for class 'copula'
predict(object, newdata, ret.per = NULL, std.err =
TRUE, ...)
## S3 method for class 'pspline2'
predict(object, newdata, ...)
## S3 method for class 'spatgev'
predict(object, newdata, ret.per = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>An object of class 'maxstab', 'copula', 'pspline' or
'spatgev'. Most often, it will be the output of one of the
following functions: <code><a href="#topic+rbpspline">rbpspline</a></code>,
<code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+fitcopula">fitcopula</a></code> or
<code><a href="#topic+fitspatgev">fitspatgev</a></code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables
with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict_+3A_ret.per">ret.per</code></td>
<td>
<p>Numeric vector giving the return periods for which
return levels are computed. If <code>NULL</code> (default), no return
levels are computed.</p>
</td></tr>
<tr><td><code id="predict_+3A_std.err">std.err</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), standard erros will
be computed if possible.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print several information on screen.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1- Simulate a max-stable random field
n.site &lt;- 35
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

data &lt;- rmaxstab(50, locations, cov.mod = "whitmat", nugget = 0, range = 30,
smooth = 0.5)

## 2- Transformation to non unit Frechet margins
param.loc &lt;- -10 + 2 * locations[,2]
param.scale &lt;- 5 + 2 * locations[,1]
param.shape &lt;- rep(0.2, n.site)

for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i])

## 3- Fit a max-stable process with the following model for
##    the GEV parameters
form.loc &lt;- loc ~ lat
form.scale &lt;- scale ~ lon
form.shape &lt;- shape ~ 1

schlather &lt;- fitmaxstab(data, locations, "whitmat", loc.form = form.loc,
                        scale.form = form.scale, shape.form =
                        form.shape)

## 4- GEV parameters estimates at each locations or at ungauged locations
predict(schlather)
ungauged &lt;- data.frame(lon = runif(10, 0, 10), lat = runif(10, 0, 10))
predict(schlather, ungauged)
</code></pre>

<hr>
<h2 id='print'>Printing objects of classes defined in the SpatialExtreme packages</h2><span id='topic+print'></span><span id='topic+print.pspline2'></span><span id='topic+print.maxstab'></span><span id='topic+print.copula'></span><span id='topic+print.spatgev'></span><span id='topic+print.latent'></span>

<h3>Description</h3>

<p>Methods for printing objects of classes introduced by the
SpatialExtremes package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pspline2'
print(x, ...)
## S3 method for class 'maxstab'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'copula'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'spatgev'
print(x, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'latent'
print(x, digits = max(3, getOption("digits") - 3), ...,
 level = 0.95)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>An object of class 'pspline', 'maxstab', 'copula', 'spatgev'
or 'latent'. Most often, <code>x</code> will be the output of one of the
following functions: <code><a href="#topic+rbpspline">rbpspline</a></code>, <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>,
<code><a href="#topic+fitcopula">fitcopula</a></code>, <code><a href="#topic+fitspatgev">fitspatgev</a></code> or
<code><a href="#topic+latent">latent</a></code>.</p>
</td></tr>
<tr><td><code id="print_+3A_digits">digits</code></td>
<td>
<p>The number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Other options to be passed to the <code><a href="#topic+print">print</a></code>
function.</p>
</td></tr>
<tr><td><code id="print_+3A_level">level</code></td>
<td>
<p>A numeric giving the significance level for the credible
intervals&mdash;class 'latent' only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print several information on screen.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinates of each location
n.site &lt;- 30
coord &lt;- matrix(5 + rnorm(2*n.site, sd = sqrt(2)), ncol = 2)
colnames(coord) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(30, coord, cov.mod = "whitmat", nugget = 0, range = 3,
smooth = 0.5)

## Printing max-stable objects
fit &lt;- fitmaxstab(data, coord, "whitmat")
fit

## Printing spatial GEV objects
loc.form &lt;- scale.form &lt;- shape.form &lt;- y ~ 1
fit &lt;- fitspatgev(data, coord, loc.form, scale.form, shape.form)
fit
</code></pre>

<hr>
<h2 id='profile'>Method for profiling fitted max-stable objects</h2><span id='topic+profile'></span><span id='topic+profile.maxstab'></span>

<h3>Description</h3>

<p>Computes profile traces for fitted max-stable models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxstab'
profile(fitted, param, range, n = 10, plot = TRUE,
conf = 0.90, method = "RJ", square = "chol", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_+3A_fitted">fitted</code></td>
<td>
<p>An object of class &ldquo;maxstab&rdquo;. Most often, it will be
the output of the function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="profile_+3A_param">param</code></td>
<td>
<p>A character string giving the model parameter that are to
be profiled.</p>
</td></tr>
<tr><td><code id="profile_+3A_range">range</code></td>
<td>
<p>The range for the profiled model parameter that must be
explored.</p>
</td></tr>
<tr><td><code id="profile_+3A_n">n</code></td>
<td>
<p>Integer. The number of profiled model parameter that must be
considered.</p>
</td></tr>
<tr><td><code id="profile_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the profile trace is
plotted.</p>
</td></tr>
<tr><td><code id="profile_+3A_conf">conf</code></td>
<td>
<p>Numeric giving the confidence interval level.</p>
</td></tr>
<tr><td><code id="profile_+3A_method">method</code></td>
<td>
<p>Character string. Must be one of &quot;CB&quot;, &quot;RJ&quot; or &quot;none&quot; for the
Chandler and Bate or the Rotnitzky and Jewell approaches
respectively. The &quot;none&quot; method simply plots the profile of the
log-composite likelihood. See details.</p>
</td></tr>
<tr><td><code id="profile_+3A_square">square</code></td>
<td>
<p>The choice for the matrix square root. This is only
useful for the 'CB' method. Must be one of 'chol' (Cholesky) or
'svd' (Singular Value Decomposition).</p>
</td></tr>
<tr><td><code id="profile_+3A_...">...</code></td>
<td>
<p>Extra options that must be passed to the
<code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rotnitzky and Jewell approach consists in adjusting the
distribution of the likelihood ratio statistics - which under
misspecification is no longer <code class="reqn">\chi^2</code> distributed.
</p>
<p>The Chandler and Bate approach adjusts the composite likelihood itself
is such a way that the usual asymptotic <code class="reqn">\chi^2</code> null
distribution is preserved. Note that in the current code, we use the
singular value decomposition for the computation of matrix square
roots to preserve asymmetry in the profile composite likelihood.
</p>


<h3>Value</h3>

<p>A matrix. The first column corresponds to the values for which the
profiled model parameter is fixed. The second column gives the value
of the pairwise log-likelihood. The remaining columns contain the
constrained maximum likelihood estimates for the remaining model
parameters.
</p>


<h3>Warnings</h3>

<p>This function can be <b>really</b> time consuming!
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Chandler, R. E. and Bate, S. (2007) Inference for clustered data using
the independence loglikelihood <em>Biometrika</em>, <b>94</b>,
167&ndash;183.
</p>
<p>Rotnitzky, A. and Jewell, N. (1990) Hypothesis testing of regression
parameters in semiparametric generalized linear models for cluster
correlated data. <em>Biometrika</em> <b>77</b>, 485&ndash;97.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Define the coordinates of each location
n.site &lt;- 30
locations &lt;- matrix(rnorm(2*n.site, sd = sqrt(.2)), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 100, cov12 =
25, cov22 = 220)

##Fit a max-stable process
##  1- using the Smith's model
fitted &lt;- fitmaxstab(data, locations, "gauss", fit.marge = FALSE)

##Plot the profile pairwise log-likelihood for the ''cov11'' parameter
profile(fitted, "cov11", range = c(20, 180))

## End(Not run)
</code></pre>

<hr>
<h2 id='profile2d'>Method for profiling (in 2d) fitted max-stable objects</h2><span id='topic+profile2d'></span><span id='topic+profile2d.maxstab'></span>

<h3>Description</h3>

<p>Computes profile surfaces for fitted max-stable models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxstab'
profile2d(fitted, params, ranges, n = 10, plot = TRUE,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile2d_+3A_fitted">fitted</code></td>
<td>
<p>An object of class &ldquo;maxstab&rdquo;. Most often, it will be
the output of the function <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>.</p>
</td></tr>
<tr><td><code id="profile2d_+3A_params">params</code></td>
<td>
<p>A character vector giving the two model parameters that
are to be profiled.</p>
</td></tr>
<tr><td><code id="profile2d_+3A_ranges">ranges</code></td>
<td>
<p>A matrix corresponding to the ranges for the profiled
model parameters that must be explored. Each row corresponds to
one model parameter range.</p>
</td></tr>
<tr><td><code id="profile2d_+3A_n">n</code></td>
<td>
<p>Integer. The number of profiled model parameter that must be
considered.</p>
</td></tr>
<tr><td><code id="profile2d_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), the profile surface is
plotted.</p>
</td></tr>
<tr><td><code id="profile2d_+3A_...">...</code></td>
<td>
<p>Extra options that must be passed to the
<code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two arguments: <code>coord</code> and <code>llik</code>. <code>coord</code>
is a matrix representing the grid where the profiled model parameters
are fixed. <code>llik</code> the corresponding pairwise log-likelihood.
</p>


<h3>Warnings</h3>

<p>This function can be <b>really</b> time consuming!
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##Define the coordinates of each location
n.site &lt;- 30
locations &lt;- matrix(rnorm(2*n.site, sd = sqrt(.2)), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(30, locations, cov.mod = "whitmat", nugget = 0, range = 30,
smooth = 0.5)

##Now define the spatial model for the GEV parameters
param.loc &lt;- -10 + 2 * locations[,2]
param.scale &lt;- 5 + 2 * locations[,1] + locations[,2]^2
param.shape &lt;- rep(0.2, n.site)

##Transform the unit Frechet margins to GEV
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i],
param.shape[i]) 

##Define a model for the GEV margins to be fitted
##shape ~ 1 stands for the GEV shape parameter is constant
##over the region
loc.form &lt;- loc ~ lat
scale.form &lt;- scale ~ lon + (lat^2)
shape.form &lt;- shape ~ 1

##Fit a max-stable process
##  1- using the Schlather representation
fitted &lt;- fitmaxstab(data, locations, "whitmat", loc.form, scale.form,
                     shape.form)

##Plot the profile pairwise log-likelihood for the smooth parameter
ranges &lt;- rbind(c(9,11), c(.3, .8))
profile2d(fitted, c("range", "smooth"), ranges = ranges)

## End(Not run)
</code></pre>

<hr>
<h2 id='qqextcoeff'>QQ-plot for the extremal coefficient</h2><span id='topic+qqextcoeff'></span>

<h3>Description</h3>

<p>This function compares the extremal coefficients estimated from a
fitted max-stable process to the ones estimated semi-parametrically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqextcoeff(fitted, estim = "ST", marge = "emp", xlab = "Semi-Empirical",
ylab = "Model", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqextcoeff_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>maxstab</code>. Most often, this will
be the output of <code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+fitcovmat">fitcovmat</a></code> or
<code><a href="#topic+fitcovariance">fitcovariance</a></code>.</p>
</td></tr>
<tr><td><code id="qqextcoeff_+3A_estim">estim</code>, <code id="qqextcoeff_+3A_marge">marge</code></td>
<td>
<p>The <code>estim</code> and <code>marge</code> options to be
passed to the <code><a href="#topic+fitextcoeff">fitextcoeff</a></code> function.</p>
</td></tr>
<tr><td><code id="qqextcoeff_+3A_xlab">xlab</code>, <code id="qqextcoeff_+3A_ylab">ylab</code></td>
<td>
<p>The x and y-axis labels.</p>
</td></tr>
<tr><td><code id="qqextcoeff_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A QQ-plot.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Schlather, M. (2002) Models for Stationary Max-Stable Random
Fields. <em>Extremes</em> <b>5</b>:1,  33&ndash;44.
</p>
<p>Schlather, M. and Tawn, J. A. (2003) A dependence measure for
multivariate and spatial extreme values: Properties and
inference. Biometrika <b>90</b>(1):139&ndash;156.
</p>
<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+fitextcoeff">fitextcoeff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinate of each location
n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 10, cov12 =
5, cov22 = 22)

fitted &lt;- fitmaxstab(data, locations, "gauss")
qqextcoeff(fitted)
</code></pre>

<hr>
<h2 id='qqgev'>QQ-plot for the GEV parameters</h2><span id='topic+qqgev'></span>

<h3>Description</h3>

<p>This function compares the GEV parameters estimated separately for
each location to the ones estimated from a fitted spatial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqgev(fitted, xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqgev_+3A_fitted">fitted</code></td>
<td>
<p>An object of class <code>maxstab</code> or
<code>spatgev</code>. Most often, this will be the output of
<code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+fitcovmat">fitcovmat</a></code>,
<code><a href="#topic+fitcovariance">fitcovariance</a></code> or <code><a href="#topic+fitspatgev">fitspatgev</a></code>.</p>
</td></tr>
<tr><td><code id="qqgev_+3A_xlab">xlab</code>, <code id="qqgev_+3A_ylab">ylab</code></td>
<td>
<p>The x and y-axis labels. May be missing.</p>
</td></tr>
<tr><td><code id="qqgev_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A QQ-plot.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Schlather, M. (2002) Models for Stationary Max-Stable Random
Fields. <em>Extremes</em> <b>5</b>:1,  33&ndash;44.
</p>
<p>Schlather, M. and Tawn, J. A. (2003) A dependence measure for
multivariate and spatial extreme values: Properties and
inference. Biometrika <b>90</b>(1):139&ndash;156.
</p>
<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqextcoeff">qqextcoeff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinate of each location
n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(50, locations, cov.mod = "gauss", cov11 = 100, cov12 =
25, cov22 = 220)

##Now define the spatial model for the GEV parameters
param.loc &lt;- -10 + 2 * locations[,2]
param.scale &lt;- 5 + 2 * locations[,1] + locations[,2]^2
param.shape &lt;- rep(0.2, n.site)

##Transform the unit Frechet margins to GEV 
for (i in 1:n.site)
  data[,i] &lt;- frech2gev(data[,i], param.loc[i], param.scale[i], param.shape[i])

##Define a model for the GEV margins to be fitted
##shape ~ 1 stands for the GEV shape parameter is constant
##over the region
loc.form &lt;- loc ~ lat
scale.form &lt;- scale ~ lon + I(lat^2)
shape.form &lt;- shape ~ 1

fitted &lt;- fitspatgev(data, locations, loc.form = loc.form, scale.form =
scale.form, shape.form = shape.form)

qqgev(fitted)
</code></pre>

<hr>
<h2 id='rainfall'>Summer annual maxima precipitation in Switzerland</h2><span id='topic+rainfall'></span>

<h3>Description</h3>

<p>Maximum daily rainfall amounts over the years 1962&ndash;2008 occuring
during June&ndash;August at 79 sites in Switzerland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rainfall)</code></pre>


<h3>Format</h3>

<p>This data set contains two R objects: 'rain' and 'coord'. 'rain'
is a 47 by 79 matrix giving the amount of rain in millimeters, each
column correspond to one locations. 'coord' is a 79 by 3 matrix giving
the longitude, latitude and the elevation for each station, all of
them being in meters.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rainfall)
op &lt;- par(mfrow = c(1,2),pty = "s", mar = c(0,0,0,0))
swiss(city = TRUE)
idx.site &lt;- c(1, 10, 20)
points(coord[-idx.site,])
points(coord[idx.site,], pch = 15, col = 2:4)

par(mar = c(2,4,0,0))
plot(1962:2008, rain[,1], type = "b", xlab = "Year", ylab =
"Precipitation (cm)", ylim = c(0, 120), col = 2)
lines(1962:2008, rain[,10], col = 3, type = "b")
lines(1962:2008, rain[,20], col = 4, type = "b")
par(op)
</code></pre>

<hr>
<h2 id='rb'>Creates a model using penalized smoothing splines</h2><span id='topic+rb'></span>

<h3>Description</h3>

<p>Creates a model using penalized smoothing splines using radial
basis functions  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rb(..., knots, degree, penalty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rb_+3A_...">...</code></td>
<td>
<p>The explicative variables for which the spline is based
on.</p>
</td></tr>
<tr><td><code id="rb_+3A_knots">knots</code></td>
<td>
<p>The coordinates of knots. See section details.</p>
</td></tr>
<tr><td><code id="rb_+3A_degree">degree</code></td>
<td>
<p>Numeric. The degree of the spline.</p>
</td></tr>
<tr><td><code id="rb_+3A_penalty">penalty</code></td>
<td>
<p>Numeric. The penalty coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If one explicative variable is given in &quot;...&quot;, the <code>knots</code>
should be a numeric vector. Otherwise, <code>knots</code> should be a matrix
with the same number of column and covariates.
</p>


<h3>Value</h3>

<p>A list giving all the required information to fit a penalized
smoothing spline:
</p>
<table>
<tr><td><code>dsgn.mat</code></td>
<td>
<p>The design matrix.</p>
</td></tr>
<tr><td><code>pen.mat</code></td>
<td>
<p>The penalization matrix.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>The degree of the smoothing spline.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>The penalty of the smoothing spline.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>The knots of the smoothing spline.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The explicative variables (e.g. covariates).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>How was the <code><a href="#topic+rb">rb</a></code> function was called?</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This function is not supposed to be called directly. <code><a href="#topic+rb">rb</a></code> is
supposed to be embedded in a R formula.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 30
locations &lt;- matrix(runif(2*n.site, 0, 10), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")
knots &lt;- quantile(locations[,2], 1:5/6)

form &lt;- y ~ rb(lat, knots = knots, degree = 3, penalty = .5)
</code></pre>

<hr>
<h2 id='rbpspline'>Fits a penalized spline with radial basis functions to data</h2><span id='topic+rbpspline'></span>

<h3>Description</h3>

<p>Fits a penalized spline with radial basis functions to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbpspline(y, x, knots, degree, penalty = "gcv", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbpspline_+3A_y">y</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code id="rbpspline_+3A_x">x</code></td>
<td>
<p>A vector/matrix giving the values of the predictor
variable(s). If <code>x</code> is a matrix, each row corresponds to one
observation.</p>
</td></tr>
<tr><td><code id="rbpspline_+3A_knots">knots</code></td>
<td>
<p>A vector givint the coordinates of the knots.</p>
</td></tr>
<tr><td><code id="rbpspline_+3A_degree">degree</code></td>
<td>
<p>The degree of the penalized smoothing spline.</p>
</td></tr>
<tr><td><code id="rbpspline_+3A_penalty">penalty</code></td>
<td>
<p>A numeric giving the penalty coefficient for the
penalization term. Alternatively, it could be either 'cv' or 'gcv'
to choose the <code>penalty</code> using the (generalized)
cross-validation criterion.</p>
</td></tr> 
<tr><td><code id="rbpspline_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="#topic+cv">cv</a></code>
or <code><a href="#topic+gcv">gcv</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The penalized spline with radial basis is defined by:
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \beta_0 + \beta_1 x + \ldots + \beta_{m-1} x^{m-1} +
    \sum_{k=0}^{K-1} \beta_{m+k} || x - \kappa_k ||^{2m - 1}</code>
</p>

<p>where <code class="reqn">\beta_i</code> are the coefficients to be estimated,
<code class="reqn">\kappa_i</code> are the coordinates of the i-th knot and
<code class="reqn">m = \frac{d+1}{2}</code> where <code class="reqn">d</code> corresponds to
the <code>degree</code> of the spline.
</p>
<p>The fitting criterion is to minimize
</p>
<p style="text-align: center;"><code class="reqn">||y - X\beta||^2 + \lambda^{2m-1} \beta^T K \beta</code>
</p>

<p>where <code class="reqn">\lambda</code> is the penalty coefficient and
<code class="reqn">K</code> the penalty matrix.  
</p>


<h3>Value</h3>

<p>An object of class <code>pspline</code>. 
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Ruppert, D. Wand, M.P. and Carrol, R.J. (2003) <em>Semiparametric
Regression</em> Cambridge Series in Statistical and Probabilistic
Mathematics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv">cv</a></code>, <code><a href="#topic+gcv">gcv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 200
x &lt;- runif(n)
fun &lt;- function(x) sin(3 * pi * x)
y &lt;- fun(x) + rnorm(n, 0, sqrt(0.4))
knots &lt;- quantile(x, prob = 1:(n/4) / (n/4 + 1))
fitted &lt;- rbpspline(y, x, knots = knots, degree = 3)
fitted

plot(x, y)
lines(fitted, col = 2)
</code></pre>

<hr>
<h2 id='rcopula'>Simulation from copula based models with unit Frechet margins</h2><span id='topic+rcopula'></span>

<h3>Description</h3>

<p>This function generates realisations from the Gaussian and Student
copula with unit Frechet margins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcopula(n, coord, copula = "gaussian", cov.mod = "whitmat", grid =
FALSE, control = list(), nugget = 0, range = 1, smooth = 1, DoF = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcopula_+3A_n">n</code></td>
<td>
<p>Integer. The number of observations.</p>
</td></tr>
<tr><td><code id="rcopula_+3A_coord">coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of each
location. Each row corresponds to one location - if any</p>
</td></tr>
<tr><td><code id="rcopula_+3A_copula">copula</code></td>
<td>
<p>A character string that specifies the copula to be used,
i.e., &quot;gaussian&quot; or &quot;student&quot;.</p>
</td></tr>
<tr><td><code id="rcopula_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string that gives the correlation function
family to be used. This must be one of &quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot;
and &quot;bessel&quot; for the Whittle-Matern, the cauchy, the powered
exponential and the bessel correlation functions.</p>
</td></tr>
<tr><td><code id="rcopula_+3A_grid">grid</code></td>
<td>
<p>Logical. Does the coordinates represent grid points?</p>
</td></tr>
<tr><td><code id="rcopula_+3A_control">control</code></td>
<td>
<p>A named list that control the simulation of the
gaussian process &mdash; see <code><a href="#topic+rgp">rgp</a></code>.</p>
</td></tr>
<tr><td><code id="rcopula_+3A_nugget">nugget</code>, <code id="rcopula_+3A_range">range</code>, <code id="rcopula_+3A_smooth">smooth</code>, <code id="rcopula_+3A_dof">DoF</code></td>
<td>
<p>Numerics. The parameters of the
copula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing observations from the required max-stable
model. Each column represents one stations. If <code>grid = TRUE</code>, the
function returns an array of dimension nrow(coord) x nrow(coord) x n.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet
</p>


<h3>References</h3>

<p>Demarta, S. and McNeil, A. J. (2005) The t Copula and Related Copulas
<em>International Statistical Review</em> <b>73</b>:1, 111&ndash;129.
</p>
<p>Davison, A. C., Padoan, S. A. and Ribatet, M. (2010) Statistical
Modelling of Spatial Extremes <em>Submitted to Statistical
Science</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitcopula">fitcopula</a></code>, <code><a href="#topic+rmaxstab">rmaxstab</a></code>, <code><a href="#topic+rmaxlin">rmaxlin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 25
n.obs &lt;- 50

coord &lt;- matrix(runif(2 * n.site, 0, 10), ncol = 2)

data1 &lt;- rcopula(n.obs, coord, "student", "whitmat", range = 3, DoF = 3)

x &lt;- y &lt;- seq(0, 10, length = 100)
data2 &lt;- rcopula(1, cbind(x, y), "gaussian", "whitmat", range = 3, grid
= TRUE)
image(x, y, log(data2), col = rainbow(64))
</code></pre>

<hr>
<h2 id='rgp'>
Gaussian Random Fields Simulation
</h2><span id='topic+rgp'></span>

<h3>Description</h3>

<p>This functions generates gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgp(n, coord, cov.mod = "powexp", mean = 0, nugget = 0, sill = 1, range
= 1, smooth = 1, grid = FALSE, control = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgp_+3A_n">n</code></td>
<td>
<p>Integer. The number of replications.</p>
</td></tr>
<tr><td><code id="rgp_+3A_coord">coord</code></td>
<td>
<p>The locations coordinates for which the gaussian process
is observed.</p>
</td></tr>
<tr><td><code id="rgp_+3A_cov.mod">cov.mod</code></td>
<td>
<p>Character string. The covariance model used. Must be
one of &quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot; of &quot;cauchy&quot;. See the
<code><a href="#topic+covariance">covariance</a></code> function.</p>
</td></tr>
<tr><td><code id="rgp_+3A_mean">mean</code></td>
<td>
<p>Numeric. The mean of the gaussian random field.</p>
</td></tr>
<tr><td><code id="rgp_+3A_nugget">nugget</code></td>
<td>
<p>Numeric. The nugget of the gaussian random field.</p>
</td></tr>
<tr><td><code id="rgp_+3A_sill">sill</code></td>
<td>
<p>Numeric. The sill parameter in the covariance function.</p>
</td></tr>
<tr><td><code id="rgp_+3A_range">range</code></td>
<td>
<p>Numeric. The range parameter in the covariance function.</p>
</td></tr>
<tr><td><code id="rgp_+3A_smooth">smooth</code></td>
<td>
<p>Numeric. The smooth parameter in the covariance function.</p>
</td></tr>
<tr><td><code id="rgp_+3A_grid">grid</code></td>
<td>
<p>Logical. Does <code>coord</code> defines a grid?</p>
</td></tr>
<tr><td><code id="rgp_+3A_control">control</code></td>
<td>
<p>A named list with arguments 'nlines' (number of lines
of the TBM simulation) and 'method' the name of the simulation
method - must be one of 'exact', 'tbm' or 'circ'. If 'method' is
<code>NULL</code> (default), the function tries to find the most
appropriate simulation technique. If 'nlines' is <code>NULL</code> it is
set to 1000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or an array containing the random field replicates.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet
</p>


<h3>See Also</h3>

<p><code>link{rmaxstab}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- y &lt;- seq(0, 20, length = 100)
coord &lt;- cbind(x, y)
gp &lt;- rgp(1, coord, cov.mod = "whitmat", grid = TRUE)
filled.contour(x, y, gp, color.palette = terrain.colors)
</code></pre>

<hr>
<h2 id='rmaxlin'>Simulation from max-linear models</h2><span id='topic+rmaxlin'></span>

<h3>Description</h3>

<p>This function generates realisations from a max-linear
model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmaxlin(n, coord, cov.mod = "gauss", dsgn.mat, grid = FALSE, p = 500,
...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmaxlin_+3A_n">n</code></td>
<td>
<p>Integer. The number of observations.</p>
</td></tr>
<tr><td><code id="rmaxlin_+3A_coord">coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of each
location. Each row corresponds to one location - if any. May be
missing if <code>dsgn.mat</code> is specified.</p>
</td></tr>
<tr><td><code id="rmaxlin_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string that specifies the max-linear
model. Currently only the discretized Smith model is implemented,
i.e., <code>cov.mod = "gauss"</code>.</p>
</td></tr>
<tr><td><code id="rmaxlin_+3A_dsgn.mat">dsgn.mat</code></td>
<td>
<p>The design matrix of the max-linear model &mdash; see
Section Details. May be missing if <code>coord</code> and <code>cov.mod</code>
are given.</p>
</td></tr>
<tr><td><code id="rmaxlin_+3A_grid">grid</code></td>
<td>
<p>Logical. Does <code>coord</code> defines a grid?</p>
</td></tr>
<tr><td><code id="rmaxlin_+3A_p">p</code></td>
<td>
<p>An integer corresponding to the number of unit Frechet random
variable used in the max-linear model &mdash; see Section Details.</p>
</td></tr>
<tr><td><code id="rmaxlin_+3A_...">...</code></td>
<td>
<p>The parameters of the max-stable model &mdash; see Section
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A max-linear process <code class="reqn">\{Y(x)\}</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">Y(x) = \max_{j=1, \ldots, p} f_j(x) Z_j, \qquad x \in
    R^d,</code>
</p>

<p>where <code class="reqn">p</code> is a positive integer, <code class="reqn">f_j</code> are non
negative functions and <code class="reqn">Z_j</code> are independent unit Frechet
random variables. Most often, the max-linear process will be generated
at locations <code class="reqn">x_1, \ldots, x_k \in R^d</code> and an alternative but equivalent formulation is
</p>
<p style="text-align: center;"><code class="reqn">\bf{Y} = A \odot \bf{Z},</code>
</p>
<p> where <code class="reqn">\mathbf{Y} =
    \{Y(x_1), \ldots, Y(x_k)\}</code>,
<code class="reqn">\mathbf{Z} = (Z_1, \ldots, Z_p)</code>,
<code class="reqn">\odot</code> is the max-linear operator, see the first equation, and
<code class="reqn">A</code> is the design matrix of the max-linear model. The design
matrix <code class="reqn">A</code> is a <code class="reqn">k \times p</code> matrix with non
negative entries and whose <code class="reqn">i</code>-th row is <code class="reqn">\{f_1(x_i),
    \ldots, f_p(x_i)\}</code>.
</p>
<p>Currently only the discretized Smith model is implemented for which
<code class="reqn">f_j(x) = c(p) \varphi(x - u_j ; \Sigma)</code> where <code class="reqn">\varphi(\cdot; \Sigma)</code> is the
zero mean (multivariate) normal density with covariance matrix
<code class="reqn">\Sigma</code>, <code class="reqn">u_j</code> is a sequence of deterministic
points appropriately chosen and <code class="reqn">c(p)</code> is a constant
ensuring unit Frechet margins. Hence if this max-linear model is used,
users must specify <code>var</code> for one dimensional processes, and
<code>cov11</code>, <code>cov12</code>, <code>cov22</code> for two dimensional
processes.
</p>


<h3>Value</h3>

<p>A matrix containing observations from the max-linear model. Each
column represents one stations. If <code>grid = TRUE</code>, the function
returns an array of dimension nrow(coord) x nrow(coord) x n.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Wang, Y. and Stoev, S. A. (2011) Conditional Sampling for Max-Stable
Random Fields. <em>Advances in Applied Probability</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condrmaxlin">condrmaxlin</a></code>, <code><a href="#topic+rmaxstab">rmaxstab</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A one dimensional simulation from a design matrix. This design matrix
## corresponds to a max-moving average process MMA(alpha)
n.site &lt;- 250
x &lt;- seq(-10, 10, length = n.site)

## Build the design matrix
alpha &lt;- 0.8
dsgn.mat &lt;- matrix(0, n.site, n.site)
dsgn.mat[1,1] &lt;- 1

for (i in 2:n.site){
dsgn.mat[i,1:(i-1)] &lt;- alpha * dsgn.mat[i-1,1:(i-1)]
dsgn.mat[i,i] &lt;- 1 - alpha
}

data &lt;- rmaxlin(3, dsgn.mat = dsgn.mat)
matplot(x, t(log(data)), pch = 1, type = "l", lty = 1, ylab =
expression(log(Y(x))))

## One realisation from the discretized Smith model (2d sim)
x &lt;- y &lt;- seq(-10, 10, length = 100)
data &lt;- rmaxlin(1, cbind(x, y), cov11 = 3, cov12 = 1, cov22 = 4, grid =
TRUE, p = 2000)
image(x, y, log(data), col = heat.colors(64))
</code></pre>

<hr>
<h2 id='rmaxstab'>Simulation of Max-Stable Random Fields</h2><span id='topic+rmaxstab'></span>

<h3>Description</h3>

<p>This function generates realisation from a max-stable
random field.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmaxstab(n, coord, cov.mod = "gauss", grid = FALSE, control =
list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmaxstab_+3A_n">n</code></td>
<td>
<p>Integer. The number of observations.</p>
</td></tr>
<tr><td><code id="rmaxstab_+3A_coord">coord</code></td>
<td>
<p>A vector or matrix that gives the coordinates of each
location. Each row corresponds to one location - if any.</p>
</td></tr>
<tr><td><code id="rmaxstab_+3A_cov.mod">cov.mod</code></td>
<td>
<p>A character string that gives the max-stable
model. This must be one of &quot;gauss&quot; for the Smith model, &quot;brown&quot; for
the Brown&ndash;Resnick model,  or &quot;whitmat&quot;, &quot;cauchy&quot;, &quot;powexp&quot; and
&quot;bessel&quot; for the Schlather model with the given  correlation
family. If the latters are prefix by a &quot;t&quot;, e.g., &quot;twhitmat&quot;, this
would corresponds to the extremal-t model.</p>
</td></tr>
<tr><td><code id="rmaxstab_+3A_grid">grid</code></td>
<td>
<p>Logical. Does the coordinates represent grid points?</p>
</td></tr>
<tr><td><code id="rmaxstab_+3A_control">control</code></td>
<td>
<p>A named list with arguments 'nlines' (number of lines
of the TBM simulation), 'method' the name of the simulation
method - must be one of 'exact', 'tbm' or 'circ', and 'uBound' the
uniform upper bound. See details.</p>
</td></tr>
<tr><td><code id="rmaxstab_+3A_...">...</code></td>
<td>
<p>The parameters of the max-stable model. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users must supply the parameters for the max-stable model. For the
Schlather model, users should supply the &quot;nugget&quot;, &quot;range&quot; and &quot;smooth&quot;
parameter values. For the Smith model, if <code>coord</code> is univariate
you must specify <code>var</code>, otherwise users should supply the
covariance parameters i.e. parameters with names such as <code>cov11</code>,
<code>cov12</code>, ... For the extremal-t model, users should supply the
&quot;DoF&quot;, &quot;nugget&quot;, &quot;range&quot; and &quot;smooth&quot; parameters. Finally for the
Brown&ndash;Resnick model, users should supply the &quot;range&quot; and the &quot;smooth&quot;
parameters.
</p>
<p>Here are the details for each allowed components of 'control'. If
'method' is <code>NULL</code> (default), the function tries to find the 
most appropriate simulation technique. Current simulation techniques
are a direct approach, i.e. Cholesky decomposition of the covariance
matrix, the turning bands and the circular embedding methods. If
'nlines' is <code>NULL</code>, it is set to 1000. If 'uBound' is
<code>NULL</code>, it is set to reasonable values - for example 3.5 for the
Schlather model.
</p>


<h3>Value</h3>

<p>A matrix containing observations from the required max-stable
model. Each column represents one stations. If <code>grid = TRUE</code>, the
function returns an array of dimension nrow(coord) x nrow(coord) x n.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Schlather, M. (2002) Models for Stationary Max-Stable Random
Fields. <em>Extremes</em> <b>5</b>:1,  33&ndash;44.
</p>
<p>Smith, R. L. (1990) Max-stable processes and spatial
extremes. Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1. Smith's model
set.seed(8)
x &lt;- y &lt;- seq(0, 10, length = 100)
coord &lt;- cbind(x, y)
data &lt;- rmaxstab(1, coord, "gauss", cov11 = 9/8, cov12 = 0, cov22 = 9/8,
  grid = TRUE)
##We change to unit Gumbel margins for visibility
filled.contour(x, y, log(data), color.palette = terrain.colors)

## 2. Schlather's model
data &lt;- rmaxstab(1, coord, cov.mod = "powexp", nugget = 0, range = 3,
smooth = 1, grid = TRUE)
filled.contour(x, y, log(data), color.palette = terrain.colors)

## 3. Brown--Resnick's model **** Only available for non gridded points currently ****
data &lt;- rmaxstab(1, x, cov.mod = "brown", range = 3, smooth = 0.5)
plot(x, log(data), type = "l")

## 4. Extremal-t model *** Very time consuming for 2d grids ***
data &lt;- rmaxstab(1, x, "twhitmat", DoF = 4, nugget = 0, range = 3,
smooth = 0.7)
plot(x, log(data), type = "l")
</code></pre>

<hr>
<h2 id='SpatialExtremes'>Analysis of Spatial Extremes</h2><span id='topic+SpatialExtremes'></span>

<h3>Description</h3>

<p>The package <span class="pkg">SpatialExtremes</span> aims to provide tools for the
analysis of spatial extremes. Currently, the package uses the
max-stable processes framework for the modelling of spatial extremes.
</p>
<p>Max-stable processes are the extension of the extreme value theory to
random fields. Consequently, they are good candidate to the analysis
of spatial extremes. The strategy used in this package is to fit
max-stable processes to data using composite likelihood.
</p>
<p>In the future, the package will allow for non-stationarity as well as
other approaches to model spatial extremes; namely latent variable and
copula based approaches.
</p>
<p>A package vignette has been writen to help new users. It can be
viewed, from the R console, by invoking
<code>vignette("SpatialExtremesGuide")</code>.
</p>


<h3>Details</h3>

<p>The package provides the following main tools:
</p>

<ol>
<li> <p><code><a href="#topic+rgp">rgp</a>, <a href="#topic+rmaxstab">rmaxstab</a>, <a href="#topic+rmaxlin">rmaxlin</a>,
      <a href="#topic+rcopula">rcopula</a></code>: simulates gaussian, max-stable, max-linear and copula
based random fields,
</p>
</li>
<li> <p><code><a href="#topic+condrgp">condrgp</a>, <a href="#topic+condrmaxlin">condrmaxlin</a></code>: conditional simulations for
gaussian, max-linear processes,
</p>
</li>
<li> <p><code><a href="#topic+fitspatgev">fitspatgev</a></code>: fits a spatial GEV model to data,
</p>
</li>
<li> <p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="#topic+lsmaxstab">lsmaxstab</a></code>: fits
max-stable processes to data,
</p>
</li>
<li> <p><code><a href="#topic+latent">latent</a></code>: draws a Markov chain from a Bayesian
hierarchical model for spatial extremes,
</p>
</li>
<li> <p><code><a href="#topic+predict.maxstab">predict</a></code>: allows predictions
for fitted max-stable processes,
</p>
</li>
<li> <p><code><a href="#topic+map">map</a></code>, <code><a href="#topic+condmap">condmap</a></code>: plot a map for GEV
parameter as well as return levels - or conditional return levels
</p>
</li>
<li> <p><code><a href="#topic+anova.maxstab">anova</a></code>, <code><a href="#topic+TIC">TIC</a></code>,
<code><a href="#topic+DIC">DIC</a></code>: help users in model selection,
</p>
</li>
<li> <p><code><a href="#topic+madogram">madogram</a></code>, <code><a href="#topic+fmadogram">fmadogram</a></code>,
<code><a href="#topic+lmadogram">lmadogram</a></code>: are (kind of) variograms devoted to extremes,
</p>
</li>
<li> <p><code><a href="#topic+fitextcoeff">fitextcoeff</a></code>: estimates semi-parametrically the
extremal coefficient,
</p>
</li>
<li> <p><code><a href="#topic+extcoeff">extcoeff</a></code>: plots the evolution of the extremal
coefficient from a fitted max-stable process,
</p>
</li>
<li> <p><code><a href="#topic+rbpspline">rbpspline</a></code>: fits a penalized spline with radial
basis function,
</p>
</li>
<li> <p><code><a href="#topic+gev2frech">gev2frech</a></code>, <code><a href="#topic+frech2gev">frech2gev</a></code>: transform
GEV (resp. Frechet) observation to unit Frechet (resp. GEV) ones
</p>
</li>
<li> <p><code><a href="#topic+gevmle">gevmle</a></code>, <code><a href="#topic+gpdmle">gpdmle</a></code>: fit the GEV/GPD
distributions to data,
</p>
</li>
<li> <p><code><a href="#topic+distance">distance</a></code>: computes the distance between each
pair of locations,
</p>
</li>
<li> <p><code><a href="#topic+profile.maxstab">profile</a></code>,
<code><a href="#topic+profile2d.maxstab">profile2d</a></code>: computes the profile
composite likelihood,
</p>
</li>
<li> <p><code><a href="#topic+covariance">covariance</a></code>, <code><a href="#topic+variogram">variogram</a></code>: computes
the covariance/semivariogram function.
</p>
</li></ol>



<h3>Acknowledgement</h3>

<p>The development of the package has been financially supported by the
Competence Center Environment and Sustainability (CCES) and more
precisely within the EXTREMES project.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>

<hr>
<h2 id='swiss'>
Map of the Switzerland.
</h2><span id='topic+swiss'></span>

<h3>Description</h3>

<p>Plot a map of Switzerland and optionnaly some cities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swiss(city = FALSE, add = FALSE, axes = FALSE, km = TRUE, xlab = "",
ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swiss_+3A_city">city</code></td>
<td>
<p>Logical. It <code>TRUE</code>, some city are displayed. Default
is to omit.</p>
</td></tr>
<tr><td><code id="swiss_+3A_add">add</code></td>
<td>
<p>Logical. Should the map be added to an existing plot?</p>
</td></tr>
<tr><td><code id="swiss_+3A_axes">axes</code></td>
<td>
<p>Logical. Should the axis be displayed?</p>
</td></tr>
<tr><td><code id="swiss_+3A_km">km</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default) the longitude and latitude
are expressed in kilometers. Otherwise it is in meters.</p>
</td></tr>
<tr><td><code id="swiss_+3A_xlab">xlab</code>, <code id="swiss_+3A_ylab">ylab</code></td>
<td>
<p>The x and y-axis labels.</p>
</td></tr>
<tr><td><code id="swiss_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphic window.
</p>


<h3>Author(s)</h3>

<p>Dominik Schaub</p>


<h3>Examples</h3>

<pre><code class='language-R'>swiss()
</code></pre>

<hr>
<h2 id='swissalt'>Elevation in Switzerland</h2><span id='topic+swissalt'></span>

<h3>Description</h3>

<p>Data required for plotting a Switzerland map with elevation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissalt)</code></pre>


<h3>Format</h3>

<p>This data set contains three R objects. 'alt.mat' is a 192 by
115 matrix giving the elevation at the grid points defined by
'lon.vec' and 'lat.vec'.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swissalt)

layout(matrix(c(1,2), 1), width = c(3.5,1))
mar &lt;- rep(0, 4)
op &lt;- par(mar = mar)
breaks &lt;- seq(0, 2000, by = 250)
image(lon.vec, lat.vec, alt.mat, col = terrain.colors(length(breaks) - 1),
      xaxt = "n", yaxt = "n", bty = "n", xlab = "", ylab = "", xlim =
c(480, 840), ylim = c(58, 300))
swiss(add = TRUE, city = TRUE)

##Heat bar
mar &lt;- c(3, 3, 3, 4)
par(las = 1, mar = mar)

plot.new()
plot.window(xlim = c(0, 1), ylim = range(breaks), xaxs = "i", 
            yaxs = "i")
rect(0, breaks[-length(breaks)], 1, breaks[-1], col = terrain.colors(length(breaks) - 1),
     border = NA)
axis(4, at = breaks[-length(breaks)])
box()
title("Elevation\n(meters)")
par(op)
</code></pre>

<hr>
<h2 id='symbolplot'>Detecting spatial trends graphically</h2><span id='topic+symbolplot'></span>

<h3>Description</h3>

<p>This function performs a symbol plot to help in identifying
any spatial trends</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolplot(data, coord, which = "gev", plot.border = NULL,
 col = c("#FF000080", "#0000FF80"), plot.legend = TRUE, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolplot_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="symbolplot_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="symbolplot_+3A_which">which</code></td>
<td>
<p>A character string specifying which values should be
plotted. Must be one of &quot;gev&quot; (for the GEV marginal parameters),
&quot;mean&quot; for pointwise mean or &quot;median&quot; for pointwise median.</p>
</td></tr>
<tr><td><code id="symbolplot_+3A_plot.border">plot.border</code></td>
<td>
<p>An R function that plots the border of the study
region. If <code>NULL</code> (default) no border is plotted.</p>
</td></tr>
<tr><td><code id="symbolplot_+3A_col">col</code></td>
<td>
<p>A vector of length 2 giving the colors to be used to fill
the circles.</p>
</td></tr>
<tr><td><code id="symbolplot_+3A_plot.legend">plot.legend</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a legend is
added to the plot.</p>
</td></tr>
<tr><td><code id="symbolplot_+3A_scale">scale</code></td>
<td>
<p>Positive number. It enables to enlarge (if scale &gt; 1) or
reduce (if 0 &lt; scale &lt; 1) the radius of the plotted circles to get a
better display.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will plot several circles whose center is located at the
weather stations and whose radius is proportional to the departure of
the value at that position to the areal mean value.
</p>


<h3>Value</h3>

<p>A plot.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Symbol plot for the Swiss rainfall data set
data(rainfall)
symbolplot(rain, coord, plot.border = swiss)
</code></pre>

<hr>
<h2 id='TIC'>Takeuchi's information criterion</h2><span id='topic+TIC'></span><span id='topic+TIC.default'></span>

<h3>Description</h3>

<p>Computes a the Takeuchi's information criterion which is equivalent to
the AIC when the model is miss-specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TIC_+3A_object">object</code></td>
<td>
<p>An object of class <code>maxstab</code> or
<code>spatgev</code>. Often, it will be the output of the
<code><a href="#topic+fitmaxstab">fitmaxstab</a></code> or <code><a href="#topic+fitspatgev">fitspatgev</a></code> function.</p>
</td></tr>
<tr><td><code id="TIC_+3A_...">...</code></td>
<td>
<p>Additional objects of class <code>maxstab</code> or
<code>spatgev</code> for which TIC should be computed.</p>
</td></tr>
<tr><td><code id="TIC_+3A_k">k</code></td>
<td>
<p>Numeric. The penalty per parameter to be used. The case k = 2
(default) correspond to the classical TIC and <code class="reqn">k = \log n</code>, n number of observations, is the robust version of the
BIC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TIC is like AIC so that when comparing models one wants to get the
lowest TIC score.
</p>


<h3>Value</h3>

<p>Numeric.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>References</h3>

<p>Gao, X. and Song, P. X.-K. (2009) Composite likelihood Bayesian
information criteria for model selection in high dimensional
data. Preprint.
</p>
<p>Sakamoto, Y., Ishiguro, M., and Kitagawa G. (1986) Akaike Information
Criterion Statistics. D. Reidel Publishing Company.
</p>
<p>Varin, C. and Vidoni, P. (2005) A note on composite likelihood
inference and model selection. Biometrika <b>92</b>(3):519&ndash;528.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitmaxstab">fitmaxstab</a></code>, <code><a href="stats.html#topic+AIC">AIC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Define the coordinate of each location
n.site &lt;- 50
locations &lt;- matrix(runif(2*n.site, 0, 100), ncol = 2)
colnames(locations) &lt;- c("lon", "lat")

##Simulate a max-stable process - with unit Frechet margins
data &lt;- rmaxstab(40, locations, cov.mod = "whitmat", nugget = 0.2, range =
30, smooth = 0.5)

M0 &lt;- fitmaxstab(data, locations, "powexp", fit.marge = FALSE)
M1 &lt;- fitmaxstab(data, locations, "cauchy", fit.marge = FALSE)

TIC(M0, M1)
TIC(M0, M1, k = log(nrow(data)))
</code></pre>

<hr>
<h2 id='USHCNTemp'>Summer/Winter annual maxima/minima temperature in continental US.</h2><span id='topic+USHCNTemp'></span>

<h3>Description</h3>

<p>Summer maxima/Winter minima temperatures over the years 1911&ndash;2010
observed at 424 weather stations located in continental USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USHCNTemp)</code></pre>


<h3>Format</h3>

<p>This data set contains three R objects: 'maxima.summer',
'minima.winter' and 'metadata'. 'maxima.summer' is a 100 by 424 matrix
giving the temperature in degrees, each column correspond to one
location. 'minima.winter is a 99 by 424 matrix giving the temperature
in degrees, each column correspond to one location. 'metadata' is a
424 by 5 data frame giving station identifier, the longitude,
latitude, elevation and the state for each station.</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USHCNTemp)
##require(maps) ## &lt;&lt;-- to plot US borders
maps::map("usa")
plot(metadata[,2:3], pch = 15)
</code></pre>

<hr>
<h2 id='variogram'>
Empirical variogram
</h2><span id='topic+variogram'></span>

<h3>Description</h3>

<p>This function computes the empirical variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogram(data, coord, n.bins, xlab, ylab, angles = NULL, add = FALSE,
xlim = c(0, max(dist)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogram_+3A_data">data</code></td>
<td>
<p>A matrix representing the data. Each column corresponds to
one location.</p>
</td></tr>
<tr><td><code id="variogram_+3A_coord">coord</code></td>
<td>
<p>A matrix that gives the coordinates of each
location. Each row corresponds to one location.</p>
</td></tr>
<tr><td><code id="variogram_+3A_n.bins">n.bins</code></td>
<td>
<p>The number of bins to be used. If missing, pairwise
madogram estimates will be computed.</p>
</td></tr>
<tr><td><code id="variogram_+3A_xlab">xlab</code>, <code id="variogram_+3A_ylab">ylab</code></td>
<td>
<p>The x-axis and y-axis labels. May be missing. Note
that <code>ylab</code> must have the same length has <code>which</code>.</p>
</td></tr>
<tr><td><code id="variogram_+3A_angles">angles</code></td>
<td>
<p>A numeric vector. A partition of the interval
<code class="reqn">(0, \pi)</code> to help detecting anisotropy.</p>
</td></tr>
<tr><td><code id="variogram_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plot is added to the current
figure; otherwhise (default) a new plot is computed.</p>
</td></tr>
<tr><td><code id="variogram_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 specifying the x coordinate
range.</p>
</td></tr> 
<tr><td><code id="variogram_+3A_...">...</code></td>
<td>
<p>Additional options to be passed to the <code><a href="graphics.html#topic+plot">plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graphic and (invisibly) a matrix with the lag distances and the
empirical variogram estimates.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmadogram">fmadogram</a></code>, <code><a href="#topic+lmadogram">lmadogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n.site &lt;- 20
n.obs &lt;- 100
coord &lt;- matrix(runif(2 * n.site, 0, 10), ncol = 2)
data &lt;- rgp(n.obs, coord, "powexp", sill = 2, range = 3, smooth = 1)
variogram(data, coord)
</code></pre>

<hr>
<h2 id='vdc'>
Van der Corput Sequence
</h2><span id='topic+vdc'></span>

<h3>Description</h3>

<p>This function generates the three dimensional Van der Corput sequence
on the half unit Sphere of <code class="reqn">R^3</code> - eventually randomly
rotated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdc(n, rand.rot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdc_+3A_n">n</code></td>
<td>
<p>Integer. The length of the sequence.</p>
</td></tr>
<tr><td><code id="vdc_+3A_rand.rot">rand.rot</code></td>
<td>
<p>Logical. Should the sequence be randomly rotated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix giving the coordinates of the points in the half unit sphere.
</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet
</p>


<h3>References</h3>

<p>Freulon, X., de Fouquet, C., 1991. Remarques sur la pratique des bandes
tournantes a trois dimensions. Cahiers de geostatistique, Fascicule
1, Centre de Geostatistique, Ecole des Mines de Paris, Fontainebleau,
pp. 101&ndash;117.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vdc(10)
</code></pre>

<hr>
<h2 id='wind'>Annual maxima wind gusts in the Netherlands.</h2><span id='topic+wind'></span>

<h3>Description</h3>

<p>Annual maxima wind gusts (km/h) in the Netherlands recorded at 35
weather stations over the period 1971&ndash;2012.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wind)</code></pre>


<h3>Format</h3>

<p>This data set contains two R objects: 'coord' and 'wind'. 'wind'
is a 42 by 35 matrix giving the wind gust speeds in km/h&mdash;with
missing values, each column correspond to one location. 'coord' is a
35 by 3 matrix giving the longitude (degree), latitude (degree) and
elevation (m).</p>


<h3>Author(s)</h3>

<p>Mathieu Ribatet</p>


<h3>Examples</h3>

<pre><code class='language-R'>##require(maps)
data(wind)
par(mar = rep(0, 4))
maps::map(xlim = c(0, 9), ylim = c(47.5, 57.5))
points(coord[,1:2], pch = 15)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
