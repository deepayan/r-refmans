<!DOCTYPE html><html lang="en"><head><title>Help for package sbrl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sbrl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sbrl-package'>
<p>SCALABLE BAYESIAN RULE LISTS</p></a></li>
<li><a href='#get_data_feature_mat'>
<p>GET BINARY MATRIX REPRESENTATION OF THE DATA-FEATURE RELAITONSHIP</p></a></li>
<li><a href='#predict.sbrl'>
<p>PREDICT THE POSITIVE PROBABILITY FOR THE OBSERVATIONS</p></a></li>
<li><a href='#print.sbrl'>
<p>INTERPRETABLE VERSION OF A SBRL MODEL</p></a></li>
<li><a href='#sbrl'>
<p>fit the scalable bayesian rule lists model</p></a></li>
<li><a href='#tictactoe'>
<p>SHUFFLED TIC-TAC-TOE-ENDGAME DATASET</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scalable Bayesian Rule Lists Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Hongyu Yang [aut, cre],
  Morris Chen [ctb],
  Cynthia Rudin [aut, ctb],
  Margo Seltzer [aut, ctb],
  The President and Fellows of Harvard College [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hongyu Yang &lt;edwardyhy1@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An efficient implementation of Scalable Bayesian Rule Lists Algorithm, a competitor algorithm for decision tree algorithms; see Hongyu Yang, Cynthia Rudin, Margo Seltzer (2017) <a href="https://proceedings.mlr.press/v70/yang17h.html">https://proceedings.mlr.press/v70/yang17h.html</a>. It builds from pre-mined association rules and have a logical structure identical to a decision list or one-sided decision tree. Fully optimized over rule lists, this algorithm strikes practical balance between accuracy, interpretability, and computational speed.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.4), arules, methods</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>sbrl</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp (&gt;= 4.2.0), gsl</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 07:56:33 UTC; hongyuy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sbrl-package'>
SCALABLE BAYESIAN RULE LISTS
</h2><span id='topic+sbrl-package'></span>

<h3>Description</h3>

<p>Fit a <code>sbrl</code> model. 
Learn from the data and create a decision rule list in the format of:
</p>
<p>if (condition1) then positive probability = ... 
</p>
<p>else if (condition2) then positive probability = ... 
</p>
<p>else if (condition3) ... 
</p>
<p>... 
</p>
<p>else (default rule) then positive probability = ... 
</p>
<p>( See the examples below )
</p>


<h3>Details</h3>

<p>This package contains three functions: <code><a href="#topic+sbrl">sbrl</a></code>, <code><a href="#topic+print.sbrl">print.sbrl</a></code>, <code><a href="#topic+show.sbrl">show.sbrl</a></code>, and <code><a href="#topic+predict.sbrl">predict.sbrl</a></code>
</p>


<h3>Author(s)</h3>

<p>Hongyu Yang, Cynthia Rudin, Margo Seltzer
</p>


<h3>References</h3>

<p>Hongyu Yang, Morris Chen, Cynthia Rudin, Margo Seltzer (2016)
<em>Scalable Bayesian Rule Lists.</em>
Working paper on arXiv 2016.
</p>
<p>Benjamin Letham, Cynthia Rudin, Tyler McCormick and David Madigan (2015)
<em>Building Interpretable Classifiers with Rules using Bayesian Analysis.</em>
Annals of Applied Statistics, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbrl">sbrl</a></code>, <code><a href="#topic+print.sbrl">print.sbrl</a></code>, <code><a href="#topic+show.sbrl">show.sbrl</a></code> and <code><a href="#topic+predict.sbrl">predict.sbrl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us use the titactoe dataset
data(tictactoe)
for (name in names(tictactoe)) {tictactoe[name] &lt;- as.factor(tictactoe[,name])}

# Train on two-thirds of the data
b = round(2*nrow(tictactoe)/3, digit=0)
data_train &lt;- tictactoe[1:b, ]
# Test on the remaining one third of the data
data_test &lt;- tictactoe[(b+1):nrow(tictactoe), ]
# data_train, data_test are dataframes with factor columns
# The class column is "label"

# Run the sbrl algorithm on the training set
  sbrl_model &lt;- sbrl(data_train, iters=20000, pos_sign="1",
   neg_sign="0", rule_minlen=1, rule_maxlen=3, 
   minsupport_pos=0.10, minsupport_neg=0.10, 
   lambda=10.0, eta=1.0, nchain=25)
  print(sbrl_model)

# Make predictions on the test set
  yhat &lt;- predict(sbrl_model, data_test)
# yhat will be a list of predicted negative and positive probabilities for the test data. 

#clean up
rm(list = ls())
gc()
</code></pre>

<hr>
<h2 id='get_data_feature_mat'>
GET BINARY MATRIX REPRESENTATION OF THE DATA-FEATURE RELAITONSHIP
</h2><span id='topic+get_data_feature_mat'></span>

<h3>Description</h3>

<p>Given some features in the form &quot;feature1=x1&quot;, &quot;feature2=x2&quot;..., this function will generate a matrix representation of which data are captured by which features. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data_feature_mat(data, featurenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_data_feature_mat_+3A_data">data</code></td>
<td>
<p> a data.frame representing the observations.
</p>
</td></tr>
<tr><td><code id="get_data_feature_mat_+3A_featurenames">featurenames</code></td>
<td>

<p>a character vector representing the features in the form: &quot;feature1=x1&quot;, &quot;feature2=x2&quot;...
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a binary matrix of size #observations-by-#featurenames
</p>


<h3>Author(s)</h3>

<p>Hongyu Yang, Morris Chen, Cynthia Rudin, Margo Seltzer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tictactoe)
featurenames &lt;- c("c1=b", "c1=o", "c1=x")
get_data_feature_mat(tictactoe, featurenames)
#it will generate a binary matrix representing which observations are captured by which features.

#clean up
rm(list = ls())
gc()
</code></pre>

<hr>
<h2 id='predict.sbrl'>
PREDICT THE POSITIVE PROBABILITY FOR THE OBSERVATIONS
</h2><span id='topic+predict'></span><span id='topic+predict.sbrl'></span>

<h3>Description</h3>

<p>Returns a list of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbrl'
predict(object, tdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sbrl_+3A_object">object</code></td>
<td>
<p>sbrl model returned from the <code><a href="#topic+sbrl">sbrl</a></code> function.
</p>
</td></tr>
<tr><td><code id="predict.sbrl_+3A_tdata">tdata</code></td>
<td>
<p>test data
</p>
</td></tr>
<tr><td><code id="predict.sbrl_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a list containing 2 lists of probablities for the rule list, corresponding to probability being 0 and 1 for each observation. The two probabilities for each rule add up to 1, P(y=0 | rule r) + p(y=1 | rule r) = 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us use the titactoe dataset
data(tictactoe)
for (name in names(tictactoe)) {tictactoe[name] &lt;- as.factor(tictactoe[,name])}

# Train on two-thirds of the data
b = round(2*nrow(tictactoe)/3, digit=0)
data_train &lt;- tictactoe[1:b, ]
# Test on the remaining one third of the data
data_test &lt;- tictactoe[(b+1):nrow(tictactoe), ]
# data_train, data_test are dataframes with factor columns
# The class column is "label"

# Run the sbrl algorithm on the training set
  sbrl_model &lt;- sbrl(data_train, iters=20000, pos_sign="1",
   neg_sign="0", rule_minlen=1, rule_maxlen=3, 
   minsupport_pos=0.10, minsupport_neg=0.10, 
   lambda=10.0, eta=1.0, nchain=25)
  print(sbrl_model)

# Make predictions on the test set
  yhat &lt;- predict(sbrl_model, data_test)
# yhat will be a list of predicted negative and positive probabilities for the test data. 

#clean up
rm(list = ls())
gc()
</code></pre>

<hr>
<h2 id='print.sbrl'>
INTERPRETABLE VERSION OF A SBRL MODEL
</h2><span id='topic+show.sbrl'></span><span id='topic+print.sbrl'></span>

<h3>Description</h3>

<p>This function prints an sbrl object. It is a method for the generic function print of class &quot;sbrl&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># S3 method for class 'sbrl'
# This complies with the form of the standard generic method print
## S3 method for class 'sbrl'
print(x, useS4=FALSE, ...)
## S3 method for class 'sbrl'
show(x, useS4=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sbrl_+3A_x">x</code></td>
<td>
<p> A sbrl model returned from <code><a href="#topic+sbrl">sbrl</a></code> function </p>
</td></tr>
<tr><td><code id="print.sbrl_+3A_uses4">useS4</code></td>
<td>
<p> An argument used to match showDefault function. Fixed as FALSE. </p>
</td></tr>
<tr><td><code id="print.sbrl_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a method for the generic function print for class &quot;sbrl&quot;. It can be invoked by calling print for an object of the appropriate class, or directly by calling print.sbrl regardless of the class of the object.
</p>


<h3>Value</h3>

<p>No return value. This function prints out the logical structure of the sbrl model as a sequence of IF-THEN rules, identical to a decision list or one-sided decision tree.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us use the titactoe dataset
data(tictactoe)
for (name in names(tictactoe)) {tictactoe[name] &lt;- as.factor(tictactoe[,name])}

# Train on two-thirds of the data
b = round(2*nrow(tictactoe)/3, digit=0)
data_train &lt;- tictactoe[1:b, ]
# Test on the remaining one third of the data
data_test &lt;- tictactoe[(b+1):nrow(tictactoe), ]
# data_train, data_test are dataframes with factor columns
# The class column is "label"

# Run the sbrl algorithm on the training set
  sbrl_model &lt;- sbrl(data_train, iters=20000, pos_sign="1",
   neg_sign="0", rule_minlen=1, rule_maxlen=3, 
   minsupport_pos=0.10, minsupport_neg=0.10, 
   lambda=10.0, eta=1.0, nchain=25)
  print(sbrl_model)

#clean up
rm(list = ls())
gc()
</code></pre>

<hr>
<h2 id='sbrl'>
fit the scalable bayesian rule lists model
</h2><span id='topic+sbrl'></span>

<h3>Description</h3>

<p>Fit the scalable bayesian rule lists model with given data and parameters. It generates a model that is a probabilistic classifier that optimizes the posterior of a Bayesian hierarchical model over pre-mined association rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbrl(tdata, iters=30000, pos_sign="1", 
 neg_sign="0", rule_minlen=1, rule_maxlen=1, 
 minsupport_pos=0.10, minsupport_neg=0.10, 
 lambda=10.0, eta=1.0, alpha=c(1,1), nchain=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sbrl_+3A_tdata">tdata</code></td>
<td>
<p>a dataframe, with a &quot;label&quot; column specifying the correct labels for each observation.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_iters">iters</code></td>
<td>
<p>the number of iterations for each MCMC chain.</p>
</td></tr> 
<tr><td><code id="sbrl_+3A_pos_sign">pos_sign</code></td>
<td>
<p>the sign for the positive labels in the &quot;label&quot; column.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_neg_sign">neg_sign</code></td>
<td>
<p>the sign for the negative labels in the &quot;label&quot; column.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_rule_minlen">rule_minlen</code></td>
<td>
<p>the minimum number of cardinality for rules to be mined from the dataframe.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_rule_maxlen">rule_maxlen</code></td>
<td>
<p>the maximum number of cardinality for rules to be mined from the dataframe.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_minsupport_pos">minsupport_pos</code></td>
<td>
<p>a number between 0 and 1, for the minimum percentage support for the positive observations.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_minsupport_neg">minsupport_neg</code></td>
<td>
<p>a number between 0 and 1, for the minimum percentage support for the negative observations.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_lambda">lambda</code></td>
<td>
<p>a hyperparameter for the expected length of the rule list.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_eta">eta</code></td>
<td>
<p>a hyperparameter for the expected cardinality of the rules in the optimal rule list.</p>
</td></tr>
<tr><td><code id="sbrl_+3A_alpha">alpha</code></td>
<td>
<p>a prior pseudo-count for the positive and negative classes. fixed at 1's</p>
</td></tr>
<tr><td><code id="sbrl_+3A_nchain">nchain</code></td>
<td>
<p>an integer for the number of the chains that MCMC will be running.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list of :
</p>
<table role = "presentation">
<tr><td><code>rs</code></td>
<td>
<p>a ruleset which contains the rule indices and their positive probabilities for the best rule list by training sbrl with the given data and parameters.</p>
</td></tr>
<tr><td><code>rulenames</code></td>
<td>
<p>a list of all the rule names mined with <code>arules</code>.</p>
</td></tr>
<tr><td><code>featurenames</code></td>
<td>
<p>a list of all the feature names.</p>
</td></tr>
<tr><td><code>mat_feature_rule</code></td>
<td>
<p>a binary matrix representing which features are included in which rules.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hongyu Yang, Morris Chen, Cynthia Rudin, Margo Seltzer
</p>


<h3>References</h3>

<p>Hongyu Yang, Cynthia Rudin, Margo Seltzer (2017)
<em>Scalable Bayesian Rule Lists.</em>
Proceedings of the 34th International Conference on Machine Learning, PMLR 70:3921-3930, 2017.
</p>
<p>Benjamin Letham, Cynthia Rudin, Tyler McCormick and David Madigan (2015)
<em>Building Interpretable Classifiers with Rules using Bayesian Analysis.</em>
Annals of Applied Statistics, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let us use the titactoe dataset
data(tictactoe)
for (name in names(tictactoe)) {tictactoe[name] &lt;- as.factor(tictactoe[,name])}

# Train on two-thirds of the data
b = round(2*nrow(tictactoe)/3, digit=0)
data_train &lt;- tictactoe[1:b, ]
# Test on the remaining one third of the data
data_test &lt;- tictactoe[(b+1):nrow(tictactoe), ]
# data_train, data_test are dataframes with factor columns
# The class column is "label"

# Run the sbrl algorithm on the training set
  sbrl_model &lt;- sbrl(data_train, iters=20000, pos_sign="1",
   neg_sign="0", rule_minlen=1, rule_maxlen=3, 
   minsupport_pos=0.10, minsupport_neg=0.10, 
   lambda=10.0, eta=1.0, nchain=25)
  print(sbrl_model)

# Make predictions on the test set
  yhat &lt;- predict(sbrl_model, data_test)
# yhat will be a list of predicted negative and positive probabilities for the test data. 

#clean up
rm(list = ls())
gc()
</code></pre>

<hr>
<h2 id='tictactoe'>
SHUFFLED TIC-TAC-TOE-ENDGAME DATASET
</h2><span id='topic+tictactoe'></span>

<h3>Description</h3>

<p>This is a shuffled version of the Tic-Tac-Toe Endgame Data Set on UCI Machine Learning Repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("tictactoe")</code></pre>


<h3>Format</h3>

<p>A data frame with 958 observations on the following 10 variables.
</p>

<dl>
<dt><code>c1</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c2</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c3</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c4</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c5</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c6</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c7</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c8</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>c9</code></dt><dd><p>a factor with levels <code>b</code>, <code>o</code>, <code>x</code></p>
</dd>
<dt><code>label</code></dt><dd><p>an integer with values <code>0</code>, <code>1</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>This database encodes the complete set of possible board configurations at the end of tic-tac-toe games, where &quot;x&quot; is assumed to have played first. The target concept is &quot;win for x&quot; (i.e., true when &quot;x&quot; has one of 8 possible ways to create a &quot;three-in-a-row&quot;). 
</p>


<h3>Source</h3>

<p>https://archive.ics.uci.edu/ml/datasets/Tic-Tac-Toe+Endgame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tictactoe)
## maybe str(tictactoe) ; plot(tictactoe) ...

#clean up
rm(list = ls())
gc()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
