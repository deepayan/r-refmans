<!DOCTYPE html><html><head><title>Help for package S7</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {S7}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_class'><p>Standard class specifications</p></a></li>
<li><a href='#base_classes'><p>Base classes</p></a></li>
<li><a href='#class_missing'><p>Special dispatch types</p></a></li>
<li><a href='#convert'><p>Convert an object from one type to another</p></a></li>
<li><a href='#method'><p>Retrieve a method for an S7 generic</p></a></li>
<li><a href='#method_explain'><p>Explain method dispatch</p></a></li>
<li><a href='#method&lt;-'><p>Register a S7 method for a generic</p></a></li>
<li><a href='#methods_register'><p>Register methods in a package</p></a></li>
<li><a href='#new_class'><p>Define a new S7 class</p></a></li>
<li><a href='#new_external_generic'><p>Generics in other packages</p></a></li>
<li><a href='#new_generic'><p>Define a new generic</p></a></li>
<li><a href='#new_property'><p>Define a new property</p></a></li>
<li><a href='#new_S3_class'><p>Declare an S3 class</p></a></li>
<li><a href='#new_union'><p>Define a class union</p></a></li>
<li><a href='#prop'><p>Get/set a property</p></a></li>
<li><a href='#prop_names'><p>Property introspection</p></a></li>
<li><a href='#props'><p>Get/set multiple properties</p></a></li>
<li><a href='#S4_register'><p>Register an S7 class with S4</p></a></li>
<li><a href='#S7_class'><p>Retrieve the S7 class of an object</p></a></li>
<li><a href='#S7_data'><p>Get/set underlying &quot;base&quot; data</p></a></li>
<li><a href='#S7_inherits'><p>Does this object inherit from an S7 class?</p></a></li>
<li><a href='#S7_object'><p>Base S7 class</p></a></li>
<li><a href='#super'><p>Force method dispatch to use a superclass</p></a></li>
<li><a href='#validate'><p>Validate an S7 object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>An Object Oriented System Meant to Become a Successor to S3 and
S4</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A new object oriented programming system designed to be a successor 
  to S3 and S4. It includes formal class, generic, and method specification, 
  and a limited form of multiple dispatch. It has been designed and implemented 
  collaboratively by the R Consortium Object-Oriented Programming Working Group, 
  which includes representatives from R-Core, 'Bioconductor', 
  'Posit'/'tidyverse', and the wider R community.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rconsortium/S7/">https://github.com/rconsortium/S7/</a>,
<a href="https://rconsortium.github.io/S7/">https://rconsortium.github.io/S7/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rconsortium/S7/issues">https://github.com/rconsortium/S7/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, covr, knitr, methods, rmarkdown, testthat (&ge; 3.0.0),
tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>sloop</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-17 11:50:09 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Object-Oriented Programming Working Group [cph],
  Davis Vaughan [aut],
  Jim Hester <a href="https://orcid.org/0000-0002-2739-7082"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tomasz Kalinowski [aut],
  Will Landau [aut],
  Michael Lawrence [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Luke Tierney [aut],
  Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-17 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_class'>Standard class specifications</h2><span id='topic+as_class'></span>

<h3>Description</h3>

<p>This is used as the interface between S7 and R's other OO systems, allowing
you to use S7 classes and methods with base types, informal S3 classes, and
formal S4 classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_class(x, arg = deparse(substitute(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_class_+3A_x">x</code></td>
<td>
<p>A class specification. One of the following:
</p>

<ul>
<li><p> An S7 class (created by <code><a href="#topic+new_class">new_class()</a></code>).
</p>
</li>
<li><p> An S7 union (created by <code><a href="#topic+new_union">new_union()</a></code>).
</p>
</li>
<li><p> An S3 class (created by <code><a href="#topic+new_S3_class">new_S3_class()</a></code>).
</p>
</li>
<li><p> An S4 class (created by <code><a href="methods.html#topic+getClass">methods::getClass()</a></code> or <code><a href="methods.html#topic+new">methods::new()</a></code>).
</p>
</li>
<li><p> A base class, like <a href="#topic+class_logical">class_logical</a>, <a href="#topic+class_integer">class_integer</a>, or <a href="#topic+class_double">class_double</a>.
</p>
</li>
<li><p> A &quot;special&quot;, either <a href="#topic+class_missing">class_missing</a> or <a href="#topic+class_any">class_any</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="as_class_+3A_arg">arg</code></td>
<td>
<p>Argument name used when generating errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A standardised class: either <code>NULL</code>, an S7 class, an S7 union,
as <a href="#topic+new_S3_class">new_S3_class</a>, or a S4 class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_class(class_logical)
as_class(new_S3_class("factor"))
</code></pre>

<hr>
<h2 id='base_classes'>Base classes</h2><span id='topic+base_classes'></span><span id='topic+class_logical'></span><span id='topic+class_integer'></span><span id='topic+class_double'></span><span id='topic+class_complex'></span><span id='topic+class_character'></span><span id='topic+class_raw'></span><span id='topic+class_list'></span><span id='topic+class_expression'></span><span id='topic+class_function'></span><span id='topic+class_environment'></span><span id='topic+class_numeric'></span><span id='topic+class_atomic'></span><span id='topic+class_vector'></span><span id='topic+class_factor'></span><span id='topic+class_Date'></span><span id='topic+class_POSIXct'></span><span id='topic+class_data.frame'></span>

<h3>Description</h3>

<p>These classes represent base types allowing them to be used within S7.
There are three categories: base types, unions types, and key S3 classes.
</p>
<p>Base types:
</p>

<ul>
<li> <p><code>class_logical</code>
</p>
</li>
<li> <p><code>class_integer</code>
</p>
</li>
<li> <p><code>class_double</code>
</p>
</li>
<li> <p><code>class_complex</code>
</p>
</li>
<li> <p><code>class_character</code>
</p>
</li>
<li> <p><code>class_raw</code>
</p>
</li>
<li> <p><code>class_list</code>
</p>
</li>
<li> <p><code>class_expression</code>
</p>
</li>
<li> <p><code>class_function</code>
</p>
</li>
<li> <p><code>class_environment</code> (can only be used for properties)
</p>
</li></ul>

<p>Union types:
</p>

<ul>
<li> <p><code>class_numeric</code> is a union of <code>class_integer</code> and <code>class_double</code>.
</p>
</li>
<li> <p><code>class_atomic</code> is a union of <code>class_logical</code>, <code>class_numeric</code>,
<code>class_complex</code>, <code>class_character</code>, and <code>class_raw</code>.
</p>
</li>
<li> <p><code>class_vector</code> is a union of <code>class_atomic</code>, <code>class_list</code>, and
<code>class_expression</code>.
</p>
</li></ul>

<p>Key S3 classes:
</p>

<ul>
<li> <p><code>class_data.frame</code>
</p>
</li>
<li> <p><code>class_Date</code>
</p>
</li>
<li> <p><code>class_factor</code>
</p>
</li>
<li> <p><code>class_POSIXct</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>class_logical

class_integer

class_double

class_complex

class_character

class_raw

class_list

class_expression

class_function

class_environment

class_numeric

class_atomic

class_vector

class_factor

class_Date

class_POSIXct

class_data.frame
</code></pre>


<h3>Value</h3>

<p>S7 classes wrapping around common base types and S3 classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
class_integer
class_numeric
class_factor
</code></pre>

<hr>
<h2 id='class_missing'>Special dispatch types</h2><span id='topic+class_missing'></span><span id='topic+class_any'></span>

<h3>Description</h3>


<ul>
<li><p> Use <code>class_missing</code> when the user has not supplied an argument
</p>
</li>
<li><p> Use <code>class_any</code> for a default method that is called only if no other
methods are matched
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>class_missing

class_any
</code></pre>


<h3>Format</h3>

<p>An object of class <code>S7_missing</code> of length 0.
</p>
<p>An object of class <code>S7_any</code> of length 0.
</p>


<h3>Value</h3>

<p>Sentinel objects used for special types of dispatch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- new_generic("foo", "x")
method(foo, class_integer) &lt;- function(x) "integer"
method(foo, class_missing) &lt;- function(x) "missing"
method(foo, class_any) &lt;- function(x) "fallback"

foo(1)
foo()
foo("x")
</code></pre>

<hr>
<h2 id='convert'>Convert an object from one type to another</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p><code>convert(from, to)</code> is a built-in generic for converting an object from
one type to another. It is special in three ways:
</p>

<ul>
<li><p> It uses double-dispatch, because conversion depends on both <code>from</code> and
<code>to</code>.
</p>
</li>
<li><p> It uses non-standard dispatch because <code>to</code> is a class, not an object.
</p>
</li>
<li><p> It doesn't use inheritance for the <code>to</code> argument. To understand
why, imagine you have written methods to objects of various types to
<code>classParent</code>. If you then create a new <code>classChild</code> that inherits from
<code>classParent</code>, you can't expect the methods written for <code>classParent</code>
to work because those methods will return <code>classParent</code> objects, not
<code>classChild</code> objects.
</p>
</li></ul>

<p><code>convert()</code> provides a default implementation when <code>from</code> inherits from
<code>to</code>. This default strips any properties that <code>from</code> possesses that <code>to</code>
does not.
</p>
<p>If you are converting an object solely for the purposes of accessing a method
on a superclass, you probably want <code><a href="#topic+super">super()</a></code> instead. See its docs for more
details.
</p>


<h4>S3 &amp; S4</h4>

<p><code>convert()</code> plays a similar role to the convention of defining <code>as.foo()</code>
functions/generics in S3, and to <code>as()</code>/<code>setAs()</code> in S4.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>convert(from, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_from">from</code></td>
<td>
<p>An S7 object to convert.</p>
</td></tr>
<tr><td><code id="convert_+3A_to">to</code></td>
<td>
<p>An S7 class specification, passed to <code><a href="#topic+as_class">as_class()</a></code>.</p>
</td></tr>
<tr><td><code id="convert_+3A_...">...</code></td>
<td>
<p>Other arguments passed to custom <code>convert()</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>from</code> coerced to class <code>to</code>, or an error if the coercion
is not possible.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo1 &lt;- new_class("foo1", properties = list(x = class_integer))
foo2 &lt;- new_class("foo2", foo1, properties = list(y = class_double))

# S7 provides a default implementation for coercing an object to one of
# its parent classes:
convert(foo2(x = 1L, y = 2), to = foo1)

# For all other cases, you'll need to provide your own.
try(convert(foo1(x = 1L), to = class_integer))

method(convert, list(foo1, class_integer)) &lt;- function(from, to) {
  from@x
}
convert(foo1(x = 1L), to = class_integer)

# Note that conversion does not respect inheritance so if we define a
# convert method for integer to foo1
method(convert, list(class_integer, foo1)) &lt;- function(from, to) {
  foo1(x = from)
}
convert(1L, to = foo1)

# Converting to foo2 will still error
try(convert(1L, to = foo2))
# This is probably not surprising because foo2 also needs some value
# for `@y`, but it definitely makes dispatch for convert() special
</code></pre>

<hr>
<h2 id='method'>Retrieve a method for an S7 generic</h2><span id='topic+method'></span>

<h3>Description</h3>

<p><code>method()</code> takes a generic and signature and retrieves the corresponding
method. This is rarely needed because most of the time you'll rely on the
the generic, via <code><a href="#topic+S7_dispatch">S7_dispatch()</a></code>, to find and call the method for you.
However, this introspection is useful if you want to see the implementation
of a specific method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method(generic, class = NULL, object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_+3A_generic">generic</code></td>
<td>
<p>A generic function, i.e. an <a href="#topic+new_generic">S7 generic</a>,
an <a href="#topic+new_external_generic">external generic</a>, an <a href="base.html#topic+UseMethod">S3 generic</a>,
or an <a href="methods.html#topic+setGeneric">S4 generic</a>.</p>
</td></tr>
<tr><td><code id="method_+3A_class">class</code>, <code id="method_+3A_object">object</code></td>
<td>
<p>Perform introspection either with a <code>class</code>
(processed with <code><a href="#topic+as_class">as_class()</a></code>) or a concrete <code>object</code>. If <code>generic</code> uses
multiple dispatch then both <code>object</code> and <code>class</code> must be a list of
classes/objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function with class &lt;S7_method&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+method_explain">method_explain()</a></code> to explain why a specific method was picked.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a generic and register some methods
bizarro &lt;- new_generic("bizarro", "x")
method(bizarro, class_numeric) &lt;- function(x) rev(x)
method(bizarro, new_S3_class("factor")) &lt;- function(x) {
  levels(x) &lt;- rev(levels(x))
  x
}

# Printing the generic shows the registered method
bizarro

# And you can use method() to inspect specific implementations
method(bizarro, class = class_integer)
method(bizarro, object = 1)
method(bizarro, new_S3_class("factor"))
</code></pre>

<hr>
<h2 id='method_explain'>Explain method dispatch</h2><span id='topic+method_explain'></span>

<h3>Description</h3>

<p><code>method_explain()</code> shows all possible methods that a call to a generic
might use, which ones exist, and which one will actually be called.
</p>
<p>Note that method dispatch uses a string representation of each class in
the class hierarchy. Each class system uses a slightly different convention
to avoid ambiguity.
</p>

<ul>
<li><p> S7: <code>pkg::class</code> or <code>class</code>
</p>
</li>
<li><p> S4: <code>S4/pkg::class</code> or <code>S4/class</code>
</p>
</li>
<li><p> S3: <code>class</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>method_explain(generic, class = NULL, object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method_explain_+3A_generic">generic</code></td>
<td>
<p>A generic function, i.e. an <a href="#topic+new_generic">S7 generic</a>,
an <a href="#topic+new_external_generic">external generic</a>, an <a href="base.html#topic+UseMethod">S3 generic</a>,
or an <a href="methods.html#topic+setGeneric">S4 generic</a>.</p>
</td></tr>
<tr><td><code id="method_explain_+3A_class">class</code>, <code id="method_explain_+3A_object">object</code></td>
<td>
<p>Perform introspection either with a <code>class</code>
(processed with <code><a href="#topic+as_class">as_class()</a></code>) or a concrete <code>object</code>. If <code>generic</code> uses
multiple dispatch then both <code>object</code> and <code>class</code> must be a list of
classes/objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; this function is called for it's side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo1 &lt;- new_class("foo1")
foo2 &lt;- new_class("foo2", foo1)

add &lt;- new_generic("add", c("x", "y"))
method(add, list(foo2, foo1)) &lt;- function(x, y) c(2, 1)
method(add, list(foo1, foo1)) &lt;- function(x, y) c(1, 1)

method_explain(add, list(foo2, foo2))
</code></pre>

<hr>
<h2 id='method+26lt+3B-'>Register a S7 method for a generic</h2><span id='topic+method+3C-'></span>

<h3>Description</h3>

<p>A generic defines the interface of a function. Once you have created a
generic with <code><a href="#topic+new_generic">new_generic()</a></code>, you provide implementations for specific
signatures by registering methods with <code style="white-space: pre;">&#8288;method&lt;-&#8288;</code>.
</p>
<p>The goal is for <code style="white-space: pre;">&#8288;method&lt;-&#8288;</code> to be the single function you need when working
with S7 generics or S7 classes. This means that as well as registering
methods for S7 classes on S7 generics, you can also register methods for
S7 classes on S3 or S4 generics, and S3 or S4 classes on S7 generics.
But this is not a general method registration function: at least one of
<code>generic</code> and <code>signature</code> needs to be from S7.
</p>
<p>Note that if you are writing a package, you must call <code><a href="#topic+methods_register">methods_register()</a></code>
in your <code>.onLoad</code>. This ensures that all methods are dynamically registered
when needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method(generic, signature) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="method+2B26lt+2B3B-_+3A_generic">generic</code></td>
<td>
<p>A generic function, i.e. an <a href="#topic+new_generic">S7 generic</a>,
an <a href="#topic+new_external_generic">external generic</a>, an <a href="base.html#topic+UseMethod">S3 generic</a>,
or an <a href="methods.html#topic+setGeneric">S4 generic</a>.</p>
</td></tr>
<tr><td><code id="method+2B26lt+2B3B-_+3A_signature">signature</code></td>
<td>
<p>A method signature.
</p>
<p>For S7 generics that use single dispatch, this must be one of the
following:
</p>

<ul>
<li><p> An S7 class (created by <code><a href="#topic+new_class">new_class()</a></code>).
</p>
</li>
<li><p> An S7 union (created by <code><a href="#topic+new_union">new_union()</a></code>).
</p>
</li>
<li><p> An S3 class (created by <code><a href="#topic+new_S3_class">new_S3_class()</a></code>).
</p>
</li>
<li><p> An S4 class (created by <code><a href="methods.html#topic+getClass">methods::getClass()</a></code> or <code><a href="methods.html#topic+new">methods::new()</a></code>).
</p>
</li>
<li><p> A base type like <a href="#topic+class_logical">class_logical</a>, <a href="#topic+class_integer">class_integer</a>, or <a href="#topic+class_numeric">class_numeric</a>.
</p>
</li>
<li><p> A special type like <a href="#topic+class_missing">class_missing</a> or <a href="#topic+class_any">class_any</a>.
</p>
</li></ul>

<p>For S7 generics that use multiple dispatch, this must be a list of any of
the above types.
</p>
<p>For S3 generics, this must be a single S7 class.
</p>
<p>For S4 generics, this must either be an S7 class, or a list that includes
at least one S7 class.</p>
</td></tr>
<tr><td><code id="method+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A function that implements the generic specification for the
given <code>signature</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>generic</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a generic
bizarro &lt;- new_generic("bizarro", "x")
# Register some methods
method(bizarro, class_numeric) &lt;- function(x) rev(x)
method(bizarro, new_S3_class("data.frame")) &lt;- function(x) {
  x[] &lt;- lapply(x, bizarro)
  rev(x)
}

# Using a generic calls the methods automatically
bizarro(head(mtcars))
</code></pre>

<hr>
<h2 id='methods_register'>Register methods in a package</h2><span id='topic+methods_register'></span>

<h3>Description</h3>

<p>When using S7 in a package you should always call <code>methods_register()</code> when
your package is loaded. This ensures that methods are registered as needed
when you implement methods for generics (S3, S4, and S7) in other packages.
(This is not strictly necessary if you only register methods for generics
in your package, but it's better to include it and not need it than forget
to include it and hit weird errors.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methods_register()
</code></pre>


<h3>Value</h3>

<p>Nothing; called for its side-effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.onLoad &lt;- function(...) {
  S7::methods_register()
}
</code></pre>

<hr>
<h2 id='new_class'>Define a new S7 class</h2><span id='topic+new_class'></span><span id='topic+new_object'></span>

<h3>Description</h3>

<p>A class specifies the properties (data) that each of its objects will
possess. The class, and its parent, determines which method will be used
when an object is passed to a generic.
</p>
<p>Learn more in <code>vignette("classes-objects")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_class(
  name,
  parent = S7_object,
  package = NULL,
  properties = list(),
  abstract = FALSE,
  constructor = NULL,
  validator = NULL
)

new_object(.parent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_class_+3A_name">name</code></td>
<td>
<p>The name of the class, as a string. The result of calling
<code>new_class()</code> should always be assigned to a variable with this name,
i.e. <code>foo &lt;- new_class("foo")</code>.</p>
</td></tr>
<tr><td><code id="new_class_+3A_parent">parent</code></td>
<td>
<p>The parent class to inherit behavior from.
There are three options:
</p>

<ul>
<li><p> An S7 class, like <a href="#topic+S7_object">S7_object</a>.
</p>
</li>
<li><p> An S3 class wrapped by <code><a href="#topic+new_S3_class">new_S3_class()</a></code>.
</p>
</li>
<li><p> A base type, like <a href="#topic+class_logical">class_logical</a>, <a href="#topic+class_integer">class_integer</a>, etc.
</p>
</li></ul>
</td></tr>
<tr><td><code id="new_class_+3A_package">package</code></td>
<td>
<p>Package name. It is good practice to set the package
name when exporting an S7 class from a package because it prevents
clashes if two packages happen to export a class with the same
name.
</p>
<p>Setting <code>package</code> implies that the class is available for external use,
so should be accompanied by exporting the constructor. Learn more
in <code>vignette("packages")</code>.</p>
</td></tr>
<tr><td><code id="new_class_+3A_properties">properties</code></td>
<td>
<p>A named list specifying the properties (data) that
belong to each instance of the class. Each element of the list can
either be a type specification (processed by <code><a href="#topic+as_class">as_class()</a></code>) or a
full property specification created <code><a href="#topic+new_property">new_property()</a></code>.</p>
</td></tr>
<tr><td><code id="new_class_+3A_abstract">abstract</code></td>
<td>
<p>Is this an abstract class? An abstract class can not be
instantiated.</p>
</td></tr>
<tr><td><code id="new_class_+3A_constructor">constructor</code></td>
<td>
<p>The constructor function. In most cases, you can rely
on the default constructor, which will generate a function with one
argument for each property.
</p>
<p>A custom constructor should call <code>new_object()</code> to create the S7 object.
The first argument, <code>.data</code>, should be an instance of the parent class
(if used). The subsequent arguments are used to set the properties.</p>
</td></tr>
<tr><td><code id="new_class_+3A_validator">validator</code></td>
<td>
<p>A function taking a single argument, <code>self</code>, the object
to validate.
</p>
<p>The job of a validator is to determine whether the object is valid,
i.e. if the current property values form an allowed combination. The
types of the properties are always automatically validated so the job of
the validator is to verify that the <em>values</em> of individual properties are
ok (i.e. maybe a property should have length 1, or should always be
positive), or that the <em>combination</em> of values of multiple properties is ok.
It is called after construction and whenever any property is set.
</p>
<p>The validator should return <code>NULL</code> if the object is valid. If not, it
should return a character vector where each element describes a single
problem, using <code style="white-space: pre;">&#8288;@prop_name&#8288;</code> to describe where the problem lies.
</p>
<p>See <code>validate()</code> for more details, examples, and how to temporarily
suppress validation when needed.</p>
</td></tr>
<tr><td><code id="new_class_+3A_.parent">.parent</code>, <code id="new_class_+3A_...">...</code></td>
<td>
<p>Parent object and named properties used to construct the
object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A object constructor, a function that can be used to create objects
of the given class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an class that represents a range using a numeric start and end
range &lt;- new_class("range",
  properties = list(
    start = class_numeric,
    end = class_numeric
  )
)
r &lt;- range(start = 10, end = 20)
r
# get and set properties with @
r@start
r@end &lt;- 40
r@end

# S7 automatically ensures that properties are of the declared types:
try(range(start = "hello", end = 20))

# But we might also want to use a validator to ensure that start and end
# are length 1, and that start is &lt; end
range &lt;- new_class("range",
  properties = list(
    start = class_numeric,
    end = class_numeric
  ),
  validator = function(self) {
    if (length(self@start) != 1) {
      "@start must be a single number"
    } else if (length(self@end) != 1) {
      "@end must be a single number"
    } else if (self@end &lt; self@start) {
      "@end must be great than or equal to @start"
    }
  }
)
try(range(start = c(10, 15), end = 20))
try(range(start = 20, end = 10))

r &lt;- range(start = 10, end = 20)
try(r@start &lt;- 25)
</code></pre>

<hr>
<h2 id='new_external_generic'>Generics in other packages</h2><span id='topic+new_external_generic'></span>

<h3>Description</h3>

<p>You need an explicit external generic when you want to provide methods
for a generic (S3, S4, or S7) that is defined in another package, and you
don't want to take a hard dependency on that package.
</p>
<p>The easiest way to provide methods for generics in other packages is
import the generic into your <code>NAMESPACE</code>. This, however, creates a hard
dependency, and sometimes you want a soft dependency, only registering the
method if the package is already installed. <code>new_external_generic()</code> allows
you to provide the minimal needed information about a generic so that methods
can be registered at run time, as needed, using <code><a href="#topic+methods_register">methods_register()</a></code>.
</p>
<p>Note that in tests, you'll need to explicitly call the generic from the
external package with <code>pkg::generic()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_external_generic(package, name, dispatch_args, version = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_external_generic_+3A_package">package</code></td>
<td>
<p>Package the generic is defined in.</p>
</td></tr>
<tr><td><code id="new_external_generic_+3A_name">name</code></td>
<td>
<p>Name of generic, as a string.</p>
</td></tr>
<tr><td><code id="new_external_generic_+3A_dispatch_args">dispatch_args</code></td>
<td>
<p>Character vector giving arguments used for dispatch.</p>
</td></tr>
<tr><td><code id="new_external_generic_+3A_version">version</code></td>
<td>
<p>An optional version the package must meet for the method to
be registered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S7 external generic, i.e. a list with class
<code>S7_external_generic</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_class &lt;- new_class("my_class")

your_generic &lt;- new_external_generic("stats", "median", "x")
method(your_generic, my_class) &lt;- function(x) "Hi!"
</code></pre>

<hr>
<h2 id='new_generic'>Define a new generic</h2><span id='topic+new_generic'></span><span id='topic+S7_dispatch'></span>

<h3>Description</h3>

<p>A generic function uses different implementations (<em>methods</em>) depending on
the class of one or more arguments (the <em>signature</em>). Create a new generic
with <code>new_generic()</code> then use <a href="#topic+method+3C-">method&lt;-</a> to add methods to it.
</p>
<p>Method dispatch is performed by <code>S7_dispatch()</code>, which must always be
included in the body of the generic, but in most cases <code>new_generic()</code> will
generate this for you.
</p>
<p>Learn more in <code>vignette("generics-methods")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_generic(name, dispatch_args, fun = NULL)

S7_dispatch()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_generic_+3A_name">name</code></td>
<td>
<p>The name of the generic. This should be the same as the object
that you assign it to.</p>
</td></tr>
<tr><td><code id="new_generic_+3A_dispatch_args">dispatch_args</code></td>
<td>
<p>A character vector giving the names of one or more
arguments used to find the method.</p>
</td></tr>
<tr><td><code id="new_generic_+3A_fun">fun</code></td>
<td>
<p>An optional specification of the generic, which must call
<code>S7_dispatch()</code> to dispatch to methods. This is usually generated
automatically from the <code>dispatch_args</code>, but you may want to supply it if
you want to add additional required arguments, omit <code>...</code>, or perform
some standardised computation in the generic.
</p>
<p>The <code>dispatch_args</code> must be the first arguments to <code>fun</code>, and, if present,
<code>...</code> must immediately follow them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S7 generic, i.e. a function with class <code>S7_generic</code>.
</p>


<h3>Dispatch arguments</h3>

<p>The arguments that are used to pick the method are called the <strong>dispatch
arguments</strong>. In most cases, this will be one argument, in which case the
generic is said to use <strong>single dispatch</strong>. If it consists of more than
one argument, it's said to use <strong>multiple dispatch</strong>.
</p>
<p>There are two restrictions on the dispatch arguments: they must be the first
arguments to the generic and if the generic uses <code>...</code>, it must occur
immediately after the dispatch arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+new_external_generic">new_external_generic()</a></code> to define a method for a generic
in another package without taking a strong dependency on it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple generic with methods for some base types and S3 classes
type_of &lt;- new_generic("type_of", dispatch_args = "x")
method(type_of, class_character) &lt;- function(x, ...) "A character vector"
method(type_of, new_S3_class("data.frame")) &lt;- function(x, ...) "A data frame"
method(type_of, class_function) &lt;- function(x, ...) "A function"

type_of(mtcars)
type_of(letters)
type_of(mean)

# If you want to require that methods implement additional arguments,
# you can use a custom function:
mean2 &lt;- new_generic("mean2", "x", function(x, ..., na.rm = FALSE) {
   S7_dispatch()
})

method(mean2, class_numeric) &lt;- function(x, ..., na.rm = FALSE) {
  if (na.rm) {
    x &lt;- x[!is.na(x)]
  }
  sum(x) / length(x)
}

# You'll be warned if you forget the argument:
method(mean2, class_character) &lt;- function(x, ...) {
  stop("Not supported")
}
</code></pre>

<hr>
<h2 id='new_property'>Define a new property</h2><span id='topic+new_property'></span>

<h3>Description</h3>

<p>A property defines a named component of an object. Properties are
typically used to store (meta) data about an object, and are often
limited to a data of a specific <code>class</code>.
</p>
<p>By specifying a <code>getter</code> and/or <code>setter</code>, you can make the property
&quot;dynamic&quot; so that it's computed when accessed or has some non-standard
behaviour when modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_property(
  class = class_any,
  getter = NULL,
  setter = NULL,
  validator = NULL,
  default = NULL,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_property_+3A_class">class</code></td>
<td>
<p>Class that the property must be an instance of.
See <code><a href="#topic+as_class">as_class()</a></code> for details.</p>
</td></tr>
<tr><td><code id="new_property_+3A_getter">getter</code></td>
<td>
<p>An optional function used to get the value. The function
should take <code>self</code> as its sole argument and return the value. If you
supply a <code>getter</code>, you are responsible for ensuring that it returns
an object of the correct <code>class</code>; it will not be validated automatically.
</p>
<p>If a property has a getter but doesn't have a setter, it is read only.</p>
</td></tr>
<tr><td><code id="new_property_+3A_setter">setter</code></td>
<td>
<p>An optional function used to set the value. The function
should take <code>self</code> and <code>value</code> and return a modified object.</p>
</td></tr>
<tr><td><code id="new_property_+3A_validator">validator</code></td>
<td>
<p>A function taking a single argument, <code>value</code>, the value
to validate.
</p>
<p>The job of a validator is to determine whether the property value is valid.
It should return <code>NULL</code> if the object is valid, or if it's not valid,
a single string describing the problem. The message should not include the
name of the property as this will be automatically appended to the
beginning of the message.
</p>
<p>The validator will be called after the <code>class</code> has been verified, so
your code can assume that <code>value</code> has known type.</p>
</td></tr>
<tr><td><code id="new_property_+3A_default">default</code></td>
<td>
<p>When an object is created and the property is not supplied,
what should it default to? If <code>NULL</code>, defaults to the &quot;empty&quot; instance
of <code>class</code>.</p>
</td></tr>
<tr><td><code id="new_property_+3A_name">name</code></td>
<td>
<p>Property name, primarily used for error messages. Used
primrarily for testing as it is set automatically when using a list of
properties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S7 property, i.e. a list with class <code>S7_property</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple properties store data inside an object
pizza &lt;- new_class("pizza", properties = list(
  slices = new_property(class_numeric, default = 10)
))
my_pizza &lt;- pizza(slices = 6)
my_pizza@slices
my_pizza@slices &lt;- 5
my_pizza@slices

your_pizza &lt;- pizza()
your_pizza@slices

# Dynamic properties can compute on demand
clock &lt;- new_class("clock", properties = list(
  now = new_property(getter = function(self) Sys.time())
))
my_clock &lt;- clock()
my_clock@now; Sys.sleep(1)
my_clock@now
# This property is read only
try(my_clock@now &lt;- 10)

# These can be useful if you want to deprecate a property
person &lt;- new_class("person", properties = list(
  first_name = class_character,
  firstName = new_property(
     getter = function(self) {
       warning("@firstName is deprecated; please use @first_name instead", call. = FALSE)
       self@first_name
     },
     setter = function(self, value) {
       warning("@firstName is deprecated; please use @first_name instead", call. = FALSE)
       self@first_name &lt;- value
       self
     }
   )
))
hadley &lt;- person(first_name = "Hadley")
hadley@firstName
hadley@firstName &lt;- "John"
hadley@first_name
</code></pre>

<hr>
<h2 id='new_S3_class'>Declare an S3 class</h2><span id='topic+new_S3_class'></span>

<h3>Description</h3>

<p>To use an S3 class with S7, you must explicitly declare it using
<code>new_S3_class()</code> because S3 lacks a formal class definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_S3_class(class, constructor = NULL, validator = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_S3_class_+3A_class">class</code></td>
<td>
<p>S3 class vector (i.e. what <code>class()</code> returns). For method
registration, you can abbreviate this to a single string, the S3 class
name.</p>
</td></tr>
<tr><td><code id="new_S3_class_+3A_constructor">constructor</code></td>
<td>
<p>An optional constructor that can be used to create
objects of the specified class. This is only needed if you wish to
have an S7 class inherit from an S3 class. It must be specified in the
same way as a S7 constructor: the first argument should be <code>.data</code>
(the base type whose attributes will be modified).
</p>
<p>All arguments to the constructor should have default values so that
when the constructor is called with no arguments, it returns returns
an &quot;empty&quot;, but valid, object.</p>
</td></tr>
<tr><td><code id="new_S3_class_+3A_validator">validator</code></td>
<td>
<p>An optional validator used by <code><a href="#topic+validate">validate()</a></code> to check that
the S7 object adheres to the constraints of the S3 class.
</p>
<p>A validator is a single argument function that takes the object to
validate and returns <code>NULL</code> if the object is valid. If the object is
invalid, it returns a character vector of problems.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S7 definition of an S3 class, i.e. a list with class
<code>S7_S3_class</code>.
</p>


<h3>Method dispatch, properties, and unions</h3>

<p>There are three ways of using S3 with S7 that only require the S3 class
vector:
</p>

<ul>
<li><p> Registering a S3 method for an S7 generic.
</p>
</li>
<li><p> Restricting an S7 property to an S3 class.
</p>
</li>
<li><p> Using an S3 class in an S7 union.
</p>
</li></ul>

<p>This is easy, and you can usually include the <code>new_S3_class()</code>
call inline:
</p>
<div class="sourceCode R"><pre>method(my_generic, new_S3_class("factor")) &lt;- function(x) "A factor"
new_class("my_class", properties = list(types = new_S3_class("factor")))
new_union("character", new_S3_class("factor"))
</pre></div>


<h3>Extending an S3 class</h3>

<p>Creating an S7 class that extends an S3 class requires more work. You'll
also need to provide a constructor for the S3 class that follows S7
conventions. This means the first argument to the constructor should be
<code>.data</code>, and it should be followed by one argument for each attribute used
by the class.
</p>
<p>This can be awkward because base S3 classes are usually heavily wrapped for user
convenience and no low level constructor is available. For example, the
factor class is an integer vector with a character vector of <code>levels</code>, but
there's no base R function that takes an integer vector of values and
character vector of levels, verifies that they are consistent, then
creates a factor object.
</p>
<p>You may optionally want to also provide a <code>validator</code> function which will
ensure that <code><a href="#topic+validate">validate()</a></code> confirms the validity of any S7 classes that build
on this class. Unlike an S7 validator, you are responsible for validating
the types of the attributes.
</p>
<p>The following code shows how you might wrap the base Date class.
A Date is a numeric vector with class <code>Date</code> that can be constructed with
<code>.Date()</code>.
</p>
<div class="sourceCode R"><pre>S3_Date &lt;- new_S3_class("Date",
  function(.data = integer()) {
    .Date(.data)
  },
  function(self) {
    if (!is.numeric(self)) {
      "Underlying data must be numeric"
    }
  }
)
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'># No checking, just used for dispatch
Date &lt;- new_S3_class("Date")

my_generic &lt;- new_generic("my_generic", "x")
method(my_generic, Date) &lt;- function(x) "This is a date"

my_generic(Sys.Date())
</code></pre>

<hr>
<h2 id='new_union'>Define a class union</h2><span id='topic+new_union'></span>

<h3>Description</h3>

<p>A class union represents a list of possible classes. You can create it
with <code>new_union(a, b, c)</code> or <code>a | b | c</code>. Unions can be used in two
places:
</p>

<ul>
<li><p> To allow a property to be one of a set of classes,
<code>new_property(class_integer | Range)</code>. The default <code>default</code> value for the
property will be the constructor of the first object in the union.
This means if you want to create an &quot;optional&quot; property (i.e. one that
can be <code>NULL</code> or of a specified type), you'll need to write (e.g.)
<code>NULL | class_integer</code>.
</p>
</li>
<li><p> As a convenient short-hand to define methods for multiple classes.
<code>method(foo, X | Y) &lt;- f</code> is short-hand for
<code style="white-space: pre;">&#8288;method(foo, X) &lt;- f; method(foo, Y) &lt;- foo&#8288;</code>
</p>
</li></ul>

<p>S7 includes built-in unions for &quot;numeric&quot; (integer and double vectors),
&quot;atomic&quot; (logical, numeric, complex, character, and raw vectors) and
&quot;vector&quot; (atomic vectors, lists, and expressions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_union(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_union_+3A_...">...</code></td>
<td>
<p>The classes to include in the union. See <code><a href="#topic+as_class">as_class()</a></code> for
details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S7 union, i.e. a list with class <code>S7_union</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logical_or_character &lt;- new_union(class_logical, class_character)
logical_or_character
# or with shortcut syntax
logical_or_character &lt;- class_logical | class_character

Foo &lt;- new_class("Foo", properties = list(x = logical_or_character))
Foo(x = TRUE)
Foo(x = letters[1:5])
try(Foo(1:3))

bar &lt;- new_generic("bar", "x")
# Use built-in union
method(bar, class_atomic) &lt;- function(x) "Hi!"
bar
bar(TRUE)
bar(letters)
try(bar(NULL))
</code></pre>

<hr>
<h2 id='prop'>Get/set a property</h2><span id='topic+prop'></span><span id='topic+prop+3C-'></span><span id='topic++40.S7_object'></span><span id='topic++40'></span>

<h3>Description</h3>


<ul>
<li> <p><code>prop(x, "name")</code> / <code>prop@name</code> get the value of the a property,
erroring if it the property doesn't exist.
</p>
</li>
<li> <p><code>prop(x, "name") &lt;- value</code> / <code>prop@name &lt;- value</code> set the value of
a property.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>prop(object, name)

prop(object, name, check = TRUE) &lt;- value

object@name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_+3A_object">object</code></td>
<td>
<p>An object from a S7 class</p>
</td></tr>
<tr><td><code id="prop_+3A_name">name</code></td>
<td>
<p>The name of the parameter as a character. Partial matching
is not performed.</p>
</td></tr>
<tr><td><code id="prop_+3A_check">check</code></td>
<td>
<p>If <code>TRUE</code>, check that <code>value</code> is of the correct type and run
<code><a href="#topic+validate">validate()</a></code> on the object before returning.</p>
</td></tr>
<tr><td><code id="prop_+3A_value">value</code></td>
<td>
<p>A new value for the property. The object is automatically
checked for validity after the replacement is done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>prop()</code> and <code>@</code> return the value of the property.
<code style="white-space: pre;">&#8288;prop&lt;-()&#8288;</code> and <code style="white-space: pre;">&#8288;@&lt;-&#8288;</code> are called for their side-effects and return
the modified object, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>horse &lt;- new_class("horse", properties = list(
  name = class_character,
  colour = class_character,
  height = class_numeric
))
lexington &lt;- horse(colour = "bay", height = 15, name = "Lex")
lexington@colour
prop(lexington, "colour")

lexington@height &lt;- 14
prop(lexington, "height") &lt;- 15
</code></pre>

<hr>
<h2 id='prop_names'>Property introspection</h2><span id='topic+prop_names'></span><span id='topic+prop_exists'></span>

<h3>Description</h3>


<ul>
<li> <p><code>prop_names(x)</code> returns the names of the properties
</p>
</li>
<li> <p><code>prop_exists(x, "prop")</code> returns <code>TRUE</code> iif <code>x</code> has property <code>prop</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>prop_names(object)

prop_exists(object, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_names_+3A_object">object</code></td>
<td>
<p>An object from a S7 class</p>
</td></tr>
<tr><td><code id="prop_names_+3A_name">name</code></td>
<td>
<p>The name of the parameter as a character. Partial matching
is not performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>prop_names()</code> returns a character vector; <code>prop_exists()</code> returns
a single <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- new_class("foo", properties = list(a = class_character, b = class_integer))
f &lt;- foo()

prop_names(f)
prop_exists(f, "a")
prop_exists(f, "c")
</code></pre>

<hr>
<h2 id='props'>Get/set multiple properties</h2><span id='topic+props'></span><span id='topic+props+3C-'></span><span id='topic+set_props'></span>

<h3>Description</h3>


<ul>
<li> <p><code>props(x)</code> returns all properties.
</p>
</li>
<li> <p><code>props(x) &lt;- list(name1 = val1, name2 = val2)</code> modifies an existing object
by setting multiple properties simultaneously.
</p>
</li>
<li> <p><code>set_props(x, name1 = val1, name2 = val2)</code> creates a copy of an existing
object with new values for the specified properties.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>props(object)

props(object) &lt;- value

set_props(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="props_+3A_object">object</code></td>
<td>
<p>An object from a S7 class</p>
</td></tr>
<tr><td><code id="props_+3A_value">value</code></td>
<td>
<p>A named list of values. The object is checked for validity
only after all replacements are performed.</p>
</td></tr>
<tr><td><code id="props_+3A_...">...</code></td>
<td>
<p>Name-value pairs given property to modify and new value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of property values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>horse &lt;- new_class("horse", properties = list(
  name = class_character,
  colour = class_character,
  height = class_numeric
))
lexington &lt;- horse(colour = "bay", height = 15, name = "Lex")

props(lexington)
props(lexington) &lt;- list(height = 14, name = "Lexington")
lexington
</code></pre>

<hr>
<h2 id='S4_register'>Register an S7 class with S4</h2><span id='topic+S4_register'></span>

<h3>Description</h3>

<p>If you want to use <a href="#topic+method+3C-">method&lt;-</a> to register an method for an S4 generic with
an S7 class, you need to call <code>S4_register()</code> once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S4_register(class, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S4_register_+3A_class">class</code></td>
<td>
<p>An S7 class created with <code><a href="#topic+new_class">new_class()</a></code>.</p>
</td></tr>
<tr><td><code id="S4_register_+3A_env">env</code></td>
<td>
<p>Expert use only. Environment where S4 class will be registered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; the function is called for its side-effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>methods::setGeneric("S4_generic", function(x) {
  standardGeneric("S4_generic")
})

foo &lt;- new_class("foo")
S4_register(foo)
method(S4_generic, foo) &lt;- function(x) "Hello"

S4_generic(foo())
</code></pre>

<hr>
<h2 id='S7_class'>Retrieve the S7 class of an object</h2><span id='topic+S7_class'></span>

<h3>Description</h3>

<p>Given an S7 object, find it's class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S7_class(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S7_class_+3A_object">object</code></td>
<td>
<p>The S7 object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="#topic+new_class">S7 class</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- new_class("foo")
S7_class(foo())
</code></pre>

<hr>
<h2 id='S7_data'>Get/set underlying &quot;base&quot; data</h2><span id='topic+S7_data'></span><span id='topic+S7_data+3C-'></span>

<h3>Description</h3>

<p>When an S7 class inherits from an existing base type, it can be useful
to work with the underlying object, i.e. the S7 object stripped of class
and properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S7_data(object)

S7_data(object, check = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S7_data_+3A_object">object</code></td>
<td>
<p>An object from a S7 class</p>
</td></tr>
<tr><td><code id="S7_data_+3A_check">check</code></td>
<td>
<p>If <code>TRUE</code>, check that <code>value</code> is of the correct type and run
<code><a href="#topic+validate">validate()</a></code> on the object before returning.</p>
</td></tr>
<tr><td><code id="S7_data_+3A_value">value</code></td>
<td>
<p>Object used to replace the underlying data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>S7_data()</code> returns the data stored in the base object;
<code style="white-space: pre;">&#8288;S7_data&lt;-()&#8288;</code> is called for its side-effects and returns <code>object</code>
invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>text &lt;- new_class("text", parent = class_character)
y &lt;- text(c(foo = "bar"))
y
S7_data(y)

S7_data(y) &lt;- c("a", "b")
y
</code></pre>

<hr>
<h2 id='S7_inherits'>Does this object inherit from an S7 class?</h2><span id='topic+S7_inherits'></span><span id='topic+check_is_S7'></span>

<h3>Description</h3>


<ul>
<li> <p><code>S7_inherits()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>check_is_S7()</code> throws an error if <code>x</code> isn't the specified <code>class</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>S7_inherits(x, class = NULL)

check_is_S7(x, class = NULL, arg = deparse(substitute(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S7_inherits_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="S7_inherits_+3A_class">class</code></td>
<td>
<p>An S7 class or <code>NULL</code>. If <code>NULL</code>, tests whether <code>x</code> is an
S7 object without testing for a specific class.</p>
</td></tr>
<tr><td><code id="S7_inherits_+3A_arg">arg</code></td>
<td>
<p>Argument name used in error message.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>S7_inherits()</code> returns a single <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>check_is_S7()</code> returns nothing; it's called for its side-effects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>foo1 &lt;- new_class("foo1")
foo2 &lt;- new_class("foo2")

S7_inherits(foo1(), foo1)
check_is_S7(foo1())
check_is_S7(foo1(), foo1)

S7_inherits(foo1(), foo2)
try(check_is_S7(foo1(), foo2))
</code></pre>

<hr>
<h2 id='S7_object'>Base S7 class</h2><span id='topic+S7_object'></span>

<h3>Description</h3>

<p>The base class from which all S7 classes eventually inherit from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S7_object()
</code></pre>


<h3>Value</h3>

<p>The base S7 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S7_object
</code></pre>

<hr>
<h2 id='super'>Force method dispatch to use a superclass</h2><span id='topic+super'></span>

<h3>Description</h3>

<p><code>super(from, to)</code> causes the dispatch for the next generic to use the method
for the superclass <code>to</code> instead of the actual class of <code>from</code>. It's needed
when you want to implement a method in terms of the implementation of its
superclass.
</p>


<h4>S3 &amp; S4</h4>

<p><code>super()</code> performs a similar role to <code><a href="base.html#topic+NextMethod">NextMethod()</a></code> in S3 or
<code><a href="methods.html#topic+NextMethod">methods::callNextMethod()</a></code> in S4, but is much more explicit:
</p>

<ul>
<li><p> The super class that <code>super()</code> will use is known when write <code>super()</code>
(i.e. statically) as opposed to when the generic is called
(i.e. dynamically).
</p>
</li>
<li><p> All arguments to the generic are explicit; they are not automatically
passed along.
</p>
</li></ul>

<p>This makes <code>super()</code> more verbose, but substantially easier to
understand and reason about.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>super(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="super_+3A_from">from</code></td>
<td>
<p>An S7 object to cast.</p>
</td></tr>
<tr><td><code id="super_+3A_to">to</code></td>
<td>
<p>An S7 class specification, passed to <code><a href="#topic+as_class">as_class()</a></code>. Must be a
superclass of <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>S7_super</code> object which should always be passed
immediately to a generic. It has no other special behavior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo1 &lt;- new_class("foo1", properties = list(x = class_numeric, y = class_numeric))
foo2 &lt;- new_class("foo2", foo1, properties = list(z = class_numeric))

total &lt;- new_generic("total", "x")
method(total, foo1) &lt;- function(x) x@x + x@y

# This won't work because it'll be stuck in an infinite loop:
method(total, foo2) &lt;- function(x) total(x) + x@z

# We could write
method(total, foo2) &lt;- function(x) x@x + x@y + x@z
# but then we'd need to remember to update it if the implementation
# for total(&lt;foo1&gt;) ever changed.

# So instead we use `super()` to call the method for the parent class:
method(total, foo2) &lt;- function(x) total(super(x, to = foo1)) + x@z
total(foo2(1, 2, 3))

# To see the difference between convert() and super() we need a
# method that calls another generic

bar1 &lt;- new_generic("bar1", "x")
method(bar1, foo1) &lt;- function(x) 1
method(bar1, foo2) &lt;- function(x) 2

bar2 &lt;- new_generic("bar2", "x")
method(bar2, foo1) &lt;- function(x) c(1, bar1(x))
method(bar2, foo2) &lt;- function(x) c(2, bar1(x))

obj &lt;- foo2(1, 2, 3)
bar2(obj)
# convert() affects every generic:
bar2(convert(obj, to = foo1))
# super() only affects the _next_ call to a generic:
bar2(super(obj, to = foo1))
</code></pre>

<hr>
<h2 id='validate'>Validate an S7 object</h2><span id='topic+validate'></span><span id='topic+valid_eventually'></span><span id='topic+valid_implicitly'></span>

<h3>Description</h3>

<p><code>validate()</code> ensures that an S7 object is valid by calling the <code>validator</code>
provided in <code><a href="#topic+new_class">new_class()</a></code>. This is done automatically when constructing new
objects and when modifying properties.
</p>
<p><code>valid_eventually()</code> disables validation, modifies the object, then
revalidates. This is useful when a sequence of operations would otherwise
lead an object to be temporarily invalid, or when repeated property
modification causes a performance bottleneck because the validator is
relatively expensive.
</p>
<p><code>valid_implicitly()</code> does the same but does not validate the object at the
end. It should only be used rarely, and in performance critical code where
you are certain a sequence of operations cannot produce an invalid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(object, recursive = TRUE, properties = TRUE)

valid_eventually(object, fun)

valid_implicitly(object, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_object">object</code></td>
<td>
<p>An S7 object</p>
</td></tr>
<tr><td><code id="validate_+3A_recursive">recursive</code></td>
<td>
<p>If <code>TRUE</code>, calls validator of parent classes recursively.</p>
</td></tr>
<tr><td><code id="validate_+3A_properties">properties</code></td>
<td>
<p>If <code>TRUE</code>, the default, checks property types before
executing the validator.</p>
</td></tr>
<tr><td><code id="validate_+3A_fun">fun</code></td>
<td>
<p>A function to call on the object before validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>object</code> invisibly if valid, otherwise an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A range class might validate that the start is less than the end
Range &lt;- new_class("Range",
  properties = list(start = class_double, end = class_double),
  validator = function(self) {
    if (self@start &gt;= self@end) "start must be smaller than end"
  }
)
# You can't construct an invalid object:
try(Range(1, 1))

# And you can't create an invalid object with @&lt;-
r &lt;- Range(1, 2)
try(r@end &lt;- 1)

# But what if you want to move a range to the right?
rightwards &lt;- function(r, x) {
  r@start &lt;- r@start + x
  r@end &lt;- r@end + x
  r
}
# This function doesn't work because it creates a temporarily invalid state
try(rightwards(r, 10))

# This is the perfect use case for valid_eventually():
rightwards &lt;- function(r, x) {
  valid_eventually(r, function(object) {
    object@start &lt;- object@start + x
    object@end &lt;- object@end + x
    object
  })
}
rightwards(r, 10)

# Alternatively, you can set multiple properties at once using props&lt;-,
# which validates once at the end
rightwards &lt;- function(r, x) {
  props(r) &lt;- list(start = r@start + x, end = r@end + x)
  r
}
rightwards(r, 20)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
