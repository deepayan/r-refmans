<!DOCTYPE html><html><head><title>Help for package gmGeostats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmGeostats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.DataFrameStack'><p>Extract rows of a DataFrameStack</p></a></li>
<li><a href='#[.gmCgram'><p>Subsetting of gmCgram variogram structures</p></a></li>
<li><a href='#[.logratioVariogramAnisotropy'><p>Subsetting of logratioVariogram objects</p></a></li>
<li><a href='#[[.gmCgram'><p>Subsetting of gmCgram variogram structures</p></a></li>
<li><a href='#+.gmCgram'><p>Combination of gmCgram variogram structures</p></a></li>
<li><a href='#accuracy'><p>Compute accuracy and precision</p></a></li>
<li><a href='#ana'><p>Flow anamorphosis transform</p>
Compute a transformation that gaussianizes a certain data set</a></li>
<li><a href='#anaBackward'><p>Backward gaussian anamorphosis</p>
backward transformation to multivariate gaussian scores</a></li>
<li><a href='#anaForward'><p>Forward gaussian anamorphosis</p>
forward transformation to multivariate gaussian scores</a></li>
<li><a href='#anis_GSLIBpar2A'><p>Produce anisotropy scaling matrix from angle and anisotropy ratios</p></a></li>
<li><a href='#AnisotropyRangeMatrix'><p>Force a matrix to be anisotropy range matrix,</p></a></li>
<li><a href='#AnisotropyScaling'><p>Convert to anisotropy scaling matrix</p></a></li>
<li><a href='#as.AnisotropyRangeMatrix'><p>Force a matrix to be anisotropy range matrix,</p></a></li>
<li><a href='#as.AnisotropyScaling'><p>Convert to anisotropy scaling matrix</p></a></li>
<li><a href='#as.array.DataFrameStack'><p>Convert a stacked data frame into an array</p></a></li>
<li><a href='#as.CompLinModCoReg'><p>Recast a model to the variogram model of package &quot;compositions&quot;</p></a></li>
<li><a href='#as.directorVector'><p>Express a direction as a director vector</p></a></li>
<li><a href='#as.function.gmCgram'><p>Convert a gmCgram object to an (evaluable) function</p></a></li>
<li><a href='#as.gmCgram.variogramModelList'><p>Convert theoretical structural functions to gmCgram format</p></a></li>
<li><a href='#as.gmEVario.gstatVariogram'><p>Convert empirical structural function to gmEVario format</p></a></li>
<li><a href='#as.gmSpatialModel'><p>Recast spatial object to gmSpatialModel format</p></a></li>
<li><a href='#as.gstat'><p>Convert a regionalized data container to gstat</p></a></li>
<li><a href='#as.gstatVariogram'><p>Represent an empirical variogram in &quot;gstatVariogram&quot; format</p></a></li>
<li><a href='#as.list.DataFrameStack'><p>Convert a stacked data frame into a list of data.frames</p></a></li>
<li><a href='#as.LMCAnisCompo.gstat'><p>Recast compositional variogram model to format LMCAnisCompo</p></a></li>
<li><a href='#as.logratioVariogram.gstatVariogram'><p>Recast empirical variogram to format logratioVariogram</p></a></li>
<li><a href='#as.logratioVariogramAnisotropy'><p>Convert empirical variogram to &quot;logratioVariogramAnisotropy&quot;</p></a></li>
<li><a href='#as.variogramModel'><p>Convert an LMC variogram model to gstat format</p></a></li>
<li><a href='#CholeskyDecomposition'><p>Create a parameter set specifying a LU decomposition simulation algorithm</p></a></li>
<li><a href='#coloredBiplot.genDiag'><p>Colored biplot for gemeralised diagonalisations</p>
Colored biplot method for objects of class genDiag</a></li>
<li><a href='#constructMask'><p>Constructs a mask for a grid</p></a></li>
<li><a href='#DataFrameStack'><p>Create a data frame stack</p></a></li>
<li><a href='#dimnames.DataFrameStack'><p>Return the dimnames of a DataFrameStack</p></a></li>
<li><a href='#DSpars'><p>Create a parameter set specifying a direct sampling algorithm</p></a></li>
<li><a href='#EmpiricalStructuralFunctionSpecification-class'><p>Empirical structural function specification</p></a></li>
<li><a href='#fit_lmc'><p>Fit an LMC to an empirical variogram</p></a></li>
<li><a href='#getMask'><p>Get the mask info out of a spatial data object</p></a></li>
<li><a href='#getStackElement'><p>Set or get the i-th data frame of a data.frame stack</p></a></li>
<li><a href='#getTellus'><p>Download the Tellus survey data set (NI)</p></a></li>
<li><a href='#gmApply'><p>Apply Functions Over Array or DataFrameStack Margins</p></a></li>
<li><a href='#gmGaussianMethodParameters-class'><p>parameters for Spatial Gaussian methods of any kind</p></a></li>
<li><a href='#gmGaussianSimulationAlgorithm-class'><p>parameters for Gaussian Simulation methods</p></a></li>
<li><a href='#gmMPSParameters-class'><p>parameters for Multiple-Point Statistics methods</p></a></li>
<li><a href='#gmNeighbourhoodSpecification-class'><p>Neighbourhood description</p></a></li>
<li><a href='#gmSimulationAlgorithm-class'><p>Parameter specification for a spatial simulation algorithm</p></a></li>
<li><a href='#gmSpatialDataContainer-class'><p>General description of a spatial data container</p></a></li>
<li><a href='#gmSpatialMethodParameters-class'><p>Parameter specification for any spatial method</p></a></li>
<li><a href='#gmSpatialModel-class'><p>Conditional spatial model data container</p></a></li>
<li><a href='#gmTrainingImage-class'><p>MPS training image class</p></a></li>
<li><a href='#gmUnconditionalSpatialModel-class'><p>General description of a spatial model</p></a></li>
<li><a href='#gmValidationStrategy-class'><p>Validation strategy description</p></a></li>
<li><a href='#GridOrNothing-class'><p>Superclass for grid or nothing</p></a></li>
<li><a href='#gsi.calcCgram'><p>Compute covariance matrix oout of locations</p></a></li>
<li><a href='#gsi.Cokriging'><p>Cokriging of all sorts, internal function</p></a></li>
<li><a href='#gsi.CondTurningBands'><p>Internal function, conditional turning bands realisations</p></a></li>
<li><a href='#gsi.DS'><p>Workhorse function for direct sampling</p></a></li>
<li><a href='#gsi.EVario2D'><p>Empirical variogram or covariance function in 2D</p></a></li>
<li><a href='#gsi.EVario3D'><p>Empirical variogram or covariance function in 3D</p></a></li>
<li><a href='#gsi.gstatCokriging2compo'><p>Reorganisation of cokriged compositions</p></a></li>
<li><a href='#gsi.orig'><p>extract information about the original data, if available</p></a></li>
<li><a href='#gsi.produceV'><p>Create a matrix of logcontrasts and name prefix</p></a></li>
<li><a href='#gsi.TurningBands'><p>Internal function, unconditional turning bands realisations</p></a></li>
<li><a href='#has.missings.data.frame'><p>Check presence of missings</p>
check presence of missings in a data.frame</a></li>
<li><a href='#image_cokriged'><p>Plot an image of gridded data</p></a></li>
<li><a href='#image.logratioVariogramAnisotropy'><p>Plot variogram maps for anisotropic logratio variograms</p></a></li>
<li><a href='#image.mask'><p>Image method for mask objects</p></a></li>
<li><a href='#is.anisotropySpecification'><p>Check for any anisotropy class</p></a></li>
<li><a href='#is.isotropic'><p>Check for anisotropy of a theoretical variogram</p></a></li>
<li><a href='#KrigingNeighbourhood'><p>Create a parameter set of local for neighbourhood specification.</p></a></li>
<li><a href='#LeaveOneOut'><p>Specify the leave-one-out strategy for validation of a spatial model</p></a></li>
<li><a href='#length.gmCgram'><p>Length, and number of columns or rows</p></a></li>
<li><a href='#LMCAnisCompo'><p>Create a anisotropic model for regionalized compositions</p></a></li>
<li><a href='#logratioVariogram'><p>Empirical logratio variogram calculation</p></a></li>
<li><a href='#logratioVariogram_gmSpatialModel'><p>Variogram method for gmSpatialModel objects</p></a></li>
<li><a href='#logratioVariogram,acomp-method'><p>Logratio variogram of a compositional data</p></a></li>
<li><a href='#Maf'><p>Generalised diagonalisations</p>
Calculate several generalized diagonalisations out of a data set and its empirical
variogram</a></li>
<li><a href='#make.gmCompositionalGaussianSpatialModel'><p>Construct a Gaussian gmSpatialModel for regionalized compositions</p></a></li>
<li><a href='#make.gmCompositionalMPSSpatialModel'><p>Construct a Multi-Point gmSpatialModel for regionalized compositions</p></a></li>
<li><a href='#make.gmMultivariateGaussianSpatialModel'><p>Construct a Gaussian gmSpatialModel for regionalized multivariate data</p></a></li>
<li><a href='#mean.accuracy'><p>Mean accuracy</p></a></li>
<li><a href='#mean.spatialDecorrelationMeasure'><p>Average measures of spatial decorrelation</p></a></li>
<li><a href='#ModelStructuralFunctionSpecification-class'><p>Structural function model specification</p></a></li>
<li><a href='#ndirections'><p>Number of directions of an empirical variogram</p></a></li>
<li><a href='#NfoldCrossValidation'><p>Specify a strategy for validation of a spatial model</p></a></li>
<li><a href='#NGSAustralia'><p>National Geochemical Survey of Australia: soil data</p></a></li>
<li><a href='#noSpatCorr.test'><p>Test for lack of spatial correlation</p></a></li>
<li><a href='#pairsmap'><p>Multiple maps</p>
Matrix of maps showing different combinations of components of a composition, user defined</a></li>
<li><a href='#plot.accuracy'><p>Plot method for accuracy curves</p></a></li>
<li><a href='#plot.gmCgram'><p>Draw cuves for covariance/variogram models</p></a></li>
<li><a href='#plot.gmEVario'><p>Plot empirical variograms</p></a></li>
<li><a href='#plot.logratioVariogramAnisotropy'><p>Plot variogram lines of empirical directional logratio variograms</p></a></li>
<li><a href='#plot.swarmPlot'><p>Plotting method for swarmPlot objects</p></a></li>
<li><a href='#precision'><p>Precision calculations</p></a></li>
<li><a href='#Predict'><p>Predict method for objects of class 'gmSpatialModel'</p></a></li>
<li><a href='#predict.genDiag'><p>Predict method for generalised diagonalisation objects</p></a></li>
<li><a href='#predict.LMCAnisCompo'><p>Compute model variogram values</p>
</p>
<p>Evaluate the variogram model provided at some lag vectors</p></a></li>
<li><a href='#print.mask'><p>Print method for mask objects</p></a></li>
<li><a href='#pwlrmap'><p>Compositional maps, pairwise logratios</p>
Matrix of maps showing different combinations of components of a composition, in pairwise logratios</a></li>
<li><a href='#SequentialSimulation'><p>Create a parameter set specifying a gaussian sequential simulation algorithm</p></a></li>
<li><a href='#setCgram'><p>Generate D-variate variogram models</p></a></li>
<li><a href='#setGridOrder'><p>Set or get the ordering of a grid</p></a></li>
<li><a href='#setMask'><p>Set a mask on an object</p></a></li>
<li><a href='#sortDataInGrid'><p>Reorder data in a grid</p></a></li>
<li><a href='#spatialDecorrelation'><p>Compute diagonalisation measures</p></a></li>
<li><a href='#spatialGridAcomp'><p>Construct a regionalized composition / reorder compositional simulations</p></a></li>
<li><a href='#spatialGridRmult'><p>Construct a regionalized multivariate data</p></a></li>
<li><a href='#spectralcolors'><p>Spectral colors palette</p>
based on the RColorBrewer::brewer.pal(11,&quot;Spectral&quot;)</a></li>
<li><a href='#sphTrans'><p>Spherifying transform</p>
Compute a transformation that spherifies a certain data set</a></li>
<li><a href='#stackDim'><p>Get/set name/index of (non)stacking dimensions</p></a></li>
<li><a href='#stackDim,Spatial-method'><p>Get name/index of the stacking dimension of a Spatial object</p></a></li>
<li><a href='#swarmPlot'><p>Plot a swarm of calculated output through a DataFrameStack</p></a></li>
<li><a href='#swath'><p>Swath plots</p></a></li>
<li><a href='#TurningBands'><p>Create a parameter set specifying a turning bands simulation algorithm</p></a></li>
<li><a href='#unmask'><p>Unmask a masked object</p></a></li>
<li><a href='#validate'><p>Validate a spatial model</p></a></li>
<li><a href='#variogramModelPlot'><p>Quick plotting of empirical and theoretical variograms</p>
Quick and dirty plotting of empirical variograms/covariances with or without their models</a></li>
<li><a href='#variogramModelPlot.gstatVariogram'><p>Quick plotting of empirical and theoretical variograms</p>
Quick and dirty plotting of empirical variograms/covariances with or without their models</a></li>
<li><a href='#variogramModelPlot.logratioVariogram'><p>Quick plotting of empirical and theoretical logratio variograms</p>
Quick and dirty plotting of empirical logratio variograms with or without their models</a></li>
<li><a href='#Windarling'><p>Ore composition of a bench at a mine in Windarling, West Australia.</p></a></li>
<li><a href='#write.GSLib'><p>Write a regionalized data set in GSLIB format</p></a></li>
<li><a href='#xvErrorMeasures'><p>Cross-validation errror measures</p></a></li>
<li><a href='#xvErrorMeasures.default'><p>Cross-validation errror measures</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.11.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Geostatistics for Compositional Analysis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>FNN, JADE, jointDiag, DescTools, knitr, rmarkdown (&ge; 2.3),
magrittr, readxl</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, gstat, compositions (&ge; 2.0), sp, boot, foreach,
utils, RColorBrewer</td>
</tr>
<tr>
<td>Description:</td>
<td>Support for geostatistical analysis of multivariate data, 
         in particular data with restrictions, e.g. positive amounts, 
         compositions, distributional data, microstructural data, etc. 
         It includes descriptive analysis and modelling for such data, both 
         from a two-point Gaussian perspective and multipoint perspective.
         The methods mainly follow Tolosana-Delgado, Mueller and van den
         Boogaart (2018) &lt;<a href="https://doi.org/10.1007%2Fs11004-018-9769-3">doi:10.1007/s11004-018-9769-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a> | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: CC BY-SA 4.0 | GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://codebase.helmholtz.cloud/geomet/gmGeostats">https://codebase.helmholtz.cloud/geomet/gmGeostats</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>(C) 2020 by Helmholtz-Zentrum Dresden-Rossendorf and Edith
Cowan University; gsi.DS code by Hassan Talebi</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Anamorphosis.R' 'preparations.R' 'gstatCompatibility.R'
'gmAnisotropy.R' 'compositionsCompatibility.R' 'variograms.R'
'gmSpatialMethodParameters.R' 'abstractClasses.R' 'accuracy.R'
'closeup.R' 'data.R' 'exploratools.R' 'genDiag.R' 'geostats.R'
'gmDataFrameStack.R' 'gmSimulation.R' 'gmSpatialModel.R'
'gmValidationStrategy.R' 'grids.R' 'mask.R' 'spSupport.R'
'uncorrelationTest.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-17 14:25:39 UTC; tolosa53</td>
</tr>
<tr>
<td>Author:</td>
<td>Raimon Tolosana-Delgado
    <a href="https://orcid.org/0000-0001-9847-0462"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Ute Mueller [aut],
  K. Gerald van den Boogaart [ctb, cre],
  Hassan Talebi [ctb, cph],
  Helmholtz-Zentrum Dresden-Rossendorf [cph],
  Edith Cowan University [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>K. Gerald van den Boogaart &lt;support@boogaart.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-18 11:50:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.DataFrameStack'>Extract rows of a DataFrameStack</h2><span id='topic++5B.DataFrameStack'></span>

<h3>Description</h3>

<p>Extract rows (and columns if you know what you are doing) from a stacked data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataFrameStack'
x[i = NULL, j = NULL, ..., drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.DataFrameStack_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> object</p>
</td></tr>
<tr><td><code id="+2B5B.DataFrameStack_+3A_i">i</code></td>
<td>
<p>row indices, names or logical vector of appropriate length (i.e. typically locations, observations, etc)</p>
</td></tr>
<tr><td><code id="+2B5B.DataFrameStack_+3A_j">j</code></td>
<td>
<p>column indices, names or logical vector of appropriate length. DO NOT USE if you are
not sure what you are doing. The result will be a conventional data.frame, probably with the
stacking structure destroyed.</p>
</td></tr>
<tr><td><code id="+2B5B.DataFrameStack_+3A_...">...</code></td>
<td>
<p>generic parameters, ignored.</p>
</td></tr>
<tr><td><code id="+2B5B.DataFrameStack_+3A_drop">drop</code></td>
<td>
<p>logical, if selection results in one single row or column selected, return a vector?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the DataFrameStack or data.frame of the selected rows and columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar = array(1:30, dim = c(5,2,3), dimnames=list(obs=1:5, vars=c("A","B"), rep=1:3))
dfs = DataFrameStack(ar, stackDim="rep")
dfs[1:2,]
stackDim(dfs[1:2,])
</code></pre>

<hr>
<h2 id='+5B.gmCgram'>Subsetting of gmCgram variogram structures</h2><span id='topic++5B.gmCgram'></span>

<h3>Description</h3>

<p>Extraction of some variables of a gmCgram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmCgram'
x[i, j = i, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.gmCgram_+3A_x">x</code></td>
<td>
<p><code>gmCgram</code> variogram object</p>
</td></tr>
<tr><td><code id="+2B5B.gmCgram_+3A_i">i</code></td>
<td>
<p>row-indices of the variables to be kept/removed</p>
</td></tr>
<tr><td><code id="+2B5B.gmCgram_+3A_j">j</code></td>
<td>
<p>column-indices of the variables to be kept/removed (if only <code>i</code>
is specified, <code>j</code> will be taken as equal to <code>i</code>!)</p>
</td></tr>
<tr><td><code id="+2B5B.gmCgram_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to extract the model for a a subset of variables.
If only <code>i</code> is specified, <code>j</code> will be taken as equal to <code>i</code>.
If you want to select all <code>i</code>'s for certain <code>j</code>'s or vice versa, give
<code>i=1:dim(x$nugget)[1]</code> and <code>j=</code> your desired indices, respectively
<code>j=1:dim(x$nugget)[2]</code> and <code>i=</code> your desired indices; replace <code>x</code> by the
object you are giving. If <code>i!=j</code>, the output will be a <code>c("gmXCgram","gmCgram")</code>
object, otherwise it will be a regular class <code>"gmCgram"</code> object.
If you want to extract &quot;slots&quot; or
&quot;elements&quot; of the variogram, use the $-notation. If you want to extract variables of the
variogram matrices, use the <code>[</code>-notation.
</p>


<h3>Value</h3>

<p>a <code>gmCgram</code> variogram object with the desired variables only.
</p>


<h3>See Also</h3>

<p>Other gmCgram functions: 
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(2), anisRanges = 3*diag(c(3,1)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(2), anisRanges = 0.5*diag(2))
vm = v1+v2
vm[1,1]
</code></pre>

<hr>
<h2 id='+5B.logratioVariogramAnisotropy'>Subsetting of logratioVariogram objects</h2><span id='topic++5B.logratioVariogramAnisotropy'></span><span id='topic++60+5B.logratioVariogram+60'></span>

<h3>Description</h3>

<p>Subsetting of logratioVariogram objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logratioVariogramAnisotropy'
x[i = NULL, j = NULL, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.logratioVariogramAnisotropy_+3A_x">x</code></td>
<td>
<p>an object of class &quot;logratioVariogram&quot; or c(&quot;logratioVariogramAnisotropy&quot;, &quot;logratioVariogram&quot;)</p>
</td></tr>
<tr><td><code id="+2B5B.logratioVariogramAnisotropy_+3A_i">i</code></td>
<td>
<p>index or indexes of lags to be kept (if positive) or removed (if negative)</p>
</td></tr>
<tr><td><code id="+2B5B.logratioVariogramAnisotropy_+3A_j">j</code></td>
<td>
<p>index or indexes of directions to be kept, only for objects of class c(&quot;logratioVariogramAnisotropy&quot;, &quot;logratioVariogram&quot;)</p>
</td></tr>
<tr><td><code id="+2B5B.logratioVariogramAnisotropy_+3A_...">...</code></td>
<td>
<p>extra arguments, ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the selected variograms or lags, potentially of class &quot;logratioVariogram&quot; if only one direction is chosen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
Zc = compositions::acomp(jura.pred[,7:9])
vg = logratioVariogram(data=Zc, loc=X)
vg[1]
vg = logratioVariogram(data=Zc, loc=X, azimuth=c(0,90))
vg[,1]
vg[1,1]
vg[1,]
</code></pre>

<hr>
<h2 id='+5B+5B.gmCgram'>Subsetting of gmCgram variogram structures</h2><span id='topic++5B+5B.gmCgram'></span>

<h3>Description</h3>

<p>Extraction or combination of nested structures of a gmCgram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmCgram'
x[[i, ...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B.gmCgram_+3A_x">x</code></td>
<td>
<p><code>gmCgram</code> variogram object</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.gmCgram_+3A_i">i</code></td>
<td>
<p>indices of the structures that are desired to be kept (0=nugget) or removed (see details)</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.gmCgram_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to: extract the nugget (i=0), extract some
structures (i=indices of the structures, possibly including 0 for the nugget),
or filter some structures out (i=negative indices of the structures to remove;
nugget will always removed in this case). If you want to extract &quot;slots&quot; or
&quot;elements&quot; of the variogram, use the $-notation. If you want to extract variables of the
variogram matrices, use the <code>[</code>-notation. The contrary operation (adding structures together)
is obtained by summing (+) two <code>gmCgram</code> objects.
</p>


<h3>Value</h3>

<p>a <code>gmCgram</code> variogram object with the desired structures only.
</p>


<h3>See Also</h3>

<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(2), anisRanges = 3*diag(c(3,1)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(2), anisRanges = 0.5*diag(2))
vm = v1+v2
vm[[1]]
</code></pre>

<hr>
<h2 id='+2B.gmCgram'>Combination of gmCgram variogram structures</h2><span id='topic++2B.gmCgram'></span>

<h3>Description</h3>

<p>combination of nested structures of a gmCgram object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmCgram'
x + y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.gmCgram_+3A_x">x</code></td>
<td>
<p><code>gmCgram</code> variogram object</p>
</td></tr>
<tr><td><code id="+2B2B.gmCgram_+3A_y">y</code></td>
<td>
<p><code>gmCgram</code> variogram object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The combined nested structures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(2), anisRanges = 3*diag(c(3,1)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(2), anisRanges = 0.5*diag(2))
vm = v1+v2
</code></pre>

<hr>
<h2 id='accuracy'>Compute accuracy and precision</h2><span id='topic+accuracy'></span><span id='topic+accuracy.data.frame'></span><span id='topic+accuracy.DataFrameStack'></span>

<h3>Description</h3>

<p>Computes goodness-of-fit measures (accuracy, precision and joint goodness) adapted or extended from the
definition of Deutsch (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy(object, ...)

## S3 method for class 'data.frame'
accuracy(
  object,
  observed = object$observed,
  prob = seq(from = 0, to = 1, by = 0.05),
  method = "kriging",
  outMahalanobis = FALSE,
  ivar,
  ...
)

## S3 method for class 'DataFrameStack'
accuracy(
  object,
  observed,
  ivars = intersect(colnames(observed), dimnames(object)[[noStackDim(object)]]),
  prob = seq(from = 0, to = 1, by = 0.05),
  method = ifelse(length(ivars) == 1, "simulation", "Mahalanobis"),
  outMahalanobis = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_+3A_object">object</code></td>
<td>
<p>data container for the predictions (plus cokriging error variances/covariance) or simulations (and eventually for the true values in univariate problems)</p>
</td></tr>
<tr><td><code id="accuracy_+3A_...">...</code></td>
<td>
<p>generic functionality, currently ignored</p>
</td></tr>
<tr><td><code id="accuracy_+3A_observed">observed</code></td>
<td>
<p>either a vector- or matrix-like object of the true values</p>
</td></tr>
<tr><td><code id="accuracy_+3A_prob">prob</code></td>
<td>
<p>sequence of cutoff probabilities to use for the calculations</p>
</td></tr>
<tr><td><code id="accuracy_+3A_method">method</code></td>
<td>
<p>which method was used for generating the predictions/simulations?
one of c(&quot;kriging&quot;, &quot;cokriging&quot;, &quot;simulation&quot;) for <code>object</code> of class &quot;data.frame&quot;, or of
c(&quot;simulation&quot;, &quot;mahalanobis&quot;, &quot;flow&quot;) for <code>object</code> of class <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>.</p>
</td></tr>
<tr><td><code id="accuracy_+3A_outmahalanobis">outMahalanobis</code></td>
<td>
<p>if TRUE, do not do the final accuracy calculations and return the Mahalanobis
norms of the residuals; if FALSE do the accuracy calculations</p>
</td></tr>
<tr><td><code id="accuracy_+3A_ivar">ivar</code></td>
<td>
<p>if <code>method</code>=&quot;kriging&quot; or &quot;cokriging&quot; you can also specify here one single variable name
to consider for univariate accuracy; this variable name must exist both in <code>object</code>
(including &quot;pred&quot; and &quot;var&quot; prefixes or suffixes in the column names) and in <code>observed</code>;
this might require renaming the columns of these files!</p>
</td></tr>
<tr><td><code id="accuracy_+3A_ivars">ivars</code></td>
<td>
<p>in multivariate cases, a vector of names of the variables to analyse (or one single variable name)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For method &quot;kriging&quot;, <code>object</code> must contain columns with names including the string &quot;pred&quot; for predictions
and &quot;var&quot; for the kriging variance; the observed values can also be included as an extra column with name &quot;observed&quot;,
or else additionally provided in argument <code>observed</code>. For method &quot;cokriging&quot;, the columns of <code>object</code> must contain
predictions, cokriging variances and cokriging covariances in columns including the strings &quot;pred&quot;, &quot;var&quot; resp. &quot;cov&quot;,
and observed values can only be provided via <code>observed</code> argument. Note that these are the natural formats when
using <code><a href="gstat.html#topic+predict.gstat">gstat::predict.gstat()</a></code> and other (co)kriging functions of that package.
</p>
<p>For univariate and multivariate cokriging results (methods &quot;kriging&quot; and &quot;cokriging&quot;), the coverage values are computed based on the
Mahalanobis square error, the (square) distance between prediction and true value, using as the positive definite bilinear form
of the distance the variance-covariance cokriging matrix. The rationale is that, under the assumption
that the random field is Gaussian, the distribution of this Mahalanobis square error should
follow a <code class="reqn">\chi^2(\nu)</code> with degrees of freedom <code class="reqn">\nu</code> equal to the number of variables. Having this
reference distribution allows us to compute confidence intervals for that Mahalanobis square error, and then
count how many of the actually observed errors are included on each one of the intervals (the <em>coverage</em>).
For a perfect adjustment to the distribution, the plot of coverage vs. nominal confidence (see <a href="#topic+plot.accuracy">plot.accuracy</a>)
should fall on the <code class="reqn">y=x</code> line. NOTE: the original definition of Deutsch (1997) for univariate case
did not make use of the <code class="reqn">\chi^2(1)</code> distribution, but instead derived the desired intervals (symmetric!)
from the standard normal distribution appearing by normalizing the residual with the kriging variance; the result is the
same.
</p>
<p>For method &quot;simulation&quot; and object <code>object</code> is a data.frame, the variable names containing the realisations must
contain the string &quot;sim&quot;, and <code>observed</code> must be a vector with as many elements as rows has <code>object</code>. If
<code>object</code> is a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>, then it is assumed that the stacking dimension is running through the realisations;
the true values must still be given in <code>observed</code>.
In both cases, the method is based on ranks:
with them we can calculate which is the frequency of simulations being more extreme than the observed value.
This calculation is done considering bilateral intervals around the median of (realisations, observed value)
for each location separately.
</p>
<p>Method &quot;mahalanobis&quot; (&quot;Mahalanobis&quot; also works) is the analogous for multivariate simulations. It
only works for <code>object</code> of class <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>, and requires the stacking dimension to run through
the realisations and the other two dimensions to coincide with the dimensions of <code>observed</code>, i.e.
giving locations by rows and variables by columns. In this case, a covariance matrix will be computed
and this will be used to compute the Mahalanobis square error defined above in method &quot;cokriging&quot;:
this Mahalanobis square error will be computed for each simulation and for the true value.
The simulated Mahalanobis square errors will then be used to generate the reference distribution
with which to derive confidence intervals.
</p>
<p>Finally, highly experimental &quot;flow&quot; method requires the input to be in the same shape as method
&quot;mahalanobis&quot;. The method is mostly the same, just that before the Mahalanobis square errors
are computed a location-wise flow anamorphosis (<code><a href="#topic+ana">ana()</a></code>) is applied to transform the realisations (including
the true value as one of them) to joint normality. The rest of the calculations are done as if with
method &quot;mahalanobis&quot;.
</p>


<h3>Value</h3>

<p>If <code>outMahalanobis=TRUE</code> (the primary use), this function returns a two-column dataset of class
c(&quot;accuracy&quot;, &quot;data.frame&quot;), which first column gives the nominal probability cutoffs used, and the second column
the actual coverage of the intervals of each of these probabilities. If <code>outMahalanobis=FALSE</code>, the output
is a vector (for prediction) or matrix (for simulation) of Mahalanobis error norms.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>data.frame</code>: Compute accuracy and precision
</p>
</li>
<li> <p><code>DataFrameStack</code>: Compute accuracy and precision
</p>
</li></ul>


<h3>References</h3>

<p>Mueller, Selia and Tolosana-Delgado (2023) Multivariate cross-validation
and measures of accuracy and precision.
Mathematical Geosciences (under review).
</p>


<h3>See Also</h3>

<p>Other accuracy functions: 
<code><a href="#topic+mean.accuracy">mean.accuracy</a>()</code>,
<code><a href="#topic+plot.accuracy">plot.accuracy</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+xvErrorMeasures.default">xvErrorMeasures.default</a>()</code>,
<code><a href="#topic+xvErrorMeasures">xvErrorMeasures</a>()</code>
</p>

<hr>
<h2 id='ana'>Flow anamorphosis transform
Compute a transformation that gaussianizes a certain data set</h2><span id='topic+ana'></span>

<h3>Description</h3>

<p>Flow anamorphosis transform
Compute a transformation that gaussianizes a certain data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ana(Y, sigma0 = 0.1, sigma1 = 1, steps = 30, sphere = TRUE, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ana_+3A_y">Y</code></td>
<td>
<p>data set defining the gaussianization</p>
</td></tr>
<tr><td><code id="ana_+3A_sigma0">sigma0</code></td>
<td>
<p>starting spread of the kernels</p>
</td></tr>
<tr><td><code id="ana_+3A_sigma1">sigma1</code></td>
<td>
<p>final spread of the kernels</p>
</td></tr>
<tr><td><code id="ana_+3A_steps">steps</code></td>
<td>
<p>number of steps to linearize the transform (default 30 is good)</p>
</td></tr>
<tr><td><code id="ana_+3A_sphere">sphere</code></td>
<td>
<p>boolean, should the transform include a spherifization step,
making <code>Y</code> spherical?</p>
</td></tr>
<tr><td><code id="ana_+3A_weights">weights</code></td>
<td>
<p>weights to incorporate in the compuations, length=nrow(Y)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with arguments <code>(x, inv=FALSE)</code>, where <code>x</code> will be the
data to apply the transformation to, and <code>inv=FALSE</code> will indicate if the direct
or the inverse transformation is desired
</p>


<h3>Author(s)</h3>

<p>K. Gerald van den Boogaart
</p>


<h3>See Also</h3>

<p>anaForward, anaBackward, sphTrans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(compositions)
data("jura", package="gstat")
Y = acomp(jura.pred[,c(10,12,13)])
plot(Y)
anafun = ana(Y)
class(anafun)
z = anafun(Y)
plot(z)
y = anafun(z, inv=TRUE)
plot(data.frame(orig=Y,recalc=y))
</code></pre>

<hr>
<h2 id='anaBackward'>Backward gaussian anamorphosis
backward transformation to multivariate gaussian scores</h2><span id='topic+anaBackward'></span>

<h3>Description</h3>

<p>Backward gaussian anamorphosis
backward transformation to multivariate gaussian scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anaBackward(
  x,
  Y,
  sigma0,
  sigma1 = 1 + sigma0,
  steps = 30,
  plt = FALSE,
  sphere = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anaBackward_+3A_x">x</code></td>
<td>
<p>matrix of gaussian scores to be back-transformed</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_y">Y</code></td>
<td>
<p>node points defining the transformation (a matrix, same nr of columns)</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_sigma0">sigma0</code></td>
<td>
<p>starting spread of the kernels in the forward transform</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_sigma1">sigma1</code></td>
<td>
<p>final spread of the kernels in the forward transform</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_steps">steps</code></td>
<td>
<p>number of steps to linearize the transform (default 30 is good)</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_plt">plt</code></td>
<td>
<p>boolean, do you want to get a plot of the transformation?</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_sphere">sphere</code></td>
<td>
<p>boolean, should the data be taken as pre-Y-spherified? defaults to true</p>
</td></tr>
<tr><td><code id="anaBackward_+3A_weights">weights</code></td>
<td>
<p>vector of weights for all computations, length must be equal
to number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the scores back-transformed to the same scale as <code>Y</code>; same dimensions of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>K. Gerald van den Boogaart, Raimon Tolosana-Delgado
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ana">ana()</a></code> for defining a function that carries over the transformation
(by means of a closure), <code><a href="#topic+anaBackward">anaBackward()</a></code> for the explicit back-transformation,
<code><a href="#topic+sphTrans">sphTrans()</a></code> for defining a function that carries over the spherification of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
Y = jura.pred[,c(10,12,13)]
plot(compositions::acomp(Y))
Ylr = compositions::alr(Y)
Xns = matrix(rnorm(500), ncol=2)
plot(Ylr)
points(Xns, col=2, pch=4)
Xlr = anaBackward(x=Xns, Y=Ylr, sigma0=0.1)
qqplot(Xlr[,1], Ylr[,1])
qqplot(Xlr[,2], Ylr[,2])
qqplot(Xlr[,1]+Xlr[,2], Ylr[,1]+Ylr[,2])
</code></pre>

<hr>
<h2 id='anaForward'>Forward gaussian anamorphosis
forward transformation to multivariate gaussian scores</h2><span id='topic+anaForward'></span>

<h3>Description</h3>

<p>Forward gaussian anamorphosis
forward transformation to multivariate gaussian scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anaForward(
  x,
  Y,
  sigma0,
  sigma1 = 1 + sigma0,
  steps = 30,
  plt = FALSE,
  sphere = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anaForward_+3A_x">x</code></td>
<td>
<p>points to be transformed (a matrix)</p>
</td></tr>
<tr><td><code id="anaForward_+3A_y">Y</code></td>
<td>
<p>node points defining the transformation (another matrix, same nr. of columns as <code>x</code>)</p>
</td></tr>
<tr><td><code id="anaForward_+3A_sigma0">sigma0</code></td>
<td>
<p>starting spread of the kernels</p>
</td></tr>
<tr><td><code id="anaForward_+3A_sigma1">sigma1</code></td>
<td>
<p>final spread of the kernels</p>
</td></tr>
<tr><td><code id="anaForward_+3A_steps">steps</code></td>
<td>
<p>number of steps to linearize the transform (default 30 is good)</p>
</td></tr>
<tr><td><code id="anaForward_+3A_plt">plt</code></td>
<td>
<p>boolean, do you want to get a plot of the transformation?</p>
</td></tr>
<tr><td><code id="anaForward_+3A_sphere">sphere</code></td>
<td>
<p>boolean, should the data be pre-Y-spherified first? defaults to true</p>
</td></tr>
<tr><td><code id="anaForward_+3A_weights">weights</code></td>
<td>
<p>vector of weights for all computations, length must be equal
to number of rows of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the gaussian scores; same dimensions of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>K. Gerald van den Boogaart, Raimon Tolosana-Delgado
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ana">ana()</a></code> for defining a function that carries over the transformation
(by means of a closure), <code><a href="#topic+anaBackward">anaBackward()</a></code> for the explicit back-transformation,
<code><a href="#topic+sphTrans">sphTrans()</a></code> for defining a function that carries over the spherification of the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
Y = jura.pred[,c(10,12,13)]
plot(compositions::acomp(Y))
Ylr = compositions::alr(Y)
plot(Ylr)
z = anaForward(x=Ylr, Y=Ylr, sigma0=0.1)
plot(z, asp=1)
shapiro.test(z[,1])
shapiro.test(z[,2])
</code></pre>

<hr>
<h2 id='anis_GSLIBpar2A'>Produce anisotropy scaling matrix from angle and anisotropy ratios</h2><span id='topic+anis_GSLIBpar2A'></span><span id='topic+anis2D_par2A'></span><span id='topic+anis3D_par2A'></span>

<h3>Description</h3>

<p>Produce anisotropy matrix (as the transposed of the Cholesky
decomposition) from angle and anisotropy ratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anis_GSLIBpar2A(ratios, angles, inv = FALSE)

anis2D_par2A(ratio, angle, inv = FALSE)

anis3D_par2A(ratios, angles, inv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anis_GSLIBpar2A_+3A_ratios">ratios</code></td>
<td>
<p>vector of two values between 0 and 1 giving the anisotropy ratios of
medium/largest smallest/largest ranges</p>
</td></tr>
<tr><td><code id="anis_GSLIBpar2A_+3A_angles">angles</code></td>
<td>
<p>as defined in gstat::vgm (and indeed GSLIB). For <code>anis2D_par2A</code> 'angle' is the direction of maximum range, i.e. largest spatial continuity, measured clockwise from North</p>
</td></tr>
<tr><td><code id="anis_GSLIBpar2A_+3A_inv">inv</code></td>
<td>
<p>boolean or integer, see <code>return</code> for details</p>
</td></tr>
<tr><td><code id="anis_GSLIBpar2A_+3A_ratio">ratio</code></td>
<td>
<p>an anisotropy ratio (min/max range)</p>
</td></tr>
<tr><td><code id="anis_GSLIBpar2A_+3A_angle">angle</code></td>
<td>
<p>direction of maximum range, i.e. largest spatial continuity, measured
clockwise from North</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3x3 matrix of anisotropy.
</p>
<p>If <code>inv=TRUE</code> (or 1) the output is a matrix <code>A</code> such that <code>norm(h %*% A)</code>
allows to use isotropic variograms, being <code>h = c(hx, hy, hz)</code> the lag vectors.
</p>
<p>If <code>inv=FALSE</code> (or 0) the output is a matrix <code>A</code> such that <code>norm(h %*% solve(A))</code>
allows to use isotropic variograms.
</p>
<p>Other values are meaningless.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>anis2D_par2A</code>: 2D case
</p>
</li>
<li> <p><code>anis3D_par2A</code>: 3D case
</p>
</li></ul>


<h3>See Also</h3>

<p>Other anisotropy: 
<code><a href="#topic+AnisotropyRangeMatrix">AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+AnisotropyScaling">AnisotropyScaling</a>()</code>,
<code><a href="#topic+as.AnisotropyRangeMatrix">as.AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+as.AnisotropyScaling">as.AnisotropyScaling</a>()</code>,
<code><a href="#topic+is.anisotropySpecification">is.anisotropySpecification</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ratio=0.5, azimuth 30?? (i.e. direction 60??)
A = anis2D_par2A(1, 30)
A
AAt = A %*% t(A)
 #  project the bisector 1:1 (i.e. 45??)
(k = c(1,1,0) %*% A)
atan2(k[2], k[1]) * 180/pi  # should be 15
sqrt(sum(k^2))
sqrt( c(1,1,0) %*% AAt %*% c(1,1,0) )
A = anis2D_par2A(0.5, 60)
rd = 60 * pi/180
A
A %*% t(A)
c(cos(rd), sin(rd),0) %*% A #  should be 1
c(-sin(rd), cos(rd),0) %*% A #  should be +/- sqrt(2)
c60 = cos(60*pi/180)
s60 = sin(60*pi/180)
c30 = cos(30*pi/180)
s30 = sin(30*pi/180)
#  in the new coordinates, 60cwN is (0,1,0)
R60p = anis3D_par2A(ratios=c(1,1), angles=c(60,0,0))
c(s60, c60, 0) %*% R60p
R6030 = anis3D_par2A(ratios=c(1,1), angles=c(60,30,0))
# the original X axis is positive on newX and newY, but negative on newZ
c(1,0,0) %*% R6030
# rotate first direction 60 degrees azimuth, then dip 30degrees upwards
c( c60*c30, -s60*c30, s30) %*% R6030
(Ranis = anis3D_par2A(ratios=c(0.5,0.25), angles=c(60,30,0)) )
</code></pre>

<hr>
<h2 id='AnisotropyRangeMatrix'>Force a matrix to be anisotropy range matrix,</h2><span id='topic+AnisotropyRangeMatrix'></span><span id='topic+as.AnisotropyRangeMatrix.AnisotropyScaling'></span>

<h3>Description</h3>

<p>Force a matrix M to be considered an anisotropy range matrix, i.e
with ranges and orientations,
such that <code class="reqn">u = sqrt(h' * M^{-1} * h)</code> allows to use an isotropic
variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnisotropyRangeMatrix(x, checkValidity = TRUE)

## S3 method for class 'AnisotropyScaling'
as.AnisotropyRangeMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnisotropyRangeMatrix_+3A_x">x</code></td>
<td>
<p>matrix simmetric positive definite (i.e. M above)</p>
</td></tr>
<tr><td><code id="AnisotropyRangeMatrix_+3A_checkvalidity">checkValidity</code></td>
<td>
<p>boolean, should validity be checked?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same matrix with a class attribute
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>as.AnisotropyRangeMatrix</code>: Convert from AnisotropyScaling
</p>
</li></ul>


<h3>See Also</h3>

<p>Other anisotropy: 
<code><a href="#topic+AnisotropyScaling">AnisotropyScaling</a>()</code>,
<code><a href="#topic+anis_GSLIBpar2A">anis_GSLIBpar2A</a>()</code>,
<code><a href="#topic+as.AnisotropyRangeMatrix">as.AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+as.AnisotropyScaling">as.AnisotropyScaling</a>()</code>,
<code><a href="#topic+is.anisotropySpecification">is.anisotropySpecification</a>()</code>
</p>

<hr>
<h2 id='AnisotropyScaling'>Convert to anisotropy scaling matrix</h2><span id='topic+AnisotropyScaling'></span>

<h3>Description</h3>

<p>Convert an anisotropy specification to a scaling matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AnisotropyScaling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AnisotropyScaling_+3A_x">x</code></td>
<td>
<p>an matrix to be tagged as anisotropy scaling matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An anisotropy scaling matrix <code class="reqn">A</code> is such that for any
lag vector <code class="reqn">h</code>, the variogram model turns isotropic in terms
of <code class="reqn">u'=h'\cdot A</code>. This function does not check any special
property for this matrix! You should probably be using <code>anis_GSLIBpar2A()</code>
isntead, and leave <code>AnisotropyScaling()</code> for internal uses.
</p>


<h3>See Also</h3>

<p>Other anisotropy: 
<code><a href="#topic+AnisotropyRangeMatrix">AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+anis_GSLIBpar2A">anis_GSLIBpar2A</a>()</code>,
<code><a href="#topic+as.AnisotropyRangeMatrix">as.AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+as.AnisotropyScaling">as.AnisotropyScaling</a>()</code>,
<code><a href="#topic+is.anisotropySpecification">is.anisotropySpecification</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( l = anis_GSLIBpar2A(angles=30, ratios=0.5))
( ll = unclass(l) )
AnisotropyScaling(l)
</code></pre>

<hr>
<h2 id='as.AnisotropyRangeMatrix'>Force a matrix to be anisotropy range matrix,</h2><span id='topic+as.AnisotropyRangeMatrix'></span><span id='topic+as.AnisotropyRangeMatrix.default'></span><span id='topic+as.AnisotropyRangeMatrix.AnisotropyRangeMatrix'></span>

<h3>Description</h3>

<p>Force a matrix M to be considered an anisotropy range matrix, i.e
with ranges and orientations,
such that <code class="reqn">u = sqrt(h' * M^{-1} * h)</code> allows to use an isotropic
variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.AnisotropyRangeMatrix(x)

## Default S3 method:
as.AnisotropyRangeMatrix(x)

## S3 method for class 'AnisotropyRangeMatrix'
as.AnisotropyRangeMatrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.AnisotropyRangeMatrix_+3A_x">x</code></td>
<td>
<p>matrix simmetric positive definite (i.e. M above)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same anisotropy, specified as <code>M</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Default conversion to anisotropy range matrix
</p>
</li>
<li> <p><code>AnisotropyRangeMatrix</code>: identity conversion
</p>
</li></ul>


<h3>See Also</h3>

<p>Other anisotropy: 
<code><a href="#topic+AnisotropyRangeMatrix">AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+AnisotropyScaling">AnisotropyScaling</a>()</code>,
<code><a href="#topic+anis_GSLIBpar2A">anis_GSLIBpar2A</a>()</code>,
<code><a href="#topic+as.AnisotropyScaling">as.AnisotropyScaling</a>()</code>,
<code><a href="#topic+is.anisotropySpecification">is.anisotropySpecification</a>()</code>
</p>

<hr>
<h2 id='as.AnisotropyScaling'>Convert to anisotropy scaling matrix</h2><span id='topic+as.AnisotropyScaling'></span><span id='topic+as.AnisotropyScaling.numeric'></span><span id='topic+as.AnisotropyScaling.AnisotropyScaling'></span><span id='topic+as.AnisotropyScaling.AnisotropyRangeMatrix'></span>

<h3>Description</h3>

<p>Convert an anisotropy specification to a scaling matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.AnisotropyScaling(x)

## S3 method for class 'AnisotropyScaling'
as.AnisotropyScaling(x)

## S3 method for class 'numeric'
as.AnisotropyScaling(x)

## S3 method for class 'AnisotropyRangeMatrix'
as.AnisotropyScaling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.AnisotropyScaling_+3A_x">x</code></td>
<td>
<p>an object convertible to an anisotropy scaling matrix; see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method <code>as.AnisotropyScaling.numeric()</code> expects a vector of two numbers in 2D,
or a vector of 5 numbers in 3D. These are in 2D, the azimuth of maximum continuity (in
degrees, clockwise from North) and the anisotropy ratio of short/long range. In 3D
these are: 1,2) the azimuth and the dip of the direction of maximal continuity; 3) the
angle of rotation around the axis of the first direction; 4,5) the anisotropy ratios of
the ranges of the second/first and third/first directions of maximal continuity. All angles
are given in degrees, all ratios must be smaller or equal to 1. This follows gstat (and hence
GSlib) conventions; see gstat::vgm() for details.
</p>


<h3>Value</h3>

<p>A matrix <code class="reqn">A</code> such that for any lag vector <code class="reqn">h</code>, the variogram model turns
isotropic in terms of <code class="reqn">u'=h'\cdot A</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>AnisotropyScaling</code>: identity method
</p>
</li>
<li> <p><code>numeric</code>: from a vector of numbers
</p>
</li>
<li> <p><code>AnisotropyRangeMatrix</code>: from an AnisotropicRangeMatrix
</p>
</li></ul>


<h3>See Also</h3>

<p>Other anisotropy: 
<code><a href="#topic+AnisotropyRangeMatrix">AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+AnisotropyScaling">AnisotropyScaling</a>()</code>,
<code><a href="#topic+anis_GSLIBpar2A">anis_GSLIBpar2A</a>()</code>,
<code><a href="#topic+as.AnisotropyRangeMatrix">as.AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+is.anisotropySpecification">is.anisotropySpecification</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>( l = anis_GSLIBpar2A(angles=30, ratios=0.5))
( ll = unclass(l) )
as.AnisotropyScaling(ll)
</code></pre>

<hr>
<h2 id='as.array.DataFrameStack'>Convert a stacked data frame into an array</h2><span id='topic+as.array.DataFrameStack'></span>

<h3>Description</h3>

<p>Recast a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> into a named array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataFrameStack'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array.DataFrameStack_+3A_x">x</code></td>
<td>
<p>input <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code></p>
</td></tr>
<tr><td><code id="as.array.DataFrameStack_+3A_...">...</code></td>
<td>
<p>generic consistency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data recasted as an array with appropriate names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll = lapply(1:3, function(i) as.data.frame(matrix(1:10+(i-1)*10, ncol=2)))
dfs = DataFrameStack(ll, stackDimName="rep")
as.array(dfs)

</code></pre>

<hr>
<h2 id='as.CompLinModCoReg'>Recast a model to the variogram model of package &quot;compositions&quot;</h2><span id='topic+as.CompLinModCoReg'></span><span id='topic+as.CompLinModCoReg.CompLinModCoReg'></span><span id='topic+as.CompLinModCoReg.LMCAnisCompo'></span>

<h3>Description</h3>

<p>Recast a variogram model specified in any of the models of &quot;gstat&quot; or &quot;gmGeostats&quot; in
the format of <code><a href="compositions.html#topic+CompLinModCo">compositions::CompLinModCoReg()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.CompLinModCoReg(v, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.CompLinModCoReg_+3A_v">v</code></td>
<td>
<p>variogram model object to convert</p>
</td></tr>
<tr><td><code id="as.CompLinModCoReg_+3A_...">...</code></td>
<td>
<p>further parameters for generic functionality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variogram model recast to &quot;CompLinModCoReg&quot;
</p>

<hr>
<h2 id='as.directorVector'>Express a direction as a director vector</h2><span id='topic+as.directorVector'></span><span id='topic+as.directorVector.default'></span><span id='topic+as.directorVector.azimuth'></span><span id='topic+as.directorVector.azimuthInterval'></span>

<h3>Description</h3>

<p>Internal methods to express a direction (in 2D or 3D) as director
vector(s). These functions are not intended for direct use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.directorVector(x, ...)

## Default S3 method:
as.directorVector(x, ...)

## S3 method for class 'azimuth'
as.directorVector(x, D = 2, ...)

## S3 method for class 'azimuthInterval'
as.directorVector(x, D = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.directorVector_+3A_x">x</code></td>
<td>
<p>value of the direction in a certain representation</p>
</td></tr>
<tr><td><code id="as.directorVector_+3A_...">...</code></td>
<td>
<p>extra parameters for generic functionality</p>
</td></tr>
<tr><td><code id="as.directorVector_+3A_d">D</code></td>
<td>
<p>dimension currently used (D=2 default; otherwise D=3; other values are not accepted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2- or 3- column matrix which rows represents the unit
director vector of each direction specified.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: default method
</p>
</li>
<li> <p><code>azimuth</code>: method for azimuths
</p>
</li>
<li> <p><code>azimuthInterval</code>: method for azimuthIntervals
</p>
</li></ul>

<hr>
<h2 id='as.function.gmCgram'>Convert a gmCgram object to an (evaluable) function</h2><span id='topic+as.function.gmCgram'></span><span id='topic+predict.gmCgram'></span>

<h3>Description</h3>

<p>Evaluate a gmCgram on some h values, or convert the gmCgram object into an evaluable function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmCgram'
as.function(x, ...)

## S3 method for class 'gmCgram'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.function.gmCgram_+3A_x">x</code></td>
<td>
<p>a gmCgram object</p>
</td></tr>
<tr><td><code id="as.function.gmCgram_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="as.function.gmCgram_+3A_object">object</code></td>
<td>
<p>gmCgram object</p>
</td></tr>
<tr><td><code id="as.function.gmCgram_+3A_newdata">newdata</code></td>
<td>
<p>matrix, data.frame or Spatial object containing coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>function</code> that can be evaluated normally, with an argument <code>X</code>
and possibly another argument <code>Y</code>; both must have the same number of columns
than the geographic dimension of the variogram (i.e. <code>dim(x$M)[3]</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>predict.gmCgram</code>: predict a gmCgram object on some lag vector coordinates
</p>
</li></ul>


<h3>See Also</h3>

<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(2)+0.5, anisRanges = 2*diag(c(3,0.5)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(2), anisRanges = 0.5*diag(2))
vm = v1+v2
vgf = as.function(vm)
(h = rbind(c(0,1), c(0,0), c(1,1)))
vgf(h)
predict(vm, h)
</code></pre>

<hr>
<h2 id='as.gmCgram.variogramModelList'>Convert theoretical structural functions to gmCgram format</h2><span id='topic+as.gmCgram.variogramModelList'></span><span id='topic+as.gmCgram.variogramModel'></span><span id='topic+as.gmCgram.LMCAnisCompo'></span><span id='topic+as.gmCgram'></span><span id='topic+as.gmCgram.default'></span>

<h3>Description</h3>

<p>Convert covariance function or variogram models to the format gmCgram
of package gmGeostats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogramModelList'
as.gmCgram(m, ...)

## S3 method for class 'variogramModel'
as.gmCgram(m, ...)

## S3 method for class 'LMCAnisCompo'
as.gmCgram(
  m,
  V = attr(m, "contrasts"),
  orignames = rownames(m["sill", 1]$sill),
  ...
)

as.gmCgram(m, ...)

## Default S3 method:
as.gmCgram(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gmCgram.variogramModelList_+3A_m">m</code></td>
<td>
<p>model to be converted</p>
</td></tr>
<tr><td><code id="as.gmCgram.variogramModelList_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="as.gmCgram.variogramModelList_+3A_v">V</code></td>
<td>
<p>original logratio matrix used in the definition of &quot;LMCAnisCompo&quot;</p>
</td></tr>
<tr><td><code id="as.gmCgram.variogramModelList_+3A_orignames">orignames</code></td>
<td>
<p>original variable names of the composition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the covariance/variogram model, recasted to class <code>gmCgram</code>.
This is a generic function. Methods exist for objects of class
<code>LMCAnisCompo</code> (for compositional data) and <code>variogramModelList</code>
(as provided by package <code>gstat</code>).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>variogramModelList</code>: Convert theoretical structural functions to gmCgram format
</p>
</li>
<li> <p><code>variogramModel</code>: Convert theoretical structural functions to gmCgram format
</p>
</li>
<li> <p><code>LMCAnisCompo</code>: method for &quot;LMCAnisCompo&quot; variogram model objects
</p>
</li>
<li> <p><code>default</code>: Convert theoretical structural functions to gmCgram format
</p>
</li></ul>


<h3>See Also</h3>

<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>

<hr>
<h2 id='as.gmEVario.gstatVariogram'>Convert empirical structural function to gmEVario format</h2><span id='topic+as.gmEVario.gstatVariogram'></span><span id='topic+as.gmEVario.logratioVariogram'></span><span id='topic+as.gmEVario.logratioVariogramAnisotropy'></span><span id='topic+as.gmEVario'></span><span id='topic+as.gmEVario.default'></span>

<h3>Description</h3>

<p>Convert empirical covariance functions or variograms to the format gmEVario
of package gmGeostats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstatVariogram'
as.gmEVario(vgemp, ...)

## S3 method for class 'logratioVariogram'
as.gmEVario(vgemp, ...)

## S3 method for class 'logratioVariogramAnisotropy'
as.gmEVario(vgemp, ...)

as.gmEVario(vgemp, ...)

## Default S3 method:
as.gmEVario(vgemp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gmEVario.gstatVariogram_+3A_vgemp">vgemp</code></td>
<td>
<p>variogram/covariance function to be converted</p>
</td></tr>
<tr><td><code id="as.gmEVario.gstatVariogram_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the empirical covariance function or variogram, recasted to class
<code>gmEVario</code>. This is a generic function. Methods exist for objects of
class <code>logratioVariogram</code><code>logratioVariogramAnisotropy</code>
(for compositional data) and <code>gstatVariogram</code>
(from package <code>gstat</code>).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gstatVariogram</code>: gstatVariogram method not yet available
</p>
</li>
<li> <p><code>logratioVariogram</code>: logratioVariogram method not yet available
</p>
</li>
<li> <p><code>logratioVariogramAnisotropy</code>: logratioVariogramAnisotropy method not yet available
</p>
</li>
<li> <p><code>default</code>: default method
</p>
</li></ul>


<h3>See Also</h3>

<p>Other gmEVario functions: 
<code><a href="#topic+gsi.EVario2D">gsi.EVario2D</a>()</code>,
<code><a href="#topic+gsi.EVario3D">gsi.EVario3D</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmEVario">plot.gmEVario</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>

<hr>
<h2 id='as.gmSpatialModel'>Recast spatial object to gmSpatialModel format</h2><span id='topic+as.gmSpatialModel'></span><span id='topic+as.gmSpatialModel.default'></span><span id='topic+as.gmSpatialModel.gstat'></span>

<h3>Description</h3>

<p>Recast a spatial data object model to format gmSpatialModel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gmSpatialModel(object, ...)

## Default S3 method:
as.gmSpatialModel(object, ...)

## S3 method for class 'gstat'
as.gmSpatialModel(object, V = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gmSpatialModel_+3A_object">object</code></td>
<td>
<p>object to recast</p>
</td></tr>
<tr><td><code id="as.gmSpatialModel_+3A_...">...</code></td>
<td>
<p>extra parameters for generic functionality</p>
</td></tr>
<tr><td><code id="as.gmSpatialModel_+3A_v">V</code></td>
<td>
<p>optional, if the original data in the sptail object was compositional, which logcontrasts
were used to express it? Thsi can be either one string of &quot;alr&quot;, &quot;ilr&quot; or &quot;clr&quot;, or else a
(Dx(D-1))-element matrix of logcontrasts to pass from compositions to logratios</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same spatial object re-structured as a &quot;gmSpatialModel&quot;, see <a href="#topic+gmSpatialModel-class">gmSpatialModel</a>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Recast spatial object to gmSpatialModel format
</p>
</li>
<li> <p><code>gstat</code>: Recast spatial object to gmSpatialModel format
</p>
</li></ul>


<h3>See Also</h3>

<p>Other gmSpatialModel: 
<code><a href="#topic+Predict">Predict</a>()</code>,
<code><a href="#topic+gmSpatialModel-class">gmSpatialModel-class</a></code>,
<code><a href="#topic+make.gmCompositionalGaussianSpatialModel">make.gmCompositionalGaussianSpatialModel</a>()</code>,
<code><a href="#topic+make.gmCompositionalMPSSpatialModel">make.gmCompositionalMPSSpatialModel</a>()</code>,
<code><a href="#topic+make.gmMultivariateGaussianSpatialModel">make.gmMultivariateGaussianSpatialModel</a>()</code>
</p>

<hr>
<h2 id='as.gstat'>Convert a regionalized data container to gstat</h2><span id='topic+as.gstat'></span><span id='topic+as.gstat.default'></span>

<h3>Description</h3>

<p>Convert a regionalized data container to a &quot;gstat&quot; model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gstat(object, ...)

## Default S3 method:
as.gstat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gstat_+3A_object">object</code></td>
<td>
<p>regionalized data container</p>
</td></tr>
<tr><td><code id="as.gstat_+3A_...">...</code></td>
<td>
<p>accessory parameters (currently not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A regionalized data container of class &quot;gstat&quot;,
eventually with variogram model included. See <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code> for more info.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as.gstat.default</code>: default does nothing
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package = "gstat")
X = jura.pred[,1:2]
Zc = jura.pred[,7:13]
gg = make.gmCompositionalGaussianSpatialModel(Zc, X, V="alr", formula = ~1)
as.gstat(gg)
</code></pre>

<hr>
<h2 id='as.gstatVariogram'>Represent an empirical variogram in &quot;gstatVariogram&quot; format</h2><span id='topic+as.gstatVariogram'></span><span id='topic+as.gstatVariogram.default'></span><span id='topic+as.gstatVariogram.gmEVario'></span><span id='topic+as.gstatVariogram.logratioVariogram'></span><span id='topic+as.gstatVariogram.logratioVariogramAnisotropy'></span>

<h3>Description</h3>

<p>Represent an empirical variogram in &quot;gstatVariogram&quot; format, from package &quot;gstat&quot;; see <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code>
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gstatVariogram(vgemp, ...)

## Default S3 method:
as.gstatVariogram(vgemp, ...)

## S3 method for class 'gmEVario'
as.gstatVariogram(vgemp, ...)

## S3 method for class 'logratioVariogram'
as.gstatVariogram(
  vgemp,
  V = NULL,
  dir.hor = 0,
  dir.ver = 0,
  prefix = NULL,
  ...
)

## S3 method for class 'logratioVariogramAnisotropy'
as.gstatVariogram(vgemp, V = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gstatVariogram_+3A_vgemp">vgemp</code></td>
<td>
<p>empirical variogram of any kind</p>
</td></tr>
<tr><td><code id="as.gstatVariogram_+3A_...">...</code></td>
<td>
<p>further parameters (for generic functionality)</p>
</td></tr>
<tr><td><code id="as.gstatVariogram_+3A_v">V</code></td>
<td>
<p>eventually, indicator of which logratio should be used (one of: a matrix of logcontrasts, or of the strings &quot;ilr&quot;, &quot;alr&quot; or &quot;clr&quot;)</p>
</td></tr>
<tr><td><code id="as.gstatVariogram_+3A_dir.hor">dir.hor</code></td>
<td>
<p>eventually, which horizontal direction is captured by the  variogram provided (seldom to be touched!)</p>
</td></tr>
<tr><td><code id="as.gstatVariogram_+3A_dir.ver">dir.ver</code></td>
<td>
<p>eventually, which vertical direction is captured by the  variogram provided (seldom to be touched!)</p>
</td></tr>
<tr><td><code id="as.gstatVariogram_+3A_prefix">prefix</code></td>
<td>
<p>prefix name to use for the variables created (seldom needed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class &quot;gstatVariogram&quot; containing the empirical variogram provided.
See <code>gstat::variogram()</code> for details.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Represent an empirical variogram in &quot;gstatVariogram&quot; format
</p>
</li>
<li> <p><code>gmEVario</code>: Represent an empirical variogram in &quot;gstatVariogram&quot; format (not yet available)
</p>
</li>
<li> <p><code>logratioVariogram</code>: Represent an empirical variogram in &quot;gstatVariogram&quot; format
</p>
</li>
<li> <p><code>logratioVariogramAnisotropy</code>: Represent an empirical variogram in &quot;gstatVariogram&quot; format
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package = "gstat")
X = jura.pred[,1:2]
Zc = compositions::acomp(jura.pred[,7:13])
lrvg = gmGeostats::logratioVariogram(data=Zc, loc=X)
as.gstatVariogram(lrvg, V="alr")
</code></pre>

<hr>
<h2 id='as.list.DataFrameStack'>Convert a stacked data frame into a list of data.frames</h2><span id='topic+as.list.DataFrameStack'></span>

<h3>Description</h3>

<p>Recast a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> into a list of data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataFrameStack'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.DataFrameStack_+3A_x">x</code></td>
<td>
<p>input <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code></p>
</td></tr>
<tr><td><code id="as.list.DataFrameStack_+3A_...">...</code></td>
<td>
<p>generic consistency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data recasted as list of data.frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar = array(1:30, dim = c(5,2,3), dimnames=list(obs=1:5, vars=c("A","B"), rep=1:3))
dfs = DataFrameStack(ar, stackDim="rep")
as.list(dfs)
</code></pre>

<hr>
<h2 id='as.LMCAnisCompo.gstat'>Recast compositional variogram model to format LMCAnisCompo</h2><span id='topic+as.LMCAnisCompo.gstat'></span><span id='topic+as.LMCAnisCompo.variogramModelList'></span><span id='topic+as.LMCAnisCompo'></span><span id='topic+gstat2LMCAnisCompo'></span><span id='topic+as.LMCAnisCompo.LMCAnisCompo'></span><span id='topic+as.LMCAnisCompo.gmCgram'></span><span id='topic+as.LMCAnisCompo.CompLinModCoReg'></span>

<h3>Description</h3>

<p>Recast a compositional variogram model of any sort to a variation-variogram model of class
&quot;LMCAnisCompo&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstat'
as.LMCAnisCompo(m, ...)

## S3 method for class 'variogramModelList'
as.LMCAnisCompo(m, V = NULL, orignames = NULL, ...)

as.LMCAnisCompo(m, ...)

## S3 method for class 'LMCAnisCompo'
as.LMCAnisCompo(m, ...)

## S3 method for class 'gmCgram'
as.LMCAnisCompo(m, V = NULL, orignames = rownames(V), ...)

## S3 method for class 'CompLinModCoReg'
as.LMCAnisCompo(m, varnames, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.LMCAnisCompo.gstat_+3A_m">m</code></td>
<td>
<p>original variogram model</p>
</td></tr>
<tr><td><code id="as.LMCAnisCompo.gstat_+3A_...">...</code></td>
<td>
<p>arguments for generic functionality</p>
</td></tr>
<tr><td><code id="as.LMCAnisCompo.gstat_+3A_v">V</code></td>
<td>
<p>eventually, a specification of the way <code>m</code> is presently represented</p>
</td></tr>
<tr><td><code id="as.LMCAnisCompo.gstat_+3A_orignames">orignames</code></td>
<td>
<p>eventually, vector of names of the components, if <code>V</code> is provided and it does not have rownnames</p>
</td></tr>
<tr><td><code id="as.LMCAnisCompo.gstat_+3A_varnames">varnames</code></td>
<td>
<p>a vector with the component names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the variogram model recasted to class &quot;LMCAnisCompo&quot;
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gstat</code>: Recast compositional variogram model to format LMCAnisCompo
</p>
</li>
<li> <p><code>variogramModelList</code>: Recast compositional variogram model to format LMCAnisCompo
</p>
</li>
<li> <p><code>LMCAnisCompo</code>: Recast compositional variogram model to format LMCAnisCompo
</p>
</li>
<li> <p><code>gmCgram</code>: Recast compositional variogram model to format LMCAnisCompo
</p>
</li>
<li> <p><code>CompLinModCoReg</code>: Recast a variogram model from package &quot;compositions&quot; to format LMCAnisCompo
</p>
</li></ul>

<hr>
<h2 id='as.logratioVariogram.gstatVariogram'>Recast empirical variogram to format logratioVariogram</h2><span id='topic+as.logratioVariogram.gstatVariogram'></span><span id='topic+as.logratioVariogram'></span><span id='topic+as.logratioVariogram.logratioVariogram'></span><span id='topic+as.logratioVariogram.gmEVario'></span>

<h3>Description</h3>

<p>Recast an empirical compositional variogram of any sort to a variation-variogram of class
&quot;logratioVariogram&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstatVariogram'
as.logratioVariogram(
  vgemp,
  V = NULL,
  tol = 1e-12,
  orignames = NULL,
  symmetrize = FALSE,
  ...
)

as.logratioVariogram(vgemp, ...)

## S3 method for class 'logratioVariogram'
as.logratioVariogram(vgemp, ...)

## S3 method for class 'gmEVario'
as.logratioVariogram(vgemp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.logratioVariogram.gstatVariogram_+3A_vgemp">vgemp</code></td>
<td>
<p>empirical variogram</p>
</td></tr>
<tr><td><code id="as.logratioVariogram.gstatVariogram_+3A_v">V</code></td>
<td>
<p>matrix or name of the logratio transformation used</p>
</td></tr>
<tr><td><code id="as.logratioVariogram.gstatVariogram_+3A_tol">tol</code></td>
<td>
<p>tolerance for generalized inverse (eventually for clr case; defaults to 1e-12)</p>
</td></tr>
<tr><td><code id="as.logratioVariogram.gstatVariogram_+3A_orignames">orignames</code></td>
<td>
<p>names of the original component (default NULL)</p>
</td></tr>
<tr><td><code id="as.logratioVariogram.gstatVariogram_+3A_symmetrize">symmetrize</code></td>
<td>
<p>do you want a whole circle of directions? (default FALSE)</p>
</td></tr>
<tr><td><code id="as.logratioVariogram.gstatVariogram_+3A_...">...</code></td>
<td>
<p>parameters for generic functionality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same model in the new format.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gstatVariogram</code>: method for gstatVariogram objects
</p>
</li>
<li> <p><code>logratioVariogram</code>: identity method
</p>
</li>
<li> <p><code>gmEVario</code>: method for gmEVario objects (not yet available)
</p>
</li></ul>

<hr>
<h2 id='as.logratioVariogramAnisotropy'>Convert empirical variogram to &quot;logratioVariogramAnisotropy&quot;</h2><span id='topic+as.logratioVariogramAnisotropy'></span><span id='topic+as.logratioVariogramAnisotropy.default'></span><span id='topic+as.logratioVariogramAnisotropy.logratioVariogram'></span><span id='topic+as.logratioVariogramAnisotropy.logratioVariogramAnisotropy'></span>

<h3>Description</h3>

<p>Convert an empirical variogram from any format to class &quot;logratioVariogramAnisotropy&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.logratioVariogramAnisotropy(vgemp, ...)

## Default S3 method:
as.logratioVariogramAnisotropy(vgemp, ...)

## S3 method for class 'logratioVariogram'
as.logratioVariogramAnisotropy(vgemp, ...)

## S3 method for class 'logratioVariogramAnisotropy'
as.logratioVariogramAnisotropy(vgemp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.logratioVariogramAnisotropy_+3A_vgemp">vgemp</code></td>
<td>
<p>an empirical variogram</p>
</td></tr>
<tr><td><code id="as.logratioVariogramAnisotropy_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The empirical variogram as a  &quot;logratioVariogramAnisotropy&quot; object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: default method, making use of <code>as.logratioVariogram()</code>
</p>
</li>
<li> <p><code>logratioVariogram</code>: method for &quot;logratioVariogram&quot; class
</p>
</li>
<li> <p><code>logratioVariogramAnisotropy</code>: identity transformation
</p>
</li></ul>

<hr>
<h2 id='as.variogramModel'>Convert an LMC variogram model to gstat format</h2><span id='topic+as.variogramModel'></span><span id='topic+as.variogramModel.default'></span><span id='topic+as.variogramModel.gmCgram'></span><span id='topic+as.variogramModel.LMCAnisCompo'></span><span id='topic+as.variogramModel.CompLinModCoReg'></span>

<h3>Description</h3>

<p>Convert a linear model of coregionalisation to the format of package gstat. See <code><a href="gstat.html#topic+vgm">gstat::vgm()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.variogramModel(m, ...)

## Default S3 method:
as.variogramModel(m, ...)

## S3 method for class 'gmCgram'
as.variogramModel(m, ...)

## S3 method for class 'LMCAnisCompo'
as.variogramModel(m, V = NULL, prefix = NULL, ensurePSD = TRUE, ...)

## S3 method for class 'CompLinModCoReg'
as.variogramModel(m, V = "alr", prefix = NULL, ensurePSD = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.variogramModel_+3A_m">m</code></td>
<td>
<p>variogram model</p>
</td></tr>
<tr><td><code id="as.variogramModel_+3A_...">...</code></td>
<td>
<p>further arguments for generic functionality</p>
</td></tr>
<tr><td><code id="as.variogramModel_+3A_v">V</code></td>
<td>
<p>eventually, specification of the logratio representation to use
for compositional data (one of: a matrix of log-contrasts to use, or else one of
the strings &quot;alr&quot;, &quot;clr&quot; or &quot;ilr&quot;)</p>
</td></tr>
<tr><td><code id="as.variogramModel_+3A_prefix">prefix</code></td>
<td>
<p>optional, name prefix for the generated variables if a transformation is used</p>
</td></tr>
<tr><td><code id="as.variogramModel_+3A_ensurepsd">ensurePSD</code></td>
<td>
<p>logical, should positive-definiteness be enforced? defaults to TRUE, which may
produce several scary looking but mostly danger-free warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The LMC model specified in the format of package gstat, i.e. as the result
of using <code><a href="gstat.html#topic+vgm">gstat::vgm()</a></code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Convert an LMC variogram model to gstat format
</p>
</li>
<li> <p><code>gmCgram</code>: Convert an LMC variogram model to gstat format
</p>
</li>
<li> <p><code>LMCAnisCompo</code>: Convert an LMC variogram model to gstat format
</p>
</li>
<li> <p><code>CompLinModCoReg</code>: Convert an LMC variogram model to gstat format
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package = "gstat")
X = jura.pred[,1:2]
Zc = compositions::acomp(jura.pred[,7:13])
lrmd = compositions::CompLinModCoReg(formula=~nugget()+sph(1.5), comp=Zc)
as.variogramModel(lrmd, V="alr")
</code></pre>

<hr>
<h2 id='CholeskyDecomposition'>Create a parameter set specifying a LU decomposition simulation algorithm</h2><span id='topic+CholeskyDecomposition'></span>

<h3>Description</h3>

<p>Create a parameter set describing a Cholesky (or LU) decomposition algorithm to two-point simulation,
mostly for covariance or variogram-based gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CholeskyDecomposition(nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CholeskyDecomposition_+3A_nsim">nsim</code></td>
<td>
<p>number of realisations desired</p>
</td></tr>
<tr><td><code id="CholeskyDecomposition_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be
initialized, see <code>?simulate</code> in base &quot;stats&quot; package</p>
</td></tr>
<tr><td><code id="CholeskyDecomposition_+3A_...">...</code></td>
<td>
<p>further parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3-list of class &quot;gmCholeskyDecomposition&quot; containing the few elements given as arguments
to the function. This is just a compact way to provide further functions such as <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a>
with appropriate triggers for choosing a prediction method or another, in this case for triggering
LU or Cholesky decomposition simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(chols_local = CholeskyDecomposition(nsim=100, nBands=300))
## then run predict(..., pars=chols_local)
</code></pre>

<hr>
<h2 id='coloredBiplot.genDiag'>Colored biplot for gemeralised diagonalisations
Colored biplot method for objects of class genDiag</h2><span id='topic+coloredBiplot.genDiag'></span>

<h3>Description</h3>

<p>Colored biplot for gemeralised diagonalisations
Colored biplot method for objects of class genDiag
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genDiag'
coloredBiplot(x, choices = 1:2, scale = 0, pc.biplot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloredBiplot.genDiag_+3A_x">x</code></td>
<td>
<p>a generalized diagonalisation object, as obtained from a call to
<code><a href="#topic+Maf">Maf</a></code> (or to <code>UWEDGE</code> or <code>RJD</code>, on the help page of <code><a href="#topic+Maf">Maf</a></code>).</p>
</td></tr>
<tr><td><code id="coloredBiplot.genDiag_+3A_choices">choices</code></td>
<td>
<p>which factors should be represented? vector of 2 indices; defaults to
c(1,2)</p>
</td></tr>
<tr><td><code id="coloredBiplot.genDiag_+3A_scale">scale</code></td>
<td>
<p>deprecated, kept for coherence with <code>link{biplot.princomp}</code></p>
</td></tr>
<tr><td><code id="coloredBiplot.genDiag_+3A_pc.biplot">pc.biplot</code></td>
<td>
<p>same as the homonimous argument from <code>link{biplot.princomp}</code>:
boolean, to scale variables down by sqrt(n) and observations up by the same factor.</p>
</td></tr>
<tr><td><code id="coloredBiplot.genDiag_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="compositions.html#topic+coloredBiplot">coloredBiplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing. Function is called exclusively to produce the plot
</p>


<h3>References</h3>

<p>Mueller, Tolosana-Delgado, Grunsky and McKinley (2020) Biplots for
compositional data derived from generalised joint diagonalization methods.
Applied Computational Geosciences 8:100044 doi: <a href="https://doi.org/10.1016/j.acags.2020.100044">10.1016/j.acags.2020.100044</a>
</p>


<h3>See Also</h3>

<p>Other generalised Diagonalisations: 
<code><a href="#topic+Maf">Maf</a>()</code>,
<code><a href="#topic+predict.genDiag">predict.genDiag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
juracomp = compositions::acomp(jura.pred[, -(1:6)]) 
lrvg = logratioVariogram(data=juracomp, loc=jura.pred[,1:2])
mf = Maf(juracomp, vg=lrvg)
mf
compositions::coloredBiplot(mf, xlabs.col=as.integer(jura.pred$Rock)+2)
</code></pre>

<hr>
<h2 id='constructMask'>Constructs a mask for a grid</h2><span id='topic+constructMask'></span>

<h3>Description</h3>

<p>Constructs a mask for a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructMask(grid, method = "maxdist", maxval = NULL, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constructMask_+3A_grid">grid</code></td>
<td>
<p>a grid, see details for more info</p>
</td></tr>
<tr><td><code id="constructMask_+3A_method">method</code></td>
<td>
<p>which construction method? currently one of 'maxdist', 'sillprop' or 'point2polygon'</p>
</td></tr>
<tr><td><code id="constructMask_+3A_maxval">maxval</code></td>
<td>
<p>for maxdist and sillprop methods, maximum reference value</p>
</td></tr>
<tr><td><code id="constructMask_+3A_x">x</code></td>
<td>
<p>extra information for the grid construction, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method 'maxdist' defines the mask as all points within a maximum distance
(must be given in <code>maxval</code>) from the reference data (given in <code>x</code>: this is expected
to be the original complete data, with coordinates and variables). For method 'sillprop'
the mask is defined by those points which total kriging variance is below
a fixed proportion (given in <code>maxval</code>, default=0.99) of the total variogram
model sill (variogram model given in <code>x</code>, of class &quot;variogramModelList&quot;).
In this method, the argument <code>grid</code> is expected to be the output of a cokriging
analysis. Finally, method 'point2poly' created the mask by taking the points internal
to a &quot;SpatialPolygon&quot; object (given in <code>x</code>).
</p>


<h3>Value</h3>

<p>a logical vector with as many elements as points in the grid, with TRUE for
those points within the mask, and FALSE for those outside the mask.
</p>


<h3>See Also</h3>

<p>Other masking functions: 
<code><a href="#topic+getMask">getMask</a>()</code>,
<code><a href="#topic+print.mask">print.mask</a>()</code>,
<code><a href="#topic+setMask">setMask</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## with data.frame
x = 1:23
y = 1:29
xy = expand.grid(x=x, y=y)
xyz.df = data.frame(xy, z = rnorm(29*23)*ifelse(abs(xy$x-xy$y)&lt;3, 1, NA)+(xy$x+xy$y)/2)
mask.df = constructMask(grid = xy, method = "maxdist", maxval = 3, x=xyz.df)
image(mask.df)
oldpar = par(mfrow = c(1,1))
mask.df
xyz.df.masked = setMask(xyz.df, mask.df)
dim(xyz.df.masked)
summary(xyz.df.masked)
xyz.df.unmasked = unmask(xyz.df.masked)
dim(xyz.df.unmasked)
length(x)*length(y)
summary(xyz.df.unmasked)
## with SpatialGrid
library(sp)
library(magrittr)
xy.sp = sp::SpatialPoints(coords = xy)
meandiff = function(x) mean(diff(x))
xy.gt = GridTopology(c(min(x),min(y)), c(meandiff(x), meandiff(y)), c(length(x),length(y)))
aux = sp::SpatialPixelsDataFrame(grid = xy.gt, data=xyz.df, points = xy.sp)
xyz.sgdf = as(aux, "SpatialGridDataFrame")
image_cokriged(xyz.sgdf, ivar="z")
## reorder the data in the grid and plot again
par(mfrow=c(1,1))
ms = function(x) sortDataInGrid(x, grid=xy.gt)
mask.gt = constructMask(grid = xy.gt, method = "maxdist", maxval = 3, x=xyz.sgdf)
image(x,y,matrix(ms(xyz.sgdf@data$z), nrow=23, ncol=29))  
image(x,y,matrix(ms(mask.gt), nrow=23, ncol=29))  
image(mask.gt)
## work with the mask and plot again
par(mfrow=c(1,1))
xyz.sgdf.masked = setMask(x = xyz.sgdf, mask = mask.gt)
getMask(xyz.sgdf.masked)
image(x,y,matrix(ms(xyz.sgdf@data$z), nrow=23, ncol=29))  
points(xyz.sgdf.masked@coords)
par(oldpar)
</code></pre>

<hr>
<h2 id='DataFrameStack'>Create a data frame stack</h2><span id='topic+DataFrameStack'></span><span id='topic+as.DataFrameStack'></span><span id='topic+DataFrameStack.data.frame'></span><span id='topic+as.DataFrameStack.data.frame'></span><span id='topic+DataFrameStack.array'></span><span id='topic+as.DataFrameStack.array'></span><span id='topic+DataFrameStack.list'></span><span id='topic+as.DataFrameStack.list'></span>

<h3>Description</h3>

<p>Make a stacked data frame, that is, a stack of data.frames representing e.g. repeated measurements,
parallel time series, or a stack of multivariate realisation of some random process. If a data frame
is analogous to a matrix, a DataFrameStack is analogous to an array. It is highly recommendable to work
with named dimensions in stacked data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataFrameStack(x, ...)

as.DataFrameStack(x, ...)

## S3 method for class 'data.frame'
DataFrameStack(x, stackDim = 2, dim = NULL, Dimnames = NULL, ...)

## S3 method for class 'data.frame'
as.DataFrameStack(x, stackDim = 2, dim = NULL, Dimnames = NULL, ...)

## S3 method for class 'array'
DataFrameStack(x, stackDim = 2, ...)

## S3 method for class 'array'
as.DataFrameStack(x, stackDim = 2, ...)

## S3 method for class 'list'
DataFrameStack(x, stackDimName = NULL, Dimnames = NULL, ...)

## S3 method for class 'list'
as.DataFrameStack(x, stackDimName = NULL, Dimnames = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataFrameStack_+3A_x">x</code></td>
<td>
<p>object containing the individual data sets, this can be an arra, a list or a data.frame</p>
</td></tr>
<tr><td><code id="DataFrameStack_+3A_...">...</code></td>
<td>
<p>further parameters, ignored but necessary for generic functionality</p>
</td></tr>
<tr><td><code id="DataFrameStack_+3A_stackdim">stackDim</code></td>
<td>
<p>for &quot;array&quot; and &quot;data.frame&quot; input, which dimension
(name or index) identifies the stacking dimension;
this is typically the replication, realisation or time slice index</p>
</td></tr>
<tr><td><code id="DataFrameStack_+3A_dim">dim</code></td>
<td>
<p>for &quot;data.frame&quot; input,  how is the data provided to be arranged in slices?</p>
</td></tr>
<tr><td><code id="DataFrameStack_+3A_dimnames">Dimnames</code></td>
<td>
<p>for &quot;list&quot; and &quot;data.frame input, which names do you want to give
to the resulting array-like structure; note that for input &quot;array&quot; it is necessary
that these names are already given to the input array beforehand!</p>
</td></tr>
<tr><td><code id="DataFrameStack_+3A_stackdimname">stackDimName</code></td>
<td>
<p>for &quot;list&quot; input, which name or index do you want to
give to the stacking dimension?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data provided reorganised as a DataFrameStack, with several additional attributes.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>DataFrameStack</code>: create a DataFrameStack from an array
</p>
</li>
<li> <p><code>as.DataFrameStack</code>: create a DataFrameStack from an array
</p>
</li>
<li> <p><code>as.DataFrameStack.data.frame</code>: create a DataFrameStack from an array
</p>
</li>
<li> <p><code>DataFrameStack.array</code>: create a DataFrameStack from an array
</p>
</li>
<li> <p><code>as.DataFrameStack.array</code>: create a DataFrameStack from an array
</p>
</li>
<li> <p><code>DataFrameStack.list</code>: create a DataFrameStack from a list
</p>
</li>
<li> <p><code>as.DataFrameStack.list</code>: create a DataFrameStack from an array
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+stackDim">stackDim()</a></code> to get or set the stacking dimension;
<code><a href="#topic+noStackDim">noStackDim()</a></code> to get (not set) the non-stacking dimension;
<code><a href="#topic+as.array.DataFrameStack">as.array.DataFrameStack()</a></code> and <code><a href="#topic+as.list.DataFrameStack">as.list.DataFrameStack()</a></code> to
convert the stack to an array or a list;
<code><a href="#topic+dimnames.DataFrameStack">dimnames.DataFrameStack()</a></code> to get the dimension names;
[<code style="white-space: pre;">&#8288;[.DataFrameStack&#8288;</code>] to extract rows of a stack;
<code><a href="#topic+getStackElement">getStackElement()</a></code> and <code>setStackElement</code> (same page as <code>getStackElement</code>)
to extract/modify an
element of the stack; <code><a href="#topic+gmApply">gmApply()</a></code> to
apply any function to the stack, typically element-wise;
and <code><a href="#topic+swarmPlot">swarmPlot()</a></code> to combine plot elements for each stack element
into a single plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll = lapply(1:3, function(i) as.data.frame(matrix(1:10+(i-1)*10, ncol=2)))
dfs = DataFrameStack(ll, stackDimName="rep")
dimnames(dfs)
df = as.data.frame(matrix(1:30, ncol=6))
dfs = DataFrameStack(df, dimnames = list(obs=1:5, vars=c("A","B"), rep=1:3), stackDim = "rep")
dimnames(dfs)
ar = array(1:30, dim = c(5,2,3), dimnames=list(obs=1:5, vars=c("A","B"), rep=1:3))
dfs = DataFrameStack(ar, stackDim="rep")
dimnames(dfs)
</code></pre>

<hr>
<h2 id='dimnames.DataFrameStack'>Return the dimnames of a DataFrameStack</h2><span id='topic+dimnames.DataFrameStack'></span><span id='topic+dimnames+2CSpatial-method'></span>

<h3>Description</h3>

<p>Return the dimnames of a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>, i.e. the three dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DataFrameStack'
dimnames(x)

## S4 method for signature 'Spatial'
dimnames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimnames.DataFrameStack_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list (possibly named) with the element names of each of the three dimensions
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dimnames,Spatial-method</code>: dimnames method for all Spatial*DataFrame objects of
package <code>sp</code> which data slot contains a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>
</li></ul>

<hr>
<h2 id='DSpars'>Create a parameter set specifying a direct sampling algorithm</h2><span id='topic+DSpars'></span><span id='topic+DirectSamplingParameters'></span>

<h3>Description</h3>

<p>Create a parameter set describing a direct sampling algorithm to multipoint simulation.
All parameters except <code>nsim</code> are optional, as they have default values reasonable
according to experience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DSpars(
  nsim = 1,
  scanFraction = 0.25,
  patternSize = 10,
  gof = 0.05,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DSpars_+3A_nsim">nsim</code></td>
<td>
<p>number of realisations desired (attention: current algorithm is slow, start with small values!)</p>
</td></tr>
<tr><td><code id="DSpars_+3A_scanfraction">scanFraction</code></td>
<td>
<p>maximum fraction of the training image to be scanned on each iteration</p>
</td></tr>
<tr><td><code id="DSpars_+3A_patternsize">patternSize</code></td>
<td>
<p>number of observations used for conditioning the simulation</p>
</td></tr>
<tr><td><code id="DSpars_+3A_gof">gof</code></td>
<td>
<p>maximum acceptance discrepance between a data event in the training image and the conditioning data event</p>
</td></tr>
<tr><td><code id="DSpars_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be
initialized, see <code>?simulate</code> in base &quot;stats&quot; package</p>
</td></tr>
<tr><td><code id="DSpars_+3A_...">...</code></td>
<td>
<p>further parameters, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3-list of class &quot;gmDirectSamplingParameters&quot; containing the six elements given as arguments
to the function. This is just a compact way to provide further functions such as <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a>
with appropriate triggers for choosing a prediction method or another, in this case for triggering
direct sampling.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(dsp = DSpars(nsim=100, scanFraction=75, patternSize=6, gof=0.05))
## then run predict(..., pars=dsp)
</code></pre>

<hr>
<h2 id='EmpiricalStructuralFunctionSpecification-class'>Empirical structural function specification</h2><span id='topic+EmpiricalStructuralFunctionSpecification-class'></span>

<h3>Description</h3>

<p>Abstract class, containing any specification of an empirical variogram
(or covariance function, or variations). Members must implement a coercion method to
class &quot;gmEVario&quot; (see <code><a href="#topic+gsi.EVario2D">gsi.EVario2D()</a></code> for an example), and (possibly) coercion to
class &quot;gstatVariogram&quot; (see <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code>)
</p>

<hr>
<h2 id='fit_lmc'>Fit an LMC to an empirical variogram</h2><span id='topic+fit_lmc'></span><span id='topic+fit_lmc.default'></span><span id='topic+fit_lmc.logratioVariogramAnisotropy'></span><span id='topic+fit_lmc.gstatVariogram'></span><span id='topic+fit_lmc.logratioVariogram'></span>

<h3>Description</h3>

<p>Fit a linear model of coregionalisation to an empirical variogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lmc(v, ...)

## S3 method for class 'gstatVariogram'
fit_lmc(
  v,
  g,
  model,
  fit.ranges = FALSE,
  fit.lmc = !fit.ranges,
  correct.diagonal = 1,
  ...
)

## Default S3 method:
fit_lmc(v, g, model, ...)

## S3 method for class 'logratioVariogram'
fit_lmc(v, g, model, ...)

## S3 method for class 'logratioVariogramAnisotropy'
fit_lmc(v, g, model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_lmc_+3A_v">v</code></td>
<td>
<p>empirical variogram</p>
</td></tr>
<tr><td><code id="fit_lmc_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="fit_lmc_+3A_g">g</code></td>
<td>
<p>spatial data object, containing the original data</p>
</td></tr>
<tr><td><code id="fit_lmc_+3A_model">model</code></td>
<td>
<p>LMC or variogram model to fit</p>
</td></tr>
<tr><td><code id="fit_lmc_+3A_fit.ranges">fit.ranges</code></td>
<td>
<p>logical, should ranges be modified? (default=FALSE)</p>
</td></tr>
<tr><td><code id="fit_lmc_+3A_fit.lmc">fit.lmc</code></td>
<td>
<p>logical, should the nugget and partial sill matrices be modified (default=TRUE)</p>
</td></tr>
<tr><td><code id="fit_lmc_+3A_correct.diagonal">correct.diagonal</code></td>
<td>
<p>positive value slightly larger than 1, for multiplying the direct variogram
models and reduce the risk of numerically negative eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Method fit_lmc.gstatVariogram is a wrapper around <code><a href="gstat.html#topic+fit.lmc">gstat::fit.lmc()</a></code>, that calls this function
and gives the resulting model its appropriate class (c(&quot;variogramModelList&quot;, &quot;list&quot;)).
Method fit_lmc.default returns the fitted lmc (this function currently uses gstat as a
calculation machine, but this behavior can change in the future)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gstatVariogram</code>: wrapper around gstat::fit.lmc method
</p>
</li>
<li> <p><code>default</code>: flexible wrapper method for any class for which methods
for <code><a href="#topic+as.gstatVariogram">as.gstatVariogram()</a></code>, <code><a href="#topic+as.gstat">as.gstat()</a></code> and <code><a href="#topic+as.variogramModel">as.variogramModel()</a></code> exist.
In the future there may be direct specialised implementations not depending on
package gstat.
</p>
</li>
<li> <p><code>logratioVariogram</code>: method for logratioVariogram wrapping compositions::fit.lmc.
In the future there may be direct specialised implementations,
including anisotropy (not yet possible).
</p>
</li>
<li> <p><code>logratioVariogramAnisotropy</code>: method for logratioVariogram with anisotropry
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package = "gstat")
X = jura.pred[,1:2]
Zc = jura.pred[,7:13]
gg = make.gmCompositionalGaussianSpatialModel(Zc, X, V="alr", formula = ~1)
vg = variogram(gg)
md = gstat::vgm(model="Sph", psill=1, nugget=1, range=1.5)
gg = fit_lmc(v=vg, g=gg, model=md)
variogramModelPlot(vg, model=gg)
</code></pre>

<hr>
<h2 id='getMask'>Get the mask info out of a spatial data object</h2><span id='topic+getMask'></span><span id='topic+getMask.default'></span><span id='topic+getMask.SpatialPixelsDataFrame'></span><span id='topic+getMask.SpatialPixels'></span><span id='topic+getMask.SpatialPointsDataFrame'></span>

<h3>Description</h3>

<p>Retrieve the mask information from an object (if present). See <code><a href="#topic+constructMask">constructMask()</a></code>
for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMask(x)

## Default S3 method:
getMask(x)

## S3 method for class 'SpatialPixelsDataFrame'
getMask(x)

## S3 method for class 'SpatialPixels'
getMask(x)

## S3 method for class 'SpatialPointsDataFrame'
getMask(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMask_+3A_x">x</code></td>
<td>
<p>a masked object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The retrieved mask information from <code>x</code>, an object of class &quot;mask&quot;
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Get the mask info out of a spatial data object
</p>
</li>
<li> <p><code>SpatialPixelsDataFrame</code>: Get the mask info out of a SpatialPixelsDataFrame data object
</p>
</li>
<li> <p><code>SpatialPixels</code>: Get the mask info out of a SpatialPixels object
</p>
</li>
<li> <p><code>SpatialPointsDataFrame</code>: Get the mask info out of a SpatialPointsDataFrame data object
</p>
</li></ul>


<h3>See Also</h3>

<p>Other masking functions: 
<code><a href="#topic+constructMask">constructMask</a>()</code>,
<code><a href="#topic+print.mask">print.mask</a>()</code>,
<code><a href="#topic+setMask">setMask</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>
</p>

<hr>
<h2 id='getStackElement'>Set or get the i-th data frame of a data.frame stack</h2><span id='topic+getStackElement'></span><span id='topic+setStackElement'></span><span id='topic+getStackElement.default'></span><span id='topic+getStackElement.list'></span><span id='topic+getStackElement.DataFrameStack'></span><span id='topic+setStackElement.default'></span><span id='topic+setStackElement.data.frame'></span><span id='topic+setStackElement.list'></span><span id='topic+setStackElement.DataFrameStack'></span>

<h3>Description</h3>

<p>Set or get one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStackElement(x, i, ...)

## Default S3 method:
getStackElement(x, i, ...)

## S3 method for class 'list'
getStackElement(x, i, ...)

## S3 method for class 'DataFrameStack'
getStackElement(x, i, MARGIN = stackDim(x), ...)

## Default S3 method:
setStackElement(x, i, value, ...)

## S3 method for class 'data.frame'
setStackElement(x, i, value, ...)

## S3 method for class 'list'
setStackElement(x, i, value, ...)

## S3 method for class 'DataFrameStack'
setStackElement(x, i, value, MARGIN = stackDim(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStackElement_+3A_x">x</code></td>
<td>
<p>container data, typically a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>, but it can also be certain <code><a href="sp.html#topic+Spatial-class">sp::Spatial()</a></code>
object derivates of it</p>
</td></tr>
<tr><td><code id="getStackElement_+3A_i">i</code></td>
<td>
<p>index (or name) of the element of the stack to extract or replace</p>
</td></tr>
<tr><td><code id="getStackElement_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="getStackElement_+3A_margin">MARGIN</code></td>
<td>
<p>which dimension is the stacking dimension? you seldom want to touch this!!</p>
</td></tr>
<tr><td><code id="getStackElement_+3A_value">value</code></td>
<td>
<p>for the setting operation, the new data.frame to replace the selected one; note
that the compatibility of the dimensions of <code>value</code> is only checked for setStackElement.DataFrameStack
and its Spatial derivates; for other methods <code>setStackElement</code> can break the consistency of the
stack!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the getters, the result is the data.frame of the stack asked for. For the setters
the result is the original DataFrameStack with the corresponding element replaced. Spatial methods
return the corresponding spatial object, ie. the spatial information of the stack is transferred to the
extracted element.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Set or get one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>
</li>
<li> <p><code>list</code>: Set or get one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>
</li>
<li> <p><code>DataFrameStack</code>: Set or get one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>
</li>
<li> <p><code>default</code>: Set or get one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>
</li>
<li> <p><code>data.frame</code>: Set  one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> in data.frame form
</p>
</li>
<li> <p><code>list</code>: Set get one element of a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> in list form
</p>
</li>
<li> <p><code>DataFrameStack</code>: Set one element of the <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>ar = array(1:30, dim = c(5,2,3), dimnames=list(obs=1:5, vars=c("A","B"), rep=1:3))
dfs = DataFrameStack(ar, stackDim="rep")
dfs
stackDim(dfs)
getStackElement(dfs, 1)
</code></pre>

<hr>
<h2 id='getTellus'>Download the Tellus survey data set (NI)</h2><span id='topic+getTellus'></span>

<h3>Description</h3>

<p>Download the A-soil geochemistry data of the Tellus survey (Northern Ireland),
and if desired produce a training image of the geochemical subcomposition
Mg-Al-Ca-Fe-Rest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTellus(wd = ".", destfile = "TellusASoil.RData", TI = FALSE, cleanup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTellus_+3A_wd">wd</code></td>
<td>
<p>working directory, where intermediate files and output will be produced</p>
</td></tr>
<tr><td><code id="getTellus_+3A_destfile">destfile</code></td>
<td>
<p>file name where to put the Tellus data (including the extension &quot;.Rdata&quot;!)</p>
</td></tr>
<tr><td><code id="getTellus_+3A_ti">TI</code></td>
<td>
<p>either a logical (should the training image be created? defaults to FALSE) or
else the file name where to put the created training image (including the extension &quot;.Rdata&quot;)</p>
</td></tr>
<tr><td><code id="getTellus_+3A_cleanup">cleanup</code></td>
<td>
<p>should the downloaded excel file be removed? defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is provided due to conflicting licenses. You download the
data from the server <a href="https://www.bgs.ac.uk/gsni/tellus/index.html">https://www.bgs.ac.uk/gsni/tellus/index.html</a> at your own
accord. Actually a visit to the project data webpage is highly recommended, in particular
for learning about the QA/QC process of the data acquisition, other data sources
available and how to use this wealth of data.
</p>


<h3>Value</h3>

<p>TRUE if everything went OK. The function is actually called for the
side effect of downloading data from the Tellus survey project website, so be careful
to call it specifying the right directory at <code>wd</code>.
</p>


<h3>Geochemical soil A survey</h3>

<p>The function will download an excel file to your working directory, do some
manipulations, save the resulting data.frame in a &quot;TellusASoil.RData&quot; file (or any other
name you provide on the <code>destfile</code> argument) and
eventually, remove the excel file (if you left <code>cleanup=TRUE</code>). This data set has
6862 obervations and 58 variables:
</p>

<dl>
<dt>Sample</dt><dd><p>Sample ID</p>
</dd>
<dt>EASTING</dt><dd><p>X coordinate of each point</p>
</dd>
<dt>NORTHING</dt><dd><p>Y coordinate of each point</p>
</dd>
<dt>Flag</dt><dd><p>a flag marking some data as a study subset, fixed for reproducibility</p>
</dd>
<dt>Ag</dt><dd><p>Silver concentration in <code>ppm</code></p>
</dd>
<dt>Cd</dt><dd><p>Cadmium concentration in <code>ppm</code></p>
</dd>
<dt>In</dt><dd><p>Indium concentration in <code>ppm</code></p>
</dd>
<dt>Sn</dt><dd><p>Tin concentration in <code>ppm</code></p>
</dd>
<dt>Sb</dt><dd><p>Antimony concentration in <code>ppm</code></p>
</dd>
<dt>Te</dt><dd><p>Tellurium concentration in <code>ppm</code></p>
</dd>
<dt>I</dt><dd><p>Indim concentration in <code>ppm</code></p>
</dd>
<dt>Cs</dt><dd><p>Caesium concentration in <code>ppm</code></p>
</dd>
<dt>Ba</dt><dd><p>Barium concentration in <code>ppm</code></p>
</dd>
<dt>La</dt><dd><p>Lanthanum concentration in <code>ppm</code></p>
</dd>
<dt>Ce</dt><dd><p>Cerium concentration in <code>ppm</code></p>
</dd>
<dt>Na2O</dt><dd><p>Sodium oxide in <code>percent</code></p>
</dd>
<dt>MgO</dt><dd><p>Magnesium oxide in <code>percent</code></p>
</dd>
<dt>Al2O3</dt><dd><p>Aluminium oxide in <code>percent</code></p>
</dd>
<dt>SiO2</dt><dd><p>Silicium oxide in <code>percent</code></p>
</dd>
<dt>P2O5</dt><dd><p>Phosphorous(V) oxide in <code>percent</code></p>
</dd>
<dt>SO3</dt><dd><p>Sulphur(III) oxide in <code>percent</code></p>
</dd>
<dt>K2O</dt><dd><p>Potasium oxide in <code>percent</code></p>
</dd>
<dt>CaO</dt><dd><p>Calcium oxide in <code>percent</code></p>
</dd>
<dt>TiO2</dt><dd><p>Titanium oxide in <code>percent</code></p>
</dd>
<dt>MnO</dt><dd><p>Manganese oxide in <code>percent</code></p>
</dd>
<dt>Fe2O3</dt><dd><p>Total Iron(III) oxide in <code>percent</code></p>
</dd>
<dt>Cl</dt><dd><p>Chlorine concentration in <code>ppm</code></p>
</dd>
<dt>Sc</dt><dd><p>Scandium concentration in <code>ppm</code></p>
</dd>
<dt>V</dt><dd><p>Vanadium concentration in <code>ppm</code></p>
</dd>
<dt>Cr</dt><dd><p>Chromium concentration in <code>ppm</code></p>
</dd>
<dt>Co</dt><dd><p>Cobalt concentration in <code>ppm</code></p>
</dd>
<dt>Ni</dt><dd><p>Nickel concentration in <code>ppm</code></p>
</dd>
<dt>Cu</dt><dd><p>Copper concentration in <code>ppm</code></p>
</dd>
<dt>Zn</dt><dd><p>Zinc concentration in <code>ppm</code></p>
</dd>
<dt>Ga</dt><dd><p>Callium concentration in <code>ppm</code></p>
</dd>
<dt>Ge</dt><dd><p>Germanium concentration in <code>ppm</code></p>
</dd>
<dt>As</dt><dd><p>Arsenic concentration in <code>ppm</code></p>
</dd>
<dt>Se</dt><dd><p>Selenium concentration in <code>ppm</code></p>
</dd>
<dt>Br</dt><dd><p>Bromine concentration in <code>ppm</code></p>
</dd>
<dt>Rb</dt><dd><p>Rubidium concentration in <code>ppm</code></p>
</dd>
<dt>Sr</dt><dd><p>Strontium concentration in <code>ppm</code></p>
</dd>
<dt>Y</dt><dd><p>Yttrium concentration in <code>ppm</code></p>
</dd>
<dt>Zr</dt><dd><p>Zirconium concentration in <code>ppm</code></p>
</dd>
<dt>Nb</dt><dd><p>Niobium concentration in <code>ppm</code></p>
</dd>
<dt>Mo</dt><dd><p>Molybdenum concentration in <code>ppm</code></p>
</dd>
<dt>Nd</dt><dd><p>Neodymium concentration in <code>ppm</code></p>
</dd>
<dt>Sm</dt><dd><p>Samarium concentration in <code>ppm</code></p>
</dd>
<dt>Yb</dt><dd><p>Ytterbium concentration in <code>ppm</code></p>
</dd>
<dt>Hf</dt><dd><p>Hafnium concentration in <code>ppm</code></p>
</dd>
<dt>Ta</dt><dd><p>Tantalum concentration in <code>ppm</code></p>
</dd>
<dt>W</dt><dd><p>Tungsten concentration in <code>ppm</code></p>
</dd>
<dt>Tl</dt><dd><p>Thallium concentration in <code>ppm</code></p>
</dd>
<dt>Pb</dt><dd><p>Lead concentration in <code>ppm</code></p>
</dd>
<dt>Bi</dt><dd><p>Bismuth concentration in <code>ppm</code></p>
</dd>
<dt>Th</dt><dd><p>Thorium concentration in <code>ppm</code></p>
</dd>
<dt>U</dt><dd><p>Uranium concentration in <code>ppm</code></p>
</dd>
<dt>pH</dt><dd><p>soil acidity</p>
</dd>
<dt>LOI</dt><dd><p>loss on ignition in <code>percent</code></p>
</dd>
</dl>



<h3>Training image</h3>

<p>Additionally, if you give <code>TI!=FALSE</code>,
the function will produce an additional
file &quot;Tellus_TI.RData&quot; (if <code>TI=TRUE</code>, or any other filename that you
specify on the argument <code>TI</code>) with a data.frame with 13287 rows and 8 columns:
</p>

<dl>
<dt>EASTING</dt><dd><p>X coordinate of each cell point</p>
</dd>
<dt>NORTHING</dt><dd><p>Y coordinate of each cell point</p>
</dd>
<dt>MgO</dt><dd><p>Magnesia proportion</p>
</dd>
<dt>Al2O3</dt><dd><p>Alumina proportion</p>
</dd>
<dt>CaO</dt><dd><p>Calcium oxide proportion</p>
</dd>
<dt>Fe2O3</dt><dd><p>Iron oxide proportion</p>
</dd>
<dt>Rest</dt><dd><p>Residual complementing the sum to 1</p>
</dd>
<dt>Mask</dt><dd><p>Indicator of grid point outside the boundary of the country.
NOTE: to use it with <code><a href="#topic+setMask">setMask()</a></code> you will need to invert it using <code>!as.logical(TellusTI$Mask)</code></p>
</dd>
</dl>

<p>This is a migrated version of the data set to a regular grid, ideal for illustrating
and testing multiple point geostatistical algorithms.
</p>


<h3>References</h3>

<p><a href="https://www.bgs.ac.uk/gsni/tellus/index.html">https://www.bgs.ac.uk/gsni/tellus/index.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 getwd()
 getTellus(TI=TRUE, cleanup=TRUE)
 dir(pattern="Tellus")

## End(Not run)
</code></pre>

<hr>
<h2 id='gmApply'>Apply Functions Over Array or DataFrameStack Margins</h2><span id='topic+gmApply'></span><span id='topic+gmApply.default'></span><span id='topic+gmApply.DataFrameStack'></span>

<h3>Description</h3>

<p>Returns a vector or array or list of values obtained by
applying a function to the margins of an array or matrix.
Method <code>gmApply.default()</code> is just a wrapper on <code><a href="base.html#topic+apply">base::apply()</a></code>.
Method <code>gmApply()</code> reimplements the functionality
with future access to parallel computing and appropriate default
values for the MARGIN. ALWAYS use named arguments here!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmApply(X, ...)

## Default S3 method:
gmApply(X, MARGIN, FUN, ...)

## S3 method for class 'DataFrameStack'
gmApply(X, MARGIN = stackDim(X), FUN, ..., .parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmApply_+3A_x">X</code></td>
<td>
<p>a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> object (see <code><a href="base.html#topic+apply">base::apply()</a></code> for other options)</p>
</td></tr>
<tr><td><code id="gmApply_+3A_...">...</code></td>
<td>
<p>further arguments to <code>FUN</code></p>
</td></tr>
<tr><td><code id="gmApply_+3A_margin">MARGIN</code></td>
<td>
<p>a name or an index of the dimension along which should
the calculations be done; defaults to the stacking dimension of the
<code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>, i.e. to the output of <code>stackDim(X)</code></p>
</td></tr>
<tr><td><code id="gmApply_+3A_fun">FUN</code></td>
<td>
<p>function to apply; the default behaviour being that this function
is applied to each element of the stack <code>X</code></p>
</td></tr>
<tr><td><code id="gmApply_+3A_.parallel">.parallel</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In principle, if <code>MARGIN==stackDim(X)</code> (the default), the oputput is a list
with the result of using <code>FUN</code> on each element of the stack. If <code>FUN</code> returns a
matrix or a data.frame assimilable to one element of the stack, a transformation of
this output to a DataFrameStack is attempted.
</p>
<p>For <code>X</code> non-DataFrameStack or <code>MARGIN!=stackDim(X)</code> see <code><a href="base.html#topic+apply">base::apply()</a></code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: wrapper around <code><a href="base.html#topic+apply">base::apply()</a></code>
</p>
</li>
<li> <p><code>DataFrameStack</code>: Apply Functions Over DataFrameStack Margins
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>dm = list(point=1:100, var=LETTERS[1:2], rep=paste("r",1:5, sep=""))
ar = array(rnorm(1000), dim=c(100,2,5), dimnames = dm)
dfs = DataFrameStack(ar, stackDim="rep")
gmApply(dfs, FUN=colMeans)
rs = gmApply(dfs, FUN=function(x) x+1)
class(rs)
getStackElement(rs,1)
getStackElement(dfs,1)
</code></pre>

<hr>
<h2 id='gmGaussianMethodParameters-class'>parameters for Spatial Gaussian methods of any kind</h2><span id='topic+gmGaussianMethodParameters-class'></span>

<h3>Description</h3>

<p>abstract class, containing any parameter specification for a spatial algorithm
for interpolation, simulation or validation making use of Gaussian assumptions
</p>

<hr>
<h2 id='gmGaussianSimulationAlgorithm-class'>parameters for Gaussian Simulation methods</h2><span id='topic+gmGaussianSimulationAlgorithm-class'></span>

<h3>Description</h3>

<p>abstract class, containing any parameter specification of a spatial simulation algorithm
exploiting a Gaussian two-point model structure
</p>

<hr>
<h2 id='gmMPSParameters-class'>parameters for Multiple-Point Statistics methods</h2><span id='topic+gmMPSParameters-class'></span>

<h3>Description</h3>

<p>abstract class, containing any parameter specification of a spatial multipoint algorithm
</p>

<hr>
<h2 id='gmNeighbourhoodSpecification-class'>Neighbourhood description</h2><span id='topic+gmNeighbourhoodSpecification-class'></span>

<h3>Description</h3>

<p>abstract class, containing any specification of a spatial neighbourhood
</p>

<hr>
<h2 id='gmSimulationAlgorithm-class'>Parameter specification for a spatial simulation algorithm</h2><span id='topic+gmSimulationAlgorithm-class'></span>

<h3>Description</h3>

<p>abstract class, containing any parameter specification for a spatial simulation algorithm
</p>

<hr>
<h2 id='gmSpatialDataContainer-class'>General description of a spatial data container</h2><span id='topic+gmSpatialDataContainer-class'></span>

<h3>Description</h3>

<p>abstract class, containing any specification of a spatial data container
</p>


<h3>Details</h3>

<p>setClassUnion(name=&quot;gmTrainingImage&quot;,
members=c(&quot;SpatialGridDataFrame&quot;,
&quot;SpatialPixelsDataFrame&quot;)
)
</p>

<hr>
<h2 id='gmSpatialMethodParameters-class'>Parameter specification for any spatial method</h2><span id='topic+gmSpatialMethodParameters-class'></span>

<h3>Description</h3>

<p>abstract class, containing any parameter specification for
any spatial method. Members of this class are <a href="#topic+gmNeighbourhoodSpecification-class">gmNeighbourhoodSpecification</a>
<a href="#topic+gmMPSParameters-class">gmMPSParameters</a> and <a href="#topic+gmValidationStrategy-class">gmValidationStrategy</a>.
</p>

<hr>
<h2 id='gmSpatialModel-class'>Conditional spatial model data container</h2><span id='topic+gmSpatialModel-class'></span><span id='topic+variogram+2CgmSpatialModel-method'></span><span id='topic+logratioVariogram+2CgmSpatialModel-method'></span><span id='topic+as.gstat+2CgmSpatialModel-method'></span>

<h3>Description</h3>

<p>This class is devised to contain a conditional spatial model, with: some conditioning data
(a <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code>), an unconditional geospatial model (a structure with e.g.
a training image; or the information defining a Gaussian random field); and eventually some
extra method parameters. The class extends <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code> and has therefore its slots,
plus <code>model</code> (for the unconditional model) and <code>parameters</code> (for the extra method information)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'gmSpatialModel'
variogram(object, methodPars = NULL, ...)

## S4 method for signature 'gmSpatialModel'
logratioVariogram(data, ..., azimuth = 0, azimuth.tol = 180/length(azimuth))

## S4 method for signature 'gmSpatialModel'
as.gstat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmSpatialModel-class_+3A_object">object</code></td>
<td>
<p>a gmSpatialModel object containing spatial data.</p>
</td></tr>
<tr><td><code id="gmSpatialModel-class_+3A_methodpars">methodPars</code></td>
<td>
<p>(currently ignored)</p>
</td></tr>
<tr><td><code id="gmSpatialModel-class_+3A_...">...</code></td>
<td>
<p>further parameters to <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code></p>
</td></tr>
<tr><td><code id="gmSpatialModel-class_+3A_data">data</code></td>
<td>
<p>the data container (see <a href="#topic+gmSpatialModel-class">gmSpatialModel</a> for details)</p>
</td></tr>
<tr><td><code id="gmSpatialModel-class_+3A_azimuth">azimuth</code></td>
<td>
<p>which direction, or directions, are desired (in case of directional variogram)</p>
</td></tr>
<tr><td><code id="gmSpatialModel-class_+3A_azimuth.tol">azimuth.tol</code></td>
<td>
<p>which tolerance sould be used for directional variograms?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>You will seldom create the spatial model directly. Use instead the creators <code style="white-space: pre;">&#8288;make.gm*&#8288;</code> linked below
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>variogram</code>: Compute a variogram, see <code><a href="#topic+variogram_gmSpatialModel">variogram_gmSpatialModel()</a></code> for details
</p>
</li>
<li> <p><code>logratioVariogram</code>: S4 wrapper method around <code><a href="#topic+logratioVariogram">logratioVariogram()</a></code> for <code>gmSpatialModel</code>
objects
</p>
</li>
<li> <p><code>as.gstat</code>: convert from gmSpatialModel to gstat; see <code><a href="#topic+as.gstat">as.gstat()</a></code>
for details
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>a data.frame (or class extending it) containing the conditional data</p>
</dd>
<dt><code>coords</code></dt><dd><p>a matrix or dataframe of 2-3 columns containing the sampling locations of the conditional data</p>
</dd>
<dt><code>coords.nrs</code></dt><dd><p>see <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code></p>
</dd>
<dt><code>bbox</code></dt><dd><p>see <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code></p>
</dd>
<dt><code>proj4string</code></dt><dd><p>see <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code></p>
</dd>
<dt><code>model</code></dt><dd><p>gmUnconditionalSpatialModel. Some unconditional geospatial model. It can be NULL.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>gmSpatialMethodParameters. Some method parameters. It can be NULL</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Other gmSpatialModel: 
<code><a href="#topic+Predict">Predict</a>()</code>,
<code><a href="#topic+as.gmSpatialModel">as.gmSpatialModel</a>()</code>,
<code><a href="#topic+make.gmCompositionalGaussianSpatialModel">make.gmCompositionalGaussianSpatialModel</a>()</code>,
<code><a href="#topic+make.gmCompositionalMPSSpatialModel">make.gmCompositionalMPSSpatialModel</a>()</code>,
<code><a href="#topic+make.gmMultivariateGaussianSpatialModel">make.gmMultivariateGaussianSpatialModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
library(sp)
X = jura.pred[,1:2]
Zc = jura.pred[,7:13]
spdf = sp::SpatialPointsDataFrame(coords=X, data=Zc)
new("gmSpatialModel", spdf)
make.gmCompositionalGaussianSpatialModel(data=Zc, coords=X, V="alr")
</code></pre>

<hr>
<h2 id='gmTrainingImage-class'>MPS training image class</h2><span id='topic+gmTrainingImage-class'></span>

<h3>Description</h3>

<p>abstract class, containing any specification of a multiple-point
training image. This must be analogous to <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame()</a></code>, and
implement a method for <code><a href="sp.html#topic+SpatialGrid">sp::getGridTopology()</a></code> and to coerce it to
<a href="sp.html#topic+SpatialGridDataFrame-class">sp::SpatialGridDataFrame</a>.
</p>

<hr>
<h2 id='gmUnconditionalSpatialModel-class'>General description of a spatial model</h2><span id='topic+gmUnconditionalSpatialModel-class'></span>

<h3>Description</h3>

<p>abstract class, containing any specification of an unconditional
spatial model
</p>

<hr>
<h2 id='gmValidationStrategy-class'>Validation strategy description</h2><span id='topic+gmValidationStrategy-class'></span>

<h3>Description</h3>

<p>abstract class, containing any specification of a validation strategy for spatial models
</p>

<hr>
<h2 id='GridOrNothing-class'>Superclass for grid or nothing</h2><span id='topic+GridOrNothing-class'></span>

<h3>Description</h3>

<p>Superclass for slots containing a grid topology or being empty
</p>

<hr>
<h2 id='gsi.calcCgram'>Compute covariance matrix oout of locations</h2><span id='topic+gsi.calcCgram'></span>

<h3>Description</h3>

<p>internal function to compute the variogram model for all combinations of two
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.calcCgram(X, Y, vgram, ijEqual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.calcCgram_+3A_x">X</code></td>
<td>
<p>matrix, coordinates of the first set of locations</p>
</td></tr>
<tr><td><code id="gsi.calcCgram_+3A_y">Y</code></td>
<td>
<p>matrix, coordinates of the first set of locations (often Y=X, and ijEqual=TR)</p>
</td></tr>
<tr><td><code id="gsi.calcCgram_+3A_vgram">vgram</code></td>
<td>
<p>covariogram model, of format &quot;gmCgram&quot;</p>
</td></tr>
<tr><td><code id="gsi.calcCgram_+3A_ijequal">ijEqual</code></td>
<td>
<p>logical, are X==Y? if you put TRUE, the function will only compute half of
the points, so be sure that this is right!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of elements of the covariance, in NxM blocks of DxD elements
(being N and M resp. the nr. of rows of X and Y, and D the nr of variables)
</p>

<hr>
<h2 id='gsi.Cokriging'>Cokriging of all sorts, internal function</h2><span id='topic+gsi.Cokriging'></span>

<h3>Description</h3>

<p>internal function to compute cokriging (simple, ordinary, universal, with trend)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.Cokriging(
  Xout,
  Xin,
  Zin,
  vgram,
  Fin = rep(1, nrow(Xin)),
  Fout = rep(1, nrow(Xout)),
  krigVar = FALSE,
  tol = 1e-15
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.Cokriging_+3A_xout">Xout</code></td>
<td>
<p>(M,g)-matrix with coordinates of desired interpolation locations</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_xin">Xin</code></td>
<td>
<p>(N,g)-matrix with coordinates of conditioning locations</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_zin">Zin</code></td>
<td>
<p>(N,D)-matrix with condtioning observations</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_vgram">vgram</code></td>
<td>
<p>D-dimensional variogram model of class &quot;gmCgram&quot;</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_fin">Fin</code></td>
<td>
<p>either NULL or a (N,p)-matrix with the base functions of the trend evaluated at
the conditioning locations (defaults to a vector of $N$ 1's)</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_fout">Fout</code></td>
<td>
<p>either NULL or a (m,p)-matrix with the base functions of the trend evaluated at
the conditioning locations (defaults to a vector of $M$ 1's)</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_krigvar">krigVar</code></td>
<td>
<p>logical or NA, should kriging variances be returned? FALSE=no,
TRUE=give point-wise cokriging covariance; NA=return the whole covariance matrix of all points</p>
</td></tr>
<tr><td><code id="gsi.Cokriging_+3A_tol">tol</code></td>
<td>
<p>tolerance for the inversion of the cokriging matrix (in case of near-singularity)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (M,D)-matrix of predictions, eventually with an attribute &quot;krigVar&quot;
containing the output defined by argument <code>krigVar</code>
</p>

<hr>
<h2 id='gsi.CondTurningBands'>Internal function, conditional turning bands realisations</h2><span id='topic+gsi.CondTurningBands'></span>

<h3>Description</h3>

<p>Internal function to compute conditional turning bands simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.CondTurningBands(
  Xout,
  Xin,
  Zin,
  vgram,
  nbands = 400,
  tol = 1e-15,
  nsim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.CondTurningBands_+3A_xout">Xout</code></td>
<td>
<p>matrix of coordinates of locations where realisations are desired</p>
</td></tr>
<tr><td><code id="gsi.CondTurningBands_+3A_xin">Xin</code></td>
<td>
<p>matrix of coordinates of locations of conditioning points</p>
</td></tr>
<tr><td><code id="gsi.CondTurningBands_+3A_zin">Zin</code></td>
<td>
<p>matrix of variables at the conditioning locations</p>
</td></tr>
<tr><td><code id="gsi.CondTurningBands_+3A_vgram">vgram</code></td>
<td>
<p>covariogram model, of format &quot;gmCgram&quot;</p>
</td></tr>
<tr><td><code id="gsi.CondTurningBands_+3A_nbands">nbands</code></td>
<td>
<p>number of bands to use</p>
</td></tr>
<tr><td><code id="gsi.CondTurningBands_+3A_tol">tol</code></td>
<td>
<p>tolerance for the inversion of the cokriging matrix (in case of near-singularity)</p>
</td></tr>
<tr><td><code id="gsi.CondTurningBands_+3A_nsim">nsim</code></td>
<td>
<p>number of realisations to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with (npoint, nvar, nsim)-elements, being npoint=nrow(X)
and nvar = nr of variables in vgram
</p>

<hr>
<h2 id='gsi.DS'>Workhorse function for direct sampling</h2><span id='topic+gsi.DS'></span>

<h3>Description</h3>

<p>This function implements in R the direct sampling algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.DS(
  n,
  f,
  t,
  n_realiz,
  dim_TI,
  dim_SimGrid,
  TI_input,
  SimGrid_input,
  ivars_TI = 3:ncol(TI_input),
  SimGrid_mask = ncol(SimGrid_input),
  invertMask = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.DS_+3A_n">n</code></td>
<td>
<p>size of the conditioning data event (integer)</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_f">f</code></td>
<td>
<p>fraction of the training image to scan (numeric between 0 and 1)</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_t">t</code></td>
<td>
<p>maximal acceptable discrepance between conditioning data event and TI event (numeric between 0 and 1)</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_n_realiz">n_realiz</code></td>
<td>
<p>number of simulations desired</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_dim_ti">dim_TI</code></td>
<td>
<p>dimensions of the grid of the training image (ie. either <code class="reqn">(n_x, n_y)</code>
for dimension <code class="reqn">k=2</code> or <code class="reqn">(n_x, n_y, n_z)</code> for dimension <code class="reqn">k=3</code>)</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_dim_simgrid">dim_SimGrid</code></td>
<td>
<p>dimensions of the simulation grid (ie. either <code class="reqn">(m_x, m_y)</code> or
<code class="reqn">(m_x, m_y, m_z)</code>)</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_ti_input">TI_input</code></td>
<td>
<p>training image, as a matrix of <code class="reqn">(n_x\cdot n_y\cdot n_z, k+D)</code>
elements; WITH NAMED COLUMNS and including spatial coordinates</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_simgrid_input">SimGrid_input</code></td>
<td>
<p>simulation grid with conditioning data, as a matrix of
<code class="reqn">(m_x\cdot m_y\cdot m_z, k+D)</code> elements; with same columns as <code>TI_input</code></p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_ivars_ti">ivars_TI</code></td>
<td>
<p>which colnames of <code>TI_input</code> and <code>SimGrid_input</code> identify variables to consider in the data event</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_simgrid_mask">SimGrid_mask</code></td>
<td>
<p>either a logical vector of length <code class="reqn">m_x\cdot m_y\cdot m_z</code>, or else a column name of <code>SimGrid_input</code>
giving a logical column</p>
</td></tr>
<tr><td><code id="gsi.DS_+3A_invertmask">invertMask</code></td>
<td>
<p>logical, does <code>SimGrid_mask</code> identify with TRUE the data OUTSIDE the simulation area?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialPixelsDataFrame()</a></code> or  <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame()</a></code>, depending on whether the whole
grid is simulated. The '@data' slot of these objects contains a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> with the stacking dimension
running through the realisations. It is safer to use this functionality through the interface
<code><a href="#topic+make.gmCompositionalMPSSpatialModel">make.gmCompositionalMPSSpatialModel()</a></code>, then request a direct simulation with <code><a href="#topic+DSpars">DSpars()</a></code> and
finally run it with <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a>.
</p>


<h3>Author(s)</h3>

<p>Hassan Talebi (copyright holder), Raimon Tolosana-Delgado
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## training image:
x = 1:10
y = 1:7
xy_TI = expand.grid(x=x, y=y)
TI_input = cbind(xy_TI, t(apply(xy_TI, 1, function(x) c(sum(x), abs(x[2]-x[1]))+rnorm(2, sd=0.01))))
colnames(TI_input) = c("x", "y", "V1", "V2")
o1 = image_cokriged(TI_input, ivar="V1")
o2 = image_cokriged(TI_input, ivar="V2")
## simulation grid:
SimGrid = TI_input
SimGrid$mask = with(SimGrid, x==1 | x==10 | y==1 | y==7)
tk = SimGrid$mask
tk[sample(70, 50)] = TRUE 
SimGrid[tk,3:4]=NA
image_cokriged(SimGrid, ivar="V1", breaks=o1$breaks, col=o1$col)
image_cokriged(SimGrid, ivar="V2", breaks=o2$breaks, col=o2$col)
image_cokriged(SimGrid, ivar="mask", breaks=c(-0.0001, 0.5, 1.001))
## Not run: 
res = gsi.DS(n=5, f=0.75, t=0.05, n_realiz=2, dim_TI=c(10,7),  dim_SimGrid=c(10,7), 
       TI_input=as.matrix(TI_input), SimGrid_input=as.matrix(SimGrid), 
       ivars_TI = c("V1", "V2"), SimGrid_mask="mask", invertMask=TRUE)
image_cokriged(cbind(xy_TI, getStackElement(res,1)), ivar="V1", breaks=o1$breaks, col=o1$col)
image_cokriged(cbind(xy_TI, getStackElement(res,2)), ivar="V1", breaks=o1$breaks, col=o1$col)
image_cokriged(cbind(xy_TI, getStackElement(res,1)), ivar="V2", breaks=o2$breaks, col=o2$col)
image_cokriged(cbind(xy_TI, getStackElement(res,2)), ivar="V2", breaks=o2$breaks, col=o2$col)

## End(Not run)
</code></pre>

<hr>
<h2 id='gsi.EVario2D'>Empirical variogram or covariance function in 2D</h2><span id='topic+gsi.EVario2D'></span>

<h3>Description</h3>

<p>compute the empirical variogram or covariance function in a 2D case study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.EVario2D(
  X,
  Z,
  Ff = rep(1, nrow(X)),
  maxdist = max(dist(X[sample(nrow(X), min(nrow(X), 1000)), ]))/2,
  lagNr = 15,
  lags = seq(from = 0, to = maxdist, length.out = lagNr + 1),
  azimuthNr = 4,
  azimuths = seq(from = 0, to = 180, length.out = azimuthNr + 1)[1:azimuthNr],
  maxbreadth = Inf,
  minpairs = 10,
  cov = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.EVario2D_+3A_x">X</code></td>
<td>
<p>matrix of Nx2 columns with the geographic coordinates</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_z">Z</code></td>
<td>
<p>matrix or data.frame of data with dimension (N,Dv)</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_ff">Ff</code></td>
<td>
<p>for variogram, matrix of basis functions with nrow(Ff)=N (can be a N-vector of 1s);
for covariance function, a (N,Dv)-matrix or a  Dv-vector giving the mean values</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_maxdist">maxdist</code></td>
<td>
<p>maximum lag distance to consider</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_lagnr">lagNr</code></td>
<td>
<p>number of lags to consider</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_lags">lags</code></td>
<td>
<p>if maxdist and lagNr are not specified, either: (a) a matrix of 2 columns giving
minimal and maximal lag distance defining the lag classes to consider, or (b) a vector of lag breaks</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_azimuthnr">azimuthNr</code></td>
<td>
<p>number of azimuths to consider</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_azimuths">azimuths</code></td>
<td>
<p>if azimuthNr is not specified, either: (a) a matrix of 2 columns giving
minimal and maximal azimuth defining the azimuth classes to consider, or (b) a vector of azimuth breaks</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_maxbreadth">maxbreadth</code></td>
<td>
<p>maximal breadth (in lag units) orthogonal to the lag direction</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_minpairs">minpairs</code></td>
<td>
<p>minimal number of pairs falling in each class to consider the calculation sufficient; defaults to 10</p>
</td></tr>
<tr><td><code id="gsi.EVario2D_+3A_cov">cov</code></td>
<td>
<p>boolean, is covariance (TRUE) or variogram (FALSE) desired? defaults to variogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empirical variogram for the provided data. NOTE: avoid using directly gsi.* functions! They
represent either internal functions, or preliminary, not fully-tested functions. Use <code><a href="spatial.html#topic+variogram">variogram</a></code> instead.
</p>


<h3>See Also</h3>

<p>Other gmEVario functions: 
<code><a href="#topic+as.gmEVario.gstatVariogram">as.gmEVario.gstatVariogram</a>()</code>,
<code><a href="#topic+gsi.EVario3D">gsi.EVario3D</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmEVario">plot.gmEVario</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gstat)
data("jura", package = "gstat")
X = as.matrix(jura.pred[,1:2])
Z = as.matrix(jura.pred[,c("Zn","Cd","Pb")])
vge = gsi.EVario2D(X,Z)
dim(vge)
dimnames(vge)
class(vge["gamma",1])
dim(vge["gamma",1][[1]])
vge["npairs",1]
vge["lags",1]
</code></pre>

<hr>
<h2 id='gsi.EVario3D'>Empirical variogram or covariance function in 3D</h2><span id='topic+gsi.EVario3D'></span>

<h3>Description</h3>

<p>compute the empirical variogram or covariance function in a 3D case study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.EVario3D(
  X,
  Z,
  Ff = rep(1, nrow(X)),
  maxdist = max(dist(X[sample(nrow(X), min(nrow(X), 1000)), ]))/2,
  lagNr = 15,
  lags = seq(from = 0, to = maxdist, length.out = lagNr + 1),
  dirvecs = t(c(1, 0, 0)),
  angtol = 90,
  maxbreadth = Inf,
  minpairs = 10,
  cov = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.EVario3D_+3A_x">X</code></td>
<td>
<p>matrix of Nx3 columns with the geographic coordinates</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_z">Z</code></td>
<td>
<p>matrix or data.frame of data with dimension (N,Dv)</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_ff">Ff</code></td>
<td>
<p>for variogram, matrix of basis functions with nrow(Ff)=N
(can be a N-vector of 1s; should include the vector of 1s!!);
for covariance function, a (N,Dv)-matrix or a Dv-vector giving the mean values</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_maxdist">maxdist</code></td>
<td>
<p>maximum lag distance to consider</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_lagnr">lagNr</code></td>
<td>
<p>number of lags to consider</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_lags">lags</code></td>
<td>
<p>if maxdist and lagNr are not specified, either: (a) a matrix of 2 columns giving
minimal and maximal lag distance defining the lag classes to consider, or (b) a vector of lag breaks</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_dirvecs">dirvecs</code></td>
<td>
<p>matrix which rows are the director vectors along which variograms will be computed (these will be normalized!)</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_angtol">angtol</code></td>
<td>
<p>scalar, angular tolerance applied (in degrees; defaults to 90??, ie. isotropic)</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_maxbreadth">maxbreadth</code></td>
<td>
<p>maximal breadth (in lag units) orthogonal to the lag direction (defaults to <code>Inf</code>, ie. not used)</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_minpairs">minpairs</code></td>
<td>
<p>minimal number of pairs falling in each class to consider the calculation sufficient; defaults to 10</p>
</td></tr>
<tr><td><code id="gsi.EVario3D_+3A_cov">cov</code></td>
<td>
<p>boolean, is covariance (TRUE) or variogram (FALSE) desired? defaults to variogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empirical variogram for the provided data. NOTE: avoid using directly gsi.* functions! They
represent either internal functions, or preliminary, not fully-tested functions. Use <code><a href="spatial.html#topic+variogram">variogram</a></code> instead.
</p>


<h3>See Also</h3>

<p>Other gmEVario functions: 
<code><a href="#topic+as.gmEVario.gstatVariogram">as.gmEVario.gstatVariogram</a>()</code>,
<code><a href="#topic+gsi.EVario2D">gsi.EVario2D</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmEVario">plot.gmEVario</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>

<hr>
<h2 id='gsi.gstatCokriging2compo'>Reorganisation of cokriged compositions</h2><span id='topic+gsi.gstatCokriging2compo'></span><span id='topic+gsi.gstatCokriging2rmult'></span><span id='topic+gsi.gstatCokriging2compo.default'></span><span id='topic+gsi.gstatCokriging2compo.data.frame'></span><span id='topic+gsi.gstatCokriging2rmult.default'></span><span id='topic+gsi.gstatCokriging2rmult.data.frame'></span>

<h3>Description</h3>

<p>Produce compositional predictions out of a <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code> prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.gstatCokriging2compo(COKresult, ...)

## Default S3 method:
gsi.gstatCokriging2compo(COKresult, ...)

## S3 method for class 'data.frame'
gsi.gstatCokriging2compo(
  COKresult,
  V = NULL,
  orignames = NULL,
  tol = 1e-12,
  nscore = FALSE,
  gg = NULL,
  ...
)

## Default S3 method:
gsi.gstatCokriging2rmult(COKresult, ...)

## S3 method for class 'data.frame'
gsi.gstatCokriging2rmult(COKresult, nscore = FALSE, gg = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_cokresult">COKresult</code></td>
<td>
<p>output of a <code><a href="gstat.html#topic+predict.gstat">gstat::predict.gstat()</a></code> cokriging,
typically of class &quot;data.frame&quot;, <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code>,
<code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame()</a></code> or <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialPixelsDataFrame()</a></code></p>
</td></tr>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_...">...</code></td>
<td>
<p>further arguments needed for nscore (<strong>deprecated</strong>)</p>
</td></tr>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_v">V</code></td>
<td>
<p>string or matrix describing which logratio was applied (&quot;ilr&quot;, &quot;alr&quot;,
or a matrix computing the ilr corrdinates; clr is not allowed!)</p>
</td></tr>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_orignames">orignames</code></td>
<td>
<p>names of the original components (optional, but recommended)</p>
</td></tr>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_tol">tol</code></td>
<td>
<p>for generalized inversion of the matrix (<strong>rarely touched!</strong>)</p>
</td></tr>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_nscore">nscore</code></td>
<td>
<p>boolean, were the data normal score-transformed? (<strong>deprecated</strong>)</p>
</td></tr>
<tr><td><code id="gsi.gstatCokriging2compo_+3A_gg">gg</code></td>
<td>
<p>in the case that normal score transformation was applied, provide the gstat object! (<strong>deprecated</strong>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an (N,D)-object of class <code>c("spatialGridAcomp","acomp")</code>
with the predictions, together with an extra attribute &quot;krigVar&quot;
containing the cokriging covariance matrices  in an (N, D, D)-array; here N=number of
interpolated locations, D=number of original components of the composition
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Reorganisation of cokriged compositions
</p>
</li>
<li> <p><code>data.frame</code>: Reorganisation of cokriged compositions
</p>
</li>
<li> <p><code>default</code>: Reorganisation of cokriged multivariate data
</p>
</li>
<li> <p><code>data.frame</code>: Reorganisation of cokriged multivariate data
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+image_cokriged.spatialGridRmult">image_cokriged.spatialGridRmult()</a></code> for an example
</p>

<hr>
<h2 id='gsi.orig'>extract information about the original data, if available</h2><span id='topic+gsi.orig'></span><span id='topic+gsi.getV'></span>

<h3>Description</h3>

<p>originally implemented in package:compositions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.orig(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.orig_+3A_x">x</code></td>
<td>
<p>an rmult object</p>
</td></tr>
<tr><td><code id="gsi.orig_+3A_y">y</code></td>
<td>
<p>possibly another rmult object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original untransformed data (with a compositional class), resp
the TRANSPOSED INVERSE matrix, i.e. the one to recover the original components.
</p>

<hr>
<h2 id='gsi.produceV'>Create a matrix of logcontrasts and name prefix</h2><span id='topic+gsi.produceV'></span>

<h3>Description</h3>

<p>Given a representation specification for compositions, this function
creates the matrix of logcontrasts and provides a suitable prefix name for naming variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.produceV(
  V = NULL,
  D = nrow(V),
  orignames = rownames(V),
  giveInv = FALSE,
  prefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.produceV_+3A_v">V</code></td>
<td>
<p>either a matrix of logcontrasts or, most commonly, one of &quot;clr&quot;, &quot;ilr&quot; or &quot;alr&quot;</p>
</td></tr>
<tr><td><code id="gsi.produceV_+3A_d">D</code></td>
<td>
<p>the number of components of the composition represented</p>
</td></tr>
<tr><td><code id="gsi.produceV_+3A_orignames">orignames</code></td>
<td>
<p>the names of the components</p>
</td></tr>
<tr><td><code id="gsi.produceV_+3A_giveinv">giveInv</code></td>
<td>
<p>logical, is the inverse logcontrast matrix desired?</p>
</td></tr>
<tr><td><code id="gsi.produceV_+3A_prefix">prefix</code></td>
<td>
<p>the desired prefix name, if this is wished to be forced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with at least two elements
</p>

<ol>
<li> <p><code>V</code> containing the final matrix of logcontrasts
</p>
</li>
<li> <p><code>prefix</code>  containing the final prefix for names of transformed variables
</p>
</li>
<li> <p><code>W</code> eventually, the (transposed, generalised) inverse of <code>V</code>, if <code>giveInv=TRUE</code>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>gsi.produceV("alr", D=3)
gsi.produceV("ilr", D=3, orignames = c("Ca", "K", "Na"))
gsi.produceV("alr", D=3, orignames = c("Ca", "K", "Na"), giveInv = TRUE)
</code></pre>

<hr>
<h2 id='gsi.TurningBands'>Internal function, unconditional turning bands realisations</h2><span id='topic+gsi.TurningBands'></span>

<h3>Description</h3>

<p>Internal function to compute unconditional turning bands simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsi.TurningBands(X, vgram, nBands, nsim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsi.TurningBands_+3A_x">X</code></td>
<td>
<p>matrix of coordinates of locations where realisations are desired</p>
</td></tr>
<tr><td><code id="gsi.TurningBands_+3A_vgram">vgram</code></td>
<td>
<p>covariogram model, of format &quot;gmCgram&quot;</p>
</td></tr>
<tr><td><code id="gsi.TurningBands_+3A_nbands">nBands</code></td>
<td>
<p>number of bands to use</p>
</td></tr>
<tr><td><code id="gsi.TurningBands_+3A_nsim">nsim</code></td>
<td>
<p>number of realisations to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with (npoint, nvar, nsim)-elements, being npoint=nrow(X)
and nvar = nr of variables in vgram
</p>

<hr>
<h2 id='has.missings.data.frame'>Check presence of missings
check presence of missings in a data.frame</h2><span id='topic+has.missings.data.frame'></span>

<h3>Description</h3>

<p>Check presence of missings
check presence of missings in a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
has.missings(x, mc = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.missings.data.frame_+3A_x">x</code></td>
<td>
<p>data, of class data.frame</p>
</td></tr>
<tr><td><code id="has.missings.data.frame_+3A_mc">mc</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="has.missings.data.frame_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single true/false response about the presence of any missing value
on the whole data set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(compositions)
data(Windarling)
has.missings(Windarling)
head(Windarling)
Windarling[1,1] = NA
head(Windarling)
has.missings(Windarling)
</code></pre>

<hr>
<h2 id='image_cokriged'>Plot an image of gridded data</h2><span id='topic+image_cokriged'></span><span id='topic+image_cokriged.default'></span><span id='topic+image_cokriged.spatialGridRmult'></span><span id='topic+image_cokriged.spatialGridAcomp'></span>

<h3>Description</h3>

<p>Plot an image of one variable (possibly, one realisation) of output
of cokriging or cosimulation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_cokriged(x, ...)

## Default S3 method:
image_cokriged(
  x,
  ivar = 3,
  breaks = quantile(as.data.frame(x)[, ivar], probs = c(0:10)/10, na.rm = TRUE),
  col = spectralcolors(length(breaks) - 1),
  legendPropSpace = 0.2,
  legendPos = "top",
  main = ifelse(is.character(ivar), ivar, colnames(x)[ivar]),
  ...
)

## S3 method for class 'spatialGridRmult'
image_cokriged(
  x,
  ivar = 1,
  isim = NULL,
  breaks = 10,
  mask = attr(x, "mask"),
  col = spectralcolors(length(breaks) - 1),
  legendPropSpace = 0.2,
  legendPos = "top",
  main = ifelse(is.character(ivar), ivar, dimnames(x)[[length(dimnames(x))]][ivar]),
  ...
)

## S3 method for class 'spatialGridAcomp'
image_cokriged(
  x,
  ivar = 1,
  isim = NULL,
  breaks = 10,
  mask = attr(x, "mask"),
  col = spectralcolors(length(breaks) - 1),
  legendPropSpace = 0.2,
  legendPos = "top",
  main = ifelse(is.character(ivar), ivar, dimnames(x)[[length(dimnames(x))]][ivar]),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_cokriged_+3A_x">x</code></td>
<td>
<p>object with the interpolated / simulated data; currently there are methods
for &quot;spatialGridAcomp&quot; and &quot;spatialGridRmult&quot;, but the default method is able to
deal with &quot;SpatialPointsDataFrame&quot;, &quot;SpatialPixelsDataFrame&quot; and &quot;SpatialGridDataFrame&quot;
objects, and with the &quot;data.frame&quot; output of <code><a href="gstat.html#topic+predict.gstat">gstat::predict.gstat()</a></code> and
<a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a></p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_...">...</code></td>
<td>
<p>generic functionality, currently ignored</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_ivar">ivar</code></td>
<td>
<p>which variable do you want to plot?</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_breaks">breaks</code></td>
<td>
<p>either the approximate number of breaks, or the vector of
exact breaks to use for the plotting regions of the chosen variable</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_col">col</code></td>
<td>
<p>vector of colors to use for the image</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_legendpropspace">legendPropSpace</code></td>
<td>
<p>which proportion of surface of the device should be used
for the legend? trial and error might be necessary to adjust this to your needs</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_legendpos">legendPos</code></td>
<td>
<p>where do you want your legend? one of c(&quot;top&quot;,&quot;left&quot;,&quot;right&quot;,&quot;bottom&quot;)</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_main">main</code></td>
<td>
<p>main title for the plot</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_isim">isim</code></td>
<td>
<p>in case of simulated output, which simulation?</p>
</td></tr>
<tr><td><code id="image_cokriged_+3A_mask">mask</code></td>
<td>
<p>optional mask object if <code>x</code> is of class &quot;spatialGridAcomp&quot; or
&quot;spatialGridRmult&quot;, and they have been masked  (see <code><a href="#topic+setMask">setMask()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a list with elements <code>breaks</code> and <code>col</code> containing the breaks
and hexadecimal colors finally used for the z-values of the image. Particularly
useful for plotting other plotting elements on the same color scale.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Plot an image of gridded data
</p>
</li>
<li> <p><code>spatialGridRmult</code>: method for spatialGridRmult objects
</p>
</li>
<li> <p><code>spatialGridAcomp</code>: method for spatialGridAcomp objects
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getTellus(cleanup=TRUE, TI=TRUE)
load("Tellus_TI.RData")
head(Tellus_TI)
coords = as.matrix(Tellus_TI[,1:2])
compo = compositions::acomp(Tellus_TI[,3:7])
dt = spatialGridAcomp(coords=coords, compo=compo)
image_cokriged(dt, ivar="MgO") # equi-spaced
image_cokriged(dt, ivar="MgO", breaks = NULL) # equi-probable

## End(Not run)
</code></pre>

<hr>
<h2 id='image.logratioVariogramAnisotropy'>Plot variogram maps for anisotropic logratio variograms</h2><span id='topic+image.logratioVariogramAnisotropy'></span>

<h3>Description</h3>

<p>Image method to obtain variogram maps for anisotropic logratio variograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logratioVariogramAnisotropy'
image(
  x,
  jointColor = FALSE,
  breaks = NULL,
  probs = seq(0, 1, 0.1),
  col = spectralcolors,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.logratioVariogramAnisotropy_+3A_x">x</code></td>
<td>
<p>object of class c(&quot;logratioVariogramAnisotropy&quot;, &quot;logratioVariogram&quot;)</p>
</td></tr>
<tr><td><code id="image.logratioVariogramAnisotropy_+3A_jointcolor">jointColor</code></td>
<td>
<p>logical, should all variogram maps share the same color scale?</p>
</td></tr>
<tr><td><code id="image.logratioVariogramAnisotropy_+3A_breaks">breaks</code></td>
<td>
<p>breaks to use in the color scale</p>
</td></tr>
<tr><td><code id="image.logratioVariogramAnisotropy_+3A_probs">probs</code></td>
<td>
<p>alternatively to explicit <code>breaks</code>, these probabilities allow to ask for some equally probable breaks</p>
</td></tr>
<tr><td><code id="image.logratioVariogramAnisotropy_+3A_col">col</code></td>
<td>
<p>either a color palette, or else a vector of colors to use, of length <code>length(breaks)-1</code></p>
</td></tr>
<tr><td><code id="image.logratioVariogramAnisotropy_+3A_...">...</code></td>
<td>
<p>additional arguments for generic functionality (currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its effect of producing a figure.
Additionally, the graphical parameters active <em>prior to calling this function</em> are
returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("jura", package="gstat")
X = jura.pred[,1:2]
Zc = compositions::acomp(jura.pred[,7:9])
vg = logratioVariogram(data=Zc, loc=X, azimuth=c(0:18)*10, 
                           azimuth.tol=22.5)
image(vg)
image(vg, jointColor=TRUE)

</code></pre>

<hr>
<h2 id='image.mask'>Image method for mask objects</h2><span id='topic+image.mask'></span>

<h3>Description</h3>

<p>Plot a mask of a 2D grid; see <code><a href="#topic+constructMask">constructMask()</a></code> for an example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mask'
image(x, col = c(NA, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.mask_+3A_x">x</code></td>
<td>
<p>a mask</p>
</td></tr>
<tr><td><code id="image.mask_+3A_col">col</code></td>
<td>
<p>a two-color vector for the color (oustide, inside) the mask</p>
</td></tr>
<tr><td><code id="image.mask_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='is.anisotropySpecification'>Check for any anisotropy class</h2><span id='topic+is.anisotropySpecification'></span>

<h3>Description</h3>

<p>Check that an object contains a valid specification of anisotropy, in any form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.anisotropySpecification(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.anisotropySpecification_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical, TRUE if the object is an anisotropy specification; FALSE otherwise
</p>


<h3>See Also</h3>

<p>Other anisotropy: 
<code><a href="#topic+AnisotropyRangeMatrix">AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+AnisotropyScaling">AnisotropyScaling</a>()</code>,
<code><a href="#topic+anis_GSLIBpar2A">anis_GSLIBpar2A</a>()</code>,
<code><a href="#topic+as.AnisotropyRangeMatrix">as.AnisotropyRangeMatrix</a>()</code>,
<code><a href="#topic+as.AnisotropyScaling">as.AnisotropyScaling</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a =  anis2D_par2A(0.5, 30)
a
is.anisotropySpecification(a)
</code></pre>

<hr>
<h2 id='is.isotropic'>Check for anisotropy of a theoretical variogram</h2><span id='topic+is.isotropic'></span>

<h3>Description</h3>

<p>Checks for anisotropy of a theoretical variogram or covariance function model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.isotropic(x, tol = 1e-10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.isotropic_+3A_x">x</code></td>
<td>
<p>variogram or covariance model object</p>
</td></tr>
<tr><td><code id="is.isotropic_+3A_tol">tol</code></td>
<td>
<p>tolerance for</p>
</td></tr>
<tr><td><code id="is.isotropic_+3A_...">...</code></td>
<td>
<p>extra arguments for generic  functionality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generic function. Returns of boolean answering the question of the name,
or NA if object <code>x</code> does not contain a known theoretical variogram
</p>

<hr>
<h2 id='KrigingNeighbourhood'>Create a parameter set of local for neighbourhood specification.</h2><span id='topic+KrigingNeighbourhood'></span>

<h3>Description</h3>

<p>Create a parameter set describing a kriging neighbourhood (local or global) for
cokriging and cokriging based simulation. This heavily relies on the definitions of
<code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code>. All parameters are optional, as their default amounts to a global
neihghbourhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KrigingNeighbourhood(
  nmax = Inf,
  nmin = 0,
  omax = 0,
  maxdist = Inf,
  force = FALSE,
  anisotropy = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KrigingNeighbourhood_+3A_nmax">nmax</code></td>
<td>
<p>maximum number of data points per cokriging system</p>
</td></tr>
<tr><td><code id="KrigingNeighbourhood_+3A_nmin">nmin</code></td>
<td>
<p>minimum number of data points per cokriging system</p>
</td></tr>
<tr><td><code id="KrigingNeighbourhood_+3A_omax">omax</code></td>
<td>
<p>maximum number of data points per cokriging system per quadrant/octant</p>
</td></tr>
<tr><td><code id="KrigingNeighbourhood_+3A_maxdist">maxdist</code></td>
<td>
<p>maximum radius of the search neighborhood</p>
</td></tr>
<tr><td><code id="KrigingNeighbourhood_+3A_force">force</code></td>
<td>
<p>logical; if less than <code>nmin</code> points are found inside <code>maxdist</code> radius,
keep searching.</p>
</td></tr>
<tr><td><code id="KrigingNeighbourhood_+3A_anisotropy">anisotropy</code></td>
<td>
<p>currently ignored; in the future, argument to specify anisotropic search areas.</p>
</td></tr>
<tr><td><code id="KrigingNeighbourhood_+3A_...">...</code></td>
<td>
<p>further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3-list of class &quot;gmKrigingNeighbourhood&quot; containing the six elements given as arguments
to the function. This is just a compact way to provide further functions such as <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a>
with appropriate triggers for choosing a prediction method or another, in this case for triggering
cokriging (if alone) or eventually sequential simulation (see <code><a href="#topic+SequentialSimulation">SequentialSimulation()</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
summary(X)
Zc = jura.pred[,7:10]
ng_global = KrigingNeighbourhood()
ng_local = KrigingNeighbourhood(maxdist=1, nmin=4, 
                                omax=5, force=TRUE)
ng_local
ng_global
make.gmCompositionalGaussianSpatialModel(data = Zc, coords = X,
                                         V = "alr", ng = ng_local)
</code></pre>

<hr>
<h2 id='LeaveOneOut'>Specify the leave-one-out strategy for validation of a spatial model</h2><span id='topic+LeaveOneOut'></span>

<h3>Description</h3>

<p>Function to specify the leave-one-out strategy for validation of a spatial model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LeaveOneOut()
</code></pre>


<h3>Value</h3>

<p>an object of class c(&quot;LeaveOneOut&quot;, &quot;NfoldCrossValidation&quot;) to be used
in a call to <code><a href="#topic+validate">validate()</a></code>
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+NfoldCrossValidation">NfoldCrossValidation</a></code>,
<code><a href="#topic+validate">validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LeaveOneOut()
</code></pre>

<hr>
<h2 id='length.gmCgram'>Length, and number of columns or rows</h2><span id='topic+length.gmCgram'></span><span id='topic+ncol.gmCgram'></span><span id='topic+nrow.gmCgram'></span>

<h3>Description</h3>

<p>Provide number of structures, and nr of variables of an LMC of class gmCgram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmCgram'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.gmCgram_+3A_x">x</code></td>
<td>
<p>gmCgram object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>length</code> returns the number of structures (nugget not counted), while
<code>ncol</code> and <code>nrow</code> return these values for the nugget (assuming that they will
be also valid for the sill).
</p>


<h3>See Also</h3>

<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(3)+0.5, anisRanges = 2*diag(c(3,0.5)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(3), anisRanges = 0.5*diag(2))
vm = v1+v2
length(vm)
ncol(vm)
nrow(vm)
</code></pre>

<hr>
<h2 id='LMCAnisCompo'>Create a anisotropic model for regionalized compositions</h2><span id='topic+LMCAnisCompo'></span>

<h3>Description</h3>

<p>Creates a (potentially anisotropic) variogram model for variation-variograms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMCAnisCompo(
  Z,
  models = c("nugget", "sph", "sph"),
  azimuths = rep(0, length(models)),
  ranges = matrix(1, nrow = length(models), ncol = G),
  sillarray = NULL,
  V = NULL,
  tol = 1e-12,
  G = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMCAnisCompo_+3A_z">Z</code></td>
<td>
<p>compositional data set, used to derive the compositional dimension and colnames</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_models">models</code></td>
<td>
<p>string (or vector of strings) specifying which reference model(s) to use</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_azimuths">azimuths</code></td>
<td>
<p>typically a vector providing, for each model, the direction
of maximal continuity (measured from North clockwise)</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_ranges">ranges</code></td>
<td>
<p>typically a <code>G</code>-column matrix providing the minimal and maximal ranges, with one row per model
(with <code>G</code> specified below)</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_sillarray">sillarray</code></td>
<td>
<p>array of sills for each model. It can be null (to be estimated in the future). If specified,
provide an appropriate <code style="white-space: pre;">&#8288;(x,x,K)&#8288;</code>-array, where <code>K</code> is the number of models given, and <code>x</code> is explained below.</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_v">V</code></td>
<td>
<p>depending on what do you give as sillarray, you may need to provide the matrix of logcontrasts, or
a string indicating whether the sills are represented in &quot;alr&quot; or &quot;ilr&quot;</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_tol">tol</code></td>
<td>
<p>tolerance for determination of positive definiteness</p>
</td></tr>
<tr><td><code id="LMCAnisCompo_+3A_g">G</code></td>
<td>
<p>one of c(1, 2, 3) identifying if we are in 1D, 2D or 3D cases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;LMCAnisCompo&quot; with all provided information appropriately structured,
ready to be used for fitting, plotting or prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
Zc = compositions::acomp(jura.pred[,7:9])
LMCAnisCompo(Zc, models=c("nugget", "sph"), azimuths=c(0,45))
</code></pre>

<hr>
<h2 id='logratioVariogram'>Empirical logratio variogram calculation</h2><span id='topic+logratioVariogram'></span>

<h3>Description</h3>

<p>Calculation of an empirical logratio variogram (aka variation-variogram)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logratioVariogram(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logratioVariogram_+3A_data">data</code></td>
<td>
<p>a data container (of class &quot;gmSpatialModel&quot;) or a composition (of class &quot;acomp&quot;)</p>
</td></tr>
<tr><td><code id="logratioVariogram_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function depends on the number of <code>azimuth</code> values provided:
if it is one single value (or if you explicitly call <code>logratioVariogram.default</code>) the result is
a list of class &quot;logratioVariogram&quot; with the following elements
</p>

<ul>
<li><p> vg:	A nbins x D x D array containing the logratio variograms
</p>
</li>
<li><p> h:	A nbins x D x D array containing the mean distance the value is computed on.
</p>
</li>
<li><p> n:	A nbins x D x D array containing the number of nonmissing pairs used for the corresponding value.
If <code>azimuth</code> is a vector of directions, then the result is a matrix-like list of  &quot;logratioVariogram&quot; objects.
Each element of the mother list (or column of the matrix) is the variogram of one direction.
The output has a compound class c(&quot;logratioVariogramAnisotropy&quot;, &quot;logratioVariogram&quot;).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
Zc = compositions::acomp(jura.pred[,7:13])
vg = logratioVariogram(data=Zc, loc=X)
class(vg)
summary(vg)
vg = logratioVariogram(data=Zc, loc=X, azimuth=c(0,90))
class(vg)
summary(vg)
</code></pre>

<hr>
<h2 id='logratioVariogram_gmSpatialModel'>Variogram method for gmSpatialModel objects</h2><span id='topic+logratioVariogram_gmSpatialModel'></span><span id='topic+variogram_gmSpatialModel'></span>

<h3>Description</h3>

<p>Compute the empirical variogram of the conditioning data contained in a <a href="#topic+gmSpatialModel-class">gmSpatialModel</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logratioVariogram_gmSpatialModel(
  data,
  ...,
  azimuth = 0,
  azimuth.tol = 180/length(azimuth)
)

variogram_gmSpatialModel(object, methodPars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logratioVariogram_gmSpatialModel_+3A_data">data</code></td>
<td>
<p>the data container (see <a href="#topic+gmSpatialModel-class">gmSpatialModel</a> for details)</p>
</td></tr>
<tr><td><code id="logratioVariogram_gmSpatialModel_+3A_...">...</code></td>
<td>
<p>further parameters to <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code></p>
</td></tr>
<tr><td><code id="logratioVariogram_gmSpatialModel_+3A_azimuth">azimuth</code></td>
<td>
<p>which direction, or directions, are desired (in case of directional variogram)</p>
</td></tr>
<tr><td><code id="logratioVariogram_gmSpatialModel_+3A_azimuth.tol">azimuth.tol</code></td>
<td>
<p>which tolerance sould be used for directional variograms?</p>
</td></tr>
<tr><td><code id="logratioVariogram_gmSpatialModel_+3A_object">object</code></td>
<td>
<p>a gmSpatialModel object containing spatial data.</p>
</td></tr>
<tr><td><code id="logratioVariogram_gmSpatialModel_+3A_methodpars">methodPars</code></td>
<td>
<p>(currently ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Currently the function is just a convenience wrapper on
the variogram calculation functionalities of package &quot;gstat&quot;,
and returns objects of class &quot;<code>gstatVariogram</code>&quot;. Check the
help of <code>gstat::variogram</code> for further information.
In the near future, methods will be created, which will depend on
the properties of the two arguments provided,  <code>object</code> and
<code>methodPars</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>logratioVariogram_gmSpatialModel</code>: logratio variogram method (see <code><a href="#topic+logratioVariogram">logratioVariogram()</a></code> for details)
</p>
</li></ul>

<hr>
<h2 id='logratioVariogram+2Cacomp-method'>Logratio variogram of a compositional data</h2><span id='topic+logratioVariogram+2Cacomp-method'></span>

<h3>Description</h3>

<p>gmGeostats reimplementation of the compositions::logratioVariogram function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'acomp'
logratioVariogram(
  data = comp,
  loc,
  ...,
  azimuth = 0,
  azimuth.tol = 180/length(azimuth),
  comp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logratioVariogram+2B2Cacomp-method_+3A_data">data</code></td>
<td>
<p>a data container (of class &quot;gmSpatialModel&quot;) or a composition (of class &quot;acomp&quot;)</p>
</td></tr>
<tr><td><code id="logratioVariogram+2B2Cacomp-method_+3A_loc">loc</code></td>
<td>
<p>if <code>data</code> is a composition (or if <code>comp</code> is provided), spatial coordinates of the sampling locations</p>
</td></tr>
<tr><td><code id="logratioVariogram+2B2Cacomp-method_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="logratioVariogram+2B2Cacomp-method_+3A_azimuth">azimuth</code></td>
<td>
<p>which direction, or directions, are desired (in case of directional variogram)</p>
</td></tr>
<tr><td><code id="logratioVariogram+2B2Cacomp-method_+3A_azimuth.tol">azimuth.tol</code></td>
<td>
<p>which tolerance sould be used for directional variograms?</p>
</td></tr>
<tr><td><code id="logratioVariogram+2B2Cacomp-method_+3A_comp">comp</code></td>
<td>
<p>an alias for <code>data</code>, provided for back-compatibility with compositions::logratioVariogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &quot;logratioVariogram&quot; object, or a &quot;logratioVariogramAnisotropy&quot; object
if you provide more than one <code>azimuth</code>. See <code><a href="#topic+logratioVariogram">logratioVariogram()</a></code> for details and
examples.
</p>

<hr>
<h2 id='Maf'>Generalised diagonalisations
Calculate several generalized diagonalisations out of a data set and its empirical
variogram</h2><span id='topic+Maf'></span><span id='topic+Maf.data.frame'></span><span id='topic+genDiag'></span><span id='topic+Maf.rmult'></span><span id='topic+Maf.aplus'></span><span id='topic+Maf.rplus'></span><span id='topic+Maf.ccomp'></span><span id='topic+Maf.rcomp'></span><span id='topic+Maf.acomp'></span><span id='topic+UWEDGE'></span><span id='topic+UWEDGE.default'></span><span id='topic+UWEDGE.acomp'></span><span id='topic+UWEDGE.rcomp'></span><span id='topic+RJD'></span><span id='topic+RJD.default'></span><span id='topic+RJD.acomp'></span><span id='topic+RJD.rcomp'></span>

<h3>Description</h3>

<p>Generalised diagonalisations
Calculate several generalized diagonalisations out of a data set and its empirical
variogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Maf(x, ...)

## S3 method for class 'data.frame'
Maf(x, vg, i = 2, ...)

## S3 method for class 'rmult'
Maf(x, vg, i = 2, ...)

## S3 method for class 'aplus'
Maf(x, vg, i = 2, ...)

## S3 method for class 'rplus'
Maf(x, vg, i = 2, ...)

## S3 method for class 'ccomp'
Maf(x, vg, i = 2, ...)

## S3 method for class 'rcomp'
Maf(x, vg, i = 2, ...)

## S3 method for class 'acomp'
Maf(x, vg, i = 2, ...)

UWEDGE(x, ...)

## Default S3 method:
UWEDGE(x, ...)

## S3 method for class 'acomp'
UWEDGE(x, vg, i = NULL, ...)

## S3 method for class 'rcomp'
UWEDGE(x, vg, i = NULL, ...)

RJD(x, ...)

## Default S3 method:
RJD(x, ...)

## S3 method for class 'acomp'
RJD(x, vg, i = NULL, ...)

## S3 method for class 'rcomp'
RJD(x, vg, i = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Maf_+3A_x">x</code></td>
<td>
<p>a data set, typically of class &quot;data.frame&quot; or of a compositional class</p>
</td></tr>
<tr><td><code id="Maf_+3A_...">...</code></td>
<td>
<p>generic functionality arguments</p>
</td></tr>
<tr><td><code id="Maf_+3A_vg">vg</code></td>
<td>
<p>empirical variogram, of a kind fitting to the data provided</p>
</td></tr>
<tr><td><code id="Maf_+3A_i">i</code></td>
<td>
<p>a slicer for the variogram, typically this will be one or more indices of
the lag distance to take. %For other options see codegetEmpVariogramSlice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object extending <code>c("princomp.CLASSOF(x)",</code>&quot;<code><a href="stats.html#topic+princomp">princomp</a></code>&quot;)
with classes &quot;<code>genDiag</code>&quot;, and an extra class argument depending on the
diagonalisation method chosen.
</p>
<p>Function <code>Maf</code> results carry the extra class &quot;<code>maf</code>&quot;, and they correspond
to minimum/maximum autocorrelation factors (MAF) as proposed by Switzer and Green
(1984). In this case, the
slicer is typically just the index of one lag distance (defaults to i=2). MAF
provides the analytical solution to the joint diagonalisation of two matrices,
the covariance of increments provided by the slicing and the conventional covariance
matrix (of the idt transformed values, if appropriate). Resulting factors are ordered
in decreasing order of spatial continuity, which might produce surprising
scree-plots for those who are used to see a screeplot of a principal component analysis.
</p>
<p>Function <code>UWEDGE</code> (Uniformly Weighted Exhaustive Diagonalization with Gauss
iterations; Tichavsky and Yeredor, 2009) results carry the extra class &quot;<code>uwedge</code>&quot;.
The function
is a wrapper on <code>jointDiag::uwedge</code> from package <code>jointDiag</code> (Gouy-Pailler, 2017).
In this case the
slicer is typically just a subset of indices of lag distances to consider
(defaults to the nearest indexes to mininum, maximum and mean lag distances of the
variogram). UWEDGE iteratively seeks for a pair of matrices (a mixing and a
demixing matrices) diagonalises the set of matrices <code class="reqn">M_1, M_2, \ldots, M_K</code>
given, by minimizing the target quantity
</p>
<p style="text-align: center;"><code class="reqn">Q_{uwedge}(A, W) = \sum_{k=1}^K Tr[E_k^t\cdot E_k],</code>
</p>

<p>where <code class="reqn">E_k = (W^t\cdot M_k \cdot W- A\cdot \Lambda_k\cdot A^t)</code> and
<code class="reqn">\Lambda_k = diag(W^t\cdot M_k \cdot W)</code> is the resulting diagonalized version of
each matrix. Obtained factors are ordered
in decreasing order of spatial continuity, which might produce surprising
scree-plots for those who are used to see a screeplot of a principal component analysis.
</p>
<p>Function <code>RJD</code> results carry the extra class &quot;<code>rjd</code>&quot;. The function
is a wrapper on <code>JADE::rjd</code> (Miettinen, Nordhausen and Taskinen, 2017),
implementing the Rotational joint diagonalisation method (Cardoso and Souloumiac, 1996).
In this case the
slicer is typically just a subset of indices of lag distances to consider
(defaults to the nearest indexes to mininum, maximum and mean lag distances).
This algorithm also served for quasi-diagonalising a set of matrices as in UWEDGE,
just that in this case the quantity to minimise is the sum of sequares of all off-diagonal
elements of <code class="reqn">A^t\cdot M_k\cdot A</code> for all <code class="reqn">k=1, 2, \ldots K</code>.
</p>
<p>All these functions produce output mimicking <code><a href="stats.html#topic+princomp">princomp</a></code>, i.e. with
elements
</p>

<dl>
<dt>sdev</dt><dd><p>contrary to the output in PCA, this contains the square root of the
metric variance of the predictions obtained for each individual factor; this is the
quantity needed for <code><a href="stats.html#topic+screeplot">screeplot</a></code> to create plots of explained variance
by factor</p>
</dd>
<dt>loadings</dt><dd><p>matrix of contributions of each (cdt-transformed) original variable to the new factors</p>
</dd>
<dt>center</dt><dd><p>center of the data set (eventually, represented through <code><a href="compositions.html#topic+cdt">cdt</a></code>),
in compositional methods</p>
</dd>
<dt>scale</dt><dd><p>the scalings applied to each original variable</p>
</dd>
<dt>n.obs</dt><dd><p>number of observations</p>
</dd>
<dt>scores</dt><dd><p>the scores of the supplied data on the new factors</p>
</dd>
<dt>call</dt><dd><p>the call to the function (attention: it actually may come much later)</p>
</dd>
</dl>

<p>and additionally some of the following arguments, in different order
</p>

<dl>
<dt>invLoadings</dt><dd><p>matrix of contributions of each factor onto each original variable</p>
</dd>
<dt>Center</dt><dd><p>compositional methods return here the cdt-backtransformed center</p>
</dd>
<dt>InvLoadings</dt><dd><p>compositional methods return here the clr-backtransformed inverse loadings, so that
each column of this matrix can be understood as a composition on itself</p>
</dd>
<dt>DownInvLoadings</dt><dd><p>compositional methods return here the clr-backtransformed &quot;minus inverse loadings&quot;, so that
each column of this matrix can be understood as a composition on itself; details in
<code><a href="compositions.html#topic+princomp.acomp">princomp.acomp</a></code> </p>
</dd>
<dt>C1, C2</dt><dd><p>Maf returns the two matrices that were diagonalised</p>
</dd>
<dt>eigenvalues</dt><dd><p>Maf returns the generalized eigenvalues of the diagonalisation of C1 and C2</p>
</dd>
<dt>gof</dt><dd><p>UWEDGE returns the values of the goodness of fit criterion across sweeps</p>
</dd>
<dt>diagonalized</dt><dd><p>RJD returns the diagonalized matrices, in an array of (K,D,D)-dimensions, being
D the number of variables in <code>x</code></p>
</dd>
<dt>type</dt><dd><p>a string describing which package and which function was used as a workhorse for
the calculation</p>
</dd>
</dl>

<p>NOTE: if the arguments you provide to RJD and UWEDGE are not of the appropriate type
(i.e. data.frames or equivalent) the default method of these functions will just attempt
to call the basis functions JADE:rjd and JointDiag:uwedge respectively.
This will be the case if you provide <code>x</code> as a &quot;<code>matrix</code>&quot;, or as
an &quot;<code>array</code>&quot;. In those cases, the output will NOT be structured as an extension
to princomp results; instead they will be native output from those functions.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>Maf</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>Maf.rmult</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>Maf.aplus</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>Maf.rplus</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>Maf.ccomp</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>Maf.rcomp</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>Maf.acomp</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>UWEDGE</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>UWEDGE.default</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>UWEDGE.acomp</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>UWEDGE.rcomp</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>RJD</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>RJD.default</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>RJD.acomp</code>: Generalised diagonalisations
</p>
</li>
<li> <p><code>RJD.rcomp</code>: Generalised diagonalisations
</p>
</li></ul>


<h3>References</h3>

<p>Cardoso, J. K. and Souloumiac A. 1996. Jacobi angles for simultaneous
diagonalization. SIAM Journal of Matrix Analysis and Applications 17(1), 161-164.
</p>
<p>Gouy-Pailler C., 2017. jointDiag: Joint approximate diagonalization of a set of
square matrices. R package version 0.3. https://CRAN.R-project.org/package=jointDiag
</p>
<p>Miettinen J., Nordhausen K., and Taskinen, S., 2017. Blind source separation based
on Joint diagonalization in R: The packages JADE and BSSasymp. Journal of Statistical
Software 76(2), 1-31.
</p>
<p>Switzer P. and Green A.A., 1984. Min/Max autocorrelation factors for multivariate
spatial imaging, Stanford University, Palo Alto, USA, 14pp.
</p>
<p>Tichavsky, P. and Yeredor, A., 2009. Fast approximate joint diagonalization
incorporating weight matrices. IEEE Transactions on Signal Processing 57, 878 ??? 891.
</p>


<h3>See Also</h3>

<p>Other generalised Diagonalisations: 
<code><a href="#topic+coloredBiplot.genDiag">coloredBiplot.genDiag</a>()</code>,
<code><a href="#topic+predict.genDiag">predict.genDiag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("magrittr")
require("gstat")
require("compositions")
data("jura", package="gstat")
gs = gstat(id="Cd", formula=log(Cd)~1, locations=~Xloc+Yloc, data=jura.pred) %&gt;% 
gstat(id="Co", formula=log(Cd)~1, locations=~Xloc+Yloc, data=jura.pred) %&gt;% 
gstat(id="Cr", formula=log(Cr)~1, locations=~Xloc+Yloc, data=jura.pred) %&gt;% 
gstat(id="Cu", formula=log(Cu)~1, locations=~Xloc+Yloc, data=jura.pred) %&gt;% 
gstat(id="Ni", formula=log(Ni)~1, locations=~Xloc+Yloc, data=jura.pred) %&gt;% 
gstat(id="Pb", formula=log(Pb)~1, locations=~Xloc+Yloc, data=jura.pred) %&gt;% 
gstat(id="Zn", formula=log(Zn)~1, locations=~Xloc+Yloc, data=jura.pred)
vg = variogram(gs)
mf = Maf(aplus(jura.pred[, -(1:6)]), vg=vg)
mf
mf$loadings
biplot(mf)
</code></pre>

<hr>
<h2 id='make.gmCompositionalGaussianSpatialModel'>Construct a Gaussian gmSpatialModel for regionalized compositions</h2><span id='topic+make.gmCompositionalGaussianSpatialModel'></span>

<h3>Description</h3>

<p>Construct a regionalized compositional data container to be used for Gaussian-based geostatistics: variogram modelling, cokriging and simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.gmCompositionalGaussianSpatialModel(
  data,
  coords = attr(data, "coords"),
  V = "ilr",
  prefix = NULL,
  model = NULL,
  beta = model$beta,
  formula = model$formula,
  ng = NULL,
  nmax = ng$nmax,
  nmin = ng$nmin,
  omax = ng$omax,
  maxdist = ng$maxdist,
  force = ng$force
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_data">data</code></td>
<td>
<p>either a <code><a href="compositions.html#topic+acomp">compositions::acomp()</a></code> compositional data set, or else a <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code> containing it</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_coords">coords</code></td>
<td>
<p>the coordinates of the sampling locations, if no SpatialPointsDataFrame was provided</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_v">V</code></td>
<td>
<p>optionally, a matrix of logcontrasts, or else one of the following strings: &quot;alr&quot;, &quot;ilr&quot; or &quot;clr&quot;;
to produce a plot of the empirical variogram in the corresponding representation; default to variation-variograms</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_prefix">prefix</code></td>
<td>
<p>the desired prefix name for the logratio variables, if this is wished to be forced; otherwise derived from <code>V</code></p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_model">model</code></td>
<td>
<p>a variogram model, of any relevant class</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_beta">beta</code></td>
<td>
<p>(see <code>formula</code>) the coefficients of dependence of the mean of the random field, if these are known; e.g. if <code>formula=~1</code> constant mean,
and the mean is indeed known, <code>beta</code> would be a compositional mean; seldom used directly</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_formula">formula</code></td>
<td>
<p>a formula without left-hand-side term, e.g. <code>~1</code> or <code>~Easting+Northing</code>, specifying what do we know of the
dependence of the mean of the random field; this follows the same ideas than in <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code></p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_ng">ng</code></td>
<td>
<p>optional neighborhood information, typically created with <code><a href="#topic+KrigingNeighbourhood">KrigingNeighbourhood()</a></code></p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_nmax">nmax</code></td>
<td>
<p>optional, neighborhood description: maximum number of data points per cokriging system</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_nmin">nmin</code></td>
<td>
<p>optional, neighborhood description: minimum number of data points per cokriging system</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_omax">omax</code></td>
<td>
<p>optional, neighborhood description: maximum number of data points per cokriging system per quadrant/octant</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_maxdist">maxdist</code></td>
<td>
<p>optional, neighborhood description: maximum radius of the search neighborhood</p>
</td></tr>
<tr><td><code id="make.gmCompositionalGaussianSpatialModel_+3A_force">force</code></td>
<td>
<p>optional logical, neighborhood description: if not <code>nmin</code> points are found inside <code>maxdist</code> radius,
keep searching. This and all preceding arguments for neighborhood definition are borrowed from <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;gmSpatialModel&quot; object with all information provided appropriately structured. See <a href="#topic+gmSpatialModel-class">gmSpatialModel</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SequentialSimulation">SequentialSimulation()</a></code>, <code><a href="#topic+TurningBands">TurningBands()</a></code> or <code><a href="#topic+CholeskyDecomposition">CholeskyDecomposition()</a></code> for specifying the exact
simulation method and its parameters, <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a> for running predictions or simulations
</p>
<p>Other gmSpatialModel: 
<code><a href="#topic+Predict">Predict</a>()</code>,
<code><a href="#topic+as.gmSpatialModel">as.gmSpatialModel</a>()</code>,
<code><a href="#topic+gmSpatialModel-class">gmSpatialModel-class</a></code>,
<code><a href="#topic+make.gmCompositionalMPSSpatialModel">make.gmCompositionalMPSSpatialModel</a>()</code>,
<code><a href="#topic+make.gmMultivariateGaussianSpatialModel">make.gmMultivariateGaussianSpatialModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[1:20,1:2]
Zc = compositions::acomp(jura.pred[1:20,7:13])
make.gmCompositionalGaussianSpatialModel(data=Zc, coords=X, V="alr")
</code></pre>

<hr>
<h2 id='make.gmCompositionalMPSSpatialModel'>Construct a Multi-Point gmSpatialModel for regionalized compositions</h2><span id='topic+make.gmCompositionalMPSSpatialModel'></span>

<h3>Description</h3>

<p>Construct a regionalized compositional data container to be used for multipoint geostatistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.gmCompositionalMPSSpatialModel(
  data,
  coords = attr(data, "coords"),
  V = "ilr",
  prefix = NULL,
  model = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.gmCompositionalMPSSpatialModel_+3A_data">data</code></td>
<td>
<p>either a <code><a href="compositions.html#topic+acomp">compositions::acomp()</a></code> compositional data set, or else a <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code> containing it</p>
</td></tr>
<tr><td><code id="make.gmCompositionalMPSSpatialModel_+3A_coords">coords</code></td>
<td>
<p>the coordinates of the sampling locations, if no SpatialPointsDataFrame was provided</p>
</td></tr>
<tr><td><code id="make.gmCompositionalMPSSpatialModel_+3A_v">V</code></td>
<td>
<p>optionally, a matrix of logcontrasts, or else one of the following strings: &quot;alr&quot;, &quot;ilr&quot; or &quot;clr&quot;;
to produce a plot of the empirical variogram in the corresponding representation; default to variation-variograms</p>
</td></tr>
<tr><td><code id="make.gmCompositionalMPSSpatialModel_+3A_prefix">prefix</code></td>
<td>
<p>the desired prefix name for the logratio variables, if this is wished to be forced; otherwise derived from <code>V</code></p>
</td></tr>
<tr><td><code id="make.gmCompositionalMPSSpatialModel_+3A_model">model</code></td>
<td>
<p>a training image, of any appropriate class (typically a <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame()</a></code> or <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialPixelsDataFrame()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;gmSpatialModel&quot; object with all information provided appropriately structured. See <a href="#topic+gmSpatialModel-class">gmSpatialModel</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DirectSamplingParameters">DirectSamplingParameters()</a></code> for specifying a direct simulation method parameters,
<a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a> for running the simulation
</p>
<p>Other gmSpatialModel: 
<code><a href="#topic+Predict">Predict</a>()</code>,
<code><a href="#topic+as.gmSpatialModel">as.gmSpatialModel</a>()</code>,
<code><a href="#topic+gmSpatialModel-class">gmSpatialModel-class</a></code>,
<code><a href="#topic+make.gmCompositionalGaussianSpatialModel">make.gmCompositionalGaussianSpatialModel</a>()</code>,
<code><a href="#topic+make.gmMultivariateGaussianSpatialModel">make.gmMultivariateGaussianSpatialModel</a>()</code>
</p>

<hr>
<h2 id='make.gmMultivariateGaussianSpatialModel'>Construct a Gaussian gmSpatialModel for regionalized multivariate data</h2><span id='topic+make.gmMultivariateGaussianSpatialModel'></span>

<h3>Description</h3>

<p>Construct a regionalized multivariate data container to be used for Gaussian-based geostatistics: variogram modelling, cokriging and simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.gmMultivariateGaussianSpatialModel(
  data,
  coords = attr(data, "coords"),
  model = NULL,
  beta = model$beta,
  formula = model$formula,
  ng = NULL,
  nmax = ng$nmax,
  nmin = ng$nmin,
  omax = ng$omax,
  maxdist = ng$maxdist,
  force = ng$force
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_data">data</code></td>
<td>
<p>either a data set of any data.frame similar class, or else a <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code> containing it</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_coords">coords</code></td>
<td>
<p>the coordinates of the sampling locations, if no SpatialPointsDataFrame was provided</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_model">model</code></td>
<td>
<p>a variogram model, of any relevant class</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_beta">beta</code></td>
<td>
<p>(see <code>formula</code>) the coefficients of dependence of the mean of the random field, if these are known; e.g. if <code>formula=~1</code> constant mean,
and the mean is indeed known, <code>beta</code> would be a compositional mean; seldom used directly</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_formula">formula</code></td>
<td>
<p>a formula without left-hand-side term, e.g. ~1 or ~Easting+Northing, specifying what do we know of the
dependence of the mean of the random field; this follows the same ideas than in <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code></p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_ng">ng</code></td>
<td>
<p>optional neighborhood information, typically created with <code><a href="#topic+KrigingNeighbourhood">KrigingNeighbourhood()</a></code></p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_nmax">nmax</code></td>
<td>
<p>optional, neighborhood description: maximum number of data points per cokriging system</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_nmin">nmin</code></td>
<td>
<p>optional, neighborhood description: minimum number of data points per cokriging system</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_omax">omax</code></td>
<td>
<p>optional, neighborhood description: maximum number of data points per cokriging system per quadrant/octant</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_maxdist">maxdist</code></td>
<td>
<p>optional, neighborhood description: maximum radius of the search neighborhood</p>
</td></tr>
<tr><td><code id="make.gmMultivariateGaussianSpatialModel_+3A_force">force</code></td>
<td>
<p>optional logical, neighborhood description: if not <code>nmin</code> points are found inside <code>maxdist</code> radius,
keep searching. This and all preceding arguments for neighborhood definition are borrowed from <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;gmSpatialModel&quot; object with all information provided appropriately structured. See <a href="#topic+gmSpatialModel-class">gmSpatialModel</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SequentialSimulation">SequentialSimulation()</a></code>, <code><a href="#topic+TurningBands">TurningBands()</a></code> or <code><a href="#topic+CholeskyDecomposition">CholeskyDecomposition()</a></code> for specifying the exact
simulation method and its parameters, <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a> for running predictions or simulations
</p>
<p>Other gmSpatialModel: 
<code><a href="#topic+Predict">Predict</a>()</code>,
<code><a href="#topic+as.gmSpatialModel">as.gmSpatialModel</a>()</code>,
<code><a href="#topic+gmSpatialModel-class">gmSpatialModel-class</a></code>,
<code><a href="#topic+make.gmCompositionalGaussianSpatialModel">make.gmCompositionalGaussianSpatialModel</a>()</code>,
<code><a href="#topic+make.gmCompositionalMPSSpatialModel">make.gmCompositionalMPSSpatialModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
Zc = jura.pred[,7:13]
make.gmMultivariateGaussianSpatialModel(data=Zc, coords=X)
</code></pre>

<hr>
<h2 id='mean.accuracy'>Mean accuracy</h2><span id='topic+mean.accuracy'></span>

<h3>Description</h3>

<p>Mean method for accuracy curves, after Deutsch (1997)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'accuracy'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.accuracy_+3A_x">x</code></td>
<td>
<p>accuracy curve obtained with <code><a href="#topic+accuracy">accuracy()</a></code></p>
</td></tr>
<tr><td><code id="mean.accuracy_+3A_...">...</code></td>
<td>
<p>generic functionality, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the mean accuracy after Deutsch (1997); details
can be found in <code><a href="#topic+precision.accuracy">precision()</a></code>.
</p>


<h3>See Also</h3>

<p>Other accuracy functions: 
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+plot.accuracy">plot.accuracy</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+xvErrorMeasures.default">xvErrorMeasures.default</a>()</code>,
<code><a href="#topic+xvErrorMeasures">xvErrorMeasures</a>()</code>
</p>

<hr>
<h2 id='mean.spatialDecorrelationMeasure'>Average measures of spatial decorrelation</h2><span id='topic+mean.spatialDecorrelationMeasure'></span>

<h3>Description</h3>

<p>Compute average measres of spatial decorrelation out of the result of a call
to <code><a href="#topic+spatialDecorrelation">spatialDecorrelation()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialDecorrelationMeasure'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.spatialDecorrelationMeasure_+3A_x">x</code></td>
<td>
<p>the outcome of a call to <code><a href="#topic+spatialDecorrelation">spatialDecorrelation()</a></code></p>
</td></tr>
<tr><td><code id="mean.spatialDecorrelationMeasure_+3A_...">...</code></td>
<td>
<p>further arguments to mean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mean for each measure available on <code>x</code>, i.e. this can be a vector.
The output is named.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatialDecorrelation">spatialDecorrelation()</a></code> for an example
</p>

<hr>
<h2 id='ModelStructuralFunctionSpecification-class'>Structural function model specification</h2><span id='topic+ModelStructuralFunctionSpecification-class'></span>

<h3>Description</h3>

<p>Abstract class, containing any specification of a variogram (or covariance) model.
Members must implement a coercion method to
class &quot;gmCgram&quot; (see <code><a href="#topic+setCgram">setCgram()</a></code> for an example), and (possibly) coercion to
class &quot;variogramModel&quot; or &quot;variogramModelList&quot; (see <code><a href="gstat.html#topic+vgm">gstat::vgm()</a></code>)
</p>

<hr>
<h2 id='ndirections'>Number of directions of an empirical variogram</h2><span id='topic+ndirections'></span><span id='topic+ndirections.default'></span><span id='topic+ndirections.azimuth'></span><span id='topic+ndirections.azimuthInterval'></span><span id='topic+ndirections.logratioVariogramAnisotropy'></span><span id='topic+ndirections.logratioVariogram'></span><span id='topic+ndirections.gmEVario'></span><span id='topic+ndirections.gstatVariogram'></span>

<h3>Description</h3>

<p>Returns the number of directions at which an empirical variogram was computed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndirections(x)

## Default S3 method:
ndirections(x)

## S3 method for class 'azimuth'
ndirections(x)

## S3 method for class 'azimuthInterval'
ndirections(x)

## S3 method for class 'logratioVariogramAnisotropy'
ndirections(x)

## S3 method for class 'logratioVariogram'
ndirections(x)

## S3 method for class 'gmEVario'
ndirections(x)

## S3 method for class 'gstatVariogram'
ndirections(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndirections_+3A_x">x</code></td>
<td>
<p>empirical variogram object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generic function. It provides the
number of directions at which an empirical variogram was computed
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: generic method
</p>
</li>
<li> <p><code>azimuth</code>: method for objects of class &quot;azimuth&quot; (vectors of single angles)
</p>
</li>
<li> <p><code>azimuthInterval</code>: method for objects of class &quot;azimuthInterval&quot; (data.frames of intervals for angles)
</p>
</li>
<li> <p><code>logratioVariogramAnisotropy</code>: method for empirical logratio variograms with anisotropy
</p>
</li>
<li> <p><code>logratioVariogram</code>: method for empirical logratio variograms without anisotropy
</p>
</li>
<li> <p><code>gmEVario</code>: method for empirical gmGeostats variograms
</p>
</li>
<li> <p><code>gstatVariogram</code>: method for empirical gstat variograms
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+logratioVariogram">logratioVariogram()</a></code>, <code><a href="gstat.html#topic+variogram">gstat::variogram()</a></code>
</p>
<p>Other gmEVario functions: 
<code><a href="#topic+as.gmEVario.gstatVariogram">as.gmEVario.gstatVariogram</a>()</code>,
<code><a href="#topic+gsi.EVario2D">gsi.EVario2D</a>()</code>,
<code><a href="#topic+gsi.EVario3D">gsi.EVario3D</a>()</code>,
<code><a href="#topic+plot.gmEVario">plot.gmEVario</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>
<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>

<hr>
<h2 id='NfoldCrossValidation'>Specify a strategy for validation of a spatial model</h2><span id='topic+NfoldCrossValidation'></span>

<h3>Description</h3>

<p>Specify a strategy to validate a spatial model. Currently only
leave-one-out and n-fold cross-validation are available, each specified
by its own function. Leave-one-out takes no parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NfoldCrossValidation(nfolds = 2, doAll = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NfoldCrossValidation_+3A_nfolds">nfolds</code></td>
<td>
<p>Either, one integer between 2 and the number of hard conditioning data,
specifying how many groups do you want to split the data available; or else a factor
specifying these groups</p>
</td></tr>
<tr><td><code id="NfoldCrossValidation_+3A_doall">doAll</code></td>
<td>
<p>boolean; should each group be used once for validating the model constructed
with the remaining groups; else, only the first group will be used for validation, and the other
will be used for training.</p>
</td></tr>
<tr><td><code id="NfoldCrossValidation_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object, a list with an appropriate class, controlling the strategy specified.
This can be of class &quot;NfoldCrossValidation&quot; or of class  c(&quot;LeaveOneOut&quot;, &quot;NfoldCrossValidation&quot;).
</p>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+LeaveOneOut">LeaveOneOut</a></code>,
<code><a href="#topic+validate">validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NfoldCrossValidation(nfolds=5, doAll=FALSE)
</code></pre>

<hr>
<h2 id='NGSAustralia'>National Geochemical Survey of Australia: soil data</h2><span id='topic+NGSAustralia'></span>

<h3>Description</h3>

<p>A dataset containing the geochemical composition of soil samples covering approx 2/3
of Australia, at a spatial resolution of 1 sample/5000 $km^2$.
The original data is published by Geosciences Australia under the Creative
Commons CC4 Licence + Attribution (CC-BY-SA-4.0).
The provided data set has additional information and
some pre-treatment with respect to the one available in the references below. These changes:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGSAustralia
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 5259 rows and 76 columns.
</p>


<h3>Details</h3>


<ul>
<li><p> Concentrations are all reported as mg/kg, also known as parts per million (ppm). Values below
detection limit are reported as minus the detection limit, as standardised in package
&quot;compositions&quot;.
</p>
</li>
<li><p> The samples were complemented with information about their belonging to one of the
major crustal blocks (MCB) of Australia.
</p>
</li>
<li><p> Easting and Northing coordinates were computed using the Lambert conformal conic projection of
Australia (earth ellipsoid GRS80; standard parallels: 18S and 36S latitude; central meridian:
134E longitude).
</p>
</li></ul>

<p>#' @format A tibble, a data set of compound class c(&quot;tbl_df&quot;, &quot;tbl&quot;, &quot;data.frame&quot;) with 5259
observations and 76 variables:
</p>

<dl>
<dt>ORDER</dt><dd><p>Entry order</p>
</dd>
<dt>SITEID</dt><dd><p>ID of the sampling site</p>
</dd>
<dt>DATE SAMPLED</dt><dd><p>Timestamp of the sampling</p>
</dd>
<dt>EAST</dt><dd><p>Easting coordinate of the sampling site</p>
</dd>
<dt>NORTH</dt><dd><p>Northing coordinate of the sampling site</p>
</dd>
<dt>LATITUDE</dt><dd><p>Latitude of the sampling site</p>
</dd>
<dt>LONGITUDE</dt><dd><p>Longitude of the sampling site</p>
</dd>
<dt>STATE</dt><dd><p>State of the sampling site, one of: &quot;NWS&quot; (New South Wales), &quot;NT&quot; (Northern Territory),
&quot;QLD&quot; (Qeensland), &quot;SA&quot; (Southern Australia), &quot;TAS&quot; (Tasmania), &quot;VIC&quot; (Victoria) or &quot;WA&quot; (Western Australia)</p>
</dd>
<dt>REGION</dt><dd><p>One of the three geo-regions of the data set: &quot;EAST&quot;, &quot;WEST&quot; or &quot;EUCLA&quot;</p>
</dd>
<dt>DUPLICATE CODE</dt><dd><p>Marker for duplicate samples, for quality control</p>
</dd>
<dt>SAMPLEID</dt><dd><p>ID of the sample</p>
</dd>
<dt>GRAIN SIZE</dt><dd><p>Particle size of the soil sample, one of &quot;&lt;2 mm&quot; (coarse) or &quot;&lt;75 um&quot; (fine)</p>
</dd>
<dt>DEPTH</dt><dd><p>Sampling depth, one of: &quot;TOS&quot; (top soil) or &quot;BOS&quot; (bottom soil)</p>
</dd>
<dt>CODE</dt><dd><p>A combination of <code style="white-space: pre;">&#8288;Grain Size&#8288;</code> and <code>DEPTH</code>, one of &quot;Tc&quot; &quot;Tf&quot; &quot;Bc&quot; &quot;Bf&quot;, standing for TOS coarse, TOS fine, BOS coarse and BOS fine, respectively</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ag ICP-MS mg/kg 0.03&#8288;</code></dt><dd><p>concemtration of Silver in that sample, analysed with inductive coupled plasma mass spectrometry (ICP-MS), with a detection limit of 0.03ppm</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Al XRF mg/kg 26&#8288;</code></dt><dd><p>concentration of Aluminium, analysed with X-Ray Fluorescence (XRF), detection limit 26 ppm</p>
</dd>
<dt><code style="white-space: pre;">&#8288;As ICP-MS mg/kg 0.4&#8288;</code></dt><dd><p>concentration of Arsenic measured with ICP-MS , detection limit: 0.4 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Au FA mg/kg 0.001&#8288;</code></dt><dd><p>concentration of Gold measured with fire assay (FA) , detection limit: 0.001 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ba ICP-MS mg/kg 0.5&#8288;</code></dt><dd><p>concentration of Barium measured with ICP-MS , detection limit: 0.5 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Be ICP-MS mg/kg 1.1&#8288;</code></dt><dd><p>concentration of Berillium measured with ICP-MS , detection limit: 1.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Bi ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Bismuth measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ca XRF mg/kg 14&#8288;</code></dt><dd><p>concentration of Calcium measured with XRF , detection limit: 14 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Cd ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Cadmium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ce ICP-MS mg/kg 0.03&#8288;</code></dt><dd><p>concentration of Cerium measured with ICP-MS , detection limit: 0.03 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Cl  XRF mg/kg 10&#8288;</code></dt><dd><p>concentration of Chlorine measured with XRF , detection limit: 10 mg/kg</p>
</dd>
<dt><code style="white-space: pre;">&#8288;Co ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Cobalt measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Cr ICP-MS mg/kg 0.5&#8288;</code></dt><dd><p>concentration of Cromium measured with ICP-MS , detection limit: 0.5 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Cs ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Caesium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Cu ICP-MS mg/kg 0.2&#8288;</code></dt><dd><p>concentration of Copper measured with ICP-MS , detection limit: 0.2 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Dy ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Dysprosium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Er ICP-MS mg/kg 0.03&#8288;</code></dt><dd><p>concentration of Erbium measured with ICP-MS , detection limit: 0.03 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Eu ICP-MS mg/kg 0.03&#8288;</code></dt><dd><p>concentration of Europium measured with ICP-MS , detection limit: 0.03 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;F ISE mg/kg 20&#8288;</code></dt><dd><p>concentration of Fluoride measured with Ion Selective Electrode (ISE), detection limit: 20 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;FeT XRF mg/kg 35&#8288;</code></dt><dd><p>concentration of total Iron measured with XRF , detection limit: 35 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ga ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Gallium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Gd ICP-MS mg/kg 0.03&#8288;</code></dt><dd><p>concentration of Gadolinium measured with ICP-MS , detection limit: 0.03 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ge ICP-MS mg/kg 0.04&#8288;</code></dt><dd><p>concentration of Germanium measured with ICP-MS , detection limit: 0.04 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Hf ICP-MS mg/kg 0.04&#8288;</code></dt><dd><p>concentration of Hafnium measured with ICP-MS , detection limit: 0.04 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ho ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Holmium measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;K XRF mg/kg 42&#8288;</code></dt><dd><p>concentration of Potassium measured with XRF , detection limit: 42 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;La ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Lantanum measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Lu ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Lutetium measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Mg XRF mg/kg 60&#8288;</code></dt><dd><p>concentration of Magnesium measured with XRF , detection limit: 60 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Mn XRF mg/kg 39&#8288;</code></dt><dd><p>concentration of Manganese measured with XRF , detection limit: 39 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Mo ICP-MS mg/kg 0.3&#8288;</code></dt><dd><p>concentration of Molybdenum measured with ICP-MS , detection limit: 0.3 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Na XRF mg/kg 74&#8288;</code></dt><dd><p>concentration of Sodium measured with XRF , detection limit: 74 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Nb ICP-MS mg/kg 0.03&#8288;</code></dt><dd><p>concentration of Niobium measured with ICP-MS , detection limit: 0.03 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Nd ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Neodymium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ni ICP-MS mg/kg 0.5&#8288;</code></dt><dd><p>concentration of Nickel measured with ICP-MS , detection limit: 0.5 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;P XRF mg/kg 22&#8288;</code></dt><dd><p>concentration of Phosphorus measured with XRF , detection limit: 22 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Pb ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Lead measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Pd FA mg/kg 0.001&#8288;</code></dt><dd><p>concentration of Palladium measured with FA , detection limit: 0.001 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Pr ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Praseodymium measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Pt FA mg/kg 0.0005&#8288;</code></dt><dd><p>concentration of Platinum measured with FA , detection limit: 0.0005 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Rb ICP-MS mg/kg 0.2&#8288;</code></dt><dd><p>concentration of Rubidium measured with ICP-MS , detection limit: 0.2 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;S XRF mg/kg 10&#8288;</code></dt><dd><p>concentration of Sulphur measured with XRF , detection limit: 10 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Sb ICP-MS mg/kg 0.4&#8288;</code></dt><dd><p>concentration of Antimony measured with ICP-MS , detection limit: 0.4 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Sc ICP-MS mg/kg 0.3&#8288;</code></dt><dd><p>concentration of Scandium measured with ICP-MS , detection limit: 0.3 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Si XRF mg/kg 47&#8288;</code></dt><dd><p>concentration of Silicon measured with XRF , detection limit: 47 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Sm ICP-MS mg/kg 0.04&#8288;</code></dt><dd><p>concentration of Samarium measured with ICP-MS , detection limit: 0.04 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Sn ICP-MS mg/kg 0.2&#8288;</code></dt><dd><p>concentration of Tin measured with ICP-MS , detection limit: 0.2 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Sr ICP-MS mg/kg 0.2&#8288;</code></dt><dd><p>concentration of Strontium measured with ICP-MS , detection limit: 0.2 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ta ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Tantalum measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Tb ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Terbium measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Th ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Thorium measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Ti XRF mg/kg 30&#8288;</code></dt><dd><p>concentration of Titanium measured with XRF , detection limit: 30 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;U ICP-MS mg/kg 0.02&#8288;</code></dt><dd><p>concentration of Uranium measured with ICP-MS , detection limit: 0.02 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;V ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Vanadium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;W ICP-MS mg/kg 0.1&#8288;</code></dt><dd><p>concentration of Wolframium measured with ICP-MS , detection limit: 0.1 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Y ICP-MS mg/kg 0.05&#8288;</code></dt><dd><p>concentration of Yttrium measured with ICP-MS , detection limit: 0.05 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Yb ICP-MS mg/kg 0.04&#8288;</code></dt><dd><p>concentration of Ytterbium measured with ICP-MS , detection limit: 0.04 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Zn ICP-MS mg/kg 0.9&#8288;</code></dt><dd><p>concentration of Zink measured with ICP-MS , detection limit: 0.9 mg/kg </p>
</dd>
<dt><code style="white-space: pre;">&#8288;Zr ICP-MS mg/kg 0.2&#8288;</code></dt><dd><p>concentration of Zirconium measured with ICP-MS , detection limit: 0.2 mg/kg </p>
</dd></dl>
<p>#'   </p>
<dl>
<dt>LOI CALC mg/kg</dt><dd><p>concentration of Loss-on-Ignition, measured by calcination</p>
</dd>
<dt><code style="white-space: pre;">&#8288;LOI CALC mg/kg&#8288;</code></dt><dd><p>concentration of Loss-On-Ignition measured with Calcination , detection limit: 0.2 mg/kg </p>
</dd></dl>
<p>#'   </p>
<dl>
<dt>LOI CALC mg/kg</dt><dd><p>concentration of Loss-on-Ignition, measured by calcination</p>
</dd>
<dt>MRB</dt><dd><p>obtained from simplifying the major crustal boundaries of Korsch2015a, Korsch2015b</p>
</dd>
</dl>



<h3>License</h3>

<p>CC BY-SA 4.0
</p>


<h3>Source</h3>

<p><a href="https://www.ga.gov.au/about/projects/resources/national-geochemical-survey">https://www.ga.gov.au/about/projects/resources/national-geochemical-survey</a>
</p>

<hr>
<h2 id='noSpatCorr.test'>Test for lack of spatial correlation</h2><span id='topic+noSpatCorr.test'></span><span id='topic+noSpatCorr.test.data.frame'></span><span id='topic+noSpatCorr.test.default'></span><span id='topic+noSpatCorr.test.matrix'></span>

<h3>Description</h3>

<p>Permutation test for checking lack of spatial correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noSpatCorr.test(Z, ...)

## S3 method for class 'data.frame'
noSpatCorr.test(Z, X, ...)

## Default S3 method:
noSpatCorr.test(Z, ...)

## S3 method for class 'matrix'
noSpatCorr.test(
  Z,
  X,
  R = 299,
  maxlag0 = 0.1 * max(as.matrix(dist(X))),
  minlagInf = 0.25 * max(as.matrix(dist(X))),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noSpatCorr.test_+3A_z">Z</code></td>
<td>
<p>matrix (or equivalent) of scaled observations</p>
</td></tr>
<tr><td><code id="noSpatCorr.test_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="noSpatCorr.test_+3A_x">X</code></td>
<td>
<p>matrix (or equivalent) of sample location coordinates</p>
</td></tr>
<tr><td><code id="noSpatCorr.test_+3A_r">R</code></td>
<td>
<p>number of realizations of the Monte Carlo test</p>
</td></tr>
<tr><td><code id="noSpatCorr.test_+3A_maxlag0">maxlag0</code></td>
<td>
<p>maximum lag distance to consider in the short range covariance</p>
</td></tr>
<tr><td><code id="noSpatCorr.test_+3A_minlaginf">minlagInf</code></td>
<td>
<p>minimum lag distance to consider in the long range covariance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a test of lack of spatial correlation by means of permutations. The test
statistic is based on the smallest eigenvalue of the generalised eigenvalues of the matrices
of covariance for short range and for long range.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>data.frame</code>: Test for lack of spatial correlation
</p>
</li>
<li> <p><code>default</code>: Test for lack of spatial correlation, works only for
Spatial objects with a &quot;data&quot; slot
</p>
</li>
<li> <p><code>matrix</code>: Test for lack of spatial correlation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[, 1:2]
Z = data.frame(compositions::ilr(jura.pred[,-(1:6)]))
## Not run:  
noSpatCorr.test(Z=Z, X=X)
# now destroy the spatial structure reshuffling the coordinates:
ip = sample(nrow(X))
noSpatCorr.test(Z=Z, X=X[ip,]) 

## End(Not run)
</code></pre>

<hr>
<h2 id='pairsmap'>Multiple maps
Matrix of maps showing different combinations of components of a composition, user defined</h2><span id='topic+pairsmap'></span><span id='topic+pairsmap.SpatialPointsDataFrame'></span><span id='topic+pairsmap.default'></span>

<h3>Description</h3>

<p>Multiple maps
Matrix of maps showing different combinations of components of a composition, user defined
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairsmap(data, ...)

## S3 method for class 'SpatialPointsDataFrame'
pairsmap(data, ...)

## Default S3 method:
pairsmap(
  data,
  loc,
  colscale = rev(rainbow(10, start = 0, end = 4/6)),
  cexrange = c(0.1, 2),
  scale = rank,
  commonscale = FALSE,
  mfrow = c(floor(sqrt(ncol(data))), ceiling(ncol(data)/floor(sqrt(ncol(data))))),
  foregroundcolor = "black",
  closeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairsmap_+3A_data">data</code></td>
<td>
<p>data to represent; admits many data containing objects
(matrix, data.frame, classes from package <code>compositions</code>) as well
as their <code>Spatial</code> counterparts (in which case, <code>loc</code> is not necessary)</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_loc">loc</code></td>
<td>
<p>matrix or data.frame of coordinates of the sample locations</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_colscale">colscale</code></td>
<td>
<p>set of colors to be used as colorscale (defauls to 10 colors between blue and red)</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_cexrange">cexrange</code></td>
<td>
<p>symbol size min and max values (default to 0.1 to 2)</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_scale">scale</code></td>
<td>
<p>function scaling the set of z-values of each map, defaults to <code><a href="base.html#topic+rank">rank</a></code></p>
</td></tr>
<tr><td><code id="pairsmap_+3A_commonscale">commonscale</code></td>
<td>
<p>logical, should all plots share a common z-scale? defaults to FALSE</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_mfrow">mfrow</code></td>
<td>
<p>vector of two integers, giving the number of plots per row and per column of the
matrix of plots to be created; defaults to something square-ish, somewhat wider than longer, and able to
contain all plots</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_foregroundcolor">foregroundcolor</code></td>
<td>
<p>color to be used for the border of the symbol</p>
</td></tr>
<tr><td><code id="pairsmap_+3A_closeplot">closeplot</code></td>
<td>
<p>logical, should the plot be left open (FALSE) for further changes, or be frozen (TRUE)?
defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is primarily called for producing a matrix of plots of each component of a
multivariate data set, such as a compositional data set. Each plot represents a map whose symbols
are colored and sized according to a z-scale controlled by one of the variables of the data set.
It can be used virtually with any geometry, any kind of data (compositional, positive, raw, etc).
This function returns invisibly the graphical parameters that were active prior to calling this
function. This allows the user to add further stuff to the plots (mostly, using <code>par(mfg=c(i,j))</code>
to plot on the diagram (i,j)), or else freeze the plot (by wrapping the call to <code>pwlrmap</code>
on a call to <code><a href="graphics.html#topic+par">par</a></code>).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>SpatialPointsDataFrame</code>: Multiple maps
</p>
</li>
<li> <p><code>default</code>: Multiple maps
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("Windarling")
library("compositions")
coords = as.matrix(Windarling[,c("Easting","Northing")])
compo = Windarling[,c("Fe","Al2O3","SiO2", "Mn", "P")]
compo$Rest = 100-rowSums(compo)
compo = acomp(compo)
pairsmap(data=clr(compo), loc=coords) # clr
pairsmap(data=compo, loc=coords) # closed data
</code></pre>

<hr>
<h2 id='plot.accuracy'>Plot method for accuracy curves</h2><span id='topic+plot.accuracy'></span>

<h3>Description</h3>

<p>Plot an accuracy curve out of the outcome of <code><a href="#topic+accuracy">accuracy()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'accuracy'
plot(
  x,
  xlim = c(0, 1),
  ylim = c(0, 1),
  xaxs = "i",
  yaxs = "i",
  type = "o",
  col = "red",
  asp = 1,
  xlab = "confidence",
  ylab = "coverage",
  pty = "s",
  main = "accuracy plot",
  colref = col[1],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.accuracy_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+accuracy">accuracy()</a></code> object</p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_xlim">xlim</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_ylim">ylim</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_xaxs">xaxs</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_yaxs">yaxs</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_type">type</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_col">col</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_asp">asp</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_ylab">ylab</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_pty">pty</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_main">main</code></td>
<td>
<p>graphical parameters, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_colref">colref</code></td>
<td>
<p>color for the reference line 1:1</p>
</td></tr>
<tr><td><code id="plot.accuracy_+3A_...">...</code></td>
<td>
<p>further graphical parameters to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called to plot the accuracy curve
<code class="reqn">\{(p_i, \pi_i), i=1,2, \ldots, I\}</code>, where <code class="reqn">\{p_i\}</code>
are a sequence of nominal confidence of prediction intervals and each <code class="reqn">\pi_i</code>
is the actual coverage of an interval with nominal confidence <code class="reqn">p_i</code>.
</p>


<h3>See Also</h3>

<p>Other accuracy functions: 
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+mean.accuracy">mean.accuracy</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+xvErrorMeasures.default">xvErrorMeasures.default</a>()</code>,
<code><a href="#topic+xvErrorMeasures">xvErrorMeasures</a>()</code>
</p>

<hr>
<h2 id='plot.gmCgram'>Draw cuves for covariance/variogram models</h2><span id='topic+plot.gmCgram'></span>

<h3>Description</h3>

<p>Represent a gmCgram object as a matrix of lines in several plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmCgram'
plot(
  x,
  xlim.up = NULL,
  xlim.lo = NULL,
  vdir.up = NULL,
  vdir.lo = NULL,
  xlength = 200,
  varnames = colnames(x$nugget),
  add = FALSE,
  commonAxis = TRUE,
  cov = TRUE,
  closeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gmCgram_+3A_x">x</code></td>
<td>
<p>object to draw, of class gmCgram // curently only valid for symmetric functions</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_xlim.up">xlim.up</code></td>
<td>
<p>range of lag values to use in plots of the upper triangle</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_xlim.lo">xlim.lo</code></td>
<td>
<p>range of lag values to use in plots of the lower triangle</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_vdir.up">vdir.up</code></td>
<td>
<p>geograohic directions to represent in the upper triangle</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_vdir.lo">vdir.lo</code></td>
<td>
<p>geograohic directions to represent in the lower triangle</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_xlength">xlength</code></td>
<td>
<p>number of discretization points to use for the curves (defaults to 200)</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_varnames">varnames</code></td>
<td>
<p>string vector, variable names to use in the labelling of axes</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_add">add</code></td>
<td>
<p>logical, should a new plot be created or stuff be added to an existing one?</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_commonaxis">commonAxis</code></td>
<td>
<p>logical, is a common Y axis for all plots in a row desired?</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_cov">cov</code></td>
<td>
<p>logical, should the covariance function (=TRUE) or the variogram (=FALSE) be plotted?</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_closeplot">closeplot</code></td>
<td>
<p>logical, should the plot be left open (FALSE) for further changes, or be frozen (TRUE)?
defaults to TRUE</p>
</td></tr>
<tr><td><code id="plot.gmCgram_+3A_...">...</code></td>
<td>
<p>further graphical parameters for the plotting function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effect of producing a plot: the plot will be
open to further changes if you provide <code>closeplot=FALSE</code>. Additionally, the function
invisibly returns the graphical parameters that were active before starting the plot. Hence,
if you want to freeze a plot and not add anymore to it, you can do <code>par(plot(x, closeplot=FALSE, ...))</code>,
or <code>plot(x, closeplot=TRUE, ...)</code>.
If you want to further add stuff to it, better just call <code>plot(x, closeplot=FALSE,...)</code>. The difference
is only relevant when working with the screen graphical device.
</p>


<h3>See Also</h3>

<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(3)-0.5, anisRanges = 2*diag(c(3,0.5)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(3), anisRanges = 0.5*diag(2))
vm = v1+v2
plot(vm)
plot(vm, cov=FALSE)
</code></pre>

<hr>
<h2 id='plot.gmEVario'>Plot empirical variograms</h2><span id='topic+plot.gmEVario'></span>

<h3>Description</h3>

<p>Flexible plot of an empirical variogram of class gmEVario
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmEVario'
plot(
  x,
  xlim.up = NULL,
  xlim.lo = NULL,
  vdir.up = NULL,
  vdir.lo = NULL,
  varnames = dimnames(x$gamma)[[2]],
  type = "o",
  add = FALSE,
  commonAxis = TRUE,
  cov = attr(x, "type") == "covariance",
  closeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gmEVario_+3A_x">x</code></td>
<td>
<p>object to print, of class gmEVario</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_xlim.up">xlim.up</code></td>
<td>
<p>range of X values to be used for the diagrams of the upper triangle</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_xlim.lo">xlim.lo</code></td>
<td>
<p>range of X values to be used for the diagrams of the lower triangle</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_vdir.up">vdir.up</code></td>
<td>
<p>in case of anisotropic variograms, indices of the directions to be plotted
on the upper triangle</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_vdir.lo">vdir.lo</code></td>
<td>
<p>..., indices of the directions to be plotted on the lower triangle</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_varnames">varnames</code></td>
<td>
<p>variable names to be used</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_type">type</code></td>
<td>
<p>string, controlling whether to plot lines, points, etc (see <code><a href="graphics.html#topic+plot">plot</a></code>)</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_add">add</code></td>
<td>
<p>boolean, add stuff to an existing diagram?</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_commonaxis">commonAxis</code></td>
<td>
<p>boolean, should vertical axes be shared by all plots in a row?</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_cov">cov</code></td>
<td>
<p>boolean, is this a covariance? (if FALSE, it is a variogram)</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_closeplot">closeplot</code></td>
<td>
<p>logical, should the plot be left open (FALSE) for further changes, or be frozen (TRUE)?
defaults to TRUE</p>
</td></tr>
<tr><td><code id="plot.gmEVario_+3A_...">...</code></td>
<td>
<p>further parameters to <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly, the graphical parameters active before calling the function.
This is useful for freezing the plot if you provided <code>closeplot=FALSE</code>.
</p>
<p>How to use arguments <code>vdir.lo</code> and <code>vdir.up</code>? Each empirical variogram <code>x</code> has been
computed along certain distances, recorded in its attributes and retrievable with command
<code><a href="#topic+ndirections">ndirections</a></code>.
</p>


<h3>See Also</h3>

<p>Other gmEVario functions: 
<code><a href="#topic+as.gmEVario.gstatVariogram">as.gmEVario.gstatVariogram</a>()</code>,
<code><a href="#topic+gsi.EVario2D">gsi.EVario2D</a>()</code>,
<code><a href="#topic+gsi.EVario3D">gsi.EVario3D</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gstat)
data("jura", package = "gstat")
X = as.matrix(jura.pred[,1:2])
Z = as.matrix(jura.pred[,c("Zn","Cd","Pb")])
vge = gsi.EVario2D(X,Z)
plot(vge)
plot(vge, pch=22, lty=1, bg="grey")
</code></pre>

<hr>
<h2 id='plot.logratioVariogramAnisotropy'>Plot variogram lines of empirical directional logratio variograms</h2><span id='topic+plot.logratioVariogramAnisotropy'></span>

<h3>Description</h3>

<p>Plots an &quot;logratioVariogramAnisotropy&quot; object in a series of panels, with each direction
represented as a broken line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logratioVariogramAnisotropy'
plot(
  x,
  azimuths = colnames(x),
  col = rev(rainbow(length(azimuths))),
  type = "o",
  V = NULL,
  lty = 1,
  pch = 1:length(azimuths),
  model = NULL,
  figsp = 0,
  closeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_x">x</code></td>
<td>
<p>logratio variogram with anisotropy, i.e. object of class c(&quot;logratioVariogramAnisotropy&quot;, &quot;logratioVariogram&quot;)</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_azimuths">azimuths</code></td>
<td>
<p>which directions do you want to plot? default: all directions available</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_col">col</code></td>
<td>
<p>colors to be used for plotting</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_type">type</code></td>
<td>
<p>type of representation, see <code><a href="graphics.html#topic+plot">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_v">V</code></td>
<td>
<p>optionally, a matrix of logcontrasts, or else one of the following strings: &quot;alr&quot;, &quot;ilr&quot; or &quot;clr&quot;;
to produce a plot of the empirical variogram in the corresponding representation; default to variation-variograms</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_lty">lty</code></td>
<td>
<p>style of the lines, potentially different for each directions</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_pch">pch</code></td>
<td>
<p>symbols for the points, potentially different for each directions</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_model">model</code></td>
<td>
<p>eventually, variogram model to plot on top of the empirical variogram</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_figsp">figsp</code></td>
<td>
<p>spacing between the several panels, if desired</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_closeplot">closeplot</code></td>
<td>
<p>boolean, should the plotting par() be returned to the starting values? (defaults to TRUE;
see <code>plot.gmCgram()</code> for details)</p>
</td></tr>
<tr><td><code id="plot.logratioVariogramAnisotropy_+3A_...">...</code></td>
<td>
<p>additional graphical arguments, to be passed to the underlying <code><a href="graphics.html#topic+matplot">graphics::matplot()</a></code>
function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. The function is called to create a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
Zc = compositions::acomp(jura.pred[,7:9])
vg = logratioVariogram(data=Zc, loc=X, azimuth=c(0:3)*45, 
                         azimuth.tol=22.5)
plot(vg) 
</code></pre>

<hr>
<h2 id='plot.swarmPlot'>Plotting method for swarmPlot objects</h2><span id='topic+plot.swarmPlot'></span>

<h3>Description</h3>

<p>Produces a plot for objects obtained by means of <code><a href="#topic+swarmPlot">swarmPlot()</a></code>. These are lists of two-element
list, respectively giving the (x,y) coordinates of a series of points defining a curve. They
are typically obtained out of a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>, and each curve represents a a certain relevant
summary of one of the elements of the stack. All parameters of <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code>
are available, plus the following
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'swarmPlot'
plot(
  x,
  type = "l",
  col = "grey",
  xlim = NULL,
  ylim = NULL,
  xlab = "x",
  ylab = "y",
  main = NULL,
  asp = NA,
  sub = NULL,
  log = "",
  ann = par("ann"),
  axes = TRUE,
  frame.plot = axes,
  bg = NA,
  pch = 1,
  cex = 1,
  lty = 1,
  lwd = 1,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.swarmPlot_+3A_x">x</code></td>
<td>
<p>swarmPlot object</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_type">type</code></td>
<td>
<p>see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_col">col</code></td>
<td>
<p>color to be used for all curves and points</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_xlim">xlim</code></td>
<td>
<p>limits of the X axis, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_ylim">ylim</code></td>
<td>
<p>limits of the Y axis, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_xlab">xlab</code></td>
<td>
<p>label for the X axis, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_ylab">ylab</code></td>
<td>
<p>label for the Y axis, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_main">main</code></td>
<td>
<p>main plot title, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_asp">asp</code></td>
<td>
<p>plot aspect ratio, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_sub">sub</code></td>
<td>
<p>plot subtitle, see  <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_log">log</code></td>
<td>
<p>log scale for any axis? see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_ann">ann</code></td>
<td>
<p>plot annotation indications, see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_axes">axes</code></td>
<td>
<p>should axes be set? see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_frame.plot">frame.plot</code></td>
<td>
<p>should the plot be framed? see <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_bg">bg</code></td>
<td>
<p>fill color for the data points if certain <code>pch</code> symbols are used</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_pch">pch</code></td>
<td>
<p>symbol for the data points, see <code><a href="graphics.html#topic+points">graphics::points()</a></code></p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_cex">cex</code></td>
<td>
<p>symbol size for the data points</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_lty">lty</code></td>
<td>
<p>line style for the curves</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_lwd">lwd</code></td>
<td>
<p>line thickness for the curves</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_add">add</code></td>
<td>
<p>logical, add results to an existing plot?</p>
</td></tr>
<tr><td><code id="plot.swarmPlot_+3A_...">...</code></td>
<td>
<p>further parameters to the plotting function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. The function is called to make a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm = list(point=1:100, var=LETTERS[1:2], rep=paste("r",1:5, sep=""))
ar = array(rnorm(1000), dim=c(100,2,5), dimnames = dm)
dfs = DataFrameStack(ar, stackDim="rep")
rs = swarmPlot(dfs, PLOTFUN=function(x) density(x[,1]), .plotargs=FALSE)
plot(rs, col="yellow", lwd=3)
</code></pre>

<hr>
<h2 id='precision'>Precision calculations</h2><span id='topic+precision'></span><span id='topic+precision.accuracy'></span>

<h3>Description</h3>

<p>Precision calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(x, ...)

## S3 method for class 'accuracy'
precision(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_+3A_x">x</code></td>
<td>
<p>an object from which precision is to be computed</p>
</td></tr>
<tr><td><code id="precision_+3A_...">...</code></td>
<td>
<p>generic functionality, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output depends on input and meaning of the function (the term <code>precision</code>
is highly polysemic)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>accuracy</code>: Compute precision and goodness for accuracy curves, after Deutsch (1997),
using the accuracy curve obtained with <code><a href="#topic+accuracy">accuracy()</a></code>. This returns a named vector with
two values, one for <code>precision</code> and one for <code>goodness</code>.
</p>
<p>Mean accuracy, precision and goodness were defined by Deutsch (1997)
for an accuracy curve <code class="reqn">\{(p_i, \pi_i), i=1,2, \ldots, I\}</code>, where <code class="reqn">\{p_i\}</code>
are a sequence of nominal confidence of prediction intervals and each <code class="reqn">\pi_i</code>
is the actual coverage of an interval with nominal confidence <code class="reqn">p_i</code>.
Out of these values, the mean accuracy (see <code><a href="#topic+mean.accuracy">mean.accuracy()</a></code>) is computed as
</p>
<p style="text-align: center;"><code class="reqn"> A = \int_{0}^{1} I\{(\pi_i-p_i)&gt;0\} dp,</code>
</p>

<p>where the indicator <code class="reqn">I\{(\pi_i-p_i)&gt;0\}</code> is 1 if the condition is satisfied and
0 otherwise. Out of it, the area above the 1:1 bisector and under the accuracy
curve is the precision
<code class="reqn"> P = 1-2\int_{0}^{1} (\pi_i-p_i)\cdot I\{(\pi_i-p_i)&gt;0\} dp, </code>
which only takes into account those points of the accuracy curve where <code class="reqn">\pi_i&gt;p_i</code>.
To consider the whole curve, goodness can be used
</p>
<p style="text-align: center;"><code class="reqn">G = 1-\int_{0}^{1} (\pi_i-p_i)\cdot (3\cdot I\{(\pi_i-p_i)&gt;0\}-2) dp.</code>
</p>

</li></ul>


<h3>See Also</h3>

<p>Other accuracy functions: 
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+mean.accuracy">mean.accuracy</a>()</code>,
<code><a href="#topic+plot.accuracy">plot.accuracy</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+xvErrorMeasures.default">xvErrorMeasures.default</a>()</code>,
<code><a href="#topic+xvErrorMeasures">xvErrorMeasures</a>()</code>
</p>

<hr>
<h2 id='Predict'>Predict method for objects of class 'gmSpatialModel'</h2><span id='topic+Predict'></span><span id='topic+predict'></span><span id='topic+predict_gmSpatialModel'></span><span id='topic+predict.gmSpatialModel'></span><span id='topic+predict+2CgmSpatialModel-method'></span><span id='topic+Predict+2CgmSpatialModel+2CANY+2CANY-method'></span><span id='topic+Predict+2CgmSpatialModel+2CANY+2CgmNeighbourhoodSpecification-method'></span><span id='topic+Predict+2CgmSpatialModel+2CANY+2CgmTurningBands-method'></span><span id='topic+Predict+2CgmSpatialModel+2CANY+2CgmCholeskyDecomposition-method'></span><span id='topic+Predict+2CgmSpatialModel+2CANY+2CgmSequentialSimulation-method'></span><span id='topic+Predict+2CgmSpatialModel+2CANY+2CgmDirectSamplingParameters-method'></span>

<h3>Description</h3>

<p>This is a one-entry function for several spatial prediction and simulation methods, for model objects
of class <a href="#topic+gmSpatialModel-class">gmSpatialModel</a>. The several methods are chosen by means of <code>pars</code> objects of the
appropriate class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Predict(object, newdata, pars, ...)

predict(object, ...)

## S3 method for class 'gmSpatialModel'
predict(object, newdata, pars = NULL, ...)

## S4 method for signature 'gmSpatialModel'
predict(object, newdata, pars = NULL, ...)

## S4 method for signature 'gmSpatialModel,ANY,ANY'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmNeighbourhoodSpecification'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmTurningBands'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmCholeskyDecomposition'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmSequentialSimulation'
Predict(object, newdata, pars, ...)

## S4 method for signature 'gmSpatialModel,ANY,gmDirectSamplingParameters'
Predict(object, newdata, pars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Predict_+3A_object">object</code></td>
<td>
<p>a complete &quot;gmSpatialModel&quot;, containing conditioning data and unconditional model</p>
</td></tr>
<tr><td><code id="Predict_+3A_newdata">newdata</code></td>
<td>
<p>a collection of locations where a prediction/simulation is desired; this is typically
a <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPoints()</a></code>, a data.frame or similar of X-Y(-Z) coordinates; or perhaps for gridded data
an object of class  <code><a href="sp.html#topic+SpatialGrid">sp::GridTopology()</a></code>, <code><a href="sp.html#topic+SpatialGrid">sp::SpatialGrid()</a></code> or <code><a href="sp.html#topic+SpatialGrid">sp::SpatialPixels()</a></code></p>
</td></tr>
<tr><td><code id="Predict_+3A_pars">pars</code></td>
<td>
<p>parameters describing the method to use, <em>enclosed in an object of appropriate class</em>
(according to the method; see below)</p>
</td></tr>
<tr><td><code id="Predict_+3A_...">...</code></td>
<td>
<p>further parameters for generic functionality, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package &quot;gmGeostats&quot; aims at providing a broad series of algorithms for geostatistical prediction
and simulation. All can be accesses through this interface, provided that arguments <code>object</code> and <code>pars</code> are of the
appropriate kind. In <code>object</code>, the most important criterion is the nature of its slot <code>model</code>. In <code>pars</code>
its class counts: for the creation of informative parameters in the appropriate format and class, a series
of accessory functions are provided as well.
</p>
<p>Classical (gaussian-based two-point) geostatistics are obtained if <code>object@model</code> contains a covariance function,
or a variogram model. Argument <code>pars</code> can be created with functions such as <code><a href="#topic+KrigingNeighbourhood">KrigingNeighbourhood()</a></code>,
<code><a href="#topic+SequentialSimulation">SequentialSimulation()</a></code>, <code><a href="#topic+TurningBands">TurningBands()</a></code> or <code><a href="#topic+CholeskyDecomposition">CholeskyDecomposition()</a></code> to respectively trigger a cokriging, as
sequential Gaussian simulation, a turning bands simulation, or a simulation via Cholesky decomposition.
The kriging neighbourhood can as well be incorporated in the &quot;gmSpatialModel&quot; <code>object</code> directly, or even be
nested in a &quot;SequentialSimulation&quot; parameter object.
</p>
<p>Conversely, to run a multipoint geostatistics algorithm, the first condition is that <code>object@model</code> contains a
training image. Additionally, <code>pars</code> must describe the characteristics of the algorithm to use. Currently, only
direct sampling is available: it can be obtained by providing some parameter object created with a call to
<code><a href="#topic+DirectSamplingParameters">DirectSamplingParameters()</a></code>. This method requires <code>newdata</code> to be on a gridded set of locations (acceptable
object classes are <code>sp::gridTopology</code>, <code>sp::SpatialGrid</code>, <code>sp::SpatialPixels</code>, <code>sp::SpatialPoints</code> or <code>data.frame</code>,
for the last two a forced conversion to a grid will be attempted).
</p>


<h3>Value</h3>

<p>Depending on the nature of <code>newdata</code>, the result will be a data container of the same kind,
extended with the predictions or simulations. For instance, if we want to obtain predictions on the
locations of a &quot;SpatialPoints&quot;, the result will be a <code><a href="sp.html#topic+SpatialPoints">sp::SpatialPointsDataFrame()</a></code>; if we want to obtain
simulations on the coordinates provided by a &quot;data.frame&quot;, the result will be a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> with
the spatial coordinates stored as an extra attribute; or if the input for a simulation is a masked grid of class
<code><a href="sp.html#topic+SpatialGrid">sp::SpatialPixels()</a></code>, the result will be of class <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialPixelsDataFrame()</a></code> which <code>data</code> slot will be
a <a href="#topic+DataFrameStack">DataFrameStack</a>.
</p>


<h3>See Also</h3>

<p>Other gmSpatialModel: 
<code><a href="#topic+as.gmSpatialModel">as.gmSpatialModel</a>()</code>,
<code><a href="#topic+gmSpatialModel-class">gmSpatialModel-class</a></code>,
<code><a href="#topic+make.gmCompositionalGaussianSpatialModel">make.gmCompositionalGaussianSpatialModel</a>()</code>,
<code><a href="#topic+make.gmCompositionalMPSSpatialModel">make.gmCompositionalMPSSpatialModel</a>()</code>,
<code><a href="#topic+make.gmMultivariateGaussianSpatialModel">make.gmMultivariateGaussianSpatialModel</a>()</code>
</p>

<hr>
<h2 id='predict.genDiag'>Predict method for generalised diagonalisation objects</h2><span id='topic+predict.genDiag'></span>

<h3>Description</h3>

<p>Predict method for generalised diagonalisation objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genDiag'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.genDiag_+3A_object">object</code></td>
<td>
<p>a generalized diagonalisation object, as obtained from a call to
<code><a href="#topic+Maf">Maf</a></code>, and on the same page, information on the other diagonalisation
methods <code>UWEDGE</code> or <code>RJD</code></p>
</td></tr>
<tr><td><code id="predict.genDiag_+3A_newdata">newdata</code></td>
<td>
<p>a matrix or data.frame of factor scores to convert back to the original
scale (default: the scores element from <code>object</code>)</p>
</td></tr>
<tr><td><code id="predict.genDiag_+3A_...">...</code></td>
<td>
<p>not used, kept for generic compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data set or compositional object of the nature of the original data
used for creating the genDiag object.
</p>


<h3>See Also</h3>

<p>Other generalised Diagonalisations: 
<code><a href="#topic+Maf">Maf</a>()</code>,
<code><a href="#topic+coloredBiplot.genDiag">coloredBiplot.genDiag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
juracomp = compositions::acomp(jura.pred[, -(1:6)]) 
lrvg = logratioVariogram(data=juracomp, loc=jura.pred[,1:2])
mf = Maf(juracomp, vg=lrvg)
mf
biplot(mf)
predict(mf) 
unclass(predict(mf)) - unclass(juracomp) # predict recovers the original composition
</code></pre>

<hr>
<h2 id='predict.LMCAnisCompo'>Compute model variogram values
Evaluate the variogram model provided at some lag vectors</h2><span id='topic+predict.LMCAnisCompo'></span>

<h3>Description</h3>

<p>Compute model variogram values
</p>
<p>Evaluate the variogram model provided at some lag vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LMCAnisCompo'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.LMCAnisCompo_+3A_object">object</code></td>
<td>
<p>variogram model</p>
</td></tr>
<tr><td><code id="predict.LMCAnisCompo_+3A_newdata">newdata</code></td>
<td>
<p>matrix or data.frame of lag vectors</p>
</td></tr>
<tr><td><code id="predict.LMCAnisCompo_+3A_...">...</code></td>
<td>
<p>extra arguments for generic compatbility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of dimension (nr of lags, D, D) with D the number of variables in the model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
Zc = compositions::acomp(jura.pred[,7:9])
lrmd = LMCAnisCompo(Zc, models=c("nugget", "sph"), azimuths=c(0,45))
predict(lrmd, outer(0:5, c(0,1)))
</code></pre>

<hr>
<h2 id='print.mask'>Print method for mask objects</h2><span id='topic+print.mask'></span>

<h3>Description</h3>

<p>Print method for mask objects. See <code><a href="#topic+constructMask">constructMask()</a></code> for examples.
If you want to see the whole content of the mask, then use <code>unclass(...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mask'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mask_+3A_x">x</code></td>
<td>
<p>mask to print</p>
</td></tr>
<tr><td><code id="print.mask_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the summary of number of nodes inside/outside the mask
</p>


<h3>See Also</h3>

<p>Other masking functions: 
<code><a href="#topic+constructMask">constructMask</a>()</code>,
<code><a href="#topic+getMask">getMask</a>()</code>,
<code><a href="#topic+setMask">setMask</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>
</p>

<hr>
<h2 id='pwlrmap'>Compositional maps, pairwise logratios
Matrix of maps showing different combinations of components of a composition, in pairwise logratios</h2><span id='topic+pwlrmap'></span>

<h3>Description</h3>

<p>Compositional maps, pairwise logratios
Matrix of maps showing different combinations of components of a composition, in pairwise logratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwlrmap(
  loc,
  comp,
  colscale = rev(rainbow(10, start = 0, end = 4/6)),
  cexrange = c(0.1, 2),
  scale = rank,
  commonscale = FALSE,
  foregroundcolor = "black",
  closeplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwlrmap_+3A_loc">loc</code></td>
<td>
<p>matrix or data.frame of coordinates of the sample locations</p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_comp">comp</code></td>
<td>
<p>composition observed at every location, can be a matrix, a data.frame or
of one of the classes <code>compositions::acomp</code> or <code>compositions::aplus</code></p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_colscale">colscale</code></td>
<td>
<p>set of colors to be used as colorscale (defauls to 10 colors between blue and red)</p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_cexrange">cexrange</code></td>
<td>
<p>symbol size min and max values (default to 0.1 to 2)</p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_scale">scale</code></td>
<td>
<p>function scaling the set of z-values of each map, defaults to <code><a href="base.html#topic+rank">rank</a></code></p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_commonscale">commonscale</code></td>
<td>
<p>logical, should all plots share a common z-scale? defaults to FALSE</p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_foregroundcolor">foregroundcolor</code></td>
<td>
<p>color to be used for the border of the symbol</p>
</td></tr>
<tr><td><code id="pwlrmap_+3A_closeplot">closeplot</code></td>
<td>
<p>logical, should the plot be left open (FALSE) for further changes, or be frozen (TRUE)?
defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is primarily called for producing a matrix of (D,D) plots of the D-part
compositional samples, where at each plot we represent a map whose symbols are colored and
sized according to a z-scale controlled by a different logratio. For each plot, this is the
logratio of the row variable by the column variable. However, in case that <code>closeplot=FALSE</code>,
this function returns
invisibly the graphical parameters that were active prior to calling this function. This allows
the user to add further stuff to the plots (mostly, using <code>par(mfg=c(i,j))</code> to plot on the
diagram (i,j)), or manually freeze the plot (by wrapping the call to <code>pwlrmap</code> on a call to
<code><a href="graphics.html#topic+par">par</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Windarling")
coords = as.matrix(Windarling[,c("Easting","Northing")])
compo = Windarling[,c("Fe","Al2O3","SiO2", "Mn", "P")]
compo$Rest = 100-rowSums(compo)
compo = compositions::acomp(compo) 
# in quantiles (default, ranking controls color and size)
pwlrmap(coords, compo) 

# in logratios (I=identity)
pwlrmap(coords, compo, scale=I)
# in ratios (i.e., apply exp)
pwlrmap(coords, compo, scale=exp)  
# use only color, no change in symbol size
pwlrmap(coords, compo, cexrange=c(1,1)) 
# change all
pwlrmap(coords, compo, commonscale=TRUE, cexrange=c(1.2,1.2), 
                    colscale=rev(rainbow(40, start=0, end=4/6))) 

</code></pre>

<hr>
<h2 id='SequentialSimulation'>Create a parameter set specifying a gaussian sequential simulation algorithm</h2><span id='topic+SequentialSimulation'></span>

<h3>Description</h3>

<p>Create a parameter set describing a sequential simulation algorithm to two-point simulation,
mostly for covariance or variogram-based gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SequentialSimulation(
  nsim = 1,
  ng = NULL,
  rank = Inf,
  debug.level = 1,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SequentialSimulation_+3A_nsim">nsim</code></td>
<td>
<p>number of realisations desired</p>
</td></tr>
<tr><td><code id="SequentialSimulation_+3A_ng">ng</code></td>
<td>
<p>a neighbourhood specification, as obtained with function <code><a href="#topic+KrigingNeighbourhood">KrigingNeighbourhood()</a></code></p>
</td></tr>
<tr><td><code id="SequentialSimulation_+3A_rank">rank</code></td>
<td>
<p>currently ignored (future functionality: obtain a reduced-rank simulation)</p>
</td></tr>
<tr><td><code id="SequentialSimulation_+3A_debug.level">debug.level</code></td>
<td>
<p>degree of verbosity of results; negative values produce a progress bar; values can be
extracted from <code><a href="gstat.html#topic+predict.gstat">gstat::predict.gstat()</a></code></p>
</td></tr>
<tr><td><code id="SequentialSimulation_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be
initialized, see <code>?simulate</code> in base &quot;stats&quot; package</p>
</td></tr>
<tr><td><code id="SequentialSimulation_+3A_...">...</code></td>
<td>
<p>further parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3-list of class &quot;gmSequentialSimulation&quot; containing the four elements given as arguments
to the function. This is just a compact way to provide further functions such as <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a>
with appropriate triggers for choosing a prediction method or another, in this case for triggering
sequential Gaussian simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
summary(X)
Zc = jura.pred[,7:10]
ng_local = KrigingNeighbourhood(maxdist=1, nmin=4, omax=5, force=TRUE)
(sgs_local = SequentialSimulation(nsim=100, ng=ng_local, debug.level=-1))
## then run predict(..., pars=sgs_local)
</code></pre>

<hr>
<h2 id='setCgram'>Generate D-variate variogram models</h2><span id='topic+setCgram'></span><span id='topic+vg.Exp'></span><span id='topic+vg.exp'></span><span id='topic+vg.Exponential'></span><span id='topic+vg.Gau'></span><span id='topic+vg.gauss'></span><span id='topic+vg.Gauss'></span><span id='topic+vg.Sph'></span><span id='topic+vg.sph'></span><span id='topic+vg.Spherical'></span><span id='topic+gsi.validModels'></span>

<h3>Description</h3>

<p>Function to set up D-variate variogram models based on model type, the variogram parameters sill and nugget and a matrix describing the anisotropy of the range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCgram(type, nugget = sill * 0, sill, anisRanges, extraPar = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCgram_+3A_type">type</code></td>
<td>
<p>model of correlation function. The function expects a constant, e.g. the internal constants 'vg.Gau' for Gaussian model or 'vg.Exp'. for exponential models. See examples for usage.</p>
</td></tr>
<tr><td><code id="setCgram_+3A_nugget">nugget</code></td>
<td>
<p>(DxD)-matrix for the nugget effect. Default is a muted nugget (0).</p>
</td></tr>
<tr><td><code id="setCgram_+3A_sill">sill</code></td>
<td>
<p>(DxD)-matrix for the partial sills of the correlation function</p>
</td></tr>
<tr><td><code id="setCgram_+3A_anisranges">anisRanges</code></td>
<td>
<p>2x2 or 3x3 matrix of ranges (see details)</p>
</td></tr>
<tr><td><code id="setCgram_+3A_extrapar">extraPar</code></td>
<td>
<p>for certain correlation functions, extra parameters (smoothness, period, etc)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>type</code> must be an integer indicating the model to be used.
Some constants are available to make reading code more understandable. That is, you can
either write <code>1</code>, <code>vg.sph</code>, <code>vg.Sph</code> or <code>vg.Spherical</code>, they will all work and produce
a spherical model. The same applies for the following models:
<code>vg.Gauss = vg.Gau = vg.gau = 0</code>;
<code style="white-space: pre;">&#8288;vg.Exponential = vg.Exp = vg. exp = 2&#8288;</code>.
These constants are available after calling <code>data("variogramModels")</code>.
No other model is currently available, but this data object will be
regularly updated.
The constant vector <code>gsi.validModels</code> contains all currently valid models.
</p>
<p>Argument <code>anisRange</code> expects a matrix $M$ such that
</p>
<p style="text-align: center;"><code class="reqn">
h^2 = (\mathbf{x}_i-\mathbf{x}_j)\cdot M^{-1}\cdot (\mathbf{x}_i-\mathbf{x}_j)^t
</code>
</p>

<p>is the (square of) the lag distance to be fed into the correlation function.
</p>


<h3>Value</h3>

<p>an object of class &quot;gmCgram&quot; containing the linear model of corregionalization
of the nugget and the structure given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels") # shortcut for all model constants
v1 = setCgram(type=vg.Gau, sill=diag(2), anisRanges = 3*diag(c(3,1)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(2), anisRanges = 0.5*diag(2))
vm = v1+v2
plot(vm)
</code></pre>

<hr>
<h2 id='setGridOrder'>Set or get the ordering of a grid</h2><span id='topic+setGridOrder'></span><span id='topic+getGridOrder'></span><span id='topic+setGridOrder_sp'></span><span id='topic+setGridOrder_array'></span><span id='topic+gridOrder_sp'></span><span id='topic+gridOrder_gstat'></span><span id='topic+gridOrder_array'></span><span id='topic+gridOrder_GSLib'></span>

<h3>Description</h3>

<p>Specify or retrieve the ordering in which a grid is stored in a vector (or matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGridOrder(x, refpoint, cycle)

setGridOrder_sp(x, G = 2)

setGridOrder_array(x, G = 2)

gridOrder_sp(G = 2)

gridOrder_gstat(G = 2)

gridOrder_array(G = 2)

gridOrder_GSLib(G = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGridOrder_+3A_x">x</code></td>
<td>
<p>a data container for the elements of the grid; the grid order is stored as an attribute to it</p>
</td></tr>
<tr><td><code id="setGridOrder_+3A_refpoint">refpoint</code></td>
<td>
<p>a string specifying which point of the grid corresponds
to the first element of <code>x</code>; see below</p>
</td></tr>
<tr><td><code id="setGridOrder_+3A_cycle">cycle</code></td>
<td>
<p>a permutation of the integers <code>1:G</code> (see below)</p>
</td></tr>
<tr><td><code id="setGridOrder_+3A_g">G</code></td>
<td>
<p>number of geographic dimensions of the setting, typically <code>G=2</code> or <code>G=3</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A &quot;gridOrder&quot; attribute is a list consisting of two named elements:
</p>

<dl>
<dt>refpoint</dt><dd><p>one of  &quot;topleft&quot;, &quot;bottomleft&quot;, &quot;topright&quot; or &quot;bottomright&quot; in 2D, or
also of &quot;topleftsurf&quot;, &quot;bottomleftsurf&quot;, &quot;toprightsurf&quot;, &quot;bottomrightsurf&quot;, &quot;topleftdeep&quot;,&quot;bottomleftdeep&quot;,
&quot;toprightdeep&quot; or &quot;bottomrightdeep&quot; in 3D (&quot;deep&quot; is accessory, i.e.  &quot;topleft&quot;== &quot;topleftdeep&quot;),
indicating the location on the grid of the first point of the object <code>x</code></p>
</dd>
<dt>cycle</dt><dd><p>a permutation of <code>1:G</code> indicating in which order run the dymensions, from faster to slower</p>
</dd>
</dl>

<p>Thus, a conventional ordering of a (nX*nY)-element vector into a matrix to plot with <code><a href="graphics.html#topic+image">graphics::image()</a></code>
corresponds to an <code>refpoint="bottomleft"</code> and <code>cycle=1:2</code>, i.e. start with the lower left corner
and run first by rows (eastwards), then by columns (northwards). This  is constructed by
<code>gridOrder_array(G)</code>, and can be directly set to an object <code>x</code> by <code>setGridOrder_array(x,G)</code>;
<code>gridOrder_GSLib</code> is an alias for <code>gridOrder_array</code>.
</p>
<p>The grids from package &quot;sp&quot; (and many other in R), on the contrary follow the convention
<code>refpoint="topleft"</code> and <code>cycle=1:2</code>,  i.e. start with the upper left corner
and run first by rows (eastwards), then by columns (<strong>southwards</strong>).  This  is constructed by
<code>gridOrder_sp(G)</code>, and can be directly set to an object <code>x</code> by <code>setGridOrder_sp(x,G)</code>; <code>gridOrder_gstat</code>
is an alias for <code>gridOrder_sp</code>.
</p>


<h3>Value</h3>

<p><code>setGridOrder(x,...)</code> returns the object <code>x</code> with the grid order description attached
as an attribute &quot;gridOrder&quot;; <code>getGridOrder(x)</code> retrieves this attribute and returns it.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>setGridOrder_sp</code>: Set or get the ordering of a grid
</p>
</li>
<li> <p><code>setGridOrder_array</code>: Set or get the ordering of a grid
</p>
</li>
<li> <p><code>gridOrder_sp</code>: Set or get the ordering of a grid
</p>
</li>
<li> <p><code>gridOrder_gstat</code>: Set or get the ordering of a grid
</p>
</li>
<li> <p><code>gridOrder_array</code>: Set or get the ordering of a grid
</p>
</li>
<li> <p><code>gridOrder_GSLib</code>: Set or get the ordering of a grid
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+sortDataInGrid">sortDataInGrid()</a></code> for ways of reordering a grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gt = sp::GridTopology(cellcentre.offset=c(1,11), cellsize=c(1,1), cells.dim=c(5,3))
sp::coordinates(sp::SpatialGrid(grid=gt))
gridOrder_sp(2)
</code></pre>

<hr>
<h2 id='setMask'>Set a mask on an object</h2><span id='topic+setMask'></span><span id='topic+setMask.default'></span><span id='topic+setMask.data.frame'></span><span id='topic+setMask.DataFrameStack'></span><span id='topic+setMask.SpatialGrid'></span><span id='topic+setMask.GridTopology'></span><span id='topic+setMask.SpatialPoints'></span>

<h3>Description</h3>

<p>Set a mask on an object See <code><a href="#topic+constructMask">constructMask()</a></code> for examples on how to construct masks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMask(x, ...)

## Default S3 method:
setMask(x, mask, coordinates = 1:2, ...)

## S3 method for class 'data.frame'
setMask(x, mask, coordinates = 1:2, ...)

## S3 method for class 'DataFrameStack'
setMask(x, mask, coordinates = attr(x, "coordinates"), ...)

## S3 method for class 'SpatialGrid'
setMask(x, mask, ...)

## S3 method for class 'GridTopology'
setMask(x, mask, ...)

## S3 method for class 'SpatialPoints'
setMask(x, mask, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMask_+3A_x">x</code></td>
<td>
<p>an object to mask (for set) or masked (for get)</p>
</td></tr>
<tr><td><code id="setMask_+3A_...">...</code></td>
<td>
<p>extra arguments for generic compatibility</p>
</td></tr>
<tr><td><code id="setMask_+3A_mask">mask</code></td>
<td>
<p>the mask to impose on <code>x</code></p>
</td></tr>
<tr><td><code id="setMask_+3A_coordinates">coordinates</code></td>
<td>
<p>for some of the methods, it is important to specify the names or indices
of the columns containing the geographic coordinates (only <code>setMask.data.frame</code>) or else
to specify the matrix of spatial coordinates (all <code>setMask</code> methods including it)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object <code>x</code> appropriately masked (for the setter methods).
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Set a mask on an object
</p>
</li>
<li> <p><code>data.frame</code>: Set a mask on a data.frame object
</p>
</li>
<li> <p><code>DataFrameStack</code>: Set a mask on a DataFrameStack object
</p>
</li>
<li> <p><code>SpatialGrid</code>: Set a mask on a SpatialGrid object
</p>
</li>
<li> <p><code>GridTopology</code>: Set a mask on a GridTopology object
</p>
</li>
<li> <p><code>SpatialPoints</code>: Set a mask on a SpatialPoints object
</p>
</li></ul>


<h3>See Also</h3>

<p>Other masking functions: 
<code><a href="#topic+constructMask">constructMask</a>()</code>,
<code><a href="#topic+getMask">getMask</a>()</code>,
<code><a href="#topic+print.mask">print.mask</a>()</code>,
<code><a href="#topic+unmask">unmask</a>()</code>
</p>

<hr>
<h2 id='sortDataInGrid'>Reorder data in a grid</h2><span id='topic+sortDataInGrid'></span>

<h3>Description</h3>

<p>Reorder the data in a compact grid, changing between ordering specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortDataInGrid(
  x,
  grid = attr(x, "grid"),
  orderIn = attr(x, "gridOrder"),
  orderOut = list(refpoint = "bottomleft", cycle = 1:2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortDataInGrid_+3A_x">x</code></td>
<td>
<p>gridded data</p>
</td></tr>
<tr><td><code id="sortDataInGrid_+3A_grid">grid</code></td>
<td>
<p>grid topology underlying</p>
</td></tr>
<tr><td><code id="sortDataInGrid_+3A_orderin">orderIn</code></td>
<td>
<p>current ordering description (see <code><a href="#topic+setGridOrder">setGridOrder()</a></code>)</p>
</td></tr>
<tr><td><code id="sortDataInGrid_+3A_orderout">orderOut</code></td>
<td>
<p>desired output ordering description (see <code><a href="#topic+setGridOrder">setGridOrder()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data from <code>x</code> (typically a matrix), but reordered as <code>orderOut</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setGridOrder">setGridOrder()</a></code> for ways of specifying the grid ordering
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getTellus(cleanup=TRUE, TI=TRUE)
load("Tellus_TI.RData")
coords = as.matrix(Tellus_TI[,1:2])
compo = compositions::acomp(Tellus_TI[,3:7])
dt = spatialGridAcomp(coords=coords, compo=compo)
image_cokriged(dt, ivar="MgO", breaks = NULL) 
x = sort(unique(coords[,1]))
y = sort(unique(coords[,2]))
x0 = c(min(x), min(y))
Ax = c(mean(diff(x)), mean(diff(y)))
n = c(length(x), length(y))
gr = sp::GridTopology(cellcentre.offset=x0, cellsize=Ax, cells.dim=n)
dt0 = sortDataInGrid(Tellus_TI, grid=gr, orderIn=gridOrder_array(2), 
                    orderOut=list(refpoint="bottomright", cycle=2:1))
coords = as.matrix(dt0[,1:2])
compo = compositions::acomp(dt0[,3:7])
spatialGridAcomp(coords=coords, compo=compo)

## End(Not run)
</code></pre>

<hr>
<h2 id='spatialDecorrelation'>Compute diagonalisation measures</h2><span id='topic+spatialDecorrelation'></span><span id='topic+spatialDecorrelation.gstatVariogram'></span><span id='topic+spatialDecorrelation.logratioVariogram'></span><span id='topic+spatialDecorrelation.gmEVario'></span>

<h3>Description</h3>

<p>Compute one or more diagonalisation measures out of an empirical multivariate variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialDecorrelation(vgemp, ...)

## S3 method for class 'gstatVariogram'
spatialDecorrelation(
  vgemp,
  vgemp0 = NULL,
  method = "add",
  quadratic = method[1] != "rdd",
  ...
)

## S3 method for class 'logratioVariogram'
spatialDecorrelation(vgemp, vgemp0 = NULL, method = "add", ...)

## S3 method for class 'gmEVario'
spatialDecorrelation(vgemp, vgemp0 = NULL, method = "add", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialDecorrelation_+3A_vgemp">vgemp</code></td>
<td>
<p>the empirical variogram to qualify</p>
</td></tr>
<tr><td><code id="spatialDecorrelation_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="spatialDecorrelation_+3A_vgemp0">vgemp0</code></td>
<td>
<p>optionally, a reference variogram (see below; necessary for <code>method="sde"</code>)</p>
</td></tr>
<tr><td><code id="spatialDecorrelation_+3A_method">method</code></td>
<td>
<p>which quantities are desired? one or more of c(&quot;rdd&quot;, &quot;add&quot;, &quot;sde&quot;)</p>
</td></tr>
<tr><td><code id="spatialDecorrelation_+3A_quadratic">quadratic</code></td>
<td>
<p>should the quantities be computed for a variogram or for its square? see below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three measures provided are
</p>

<dl>
<dt>absolute deviation from diagonality (&quot;add&quot;)</dt><dd><p>defined as the sum of all off-diagonal elements
of the variogram, possibly squared ($p=2$ if <code>quadratic=TRUE</code> the default; otherwise $p=1$)</p>
</dd></dl>

<p style="text-align: center;"><code class="reqn">
\zeta(h)=\sum_{k=1}^n\sum_{j\neq k}^n \gamma_{k,j}^p(h)
</code>
</p>


<dl>
<dt>relative deviation from diagonality (&quot;rdd&quot;)</dt><dd><p>comparing the absolute sum of off-diagonal elements
with the sum of the diagonal elements of the variogram, each possibly squared ($p=2$ if <code>quadratic=TRUE</code>;
otherwise $p=1$ the default)</p>
</dd></dl>

<p style="text-align: center;"><code class="reqn">
\tau(h)=\frac{\sum_{k=1}^n\sum_{j \neq k}^n |\gamma_{k,j}(h)|^p}{\sum_{k=1}^n|\gamma_{k,k}(h)|^p}
</code>
</p>


<dl>
<dt>spatial diagonalisation efficiency (&quot;sde&quot;)</dt><dd><p>is the only one requiring <code>vgemp0</code>, because it compares
an initial state with a diagonalised state of the variogram system</p>
</dd></dl>

<p style="text-align: center;"><code class="reqn">
\kappa(h)=1-
\frac{\sum_{k=1}^n\sum_{j \neq k}^n |\gamma_{k,j}(h)|^p}{\sum_{k=1}^n\sum_{j \neq k}^n |\gamma_{(0)k,j}(h)|^p }
</code>
</p>

<p>The value of $p$ is controlled by the first value of <code>method</code>. That is, the results with <code>method=c("rdd", "add")</code>
are not the same as those obtained with <code>method=c("add", "rdd")</code>, as in the first case $p=1$ and in the second case $p=2$.
</p>


<h3>Value</h3>

<p>an object of a similar nature to <code>vgemp</code>, but where the desired quantities are
reported for each lag. This can then be plotted or averages be computed.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>gstatVariogram</code>: Compute diagonalisation measures
</p>
</li>
<li> <p><code>logratioVariogram</code>: Compute diagonalisation measures
</p>
</li>
<li> <p><code>gmEVario</code>: Compute diagonalisation measures
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[, 1:2]
Z = jura.pred[,-(1:6)]
gm1 = make.gmCompositionalGaussianSpatialModel(data=Z, coords=X, V="alr")
vg1 = variogram(as.gstat(gm1)) 
(r1 = spatialDecorrelation(vg1, method=c("add", "rdd")))
plot(r1)
mean(r1)
require("compositions")
pc = princomp(acomp(Z))
v = pc$loadings
colnames(v)=paste("pc", 1:ncol(v), sep="")
gm2 = make.gmCompositionalGaussianSpatialModel(data=Z, coords=X, V=v, prefix="pc")
vg2 = variogram(as.gstat(gm2)) 
(r2 = spatialDecorrelation(vg2, method=c("add", "rdd")))
plot(r2)
mean(r2)
(r21 = spatialDecorrelation(vg2, vg1, method="sde") )
plot(r21)
mean(r21)
</code></pre>

<hr>
<h2 id='spatialGridAcomp'>Construct a regionalized composition / reorder compositional simulations</h2><span id='topic+spatialGridAcomp'></span>

<h3>Description</h3>

<p>Connect some coordinates to a composition (of hard data, of predictions
or of simulations); currently, the coordinates
are stored in an attribute and the dataset is given a complex S3 class.
This functionality <strong>will</strong> change in the future, to make use of package
&quot;sp&quot; classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialGridAcomp(coords, compo, dimcomp = 2, dimsim = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialGridAcomp_+3A_coords">coords</code></td>
<td>
<p>coordinates of the locations</p>
</td></tr>
<tr><td><code id="spatialGridAcomp_+3A_compo">compo</code></td>
<td>
<p>(observed or predicted) compositional data set; or else array of
simulated compositions</p>
</td></tr>
<tr><td><code id="spatialGridAcomp_+3A_dimcomp">dimcomp</code></td>
<td>
<p>which of the dimensions of <code>compo</code> does correspond to the
parts of the compositon?</p>
</td></tr>
<tr><td><code id="spatialGridAcomp_+3A_dimsim">dimsim</code></td>
<td>
<p>if <code>compo</code> contains simulations, which of its dimensions does
run across the realisations? leave it as NA if <code>compo</code> has observations or predictions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (potentially transposed/aperm-ed) matrix of class  c(&quot;spatialGridAcomp&quot;,&quot;acomp&quot;)
with the coordinates in an extra attribute &quot;coords&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image_cokriged.spatialGridAcomp">image_cokriged.spatialGridAcomp()</a></code> for an example; <code><a href="#topic+gsi.gstatCokriging2compo">gsi.gstatCokriging2compo()</a></code> to
restructure the output from <code><a href="gstat.html#topic+predict.gstat">gstat::predict.gstat()</a></code> confortably
</p>

<hr>
<h2 id='spatialGridRmult'>Construct a regionalized multivariate data</h2><span id='topic+spatialGridRmult'></span>

<h3>Description</h3>

<p>Connect some coordinates to a multivariate data set (of hard data, of predictions
or of simulations); currently, the coordinates
are stored in an attribute and the dataset is given a complex S3 class.
This functionality <strong>will</strong> change in the future, to make use of package
&quot;sp&quot; classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialGridRmult(coords, data, dimcomp = 2, dimsim = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialGridRmult_+3A_coords">coords</code></td>
<td>
<p>coordinates of the locations</p>
</td></tr>
<tr><td><code id="spatialGridRmult_+3A_data">data</code></td>
<td>
<p>(observed or predicted) rmult or matrix data set; or else array of
simulated rmult /real-valued multivariate data</p>
</td></tr>
<tr><td><code id="spatialGridRmult_+3A_dimcomp">dimcomp</code></td>
<td>
<p>which of the dimensions of <code>data</code> does correspond to the
variables?</p>
</td></tr>
<tr><td><code id="spatialGridRmult_+3A_dimsim">dimsim</code></td>
<td>
<p>if <code>data</code> contains simulations, which of its dimensions does
run across the realisations? leave it as NA if <code>data</code> has observations or predictions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (potentially transposed/aperm-ed) matrix of class  c(&quot;spatialGridAcomp&quot;,&quot;acomp&quot;)
with the coordinates in an extra attribute &quot;coords&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+image_cokriged.spatialGridRmult">image_cokriged.spatialGridRmult()</a></code> for an example; <code><a href="#topic+gsi.gstatCokriging2rmult">gsi.gstatCokriging2rmult()</a></code> to
restructure the output from <code><a href="gstat.html#topic+predict.gstat">gstat::predict.gstat()</a></code> confortably
</p>

<hr>
<h2 id='spectralcolors'>Spectral colors palette
based on the RColorBrewer::brewer.pal(11,&quot;Spectral&quot;)</h2><span id='topic+spectralcolors'></span>

<h3>Description</h3>

<p>Spectral colors palette
based on the RColorBrewer::brewer.pal(11,&quot;Spectral&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralcolors(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralcolors_+3A_n">n</code></td>
<td>
<p>number of colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a palette, i.e. a list of colors, from dark blue to dark red over pale yellow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(cls=spectralcolors(20))
</code></pre>

<hr>
<h2 id='sphTrans'>Spherifying transform
Compute a transformation that spherifies a certain data set</h2><span id='topic+sphTrans'></span><span id='topic+sphTrans.default'></span>

<h3>Description</h3>

<p>Spherifying transform
Compute a transformation that spherifies a certain data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphTrans(Y, ...)

## Default S3 method:
sphTrans(Y, weights = NULL, p = 1:ncol(Y), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphTrans_+3A_y">Y</code></td>
<td>
<p>data set defining the spherifization</p>
</td></tr>
<tr><td><code id="sphTrans_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="sphTrans_+3A_weights">weights</code></td>
<td>
<p>weights to incorporate in the compuations, length=nrow(Y)</p>
</td></tr>
<tr><td><code id="sphTrans_+3A_p">p</code></td>
<td>
<p>dimensions to be considered structural (useful for filtering noise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function with arguments <code>(x, inv=FALSE)</code>, where <code>x</code> will be the
data to apply the transformation to, and <code>inv=FALSE</code> will indicate if the direct
or the inverse transformation is desired.
This function applied to the same data returns a translated, rotated and scaled, so that
the new scores are centered, have variance 1, and no correlation.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: Spherifying transform
</p>
</li></ul>


<h3>Author(s)</h3>

<p>K. Gerald van den Boogaart, Raimon Tolosana-Delgado
</p>


<h3>See Also</h3>

<p>ana, anaBackward, sphTrans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(compositions)
data("jura", package="gstat")
Y = acomp(jura.pred[,c(10,12,13)])
oldpar = par(mfrow = c(1,1))
plot(Y)
sph = sphTrans(Y)
class(sph)
z = sph(Y)
plot(z)
par(oldpar)
cor(cbind(z, ilr(Y)))
colMeans(cbind(z, ilr(Y)))
</code></pre>

<hr>
<h2 id='stackDim'>Get/set name/index of (non)stacking dimensions</h2><span id='topic+stackDim'></span><span id='topic+stackDim.DataFrameStack'></span><span id='topic+noStackDim'></span><span id='topic+noStackDim.default'></span><span id='topic+stackDim+3C-'></span><span id='topic+stackDim+3C-.default'></span>

<h3>Description</h3>

<p>Return (or set) the name or index of either the stacking dimension, or else of the
non-stacking dimension (typically, the dimension runing through the variables)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackDim(x, ...)

## S3 method for class 'DataFrameStack'
stackDim(x, ...)

noStackDim(x, ...)

## Default S3 method:
noStackDim(x, ...)

stackDim(x) &lt;- value

## Default S3 replacement method:
stackDim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackDim_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> object, (only for <code>stackDim</code> it can also be a <code>Spatial</code>
object which <code>data</code> slot is a <code>DataFrameStack</code>)</p>
</td></tr>
<tr><td><code id="stackDim_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="stackDim_+3A_value">value</code></td>
<td>
<p>the name or the index to be considered as stacking dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the index or the name of the asked dimension.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stackDim.DataFrameStack</code>: Get/set name/index of (non)stacking dimensions
</p>
</li>
<li> <p><code>noStackDim</code>: Get/set name/index of (non)stacking dimensions
</p>
</li>
<li> <p><code>noStackDim.default</code>: Get/set name/index of (non)stacking dimensions
</p>
</li>
<li> <p><code>stackDim&lt;-</code>: Get/set name/index of (non)stacking dimensions
</p>
</li>
<li> <p><code>stackDim&lt;-.default</code>: Get/set name/index of (non)stacking dimensions
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>ar = array(1:30, dim = c(5,2,3), dimnames=list(obs=1:5, vars=c("A","B"), rep=1:3))
dfs = DataFrameStack(ar, stackDim="rep")
dfs
stackDim(dfs)
noStackDim(dfs)
getStackElement(dfs, 1)
stackDim(dfs) &lt;- "vars"
getStackElement(dfs, 1)
</code></pre>

<hr>
<h2 id='stackDim+2CSpatial-method'>Get name/index of the stacking dimension of a Spatial object</h2><span id='topic+stackDim+2CSpatial-method'></span>

<h3>Description</h3>

<p>Get name/index of the stacking dimension of a Spatial object which
data slot is of class <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Spatial'
stackDim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackDim+2B2CSpatial-method_+3A_x">x</code></td>
<td>
<p>a <code>Spatial</code> object which <code>data</code> slot is a <code>DataFrameStack</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>see <code><a href="#topic+stackDim">stackDim()</a></code> for details
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stackDim">stackDim()</a></code>
</p>

<hr>
<h2 id='swarmPlot'>Plot a swarm of calculated output through a DataFrameStack</h2><span id='topic+swarmPlot'></span>

<h3>Description</h3>

<p>Take a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> and apply a certain plotting function to each elements of the stack.
The result (typically a curve per each stack element), may then be plotted all together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swarmPlot(
  X,
  MARGIN = stackDim(X),
  PLOTFUN,
  ...,
  .plotargs = list(type = "l"),
  .parallelBackend = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swarmPlot_+3A_x">X</code></td>
<td>
<p>a <code><a href="#topic+DataFrameStack">DataFrameStack()</a></code> or anaologous object</p>
</td></tr>
<tr><td><code id="swarmPlot_+3A_margin">MARGIN</code></td>
<td>
<p>which dimension defines the stack? it has a good default! change only if you
know what you do</p>
</td></tr>
<tr><td><code id="swarmPlot_+3A_plotfun">PLOTFUN</code></td>
<td>
<p>the elemental calculating function; this must take as input one element
of the stack and return as output the (x,y)-coordinates of the calculated curve for that
element, in a list of two elements</p>
</td></tr>
<tr><td><code id="swarmPlot_+3A_...">...</code></td>
<td>
<p>further parameters to <code>PLOTFUN</code></p>
</td></tr>
<tr><td><code id="swarmPlot_+3A_.plotargs">.plotargs</code></td>
<td>
<p>either a logical, or else a list of graphical arguments to pass
to <code><a href="#topic+plot.swarmPlot">plot.swarmPlot()</a></code>; if <code>.plotargs=FALSE</code> no plot is produced; if <code>.plotargs=TRUE</code>
a plot with default values is produced;</p>
</td></tr>
<tr><td><code id="swarmPlot_+3A_.parallelbackend">.parallelBackend</code></td>
<td>
<p>NA or a parallelization strategy; currently unstable for certain
operations and platforms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, this function returns a list of the evaluation of <code>PLOTFUN</code> on
each element of the stack. If <code>.plotargs</code> other than <code>FALSE</code>, then the function calls
<code><a href="#topic+plot.swarmPlot">plot.swarmPlot()</a></code> to produce a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dm = list(point=1:100, var=LETTERS[1:2], rep=paste("r",1:5, sep=""))
ar = array(rnorm(1000), dim=c(100,2,5), dimnames = dm)
dfs = DataFrameStack(ar, stackDim="rep")
swarmPlot(dfs, PLOTFUN=function(x) density(x[,1]))
</code></pre>

<hr>
<h2 id='swath'>Swath plots</h2><span id='topic+swath'></span><span id='topic+swath.default'></span><span id='topic+swath.acomp'></span><span id='topic+swath.ccomp'></span><span id='topic+swath.rcomp'></span>

<h3>Description</h3>

<p>Plots of data vs. one spatial coordinate, with local average spline curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swath(data, ...)

## Default S3 method:
swath(
  data,
  loc,
  pch = ".",
  withLoess = TRUE,
  commonScale = TRUE,
  xlab = deparse(substitute(loc)),
  ...,
  mfrow
)

## S3 method for class 'acomp'
swath(
  data,
  loc,
  pch = ".",
  withLoess = TRUE,
  commonScale = NA,
  xlab = deparse(substitute(loc)),
  ...
)

## S3 method for class 'ccomp'
swath(
  data,
  loc,
  pch = ".",
  withLoess = TRUE,
  commonScale = NA,
  xlab = deparse(substitute(loc)),
  ...
)

## S3 method for class 'rcomp'
swath(
  data,
  loc,
  pch = ".",
  withLoess = TRUE,
  commonScale = NA,
  xlab = deparse(substitute(loc)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swath_+3A_data">data</code></td>
<td>
<p>data to be represented, compositional class, data.frame, or
spatial data object (in which case, <code>loc</code> is a formula!)</p>
</td></tr>
<tr><td><code id="swath_+3A_...">...</code></td>
<td>
<p>further arguments to panel plots</p>
</td></tr>
<tr><td><code id="swath_+3A_loc">loc</code></td>
<td>
<p>a numeric vector with the values for one coordinate</p>
</td></tr>
<tr><td><code id="swath_+3A_pch">pch</code></td>
<td>
<p>symbol to be used for the individual points, defaults to &quot;.&quot;</p>
</td></tr>
<tr><td><code id="swath_+3A_withloess">withLoess</code></td>
<td>
<p>either logical (should a loess line be added?) or a list
of arguments to DescTools::lines.loess</p>
</td></tr>
<tr><td><code id="swath_+3A_commonscale">commonScale</code></td>
<td>
<p>logical or NA: should all plots share the same vertical
range? FALSE=no, TRUE=yes (default), for
compositional data sets, the value NA (=all plots within a row) is also
permitted and is actually the default</p>
</td></tr>
<tr><td><code id="swath_+3A_xlab">xlab</code></td>
<td>
<p>label for the common x axis (defaults to a deparsed version
of loc)</p>
</td></tr>
<tr><td><code id="swath_+3A_mfrow">mfrow</code></td>
<td>
<p>distribution of the several plots; it has a good internal default
(not used for compositional
classes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as the function is primarily called to produce a plot
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>default</code>: swath plot default method
</p>
</li>
<li> <p><code>acomp</code>: Swath plots for acomp objects
</p>
</li>
<li> <p><code>ccomp</code>: Swath plots for ccomp objects
</p>
</li>
<li> <p><code>rcomp</code>: Swath plots for rcomp objects
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Windarling")
library("sp")
compo = compositions::acomp(Windarling[,c("Fe","Al2O3","SiO2", "Mn", "P")])
Northing = Windarling$Northing
swath(compo, Northing)
wind.spdf = sp::SpatialPointsDataFrame(sp::SpatialPoints(Windarling[,6:7]), 
     data=compo)
swath(wind.spdf, loc=Northing)

</code></pre>

<hr>
<h2 id='TurningBands'>Create a parameter set specifying a turning bands simulation algorithm</h2><span id='topic+TurningBands'></span>

<h3>Description</h3>

<p>Create a parameter set describing a turning bands algorithm to two-point simulation,
mostly for covariance or variogram-based gaussian random fields.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TurningBands(nsim = 1, nBands = 1000, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TurningBands_+3A_nsim">nsim</code></td>
<td>
<p>number of realisations desired</p>
</td></tr>
<tr><td><code id="TurningBands_+3A_nbands">nBands</code></td>
<td>
<p>number of bands desired for the decomposition of the 2D or 3D space in individual signals</p>
</td></tr>
<tr><td><code id="TurningBands_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number generator should be
initialized, see <code>?simulate</code> in base &quot;stats&quot; package</p>
</td></tr>
<tr><td><code id="TurningBands_+3A_...">...</code></td>
<td>
<p>further parameters, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an S3-list of class &quot;gmTurningBands&quot; containing the few elements given as arguments
to the function. This is just a compact way to provide further functions such as <a href="#topic+predict_gmSpatialModel">predict_gmSpatialModel</a>
with appropriate triggers for choosing a prediction method or another, in this case for triggering
turning bands simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(tbs_local = TurningBands(nsim=100, nBands=300))
## then run predict(..., pars=tbs_local)
</code></pre>

<hr>
<h2 id='unmask'>Unmask a masked object</h2><span id='topic+unmask'></span><span id='topic+unmask.data.frame'></span><span id='topic+unmask.DataFrameStack'></span><span id='topic+unmask.SpatialPixels'></span><span id='topic+unmask.SpatialPoints'></span>

<h3>Description</h3>

<p>Unmask a masked object, i.e. recover the original grid and extend potential
data containers associated to it with NAs. See examples in <code><a href="#topic+constructMask">constructMask()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmask(x, ...)

## S3 method for class 'data.frame'
unmask(
  x,
  mask = attr(x, "mask"),
  fullgrid = attr(mask, "fullgrid"),
  forceCheck = is(fullgrid, "GridTopology"),
  ...
)

## S3 method for class 'DataFrameStack'
unmask(
  x,
  mask = attr(x, "mask"),
  fullgrid = attr(mask, "fullgrid"),
  forceCheck = is(fullgrid, "GridTopology"),
  ...
)

## S3 method for class 'SpatialPixels'
unmask(
  x,
  mask = NULL,
  fullgrid = attr(mask, "fullgrid"),
  forceCheck = FALSE,
  ...
)

## S3 method for class 'SpatialPoints'
unmask(
  x,
  mask = attr(x@data, "mask"),
  fullgrid = attr(mask, "fullgrid"),
  forceCheck = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmask_+3A_x">x</code></td>
<td>
<p>a masked object</p>
</td></tr>
<tr><td><code id="unmask_+3A_...">...</code></td>
<td>
<p>arguments for generic functionality</p>
</td></tr>
<tr><td><code id="unmask_+3A_mask">mask</code></td>
<td>
<p>the mask; typically has good defaults</p>
</td></tr>
<tr><td><code id="unmask_+3A_fullgrid">fullgrid</code></td>
<td>
<p>the full grid; typically has good defaults</p>
</td></tr>
<tr><td><code id="unmask_+3A_forcecheck">forceCheck</code></td>
<td>
<p>if <code>fullgrid</code> is provided, should the coordinates provided
in <code>x</code> and in <code>fullgrid</code> be cross-checked to ensure that they are given in
compatible orders? See <code><a href="#topic+sortDataInGrid">sortDataInGrid()</a></code> and <code><a href="#topic+setGridOrder">setGridOrder()</a></code> for controlling
the ordering of vectors and grids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original grid data and extend potential
data containers associated to it with NAs. See examples in <code><a href="#topic+constructMask">constructMask()</a></code>.
The nature of the output depends on the nature of <code>x</code>:
a &quot;data.frame&quot; produced a &quot;data.frame&quot;;
a &quot;unmask.DataFrameStack&quot; produces a &quot;unmask.DataFrameStack&quot;;
a &quot;SpatialPoints&quot; produces a &quot;SpatialPoints&quot;; and finally
a &quot;SpatialPixels&quot; produces either a &quot;SpatialPixels&quot; or a &quot;SpatialGrid&quot; (if it is full).
Note that only in the case that <code>is(x,"SpatialPixels")=TRUE</code> is <code>mask</code> required,
for the other methods all arguments have reasonable defaults.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>unmask</code>: Unmask a masked object
</p>
</li>
<li> <p><code>unmask.DataFrameStack</code>: Unmask a masked object
</p>
</li>
<li> <p><code>unmask.SpatialPixels</code>: Unmask a masked object
</p>
</li>
<li> <p><code>unmask.SpatialPoints</code>: Unmask a masked object
</p>
</li></ul>


<h3>See Also</h3>

<p>Other masking functions: 
<code><a href="#topic+constructMask">constructMask</a>()</code>,
<code><a href="#topic+getMask">getMask</a>()</code>,
<code><a href="#topic+print.mask">print.mask</a>()</code>,
<code><a href="#topic+setMask">setMask</a>()</code>
</p>

<hr>
<h2 id='validate'>Validate a spatial model</h2><span id='topic+validate'></span><span id='topic+validate.LeaveOneOut'></span><span id='topic+validate.NfoldCrossValidation'></span>

<h3>Description</h3>

<p>Validate a spatial model by predicting some values. Typically this will be a validation set,
or else some subset of the conditing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(object, strategy, ...)

## S3 method for class 'LeaveOneOut'
validate(object, strategy, ...)

## S3 method for class 'NfoldCrossValidation'
validate(object, strategy, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_object">object</code></td>
<td>
<p>spatial model object, typically of class <code><a href="gstat.html#topic+gstat">gstat::gstat()</a></code> or <a href="#topic+gmSpatialModel-class">gmSpatialModel</a></p>
</td></tr>
<tr><td><code id="validate_+3A_strategy">strategy</code></td>
<td>
<p>which strategy to follow for the validation? see functions in 'see also' below.</p>
</td></tr>
<tr><td><code id="validate_+3A_...">...</code></td>
<td>
<p>generic parameters, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of predictions (possibly with kriging variances and covariances, or equivalent
uncertainty measures) for each element of the validation set
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>LeaveOneOut</code>: Validate a spatial model
</p>
</li>
<li> <p><code>NfoldCrossValidation</code>: Validate a spatial model
</p>
</li></ul>


<h3>See Also</h3>

<p>Other validation functions: 
<code><a href="#topic+LeaveOneOut">LeaveOneOut</a></code>,
<code><a href="#topic+NfoldCrossValidation">NfoldCrossValidation</a></code>
</p>
<p>Other accuracy functions: 
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+mean.accuracy">mean.accuracy</a>()</code>,
<code><a href="#topic+plot.accuracy">plot.accuracy</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+xvErrorMeasures.default">xvErrorMeasures.default</a>()</code>,
<code><a href="#topic+xvErrorMeasures">xvErrorMeasures</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Windarling")
X = Windarling[,c("Easting","Northing")]
Z = compositions::acomp(Windarling[,c(9:12,16)])
gm = make.gmCompositionalGaussianSpatialModel(data=Z, coords=X)
vg = variogram(gm)
md = gstat::vgm(range=30, model="Sph", nugget=1, psill=1)
gs = fit_lmc(v=vg, g=gm, model=md) 
## Not run:  v1 = validate(gs, strategy=LeaveOneOut()) # quite slow 
vs2 = NfoldCrossValidation(nfolds=sample(1:10, nrow(X), replace=TRUE))
vs2
## Not run:  v2 = validate(gs, strategy=vs2) # quite slow 
</code></pre>

<hr>
<h2 id='variogramModelPlot'>Quick plotting of empirical and theoretical variograms
Quick and dirty plotting of empirical variograms/covariances with or without their models</h2><span id='topic+variogramModelPlot'></span><span id='topic+variogramModelPlot.gmEVario'></span>

<h3>Description</h3>

<p>Quick plotting of empirical and theoretical variograms
Quick and dirty plotting of empirical variograms/covariances with or without their models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogramModelPlot(vg, ...)

## S3 method for class 'gmEVario'
variogramModelPlot(
  vg,
  model = NULL,
  col = rev(rainbow(ndirections(vg))),
  commonAxis = FALSE,
  newfig = TRUE,
  closeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramModelPlot_+3A_vg">vg</code></td>
<td>
<p>empirical variogram or covariance function</p>
</td></tr>
<tr><td><code id="variogramModelPlot_+3A_...">...</code></td>
<td>
<p>further parameters to underlying plot or matplot functions</p>
</td></tr>
<tr><td><code id="variogramModelPlot_+3A_model">model</code></td>
<td>
<p>optional, theoretical variogram or covariance function</p>
</td></tr>
<tr><td><code id="variogramModelPlot_+3A_col">col</code></td>
<td>
<p>colors to use for the several directional variograms</p>
</td></tr>
<tr><td><code id="variogramModelPlot_+3A_commonaxis">commonAxis</code></td>
<td>
<p>boolean, should all plots in a row share the same vertical axis?</p>
</td></tr>
<tr><td><code id="variogramModelPlot_+3A_newfig">newfig</code></td>
<td>
<p>boolean, should a new figure be created? otherwise user should ensure the device space is appropriately managed</p>
</td></tr>
<tr><td><code id="variogramModelPlot_+3A_closeplot">closeplot</code></td>
<td>
<p>logical, should the plot be left open (FALSE) for further changes, or be frozen (TRUE)?
defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is primarily called for producing a plot. However, it
invisibly returns the graphical parameters active before the call
occurred. This is useful for constructing complex diagrams, by adding layers
of info. If you want to &quot;freeze&quot; your plot, embed your call in another
call to <code><a href="graphics.html#topic+par">par</a></code>, e.g. <code>par(variogramModelPlot(...))</code>; if you
want to leave the plot open for further changes give the extra argument <code>closeplot=FALSE</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>variogramModelPlot</code>: Quick plotting of empirical and theoretical variograms
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+logratioVariogram">logratioVariogram()</a></code>
</p>
<p>Other variogramModelPlot: 
<code><a href="#topic+variogramModelPlot.gstatVariogram">variogramModelPlot.gstatVariogram</a>()</code>,
<code><a href="#topic+variogramModelPlot.logratioVariogram">variogramModelPlot.logratioVariogram</a>()</code>
</p>
<p>Other gmEVario functions: 
<code><a href="#topic+as.gmEVario.gstatVariogram">as.gmEVario.gstatVariogram</a>()</code>,
<code><a href="#topic+gsi.EVario2D">gsi.EVario2D</a>()</code>,
<code><a href="#topic+gsi.EVario3D">gsi.EVario3D</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmEVario">plot.gmEVario</a>()</code>
</p>
<p>Other gmCgram functions: 
<code><a href="#topic++5B.gmCgram">[.gmCgram</a>()</code>,
<code><a href="#topic++5B+5B.gmCgram">[[.gmCgram</a>()</code>,
<code><a href="#topic+as.function.gmCgram">as.function.gmCgram</a>()</code>,
<code><a href="#topic+as.gmCgram.variogramModelList">as.gmCgram.variogramModelList</a>()</code>,
<code><a href="#topic+length.gmCgram">length.gmCgram</a>()</code>,
<code><a href="#topic+ndirections">ndirections</a>()</code>,
<code><a href="#topic+plot.gmCgram">plot.gmCgram</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utils::data("variogramModels")
v1 = setCgram(type=vg.Gau, sill=diag(3)+0.5, anisRanges = 5e-1*diag(c(3,0.5)))
v2 = setCgram(type=vg.Exp, sill=0.3*diag(3), anisRanges = 5e-2*diag(2))
vm = v1+v2
plot(vm, closeplot=TRUE)
library(gstat)
data("jura", package = "gstat")
X = as.matrix(jura.pred[,1:2])
Z = as.matrix(jura.pred[,c("Zn","Cd","Pb")])
vge = gsi.EVario2D(X,Z)
variogramModelPlot(vge, vm)


</code></pre>

<hr>
<h2 id='variogramModelPlot.gstatVariogram'>Quick plotting of empirical and theoretical variograms
Quick and dirty plotting of empirical variograms/covariances with or without their models</h2><span id='topic+variogramModelPlot.gstatVariogram'></span>

<h3>Description</h3>

<p>Quick plotting of empirical and theoretical variograms
Quick and dirty plotting of empirical variograms/covariances with or without their models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstatVariogram'
variogramModelPlot(
  vg,
  model = NULL,
  col = rev(rainbow(1 + length(unique(vg$dir.hor)))),
  commonAxis = FALSE,
  newfig = TRUE,
  closeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_vg">vg</code></td>
<td>
<p>empirical variogram or covariance function</p>
</td></tr>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_model">model</code></td>
<td>
<p>optional, theoretical variogram or covariance function</p>
</td></tr>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_col">col</code></td>
<td>
<p>colors to use for the several directional variograms</p>
</td></tr>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_commonaxis">commonAxis</code></td>
<td>
<p>boolean, should all plots in a row share the same vertical axis?</p>
</td></tr>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_newfig">newfig</code></td>
<td>
<p>boolean, should a new figure be created? otherwise user should ensure the device space is appropriately managed</p>
</td></tr>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_closeplot">closeplot</code></td>
<td>
<p>logical, should the plot be left open (FALSE) for further changes, or be frozen (TRUE)?
defaults to TRUE</p>
</td></tr>
<tr><td><code id="variogramModelPlot.gstatVariogram_+3A_...">...</code></td>
<td>
<p>further parameters to underlying plot or matplot functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is primarily called for producing a plot. However, it
invisibly returns the graphical parameters active before the call
occurred. This is useful for constructing complex diagrams, by giving
argument <code>closeplot=FALSE</code> and then adding layers
of information. If you want to &quot;freeze&quot; your plot, either give <code>closeplot=TRUE</code> or
embed your call in another call to <code><a href="graphics.html#topic+par">par</a></code>, e.g. <code>par(variogramModelPlot(...))</code>.
</p>


<h3>See Also</h3>

<p><code>gstat::plot.gstatVariogram()</code>
</p>
<p>Other variogramModelPlot: 
<code><a href="#topic+variogramModelPlot.logratioVariogram">variogramModelPlot.logratioVariogram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
X = jura.pred[,1:2]
Zc = jura.pred[,7:13]
gg = make.gmCompositionalGaussianSpatialModel(Zc, X, V="alr", formula = ~1)
vg = variogram(gg)
md = gstat::vgm(model="Sph", psill=1, nugget=1, range=1.5)
gg = fit_lmc(v=vg, g=gg, model=md)
variogramModelPlot(vg, model=gg)
</code></pre>

<hr>
<h2 id='variogramModelPlot.logratioVariogram'>Quick plotting of empirical and theoretical logratio variograms
Quick and dirty plotting of empirical logratio variograms with or without their models</h2><span id='topic+variogramModelPlot.logratioVariogram'></span>

<h3>Description</h3>

<p>Quick plotting of empirical and theoretical logratio variograms
Quick and dirty plotting of empirical logratio variograms with or without their models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logratioVariogram'
variogramModelPlot(vg, model = NULL, col = rev(rainbow(ndirections(vg))), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramModelPlot.logratioVariogram_+3A_vg">vg</code></td>
<td>
<p>empirical variogram or covariance function</p>
</td></tr>
<tr><td><code id="variogramModelPlot.logratioVariogram_+3A_model">model</code></td>
<td>
<p>optional, theoretical variogram or covariance function</p>
</td></tr>
<tr><td><code id="variogramModelPlot.logratioVariogram_+3A_col">col</code></td>
<td>
<p>colors to use for the several directional variograms</p>
</td></tr>
<tr><td><code id="variogramModelPlot.logratioVariogram_+3A_...">...</code></td>
<td>
<p>further parameters to <code>plot.logratioVariogramAnisotropy()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function is primarily called for producing a plot. However, it
invisibly returns the graphical parameters active before the call
occurred. This is useful for constructing complex diagrams, by adding layers
of info. If you want to &quot;freeze&quot; your plot, embed your call in another
call to <code><a href="graphics.html#topic+par">par</a></code>, e.g. <code>par(variogramModelPlot(...))</code>.
</p>


<h3>See Also</h3>

<p>Other variogramModelPlot: 
<code><a href="#topic+variogramModelPlot.gstatVariogram">variogramModelPlot.gstatVariogram</a>()</code>,
<code><a href="#topic+variogramModelPlot">variogramModelPlot</a>()</code>
</p>

<hr>
<h2 id='Windarling'>Ore composition of a bench at a mine in Windarling, West Australia.</h2><span id='topic+Windarling'></span>

<h3>Description</h3>

<p>A dataset containing the geochemical composition (and some extra variables)
of a grade control study of a mine bench at Windarling, West Australia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Windarling
</code></pre>


<h3>Format</h3>

<p>A data.frame with 1600 rows and 16 columns:
</p>

<dl>
<dt>Hole_id</dt><dd><p>ID of the observation</p>
</dd>
<dt>Sample.West</dt><dd><p>indicator for belonging to a subsample on the West sector</p>
</dd>
<dt>Sample.East</dt><dd><p>indicator for belonging to a subsample on the East sector</p>
</dd>
<dt>West</dt><dd><p>indicator for belonging to the Western wing of the bench</p>
</dd>
<dt>East</dt><dd><p>indicator for belonging to the Eastern wing of the bench</p>
</dd>
<dt>Easting</dt><dd><p>Easting (X) coordinate of the sample</p>
</dd>
<dt>Northing</dt><dd><p>Northing (Y) coordinate of the sample</p>
</dd>
<dt>Lithotype</dt><dd><p>factor, indicating material type of the sample, one of: basalt, goethite, magnetite, schist</p>
</dd>
<dt>Fe</dt><dd><p>percent of Iron in the sample</p>
</dd>
<dt>P</dt><dd><p>percent of Phosphorus in the sample</p>
</dd>
<dt>SiO2</dt><dd><p>percent of Silica in the sample</p>
</dd>
<dt>Al2O3</dt><dd><p>percent of Alumina in the sample</p>
</dd>
<dt>S</dt><dd><p>percent of Sulphur in the sample</p>
</dd>
<dt>Mn</dt><dd><p>percent of Magnanese in the sample</p>
</dd>
<dt>CL</dt><dd><p>percent of Chlorine in the sample</p>
</dd>
<dt>LOI</dt><dd><p>percent Loss-on-Ignition of the sample</p>
</dd>
</dl>



<h3>License</h3>

<p>CC BY-SA 4.0
</p>


<h3>Source</h3>

<p>Ward (2015) Compositions, logratios and
geostatistics: An application to iron ore. MSc Thesis
Edith Cowan University; <a href="https://ro.ecu.edu.au/theses/1581/">https://ro.ecu.edu.au/theses/1581/</a>
</p>

<hr>
<h2 id='write.GSLib'>Write a regionalized data set in GSLIB format</h2><span id='topic+write.GSLib'></span>

<h3>Description</h3>

<p>Write a regionalized data set in plain text GSLIB format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.GSLib(x, file, header = basename(file))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.GSLib_+3A_x">x</code></td>
<td>
<p>regionalized data set</p>
</td></tr>
<tr><td><code id="write.GSLib_+3A_file">file</code></td>
<td>
<p>filename</p>
</td></tr>
<tr><td><code id="write.GSLib_+3A_header">header</code></td>
<td>
<p>the first line of text for the file, defaults to filename</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The status of closing the file, see <code><a href="base.html#topic+close">close</a></code>
for details, although this is seldom problematic. This function is basically called
for its side-effect of writing a data set in the simplified Geo-EAS format that is
used in GSLIB.
</p>


<h3>See Also</h3>

<p><a href="http://www.gslib.com/gslib_help/format.html">http://www.gslib.com/gslib_help/format.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("jura", package="gstat")
## Not run: write.GSLib(jura.pred, file="jurapred.txt")
</code></pre>

<hr>
<h2 id='xvErrorMeasures'>Cross-validation errror measures</h2><span id='topic+xvErrorMeasures'></span><span id='topic+xvErrorMeasures.data.frame'></span><span id='topic+xvErrorMeasures.DataFrameStack'></span>

<h3>Description</h3>

<p>Compute one or more error measures from cross-validation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xvErrorMeasures(x, ...)

## S3 method for class 'data.frame'
xvErrorMeasures(
  x,
  observed = x$observed,
  output = "MSDR1",
  univariate = length(dim(observed)) == 0,
  ...
)

## S3 method for class 'DataFrameStack'
xvErrorMeasures(
  x,
  observed,
  output = "ME",
  univariate = length(dim(observed)) == 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvErrorMeasures_+3A_x">x</code></td>
<td>
<p>a dataset of predictions (if <code>x</code> is of class &quot;data.frame&quot;) or simulations
(if <code>x</code> is of class &quot;DataFrameStack&quot;)</p>
</td></tr>
<tr><td><code id="xvErrorMeasures_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
<tr><td><code id="xvErrorMeasures_+3A_observed">observed</code></td>
<td>
<p>a vector (if univariate) or a matrix/dataset of true values</p>
</td></tr>
<tr><td><code id="xvErrorMeasures_+3A_output">output</code></td>
<td>
<p>which output do you want? a vector of one or several of  c(&quot;ME&quot;,&quot;MSE&quot;,&quot;MSDR&quot;,&quot;MSDR1&quot;,&quot;MSDR2&quot;,&quot;Mahalanobis&quot;)</p>
</td></tr>
<tr><td><code id="xvErrorMeasures_+3A_univariate">univariate</code></td>
<td>
<p>logical control, typically you should not touch it</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;ME&quot; stands for <em>mean error</em> (average of the differences between true values and predicted values),
&quot;MSE&quot; stands for <em>mean square error</em> (average of the square differences between true values and predicted values),
and &quot;MSDR&quot; for <em>mean squared deviation ratio</em> (average of the square between true values and predicted values
each normalized by its kriging variance). These quantities are classically used in evaluating
output results of validation exercises of one single variable.
For multivariate cases, &quot;ME&quot; (a vector) and &quot;MSE&quot; (a scalar) work as well,
while two different definitions of a multivariate
mean squared deviation ratio can be given:
</p>

<ul>
<li><p> &quot;MSDR1&quot; is the average Mahalanobis square error (see <code><a href="#topic+accuracy">accuracy()</a></code> for explanations)
</p>
</li>
<li><p> &quot;MSDR2&quot; is the average univariate &quot;MSDR&quot; over all variables.
</p>
</li></ul>



<h3>Value</h3>

<p>If just some of c(&quot;ME&quot;,&quot;MSE&quot;,&quot;MSDR&quot;,&quot;MSDR1&quot;,&quot;MSDR2&quot;) are requested, the output is a named
vector with the desired quantities. If only &quot;Mahalanobis&quot; is requested, the output is a vector
of Mahalanobis square errors. If you mix up things and ask for &quot;Mahalanobis&quot; and some of
the quantities mentioned above, the result will be a named list with the requested quantities.
(NOTE: some options are not available for <code>x</code> a &quot;DataFrameStack&quot;)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>xvErrorMeasures</code>: Cross-validation errror measures
</p>
</li>
<li> <p><code>xvErrorMeasures.DataFrameStack</code>: Cross-validation errror measures
</p>
</li></ul>


<h3>See Also</h3>

<p>Other accuracy functions: 
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+mean.accuracy">mean.accuracy</a>()</code>,
<code><a href="#topic+plot.accuracy">plot.accuracy</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+xvErrorMeasures.default">xvErrorMeasures.default</a>()</code>
</p>

<hr>
<h2 id='xvErrorMeasures.default'>Cross-validation errror measures</h2><span id='topic+xvErrorMeasures.default'></span>

<h3>Description</h3>

<p>Compute one or more error measures from cross-validation output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
xvErrorMeasures(x, krigVar, observed, output = "MSDR1", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvErrorMeasures.default_+3A_x">x</code></td>
<td>
<p>a vector containing the predicted values</p>
</td></tr>
<tr><td><code id="xvErrorMeasures.default_+3A_krigvar">krigVar</code></td>
<td>
<p>a vector containing the kriging variances</p>
</td></tr>
<tr><td><code id="xvErrorMeasures.default_+3A_observed">observed</code></td>
<td>
<p>a vector containing the true values</p>
</td></tr>
<tr><td><code id="xvErrorMeasures.default_+3A_output">output</code></td>
<td>
<p>which output do you want? a vector of one or several of  c(&quot;ME&quot;,&quot;MSE&quot;,&quot;MSDR&quot;,&quot;Mahalanobis&quot;)</p>
</td></tr>
<tr><td><code id="xvErrorMeasures.default_+3A_...">...</code></td>
<td>
<p>extra arguments for generic functionality</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;ME&quot; stands for <em>mean error</em> (average of the differences between true values and predicted values),
&quot;MSE&quot; stands for <em>mean square error</em> (average of the square differences between true values and predicted values),
and &quot;MSDR&quot; for <em>mean squared deviation ratio</em> (average of the square between true values and predicted values
each normalized by its kriging variance). These quantities are classically used in evaluating
output results of validation exercises of one single variable.
For multivariate cases, see <code><a href="#topic+xvErrorMeasures.data.frame">xvErrorMeasures.data.frame()</a></code>.
</p>


<h3>Value</h3>

<p>If just some of c(&quot;ME&quot;,&quot;MSE&quot;,&quot;MSDR&quot;) are requested, the output is a named
vector with the desired quantities. If only &quot;Mahalanobis&quot; is requested, the output is a vector
of Mahalanobis square errors. If you mix up things and ask for &quot;Mahalanobis&quot; and some of
the quantities mentioned above, the result will be a named list with the requested quantities.
</p>


<h3>See Also</h3>

<p>Other accuracy functions: 
<code><a href="#topic+accuracy">accuracy</a>()</code>,
<code><a href="#topic+mean.accuracy">mean.accuracy</a>()</code>,
<code><a href="#topic+plot.accuracy">plot.accuracy</a>()</code>,
<code><a href="#topic+precision">precision</a>()</code>,
<code><a href="#topic+validate">validate</a>()</code>,
<code><a href="#topic+xvErrorMeasures">xvErrorMeasures</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
