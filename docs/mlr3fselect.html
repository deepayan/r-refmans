<!DOCTYPE html><html><head><title>Help for package mlr3fselect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlr3fselect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlr3fselect-package'><p>mlr3fselect: Feature Selection for 'mlr3'</p></a></li>
<li><a href='#ArchiveBatchFSelect'><p>Class for Logging Evaluated Feature Sets</p></a></li>
<li><a href='#auto_fselector'><p>Function for Automatic Feature Selection</p></a></li>
<li><a href='#AutoFSelector'><p>Class for Automatic Feature Selection</p></a></li>
<li><a href='#callback_batch_fselect'><p>Create Feature Selection Callback</p></a></li>
<li><a href='#CallbackBatchFSelect'><p>Create Feature Selection Callback</p></a></li>
<li><a href='#ContextBatchFSelect'><p>Evaluation Context</p></a></li>
<li><a href='#ensemble_fs_result'><p>Ensemble Feature Selection Result</p></a></li>
<li><a href='#ensemble_fselect'><p>Ensemble Feature Selection</p></a></li>
<li><a href='#extract_inner_fselect_archives'><p>Extract Inner Feature Selection Archives</p></a></li>
<li><a href='#extract_inner_fselect_results'><p>Extract Inner Feature Selection Results</p></a></li>
<li><a href='#fs'><p>Syntactic Sugar for FSelect Construction</p></a></li>
<li><a href='#fselect'><p>Function for Feature Selection</p></a></li>
<li><a href='#fselect_nested'><p>Function for Nested Resampling</p></a></li>
<li><a href='#FSelectInstanceBatchMultiCrit'><p>Class for Multi Criteria Feature Selection</p></a></li>
<li><a href='#FSelectInstanceBatchSingleCrit'><p>Class for Single Criterion Feature Selection</p></a></li>
<li><a href='#FSelector'><p>FSelector</p></a></li>
<li><a href='#FSelectorBatch'><p>Class for Batch Feature Selection Algorithms</p></a></li>
<li><a href='#FSelectorBatchFromOptimizerBatch'><p>FSelectorBatchFromOptimizerBatch</p></a></li>
<li><a href='#fsi'><p>Syntactic Sugar for Instance Construction</p></a></li>
<li><a href='#mlr_fselectors'><p>Dictionary of FSelectors</p></a></li>
<li><a href='#mlr_fselectors_design_points'><p>Feature Selection with Design Points</p></a></li>
<li><a href='#mlr_fselectors_exhaustive_search'><p>Feature Selection with Exhaustive Search</p></a></li>
<li><a href='#mlr_fselectors_genetic_search'><p>Feature Selection with Genetic Search</p></a></li>
<li><a href='#mlr_fselectors_random_search'><p>Feature Selection with Random Search</p></a></li>
<li><a href='#mlr_fselectors_rfe'><p>Feature Selection with Recursive Feature Elimination</p></a></li>
<li><a href='#mlr_fselectors_rfecv'><p>Feature Selection with Recursive Feature Elimination with Cross Validation</p></a></li>
<li><a href='#mlr_fselectors_sequential'><p>Feature Selection with Sequential Search</p></a></li>
<li><a href='#mlr_fselectors_shadow_variable_search'><p>Feature Selection with Shadow Variable Search</p></a></li>
<li><a href='#mlr3fselect_assertions'><p>Assertion for mlr3fselect objects</p></a></li>
<li><a href='#mlr3fselect.backup'><p>Backup Benchmark Result Callback</p></a></li>
<li><a href='#mlr3fselect.one_se_rule'><p>One Standard Error Rule Callback</p></a></li>
<li><a href='#mlr3fselect.svm_rfe'><p>SVM-RFE Callback</p></a></li>
<li><a href='#ObjectiveFSelect'><p>Class for Feature Selection Objective</p></a></li>
<li><a href='#ObjectiveFSelectBatch'><p>Class for Feature Selection Objective</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Feature Selection for 'mlr3'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Feature selection package of the 'mlr3' ecosystem. It selects
    the optimal feature set for any 'mlr3' learner. The package works with
    several optimization algorithms e.g. Random Search, Recursive Feature
    Elimination, and Genetic Search. Moreover, it can automatically
    optimize learners and estimate the performance of optimized feature
    sets with nested resampling.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlr3fselect.mlr-org.com">https://mlr3fselect.mlr-org.com</a>,
<a href="https://github.com/mlr-org/mlr3fselect">https://github.com/mlr-org/mlr3fselect</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlr3fselect/issues">https://github.com/mlr-org/mlr3fselect/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3 (&ge; 0.12.0), R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bbotk (&ge; 1.0.0), checkmate (&ge; 2.0.0), data.table, lgr,
mlr3misc (&ge; 0.15.1), paradox (&ge; 1.0.0), R6, stabm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>e1071, genalg, mlr3learners, mlr3pipelines, rpart, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ArchiveBatchFSelect.R' 'AutoFSelector.R'
'CallbackBatchFSelect.R' 'ContextBatchFSelect.R'
'EnsembleFSResult.R' 'FSelectInstanceBatchSingleCrit.R'
'FSelectInstanceBatchMultiCrit.R' 'mlr_fselectors.R'
'FSelector.R' 'FSelectorBatch.R' 'FSelectorBatchDesignPoints.R'
'FSelectorBatchExhaustiveSearch.R'
'FSelectorBatchFromOptimizerBatch.R'
'FSelectorBatchGeneticSearch.R' 'FSelectorBatchRFE.R'
'FSelectorBatchRFECV.R' 'FSelectorBatchRandomSearch.R'
'FSelectorBatchSequential.R'
'FSelectorBatchShadowVariableSearch.R' 'ObjectiveFSelect.R'
'ObjectiveFSelectBatch.R' 'assertions.R' 'auto_fselector.R'
'bibentries.R' 'ensemble_fselect.R'
'extract_inner_fselect_archives.R'
'extract_inner_fselect_results.R' 'fselect.R'
'fselect_nested.R' 'helper.R' 'mlr_callbacks.R' 'reexports.R'
'sugar.R' 'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-29 12:51:07 UTC; marc</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Patrick Schratz <a href="https://orcid.org/0000-0003-0748-6624"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  John Zobolas <a href="https://orcid.org/0000-0002-3609-8674"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Becker &lt;marcbecker@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-29 15:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlr3fselect-package'>mlr3fselect: Feature Selection for 'mlr3'</h2><span id='topic+mlr3fselect'></span><span id='topic+mlr3fselect-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Feature selection package of the 'mlr3' ecosystem. It selects the optimal feature set for any 'mlr3' learner. The package works with several optimization algorithms e.g. Random Search, Recursive Feature Elimination, and Genetic Search. Moreover, it can automatically optimize learners and estimate the performance of optimized feature sets with nested resampling.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Patrick Schratz <a href="mailto:patrick.schratz@gmail.com">patrick.schratz@gmail.com</a> (<a href="https://orcid.org/0000-0003-0748-6624">ORCID</a>)
</p>
</li>
<li><p> Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>)
</p>
</li>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a> (<a href="https://orcid.org/0000-0001-6002-6980">ORCID</a>)
</p>
</li>
<li><p> John Zobolas <a href="mailto:bblodfon@gmail.com">bblodfon@gmail.com</a> (<a href="https://orcid.org/0000-0002-3609-8674">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mlr3fselect.mlr-org.com">https://mlr3fselect.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/mlr3fselect">https://github.com/mlr-org/mlr3fselect</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mlr3fselect/issues">https://github.com/mlr-org/mlr3fselect/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ArchiveBatchFSelect'>Class for Logging Evaluated Feature Sets</h2><span id='topic+ArchiveBatchFSelect'></span>

<h3>Description</h3>

<p>The <a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> stores all evaluated feature sets and performance scores.
</p>


<h3>Details</h3>

<p>The <a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> is a container around a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
Each row corresponds to a single evaluation of a feature set.
See the section on Data Structure for more information.
The archive stores additionally a <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a> (<code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code>) that records the resampling experiments.
Each experiment corresponds to a single evaluation of a feature set.
The table (<code style="white-space: pre;">&#8288;$data&#8288;</code>) and the benchmark result (<code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code>) are linked by the <code>uhash</code> column.
If the archive is passed to <code>as.data.table()</code>, both are joined automatically.
</p>


<h3>Data structure</h3>

<p>The table (<code style="white-space: pre;">&#8288;$data&#8288;</code>) has the following columns:
</p>

<ul>
<li><p> One column for each feature of the task (<code style="white-space: pre;">&#8288;$search_space&#8288;</code>).
</p>
</li>
<li><p> One column for each performance measure (<code style="white-space: pre;">&#8288;$codomain&#8288;</code>).
</p>
</li>
<li> <p><code>runtime_learners</code> (<code>numeric(1)</code>)<br />
Sum of training and predict times logged in learners per <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> / evaluation.
This does not include potential overhead time.
</p>
</li>
<li> <p><code>timestamp</code> (<code>POSIXct</code>)<br />
Time stamp when the evaluation was logged into the archive.
</p>
</li>
<li> <p><code>batch_nr</code> (<code>integer(1)</code>)<br />
Feature sets are evaluated in batches. Each batch has a unique batch number.
</p>
</li>
<li> <p><code>uhash</code> (<code>character(1)</code>)<br />
Connects each feature set to the resampling experiment stored in the <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>.
</p>
</li></ul>



<h3>Analysis</h3>

<p>For analyzing the feature selection results, it is recommended to pass the archive to <code>as.data.table()</code>.
The returned data table is joined with the benchmark result which adds the <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> for each feature set.
</p>
<p>The archive provides various getters (e.g. <code style="white-space: pre;">&#8288;$learners()&#8288;</code>) to ease the access.
All getters extract by position (<code>i</code>) or unique hash (<code>uhash</code>).
For a complete list of all getters see the methods section.
</p>
<p>The benchmark result (<code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code>) allows to score the feature sets again on a different measure.
Alternatively, measures can be supplied to <code>as.data.table()</code>.
</p>


<h3>S3 Methods</h3>


<ul>
<li> <p><code>as.data.table.ArchiveBatchFSelect(x, exclude_columns = "uhash", measures = NULL)</code><br />
Returns a tabular view of all evaluated feature sets.<br />
<a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
</p>

<ul>
<li> <p><code>x</code> (<a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a>)
</p>
</li>
<li> <p><code>exclude_columns</code> (<code>character()</code>)<br />
Exclude columns from table. Set to <code>NULL</code> if no column should be excluded.
</p>
</li>
<li> <p><code>measures</code> (list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Score feature sets on additional measures.
</p>
</li></ul>

</li></ul>



<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Archive">bbotk::Archive</a></code> -&gt; <code><a href="bbotk.html#topic+ArchiveBatch">bbotk::ArchiveBatch</a></code> -&gt; <code>ArchiveBatchFSelect</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>benchmark_result</code></dt><dd><p>(<a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>)<br />
Benchmark result.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>ties_method</code></dt><dd><p>(<code>character(1)</code>)<br />
Method to handle ties.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ArchiveBatchFSelect-new"><code>ArchiveBatchFSelect$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-learner"><code>ArchiveBatchFSelect$learner()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-learners"><code>ArchiveBatchFSelect$learners()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-predictions"><code>ArchiveBatchFSelect$predictions()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-resample_result"><code>ArchiveBatchFSelect$resample_result()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-print"><code>ArchiveBatchFSelect$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-best"><code>ArchiveBatchFSelect$best()</code></a>
</p>
</li>
<li> <p><a href="#method-ArchiveBatchFSelect-clone"><code>ArchiveBatchFSelect$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="format"><a href='../../bbotk/html/Archive.html#method-Archive-format'><code>bbotk::Archive$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Archive" data-id="help"><a href='../../bbotk/html/Archive.html#method-Archive-help'><code>bbotk::Archive$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="ArchiveBatch" data-id="add_evals"><a href='../../bbotk/html/ArchiveBatch.html#method-ArchiveBatch-add_evals'><code>bbotk::ArchiveBatch$add_evals()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="ArchiveBatch" data-id="clear"><a href='../../bbotk/html/ArchiveBatch.html#method-ArchiveBatch-clear'><code>bbotk::ArchiveBatch$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="ArchiveBatch" data-id="nds_selection"><a href='../../bbotk/html/ArchiveBatch.html#method-ArchiveBatch-nds_selection'><code>bbotk::ArchiveBatch$nds_selection()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ArchiveBatchFSelect-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$new(
  search_space,
  codomain,
  check_values = TRUE,
  ties_method = "least_features"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>search_space</code></dt><dd><p>(<a href="paradox.html#topic+ParamSet">paradox::ParamSet</a>)<br />
Search space.
Internally created from provided <a href="mlr3.html#topic+Task">mlr3::Task</a> by instance.</p>
</dd>
<dt><code>codomain</code></dt><dd><p>(<a href="bbotk.html#topic+Codomain">bbotk::Codomain</a>)<br />
Specifies codomain of objective function i.e. a set of performance measures.
Internally created from provided <a href="mlr3.html#topic+Measure">mlr3::Measure</a>s by instance.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), hyperparameter configurations are check for validity.</p>
</dd>
<dt><code>ties_method</code></dt><dd><p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBatchFSelect-learner"></a>



<h4>Method <code>learner()</code></h4>

<p>Retrieve <a href="mlr3.html#topic+Learner">mlr3::Learner</a> of the i-th evaluation, by position or by unique hash <code>uhash</code>.
<code>i</code> and <code>uhash</code> are mutually exclusive.
Learner does not contain a model. Use <code style="white-space: pre;">&#8288;$learners()&#8288;</code> to get learners with models.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$learner(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>(<code>integer(1)</code>)<br />
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt><dd><p>(<code>logical(1)</code>)<br />
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBatchFSelect-learners"></a>



<h4>Method <code>learners()</code></h4>

<p>Retrieve list of trained <a href="mlr3.html#topic+Learner">mlr3::Learner</a> objects of the i-th evaluation,
by position or by unique hash <code>uhash</code>. <code>i</code> and <code>uhash</code> are mutually
exclusive.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$learners(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>(<code>integer(1)</code>)<br />
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt><dd><p>(<code>logical(1)</code>)<br />
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBatchFSelect-predictions"></a>



<h4>Method <code>predictions()</code></h4>

<p>Retrieve list of <a href="mlr3.html#topic+Prediction">mlr3::Prediction</a> objects of the i-th evaluation, by
position or by unique hash <code>uhash</code>. <code>i</code> and <code>uhash</code> are mutually
exclusive.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$predictions(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>(<code>integer(1)</code>)<br />
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt><dd><p>(<code>logical(1)</code>)<br />
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBatchFSelect-resample_result"></a>



<h4>Method <code>resample_result()</code></h4>

<p>Retrieve <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> of the i-th evaluation, by position
or by unique hash <code>uhash</code>. <code>i</code> and <code>uhash</code> are mutually exclusive.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$resample_result(i = NULL, uhash = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>(<code>integer(1)</code>)<br />
The iteration value to filter for.</p>
</dd>
<dt><code>uhash</code></dt><dd><p>(<code>logical(1)</code>)<br />
The <code>uhash</code> value to filter for.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBatchFSelect-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ArchiveBatchFSelect-best"></a>



<h4>Method <code>best()</code></h4>

<p>Returns the best scoring feature sets.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$best(batch = NULL, ties_method = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>batch</code></dt><dd><p>(<code>integer()</code>)<br />
The batch number(s) to limit the best results to.
Default is all batches.</p>
</dd>
<dt><code>ties_method</code></dt><dd><p>(<code>character(1)</code>)<br />
Method to handle ties.
If <code>NULL</code> (default), the global ties method set during initialization is used.
The default global ties method is <code>least_features</code> which selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-ArchiveBatchFSelect-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ArchiveBatchFSelect$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='auto_fselector'>Function for Automatic Feature Selection</h2><span id='topic+auto_fselector'></span>

<h3>Description</h3>

<p>The <a href="#topic+AutoFSelector">AutoFSelector</a> wraps a <a href="mlr3.html#topic+Learner">mlr3::Learner</a> and augments it with an automatic feature selection.
The <code><a href="#topic+auto_fselector">auto_fselector()</a></code> function creates an <a href="#topic+AutoFSelector">AutoFSelector</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_fselector(
  fselector,
  learner,
  resampling,
  measure = NULL,
  term_evals = NULL,
  term_time = NULL,
  terminator = NULL,
  store_fselect_instance = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_fselector_+3A_fselector">fselector</code></td>
<td>
<p>(<a href="#topic+FSelector">FSelector</a>)<br />
Optimization algorithm.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_learner">learner</code></td>
<td>
<p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_resampling">resampling</code></td>
<td>
<p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_measure">measure</code></td>
<td>
<p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_term_evals">term_evals</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of allowed evaluations.
Ignored if <code>terminator</code> is passed.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_term_time">term_time</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Maximum allowed time in seconds.
Ignored if <code>terminator</code> is passed.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_store_fselect_instance">store_fselect_instance</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), stores the internally created <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> with all intermediate results in slot <code style="white-space: pre;">&#8288;$fselect_instance&#8288;</code>.
Is set to <code>TRUE</code>, if <code>store_models = TRUE</code></p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_store_benchmark_result">store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_store_models">store_models</code></td>
<td>
<p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_check_values">check_values</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_callbacks">callbacks</code></td>
<td>
<p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</td></tr>
<tr><td><code id="auto_fselector_+3A_ties_method">ties_method</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+AutoFSelector">AutoFSelector</a> is a <a href="mlr3.html#topic+Learner">mlr3::Learner</a> which wraps another <a href="mlr3.html#topic+Learner">mlr3::Learner</a> and performs the following steps during <code style="white-space: pre;">&#8288;$train()&#8288;</code>:
</p>

<ol>
<li><p> The wrapped (inner) learner is trained on the feature subsets via resampling.
The feature selection can be specified by providing a <a href="#topic+FSelector">FSelector</a>, a <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>, a <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a> and a <a href="mlr3.html#topic+Measure">mlr3::Measure</a>.
</p>
</li>
<li><p> A final model is fit on the complete training data with the best-found feature subset.
</p>
</li></ol>

<p>During <code style="white-space: pre;">&#8288;$predict()&#8288;</code> the <a href="#topic+AutoFSelector">AutoFSelector</a> just calls the predict method of the wrapped (inner) learner.
</p>


<h3>Value</h3>

<p><a href="#topic+AutoFSelector">AutoFSelector</a>.
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Estimate Model Performance with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-autofselect">nested resampling</a>.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>


<h3>Nested Resampling</h3>

<p>Nested resampling can be performed by passing an <a href="#topic+AutoFSelector">AutoFSelector</a> object to <code><a href="mlr3.html#topic+resample">mlr3::resample()</a></code> or <code><a href="mlr3.html#topic+benchmark">mlr3::benchmark()</a></code>.
To access the inner resampling results, set <code>store_fselect_instance = TRUE</code> and execute <code><a href="mlr3.html#topic+resample">mlr3::resample()</a></code> or <code><a href="mlr3.html#topic+benchmark">mlr3::benchmark()</a></code> with <code>store_models = TRUE</code> (see examples).
The <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a> passed to the <a href="#topic+AutoFSelector">AutoFSelector</a> is meant to be the inner resampling, operating on the training set of an arbitrary outer resampling.
For this reason it is not feasible to pass an instantiated <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a> here.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Automatic Feature Selection


# split to train and external set
task = tsk("penguins")
split = partition(task, ratio = 0.8)

# create auto fselector
afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

# optimize feature subset and fit final model
afs$train(task, row_ids = split$train)

# predict with final model
afs$predict(task, row_ids = split$test)

# show result
afs$fselect_result

# model slot contains trained learner and fselect instance
afs$model

# shortcut trained learner
afs$learner

# shortcut fselect instance
afs$fselect_instance


# Nested Resampling

afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

resampling_outer = rsmp("cv", folds = 3)
rr = resample(task, afs, resampling_outer, store_models = TRUE)

# retrieve inner feature selection results.
extract_inner_fselect_results(rr)

# performance scores estimated on the outer resampling
rr$score()

# unbiased performance of the final model trained on the full data set
rr$aggregate()

</code></pre>

<hr>
<h2 id='AutoFSelector'>Class for Automatic Feature Selection</h2><span id='topic+AutoFSelector'></span>

<h3>Description</h3>

<p>The <a href="#topic+AutoFSelector">AutoFSelector</a> wraps a <a href="mlr3.html#topic+Learner">mlr3::Learner</a> and augments it with an automatic feature selection.
The <code><a href="#topic+auto_fselector">auto_fselector()</a></code> function creates an <a href="#topic+AutoFSelector">AutoFSelector</a> object.
</p>


<h3>Details</h3>

<p>The <a href="#topic+AutoFSelector">AutoFSelector</a> is a <a href="mlr3.html#topic+Learner">mlr3::Learner</a> which wraps another <a href="mlr3.html#topic+Learner">mlr3::Learner</a> and performs the following steps during <code style="white-space: pre;">&#8288;$train()&#8288;</code>:
</p>

<ol>
<li><p> The wrapped (inner) learner is trained on the feature subsets via resampling.
The feature selection can be specified by providing a <a href="#topic+FSelector">FSelector</a>, a <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>, a <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a> and a <a href="mlr3.html#topic+Measure">mlr3::Measure</a>.
</p>
</li>
<li><p> A final model is fit on the complete training data with the best-found feature subset.
</p>
</li></ol>

<p>During <code style="white-space: pre;">&#8288;$predict()&#8288;</code> the <a href="#topic+AutoFSelector">AutoFSelector</a> just calls the predict method of the wrapped (inner) learner.
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Estimate Model Performance with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-autofselect">nested resampling</a>.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>


<h3>Nested Resampling</h3>

<p>Nested resampling can be performed by passing an <a href="#topic+AutoFSelector">AutoFSelector</a> object to <code><a href="mlr3.html#topic+resample">mlr3::resample()</a></code> or <code><a href="mlr3.html#topic+benchmark">mlr3::benchmark()</a></code>.
To access the inner resampling results, set <code>store_fselect_instance = TRUE</code> and execute <code><a href="mlr3.html#topic+resample">mlr3::resample()</a></code> or <code><a href="mlr3.html#topic+benchmark">mlr3::benchmark()</a></code> with <code>store_models = TRUE</code> (see examples).
The <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a> passed to the <a href="#topic+AutoFSelector">AutoFSelector</a> is meant to be the inner resampling, operating on the training set of an arbitrary outer resampling.
For this reason it is not feasible to pass an instantiated <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a> here.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Learner">mlr3::Learner</a></code> -&gt; <code>AutoFSelector</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>instance_args</code></dt><dd><p>(<code>list()</code>)<br />
All arguments from construction to create the <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>.</p>
</dd>
<dt><code>fselector</code></dt><dd><p>(<a href="#topic+FSelector">FSelector</a>)<br />
Optimization algorithm.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>archive</code></dt><dd><p>([ArchiveBatchFSelect)<br />
Returns <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> archive.</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Trained learner.</p>
</dd>
<dt><code>fselect_instance</code></dt><dd><p>(<a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>)<br />
Internally created feature selection instance with all intermediate results.</p>
</dd>
<dt><code>fselect_result</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
Short-cut to <code style="white-space: pre;">&#8288;$result&#8288;</code> from <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>.</p>
</dd>
<dt><code>predict_type</code></dt><dd><p>(<code>character(1)</code>)<br />
Stores the currently active predict type, e.g. <code>"response"</code>.
Must be an element of <code style="white-space: pre;">&#8288;$predict_types&#8288;</code>.</p>
</dd>
<dt><code>hash</code></dt><dd><p>(<code>character(1)</code>)<br />
Hash (unique identifier) for this object.</p>
</dd>
<dt><code>phash</code></dt><dd><p>(<code>character(1)</code>)<br />
Hash (unique identifier) for this partial object, excluding some components which are varied systematically during tuning (parameter values) or feature selection (feature names).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AutoFSelector-new"><code>AutoFSelector$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-base_learner"><code>AutoFSelector$base_learner()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-importance"><code>AutoFSelector$importance()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-selected_features"><code>AutoFSelector$selected_features()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-oob_error"><code>AutoFSelector$oob_error()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-loglik"><code>AutoFSelector$loglik()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-print"><code>AutoFSelector$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AutoFSelector-clone"><code>AutoFSelector$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="format"><a href='../../mlr3/html/Learner.html#method-Learner-format'><code>mlr3::Learner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="help"><a href='../../mlr3/html/Learner.html#method-Learner-help'><code>mlr3::Learner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict"><a href='../../mlr3/html/Learner.html#method-Learner-predict'><code>mlr3::Learner$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="predict_newdata"><a href='../../mlr3/html/Learner.html#method-Learner-predict_newdata'><code>mlr3::Learner$predict_newdata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="reset"><a href='../../mlr3/html/Learner.html#method-Learner-reset'><code>mlr3::Learner$reset()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Learner" data-id="train"><a href='../../mlr3/html/Learner.html#method-Learner-train'><code>mlr3::Learner$train()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-AutoFSelector-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$new(
  fselector,
  learner,
  resampling,
  measure = NULL,
  terminator,
  store_fselect_instance = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fselector</code></dt><dd><p>(<a href="#topic+FSelector">FSelector</a>)<br />
Optimization algorithm.</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</dd>
<dt><code>resampling</code></dt><dd><p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</dd>
<dt><code>measure</code></dt><dd><p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</dd>
<dt><code>store_fselect_instance</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), stores the internally created <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> with all intermediate results in slot <code style="white-space: pre;">&#8288;$fselect_instance&#8288;</code>.
Is set to <code>TRUE</code>, if <code>store_models = TRUE</code></p>
</dd>
<dt><code>store_benchmark_result</code></dt><dd><p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</dd>
<dt><code>store_models</code></dt><dd><p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</dd>
<dt><code>ties_method</code></dt><dd><p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AutoFSelector-base_learner"></a>



<h4>Method <code>base_learner()</code></h4>

<p>Extracts the base learner from nested learner objects like <code>GraphLearner</code> in <a href="https://CRAN.R-project.org/package=mlr3pipelines"><span class="pkg">mlr3pipelines</span></a>.
If <code>recursive = 0</code>, the (tuned) learner is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$base_learner(recursive = Inf)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>recursive</code></dt><dd><p>(<code>integer(1)</code>)<br />
Depth of recursion for multiple nested objects.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="mlr3.html#topic+Learner">mlr3::Learner</a>.
</p>


<hr>
<a id="method-AutoFSelector-importance"></a>



<h4>Method <code>importance()</code></h4>

<p>The importance scores of the final model.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$importance()</pre></div>



<h5>Returns</h5>

<p>Named <code>numeric()</code>.
</p>


<hr>
<a id="method-AutoFSelector-selected_features"></a>



<h4>Method <code>selected_features()</code></h4>

<p>The selected features of the final model.
These features are selected internally by the learner.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$selected_features()</pre></div>



<h5>Returns</h5>

<p><code>character()</code>.
</p>


<hr>
<a id="method-AutoFSelector-oob_error"></a>



<h4>Method <code>oob_error()</code></h4>

<p>The out-of-bag error of the final model.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$oob_error()</pre></div>



<h5>Returns</h5>

<p><code>numeric(1)</code>.
</p>


<hr>
<a id="method-AutoFSelector-loglik"></a>



<h4>Method <code>loglik()</code></h4>

<p>The log-likelihood of the final model.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$loglik()</pre></div>



<h5>Returns</h5>

<p><code>logLik</code>.
Printer.
</p>


<hr>
<a id="method-AutoFSelector-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AutoFSelector-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AutoFSelector$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Automatic Feature Selection


# split to train and external set
task = tsk("penguins")
split = partition(task, ratio = 0.8)

# create auto fselector
afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

# optimize feature subset and fit final model
afs$train(task, row_ids = split$train)

# predict with final model
afs$predict(task, row_ids = split$test)

# show result
afs$fselect_result

# model slot contains trained learner and fselect instance
afs$model

# shortcut trained learner
afs$learner

# shortcut fselect instance
afs$fselect_instance


# Nested Resampling

afs = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

resampling_outer = rsmp("cv", folds = 3)
rr = resample(task, afs, resampling_outer, store_models = TRUE)

# retrieve inner feature selection results.
extract_inner_fselect_results(rr)

# performance scores estimated on the outer resampling
rr$score()

# unbiased performance of the final model trained on the full data set
rr$aggregate()

</code></pre>

<hr>
<h2 id='callback_batch_fselect'>Create Feature Selection Callback</h2><span id='topic+callback_batch_fselect'></span>

<h3>Description</h3>

<p>Function to create a <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>.
Predefined callbacks are stored in the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_callbacks">mlr_callbacks</a> and can be retrieved with <code><a href="#topic+clbk">clbk()</a></code>.
</p>
<p>Feature selection callbacks can be called from different stages of feature selection.
The stages are prefixed with <code style="white-space: pre;">&#8288;on_*&#8288;</code>.
</p>
<div class="sourceCode"><pre>Start Feature Selection
     - on_optimization_begin
    Start FSelect Batch
         - on_optimizer_before_eval
        Start Evaluation
             - on_eval_after_design
             - on_eval_after_benchmark
             - on_eval_before_archive
        End Evaluation
         - on_optimizer_after_eval
    End FSelect Batch
     - on_result
     - on_optimization_end
End Feature Selection
</pre></div>
<p>See also the section on parameters for more information on the stages.
A feature selection callback works with <a href="bbotk.html#topic+ContextBatch">bbotk::ContextBatch</a> and <a href="#topic+ContextBatchFSelect">ContextBatchFSelect</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callback_batch_fselect(
  id,
  label = NA_character_,
  man = NA_character_,
  on_optimization_begin = NULL,
  on_optimizer_before_eval = NULL,
  on_eval_after_design = NULL,
  on_eval_after_benchmark = NULL,
  on_eval_before_archive = NULL,
  on_optimizer_after_eval = NULL,
  on_result = NULL,
  on_optimization_end = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callback_batch_fselect_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_label">label</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Label for the new instance.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_man">man</code></td>
<td>
<p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_optimization_begin">on_optimization_begin</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called at the beginning of the optimization.
Called in <code>Optimizer$optimize()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_optimizer_before_eval">on_optimizer_before_eval</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after the optimizer proposes points.
Called in <code>OptimInstance$eval_batch()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_eval_after_design">on_eval_after_design</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after design is created.
Called in <code>ObjectiveFSelectBatch$eval_many()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_eval_after_benchmark">on_eval_after_benchmark</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after feature sets are evaluated.
Called in <code>ObjectiveFSelectBatch$eval_many()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_eval_before_archive">on_eval_before_archive</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called before performance values are written to the archive.
Called in <code>ObjectiveFSelectBatch$eval_many()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_optimizer_after_eval">on_optimizer_after_eval</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after points are evaluated.
Called in <code>OptimInstance$eval_batch()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_result">on_result</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after result are written.
Called in <code>OptimInstance$assign_result()</code>.</p>
</td></tr>
<tr><td><code id="callback_batch_fselect_+3A_on_optimization_end">on_optimization_end</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called at the end of the optimization.
Called in <code>Optimizer$optimize()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When implementing a callback, each function must have two arguments named <code>callback</code> and <code>context</code>.
</p>
<p>A callback can write data to the state (<code style="white-space: pre;">&#8288;$state&#8288;</code>), e.g. settings that affect the callback itself.
Avoid writing large data the state.
This can slow down the feature selection when the evaluation of configurations is parallelized.
</p>
<p>Feature selection callbacks access two different contexts depending on the stage.
The stages <code>on_eval_after_design</code>, <code>on_eval_after_benchmark</code>, <code>on_eval_before_archive</code> access <a href="#topic+ContextBatchFSelect">ContextBatchFSelect</a>.
This context can be used to customize the evaluation of a batch of feature sets.
Changes to the state of callback are lost after the evaluation of a batch and changes to the fselect instance or the fselector are not possible.
Persistent data should be written to the archive via <code style="white-space: pre;">&#8288;$aggregated_performance&#8288;</code> (see <a href="#topic+ContextBatchFSelect">ContextBatchFSelect</a>).
The other stages access <a href="bbotk.html#topic+ContextBatch">bbotk::ContextBatch</a>.
This context can be used to modify the fselect instance, archive, fselector and final result.
There are two different contexts because the evaluation can be parallelized i.e. multiple instances of <a href="#topic+ContextBatchFSelect">ContextBatchFSelect</a> exists on different workers at the same time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Write archive to disk
callback_batch_fselect("mlr3fselect.backup",
  on_optimization_end = function(callback, context) {
    saveRDS(context$instance$archive, "archive.rds")
  }
)
</code></pre>

<hr>
<h2 id='CallbackBatchFSelect'>Create Feature Selection Callback</h2><span id='topic+CallbackBatchFSelect'></span>

<h3>Description</h3>

<p>Specialized <a href="bbotk.html#topic+CallbackBatch">bbotk::CallbackBatch</a> for feature selection.
Callbacks allow customizing the behavior of processes in mlr3fselect.
The <code><a href="#topic+callback_batch_fselect">callback_batch_fselect()</a></code> function creates a <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>.
Predefined callbacks are stored in the <a href="mlr3misc.html#topic+Dictionary">dictionary</a> <a href="#topic+mlr_callbacks">mlr_callbacks</a> and can be retrieved with <code><a href="#topic+clbk">clbk()</a></code>.
For more information on callbacks see <code><a href="#topic+callback_batch_fselect">callback_batch_fselect()</a></code>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3misc.html#topic+Callback">mlr3misc::Callback</a></code> -&gt; <code><a href="bbotk.html#topic+CallbackBatch">bbotk::CallbackBatch</a></code> -&gt; <code>CallbackBatchFSelect</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>on_eval_after_design</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after design is created.
Called in <code>ObjectiveFSelectBatch$eval_many()</code>.</p>
</dd>
<dt><code>on_eval_after_benchmark</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called after feature sets are evaluated.
Called in <code>ObjectiveFSelectBatch$eval_many()</code>.</p>
</dd>
<dt><code>on_eval_before_archive</code></dt><dd><p>(<code style="white-space: pre;">&#8288;function()&#8288;</code>)<br />
Stage called before performance values are written to the archive.
Called in <code>ObjectiveFSelectBatch$eval_many()</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CallbackBatchFSelect-clone"><code>CallbackBatchFSelect$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="call"><a href='../../mlr3misc/html/Callback.html#method-Callback-call'><code>mlr3misc::Callback$call()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="format"><a href='../../mlr3misc/html/Callback.html#method-Callback-format'><code>mlr3misc::Callback$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="help"><a href='../../mlr3misc/html/Callback.html#method-Callback-help'><code>mlr3misc::Callback$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="initialize"><a href='../../mlr3misc/html/Callback.html#method-Callback-initialize'><code>mlr3misc::Callback$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Callback" data-id="print"><a href='../../mlr3misc/html/Callback.html#method-Callback-print'><code>mlr3misc::Callback$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CallbackBatchFSelect-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CallbackBatchFSelect$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Write archive to disk
callback_batch_fselect("mlr3fselect.backup",
  on_optimization_end = function(callback, context) {
    saveRDS(context$instance$archive, "archive.rds")
  }
)
</code></pre>

<hr>
<h2 id='ContextBatchFSelect'>Evaluation Context</h2><span id='topic+ContextBatchFSelect'></span>

<h3>Description</h3>

<p>The <a href="#topic+ContextBatchFSelect">ContextBatchFSelect</a> allows <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>s to access and modify data while a batch of feature sets is evaluated.
See the section on active bindings for a list of modifiable objects.
See <code><a href="#topic+callback_batch_fselect">callback_batch_fselect()</a></code> for a list of stages that access <a href="#topic+ContextBatchFSelect">ContextBatchFSelect</a>.
</p>


<h3>Details</h3>

<p>This context is re-created each time a new batch of feature sets is evaluated.
Changes to <code style="white-space: pre;">&#8288;$objective_fselect&#8288;</code>, <code style="white-space: pre;">&#8288;$design&#8288;</code> <code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code> are discarded after the function is finished.
Modification on the data table in <code style="white-space: pre;">&#8288;$aggregated_performance&#8288;</code> are written to the archive.
Any number of columns can be added.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3misc.html#topic+Context">mlr3misc::Context</a></code> -&gt; <code><a href="bbotk.html#topic+ContextBatch">bbotk::ContextBatch</a></code> -&gt; <code>ContextBatchFSelect</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>xss</code></dt><dd><p>(list())<br />
The feature sets of the latest batch.</p>
</dd>
<dt><code>design</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
The benchmark design of the latest batch.</p>
</dd>
<dt><code>benchmark_result</code></dt><dd><p>(<a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>)<br />
The benchmark result of the latest batch.</p>
</dd>
<dt><code>aggregated_performance</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
Aggregated performance scores and training time of the latest batch.
This data table is passed to the archive.
A callback can add additional columns which are also written to the archive.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ContextBatchFSelect-clone"><code>ContextBatchFSelect$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Context" data-id="format"><a href='../../mlr3misc/html/Context.html#method-Context-format'><code>mlr3misc::Context$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3misc" data-topic="Context" data-id="print"><a href='../../mlr3misc/html/Context.html#method-Context-print'><code>mlr3misc::Context$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="ContextBatch" data-id="initialize"><a href='../../bbotk/html/ContextBatch.html#method-ContextBatch-initialize'><code>bbotk::ContextBatch$initialize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ContextBatchFSelect-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ContextBatchFSelect$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ensemble_fs_result'>Ensemble Feature Selection Result</h2><span id='topic+ensemble_fs_result'></span><span id='topic+EnsembleFSResult'></span>

<h3>Description</h3>

<p>The <code>EnsembleFSResult</code> stores the results of ensemble feature selection.
It includes methods for evaluating the stability of the feature selection process and for ranking the selected features among others.
The function <code><a href="#topic+ensemble_fselect">ensemble_fselect()</a></code> returns an object of this class.
</p>


<h3>S3 Methods</h3>


<ul>
<li> <p><code>as.data.table.EnsembleFSResult(x, benchmark_result = TRUE)</code><br />
Returns a tabular view of the ensemble feature selection.<br />
<a href="#topic+EnsembleFSResult">EnsembleFSResult</a> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
</p>

<ul>
<li> <p><code>x</code> (<a href="#topic+EnsembleFSResult">EnsembleFSResult</a>)
</p>
</li>
<li> <p><code>benchmark_result</code> (<code>logical(1)</code>)<br />
Whether to add the learner, task and resampling information from the benchmark result.
</p>
</li></ul>

</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>benchmark_result</code></dt><dd><p>(<a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>)<br />
The benchmark result.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
Manual page for this object.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>result</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
Returns the result of the ensemble feature selection.</p>
</dd>
<dt><code>n_learners</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Returns the number of learners used in the ensemble feature selection.</p>
</dd>
<dt><code>measure</code></dt><dd><p>(<code>character(1)</code>)<br />
Returns the measure id used in the ensemble feature selection.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-EnsembleFSResult-new"><code>EnsembleFSResult$new()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-format"><code>EnsembleFSResult$format()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-print"><code>EnsembleFSResult$print()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-help"><code>EnsembleFSResult$help()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-feature_ranking"><code>EnsembleFSResult$feature_ranking()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-stability"><code>EnsembleFSResult$stability()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-pareto_front"><code>EnsembleFSResult$pareto_front()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-knee_points"><code>EnsembleFSResult$knee_points()</code></a>
</p>
</li>
<li> <p><a href="#method-EnsembleFSResult-clone"><code>EnsembleFSResult$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-EnsembleFSResult-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$new(
  result,
  features,
  benchmark_result = NULL,
  measure_id,
  minimize = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>result</code></dt><dd><p>(<a href="data.table.html#topic+data.table">data.table::data.table</a>)<br />
The result of the ensemble feature selection.
Column names should include <code>"resampling_iteration"</code>, <code>"learner_id"</code>, <code>"features"</code>
and <code>"n_features"</code>.</p>
</dd>
<dt><code>features</code></dt><dd><p>(<code><a href="base.html#topic+character">character()</a></code>)<br />
The vector of features of the task that was used in the ensemble feature
selection.</p>
</dd>
<dt><code>benchmark_result</code></dt><dd><p>(<a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>)<br />
The benchmark result object.</p>
</dd>
<dt><code>measure_id</code></dt><dd><p>(<code>character(1)</code>)<br />
Column name of <code>"result"</code> that corresponds to the measure used.</p>
</dd>
<dt><code>minimize</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), lower values of the measure correspond to higher performance.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EnsembleFSResult-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EnsembleFSResult-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-EnsembleFSResult-help"></a>



<h4>Method <code>help()</code></h4>

<p>Opens the corresponding help page referenced by field <code style="white-space: pre;">&#8288;$man&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$help()</pre></div>


<hr>
<a id="method-EnsembleFSResult-feature_ranking"></a>



<h4>Method <code>feature_ranking()</code></h4>

<p>Calculates the feature ranking.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$feature_ranking(method = "approval_voting")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>(<code>character(1)</code>)<br />
The method to calculate the feature ranking.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The feature ranking process is built on the following framework: models act as voters, features act as candidates, and voters select certain candidates (features).
The primary objective is to compile these selections into a consensus ranked list of features, effectively forming a committee.
Currently, only <code>"approval_voting"</code> method is supported, which selects the candidates/features that have the highest approval score or selection frequency, i.e. appear the most often.
</p>



<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table::data.table</a> listing all the features, ordered by decreasing inclusion probability scores (depending on the <code>method</code>)
</p>


<hr>
<a id="method-EnsembleFSResult-stability"></a>



<h4>Method <code>stability()</code></h4>

<p>Calculates the stability of the selected features with the <a href="https://CRAN.R-project.org/package=stabm"><span class="pkg">stabm</span></a> package.
The results are cached.
When the same stability measure is requested again with different arguments, the cache must be reset.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$stability(
  stability_measure = "jaccard",
  stability_args = NULL,
  global = TRUE,
  reset_cache = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stability_measure</code></dt><dd><p>(<code>character(1)</code>)<br />
The stability measure to be used.
One of the measures returned by <code><a href="stabm.html#topic+listStabilityMeasures">stabm::listStabilityMeasures()</a></code> in lower case.
Default is <code>"jaccard"</code>.</p>
</dd>
<dt><code>stability_args</code></dt><dd><p>(<code>list</code>)<br />
Additional arguments passed to the stability measure function.</p>
</dd>
<dt><code>global</code></dt><dd><p>(<code>logical(1)</code>)<br />
Whether to calculate the stability globally or for each learner.</p>
</dd>
<dt><code>reset_cache</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, the cached results are ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>numeric()</code> value representing the stability of the selected features.
Or a <code>numeric()</code> vector with the stability of the selected features for each learner.
</p>


<hr>
<a id="method-EnsembleFSResult-pareto_front"></a>



<h4>Method <code>pareto_front()</code></h4>

<p>This function identifies the <strong>Pareto front</strong> of the ensemble feature
selection process, i.e., the set of points that represent the trade-off
between the number of features and performance (e.g. classification error).
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$pareto_front(type = "empirical")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>(<code>character(1)</code>)<br />
Specifies the type of Pareto front to return. See details.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>Two options are available for the Pareto front:
</p>

<ul>
<li> <p><code>"empirical"</code> (default): returns the empirical Pareto front.
</p>
</li>
<li> <p><code>"estimated"</code>: the Pareto front points are estimated by fitting a linear model with the inversed of the number of features (<code class="reqn">1/x</code>) as input and the associated performance scores as output.
This method is useful when the Pareto points are sparse and the front  assumes a convex shape if better performance corresponds to lower measure values (e.g. classification error), or a concave shape otherwise (e.g. classification accuracy).
The <code>estimated</code> Pareto front will include points for a number of features ranging from 1 up to the maximum number found in the empirical Pareto front.
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table::data.table</a> with columns the number of features and the performance that together form the Pareto front.
</p>


<hr>
<a id="method-EnsembleFSResult-knee_points"></a>



<h4>Method <code>knee_points()</code></h4>

<p>This function implements various <em>knee</em> point identification (KPI) methods, which select points in the Pareto front, such that an optimal trade-off between performance and number of features is achieved.
In most cases, only one such point is returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$knee_points(method = "NBI", type = "empirical")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>(<code>character(1)</code>)<br />
Type of method to use to identify the knee point. See details.</p>
</dd>
<dt><code>type</code></dt><dd><p>(<code>character(1)</code>)<br />
Specifies the type of Pareto front to use for the identification of the knee point.
See <code>pareto_front()</code> method for more details.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>The available KPI methods are:
</p>

<ul>
<li> <p><code>"NBI"</code> (default): The <strong>Normal-Boundary Intersection</strong> method is a geometry-based method which calculates the perpendicular distance of each point from the line connecting the first and last points of the Pareto front.
The knee point is determined as the Pareto point with the maximum distance from this line, see Das (1999).
</p>
</li></ul>




<h5>Returns</h5>

<p>A <a href="data.table.html#topic+data.table">data.table::data.table</a> with the knee point(s) of the Pareto front.
</p>


<hr>
<a id="method-EnsembleFSResult-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>EnsembleFSResult$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Das, I (1999).
&ldquo;On characterizing the 'knee' of the Pareto curve based on normal-boundary intersection.&rdquo;
<em>Structural Optimization</em>, <b>18</b>(1-2), 107&ndash;115.
ISSN 09344373.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  efsr = ensemble_fselect(
    fselector = fs("rfe", n_features = 2, feature_fraction = 0.8),
    task = tsk("sonar"),
    learners = lrns(c("classif.rpart", "classif.featureless")),
    init_resampling = rsmp("subsampling", repeats = 2),
    inner_resampling = rsmp("cv", folds = 3),
    measure = msr("classif.ce"),
    terminator = trm("none")
  )

  # contains the benchmark result
  efsr$benchmark_result

  # contains the selected features for each iteration
  efsr$result

  # returns the stability of the selected features
  efsr$stability(stability_measure = "jaccard")

  # returns a ranking of all features
  head(efsr$feature_ranking())

  # returns the empirical pareto front (nfeatures vs error)
  efsr$pareto_front()

</code></pre>

<hr>
<h2 id='ensemble_fselect'>Ensemble Feature Selection</h2><span id='topic+ensemble_fselect'></span>

<h3>Description</h3>

<p>Ensemble feature selection using multiple learners.
The ensemble feature selection method is designed to identify the most informative features from a given dataset by leveraging multiple machine learning models and resampling techniques.
Returns an <a href="#topic+EnsembleFSResult">EnsembleFSResult</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble_fselect(
  fselector,
  task,
  learners,
  init_resampling,
  inner_resampling,
  measure,
  terminator,
  callbacks = NULL,
  store_benchmark_result = TRUE,
  store_models = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensemble_fselect_+3A_fselector">fselector</code></td>
<td>
<p>(<a href="#topic+FSelector">FSelector</a>)<br />
Optimization algorithm.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_task">task</code></td>
<td>
<p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_learners">learners</code></td>
<td>
<p>(list of <a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
The learners to be used for feature selection.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_init_resampling">init_resampling</code></td>
<td>
<p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
The initial resampling strategy of the data, from which each train set
will be passed on to the learners.
Can only be <a href="mlr3.html#topic+mlr_resamplings_subsampling">mlr3::ResamplingSubsampling</a> or <a href="mlr3.html#topic+mlr_resamplings_bootstrap">mlr3::ResamplingBootstrap</a>.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_inner_resampling">inner_resampling</code></td>
<td>
<p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
The inner resampling strategy used by the <a href="#topic+FSelector">FSelector</a>.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_measure">measure</code></td>
<td>
<p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_callbacks">callbacks</code></td>
<td>
<p>(list of lists of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
Callbacks to be used for each learner.
The lists must have the same length as the number of learners.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_store_benchmark_result">store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to store the benchmark result in <a href="#topic+EnsembleFSResult">EnsembleFSResult</a> or not.</p>
</td></tr>
<tr><td><code id="ensemble_fselect_+3A_store_models">store_models</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Whether to store models in <a href="#topic+auto_fselector">auto_fselector</a> or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method begins by applying an initial resampling technique specified by the user, to create <strong>multiple subsamples</strong> from the original dataset.
This resampling process helps in generating diverse subsets of data for robust feature selection.
</p>
<p>For each subsample generated in the previous step, the method performs <strong>wrapped-based feature selection</strong> (<a href="#topic+auto_fselector">auto_fselector</a>) using each provided learner, the given inner resampling method, performance measure and optimization algorithm.
This process generates the best feature subset for each combination of subsample and learner.
Results are stored in an <a href="#topic+EnsembleFSResult">EnsembleFSResult</a>.
</p>


<h3>Value</h3>

<p>an <a href="#topic+EnsembleFSResult">EnsembleFSResult</a> object.
</p>


<h3>Source</h3>

<p>Saeys, Yvan, Abeel, Thomas, Van De Peer, Yves (2008).
&ldquo;Robust feature selection using ensemble feature selection techniques.&rdquo;
<em>Machine Learning and Knowledge Discovery in Databases</em>, <b>5212 LNAI</b>, 313&ndash;325.
<a href="https://doi.org/10.1007/978-3-540-87481-2_21">doi:10.1007/978-3-540-87481-2_21</a>.
</p>
<p>Abeel, Thomas, Helleputte, Thibault, Van de Peer, Yves, Dupont, Pierre, Saeys, Yvan (2010).
&ldquo;Robust biomarker identification for cancer diagnosis with ensemble feature selection methods.&rdquo;
<em>Bioinformatics</em>, <b>26</b>, 392&ndash;398.
ISSN 1367-4803, <a href="https://doi.org/10.1093/BIOINFORMATICS/BTP630">doi:10.1093/BIOINFORMATICS/BTP630</a>.
</p>
<p>Pes, Barbara (2020).
&ldquo;Ensemble feature selection for high-dimensional data: a stability analysis across multiple domains.&rdquo;
<em>Neural Computing and Applications</em>, <b>32</b>(10), 5951&ndash;5973.
ISSN 14333058, <a href="https://doi.org/10.1007/s00521-019-04082-3">doi:10.1007/s00521-019-04082-3</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  efsr = ensemble_fselect(
    fselector = fs("random_search"),
    task = tsk("sonar"),
    learners = lrns(c("classif.rpart", "classif.featureless")),
    init_resampling = rsmp("subsampling", repeats = 2),
    inner_resampling = rsmp("cv", folds = 3),
    measure = msr("classif.ce"),
    terminator = trm("evals", n_evals = 10)
  )
  efsr

</code></pre>

<hr>
<h2 id='extract_inner_fselect_archives'>Extract Inner Feature Selection Archives</h2><span id='topic+extract_inner_fselect_archives'></span>

<h3>Description</h3>

<p>Extract inner feature selection archives of nested resampling.
Implemented for <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> and <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>.
The function iterates over the <a href="#topic+AutoFSelector">AutoFSelector</a> objects and binds the archives to a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
<a href="#topic+AutoFSelector">AutoFSelector</a> must be initialized with <code>store_fselect_instance = TRUE</code> and <code>resample()</code> or <code>benchmark()</code> must be called with <code>store_models = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_inner_fselect_archives(x, exclude_columns = "uhash")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_inner_fselect_archives_+3A_x">x</code></td>
<td>
<p>(<a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> | <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>).</p>
</td></tr>
<tr><td><code id="extract_inner_fselect_archives_+3A_exclude_columns">exclude_columns</code></td>
<td>
<p>(<code>character()</code>)<br />
Exclude columns from result table. Set to <code>NULL</code> if no column should be
excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>


<h3>Data structure</h3>

<p>The returned data table has the following columns:
</p>

<ul>
<li> <p><code>experiment</code> (integer(1))<br />
Index, giving the according row number in the original benchmark grid.
</p>
</li>
<li> <p><code>iteration</code> (integer(1))<br />
Iteration of the outer resampling.
</p>
</li>
<li><p> One column for each feature of the task.
</p>
</li>
<li><p> One column for each performance measure.
</p>
</li>
<li> <p><code>runtime_learners</code> (<code>numeric(1)</code>)<br />
Sum of training and predict times logged in learners per
<a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> / evaluation. This does not include potential
overhead time.
</p>
</li>
<li> <p><code>timestamp</code> (<code>POSIXct</code>)<br />
Time stamp when the evaluation was logged into the archive.
</p>
</li>
<li> <p><code>batch_nr</code> (<code>integer(1)</code>)<br />
Feature sets are evaluated in batches. Each batch has a unique batch
number.
</p>
</li>
<li> <p><code>resample_result</code> (<a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a>)<br />
Resample result of the inner resampling.
</p>
</li>
<li> <p><code>task_id</code> (<code>character(1)</code>).
</p>
</li>
<li> <p><code>learner_id</code> (<code>character(1)</code>).
</p>
</li>
<li> <p><code>resampling_id</code> (<code>character(1)</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Nested Resampling on Palmer Penguins Data Set

# create auto fselector
at = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

resampling_outer = rsmp("cv", folds = 2)
rr = resample(tsk("penguins"), at, resampling_outer, store_models = TRUE)

# extract inner archives
extract_inner_fselect_archives(rr)
</code></pre>

<hr>
<h2 id='extract_inner_fselect_results'>Extract Inner Feature Selection Results</h2><span id='topic+extract_inner_fselect_results'></span>

<h3>Description</h3>

<p>Extract inner feature selection results of nested resampling.
Implemented for <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> and <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_inner_fselect_results(x, fselect_instance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_inner_fselect_results_+3A_x">x</code></td>
<td>
<p>(<a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> | <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a>).</p>
</td></tr>
<tr><td><code id="extract_inner_fselect_results_+3A_fselect_instance">fselect_instance</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, instances are added to the table.</p>
</td></tr>
<tr><td><code id="extract_inner_fselect_results_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function iterates over the <a href="#topic+AutoFSelector">AutoFSelector</a> objects and binds the feature selection results to a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
<a href="#topic+AutoFSelector">AutoFSelector</a> must be initialized with <code>store_fselect_instance = TRUE</code> and <code>resample()</code> or <code>benchmark()</code> must be called with <code>store_models = TRUE</code>.
Optionally, the instance can be added for each iteration.
</p>


<h3>Value</h3>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>


<h3>Data structure</h3>

<p>The returned data table has the following columns:
</p>

<ul>
<li> <p><code>experiment</code> (integer(1))<br />
Index, giving the according row number in the original benchmark grid.
</p>
</li>
<li> <p><code>iteration</code> (integer(1))<br />
Iteration of the outer resampling.
</p>
</li>
<li><p> One column for each feature of the task.
</p>
</li>
<li><p> One column for each performance measure.
</p>
</li>
<li> <p><code>features</code> (character())<br />
Vector of selected feature set.
</p>
</li>
<li> <p><code>task_id</code> (<code>character(1)</code>).
</p>
</li>
<li> <p><code>learner_id</code> (<code>character(1)</code>).
</p>
</li>
<li> <p><code>resampling_id</code> (<code>character(1)</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Nested Resampling on Palmer Penguins Data Set

# create auto fselector
at = auto_fselector(
  fselector = fs("random_search"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measure = msr("classif.ce"),
  term_evals = 4)

resampling_outer = rsmp("cv", folds = 2)
rr = resample(tsk("iris"), at, resampling_outer, store_models = TRUE)

# extract inner results
extract_inner_fselect_results(rr)
</code></pre>

<hr>
<h2 id='fs'>Syntactic Sugar for FSelect Construction</h2><span id='topic+fs'></span><span id='topic+fss'></span>

<h3>Description</h3>

<p>Functions to retrieve objects, set parameters and assign to fields in one go.
Relies on <code><a href="mlr3misc.html#topic+dictionary_sugar_get">mlr3misc::dictionary_sugar_get()</a></code> to extract objects from the respective <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>:
</p>

<ul>
<li> <p><code>fs()</code> for a <a href="#topic+FSelector">FSelector</a> from <a href="#topic+mlr_fselectors">mlr_fselectors</a>.
</p>
</li>
<li> <p><code>fss()</code> for a list of a <a href="#topic+FSelector">FSelector</a> from <a href="#topic+mlr_fselectors">mlr_fselectors</a>.
</p>
</li>
<li> <p><code>trm()</code> for a <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> from <a href="#topic+mlr_terminators">mlr_terminators</a>.
</p>
</li>
<li> <p><code>trms()</code> for a list of <a href="bbotk.html#topic+Terminator">Terminators</a> from <a href="#topic+mlr_terminators">mlr_terminators</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>fs(.key, ...)

fss(.keys, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_+3A_.key">.key</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Key passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve the object.</p>
</td></tr>
<tr><td><code id="fs_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
<tr><td><code id="fs_+3A_.keys">.keys</code></td>
<td>
<p>(<code>character()</code>)<br />
Keys passed to the respective <a href="mlr3misc.html#topic+Dictionary">dictionary</a> to retrieve multiple objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object of the respective type, or a list of <a href="R6.html#topic+R6Class">R6::R6Class</a> objects for the plural versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># random search with batch size of 5
fs("random_search", batch_size = 5)

# run time terminator with 20 seconds
trm("run_time", secs = 20)
</code></pre>

<hr>
<h2 id='fselect'>Function for Feature Selection</h2><span id='topic+fselect'></span>

<h3>Description</h3>

<p>Function to optimize the features of a <a href="mlr3.html#topic+Learner">mlr3::Learner</a>.
The function internally creates a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> or <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> which describes the feature selection problem.
It executes the feature selection with the <a href="#topic+FSelector">FSelector</a> (<code>method</code>) and returns the result with the fselect instance (<code style="white-space: pre;">&#8288;$result&#8288;</code>).
The <a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> (<code style="white-space: pre;">&#8288;$archive&#8288;</code>) stores all evaluated hyperparameter configurations and performance scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fselect(
  fselector,
  task,
  learner,
  resampling,
  measures = NULL,
  term_evals = NULL,
  term_time = NULL,
  terminator = NULL,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fselect_+3A_fselector">fselector</code></td>
<td>
<p>(<a href="#topic+FSelector">FSelector</a>)<br />
Optimization algorithm.</p>
</td></tr>
<tr><td><code id="fselect_+3A_task">task</code></td>
<td>
<p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</td></tr>
<tr><td><code id="fselect_+3A_learner">learner</code></td>
<td>
<p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</td></tr>
<tr><td><code id="fselect_+3A_resampling">resampling</code></td>
<td>
<p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</td></tr>
<tr><td><code id="fselect_+3A_measures">measures</code></td>
<td>
<p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a> or list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
A single measure creates a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> and multiple measures a <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
If <code>NULL</code>, default measure is used.</p>
</td></tr>
<tr><td><code id="fselect_+3A_term_evals">term_evals</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of allowed evaluations.
Ignored if <code>terminator</code> is passed.</p>
</td></tr>
<tr><td><code id="fselect_+3A_term_time">term_time</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Maximum allowed time in seconds.
Ignored if <code>terminator</code> is passed.</p>
</td></tr>
<tr><td><code id="fselect_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</td></tr>
<tr><td><code id="fselect_+3A_store_benchmark_result">store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</td></tr>
<tr><td><code id="fselect_+3A_store_models">store_models</code></td>
<td>
<p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</td></tr>
<tr><td><code id="fselect_+3A_check_values">check_values</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</td></tr>
<tr><td><code id="fselect_+3A_callbacks">callbacks</code></td>
<td>
<p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</td></tr>
<tr><td><code id="fselect_+3A_ties_method">ties_method</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="mlr3.html#topic+Task">mlr3::Task</a>, <a href="mlr3.html#topic+Learner">mlr3::Learner</a>, <a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>, <a href="mlr3.html#topic+Measure">mlr3::Measure</a> and <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> are used to construct a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>.
If multiple performance <a href="mlr3.html#topic+Measure">Measures</a> are supplied, a <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> is created.
The parameter <code>term_evals</code> and <code>term_time</code> are shortcuts to create a <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>.
If both parameters are passed, a <a href="bbotk.html#topic+mlr_terminators_combo">bbotk::TerminatorCombo</a> is constructed.
For other <a href="bbotk.html#topic+Terminator">Terminators</a>, pass one with <code>terminator</code>.
If no termination criterion is needed, set <code>term_evals</code>, <code>term_time</code> and <code>terminator</code> to <code>NULL</code>.
</p>


<h3>Value</h3>

<p><a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> | <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Getting started with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-fs-wrapper">wrapper feature selection</a>.
</p>
</li>
<li><p> Do a <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-fs-wrapper-example">sequential forward selection</a> Palmer Penguins data set.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li>
<li><p> Run a feature selection with <a href="https://mlr-org.com/gallery/optimization/2023-02-01-shadow-variable-search/">Shadow Variable Search</a>.
</p>
</li>
<li> <p><a href="https://mlr-org.com/gallery/optimization/2020-09-14-mlr3fselect-basic/">Feature Selection</a> on the Titanic data set.
</p>
</li></ul>



<h3>Analysis</h3>

<p>For analyzing the feature selection results, it is recommended to pass the archive to <code>as.data.table()</code>.
The returned data table is joined with the benchmark result which adds the <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> for each feature set.
</p>
<p>The archive provides various getters (e.g. <code style="white-space: pre;">&#8288;$learners()&#8288;</code>) to ease the access.
All getters extract by position (<code>i</code>) or unique hash (<code>uhash</code>).
For a complete list of all getters see the methods section.
</p>
<p>The benchmark result (<code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code>) allows to score the feature sets again on a different measure.
Alternatively, measures can be supplied to <code>as.data.table()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature selection on the Palmer Penguins data set
task = tsk("pima")
learner = lrn("classif.rpart")

# Run feature selection
instance = fselect(
  fselector = fs("random_search"),
  task = task,
  learner = learner,
  resampling = rsmp ("holdout"),
  measures = msr("classif.ce"),
  term_evals = 4)

# Subset task to optimized feature set
task$select(instance$result_feature_set)

# Train the learner with optimal feature set on the full data set
learner$train(task)

# Inspect all evaluated configurations
as.data.table(instance$archive)
</code></pre>

<hr>
<h2 id='fselect_nested'>Function for Nested Resampling</h2><span id='topic+fselect_nested'></span>

<h3>Description</h3>

<p>Function to conduct nested resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fselect_nested(
  fselector,
  task,
  learner,
  inner_resampling,
  outer_resampling,
  measure = NULL,
  term_evals = NULL,
  term_time = NULL,
  terminator = NULL,
  store_fselect_instance = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fselect_nested_+3A_fselector">fselector</code></td>
<td>
<p>(<a href="#topic+FSelector">FSelector</a>)<br />
Optimization algorithm.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_task">task</code></td>
<td>
<p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_learner">learner</code></td>
<td>
<p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_inner_resampling">inner_resampling</code></td>
<td>
<p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling used for the inner loop.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_outer_resampling">outer_resampling</code></td>
<td>
<p><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling used for the outer loop.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_measure">measure</code></td>
<td>
<p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_term_evals">term_evals</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Number of allowed evaluations.
Ignored if <code>terminator</code> is passed.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_term_time">term_time</code></td>
<td>
<p>(<code>integer(1)</code>)<br />
Maximum allowed time in seconds.
Ignored if <code>terminator</code> is passed.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_store_fselect_instance">store_fselect_instance</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), stores the internally created <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> with all intermediate results in slot <code style="white-space: pre;">&#8288;$fselect_instance&#8288;</code>.
Is set to <code>TRUE</code>, if <code>store_models = TRUE</code></p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_store_benchmark_result">store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_store_models">store_models</code></td>
<td>
<p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_check_values">check_values</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_callbacks">callbacks</code></td>
<td>
<p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</td></tr>
<tr><td><code id="fselect_nested_+3A_ties_method">ties_method</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Nested resampling on Palmer Penguins data set
rr = fselect_nested(
  fselector = fs("random_search"),
  task = tsk("penguins"),
  learner = lrn("classif.rpart"),
  inner_resampling = rsmp ("holdout"),
  outer_resampling = rsmp("cv", folds = 2),
  measure = msr("classif.ce"),
  term_evals = 4)

# Performance scores estimated on the outer resampling
rr$score()

# Unbiased performance of the final model trained on the full data set
rr$aggregate()
</code></pre>

<hr>
<h2 id='FSelectInstanceBatchMultiCrit'>Class for Multi Criteria Feature Selection</h2><span id='topic+FSelectInstanceBatchMultiCrit'></span>

<h3>Description</h3>

<p>The <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> specifies a feature selection problem for a <a href="#topic+FSelector">FSelector</a>.
The function <code><a href="#topic+fsi">fsi()</a></code> creates a <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> and the function <code><a href="#topic+fselect">fselect()</a></code> creates an instance internally.
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Learn about <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-multicrit-featsel">multi-objective optimization</a>.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>


<h3>Analysis</h3>

<p>For analyzing the feature selection results, it is recommended to pass the archive to <code>as.data.table()</code>.
The returned data table is joined with the benchmark result which adds the <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> for each feature set.
</p>
<p>The archive provides various getters (e.g. <code style="white-space: pre;">&#8288;$learners()&#8288;</code>) to ease the access.
All getters extract by position (<code>i</code>) or unique hash (<code>uhash</code>).
For a complete list of all getters see the methods section.
</p>
<p>The benchmark result (<code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code>) allows to score the feature sets again on a different measure.
Alternatively, measures can be supplied to <code>as.data.table()</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatchMultiCrit">bbotk::OptimInstanceBatchMultiCrit</a></code> -&gt; <code>FSelectInstanceBatchMultiCrit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>result_feature_set</code></dt><dd><p>(list of <code>character()</code>)<br />
Feature sets for task subsetting.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectInstanceBatchMultiCrit-new"><code>FSelectInstanceBatchMultiCrit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectInstanceBatchMultiCrit-assign_result"><code>FSelectInstanceBatchMultiCrit$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectInstanceBatchMultiCrit-print"><code>FSelectInstanceBatchMultiCrit$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectInstanceBatchMultiCrit-clone"><code>FSelectInstanceBatchMultiCrit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="eval_batch"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-eval_batch'><code>bbotk::OptimInstanceBatch$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="objective_function"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-objective_function'><code>bbotk::OptimInstanceBatch$objective_function()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectInstanceBatchMultiCrit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchMultiCrit$new(
  task,
  learner,
  resampling,
  measures,
  terminator,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</dd>
<dt><code>resampling</code></dt><dd><p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</dd>
<dt><code>measures</code></dt><dd><p>(list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measures to optimize.
If <code>NULL</code>, <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>'s default measure is used.</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</dd>
<dt><code>store_benchmark_result</code></dt><dd><p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</dd>
<dt><code>store_models</code></dt><dd><p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectInstanceBatchMultiCrit-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>The <a href="#topic+FSelector">FSelector</a> object writes the best found feature subsets and estimated performance values here.
For internal use.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchMultiCrit$assign_result(xdt, ydt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code>data.table::data.table()</code>)<br />
x values as <code>data.table</code>. Each row is one point. Contains the value in
the <em>search space</em> of the <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> object. Can contain
additional columns for extra information.</p>
</dd>
<dt><code>ydt</code></dt><dd><p>(<code>data.table::data.table()</code>)<br />
Optimal outcomes, e.g. the Pareto front.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectInstanceBatchMultiCrit-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchMultiCrit$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectInstanceBatchMultiCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchMultiCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Feature selection on Palmer Penguins data set


task = tsk("penguins")

# Construct feature selection instance
instance = fsi(
  task = task,
  learner = lrn("classif.rpart"),
  resampling = rsmp("cv", folds = 3),
  measures = msrs(c("classif.ce", "time_train")),
  terminator = trm("evals", n_evals = 4)
)

# Choose optimization algorithm
fselector = fs("random_search", batch_size = 2)

# Run feature selection
fselector$optimize(instance)

# Optimal feature sets
instance$result_feature_set

# Inspect all evaluated sets
as.data.table(instance$archive)

</code></pre>

<hr>
<h2 id='FSelectInstanceBatchSingleCrit'>Class for Single Criterion Feature Selection</h2><span id='topic+FSelectInstanceBatchSingleCrit'></span>

<h3>Description</h3>

<p>The <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> specifies a feature selection problem for a <a href="#topic+FSelector">FSelector</a>.
The function <code><a href="#topic+fsi">fsi()</a></code> creates a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> and the function <code><a href="#topic+fselect">fselect()</a></code> creates an instance internally.
</p>
<p>The instance contains an <a href="#topic+ObjectiveFSelectBatch">ObjectiveFSelectBatch</a> object that encodes the black box objective function a <a href="#topic+FSelector">FSelector</a> has to optimize.
The instance allows the basic operations of querying the objective at design points (<code style="white-space: pre;">&#8288;$eval_batch()&#8288;</code>).
This operation is usually done by the <a href="#topic+FSelector">FSelector</a>.
Evaluations of feature subsets are performed in batches by calling <code><a href="mlr3.html#topic+benchmark">mlr3::benchmark()</a></code> internally.
The evaluated feature subsets are stored in the <a href="#topic+ArchiveBatchFSelect">Archive</a> (<code style="white-space: pre;">&#8288;$archive&#8288;</code>).
Before a batch is evaluated, the <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> is queried for the remaining budget.
If the available budget is exhausted, an exception is raised, and no further evaluations can be performed from this point on.
The <a href="#topic+FSelector">FSelector</a> is also supposed to store its final result, consisting of a selected feature subset and associated estimated performance values, by calling the method <code>instance$assign_result()</code>.
</p>


<h3>Default Measures</h3>

<p>If no measure is passed, the default measure is used.
The default measure depends on the task type.</p>

<table>
<tr>
 <td style="text-align: left;">
   Task </td><td style="text-align: left;"> Default Measure </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"classif"</code> </td><td style="text-align: left;"> <code>"classif.ce"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"regr"</code> </td><td style="text-align: left;"> <code>"regr.mse"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"surv"</code> </td><td style="text-align: left;"> <code>"surv.cindex"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3proba"><span class="pkg">mlr3proba</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"dens"</code> </td><td style="text-align: left;"> <code>"dens.logloss"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3proba"><span class="pkg">mlr3proba</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"classif_st"</code> </td><td style="text-align: left;"> <code>"classif.ce"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3spatial"><span class="pkg">mlr3spatial</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"regr_st"</code> </td><td style="text-align: left;"> <code>"regr.mse"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3spatial"><span class="pkg">mlr3spatial</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"clust"</code> </td><td style="text-align: left;"> <code>"clust.dunn"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3cluster"><span class="pkg">mlr3cluster</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Getting started with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-fs-wrapper">wrapper feature selection</a>.
</p>
</li>
<li><p> Do a <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-fs-wrapper-example">sequential forward selection</a> Palmer Penguins data set.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li>
<li><p> Run a feature selection with <a href="https://mlr-org.com/gallery/optimization/2023-02-01-shadow-variable-search/">Shadow Variable Search</a>.
</p>
</li>
<li> <p><a href="https://mlr-org.com/gallery/optimization/2020-09-14-mlr3fselect-basic/">Feature Selection</a> on the Titanic data set.
</p>
</li></ul>



<h3>Analysis</h3>

<p>For analyzing the feature selection results, it is recommended to pass the archive to <code>as.data.table()</code>.
The returned data table is joined with the benchmark result which adds the <a href="mlr3.html#topic+ResampleResult">mlr3::ResampleResult</a> for each feature set.
</p>
<p>The archive provides various getters (e.g. <code style="white-space: pre;">&#8288;$learners()&#8288;</code>) to ease the access.
All getters extract by position (<code>i</code>) or unique hash (<code>uhash</code>).
For a complete list of all getters see the methods section.
</p>
<p>The benchmark result (<code style="white-space: pre;">&#8288;$benchmark_result&#8288;</code>) allows to score the feature sets again on a different measure.
Alternatively, measures can be supplied to <code>as.data.table()</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+OptimInstance">bbotk::OptimInstance</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatch">bbotk::OptimInstanceBatch</a></code> -&gt; <code><a href="bbotk.html#topic+OptimInstanceBatchSingleCrit">bbotk::OptimInstanceBatchSingleCrit</a></code> -&gt; <code>FSelectInstanceBatchSingleCrit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>result_feature_set</code></dt><dd><p>(<code>character()</code>)<br />
Feature set for task subsetting.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectInstanceBatchSingleCrit-new"><code>FSelectInstanceBatchSingleCrit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectInstanceBatchSingleCrit-assign_result"><code>FSelectInstanceBatchSingleCrit$assign_result()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectInstanceBatchSingleCrit-print"><code>FSelectInstanceBatchSingleCrit$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectInstanceBatchSingleCrit-clone"><code>FSelectInstanceBatchSingleCrit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="clear"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-clear'><code>bbotk::OptimInstance$clear()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstance" data-id="format"><a href='../../bbotk/html/OptimInstance.html#method-OptimInstance-format'><code>bbotk::OptimInstance$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="eval_batch"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-eval_batch'><code>bbotk::OptimInstanceBatch$eval_batch()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="OptimInstanceBatch" data-id="objective_function"><a href='../../bbotk/html/OptimInstanceBatch.html#method-OptimInstanceBatch-objective_function'><code>bbotk::OptimInstanceBatch$objective_function()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectInstanceBatchSingleCrit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchSingleCrit$new(
  task,
  learner,
  resampling,
  measure,
  terminator,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</dd>
<dt><code>resampling</code></dt><dd><p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</dd>
<dt><code>measure</code></dt><dd><p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measure to optimize. If <code>NULL</code>, default measure is used.</p>
</dd>
<dt><code>terminator</code></dt><dd><p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</dd>
<dt><code>store_benchmark_result</code></dt><dd><p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</dd>
<dt><code>store_models</code></dt><dd><p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</dd>
<dt><code>ties_method</code></dt><dd><p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectInstanceBatchSingleCrit-assign_result"></a>



<h4>Method <code>assign_result()</code></h4>

<p>The <a href="#topic+FSelector">FSelector</a> writes the best found feature subset and estimated performance value here.
For internal use.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchSingleCrit$assign_result(xdt, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xdt</code></dt><dd><p>(<code>data.table::data.table()</code>)<br />
x values as <code>data.table</code>. Each row is one point. Contains the value in
the <em>search space</em> of the <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> object. Can contain
additional columns for extra information.</p>
</dd>
<dt><code>y</code></dt><dd><p>(<code>numeric(1)</code>)<br />
Optimal outcome.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectInstanceBatchSingleCrit-print"></a>



<h4>Method <code>print()</code></h4>

<p>Printer.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchSingleCrit$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectInstanceBatchSingleCrit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectInstanceBatchSingleCrit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># Feature selection on Palmer Penguins data set


task = tsk("penguins")
learner = lrn("classif.rpart")

# Construct feature selection instance
instance = fsi(
  task = task,
  learner = learner,
  resampling = rsmp("cv", folds = 3),
  measures = msr("classif.ce"),
  terminator = trm("evals", n_evals = 4)
)

# Choose optimization algorithm
fselector = fs("random_search", batch_size = 2)

# Run feature selection
fselector$optimize(instance)

# Subset task to optimal feature set
task$select(instance$result_feature_set)

# Train the learner with optimal feature set on the full data set
learner$train(task)

# Inspect all evaluated sets
as.data.table(instance$archive)

</code></pre>

<hr>
<h2 id='FSelector'>FSelector</h2><span id='topic+FSelector'></span>

<h3>Description</h3>

<p>The 'FSelector&ldquo; implements the optimization algorithm.
</p>


<h3>Details</h3>

<p><code>FSelector</code> is an abstract base class that implements the base functionality each fselector must provide.
</p>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Learn more about <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#the-fselector-class">fselectors</a>.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li>
<li><p> Run a feature selection with <a href="https://mlr-org.com/gallery/optimization/2023-02-01-shadow-variable-search/">Shadow Variable Search</a>.
</p>
</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier of the object.
Used in tables, plot and text output.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>param_set</code></dt><dd><p><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a><br />
Set of control parameters.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the fselector.
Must be a subset of <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$fselect_properties</a></code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
Note that these packages will be loaded via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>, and are not attached.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelector-new"><code>FSelector$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelector-format"><code>FSelector$format()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelector-print"><code>FSelector$print()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelector-help"><code>FSelector$help()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelector-clone"><code>FSelector$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FSelector-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelector$new(
  id = "fselector",
  param_set,
  properties,
  packages = character(),
  label = NA_character_,
  man = NA_character_
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>param_set</code></dt><dd><p><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a><br />
Set of control parameters.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the fselector.
Must be a subset of <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$fselect_properties</a></code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
Note that these packages will be loaded via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>, and are not attached.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelector-format"></a>



<h4>Method <code>format()</code></h4>

<p>Helper for print outputs.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelector$format(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>(ignored).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-FSelector-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelector$print()</pre></div>



<h5>Returns</h5>

<p>(<code>character()</code>).
</p>


<hr>
<a id="method-FSelector-help"></a>



<h4>Method <code>help()</code></h4>

<p>Opens the corresponding help page referenced by field <code style="white-space: pre;">&#8288;$man&#8288;</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelector$help()</pre></div>


<hr>
<a id="method-FSelector-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelector$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>

<hr>
<h2 id='FSelectorBatch'>Class for Batch Feature Selection Algorithms</h2><span id='topic+FSelectorBatch'></span>

<h3>Description</h3>

<p>The <a href="#topic+FSelectorBatch">FSelectorBatch</a> implements the optimization algorithm.
</p>


<h3>Details</h3>

<p><a href="#topic+FSelectorBatch">FSelectorBatch</a> is an abstract base class that implements the base functionality each fselector must provide.
A subclass is implemented in the following way:
</p>

<ul>
<li><p> Inherit from FSelectorBatch.
</p>
</li>
<li><p> Specify the private abstract method <code style="white-space: pre;">&#8288;$.optimize()&#8288;</code> and use it to call into your optimizer.
</p>
</li>
<li><p> You need to call <code>instance$eval_batch()</code> to evaluate design points.
</p>
</li>
<li><p> The batch evaluation is requested at the <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>/<a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> object <code>instance</code>, so each batch is possibly executed in parallel via <code><a href="mlr3.html#topic+benchmark">mlr3::benchmark()</a></code>, and all evaluations are stored inside of <code>instance$archive</code>.
</p>
</li>
<li><p> Before the batch evaluation, the <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> is checked, and if it is positive, an exception of class <code>"terminated_error"</code> is generated.
In the latter case the current batch of evaluations is still stored in <code>instance</code>, but the numeric scores are not sent back to the handling optimizer as it has lost execution control.
</p>
</li>
<li><p> After such an exception was caught we select the best set from <code>instance$archive</code> and return it.
</p>
</li>
<li><p> Note that therefore more points than specified by the <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> may be evaluated, as the Terminator is only checked before a batch evaluation, and not in-between evaluation in a batch.
How many more depends on the setting of the batch size.
</p>
</li>
<li><p> Overwrite the private super-method <code>.assign_result()</code> if you want to decide how to estimate the final set in the instance and its estimated performance.
The default behavior is: We pick the best resample experiment, regarding the given measure, then assign its set and aggregated performance to the instance.
</p>
</li></ul>



<h3>Private Methods</h3>


<ul>
<li> <p><code>.optimize(instance)</code> -&gt; <code>NULL</code><br />
Abstract base method. Implement to specify feature selection of your subclass.
See technical details sections.
</p>
</li>
<li> <p><code>.assign_result(instance)</code> -&gt; <code>NULL</code><br />
Abstract base method. Implement to specify how the final feature subset is selected.
See technical details sections.
</p>
</li></ul>



<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Learn more about <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#the-fselector-class">fselectors</a>.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li>
<li><p> Run a feature selection with <a href="https://mlr-org.com/gallery/optimization/2023-02-01-shadow-variable-search/">Shadow Variable Search</a>.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code>FSelectorBatch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatch-new"><code>FSelectorBatch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatch-optimize"><code>FSelectorBatch$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatch-clone"><code>FSelectorBatch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatch$new(
  id = "fselector_batch",
  param_set,
  properties,
  packages = character(),
  label = NA_character_,
  man = NA_character_
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>param_set</code></dt><dd><p><a href="paradox.html#topic+ParamSet">paradox::ParamSet</a><br />
Set of control parameters.</p>
</dd>
<dt><code>properties</code></dt><dd><p>(<code>character()</code>)<br />
Set of properties of the fselector.
Must be a subset of <code><a href="mlr3.html#topic+mlr_reflections">mlr_reflections$fselect_properties</a></code>.</p>
</dd>
<dt><code>packages</code></dt><dd><p>(<code>character()</code>)<br />
Set of required packages.
Note that these packages will be loaded via <code><a href="base.html#topic+requireNamespace">requireNamespace()</a></code>, and are not attached.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for this object.
Can be used in tables, plot and text output instead of the ID.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectorBatch-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Performs the feature selection on a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> or <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> until termination.
The single evaluations will be written into the <a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> that resides in the <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> / <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
The result will be written into the instance object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatch$optimize(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> | <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>.
</p>


<hr>
<a id="method-FSelectorBatch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='FSelectorBatchFromOptimizerBatch'>FSelectorBatchFromOptimizerBatch</h2><span id='topic+FSelectorBatchFromOptimizerBatch'></span>

<h3>Description</h3>

<p>Internally used to transform <a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a> to <a href="#topic+FSelector">FSelector</a>.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchFromOptimizerBatch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchFromOptimizerBatch-new"><code>FSelectorBatchFromOptimizerBatch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchFromOptimizerBatch-optimize"><code>FSelectorBatchFromOptimizerBatch$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchFromOptimizerBatch-clone"><code>FSelectorBatchFromOptimizerBatch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchFromOptimizerBatch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchFromOptimizerBatch$new(optimizer, man = NA_character_)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optimizer</code></dt><dd><p><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a><br />
Optimizer that is called.</p>
</dd>
<dt><code>man</code></dt><dd><p>(<code>character(1)</code>)<br />
String in the format <code style="white-space: pre;">&#8288;[pkg]::[topic]&#8288;</code> pointing to a manual page for this object.
The referenced help package can be opened via method <code style="white-space: pre;">&#8288;$help()&#8288;</code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FSelectorBatchFromOptimizerBatch-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>Performs the feature selection on a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> /
<a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a> until termination.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchFromOptimizerBatch$optimize(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> | <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>.
</p>


<hr>
<a id="method-FSelectorBatchFromOptimizerBatch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchFromOptimizerBatch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='fsi'>Syntactic Sugar for Instance Construction</h2><span id='topic+fsi'></span>

<h3>Description</h3>

<p>Function to construct a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> or <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsi(
  task,
  learner,
  resampling,
  measures = NULL,
  terminator,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  check_values = FALSE,
  callbacks = NULL,
  ties_method = "least_features"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsi_+3A_task">task</code></td>
<td>
<p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</td></tr>
<tr><td><code id="fsi_+3A_learner">learner</code></td>
<td>
<p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</td></tr>
<tr><td><code id="fsi_+3A_resampling">resampling</code></td>
<td>
<p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</td></tr>
<tr><td><code id="fsi_+3A_measures">measures</code></td>
<td>
<p>(<a href="mlr3.html#topic+Measure">mlr3::Measure</a> or list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
A single measure creates a <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> and multiple measures a <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
If <code>NULL</code>, default measure is used.</p>
</td></tr>
<tr><td><code id="fsi_+3A_terminator">terminator</code></td>
<td>
<p>(<a href="bbotk.html#topic+Terminator">bbotk::Terminator</a>)<br />
Stop criterion of the feature selection.</p>
</td></tr>
<tr><td><code id="fsi_+3A_store_benchmark_result">store_benchmark_result</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</td></tr>
<tr><td><code id="fsi_+3A_store_models">store_models</code></td>
<td>
<p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</td></tr>
<tr><td><code id="fsi_+3A_check_values">check_values</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</td></tr>
<tr><td><code id="fsi_+3A_callbacks">callbacks</code></td>
<td>
<p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</td></tr>
<tr><td><code id="fsi_+3A_ties_method">ties_method</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The method to break ties when selecting sets while optimizing and when selecting the best set.
Can be <code>"least_features"</code> or <code>"random"</code>.
The option <code>"least_features"</code> (default) selects the feature set with the least features.
If there are multiple best feature sets with the same number of features, one is selected randomly.
The <code>random</code> method returns a random feature set from the best feature sets.
Ignored if multiple measures are used.</p>
</td></tr>
</table>


<h3>Resources</h3>

<p>There are several sections about feature selection in the <a href="https://mlr3book.mlr-org.com">mlr3book</a>.
</p>

<ul>
<li><p> Getting started with <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-fs-wrapper">wrapper feature selection</a>.
</p>
</li>
<li><p> Do a <a href="https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-fs-wrapper-example">sequential forward selection</a> Palmer Penguins data set.
</p>
</li></ul>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li>
<li><p> Run a feature selection with <a href="https://mlr-org.com/gallery/optimization/2023-02-01-shadow-variable-search/">Shadow Variable Search</a>.
</p>
</li>
<li> <p><a href="https://mlr-org.com/gallery/optimization/2020-09-14-mlr3fselect-basic/">Feature Selection</a> on the Titanic data set.
</p>
</li></ul>



<h3>Default Measures</h3>

<p>If no measure is passed, the default measure is used.
The default measure depends on the task type.</p>

<table>
<tr>
 <td style="text-align: left;">
   Task </td><td style="text-align: left;"> Default Measure </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"classif"</code> </td><td style="text-align: left;"> <code>"classif.ce"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"regr"</code> </td><td style="text-align: left;"> <code>"regr.mse"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"surv"</code> </td><td style="text-align: left;"> <code>"surv.cindex"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3proba"><span class="pkg">mlr3proba</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"dens"</code> </td><td style="text-align: left;"> <code>"dens.logloss"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3proba"><span class="pkg">mlr3proba</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"classif_st"</code> </td><td style="text-align: left;"> <code>"classif.ce"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3spatial"><span class="pkg">mlr3spatial</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"regr_st"</code> </td><td style="text-align: left;"> <code>"regr.mse"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3spatial"><span class="pkg">mlr3spatial</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>"clust"</code> </td><td style="text-align: left;"> <code>"clust.dunn"</code> </td><td style="text-align: left;"> <a href="https://CRAN.R-project.org/package=mlr3cluster"><span class="pkg">mlr3cluster</span></a> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># Feature selection on Palmer Penguins data set


task = tsk("penguins")
learner = lrn("classif.rpart")

# Construct feature selection instance
instance = fsi(
  task = task,
  learner = learner,
  resampling = rsmp("cv", folds = 3),
  measures = msr("classif.ce"),
  terminator = trm("evals", n_evals = 4)
)

# Choose optimization algorithm
fselector = fs("random_search", batch_size = 2)

# Run feature selection
fselector$optimize(instance)

# Subset task to optimal feature set
task$select(instance$result_feature_set)

# Train the learner with optimal feature set on the full data set
learner$train(task)

# Inspect all evaluated sets
as.data.table(instance$archive)

</code></pre>

<hr>
<h2 id='mlr_fselectors'>Dictionary of FSelectors</h2><span id='topic+mlr_fselectors'></span>

<h3>Description</h3>

<p>A <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> storing objects of class <a href="#topic+FSelector">FSelector</a>.
Each fselector has an associated help page, see <code>mlr_fselectors_[id]</code>.
</p>
<p>For a more convenient way to retrieve and construct fselectors, see <code><a href="#topic+fs">fs()</a></code>/<code><a href="#topic+fss">fss()</a></code>.
</p>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> object inheriting from <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>Methods</h3>

<p>See <a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a>.
</p>


<h3>S3 methods</h3>


<ul>
<li> <p><code>as.data.table(dict, ..., objects = FALSE)</code><br />
<a href="mlr3misc.html#topic+Dictionary">mlr3misc::Dictionary</a> -&gt; <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code><br />
Returns a <code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code> with fields &quot;key&quot;, &quot;label&quot;, &quot;properties&quot; and &quot;packages&quot; as columns.
If <code>objects</code> is set to <code>TRUE</code>, the constructed objects are returned in the list column named <code>object</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Sugar functions: <code><a href="#topic+fs">fs()</a></code>, <code><a href="#topic+fss">fss()</a></code>
</p>
<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.data.table(mlr_fselectors)
mlr_fselectors$get("random_search")
fs("random_search")
</code></pre>

<hr>
<h2 id='mlr_fselectors_design_points'>Feature Selection with Design Points</h2><span id='topic+mlr_fselectors_design_points'></span><span id='topic+FSelectorBatchDesignPoints'></span>

<h3>Description</h3>

<p>Feature selection using user-defined feature sets.
</p>


<h3>Details</h3>

<p>The feature sets are evaluated in order as given.
</p>
<p>The feature selection terminates itself when all feature sets are evaluated.
It is not necessary to set a termination criterion.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("design_points")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>batch_size</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of configurations to try in a batch.</p>
</dd>
<dt><code>design</code></dt><dd><p><a href="data.table.html#topic+data.table">data.table::data.table</a><br />
Design points to try in search, one per row.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code><a href="#topic+FSelectorBatchFromOptimizerBatch">mlr3fselect::FSelectorBatchFromOptimizerBatch</a></code> -&gt; <code>FSelectorBatchDesignPoints</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchDesignPoints-new"><code>FSelectorBatchDesignPoints$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchDesignPoints-clone"><code>FSelectorBatchDesignPoints$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatchFromOptimizerBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatchFromOptimizerBatch.html#method-FSelectorBatchFromOptimizerBatch-optimize'><code>mlr3fselect::FSelectorBatchFromOptimizerBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchDesignPoints-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchDesignPoints$new()</pre></div>


<hr>
<a id="method-FSelectorBatchDesignPoints-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchDesignPoints$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("pima")
learner = lrn("classif.rpart")

# create design
design = mlr3misc::rowwise_table(
  ~age, ~glucose, ~insulin, ~mass, ~pedigree, ~pregnant, ~pressure, ~triceps,
  TRUE, FALSE,    TRUE,     TRUE,  FALSE,     TRUE,       FALSE,    TRUE,
  TRUE, TRUE,     FALSE,    TRUE,  FALSE,     TRUE,       FALSE,    FALSE,
  TRUE, FALSE,    TRUE,     TRUE,  FALSE,     TRUE,       FALSE,    FALSE,
  TRUE, FALSE,    TRUE,     TRUE,  FALSE,     TRUE,       TRUE,     TRUE
)

# run feature selection on the Pima Indians diabetes data set
instance = fselect(
  fselector = fs("design_points", design = design),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce")
)

# best performing feature set
instance$result

# all evaluated feature sets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_exhaustive_search'>Feature Selection with Exhaustive Search</h2><span id='topic+mlr_fselectors_exhaustive_search'></span><span id='topic+FSelectorBatchExhaustiveSearch'></span>

<h3>Description</h3>

<p>Feature Selection using the Exhaustive Search Algorithm.
Exhaustive Search generates all possible feature sets.
</p>


<h3>Details</h3>

<p>The feature selection terminates itself when all feature sets are evaluated.
It is not necessary to set a termination criterion.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("exhaustive_search")
</pre></div>


<h3>Control Parameters</h3>


<dl>
<dt><code>max_features</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of features.
By default, number of features in <a href="mlr3.html#topic+Task">mlr3::Task</a>.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchExhaustiveSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchExhaustiveSearch-new"><code>FSelectorBatchExhaustiveSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchExhaustiveSearch-clone"><code>FSelectorBatchExhaustiveSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchExhaustiveSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchExhaustiveSearch$new()</pre></div>


<hr>
<a id="method-FSelectorBatchExhaustiveSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchExhaustiveSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("exhaustive_search"),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
  term_evals = 10
)

# best performing feature set
instance$result

# all evaluated feature sets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_genetic_search'>Feature Selection with Genetic Search</h2><span id='topic+mlr_fselectors_genetic_search'></span><span id='topic+FSelectorBatchGeneticSearch'></span>

<h3>Description</h3>

<p>Feature selection using the Genetic Algorithm from the package <a href="https://CRAN.R-project.org/package=genalg"><span class="pkg">genalg</span></a>.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("genetic_search")
</pre></div>


<h3>Control Parameters</h3>

<p>For the meaning of the control parameters, see <code><a href="genalg.html#topic+rbga.bin">genalg::rbga.bin()</a></code>.
<code><a href="genalg.html#topic+rbga.bin">genalg::rbga.bin()</a></code> internally terminates after <code>iters</code> iteration.
We set <code>ìters = 100000</code>  to allow the termination via our terminators.
If more iterations are needed, set <code>ìters</code> to a higher value in the parameter set.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchGeneticSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchGeneticSearch-new"><code>FSelectorBatchGeneticSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchGeneticSearch-clone"><code>FSelectorBatchGeneticSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchGeneticSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchGeneticSearch$new()</pre></div>


<hr>
<a id="method-FSelectorBatchGeneticSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchGeneticSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("genetic_search"),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
  term_evals = 10
)

# best performing feature set
instance$result

# all evaluated feature sets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_random_search'>Feature Selection with Random Search</h2><span id='topic+mlr_fselectors_random_search'></span><span id='topic+FSelectorBatchRandomSearch'></span>

<h3>Description</h3>

<p>Feature selection using Random Search Algorithm.
</p>


<h3>Details</h3>

<p>The feature sets are randomly drawn.
The sets are evaluated in batches of size <code>batch_size</code>.
Larger batches mean we can parallelize more, smaller batches imply a more fine-grained checking of termination criteria.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("random_search")
</pre></div>


<h3>Control Parameters</h3>


<dl>
<dt><code>max_features</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of features.
By default, number of features in <a href="mlr3.html#topic+Task">mlr3::Task</a>.</p>
</dd>
<dt><code>batch_size</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of feature sets to try in a batch.</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchRandomSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchRandomSearch-new"><code>FSelectorBatchRandomSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchRandomSearch-clone"><code>FSelectorBatchRandomSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchRandomSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchRandomSearch$new()</pre></div>


<hr>
<a id="method-FSelectorBatchRandomSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchRandomSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Bergstra J, Bengio Y (2012).
&ldquo;Random Search for Hyper-Parameter Optimization.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>13</b>(10), 281&ndash;305.
<a href="https://jmlr.csail.mit.edu/papers/v13/bergstra12a.html">https://jmlr.csail.mit.edu/papers/v13/bergstra12a.html</a>.
</p>


<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("random_search"),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
  term_evals = 10
)

# best performing feature subset
instance$result

# all evaluated feature subsets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_rfe'>Feature Selection with Recursive Feature Elimination</h2><span id='topic+mlr_fselectors_rfe'></span><span id='topic+FSelectorBatchRFE'></span>

<h3>Description</h3>

<p>Feature selection using the Recursive Feature Elimination (RFE) algorithm.
Recursive feature elimination iteratively removes features with a low importance score.
Only works with <a href="mlr3.html#topic+Learner">mlr3::Learner</a>s that can calculate importance scores (see the section on optional extractors in <a href="mlr3.html#topic+Learner">mlr3::Learner</a>).
</p>


<h3>Details</h3>

<p>The learner is trained on all features at the start and importance scores are calculated for each feature.
Then the least important feature is removed and the learner is trained on the reduced feature set.
The importance scores are calculated again and the procedure is repeated until the desired number of features is reached.
The non-recursive option (<code>recursive = FALSE</code>) only uses the importance scores calculated in the first iteration.
</p>
<p>The feature selection terminates itself when <code>n_features</code> is reached.
It is not necessary to set a termination criterion.
</p>
<p>When using a cross-validation resampling strategy, the importance scores of the resampling iterations are aggregated.
The parameter <code>aggregation</code> determines how the importance scores are aggregated.
By default (<code>"rank"</code>), the importance score vector of each fold is ranked and the feature with the lowest average rank is removed.
The option <code>"mean"</code> averages the score of each feature across the resampling iterations and removes the feature with the lowest average score.
Averaging the scores is not appropriate for most importance measures.
</p>


<h3>Archive</h3>

<p>The <a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> holds the following additional columns:
</p>

<ul>
<li> <p><code>"importance"</code> (<code>numeric()</code>)<br />
The importance score vector of the feature subset.
</p>
</li></ul>



<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li></ul>



<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("rfe")
</pre></div>


<h3>Control Parameters</h3>


<dl>
<dt><code>n_features</code></dt><dd><p><code>integer(1)</code><br />
The minimum number of features to select, by default half of the features.</p>
</dd>
<dt><code>feature_fraction</code></dt><dd><p><code>double(1)</code><br />
Fraction of features to retain in each iteration.
The default of 0.5 retains half of the features.</p>
</dd>
<dt><code>feature_number</code></dt><dd><p><code>integer(1)</code><br />
Number of features to remove in each iteration.</p>
</dd>
<dt><code>subset_sizes</code></dt><dd><p><code>integer()</code><br />
Vector of the number of features to retain in each iteration.
Must be sorted in decreasing order.</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical(1)</code><br />
If <code>TRUE</code> (default), the feature importance is calculated in each iteration.</p>
</dd>
<dt><code>aggregation</code></dt><dd><p><code>character(1)</code><br />
The aggregation method for the importance scores of the resampling iterations.
See details.
</p>
</dd>
</dl>

<p>The parameter <code>feature_fraction</code>, <code>feature_number</code> and <code>subset_sizes</code> are mutually exclusive.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchRFE</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchRFE-new"><code>FSelectorBatchRFE$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchRFE-clone"><code>FSelectorBatchRFE$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchRFE-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchRFE$new()</pre></div>


<hr>
<a id="method-FSelectorBatchRFE-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchRFE$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Guyon I, Weston J, Barnhill S, Vapnik V (2002).
&ldquo;Gene Selection for Cancer Classification using Support Vector Machines.&rdquo;
<em>Machine Learning</em>, <b>46</b>(1), 389&ndash;422.
ISSN 1573-0565, <a href="https://doi.org/10.1023/A%3A1012487302797">doi:10.1023/A:1012487302797</a>.
</p>


<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("rfe"),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
  store_models = TRUE
)

# best performing feature subset
instance$result

# all evaluated feature subsets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_rfecv'>Feature Selection with Recursive Feature Elimination with Cross Validation</h2><span id='topic+mlr_fselectors_rfecv'></span><span id='topic+FSelectorBatchRFECV'></span>

<h3>Description</h3>

<p>Feature selection using the Recursive Feature Elimination with Cross-Validation (RFE-CV) algorithm.
See <a href="#topic+FSelectorBatchRFE">FSelectorBatchRFE</a> for a description of the base algorithm.
RFE-CV runs a recursive feature elimination in each iteration of a cross-validation to determine the optimal number of features.
Then a recursive feature elimination is run again on the complete dataset with the optimal number of features as the final feature set size.
The performance of the optimal feature set is calculated on the complete data set and should not be reported as the performance of the final model.
Only works with <a href="mlr3.html#topic+Learner">mlr3::Learner</a>s that can calculate importance scores (see the section on optional extractors in <a href="mlr3.html#topic+Learner">mlr3::Learner</a>).
</p>


<h3>Details</h3>

<p>The resampling strategy is changed during the feature selection.
The resampling strategy passed to the instance (<code>resampling</code>) is used to determine the optimal number of features.
Usually, a cross-validation strategy is used and a recursive feature elimination is run in each iteration of the cross-validation.
Internally, <a href="mlr3.html#topic+mlr_resamplings_custom">mlr3::ResamplingCustom</a> is used to emulate this part of the algorithm.
In the final recursive feature elimination run the resampling strategy is changed to <a href="mlr3.html#topic+mlr_resamplings_insample">mlr3::ResamplingInsample</a> i.e. the complete data set is used for training and testing.
</p>
<p>The feature selection terminates itself when the optimal number of features is reached.
It is not necessary to set a termination criterion.
</p>


<h3>Archive</h3>

<p>The <a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a> holds the following additional columns:
</p>

<ul>
<li> <p><code>"iteration"</code> (<code>integer(1)</code>)<br />
The resampling iteration in which the feature subset was evaluated.
</p>
</li>
<li> <p><code>"importance"</code> (<code>numeric()</code>)<br />
The importance score vector of the feature subset.
</p>
</li></ul>



<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Utilize the built-in feature importance of models with <a href="https://mlr-org.com/gallery/optimization/2023-02-07-recursive-feature-elimination/">Recursive Feature Elimination</a>.
</p>
</li></ul>



<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("rfe")
</pre></div>


<h3>Control Parameters</h3>


<dl>
<dt><code>n_features</code></dt><dd><p><code>integer(1)</code><br />
The number of features to select.
By default half of the features are selected.</p>
</dd>
<dt><code>feature_fraction</code></dt><dd><p><code>double(1)</code><br />
Fraction of features to retain in each iteration.
The default 0.5 retrains half of the features.</p>
</dd>
<dt><code>feature_number</code></dt><dd><p><code>integer(1)</code><br />
Number of features to remove in each iteration.</p>
</dd>
<dt><code>subset_sizes</code></dt><dd><p><code>integer()</code><br />
Vector of number of features to retain in each iteration.
Must be sorted in decreasing order.</p>
</dd>
<dt><code>recursive</code></dt><dd><p><code>logical(1)</code><br />
If <code>TRUE</code> (default), the feature importance is calculated in each iteration.</p>
</dd>
</dl>

<p>The parameter <code>feature_fraction</code>, <code>feature_number</code> and <code>subset_sizes</code> are mutually exclusive.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchRFECV</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchRFECV-new"><code>FSelectorBatchRFECV$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchRFECV-clone"><code>FSelectorBatchRFECV$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchRFECV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchRFECV$new()</pre></div>


<hr>
<a id="method-FSelectorBatchRFECV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchRFECV$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("rfecv"),
  task = task,
  learner = learner,
  resampling = rsmp("cv", folds = 3),
  measure = msr("classif.ce"),
  store_models = TRUE
)

# best performing feature subset
instance$result

# all evaluated feature subsets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_sequential'>Feature Selection with Sequential Search</h2><span id='topic+mlr_fselectors_sequential'></span><span id='topic+FSelectorBatchSequential'></span>

<h3>Description</h3>

<p>Feature selection using Sequential Search Algorithm.
</p>


<h3>Details</h3>

<p>Sequential forward selection (<code>strategy = fsf</code>) extends the feature set in each iteration with the feature that increases the model's performance the most.
Sequential backward selection (<code>strategy = fsb</code>) follows the same idea but starts with all features and removes features from the set.
</p>
<p>The feature selection terminates itself when <code>min_features</code> or <code>max_features</code> is reached.
It is not necessary to set a termination criterion.
</p>


<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("sequential")
</pre></div>


<h3>Control Parameters</h3>


<dl>
<dt><code>min_features</code></dt><dd><p><code>integer(1)</code><br />
Minimum number of features. By default, 1.</p>
</dd>
<dt><code>max_features</code></dt><dd><p><code>integer(1)</code><br />
Maximum number of features. By default, number of features in <a href="mlr3.html#topic+Task">mlr3::Task</a>.</p>
</dd>
<dt><code>strategy</code></dt><dd><p><code>character(1)</code><br />
Search method <code>sfs</code> (forward search) or <code>sbs</code> (backward search).</p>
</dd>
</dl>



<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchSequential</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchSequential-new"><code>FSelectorBatchSequential$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchSequential-optimization_path"><code>FSelectorBatchSequential$optimization_path()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchSequential-clone"><code>FSelectorBatchSequential$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchSequential-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.'
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchSequential$new()</pre></div>


<hr>
<a id="method-FSelectorBatchSequential-optimization_path"></a>



<h4>Method <code>optimization_path()</code></h4>

<p>Returns the optimization path.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchSequential$optimization_path(inst, include_uhash = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>)<br />
Instance optimized with <a href="#topic+FSelectorBatchSequential">FSelectorBatchSequential</a>.</p>
</dd>
<dt><code>include_uhash</code></dt><dd><p>(<code>logical(1)</code>)<br />
Include <code>uhash</code> column?</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-FSelectorBatchSequential-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchSequential$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_shadow_variable_search">mlr_fselectors_shadow_variable_search</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("sequential"),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
  term_evals = 10
)

# best performing feature set
instance$result

# all evaluated feature sets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr_fselectors_shadow_variable_search'>Feature Selection with Shadow Variable Search</h2><span id='topic+mlr_fselectors_shadow_variable_search'></span><span id='topic+FSelectorBatchShadowVariableSearch'></span>

<h3>Description</h3>

<p>Feature selection using the Shadow Variable Search Algorithm.
Shadow variable search creates for each feature a permutated copy and stops when one of them is selected.
</p>


<h3>Details</h3>

<p>The feature selection terminates itself when the first shadow variable is selected.
It is not necessary to set a termination criterion.
</p>


<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li><p> Run a feature selection with <a href="https://mlr-org.com/gallery/optimization/2023-02-01-shadow-variable-search/">Shadow Variable Search</a>.
</p>
</li></ul>



<h3>Dictionary</h3>

<p>This <a href="#topic+FSelector">FSelector</a> can be instantiated with the associated sugar function <code><a href="#topic+fs">fs()</a></code>:
</p>
<div class="sourceCode"><pre>fs("shadow_variable_search")
</pre></div>


<h3>Super classes</h3>

<p><code><a href="#topic+FSelector">mlr3fselect::FSelector</a></code> -&gt; <code><a href="#topic+FSelectorBatch">mlr3fselect::FSelectorBatch</a></code> -&gt; <code>FSelectorBatchShadowVariableSearch</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FSelectorBatchShadowVariableSearch-new"><code>FSelectorBatchShadowVariableSearch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchShadowVariableSearch-optimization_path"><code>FSelectorBatchShadowVariableSearch$optimization_path()</code></a>
</p>
</li>
<li> <p><a href="#method-FSelectorBatchShadowVariableSearch-clone"><code>FSelectorBatchShadowVariableSearch$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="format"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-format'><code>mlr3fselect::FSelector$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="help"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-help'><code>mlr3fselect::FSelector$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelector" data-id="print"><a href='../../mlr3fselect/html/FSelector.html#method-FSelector-print'><code>mlr3fselect::FSelector$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3fselect" data-topic="FSelectorBatch" data-id="optimize"><a href='../../mlr3fselect/html/FSelectorBatch.html#method-FSelectorBatch-optimize'><code>mlr3fselect::FSelectorBatch$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-FSelectorBatchShadowVariableSearch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.'
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchShadowVariableSearch$new()</pre></div>


<hr>
<a id="method-FSelectorBatchShadowVariableSearch-optimization_path"></a>



<h4>Method <code>optimization_path()</code></h4>

<p>Returns the optimization path.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchShadowVariableSearch$optimization_path(inst)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inst</code></dt><dd><p>(<a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a>)<br />
Instance optimized with <a href="#topic+FSelectorBatchShadowVariableSearch">FSelectorBatchShadowVariableSearch</a>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><a href="data.table.html#topic+data.table">data.table::data.table</a>
</p>


<hr>
<a id="method-FSelectorBatchShadowVariableSearch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FSelectorBatchShadowVariableSearch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Thomas J, Hepp T, Mayr A, Bischl B (2017).
&ldquo;Probing for Sparse and Fast Variable Selection with Model-Based Boosting.&rdquo;
<em>Computational and Mathematical Methods in Medicine</em>, <b>2017</b>, 1&ndash;8.
<a href="https://doi.org/10.1155/2017/1421409">doi:10.1155/2017/1421409</a>.
</p>
<p>Wu Y, Boos DD, Stefanski LA (2007).
&ldquo;Controlling Variable Selection by the Addition of Pseudovariables.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>102</b>(477), 235&ndash;243.
<a href="https://doi.org/10.1198/016214506000000843">doi:10.1198/016214506000000843</a>.
</p>


<h3>See Also</h3>

<p>Other FSelector: 
<code><a href="#topic+FSelector">FSelector</a></code>,
<code><a href="#topic+mlr_fselectors">mlr_fselectors</a></code>,
<code><a href="#topic+mlr_fselectors_design_points">mlr_fselectors_design_points</a></code>,
<code><a href="#topic+mlr_fselectors_exhaustive_search">mlr_fselectors_exhaustive_search</a></code>,
<code><a href="#topic+mlr_fselectors_genetic_search">mlr_fselectors_genetic_search</a></code>,
<code><a href="#topic+mlr_fselectors_random_search">mlr_fselectors_random_search</a></code>,
<code><a href="#topic+mlr_fselectors_rfe">mlr_fselectors_rfe</a></code>,
<code><a href="#topic+mlr_fselectors_rfecv">mlr_fselectors_rfecv</a></code>,
<code><a href="#topic+mlr_fselectors_sequential">mlr_fselectors_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Feature Selection


# retrieve task and load learner
task = tsk("penguins")
learner = lrn("classif.rpart")

# run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("shadow_variable_search"),
  task = task,
  learner = learner,
  resampling = rsmp("holdout"),
  measure = msr("classif.ce"),
)

# best performing feature subset
instance$result

# all evaluated feature subsets
as.data.table(instance$archive)

# subset the task and fit the final model
task$select(instance$result_feature_set)
learner$train(task)

</code></pre>

<hr>
<h2 id='mlr3fselect_assertions'>Assertion for mlr3fselect objects</h2><span id='topic+mlr3fselect_assertions'></span><span id='topic+assert_fselectors'></span><span id='topic+assert_fselector_async'></span><span id='topic+assert_fselector_batch'></span><span id='topic+assert_fselect_instance'></span><span id='topic+assert_fselect_instance_async'></span><span id='topic+assert_fselect_instance_batch'></span>

<h3>Description</h3>

<p>Most assertion functions ensure the right class attribute, and optionally additional properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_fselectors(fselectors)

assert_fselector_async(fselector)

assert_fselector_batch(fselector)

assert_fselect_instance(inst)

assert_fselect_instance_async(inst)

assert_fselect_instance_batch(inst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlr3fselect_assertions_+3A_fselectors">fselectors</code></td>
<td>
<p>(list of <a href="#topic+FSelector">FSelector</a>).</p>
</td></tr>
<tr><td><code id="mlr3fselect_assertions_+3A_fselector">fselector</code></td>
<td>
<p>(<a href="#topic+FSelectorBatch">FSelectorBatch</a>).</p>
</td></tr>
<tr><td><code id="mlr3fselect_assertions_+3A_inst">inst</code></td>
<td>
<p>(<a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> | <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>).</p>
</td></tr>
</table>

<hr>
<h2 id='mlr3fselect.backup'>Backup Benchmark Result Callback</h2><span id='topic+mlr3fselect.backup'></span>

<h3>Description</h3>

<p>This <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a> writes the <a href="mlr3.html#topic+BenchmarkResult">mlr3::BenchmarkResult</a> after each batch to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clbk("mlr3fselect.backup", path = "backup.rds")

# Run feature selection on the Palmer Penguins data set
instance = fselect(
  fselector = fs("random_search"),
  task = tsk("pima"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("holdout"),
  measures = msr("classif.ce"),
  term_evals = 4,
  callbacks = clbk("mlr3fselect.backup", path = tempfile(fileext = ".rds")))
</code></pre>

<hr>
<h2 id='mlr3fselect.one_se_rule'>One Standard Error Rule Callback</h2><span id='topic+mlr3fselect.one_se_rule'></span>

<h3>Description</h3>

<p>Selects the smallest feature set within one standard error of the best as the result.
If there are multiple such feature sets with the same number of features, the first one is selected.
If the sets have exactly the same performance but different number of features,
the one with the smallest number of features is selected.
</p>


<h3>Source</h3>

<p>Kuhn, Max, Johnson, Kjell (2013).
&ldquo;Applied Predictive Modeling.&rdquo;
In chapter Over-Fitting and Model Tuning, 61&ndash;92.
Springer New York, New York, NY.
ISBN 978-1-4614-6849-3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clbk("mlr3fselect.one_se_rule")

# Run feature selection on the pima data set with the callback
instance = fselect(
  fselector = fs("random_search"),
  task = tsk("pima"),
  learner = lrn("classif.rpart"),
  resampling = rsmp ("cv", folds = 3),
  measures = msr("classif.ce"),
  term_evals = 10,
  callbacks = clbk("mlr3fselect.one_se_rule"))
# Smallest feature set within one standard error of the best
instance$result
</code></pre>

<hr>
<h2 id='mlr3fselect.svm_rfe'>SVM-RFE Callback</h2><span id='topic+mlr3fselect.svm_rfe'></span>

<h3>Description</h3>

<p>Runs a recursive feature elimination with a <a href="mlr3learners.html#topic+mlr_learners_classif.svm">mlr3learners::LearnerClassifSVM</a>.
The SVM must be configured with <code>type = "C-classification"</code> and <code>kernel = "linear"</code>.
</p>


<h3>Source</h3>

<p>Guyon I, Weston J, Barnhill S, Vapnik V (2002).
&ldquo;Gene Selection for Cancer Classification using Support Vector Machines.&rdquo;
<em>Machine Learning</em>, <b>46</b>(1), 389&ndash;422.
ISSN 1573-0565, <a href="https://doi.org/10.1023/A%3A1012487302797">doi:10.1023/A:1012487302797</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clbk("mlr3fselect.svm_rfe")

library(mlr3learners)

# Create instance with classification svm with linear kernel
instance = fsi(
  task = tsk("sonar"),
  learner = lrn("classif.svm", type = "C-classification", kernel = "linear"),
  resampling = rsmp("cv", folds = 3),
  measures = msr("classif.ce"),
  terminator = trm("none"),
  callbacks = clbk("mlr3fselect.svm_rfe"),
  store_models = TRUE
)

fselector = fs("rfe", feature_number = 5, n_features = 10)

# Run recursive feature elimination on the Sonar data set
fselector$optimize(instance)
</code></pre>

<hr>
<h2 id='ObjectiveFSelect'>Class for Feature Selection Objective</h2><span id='topic+ObjectiveFSelect'></span>

<h3>Description</h3>

<p>Stores the objective function that estimates the performance of feature subsets.
This class is usually constructed internally by the <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> / <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
</p>


<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code>ObjectiveFSelect</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>task</code></dt><dd><p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>).</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>).</p>
</dd>
<dt><code>resampling</code></dt><dd><p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>).</p>
</dd>
<dt><code>measures</code></dt><dd><p>(list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>).</p>
</dd>
<dt><code>store_models</code></dt><dd><p>(<code>logical(1)</code>).</p>
</dd>
<dt><code>store_benchmark_result</code></dt><dd><p>(<code>logical(1)</code>).</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(List of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>s).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ObjectiveFSelect-new"><code>ObjectiveFSelect$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveFSelect-clone"><code>ObjectiveFSelect$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_dt"><a href='../../bbotk/html/Objective.html#method-Objective-eval_dt'><code>bbotk::Objective$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_many"><a href='../../bbotk/html/Objective.html#method-Objective-eval_many'><code>bbotk::Objective$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ObjectiveFSelect-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveFSelect$new(
  task,
  learner,
  resampling,
  measures,
  check_values = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  callbacks = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</dd>
<dt><code>resampling</code></dt><dd><p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</dd>
<dt><code>measures</code></dt><dd><p>(list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measures to optimize.
If <code>NULL</code>, <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>'s default measure is used.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</dd>
<dt><code>store_benchmark_result</code></dt><dd><p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</dd>
<dt><code>store_models</code></dt><dd><p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ObjectiveFSelect-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveFSelect$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ObjectiveFSelectBatch'>Class for Feature Selection Objective</h2><span id='topic+ObjectiveFSelectBatch'></span>

<h3>Description</h3>

<p>Stores the objective function that estimates the performance of feature subsets.
This class is usually constructed internally by the <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> / <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
</p>


<h3>Super classes</h3>

<p><code><a href="bbotk.html#topic+Objective">bbotk::Objective</a></code> -&gt; <code><a href="#topic+ObjectiveFSelect">mlr3fselect::ObjectiveFSelect</a></code> -&gt; <code>ObjectiveFSelectBatch</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a>).</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ObjectiveFSelectBatch-new"><code>ObjectiveFSelectBatch$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ObjectiveFSelectBatch-clone"><code>ObjectiveFSelectBatch$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval"><a href='../../bbotk/html/Objective.html#method-Objective-eval'><code>bbotk::Objective$eval()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_dt"><a href='../../bbotk/html/Objective.html#method-Objective-eval_dt'><code>bbotk::Objective$eval_dt()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="eval_many"><a href='../../bbotk/html/Objective.html#method-Objective-eval_many'><code>bbotk::Objective$eval_many()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="format"><a href='../../bbotk/html/Objective.html#method-Objective-format'><code>bbotk::Objective$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="help"><a href='../../bbotk/html/Objective.html#method-Objective-help'><code>bbotk::Objective$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Objective" data-id="print"><a href='../../bbotk/html/Objective.html#method-Objective-print'><code>bbotk::Objective$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ObjectiveFSelectBatch-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveFSelectBatch$new(
  task,
  learner,
  resampling,
  measures,
  check_values = TRUE,
  store_benchmark_result = TRUE,
  store_models = FALSE,
  archive = NULL,
  callbacks = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p>(<a href="mlr3.html#topic+Task">mlr3::Task</a>)<br />
Task to operate on.</p>
</dd>
<dt><code>learner</code></dt><dd><p>(<a href="mlr3.html#topic+Learner">mlr3::Learner</a>)<br />
Learner to optimize the feature subset for.</p>
</dd>
<dt><code>resampling</code></dt><dd><p>(<a href="mlr3.html#topic+Resampling">mlr3::Resampling</a>)<br />
Resampling that is used to evaluated the performance of the feature subsets.
Uninstantiated resamplings are instantiated during construction so that all feature subsets are evaluated on the same data splits.
Already instantiated resamplings are kept unchanged.</p>
</dd>
<dt><code>measures</code></dt><dd><p>(list of <a href="mlr3.html#topic+Measure">mlr3::Measure</a>)<br />
Measures to optimize.
If <code>NULL</code>, <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>'s default measure is used.</p>
</dd>
<dt><code>check_values</code></dt><dd><p>(<code>logical(1)</code>)<br />
Check the parameters before the evaluation and the results for
validity?</p>
</dd>
<dt><code>store_benchmark_result</code></dt><dd><p>(<code>logical(1)</code>)<br />
Store benchmark result in archive?</p>
</dd>
<dt><code>store_models</code></dt><dd><p>(<code>logical(1)</code>).
Store models in benchmark result?</p>
</dd>
<dt><code>archive</code></dt><dd><p>(<a href="#topic+ArchiveBatchFSelect">ArchiveBatchFSelect</a>)<br />
Reference to the archive of <a href="#topic+FSelectInstanceBatchSingleCrit">FSelectInstanceBatchSingleCrit</a> | <a href="#topic+FSelectInstanceBatchMultiCrit">FSelectInstanceBatchMultiCrit</a>.
If <code>NULL</code> (default), benchmark result and models cannot be stored.</p>
</dd>
<dt><code>callbacks</code></dt><dd><p>(list of <a href="#topic+CallbackBatchFSelect">CallbackBatchFSelect</a>)<br />
List of callbacks.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ObjectiveFSelectBatch-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ObjectiveFSelectBatch$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+mlr_terminators'></span><span id='topic+trm'></span><span id='topic+trms'></span><span id='topic+mlr_callbacks'></span><span id='topic+clbk'></span><span id='topic+clbks'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>bbotk</dt><dd><p><code><a href="bbotk.html#topic+mlr_terminators">mlr_terminators</a></code>, <code><a href="bbotk.html#topic+trm">trm</a></code>, <code><a href="bbotk.html#topic+trm">trms</a></code></p>
</dd>
<dt>mlr3misc</dt><dd><p><code><a href="mlr3misc.html#topic+clbk">clbk</a></code>, <code><a href="mlr3misc.html#topic+clbk">clbks</a></code>, <code><a href="mlr3misc.html#topic+mlr_callbacks">mlr_callbacks</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
