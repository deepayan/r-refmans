<!DOCTYPE html><html lang="en"><head><title>Help for package systemfonts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {systemfonts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#systemfonts-package'><p>systemfonts: System Native Font Finding</p></a></li>
<li><a href='#add_fonts'><p>Add local font files to the search path</p></a></li>
<li><a href='#as_font_weight'><p>Convert weight and width to numerics</p></a></li>
<li><a href='#font_fallback'><p>Get the fallback font for a given string</p></a></li>
<li><a href='#font_feature'><p>Define OpenType font feature settings</p></a></li>
<li><a href='#font_info'><p>Query font-specific information</p></a></li>
<li><a href='#get_fallback'><p>Get location of the fallback font</p></a></li>
<li><a href='#glyph_info'><p>Query glyph-specific information from fonts</p></a></li>
<li><a href='#glyph_outline'><p>Get the outline of glyphs</p></a></li>
<li><a href='#glyph_raster'><p>Render glyphs to raster image</p></a></li>
<li><a href='#glyph_raster_grob'><p>Convert an extracted glyph raster to a grob</p></a></li>
<li><a href='#match_fonts'><p>Find a system font by name and style</p></a></li>
<li><a href='#register_font'><p>Register font collections as families</p></a></li>
<li><a href='#register_variant'><p>Register a font as a variant as an existing one</p></a></li>
<li><a href='#require_font'><p>Ensure font availability in a script</p></a></li>
<li><a href='#reset_font_cache'><p>Reset the system font cache</p></a></li>
<li><a href='#search_web_fonts'><p>Search font repositories for a font based on family name</p></a></li>
<li><a href='#shape_string'><p>Calculate glyph positions for strings</p></a></li>
<li><a href='#str_split_emoji'><p>Split a string into emoji and non-emoji glyph runs</p></a></li>
<li><a href='#string_metrics_dev'><p>Get string metrics as measured by the current device</p></a></li>
<li><a href='#string_width'><p>Calculate the width of a string, ignoring new-lines</p></a></li>
<li><a href='#string_widths_dev'><p>Get string widths as measured by the current device</p></a></li>
<li><a href='#system_fonts'><p>List all fonts installed on your system</p></a></li>
<li><a href='#web-fonts'><p>Download and add web font</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>System Native Font Finding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides system native access to the font catalogue. As font
    handling varies between systems it is difficult to correctly locate
    installed fonts across different operating systems. The 'systemfonts'
    package provides bindings to the native libraries on Windows, macOS
    and Linux for finding font files that can then be used further by e.g.
    graphic devices. The main use is intended to be from compiled code but
    'systemfonts' also provides access from R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/systemfonts">https://github.com/r-lib/systemfonts</a>,
<a href="https://systemfonts.r-lib.org">https://systemfonts.r-lib.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/systemfonts/issues">https://github.com/r-lib/systemfonts/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, farver, graphics, knitr, rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.2.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fontconfig, freetype2</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, jsonlite, lifecycle, tools, utils</td>
</tr>
<tr>
<td>Config/build/compilation-database:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-20 08:28:46 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Devon Govett [aut] (Author of font-manager),
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomas.pedersen@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-20 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='systemfonts-package'>systemfonts: System Native Font Finding</h2><span id='topic+systemfonts'></span><span id='topic+systemfonts-package'></span>

<h3>Description</h3>

<p>Provides system native access to the font catalogue. As font handling varies between systems it is difficult to correctly locate installed fonts across different operating systems. The 'systemfonts' package provides bindings to the native libraries on Windows, macOS and Linux for finding font files that can then be used further by e.g. graphic devices. The main use is intended to be from compiled code but 'systemfonts' also provides access from R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomas.pedersen@posit.co">thomas.pedersen@posit.co</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jeroen Ooms <a href="mailto:jeroen@berkeley.edu">jeroen@berkeley.edu</a> (<a href="https://orcid.org/0000-0002-4035-0289">ORCID</a>)
</p>
</li>
<li><p> Devon Govett (Author of font-manager)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/systemfonts">https://github.com/r-lib/systemfonts</a>
</p>
</li>
<li> <p><a href="https://systemfonts.r-lib.org">https://systemfonts.r-lib.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/systemfonts/issues">https://github.com/r-lib/systemfonts/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_fonts'>Add local font files to the search path</h2><span id='topic+add_fonts'></span><span id='topic+scan_local_fonts'></span><span id='topic+clear_local_fonts'></span>

<h3>Description</h3>

<p>systemfonts is mainly about getting system native access to the fonts
installed on the OS you are executing the code on. However, you may want to
access fonts without doing a full installation, either because you want your
project to be reproducible on all systems, because you don't have
administrator priviliges on the system, or for a different reason entirely.
<code>add_fonts()</code> provide a way to side load font files so that they are found
during font matching. The function differs from <code><a href="#topic+register_font">register_font()</a></code> and
<code><a href="#topic+register_variant">register_variant()</a></code> in that they add the font file as-is using the family
name etc that are provided by the font. <code>scan_local_fonts()</code> is run when
systemfonts is loaded and will automatically add font files stored in
<code>./fonts</code> (project local) and <code style="white-space: pre;">&#8288;~/fonts&#8288;</code> (user local).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_fonts(files)

scan_local_fonts()

clear_local_fonts()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_fonts_+3A_files">files</code></td>
<td>
<p>A character vector of font file paths to add</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its sideeffects
</p>


<h3>Font matching</h3>

<p>During font matching, systemfonts has to look in three different locations.
The font registry (populated by <code><a href="#topic+register_font">register_font()</a></code>/<code><a href="#topic+register_variant">register_variant()</a></code>), the
local fonts (populated with <code><a href="#topic+add_fonts">add_fonts()</a></code>/<code><a href="#topic+scan_local_fonts">scan_local_fonts()</a></code>), and the
fonts installed on the system. It does so in that order: registry &gt; local &gt;
installed.
</p>
<p>The matching performed at each step also differs. The fonts in the registry
is only matched by family name. The local fonts are matched based on all the
provided parameters (family, weight, italic, etc) in a way that is local to
systemfonts, but try to emulate the system native matching. The installed
fonts are matched using the system native matching functionality on macOS and
Linux. On Windows the installed fonts are read from the system registry and
matched using the same approach as for local fonts. Matching will always find
a font no matter what you throw at it, defaulting to &quot;sans&quot; if nothing else
is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code
empty_font &lt;- system.file("unfont.ttf", package = "systemfonts")

add_fonts(empty_font)

clear_local_fonts()

</code></pre>

<hr>
<h2 id='as_font_weight'>Convert weight and width to numerics</h2><span id='topic+as_font_weight'></span><span id='topic+as_font_width'></span>

<h3>Description</h3>

<p>It is often more natural to describe font weight and width with names rather
than numbers (e.g. &quot;bold&quot; or &quot;condensed&quot;), but underneath these names are
matched to numeric values. These two functions are used to retrieve the
numeric counterparts to names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_font_weight(weight)

as_font_width(width)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_font_weight_+3A_weight">weight</code>, <code id="as_font_weight_+3A_width">width</code></td>
<td>
<p>character vectors with valid names for weight or width</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector matching the length of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_font_weight(
  c("undefined", "thin", "ultralight", "light", "normal", "medium", "semibold",
    "bold", "ultrabold", "heavy")
)

as_font_width(
  c("undefined", "ultracondensed", "extracondensed", "condensed", "semicondensed",
  "normal", "semiexpanded", "expanded", "extraexpanded", "ultraexpanded")
)

</code></pre>

<hr>
<h2 id='font_fallback'>Get the fallback font for a given string</h2><span id='topic+font_fallback'></span>

<h3>Description</h3>

<p>A fallback font is a font to use as a substitute if the chosen font does not
contain the requested characters. Using font fallbacks means that the user
doesn't have to worry about mixing characters from different scripts or
mixing text and emojies. Fallback is calculated for the full string and the
result is platform specific. If no font covers all the characters in the
string an undefined &quot;best match&quot; is returned. The best approach is to figure
out which characters are not covered by your chosen font and figure out
fallbacks for these, rather than just request a fallback for the full string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>font_fallback(
  string,
  family = "",
  italic = FALSE,
  bold = FALSE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="font_fallback_+3A_string">string</code></td>
<td>
<p>The strings to find fallbacks for</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_path">path</code>, <code id="font_fallback_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a <code>path</code> and <code>index</code> column giving fallback for the
specified string and font combinations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font_fallback("\U0001f604") # Smile emoji

</code></pre>

<hr>
<h2 id='font_feature'>Define OpenType font feature settings</h2><span id='topic+font_feature'></span>

<h3>Description</h3>

<p>This function encapsulates the specification of OpenType font features. Some
specific features have named arguments, but all available features can be
set by using its specific 4-letter tag For a list of the 4-letter tags
available see e.g. the overview on
<a href="https://en.wikipedia.org/wiki/List_of_typographic_features">Wikipedia</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>font_feature(ligatures = NULL, letters = NULL, numbers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="font_feature_+3A_ligatures">ligatures</code></td>
<td>
<p>Settings related to ligatures. One or more types of
ligatures to turn on (see details).</p>
</td></tr>
<tr><td><code id="font_feature_+3A_letters">letters</code></td>
<td>
<p>Settings related to the appearance of single
letters (as opposed to ligatures that substitutes multiple letters). See
details for supported values.</p>
</td></tr>
<tr><td><code id="font_feature_+3A_numbers">numbers</code></td>
<td>
<p>Settings related to the appearance of numbers. See details for
supported values.</p>
</td></tr>
<tr><td><code id="font_feature_+3A_...">...</code></td>
<td>
<p>key-value pairs with the key being the 4-letter tag and the value
being the setting (usually <code>TRUE</code> to turn it on).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OpenType features are defined by a 4-letter tag along with an integer value.
Often that value is a simple <code>0</code> (off) or <code>1</code> (on), but some features support
additional values, e.g. stylistic alternates (<code>salt</code>) where a font may
provide multiple variants of a letter and the value will be used to chose
which one to use.
</p>
<p>Common features related to appearance may be given with a long form name to
either the <code>ligatures</code>, <code>letters</code>, or <code>numbers</code> argument to avoid remembering
the often arbitrary 4-letter tag. Providing a long form name is the same as
setting the tag to <code>1</code> and can thus not be used to set tags to other values.
</p>
<p>The possible long form names are given below with the tag in parenthesis:
</p>
<p><strong>Ligatures</strong>
</p>

<ul>
<li> <p><code>standard</code> (<em>liga</em>): Turns on standard multiple letter substitution
</p>
</li>
<li> <p><code>historical</code> (<em>hlig</em>): Use obsolete historical ligatures
</p>
</li>
<li> <p><code>contextual</code> (<em>clig</em>): Apply secondary ligatures based on the character
patterns surrounding the potential ligature
</p>
</li>
<li> <p><code>discretionary</code> (<em>dlig</em>): Use ornamental ligatures
</p>
</li></ul>

<p><strong>Letters</strong>
</p>

<ul>
<li> <p><code>swash</code> (<em>cswh</em>): Use contextual swashes (ornamental decorations)
</p>
</li>
<li> <p><code>alternates</code> (<em>calt</em>): Use alternate letter forms based on the sourrounding
pattern
</p>
</li>
<li> <p><code>historical</code> (<em>hist</em>): Use obsolete historical forms of the letters
</p>
</li>
<li> <p><code>localized</code> (<em>locl</em>): Use alternate forms preferred by the script language
</p>
</li>
<li> <p><code>randomize</code> (<em>rand</em>): Use random variants of the letters (e.g. to mimick
handwriting)
</p>
</li>
<li> <p><code>alt_annotation</code> (<em>nalt</em>): Use alternate annotations (e.g. circled digits)
</p>
</li>
<li> <p><code>stylistic</code> (<em>salt</em>): Use a stylistic alternative form of the letter
</p>
</li>
<li> <p><code>subscript</code> (<em>subs</em>): Set letter in subscript
</p>
</li>
<li> <p><code>superscript</code> (<em>sups</em>): Set letter in superscript
</p>
</li>
<li> <p><code>titling</code> (<em>titl</em>): Use letter forms well suited for large text and titles
</p>
</li>
<li> <p><code>small_caps</code> (<em>smcp</em>): Use small caps variants of the letters
</p>
</li></ul>

<p><strong>Numbers</strong>
</p>

<ul>
<li> <p><code>lining</code> (<em>lnum</em>): Use number variants that rest on the baseline
</p>
</li>
<li> <p><code>oldstyle</code> (<em>onum</em>): Use old style numbers that use descender and ascender
for various numbers
</p>
</li>
<li> <p><code>proportional</code> (<em>pnum</em>): Let numbers take up width based on the visual
width of the glyph
</p>
</li>
<li> <p><code>tabular</code> (<em>tnum</em>): Enforce all numbers to take up the same width
</p>
</li>
<li> <p><code>fractions</code> (<em>frac</em>): Convert numbers separated by <code>/</code> into a fraction
glyph
</p>
</li>
<li> <p><code>fractions_alt</code> (<em>afrc</em>): Use alternate fraction form with a horizontal
divider
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>font_feature</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font_feature(letters = "stylistic", numbers = c("lining", "tabular"))

# Use the tag directly to access additional stylistic variants
font_feature(numbers = c("lining", "tabular"), salt = 2)

</code></pre>

<hr>
<h2 id='font_info'>Query font-specific information</h2><span id='topic+font_info'></span>

<h3>Description</h3>

<p>Get general information about a font, relative to a given size. Size specific
measures will be returned in pixel units. The function is vectorised to the
length of the longest argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>font_info(
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="font_info_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="font_info_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="font_info_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="font_info_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="font_info_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="font_info_+3A_path">path</code>, <code id="font_info_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame giving info on the requested font + size combinations. The
data.frame will contain the following columns:
</p>

<dl>
<dt>path</dt><dd><p>The path to the font file</p>
</dd>
<dt>index</dt><dd><p>The 0-based index of the font in the fontfile</p>
</dd>
<dt>family</dt><dd><p>The family name of the font</p>
</dd>
<dt>style</dt><dd><p>The style name of the font</p>
</dd>
<dt>italic</dt><dd><p>A logical giving if the font is italic</p>
</dd>
<dt>bold</dt><dd><p>A logical giving if the font is bold</p>
</dd>
<dt>monospace</dt><dd><p>A logical giving if the font is monospace</p>
</dd>
<dt>weight</dt><dd><p>A factor giving the weight of the font</p>
</dd>
<dt>width</dt><dd><p>A factor giving the width of the font</p>
</dd>
<dt>kerning</dt><dd><p>A logical giving if the font supports kerning</p>
</dd>
<dt>color</dt><dd><p>A logical giving if the font has color glyphs</p>
</dd>
<dt>scalable</dt><dd><p>A logical giving if the font is scalable</p>
</dd>
<dt>vertical</dt><dd><p>A logical giving if the font is vertical</p>
</dd>
<dt>n_glyphs</dt><dd><p>The number of glyphs in the font</p>
</dd>
<dt>n_sizes</dt><dd><p>The number of predefined sizes in the font</p>
</dd>
<dt>n_charmaps</dt><dd><p>The number of character mappings in the font file</p>
</dd>
<dt>bbox</dt><dd><p>A bounding box large enough to contain any of the glyphs in the font</p>
</dd>
<dt>max_ascend</dt><dd><p>The maximum ascend of the tallest glyph in the font</p>
</dd>
<dt>max_descent</dt><dd><p>The maximum descend of the most descending glyph in the font</p>
</dd>
<dt>max_advance_width</dt><dd><p>The maximum horizontal advance a glyph can make</p>
</dd>
<dt>max_advance_height</dt><dd><p>The maximum vertical advance a glyph can make</p>
</dd>
<dt>lineheight</dt><dd><p>The height of a single line of text in the font</p>
</dd>
<dt>underline_pos</dt><dd><p>The position of a potential underlining segment</p>
</dd>
<dt>underline_size</dt><dd><p>The width the the underline</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>font_info('serif')

# Avoid lookup if font file is already known
sans &lt;- match_fonts('sans')
font_info(path = sans$path, index = sans$index)

</code></pre>

<hr>
<h2 id='get_fallback'>Get location of the fallback font</h2><span id='topic+get_fallback'></span>

<h3>Description</h3>

<p>Get location of the fallback font
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fallback()
</code></pre>

<hr>
<h2 id='glyph_info'>Query glyph-specific information from fonts</h2><span id='topic+glyph_info'></span>

<h3>Description</h3>

<p>This function allows you to extract information about the individual glyphs
in a font, based on a specified size. All size related measures are in
pixel-units. The function is vectorised to the length of the <code>glyphs</code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glyph_info(
  glyphs,
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glyph_info_+3A_glyphs">glyphs</code></td>
<td>
<p>A vector of glyphs. Strings will be split into separate glyphs
automatically</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_path">path</code>, <code id="glyph_info_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with information about each glyph, containing the following
columns:
</p>

<dl>
<dt>glyph</dt><dd><p>The glyph as a character</p>
</dd>
<dt>index</dt><dd><p>The index of the glyph in the font file</p>
</dd>
<dt>width</dt><dd><p>The width of the glyph</p>
</dd>
<dt>height</dt><dd><p>The height of the glyph</p>
</dd>
<dt>x_bearing</dt><dd><p>The horizontal distance from the origin to the leftmost part of the glyph</p>
</dd>
<dt>y_bearing</dt><dd><p>The vertical distance from the origin to the top part of the glyph</p>
</dd>
<dt>x_advance</dt><dd><p>The horizontal distance to move the cursor after adding the glyph</p>
</dd>
<dt>y_advance</dt><dd><p>The vertical distance to move the cursor after adding the glyph</p>
</dd>
<dt>bbox</dt><dd><p>The tight bounding box surrounding the glyph</p>
</dd>
</dl>


<hr>
<h2 id='glyph_outline'>Get the outline of glyphs</h2><span id='topic+glyph_outline'></span>

<h3>Description</h3>

<p>This function allows you to retrieve the outline of glyphs as polygon
coordinates. The glyphs are given as indexes into a font file and not as
characters allowing you to retrieve outlines for glyphs that doesn't have a
character counterpoint. Glyphs that are given as bitmaps are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glyph_outline(
  glyph,
  path,
  index = 0,
  size = 12,
  tolerance = 0.2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glyph_outline_+3A_glyph">glyph</code></td>
<td>
<p>The index of the glyph in the font file</p>
</td></tr>
<tr><td><code id="glyph_outline_+3A_path">path</code></td>
<td>
<p>The path to the font file encoding the glyph</p>
</td></tr>
<tr><td><code id="glyph_outline_+3A_index">index</code></td>
<td>
<p>The index of the font in the font file</p>
</td></tr>
<tr><td><code id="glyph_outline_+3A_size">size</code></td>
<td>
<p>The size of the font in big points (1/72 inch)</p>
</td></tr>
<tr><td><code id="glyph_outline_+3A_tolerance">tolerance</code></td>
<td>
<p>The deviation tolerance for decomposing bezier curves of the
glyph. Given in the same unit as size. Smaller values give more detailed
polygons</p>
</td></tr>
<tr><td><code id="glyph_outline_+3A_verbose">verbose</code></td>
<td>
<p>Should font and glyph loading errors be reported as warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving the outlines of the glyphs provide in <code>glyph</code>. It
contains the columns <code>glyph</code> pointing to the element in the input it relates
to, <code>contour</code> enumerating the contours the glyph consists of, and <code>x</code> and <code>y</code>
giving the coordinates in big points
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the shape of s in the default font
font &lt;- font_info()
glyph &lt;- glyph_info("s", path = font$path, index = font$index)

s &lt;- glyph_outline(glyph$index, font$path, font$index, size = 150)

plot(s$x, s$y, type = 'l')

</code></pre>

<hr>
<h2 id='glyph_raster'>Render glyphs to raster image</h2><span id='topic+glyph_raster'></span>

<h3>Description</h3>

<p>Not all glyphs are encoded as vector outlines (emojis often not). Even for
fonts that provide an outline you might be interested in a raster version.
This function gives you just that. It converts a glyph into an optimized
raster object that can be plotted with e.g. <code><a href="graphics.html#topic+rasterImage">graphics::rasterImage()</a></code> or
<code><a href="grid.html#topic+grid.raster">grid::grid.raster()</a></code>. For convenience, you can also use
<code><a href="#topic+glyph_raster_grob">glyph_raster_grob()</a></code> for plotting the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glyph_raster(
  glyph,
  path,
  index = 0,
  size = 12,
  res = 300,
  col = "black",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glyph_raster_+3A_glyph">glyph</code></td>
<td>
<p>The index of the glyph in the font file</p>
</td></tr>
<tr><td><code id="glyph_raster_+3A_path">path</code></td>
<td>
<p>The path to the font file encoding the glyph</p>
</td></tr>
<tr><td><code id="glyph_raster_+3A_index">index</code></td>
<td>
<p>The index of the font in the font file</p>
</td></tr>
<tr><td><code id="glyph_raster_+3A_size">size</code></td>
<td>
<p>The size of the font in big points (1/72 inch)</p>
</td></tr>
<tr><td><code id="glyph_raster_+3A_res">res</code></td>
<td>
<p>The resolution to render the glyphs to</p>
</td></tr>
<tr><td><code id="glyph_raster_+3A_col">col</code></td>
<td>
<p>The color of the glyph assuming the glyph doesn't have a native
coloring</p>
</td></tr>
<tr><td><code id="glyph_raster_+3A_verbose">verbose</code></td>
<td>
<p>Should font and glyph loading errors be reported as warnings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of nativeRaster objects (or <code>NULL</code> if it failed to render a
given glyph). The nativeRasters have additional attributes attached. <code>"size"</code>
will give the size of the glyph in big points and <code>"offset"</code> will give the
location of the top-left corner of the raster with respect to where it should
be rendered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font &lt;- font_info()
glyph &lt;- glyph_info("R", path = font$path, index = font$index)

R &lt;- glyph_raster(glyph$index, font$path, font$index, size = 150)

plot.new()
plot.window(c(0,150), c(0, 150), asp = 1)
rasterImage(R[[1]], 0, 0, attr(R[[1]], "size")[2], attr(R[[1]], "size")[1])

</code></pre>

<hr>
<h2 id='glyph_raster_grob'>Convert an extracted glyph raster to a grob</h2><span id='topic+glyph_raster_grob'></span>

<h3>Description</h3>

<p>This is a convenience function that helps in creating <a href="grid.html#topic+rasterGrob">rasterGrob</a> with the
correct settings for the glyph. It takes inot account the sizing and offset
returned by <code><a href="#topic+glyph_raster">glyph_raster()</a></code> and allows you to only consider the baseline
position of the glyph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glyph_raster_grob(glyph, x, y, ..., default.units = "bigpts")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glyph_raster_grob_+3A_glyph">glyph</code></td>
<td>
<p>The nativeRaster object returned as one of the elements by
<code><a href="#topic+glyph_raster">glyph_raster()</a></code></p>
</td></tr>
<tr><td><code id="glyph_raster_grob_+3A_x">x</code>, <code id="glyph_raster_grob_+3A_y">y</code></td>
<td>
<p>The baseline location of the glyph</p>
</td></tr>
<tr><td><code id="glyph_raster_grob_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="grid.html#topic+grid.raster">grid::rasterGrob</a></code>
</p>

<dl>
<dt><code>image</code></dt><dd>
<p>Any R object that can be coerced to a raster object.
</p>
</dd>
<dt><code>width</code></dt><dd><p>A numeric vector or unit object specifying width.</p>
</dd>
<dt><code>height</code></dt><dd><p>A numeric vector or unit object specifying height.</p>
</dd>
<dt><code>just</code></dt><dd><p>The justification of the rectangle
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left alignment
and 1 means right alignment.
</p>
</dd>
<dt><code>hjust</code></dt><dd><p>A numeric vector specifying horizontal justification.
If specified, overrides the <code>just</code> setting.</p>
</dd>
<dt><code>vjust</code></dt><dd><p>A numeric vector specifying vertical justification.
If specified, overrides the <code>just</code> setting.</p>
</dd>
<dt><code>name</code></dt><dd><p> A character identifier. </p>
</dd>
<dt><code>gp</code></dt><dd><p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</dd>
<dt><code>vp</code></dt><dd><p>A Grid viewport object (or NULL).</p>
</dd>
<dt><code>interpolate</code></dt><dd>
<p>A logical value indicating whether to linearly interpolate the
image (the alternative is to use nearest-neighbour interpolation,
which gives a more blocky result).
</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="glyph_raster_grob_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rasterGrob object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font &lt;- font_info()
glyph &lt;- glyph_info("R", path = font$path, index = font$index)

R &lt;- glyph_raster(glyph$index, font$path, font$index, size = 150)

grob &lt;- glyph_raster_grob(R[[1]], 50, 50)

grid::grid.newpage()
# Mark the baseline location
grid::grid.points(50, 50, default.units = "bigpts")
# Draw the glyph
grid::grid.draw(grob)

</code></pre>

<hr>
<h2 id='match_fonts'>Find a system font by name and style</h2><span id='topic+match_fonts'></span><span id='topic+match_font'></span>

<h3>Description</h3>

<p>This function locates the font file (and index) best matching a name and
optional style. A font file will be returned even if a perfect match
isn't found, but it is not necessarily similar to the requested family and
it should not be relied on for font substitution. The aliases <code>"sans"</code>,
<code>"serif"</code>, <code>"mono"</code>, <code>"symbol"</code>, and <code>"emoji"</code> match to their respective
system defaults (<code>""</code> is equivalent to <code>"sans"</code>). <code>match_font()</code> has been
deprecated in favour of <code>match_fonts()</code> which provides vectorisation, as well
as querying for different weights (rather than just &quot;normal&quot; and &quot;bold&quot;) as
well as different widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_fonts(family, italic = FALSE, weight = "normal", width = "undefined")

match_font(family, italic = FALSE, bold = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_fonts_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="match_fonts_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="match_fonts_+3A_weight">weight</code></td>
<td>
<p>The weight to query for, either in numbers (<code>0</code>, <code>100</code>, <code>200</code>,
<code>300</code>, <code>400</code>, <code>500</code>, <code>600</code>, <code>700</code>, <code>800</code>, or <code>900</code>) or strings (<code>"undefined"</code>,
<code>"thin"</code>, <code>"ultralight"</code>, <code>"light"</code>, <code>"normal"</code>, <code>"medium"</code>, <code>"semibold"</code>,
<code>"bold"</code>, <code>"ultrabold"</code>, or <code>"heavy"</code>). <code>NA</code> will be interpreted as
<code>"undefined"</code>/<code>0</code></p>
</td></tr>
<tr><td><code id="match_fonts_+3A_width">width</code></td>
<td>
<p>The width to query for either in numbers (<code>0</code>, <code>1</code>, <code>2</code>,
<code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, or <code>9</code>) or strings (<code>"undefined"</code>,
<code>"ultracondensed"</code>, <code>"extracondensed"</code>, <code>"condensed"</code>, <code>"semicondensed"</code>,
<code>"normal"</code>, <code>"semiexpanded"</code>, <code>"expanded"</code>, <code>"extraexpanded"</code>, or
<code>"ultraexpanded"</code>). <code>NA</code> will be interpreted as <code>"undefined"</code>/<code>0</code></p>
</td></tr>
<tr><td><code id="match_fonts_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the paths locating the font files, the 0-based
index of the font in the files and the features for the font in case a
registered font was located.
</p>


<h3>Font matching</h3>

<p>During font matching, systemfonts has to look in three different locations.
The font registry (populated by <code><a href="#topic+register_font">register_font()</a></code>/<code><a href="#topic+register_variant">register_variant()</a></code>), the
local fonts (populated with <code><a href="#topic+add_fonts">add_fonts()</a></code>/<code><a href="#topic+scan_local_fonts">scan_local_fonts()</a></code>), and the
fonts installed on the system. It does so in that order: registry &gt; local &gt;
installed.
</p>
<p>The matching performed at each step also differs. The fonts in the registry
is only matched by family name. The local fonts are matched based on all the
provided parameters (family, weight, italic, etc) in a way that is local to
systemfonts, but try to emulate the system native matching. The installed
fonts are matched using the system native matching functionality on macOS and
Linux. On Windows the installed fonts are read from the system registry and
matched using the same approach as for local fonts. Matching will always find
a font no matter what you throw at it, defaulting to &quot;sans&quot; if nothing else
is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the system default sans-serif font in italic
match_fonts('sans', italic = TRUE)

# Try to match it to a thin variant
match_fonts(c('sans', 'serif'), weight = "thin")

</code></pre>

<hr>
<h2 id='register_font'>Register font collections as families</h2><span id='topic+register_font'></span><span id='topic+registry_fonts'></span><span id='topic+clear_registry'></span>

<h3>Description</h3>

<p>By design, systemfonts searches the fonts installed natively on the system.
It is possible, however, to register other fonts from e.g. font packages or
local font files, that will get searched before searching any installed
fonts. You can always get an overview over all registered fonts with the
<code>registry_fonts()</code> function that works as a registry focused analogue to
<code><a href="#topic+system_fonts">system_fonts()</a></code>. If you wish to clear out the registry, you can either
restart the R session or call <code>clear_registry()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_font(
  name,
  plain,
  bold = plain,
  italic = plain,
  bolditalic = plain,
  features = font_feature()
)

registry_fonts()

clear_registry()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_font_+3A_name">name</code></td>
<td>
<p>The name the collection will be known under (i.e. <em>family</em>)</p>
</td></tr>
<tr><td><code id="register_font_+3A_plain">plain</code>, <code id="register_font_+3A_bold">bold</code>, <code id="register_font_+3A_italic">italic</code>, <code id="register_font_+3A_bolditalic">bolditalic</code></td>
<td>
<p>Fontfiles for the different faces of the
collection. can either be a filepath or a list containing a filepath and an
index (only for font files containing multiple fonts). If not given it will
default to the <code>plain</code> specification.</p>
</td></tr>
<tr><td><code id="register_font_+3A_features">features</code></td>
<td>
<p>A <code><a href="#topic+font_feature">font_feature</a></code> object describing the specific OpenType
font features to turn on for the registered font.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>register_font</code> also makes it possible to use system fonts with traits that
is not covered by the graphic engine in R. In plotting operations it is only
possible to specify a family name and whether or not the font should be bold
and/or italic. There are numerous fonts that will never get matched to this,
especially because bold is only one of many weights.
</p>
<p>Apart from granting a way to use new varieties of fonts, font registration
also allows you to override the default <code>sans</code>, <code>serif</code>, and <code>mono</code> mappings,
simply by registering a collection to the relevant default name. As
registered fonts are searched first it will take precedence over the default.
</p>


<h3>Value</h3>

<p><code>register_font()</code> and <code>clear_registry()</code> returns <code>NULL</code> invisibly.
<code>registry_fonts()</code> returns a data table in the same style as <code><a href="#topic+system_fonts">system_fonts()</a></code>
though less detailed and not based on information in the font file.
</p>


<h3>Font matching</h3>

<p>During font matching, systemfonts has to look in three different locations.
The font registry (populated by <code><a href="#topic+register_font">register_font()</a></code>/<code><a href="#topic+register_variant">register_variant()</a></code>), the
local fonts (populated with <code><a href="#topic+add_fonts">add_fonts()</a></code>/<code><a href="#topic+scan_local_fonts">scan_local_fonts()</a></code>), and the
fonts installed on the system. It does so in that order: registry &gt; local &gt;
installed.
</p>
<p>The matching performed at each step also differs. The fonts in the registry
is only matched by family name. The local fonts are matched based on all the
provided parameters (family, weight, italic, etc) in a way that is local to
systemfonts, but try to emulate the system native matching. The installed
fonts are matched using the system native matching functionality on macOS and
Linux. On Windows the installed fonts are read from the system registry and
matched using the same approach as for local fonts. Matching will always find
a font no matter what you throw at it, defaulting to &quot;sans&quot; if nothing else
is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random font collection
fonts &lt;- system_fonts()
plain &lt;- sample(which(!fonts$italic &amp; fonts$weight &lt;= 'normal'), 1)
bold &lt;- sample(which(!fonts$italic &amp; fonts$weight &gt; 'normal'), 1)
italic &lt;- sample(which(fonts$italic &amp; fonts$weight &lt;= 'normal'), 1)
bolditalic &lt;- sample(which(fonts$italic &amp; fonts$weight &gt; 'normal'), 1)
register_font(
  'random',
  plain = list(fonts$path[plain], fonts$index[plain]),
  bold = list(fonts$path[bold], fonts$index[bold]),
  italic = list(fonts$path[italic], fonts$index[italic]),
  bolditalic = list(fonts$path[bolditalic], fonts$index[bolditalic])
)

# Look at your creation
registry_fonts()

# Reset
clear_registry()

</code></pre>

<hr>
<h2 id='register_variant'>Register a font as a variant as an existing one</h2><span id='topic+register_variant'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="#topic+register_font">register_font()</a></code> that allows you to easily
create variants of existing system fonts, e.g. to target different weights
and/or widths, or for attaching OpenType features to a font.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_variant(
  name,
  family,
  weight = NULL,
  width = NULL,
  features = font_feature()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_variant_+3A_name">name</code></td>
<td>
<p>The new family name the variant should respond to</p>
</td></tr>
<tr><td><code id="register_variant_+3A_family">family</code></td>
<td>
<p>The name of an existing font family that this is a variant of</p>
</td></tr>
<tr><td><code id="register_variant_+3A_weight">weight</code></td>
<td>
<p>One or two of <code>"thin"</code>, <code>"ultralight"</code>, <code>"light"</code>, <code>"normal"</code>,
<code>"medium"</code>, <code>"semibold"</code>, <code>"bold"</code>, <code>"ultrabold"</code>, or <code>"heavy"</code>. If one is
given it sets the weight for the whole variant. If two is given the first
one defines the plain weight and the second the bold weight. If <code>NULL</code> then
the variants of the given family closest to <code>"normal"</code> and <code>"bold"</code> will be
chosen.</p>
</td></tr>
<tr><td><code id="register_variant_+3A_width">width</code></td>
<td>
<p>One of <code>"ultracondensed"</code>, <code>"extracondensed"</code>, <code>"condensed"</code>,
<code>"semicondensed"</code>, <code>"normal"</code>, <code>"semiexpanded"</code>, <code>"expanded"</code>,
<code>"extraexpanded"</code>, or <code>"ultraexpanded"</code> giving the width of the variant. If
<code>NULL</code> then the width closest to <code>"normal"</code> will be chosen.</p>
</td></tr>
<tr><td><code id="register_variant_+3A_features">features</code></td>
<td>
<p>A <code><a href="#topic+font_feature">font_feature</a></code> object describing the specific OpenType
font features to turn on for the registered font variant.</p>
</td></tr>
</table>


<h3>Font matching</h3>

<p>During font matching, systemfonts has to look in three different locations.
The font registry (populated by <code><a href="#topic+register_font">register_font()</a></code>/<code><a href="#topic+register_variant">register_variant()</a></code>), the
local fonts (populated with <code><a href="#topic+add_fonts">add_fonts()</a></code>/<code><a href="#topic+scan_local_fonts">scan_local_fonts()</a></code>), and the
fonts installed on the system. It does so in that order: registry &gt; local &gt;
installed.
</p>
<p>The matching performed at each step also differs. The fonts in the registry
is only matched by family name. The local fonts are matched based on all the
provided parameters (family, weight, italic, etc) in a way that is local to
systemfonts, but try to emulate the system native matching. The installed
fonts are matched using the system native matching functionality on macOS and
Linux. On Windows the installed fonts are read from the system registry and
matched using the same approach as for local fonts. Matching will always find
a font no matter what you throw at it, defaulting to &quot;sans&quot; if nothing else
is found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the default "sans" family
sans &lt;- match_fonts("sans")$path
sans &lt;- system_fonts()$family[system_fonts()$path == sans][1]

# Register a variant of it:
register_variant(
  "sans_ligature",
  sans,
  features = font_feature(ligatures = "discretionary")
)

registry_fonts()

# clean up
clear_registry()

</code></pre>

<hr>
<h2 id='require_font'>Ensure font availability in a script</h2><span id='topic+require_font'></span>

<h3>Description</h3>

<p>When running a script on a different machine you are not always in control of
which fonts are installed on the system and thus how graphics created by the
script ends up looking. <code>require_font()</code> is a way to specify your font
requirements for a script. It will look at the available fonts and if the
required font family is not present it will attempt to fetch it from one of
the given repositories (in the order given). If that fails, it will either
throw an error or, if <code>fallback</code> is given, provide an alias for the fallback
so it maps to the required font.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>require_font(
  family,
  fallback = NULL,
  dir = tempdir(),
  repositories = c("Google Fonts", "Font Squirrel"),
  error = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="require_font_+3A_family">family</code></td>
<td>
<p>The font family to require</p>
</td></tr>
<tr><td><code id="require_font_+3A_fallback">fallback</code></td>
<td>
<p>An available font to fall back to if <code>family</code> cannot be found
or downloaded</p>
</td></tr>
<tr><td><code id="require_font_+3A_dir">dir</code></td>
<td>
<p>The location to put the font file downloaded from repositories</p>
</td></tr>
<tr><td><code id="require_font_+3A_repositories">repositories</code></td>
<td>
<p>The repositories to search for the font in case it is not
available on the system. They will be tried in the order given. Currently
only <code>"Google Fonts"</code> and <code>"Font Squirrel"</code> is available.</p>
</td></tr>
<tr><td><code id="require_font_+3A_error">error</code></td>
<td>
<p>Should the function throw an error if unsuccessful?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly <code>TRUE</code> if the font is available or <code>FALSE</code> if not (this can
only be returned if <code>error = FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Should always work
require_font("sans")

</code></pre>

<hr>
<h2 id='reset_font_cache'>Reset the system font cache</h2><span id='topic+reset_font_cache'></span>

<h3>Description</h3>

<p>Building the list of system fonts is time consuming and is therefore cached.
This, in turn, means that changes to the system fonts (i.e. installing new
fonts), will not propagate to systemfonts. The solution is to reset the
cache, which will result in the next call to e.g. <code><a href="#topic+match_fonts">match_fonts()</a></code> will
trigger a rebuild of the cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_font_cache()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>all_fonts &lt;- system_fonts()

##-- Install a new font on the system --##

all_fonts_new &lt;- system_fonts()

## all_fonts_new will be equal to all_fonts

reset_font_cache()

all_fonts_new &lt;- system_fonts()

## all_fonts_new will now contain the new font

</code></pre>

<hr>
<h2 id='search_web_fonts'>Search font repositories for a font based on family name</h2><span id='topic+search_web_fonts'></span>

<h3>Description</h3>

<p>While it is often advisable to visit the webpage for a font repository when
looking for a font, in order to see examples etc, <code>search_web_fonts()</code>
provide a quick lookup based on family name in the repositories supported by
systemfonts (currently <a href="https://fonts.google.com">Google Fonts</a> and
<a href="https://www.fontsquirrel.com">Font Squirrel</a>). The lookup is based on fuzzy
matching provided by <code><a href="utils.html#topic+adist">utils::adist()</a></code> and the matching parameters can be
controlled through <code>...</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_web_fonts(family, n_max = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_web_fonts_+3A_family">family</code></td>
<td>
<p>The font family name to look for</p>
</td></tr>
<tr><td><code id="search_web_fonts_+3A_n_max">n_max</code></td>
<td>
<p>The maximum number of matches to return</p>
</td></tr>
<tr><td><code id="search_web_fonts_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="utils.html#topic+adist">utils::adist</a></code>
</p>

<dl>
<dt><code>costs</code></dt><dd><p>a numeric vector or list with names partially matching
&lsquo;<span class="samp">&#8288;insertions&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;deletions&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;substitutions&#8288;</span>&rsquo; giving
the respective costs for computing the Levenshtein distance, or
<code>NULL</code> (default) indicating using unit cost for all three
possible transformations.</p>
</dd>
<dt><code>counts</code></dt><dd><p>a logical indicating whether to optionally return the
transformation counts (numbers of insertions, deletions and
substitutions) as the <code>"counts"</code> attribute of the return
value.</p>
</dd>
<dt><code>fixed</code></dt><dd><p>a logical.  If <code>TRUE</code> (default), the <code>x</code>
elements are used as string literals.  Otherwise, they are taken as
regular expressions and <code>partial = TRUE</code> is implied
(corresponding to the approximate string distance used by
<code><a href="base.html#topic+agrep">agrep</a></code> with <code>fixed = FALSE</code>).</p>
</dd>
<dt><code>partial</code></dt><dd><p>a logical indicating whether the transformed <code>x</code>
elements must exactly match the complete <code>y</code> elements, or only
substrings of these.  The latter corresponds to the approximate
string distance used by <code><a href="base.html#topic+agrep">agrep</a></code> (by default).</p>
</dd>
<dt><code>ignore.case</code></dt><dd><p>a logical.  If <code>TRUE</code>, case is ignored for
computing the distances.</p>
</dd>
<dt><code>useBytes</code></dt><dd><p>a logical.  If <code>TRUE</code> distance computations are
done byte-by-byte rather than character-by-character.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the columns <code>family</code>, giving the family name of the
matched font, and <code>repository</code> giving the repository it was found in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires an internet connection

# search_web_fonts("Spectral")

</code></pre>

<hr>
<h2 id='shape_string'>Calculate glyph positions for strings</h2><span id='topic+shape_string'></span>

<h3>Description</h3>

<p>Do basic text shaping of strings. This function will use freetype to
calculate advances, doing kerning if possible. It will not perform any font
substitution or ligature resolving and will thus be much in line with how
the standard graphic devices does text shaping. Inputs are recycled to the
length of <code>strings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_string(
  strings,
  id = NULL,
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  lineheight = 1,
  align = "left",
  hjust = 0,
  vjust = 0,
  width = NA,
  tracking = 0,
  indent = 0,
  hanging = 0,
  space_before = 0,
  space_after = 0,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_string_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to shape</p>
</td></tr>
<tr><td><code id="shape_string_+3A_id">id</code></td>
<td>
<p>A vector grouping the strings together. If strings share an id the
shaping will continue between strings</p>
</td></tr>
<tr><td><code id="shape_string_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="shape_string_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="shape_string_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="shape_string_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="shape_string_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="shape_string_+3A_lineheight">lineheight</code></td>
<td>
<p>A multiplier for the lineheight</p>
</td></tr>
<tr><td><code id="shape_string_+3A_align">align</code></td>
<td>
<p>Within text box alignment, either <code>'left'</code>, <code>'center'</code>, or
<code>'right'</code></p>
</td></tr>
<tr><td><code id="shape_string_+3A_hjust">hjust</code>, <code id="shape_string_+3A_vjust">vjust</code></td>
<td>
<p>The justification of the textbox surrounding the text</p>
</td></tr>
<tr><td><code id="shape_string_+3A_width">width</code></td>
<td>
<p>The requested with of the string in inches. Setting this to
something other than <code>NA</code> will turn on word wrapping.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_tracking">tracking</code></td>
<td>
<p>Tracking of the glyphs (space adjustment) measured in 1/1000
em.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_indent">indent</code></td>
<td>
<p>The indent of the first line in a paragraph measured in inches.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_hanging">hanging</code></td>
<td>
<p>The indent of the remaining lines in a paragraph measured in
inches.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_space_before">space_before</code>, <code id="shape_string_+3A_space_after">space_after</code></td>
<td>
<p>The spacing above and below a paragraph,
measured in points</p>
</td></tr>
<tr><td><code id="shape_string_+3A_path">path</code>, <code id="shape_string_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two element: <code>shape</code> contains the position of each glyph,
relative to the origin in the enclosing textbox. <code>metrics</code> contain metrics
about the full strings.
</p>
<p><code>shape</code> is a data.frame with the following columns:
</p>

<dl>
<dt>glyph</dt><dd><p>The glyph as a character</p>
</dd>
<dt>index</dt><dd><p>The index of the glyph in the font file</p>
</dd>
<dt>metric_id</dt><dd><p>The index of the string the glyph is part of (referencing a row in the <code>metrics</code> data.frame)</p>
</dd>
<dt>string_id</dt><dd><p>The index of the string the glyph came from (referencing an element in the <code>strings</code> input)</p>
</dd>
<dt>x_offset</dt><dd><p>The x offset in pixels from the origin of the textbox</p>
</dd>
<dt>y_offset</dt><dd><p>The y offset in pixels from the origin of the textbox</p>
</dd>
<dt>x_mid</dt><dd><p>The x offset in pixels to the middle of the glyph, measured from the origin of the glyph</p>
</dd>
</dl>

<p><code>metrics</code> is a data.frame with the following columns:
</p>

<dl>
<dt>string</dt><dd><p>The text the string consist of</p>
</dd>
<dt>width</dt><dd><p>The width of the string</p>
</dd>
<dt>height</dt><dd><p>The height of the string</p>
</dd>
<dt>left_bearing</dt><dd><p>The distance from the left edge of the textbox and the leftmost glyph</p>
</dd>
<dt>right_bearing</dt><dd><p>The distance from the right edge of the textbox and the rightmost glyph</p>
</dd>
<dt>top_bearing</dt><dd><p>The distance from the top edge of the textbox and the topmost glyph</p>
</dd>
<dt>bottom_bearing</dt><dd><p>The distance from the bottom edge of the textbox and the bottommost glyph</p>
</dd>
<dt>left_border</dt><dd><p>The position of the leftmost edge of the textbox related to the origin</p>
</dd>
<dt>top_border</dt><dd><p>The position of the topmost edge of the textbox related to the origin</p>
</dd>
<dt>pen_x</dt><dd><p>The horizontal position of the next glyph after the string</p>
</dd>
<dt>pen_y</dt><dd><p>The vertical position of the next glyph after the string</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- "This is a long string\nLook; It spans multiple lines\nand all"

# Shape with default settings
shape_string(string)

# Mix styles within the same string
string &lt;- c(
  "This string will have\na ",
  "very large",
  " text style\nin the middle"
)

shape_string(string, id = c(1, 1, 1), size = c(12, 24, 12))

</code></pre>

<hr>
<h2 id='str_split_emoji'>Split a string into emoji and non-emoji glyph runs</h2><span id='topic+str_split_emoji'></span>

<h3>Description</h3>

<p>In order to do correct text rendering, the font needed must be figured out. A
common case is rendering of emojis within a string where the system emoji
font is used rather than the requested font. This function will inspect the
provided strings and split them up in runs that must be rendered with the
emoji font, and the rest. Arguments are recycled to the length of the <code>string</code>
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_split_emoji(
  string,
  family = "",
  italic = FALSE,
  bold = FALSE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="str_split_emoji_+3A_string">string</code></td>
<td>
<p>A character vector of strings that should be splitted.</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_path">path</code>, <code id="str_split_emoji_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the following columns:
</p>

<dl>
<dt>string</dt><dd><p>The substring containing a consecutive run of glyphs</p>
</dd>
<dt>id</dt><dd><p>The index into the original <code>string</code> vector that the substring is part of</p>
</dd>
<dt>emoji</dt><dd><p>A logical vector giving if the substring is a run of emojis or not</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>emoji_string &lt;- "This is a joke\U0001f642. It should be obvious from the smiley"
str_split_emoji(emoji_string)

</code></pre>

<hr>
<h2 id='string_metrics_dev'>Get string metrics as measured by the current device</h2><span id='topic+string_metrics_dev'></span>

<h3>Description</h3>

<p>This function is much like <code><a href="#topic+string_widths_dev">string_widths_dev()</a></code> but also returns the ascent
and descent of the string making it possible to construct a tight bounding
box around the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_metrics_dev(
  strings,
  family = "",
  face = 1,
  size = 12,
  cex = 1,
  unit = "cm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="string_metrics_dev_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to measure</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_family">family</code></td>
<td>
<p>The font families to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_face">face</code></td>
<td>
<p>The font faces to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_size">size</code></td>
<td>
<p>The font size to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_cex">cex</code></td>
<td>
<p>The cex multiplier to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_unit">unit</code></td>
<td>
<p>The unit to return the width in. Either <code>"cm"</code>, <code>"inches"</code>,
<code>"device"</code>, or <code>"relative"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>width</code>, <code>ascent</code>, and <code>descent</code> columns giving the
metrics in the requested unit.
</p>


<h3>See Also</h3>

<p>Other device metrics: 
<code><a href="#topic+string_widths_dev">string_widths_dev</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the metrics as measured in cm (default)
string_metrics_dev(c('some text', 'a string with descenders'))

</code></pre>

<hr>
<h2 id='string_width'>Calculate the width of a string, ignoring new-lines</h2><span id='topic+string_width'></span>

<h3>Description</h3>

<p>This is a very simple alternative to <code><a href="#topic+shape_string">shape_string()</a></code> that simply calculates
the width of strings without taking any newline into account. As such it is
suitable to calculate the width of words or lines that has already been
splitted by <code style="white-space: pre;">&#8288;\n&#8288;</code>. Input is recycled to the length of <code>strings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_width(
  strings,
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  include_bearing = TRUE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="string_width_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings</p>
</td></tr>
<tr><td><code id="string_width_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="string_width_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="string_width_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="string_width_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="string_width_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="string_width_+3A_include_bearing">include_bearing</code></td>
<td>
<p>Logical, should left and right bearing be included in
the string width?</p>
</td></tr>
<tr><td><code id="string_width_+3A_path">path</code>, <code id="string_width_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the width of the strings in pixels. Use the
provided <code>res</code> value to convert it into absolute values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c('A short string', 'A very very looong string')
string_width(strings)

</code></pre>

<hr>
<h2 id='string_widths_dev'>Get string widths as measured by the current device</h2><span id='topic+string_widths_dev'></span>

<h3>Description</h3>

<p>For certain composition tasks it is beneficial to get the width of a string
as interpreted by the device that is going to plot it. grid provides this
through construction of a <code>textGrob</code> and then converting the corresponding
grob width to e.g. cm, but this comes with a huge overhead.
<code>string_widths_dev()</code> provides direct, vectorised, access to the graphic
device for as high performance as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_widths_dev(
  strings,
  family = "",
  face = 1,
  size = 12,
  cex = 1,
  unit = "cm"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="string_widths_dev_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to measure</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_family">family</code></td>
<td>
<p>The font families to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_face">face</code></td>
<td>
<p>The font faces to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_size">size</code></td>
<td>
<p>The font size to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_cex">cex</code></td>
<td>
<p>The cex multiplier to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_unit">unit</code></td>
<td>
<p>The unit to return the width in. Either <code>"cm"</code>, <code>"inches"</code>,
<code>"device"</code>, or <code>"relative"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the width of each of the strings given in
<code>strings</code> in the unit given in <code>unit</code>
</p>


<h3>See Also</h3>

<p>Other device metrics: 
<code><a href="#topic+string_metrics_dev">string_metrics_dev</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the widths as measured in cm (default)
string_widths_dev(c('a string', 'an even longer string'))

</code></pre>

<hr>
<h2 id='system_fonts'>List all fonts installed on your system</h2><span id='topic+system_fonts'></span>

<h3>Description</h3>

<p>List all fonts installed on your system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system_fonts()
</code></pre>


<h3>Value</h3>

<p>A data frame with a row for each font and various information in each
column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See all monospace fonts
fonts &lt;- system_fonts()
fonts[fonts$monospace, ]

</code></pre>

<hr>
<h2 id='web-fonts'>Download and add web font</h2><span id='topic+web-fonts'></span><span id='topic+get_from_google_fonts'></span><span id='topic+get_from_font_squirrel'></span>

<h3>Description</h3>

<p>In order to use a font in R it must first be made available locally. These
functions facilitate the download and registration of fonts from online
repositories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_from_google_fonts(family, dir = "~/fonts", woff2 = FALSE)

get_from_font_squirrel(family, dir = "~/fonts")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="web-fonts_+3A_family">family</code></td>
<td>
<p>The font family to download (case insensitive)</p>
</td></tr>
<tr><td><code id="web-fonts_+3A_dir">dir</code></td>
<td>
<p>Where to download the font to. The default places it in your user
local font folder so that the font will be available automatically in new R
sessions. Set to <code>tempdir()</code> to only keep the font for the session.</p>
</td></tr>
<tr><td><code id="web-fonts_+3A_woff2">woff2</code></td>
<td>
<p>Should the font be downloaded in the woff2 format (smaller and
more optimized)? Defaults to FALSE as the format is not supported on all
systems</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical invisibly indicating whether a font was found and
downloaded or not
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
