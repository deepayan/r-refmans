<!DOCTYPE html><html><head><title>Help for package systemfonts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {systemfonts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#systemfonts-package'><p>systemfonts: System Native Font Finding</p></a></li>
<li><a href='#font_fallback'><p>Get the fallback font for a given string</p></a></li>
<li><a href='#font_feature'><p>Define OpenType font feature settings</p></a></li>
<li><a href='#font_info'><p>Query font-specific information</p></a></li>
<li><a href='#get_fallback'><p>Get location of the fallback font</p></a></li>
<li><a href='#glyph_info'><p>Query glyph-specific information from fonts</p></a></li>
<li><a href='#match_font'><p>Find a system font by name and style</p></a></li>
<li><a href='#register_font'><p>Register font collections as families</p></a></li>
<li><a href='#register_variant'><p>Register a font as a variant as an existing one</p></a></li>
<li><a href='#reset_font_cache'><p>Reset the system font cache</p></a></li>
<li><a href='#shape_string'><p>Calculate glyph positions for strings</p></a></li>
<li><a href='#str_split_emoji'><p>Split a string into emoji and non-emoji glyph runs</p></a></li>
<li><a href='#string_metrics_dev'><p>Get string metrics as measured by the current device</p></a></li>
<li><a href='#string_width'><p>Calculate the width of a string, ignoring new-lines</p></a></li>
<li><a href='#string_widths_dev'><p>Get string widths as measured by the current device</p></a></li>
<li><a href='#system_fonts'><p>List all fonts installed on your system</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>System Native Font Finding</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides system native access to the font catalogue. As font
    handling varies between systems it is difficult to correctly locate
    installed fonts across different operating systems. The 'systemfonts'
    package provides bindings to the native libraries on Windows, macOS
    and Linux for finding font files that can then be used further by e.g.
    graphic devices. The main use is intended to be from compiled code but
    'systemfonts' also provides access from R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/systemfonts">https://github.com/r-lib/systemfonts</a>,
<a href="https://systemfonts.r-lib.org">https://systemfonts.r-lib.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/systemfonts/issues">https://github.com/r-lib/systemfonts/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat (&ge; 2.1.0), tools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.2.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>fontconfig, freetype2</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-07 08:43:59 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Devon Govett [aut] (Author of font-manager),
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomas.pedersen@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='systemfonts-package'>systemfonts: System Native Font Finding</h2><span id='topic+systemfonts'></span><span id='topic+systemfonts-package'></span>

<h3>Description</h3>

<p>Provides system native access to the font catalogue. As font handling varies between systems it is difficult to correctly locate installed fonts across different operating systems. The 'systemfonts' package provides bindings to the native libraries on Windows, macOS and Linux for finding font files that can then be used further by e.g. graphic devices. The main use is intended to be from compiled code but 'systemfonts' also provides access from R.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomas.pedersen@rstudio.com">thomas.pedersen@rstudio.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jeroen Ooms <a href="mailto:jeroen@berkeley.edu">jeroen@berkeley.edu</a> (<a href="https://orcid.org/0000-0002-4035-0289">ORCID</a>)
</p>
</li>
<li><p> Devon Govett (Author of font-manager)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> RStudio [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/systemfonts">https://github.com/r-lib/systemfonts</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/systemfonts/issues">https://github.com/r-lib/systemfonts/issues</a>
</p>
</li></ul>


<hr>
<h2 id='font_fallback'>Get the fallback font for a given string</h2><span id='topic+font_fallback'></span>

<h3>Description</h3>

<p>A fallback font is a font to use as a substitute if the chosen font does not
contain the requested characters. Using font fallbacks means that the user
doesn't have to worry about mixing characters from different scripts or
mixing text and emojies. Fallback is calculated for the full string and the
result is platform specific. If no font covers all the characters in the
string an undefined &quot;best match&quot; is returned. The best approach is to figure
out which characters are not covered by your chosen font and figure out
fallbacks for these, rather than just request a fallback for the full string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>font_fallback(
  string,
  family = "",
  italic = FALSE,
  bold = FALSE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="font_fallback_+3A_string">string</code></td>
<td>
<p>The strings to find fallbacks for</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_italic">italic</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_path">path</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
<tr><td><code id="font_fallback_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with a <code>path</code> and <code>index</code> column giving fallback for the
specified string and font combinations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font_fallback("\U0001f604") # Smile emoji

</code></pre>

<hr>
<h2 id='font_feature'>Define OpenType font feature settings</h2><span id='topic+font_feature'></span>

<h3>Description</h3>

<p>This function encapsulates the specification of OpenType font features. Some
specific features have named arguments, but all available features can be
set by using its specific 4-letter tag For a list of the 4-letter tags
available see e.g. the overview on
<a href="https://en.wikipedia.org/wiki/List_of_typographic_features">Wikipedia</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>font_feature(ligatures = NULL, letters = NULL, numbers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="font_feature_+3A_ligatures">ligatures</code></td>
<td>
<p>Settings related to ligatures. One or more types of
ligatures to turn on (see details).</p>
</td></tr>
<tr><td><code id="font_feature_+3A_letters">letters</code></td>
<td>
<p>Settings related to the appearance of single
letters (as opposed to ligatures that substitutes multiple letters). See
details for supported values.</p>
</td></tr>
<tr><td><code id="font_feature_+3A_numbers">numbers</code></td>
<td>
<p>Settings related to the appearance of numbers. See details for
supported values.</p>
</td></tr>
<tr><td><code id="font_feature_+3A_...">...</code></td>
<td>
<p>key-value pairs with the key being the 4-letter tag and the value
being the setting (usually <code>TRUE</code> to turn it on).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>OpenType features are defined by a 4-letter tag along with an integer value.
Often that value is a simple <code>0</code> (off) or <code>1</code> (on), but some features support
additional values, e.g. stylistic alternates (<code>salt</code>) where a font may
provide multiple variants of a letter and the value will be used to chose
which one to use.
</p>
<p>Common features related to appearance may be given with a long form name to
either the <code>ligatures</code>, <code>letters</code>, or <code>numbers</code> argument to avoid remembering
the often arbitrary 4-letter tag. Providing a long form name is the same as
setting the tag to <code>1</code> and can thus not be used to set tags to other values.
</p>
<p>The possible long form names are given below with the tag in parenthesis:
</p>
<p><strong>Ligatures</strong>
</p>

<ul>
<li> <p><code>standard</code> (<em>liga</em>): Turns on standard multiple letter substitution
</p>
</li>
<li> <p><code>historical</code> (<em>hlig</em>): Use obsolete historical ligatures
</p>
</li>
<li> <p><code>contextual</code> (<em>clig</em>): Apply secondary ligatures based on the character
patterns surrounding the potential ligature
</p>
</li>
<li> <p><code>discretionary</code> (<em>dlig</em>): Use ornamental ligatures
</p>
</li></ul>

<p><strong>Letters</strong>
</p>

<ul>
<li> <p><code>swash</code> (<em>cswh</em>): Use contextual swashes (ornamental decorations)
</p>
</li>
<li> <p><code>alternates</code> (<em>calt</em>): Use alternate letter forms based on the sourrounding
pattern
</p>
</li>
<li> <p><code>historical</code> (<em>hist</em>): Use obsolete historical forms of the letters
</p>
</li>
<li> <p><code>localized</code> (<em>locl</em>): Use alternate forms preferred by the script language
</p>
</li>
<li> <p><code>randomize</code> (<em>rand</em>): Use random variants of the letters (e.g. to mimick
handwriting)
</p>
</li>
<li> <p><code>alt_annotation</code> (<em>nalt</em>): Use alternate annotations (e.g. circled digits)
</p>
</li>
<li> <p><code>stylistic</code> (<em>salt</em>): Use a stylistic alternative form of the letter
</p>
</li>
<li> <p><code>subscript</code> (<em>subs</em>): Set letter in subscript
</p>
</li>
<li> <p><code>superscript</code> (<em>sups</em>): Set letter in superscript
</p>
</li>
<li> <p><code>titling</code> (<em>titl</em>): Use letter forms well suited for large text and titles
</p>
</li>
<li> <p><code>small_caps</code> (<em>smcp</em>): Use small caps variants of the letters
</p>
</li></ul>

<p><strong>Numbers</strong>
</p>

<ul>
<li> <p><code>lining</code> (<em>lnum</em>): Use number variants that rest on the baseline
</p>
</li>
<li> <p><code>oldstyle</code> (<em>onum</em>): Use old style numbers that use descender and ascender
for various numbers
</p>
</li>
<li> <p><code>proportional</code> (<em>pnum</em>): Let numbers take up width based on the visual
width of the glyph
</p>
</li>
<li> <p><code>tabular</code> (<em>tnum</em>): Enforce all numbers to take up the same width
</p>
</li>
<li> <p><code>fractions</code> (<em>frac</em>): Convert numbers separated by <code>/</code> into a fraction
glyph
</p>
</li>
<li> <p><code>fractions_alt</code> (<em>afrc</em>): Use alternate fraction form with a horizontal
divider
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>font_feature</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font_feature(letters = "stylistic", numbers = c("lining", "tabular"))

# Use the tag directly to access additional stylistic variants
font_feature(numbers = c("lining", "tabular"), salt = 2)

</code></pre>

<hr>
<h2 id='font_info'>Query font-specific information</h2><span id='topic+font_info'></span>

<h3>Description</h3>

<p>Get general information about a font, relative to a given size. Size specific
measures will be returned in pixel units. The function is vectorised to the
length of the longest argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>font_info(
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="font_info_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="font_info_+3A_italic">italic</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="font_info_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="font_info_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="font_info_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="font_info_+3A_path">path</code>, <code id="font_info_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame giving info on the requested font + size combinations. The
data.frame will contain the following columns:
</p>

<dl>
<dt>path</dt><dd><p>The path to the font file</p>
</dd>
<dt>index</dt><dd><p>The 0-based index of the font in the fontfile</p>
</dd>
<dt>family</dt><dd><p>The family name of the font</p>
</dd>
<dt>style</dt><dd><p>The style name of the font</p>
</dd>
<dt>italic</dt><dd><p>A logical giving if the font is italic</p>
</dd>
<dt>bold</dt><dd><p>A logical giving if the font is bold</p>
</dd>
<dt>monospace</dt><dd><p>A logical giving if the font is monospace</p>
</dd>
<dt>weight</dt><dd><p>A factor giving the weight of the font</p>
</dd>
<dt>width</dt><dd><p>A factor giving the width of the font</p>
</dd>
<dt>kerning</dt><dd><p>A logical giving if the font supports kerning</p>
</dd>
<dt>color</dt><dd><p>A logical giving if the font has color glyphs</p>
</dd>
<dt>scalable</dt><dd><p>A logical giving if the font is scalable</p>
</dd>
<dt>vertical</dt><dd><p>A logical giving if the font is vertical</p>
</dd>
<dt>n_glyphs</dt><dd><p>The number of glyphs in the font</p>
</dd>
<dt>n_sizes</dt><dd><p>The number of predefined sizes in the font</p>
</dd>
<dt>n_charmaps</dt><dd><p>The number of character mappings in the font file</p>
</dd>
<dt>bbox</dt><dd><p>A bounding box large enough to contain any of the glyphs in the font</p>
</dd>
<dt>max_ascend</dt><dd><p>The maximum ascend of the tallest glyph in the font</p>
</dd>
<dt>max_descent</dt><dd><p>The maximum descend of the most descending glyph in the font</p>
</dd>
<dt>max_advance_width</dt><dd><p>The maximum horizontal advance a glyph can make</p>
</dd>
<dt>max_advance_height</dt><dd><p>The maximum vertical advance a glyph can make</p>
</dd>
<dt>lineheight</dt><dd><p>The height of a single line of text in the font</p>
</dd>
<dt>underline_pos</dt><dd><p>The position of a potential underlining segment</p>
</dd>
<dt>underline_size</dt><dd><p>The width the the underline</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>font_info('serif')

# Avoid lookup if font file is already known
sans &lt;- match_font('sans')
font_info(path = sans$path, index = sans$index)

</code></pre>

<hr>
<h2 id='get_fallback'>Get location of the fallback font</h2><span id='topic+get_fallback'></span>

<h3>Description</h3>

<p>Get location of the fallback font
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fallback()
</code></pre>

<hr>
<h2 id='glyph_info'>Query glyph-specific information from fonts</h2><span id='topic+glyph_info'></span>

<h3>Description</h3>

<p>This function allows you to extract information about the individual glyphs
in a font, based on a specified size. All size related measures are in
pixel-units. The function is vectorised to the length of the <code>glyphs</code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glyph_info(
  glyphs,
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glyph_info_+3A_glyphs">glyphs</code></td>
<td>
<p>A vector of glyphs. Strings will be split into separate glyphs
automatically</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_italic">italic</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="glyph_info_+3A_path">path</code>, <code id="glyph_info_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with information about each glyph, containing the following
columns:
</p>

<dl>
<dt>glyph</dt><dd><p>The glyph as a character</p>
</dd>
<dt>index</dt><dd><p>The index of the glyph in the font file</p>
</dd>
<dt>width</dt><dd><p>The width of the glyph</p>
</dd>
<dt>height</dt><dd><p>The height of the glyph</p>
</dd>
<dt>x_bearing</dt><dd><p>The horizontal distance from the origin to the leftmost part of the glyph</p>
</dd>
<dt>y_bearing</dt><dd><p>The vertical distance from the origin to the top part of the glyph</p>
</dd>
<dt>x_advance</dt><dd><p>The horizontal distance to move the cursor after adding the glyph</p>
</dd>
<dt>y_advance</dt><dd><p>The vertical distance to move the cursor after adding the glyph</p>
</dd>
<dt>bbox</dt><dd><p>The tight bounding box surrounding the glyph</p>
</dd>
</dl>


<hr>
<h2 id='match_font'>Find a system font by name and style</h2><span id='topic+match_font'></span>

<h3>Description</h3>

<p>This function locates the font file (and index) best matching a name and
optional style (italic/bold). A font file will be returned even if a match
isn't found, but it is not necessarily similar to the requested family and
it should not be relied on for font substitution. The aliases <code>"sans"</code>,
<code>"serif"</code>, and <code>"mono"</code> match to the system default sans-serif, serif, and
mono fonts respectively (<code>""</code> is equivalent to <code>"sans"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_font(family, italic = FALSE, bold = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_font_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="match_font_+3A_italic">italic</code>, <code id="match_font_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the path locating the font file and the 0-based
index of the font in the file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the system default sans-serif font in italic
match_font('sans', italic = TRUE)

</code></pre>

<hr>
<h2 id='register_font'>Register font collections as families</h2><span id='topic+register_font'></span><span id='topic+registry_fonts'></span><span id='topic+clear_registry'></span>

<h3>Description</h3>

<p>By design, systemfonts searches the fonts installed natively on the system.
It is possible, however, to register other fonts from e.g. font packages or
local font files, that will get searched before searching any installed
fonts. You can always get an overview over all registered fonts with the
<code>registry_fonts()</code> function that works as a registry focused analogue to
<code><a href="#topic+system_fonts">system_fonts()</a></code>. If you wish to clear out the registry, you can either
restart the R session or call <code>clear_registry()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_font(
  name,
  plain,
  bold = plain,
  italic = plain,
  bolditalic = plain,
  features = font_feature()
)

registry_fonts()

clear_registry()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_font_+3A_name">name</code></td>
<td>
<p>The name the collection will be known under (i.e. <em>family</em>)</p>
</td></tr>
<tr><td><code id="register_font_+3A_plain">plain</code>, <code id="register_font_+3A_bold">bold</code>, <code id="register_font_+3A_italic">italic</code>, <code id="register_font_+3A_bolditalic">bolditalic</code></td>
<td>
<p>Fontfiles for the different faces of the
collection. can either be a filepath or a list containing a filepath and an
index (only for font files containing multiple fonts). If not given it will
default to the <code>plain</code> specification.</p>
</td></tr>
<tr><td><code id="register_font_+3A_features">features</code></td>
<td>
<p>A <code><a href="#topic+font_feature">font_feature</a></code> object describing the specific OpenType
font features to turn on for the registered font.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>register_font</code> also makes it possible to use system fonts with traits that
is not covered by the graphic engine in R. In plotting operations it is only
possible to specify a family name and whether or not the font should be bold
and/or italic. There are numerous fonts that will never get matched to this,
especially because bold is only one of many weights.
</p>
<p>Apart from granting a way to use new varieties of fonts, font registration
also allows you to override the default <code>sans</code>, <code>serif</code>, and <code>mono</code> mappings,
simply by registering a collection to the relevant default name. As
registered fonts are searched first it will take precedence over the default.
</p>


<h3>Value</h3>

<p><code>register_font()</code> and <code>clear_registry()</code> returns <code>NULL</code> invisibly.
<code>registry_fonts()</code> returns a data table in the same style as <code><a href="#topic+system_fonts">system_fonts()</a></code>
though less detailed and not based on information in the font file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random font collection
fonts &lt;- system_fonts()
plain &lt;- sample(which(!fonts$italic &amp; fonts$weight &lt;= 'normal'), 1)
bold &lt;- sample(which(!fonts$italic &amp; fonts$weight &gt; 'normal'), 1)
italic &lt;- sample(which(fonts$italic &amp; fonts$weight &lt;= 'normal'), 1)
bolditalic &lt;- sample(which(fonts$italic &amp; fonts$weight &gt; 'normal'), 1)
register_font(
  'random', 
  plain = list(fonts$path[plain], fonts$index[plain]), 
  bold = list(fonts$path[bold], fonts$index[bold]), 
  italic = list(fonts$path[italic], fonts$index[italic]),
  bolditalic = list(fonts$path[bolditalic], fonts$index[bolditalic])
)

# Look at your creation
registry_fonts()

# Reset
clear_registry()

</code></pre>

<hr>
<h2 id='register_variant'>Register a font as a variant as an existing one</h2><span id='topic+register_variant'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="#topic+register_font">register_font()</a></code> that allows you to easily
create variants of existing system fonts, e.g. to target different weights
and/or widths, or for attaching OpenType features to a font.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_variant(
  name,
  family,
  weight = NULL,
  width = NULL,
  features = font_feature()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_variant_+3A_name">name</code></td>
<td>
<p>The new family name the variant should respond to</p>
</td></tr>
<tr><td><code id="register_variant_+3A_family">family</code></td>
<td>
<p>The name of an existing font family that this is a variant of</p>
</td></tr>
<tr><td><code id="register_variant_+3A_weight">weight</code></td>
<td>
<p>One or two of <code>"thin"</code>, <code>"ultralight"</code>, <code>"light"</code>, <code>"normal"</code>,
<code>"medium"</code>, <code>"semibold"</code>, <code>"bold"</code>, <code>"ultrabold"</code>, or <code>"heavy"</code>. If one is
given it sets the weight for the whole variant. If two is given the first
one defines the plain weight and the second the bold weight. If <code>NULL</code> then
the variants of the given family closest to <code>"normal"</code> and <code>"bold"</code> will be
chosen.</p>
</td></tr>
<tr><td><code id="register_variant_+3A_width">width</code></td>
<td>
<p>One of <code>"ultracondensed"</code>, <code>"extracondensed"</code>, <code>"condensed"</code>,
<code>"semicondensed"</code>, <code>"normal"</code>, <code>"semiexpanded"</code>, <code>"expanded"</code>,
<code>"extraexpanded"</code>, or <code>"ultraexpanded"</code> giving the width of the variant. If
<code>NULL</code> then the width closest to <code>"normal"</code> will be chosen.</p>
</td></tr>
<tr><td><code id="register_variant_+3A_features">features</code></td>
<td>
<p>A <code><a href="#topic+font_feature">font_feature</a></code> object describing the specific OpenType
font features to turn on for the registered font variant.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Get the default "sans" family
sans &lt;- match_font("sans")$path
sans &lt;- system_fonts()$family[system_fonts()$path == sans][1]

# Register a variant of it:
register_variant(
  "sans_ligature", 
  sans, 
  features = font_feature(ligatures = "discretionary")
)

registry_fonts()

# clean up
clear_registry()
</code></pre>

<hr>
<h2 id='reset_font_cache'>Reset the system font cache</h2><span id='topic+reset_font_cache'></span>

<h3>Description</h3>

<p>Building the list of system fonts is time consuming and is therefore cached.
This, in turn, means that changes to the system fonts (i.e. installing new
fonts), will not propagate to systemfonts. The solution is to reset the
cache, which will result in the next call to e.g. <code><a href="#topic+match_font">match_font()</a></code> will trigger
a rebuild of the cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_font_cache()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>all_fonts &lt;- system_fonts()

##-- Install a new font on the system --##

all_fonts_new &lt;- system_fonts()

## all_fonts_new will be equal to all_fonts

reset_font_cache()

all_fonts_new &lt;- system_fonts()

## all_fonts_new will now contain the new font

</code></pre>

<hr>
<h2 id='shape_string'>Calculate glyph positions for strings</h2><span id='topic+shape_string'></span>

<h3>Description</h3>

<p>Do basic text shaping of strings. This function will use freetype to
calculate advances, doing kerning if possible. It will not perform any font
substitution or ligature resolving and will thus be much in line with how
the standard graphic devices does text shaping. Inputs are recycled to the
length of <code>strings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_string(
  strings,
  id = NULL,
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  lineheight = 1,
  align = "left",
  hjust = 0,
  vjust = 0,
  width = NA,
  tracking = 0,
  indent = 0,
  hanging = 0,
  space_before = 0,
  space_after = 0,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shape_string_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to shape</p>
</td></tr>
<tr><td><code id="shape_string_+3A_id">id</code></td>
<td>
<p>A vector grouping the strings together. If strings share an id the
shaping will continue between strings</p>
</td></tr>
<tr><td><code id="shape_string_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="shape_string_+3A_italic">italic</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="shape_string_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="shape_string_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="shape_string_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="shape_string_+3A_lineheight">lineheight</code></td>
<td>
<p>A multiplier for the lineheight</p>
</td></tr>
<tr><td><code id="shape_string_+3A_align">align</code></td>
<td>
<p>Within text box alignment, either <code>'left'</code>, <code>'center'</code>, or
<code>'right'</code></p>
</td></tr>
<tr><td><code id="shape_string_+3A_hjust">hjust</code>, <code id="shape_string_+3A_vjust">vjust</code></td>
<td>
<p>The justification of the textbox surrounding the text</p>
</td></tr>
<tr><td><code id="shape_string_+3A_width">width</code></td>
<td>
<p>The requested with of the string in inches. Setting this to
something other than <code>NA</code> will turn on word wrapping.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_tracking">tracking</code></td>
<td>
<p>Tracking of the glyphs (space adjustment) measured in 1/1000
em.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_indent">indent</code></td>
<td>
<p>The indent of the first line in a paragraph measured in inches.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_hanging">hanging</code></td>
<td>
<p>The indent of the remaining lines in a paragraph measured in
inches.</p>
</td></tr>
<tr><td><code id="shape_string_+3A_space_before">space_before</code>, <code id="shape_string_+3A_space_after">space_after</code></td>
<td>
<p>The spacing above and below a paragraph,
measured in points</p>
</td></tr>
<tr><td><code id="shape_string_+3A_path">path</code>, <code id="shape_string_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two element: <code>shape</code> contains the position of each glyph,
relative to the origin in the enclosing textbox. <code>metrics</code> contain metrics
about the full strings.
</p>
<p><code>shape</code> is a data.frame with the following columns:
</p>

<dl>
<dt>glyph</dt><dd><p>The glyph as a character</p>
</dd>
<dt>index</dt><dd><p>The index of the glyph in the font file</p>
</dd>
<dt>metric_id</dt><dd><p>The index of the string the glyph is part of (referencing a row in the <code>metrics</code> data.frame)</p>
</dd>
<dt>string_id</dt><dd><p>The index of the string the glyph came from (referencing an element in the <code>strings</code> input)</p>
</dd>
<dt>x_offset</dt><dd><p>The x offset in pixels from the origin of the textbox</p>
</dd>
<dt>y_offset</dt><dd><p>The y offset in pixels from the origin of the textbox</p>
</dd>
<dt>x_mid</dt><dd><p>The x offset in pixels to the middle of the glyph, measured from the origin of the glyph</p>
</dd>
</dl>

<p><code>metrics</code> is a data.frame with the following columns:
</p>

<dl>
<dt>string</dt><dd><p>The text the string consist of</p>
</dd>
<dt>width</dt><dd><p>The width of the string</p>
</dd>
<dt>height</dt><dd><p>The height of the string</p>
</dd>
<dt>left_bearing</dt><dd><p>The distance from the left edge of the textbox and the leftmost glyph</p>
</dd>
<dt>right_bearing</dt><dd><p>The distance from the right edge of the textbox and the rightmost glyph</p>
</dd>
<dt>top_bearing</dt><dd><p>The distance from the top edge of the textbox and the topmost glyph</p>
</dd>
<dt>bottom_bearing</dt><dd><p>The distance from the bottom edge of the textbox and the bottommost glyph</p>
</dd>
<dt>left_border</dt><dd><p>The position of the leftmost edge of the textbox related to the origin</p>
</dd>
<dt>top_border</dt><dd><p>The position of the topmost edge of the textbox related to the origin</p>
</dd>
<dt>pen_x</dt><dd><p>The horizontal position of the next glyph after the string</p>
</dd>
<dt>pen_y</dt><dd><p>The vertical position of the next glyph after the string</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- "This is a long string\nLook; It spans multiple lines\nand all"

# Shape with default settings
shape_string(string)

# Mix styles within the same string
string &lt;- c(
  "This string will have\na ",
  "very large",
  " text style\nin the middle"
)

shape_string(string, id = c(1, 1, 1), size = c(12, 24, 12))

</code></pre>

<hr>
<h2 id='str_split_emoji'>Split a string into emoji and non-emoji glyph runs</h2><span id='topic+str_split_emoji'></span>

<h3>Description</h3>

<p>In order to do correct text rendering, the font needed must be figured out. A
common case is rendering of emojis within a string where the system emoji
font is used rather than the requested font. This function will inspect the
provided strings and split them up in runs that must be rendered with the
emoji font, and the rest. Arguments are recycled to the length of the <code>string</code>
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_split_emoji(
  string,
  family = "",
  italic = FALSE,
  bold = FALSE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_split_emoji_+3A_string">string</code></td>
<td>
<p>A character vector of strings that should be splitted.</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_italic">italic</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="str_split_emoji_+3A_path">path</code>, <code id="str_split_emoji_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the following columns:
</p>

<dl>
<dt>string</dt><dd><p>The substring containing a consecutive run of glyphs</p>
</dd>
<dt>id</dt><dd><p>The index into the original <code>string</code> vector that the substring is part of</p>
</dd>
<dt>emoji</dt><dd><p>A logical vector giving if the substring is a run of emojis or not</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>emoji_string &lt;- "This is a joke\U0001f642. It should be obvious from the smiley"
str_split_emoji(emoji_string)

</code></pre>

<hr>
<h2 id='string_metrics_dev'>Get string metrics as measured by the current device</h2><span id='topic+string_metrics_dev'></span>

<h3>Description</h3>

<p>This function is much like <code><a href="#topic+string_widths_dev">string_widths_dev()</a></code> but also returns the ascent
and descent of the string making it possible to construct a tight bounding
box around the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_metrics_dev(
  strings,
  family = "",
  face = 1,
  size = 12,
  cex = 1,
  unit = "cm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_metrics_dev_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to measure</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_family">family</code></td>
<td>
<p>The font families to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_face">face</code></td>
<td>
<p>The font faces to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_size">size</code></td>
<td>
<p>The font size to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_cex">cex</code></td>
<td>
<p>The cex multiplier to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_metrics_dev_+3A_unit">unit</code></td>
<td>
<p>The unit to return the width in. Either <code>"cm"</code>, <code>"inches"</code>,
<code>"device"</code>, or <code>"relative"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with <code>width</code>, <code>ascent</code>, and <code>descent</code> columns giving the
metrics in the requested unit.
</p>


<h3>See Also</h3>

<p>Other device metrics: 
<code><a href="#topic+string_widths_dev">string_widths_dev</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the metrics as measured in cm (default)
string_metrics_dev(c('some text', 'a string with descenders'))

</code></pre>

<hr>
<h2 id='string_width'>Calculate the width of a string, ignoring new-lines</h2><span id='topic+string_width'></span>

<h3>Description</h3>

<p>This is a very simple alternative to <code><a href="#topic+shape_string">shape_string()</a></code> that simply calculates
the width of strings without taking any newline into account. As such it is
suitable to calculate the width of words or lines that has already been
splitted by <code style="white-space: pre;">&#8288;\n&#8288;</code>. Input is recycled to the length of <code>strings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_width(
  strings,
  family = "",
  italic = FALSE,
  bold = FALSE,
  size = 12,
  res = 72,
  include_bearing = TRUE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_width_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings</p>
</td></tr>
<tr><td><code id="string_width_+3A_family">family</code></td>
<td>
<p>The name of the font family</p>
</td></tr>
<tr><td><code id="string_width_+3A_italic">italic</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="string_width_+3A_bold">bold</code></td>
<td>
<p>logicals indicating the font style</p>
</td></tr>
<tr><td><code id="string_width_+3A_size">size</code></td>
<td>
<p>The pointsize of the font to use for size related measures</p>
</td></tr>
<tr><td><code id="string_width_+3A_res">res</code></td>
<td>
<p>The ppi of the size related mesures</p>
</td></tr>
<tr><td><code id="string_width_+3A_include_bearing">include_bearing</code></td>
<td>
<p>Logical, should left and right bearing be included in
the string width?</p>
</td></tr>
<tr><td><code id="string_width_+3A_path">path</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
<tr><td><code id="string_width_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the width of the strings in pixels. Use the
provided <code>res</code> value to convert it into absolute values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c('A short string', 'A very very looong string')
string_width(strings)

</code></pre>

<hr>
<h2 id='string_widths_dev'>Get string widths as measured by the current device</h2><span id='topic+string_widths_dev'></span>

<h3>Description</h3>

<p>For certain composition tasks it is beneficial to get the width of a string
as interpreted by the device that is going to plot it. grid provides this
through construction of a <code>textGrob</code> and then converting the corresponding
grob width to e.g. cm, but this comes with a huge overhead.
<code>string_widths_dev()</code> provides direct, vectorised, access to the graphic
device for as high performance as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>string_widths_dev(
  strings,
  family = "",
  face = 1,
  size = 12,
  cex = 1,
  unit = "cm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="string_widths_dev_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to measure</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_family">family</code></td>
<td>
<p>The font families to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_face">face</code></td>
<td>
<p>The font faces to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_size">size</code></td>
<td>
<p>The font size to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_cex">cex</code></td>
<td>
<p>The cex multiplier to use. Will get recycled</p>
</td></tr>
<tr><td><code id="string_widths_dev_+3A_unit">unit</code></td>
<td>
<p>The unit to return the width in. Either <code>"cm"</code>, <code>"inches"</code>,
<code>"device"</code>, or <code>"relative"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the width of each of the strings given in
<code>strings</code> in the unit given in <code>unit</code>
</p>


<h3>See Also</h3>

<p>Other device metrics: 
<code><a href="#topic+string_metrics_dev">string_metrics_dev</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the widths as measured in cm (default)
string_widths_dev(c('a string', 'an even longer string'))

</code></pre>

<hr>
<h2 id='system_fonts'>List all fonts installed on your system</h2><span id='topic+system_fonts'></span>

<h3>Description</h3>

<p>List all fonts installed on your system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>system_fonts()
</code></pre>


<h3>Value</h3>

<p>A data frame with a row for each font and various information in each
column
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See all monospace fonts
fonts &lt;- system_fonts()
fonts[fonts$monospace, ]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
