<!DOCTYPE html><html><head><title>Help for package srvyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {srvyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#as_srvyr_result_df'><p>Create a srvyr results data.frame which is automatically unpacked by srvyr</p></a></li>
<li><a href='#as_survey'><p>Create a tbl_svy from a data.frame</p></a></li>
<li><a href='#as_survey_design'><p>Create a tbl_svy survey object using sampling design</p></a></li>
<li><a href='#as_survey_rep'><p>Create a tbl_svy survey object using replicate weights</p></a></li>
<li><a href='#as_survey_twophase'><p>Create a tbl_svy survey object using two phase design</p></a></li>
<li><a href='#as_tibble'><p>Coerce survey variables to a data frame (tibble)</p></a></li>
<li><a href='#cascade'><p>Summarise multiple values into cascading groups</p></a></li>
<li><a href='#collect'><p>Force computation of a database query</p></a></li>
<li><a href='#cur_svy'><p>Get the survey data for the current context</p></a></li>
<li><a href='#cur_svy_wts'><p>Get the full-sample weights for the current context</p></a></li>
<li><a href='#dplyr_filter_joins'><p>Filtering joins from dplyr</p></a></li>
<li><a href='#get_var_est'><p>Get the variance estimates for a survey estimate</p></a></li>
<li><a href='#group_by'><p>Group a (survey) dataset by one or more variables.</p></a></li>
<li><a href='#group_map_dfr'><p>Apply a function to each group</p></a></li>
<li><a href='#group_trim'><p>Single table verbs from dplyr and tidyr</p></a></li>
<li><a href='#groups'><p>Get/set the grouping variables for tbl.</p></a></li>
<li><a href='#interact'><p>Create interaction terms to group by when summarizing</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rlang-tidyeval'><p>Tidy eval helpers from rlang</p></a></li>
<li><a href='#set_survey_vars'><p>Set the variables for the current survey variable</p></a></li>
<li><a href='#srvyr'><p>srvyr: A package for 'dplyr'-Like Syntax for Summary Statistics of Survey Data.</p></a></li>
<li><a href='#srvyr_interaction'><p>srvyr interaction column</p></a></li>
<li><a href='#srvyr-se-deprecated'><p>Deprecated SE versions of main srvyr verbs</p></a></li>
<li><a href='#summarise'><p>Summarise multiple values to a single value.</p></a></li>
<li><a href='#summarise_all'><p>Manipulate multiple columns.</p></a></li>
<li><a href='#survey_corr'><p>Calculate correlation and its variation using survey methods</p></a></li>
<li><a href='#survey_mean'><p>Calculate mean/proportion and its variation using survey methods</p></a></li>
<li><a href='#survey_old_quantile'><p>Calculate the quantile and its variation using survey methods</p></a></li>
<li><a href='#survey_quantile'><p>Calculate the quantile and its variation using survey methods</p></a></li>
<li><a href='#survey_ratio'><p>Calculate the ratio and its variation using survey methods</p></a></li>
<li><a href='#survey_tally'><p>Count/tally survey weighted observations by group</p></a></li>
<li><a href='#survey_total'><p>Calculate the total and its variation using survey methods</p></a></li>
<li><a href='#survey_var'><p>Calculate the population variance and its variation using survey methods</p></a></li>
<li><a href='#svychisq'><p>Chisquared tests of association for survey data.</p></a></li>
<li><a href='#tbl_svy'><p>tbl_svy object.</p></a></li>
<li><a href='#tbl_vars'><p>List variables produced by a tbl.</p></a></li>
<li><a href='#uninteract'><p>Break interaction vectors back into component columns</p></a></li>
<li><a href='#unweighted'><p>Calculate the an unweighted summary statistic from a survey</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'dplyr'-Like Syntax for Summary Statistics of Survey Data</td>
</tr>
<tr>
<td>Description:</td>
<td>Use piping, verbs like 'group_by' and 'summarize', and other
    'dplyr' inspired syntactic style when calculating summary statistics on survey
    data using functions from the 'survey' package.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-20</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://gdfe.co/srvyr/">http://gdfe.co/srvyr/</a>, <a href="https://github.com/gergness/srvyr/">https://github.com/gergness/srvyr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gergness/srvyr/issues">https://github.com/gergness/srvyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.0), magrittr, methods, rlang, survey (&ge; 4.1),
tibble, tidyr, tidyselect, vctrs (&ge; 0.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, convey, DBI, dbplyr, ggplot2, knitr, laeken,
Matrix, rmarkdown (&ge; 2.2.2), pander, RSQLite, survival,
testthat, covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-21 03:02:13 UTC; gregfreedmanellis</td>
</tr>
<tr>
<td>Author:</td>
<td>Greg Freedman Ellis [aut, cre],
  Thomas Lumley [ctb],
  Tomasz Żółtak [ctb],
  Ben Schneider [aut, ctb],
  Pavel N. Krivitsky [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Greg Freedman Ellis &lt;greg.freedman@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-21 04:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code><a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='as_srvyr_result_df'>Create a srvyr results data.frame which is automatically unpacked by srvyr</h2><span id='topic+as_srvyr_result_df'></span>

<h3>Description</h3>

<p>srvyr uses data.frame columns wrapped by this function to know when to
automatically unpack the results for the user. When developing extensions
(see vignette <code>extending-srvyr</code>), use this function to wrap the result
in so that <code>summarize</code> knows to unpack them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_srvyr_result_df(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_srvyr_result_df_+3A_x">x</code></td>
<td>
<p>A data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with the <code>srvyr_result_df</code> added
</p>

<hr>
<h2 id='as_survey'>Create a tbl_svy from a data.frame</h2><span id='topic+as_survey'></span><span id='topic+as_survey.tbl_svy'></span><span id='topic+as_survey.data.frame'></span><span id='topic+as_survey.tbl_lazy'></span><span id='topic+as_survey.survey.design2'></span><span id='topic+as_survey.svyrep.design'></span><span id='topic+as_survey.twophase2'></span>

<h3>Description</h3>

<p><code>as_survey</code> can be used to create a <code>tbl_svy</code> using design information
(<code><a href="#topic+as_survey_design">as_survey_design</a></code>), replicate weights (<code><a href="#topic+as_survey_rep">as_survey_rep</a></code>),
or a two phase design (<code><a href="#topic+as_survey_twophase">as_survey_twophase</a></code>), or an object created by the
survey package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_survey(.data, ...)

## S3 method for class 'tbl_svy'
as_survey(.data, ...)

## S3 method for class 'data.frame'
as_survey(.data, ...)

## S3 method for class 'tbl_lazy'
as_survey(.data, ...)

## S3 method for class 'survey.design2'
as_survey(.data, ...)

## S3 method for class 'svyrep.design'
as_survey(.data, ...)

## S3 method for class 'twophase2'
as_survey(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_survey_+3A_.data">.data</code></td>
<td>
<p>a data.frame or an object from the survey package</p>
</td></tr>
<tr><td><code id="as_survey_+3A_...">...</code></td>
<td>
<p>other arguments, see other functions for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("databases", package = "dplyr")</code>
for more information on setting up databases in dplyr.
</p>


<h3>Value</h3>

<p>a tbl_svy
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples from ?survey::svydesign
library(survey)
library(dplyr)
data(api)

# stratified sample
dstrata &lt;- apistrat %&gt;%
  as_survey(strata = stype, weights = pw)

# Examples from ?survey::svrepdesign
data(scd)
# use BRR replicate weights from Levy and Lemeshow
scd$rep1 &lt;- 2 * c(1, 0, 1, 0, 1, 0)
scd$rep2 &lt;- 2 * c(1, 0, 0, 1, 0, 1)
scd$rep3 &lt;- 2 * c(0, 1, 1, 0, 0, 1)
scd$rep4 &lt;- 2 * c(0, 1, 0, 1, 1, 0)

scdrep &lt;- scd %&gt;%
  as_survey(type = "BRR", repweights = starts_with("rep"),
                    combined_weights = FALSE)

# Examples from ?survey::twophase
# two-phase simple random sampling.
data(pbc, package="survival")

pbc &lt;- pbc %&gt;%
  mutate(randomized = !is.na(trt) &amp; trt &gt; 0,
         id = row_number())
d2pbc &lt;- pbc %&gt;%
  as_survey(id = list(id, id), subset = randomized)

# dplyr 0.7 introduced new style of NSE called quosures
# See `vignette("programming", package = "dplyr")` for details
st &lt;- quo(stype)
wt &lt;- quo(pw)
dstrata &lt;- apistrat %&gt;%
  as_survey(strata = !!st, weights = !!wt)
</code></pre>

<hr>
<h2 id='as_survey_design'>Create a tbl_svy survey object using sampling design</h2><span id='topic+as_survey_design'></span><span id='topic+as_survey_design.data.frame'></span><span id='topic+as_survey_design.survey.design2'></span><span id='topic+as_survey_design.tbl_lazy'></span>

<h3>Description</h3>

<p>Create a survey object with a survey design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_survey_design(.data, ...)

## S3 method for class 'data.frame'
as_survey_design(
  .data,
  ids = NULL,
  probs = NULL,
  strata = NULL,
  variables = NULL,
  fpc = NULL,
  nest = FALSE,
  check_strata = !nest,
  weights = NULL,
  pps = FALSE,
  variance = c("HT", "YG"),
  ...
)

## S3 method for class 'survey.design2'
as_survey_design(.data, ...)

## S3 method for class 'tbl_lazy'
as_survey_design(
  .data,
  ids = NULL,
  probs = NULL,
  strata = NULL,
  variables = NULL,
  fpc = NULL,
  nest = FALSE,
  check_strata = !nest,
  weights = NULL,
  pps = FALSE,
  variance = c("HT", "YG"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_survey_design_+3A_.data">.data</code></td>
<td>
<p>A data frame (which contains the variables specified below)</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_ids">ids</code></td>
<td>
<p>Variables specifying cluster ids from largest level to smallest level
(leaving the argument empty, NULL, 1, or 0 indicate no clusters).</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_probs">probs</code></td>
<td>
<p>Variables specifying cluster sampling probabilities.</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_strata">strata</code></td>
<td>
<p>Variables specifying strata.</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_variables">variables</code></td>
<td>
<p>Variables specifying variables to be included in survey.
Defaults to all variables in .data</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_fpc">fpc</code></td>
<td>
<p>Variables specifying a finite population correct, see
<code><a href="survey.html#topic+svydesign">svydesign</a></code> for more details.</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_nest">nest</code></td>
<td>
<p>If <code>TRUE</code>, relabel cluster ids to enforce nesting within strata.</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_check_strata">check_strata</code></td>
<td>
<p>If <code>TRUE</code>, check that clusters are nested in strata.</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_weights">weights</code></td>
<td>
<p>Variables specifying weights (inverse of probability).</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_pps">pps</code></td>
<td>
<p>&quot;brewer&quot; to use Brewer's approximation for PPS sampling without replacement.
&quot;overton&quot; to use Overton's approximation. An object of class HR to use the Hartley-Rao
approximation. An object of class ppsmat to use the Horvitz-Thompson estimator.</p>
</td></tr>
<tr><td><code id="as_survey_design_+3A_variance">variance</code></td>
<td>
<p>For pps without replacement, use variance=&quot;YG&quot; for the Yates-Grundy estimator
instead of the Horvitz-Thompson estimator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If provided a data.frame, it is a wrapper
around <code><a href="survey.html#topic+svydesign">svydesign</a></code>. All survey variables must be included
in the data.frame itself. Variables are selected by using bare column names, or
convenience functions described in <code><a href="dplyr.html#topic+select">select</a></code>.
</p>
<p>If provided a <code>survey.design2</code> object from the survey package,
it will turn it into a srvyr object, so that srvyr functions will work with it
</p>


<h3>Value</h3>

<p>An object of class <code>tbl_svy</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples from ?survey::svydesign
library(survey)
data(api)

# stratified sample
dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

# one-stage cluster sample
dclus1 &lt;- apiclus1 %&gt;%
  as_survey_design(dnum, weights = pw, fpc = fpc)

# two-stage cluster sample: weights computed from population sizes.
dclus2 &lt;- apiclus2 %&gt;%
  as_survey_design(c(dnum, snum), fpc = c(fpc1, fpc2))

## multistage sampling has no effect when fpc is not given, so
## these are equivalent.
dclus2wr &lt;- apiclus2 %&gt;%
  dplyr::mutate(weights = weights(dclus2)) %&gt;%
  as_survey_design(c(dnum, snum), weights = weights)

dclus2wr2 &lt;- apiclus2 %&gt;%
  dplyr::mutate(weights = weights(dclus2)) %&gt;%
  as_survey_design(c(dnum), weights = weights)

## syntax for stratified cluster sample
## (though the data weren't really sampled this way)
apistrat %&gt;% as_survey_design(dnum, strata = stype, weights = pw,
                           nest = TRUE)

## PPS sampling without replacement
data(election)
dpps &lt;- election_pps %&gt;%
  as_survey_design(fpc = p, pps = "brewer")

# dplyr 0.7 introduced new style of NSE called quosures
# See `vignette("programming", package = "dplyr")` for details
st &lt;- quo(stype)
wt &lt;- quo(pw)
dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = !!st, weights = !!wt)

</code></pre>

<hr>
<h2 id='as_survey_rep'>Create a tbl_svy survey object using replicate weights</h2><span id='topic+as_survey_rep'></span><span id='topic+as_survey_rep.data.frame'></span><span id='topic+as_survey_rep.tbl_lazy'></span><span id='topic+as_survey_rep.svyrep.design'></span><span id='topic+as_survey_rep.survey.design2'></span><span id='topic+as_survey_rep.tbl_svy'></span>

<h3>Description</h3>

<p>Create a survey object with replicate weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_survey_rep(.data, ...)

## S3 method for class 'data.frame'
as_survey_rep(
  .data,
  variables = NULL,
  repweights = NULL,
  weights = NULL,
  type = c("BRR", "Fay", "JK1", "JKn", "bootstrap", "successive-difference", "ACS",
    "other"),
  combined_weights = TRUE,
  rho = NULL,
  bootstrap_average = NULL,
  scale = NULL,
  rscales = NULL,
  fpc = NULL,
  fpctype = c("fraction", "correction"),
  mse = getOption("survey.replicates.mse"),
  ...
)

## S3 method for class 'tbl_lazy'
as_survey_rep(
  .data,
  variables = NULL,
  repweights = NULL,
  weights = NULL,
  type = c("BRR", "Fay", "JK1", "JKn", "bootstrap", "successive-difference", "ACS",
    "other"),
  combined_weights = TRUE,
  rho = NULL,
  bootstrap_average = NULL,
  scale = NULL,
  rscales = NULL,
  fpc = NULL,
  fpctype = c("fraction", "correction"),
  mse = getOption("survey.replicates.mse"),
  ...
)

## S3 method for class 'svyrep.design'
as_survey_rep(.data, ...)

## S3 method for class 'survey.design2'
as_survey_rep(
  .data,
  type = c("auto", "JK1", "JKn", "BRR", "bootstrap", "subbootstrap", "mrbbootstrap",
    "Fay"),
  rho = 0,
  fpc = NULL,
  fpctype = NULL,
  ...,
  compress = TRUE,
  mse = getOption("survey.replicates.mse")
)

## S3 method for class 'tbl_svy'
as_survey_rep(
  .data,
  type = c("auto", "JK1", "JKn", "BRR", "bootstrap", "subbootstrap", "mrbbootstrap",
    "Fay"),
  rho = 0,
  fpc = NULL,
  fpctype = NULL,
  ...,
  compress = TRUE,
  mse = getOption("survey.replicates.mse")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_survey_rep_+3A_.data">.data</code></td>
<td>
<p>A data frame (which contains the variables specified below)</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_variables">variables</code></td>
<td>
<p>Variables to include in the design (default is all)</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_repweights">repweights</code></td>
<td>
<p>Variables specifying the replication weight variables</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_weights">weights</code></td>
<td>
<p>Variables specifying sampling weights</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_type">type</code></td>
<td>
<p>Type of replication weights</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_combined_weights">combined_weights</code></td>
<td>
<p><code>TRUE</code> if the <code>repweights</code> already
include the sampling weights. This is usually the case.</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_rho">rho</code></td>
<td>
<p>Shrinkage factor for weights in Fay's method</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_bootstrap_average">bootstrap_average</code></td>
<td>
<p>For <code>type = "bootstrap"</code>, if the bootstrap
weights have been averaged, gives the number of iterations averaged over.</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_scale">scale</code>, <code id="as_survey_rep_+3A_rscales">rscales</code></td>
<td>
<p>Scaling constant for variance, see
<code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> for more information.</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_fpc">fpc</code></td>
<td>
<p>Variables specifying a finite population correction, see
<code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> for more details.</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_fpctype">fpctype</code></td>
<td>
<p>Finite population correction information</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_mse">mse</code></td>
<td>
<p>if <code>TRUE</code>, compute variances based on sum of squares
around the point estimate, rather than the mean of the replicates</p>
</td></tr>
<tr><td><code id="as_survey_rep_+3A_compress">compress</code></td>
<td>
<p>if <code>TRUE</code>, store replicate weights in compressed form
(if converting from design)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If provided a data.frame, it is a wrapper around <code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code>.
All survey variables must be included in the data.frame itself. Variables are
selected by using bare column names, or convenience functions described in
<code><a href="dplyr.html#topic+select">select</a></code>.
</p>
<p>If provided a <code>svyrep.design</code> object from the survey package,
it will turn it into a srvyr object, so that srvyr functions will work with it
</p>
<p>If provided a survey design (<code>survey.design2</code> or <code>tbl_svy</code>), it is a wrapper
around <code><a href="survey.html#topic+as.svrepdesign">as.svrepdesign</a></code>, and will convert from a survey design to
replicate weights.
</p>


<h3>Value</h3>

<p>An object of class <code>tbl_svy</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples from ?survey::svrepdesign()
library(survey)
library(dplyr)
data(scd)
# use BRR replicate weights from Levy and Lemeshow
scd &lt;- scd %&gt;%
  mutate(rep1 = 2 * c(1, 0, 1, 0, 1, 0),
         rep2 = 2 * c(1, 0, 0, 1, 0, 1),
         rep3 = 2 * c(0, 1, 1, 0, 0, 1),
         rep4 = 2 * c(0, 1, 0, 1, 1, 0))

scdrep &lt;- scd %&gt;%
  as_survey_rep(type = "BRR", repweights = starts_with("rep"),
                combined_weights = FALSE)

# dplyr 0.7 introduced new style of NSE called quosures
# See `vignette("programming", package = "dplyr")` for details
repwts &lt;- quo(starts_with("rep"))
scdrep &lt;- scd %&gt;%
  as_survey_rep(type = "BRR", repweights = !!repwts,
                combined_weights = FALSE)

</code></pre>

<hr>
<h2 id='as_survey_twophase'>Create a tbl_svy survey object using two phase design</h2><span id='topic+as_survey_twophase'></span><span id='topic+as_survey_twophase.data.frame'></span><span id='topic+as_survey_twophase.twophase2'></span>

<h3>Description</h3>

<p>Create a survey object by specifying the survey's two phase design. It is a
wrapper around <code><a href="survey.html#topic+twophase">twophase</a></code>. All survey variables must be
included in the data.frame itself. Variables are selected by using bare
column names, or convenience functions described in
<code><a href="dplyr.html#topic+select">select</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_survey_twophase(.data, ...)

## S3 method for class 'data.frame'
as_survey_twophase(
  .data,
  id,
  strata = NULL,
  probs = NULL,
  weights = NULL,
  fpc = NULL,
  subset,
  method = c("full", "approx", "simple"),
  ...
)

## S3 method for class 'twophase2'
as_survey_twophase(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_survey_twophase_+3A_.data">.data</code></td>
<td>
<p>A data frame (which contains the variables specified below)</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_id">id</code></td>
<td>
<p>list of two sets of variable names for sampling unit identifiers</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_strata">strata</code></td>
<td>
<p>list of two sets of variable names (or <code>NULLs</code>) for stratum identifiers</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_probs">probs</code></td>
<td>
<p>list of two sets of variable names (or <code>NULLs</code>) for sampling probabilities</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_weights">weights</code></td>
<td>
<p>Only for method = &quot;approx&quot;, list of two sets of variable names (or <code>NULLs</code>)
for sampling weights</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_fpc">fpc</code></td>
<td>
<p>list of two sets of variables (or <code>NULLs</code> for finite population corrections</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_subset">subset</code></td>
<td>
<p>bare name of a variable which specifies which observations are selected in phase 2</p>
</td></tr>
<tr><td><code id="as_survey_twophase_+3A_method">method</code></td>
<td>
<p>&quot;full&quot; requires (much) more memory, but gives unbiased variance estimates for
general multistage designs at both phases. &quot;simple&quot; or &quot;approx&quot; use less memory, and is correct for
designs with simple random sampling at phase one and stratified randoms sampling at phase two. See
<code><a href="survey.html#topic+twophase">twophase</a></code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tbl_svy</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples from ?survey::twophase
# two-phase simple random sampling.
data(pbc, package="survival")
library(dplyr)

pbc &lt;- pbc %&gt;%
  mutate(randomized = !is.na(trt) &amp; trt &gt; 0,
         id = row_number())
d2pbc &lt;- pbc %&gt;%
  as_survey_twophase(id = list(id, id), subset = randomized)

d2pbc %&gt;% summarize(mean = survey_mean(bili))

# two-stage sampling as two-phase
library(survey)
data(mu284)

mu284_1 &lt;- mu284 %&gt;%
  dplyr::slice(c(1:15, rep(1:5, n2[1:5] - 3))) %&gt;%
  mutate(id = row_number(),
         sub = rep(c(TRUE, FALSE), c(15, 34-15)))

dmu284 &lt;- mu284 %&gt;%
  as_survey_design(ids = c(id1, id2), fpc = c(n1, n2))
# first phase cluster sample, second phase stratified within cluster
d2mu284 &lt;- mu284_1 %&gt;%
  as_survey_twophase(id = list(id1, id), strata = list(NULL, id1),
                  fpc = list(n1, NULL), subset = sub)
dmu284 %&gt;%
  summarize(total = survey_total(y1),
            mean = survey_mean(y1))
d2mu284 %&gt;%
  summarize(total = survey_total(y1),
            mean = survey_mean(y1))

# dplyr 0.7 introduced new style of NSE called quosures
# See `vignette("programming", package = "dplyr")` for details
ids &lt;- quo(list(id, id))
d2pbc &lt;- pbc %&gt;%
  as_survey_twophase(id = !!ids, subset = "randomized")

</code></pre>

<hr>
<h2 id='as_tibble'>Coerce survey variables to a data frame (tibble)</h2><span id='topic+as_tibble'></span>

<h3>Description</h3>

<p>Coerce survey variables to a data frame (tibble)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble_+3A_x">x</code></td>
<td>
<p>A <code>tbl_svy</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='cascade'>Summarise multiple values into cascading groups</h2><span id='topic+cascade'></span>

<h3>Description</h3>

<p><code>cascade</code> is similar to <code><a href="#topic+summarise">summarise</a></code>, but calculates
a summary statistics for the total of a group in addition to each group.
The groupings are chosen by &quot;unpeeling&quot; from the end of the groupings,
and also expanding out interactions to all terms (eg the interactions of
all combinations of subsets of variables as well as each variable on
it's own).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cascade(.data, ..., .fill = NA, .fill_level_top = FALSE, .groupings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cascade_+3A_.data">.data</code></td>
<td>
<p>tbl A <code>tbl_svy</code> object</p>
</td></tr>
<tr><td><code id="cascade_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions</p>
</td></tr>
<tr><td><code id="cascade_+3A_.fill">.fill</code></td>
<td>
<p>Value to fill in for group summaries</p>
</td></tr>
<tr><td><code id="cascade_+3A_.fill_level_top">.fill_level_top</code></td>
<td>
<p>When filling factor variables, whether to put the
value '.fill' in the first position (defaults to FALSE, placing it in
the bottom).</p>
</td></tr>
<tr><td><code id="cascade_+3A_.groupings">.groupings</code></td>
<td>
<p>(Experimental) A list of lists of quosures to manually
specify the groupings to use, rather than the default.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

# Calculates the means by stype and also for the whole
# sample
dstrata %&gt;%
  group_by(stype) %&gt;%
  cascade(api99_mn = survey_mean(api99),
            api00_mn = survey_mean(api00),
            api_diff = survey_mean(api00 - api99))

# Calculates the proportions by the interaction of stype &amp; awards
# as well as by each of those variable's groups alone, and finally
# the total as well
dstrata %&gt;%
  group_by(interact(stype, awards)) %&gt;%
  cascade(prop = survey_mean())

# Can also specify the .groupings manually, though this interface
# is a little ugly, as it requires passing a list of quosures or
# symbols you've created, rather than the usual syntax
dstrata %&gt;%
  cascade(
    prop = survey_mean(),
    .groupings = list(rlang::quos(stype, awards), rlang::quos(NULL))
  )

</code></pre>

<hr>
<h2 id='collect'>Force computation of a database query</h2><span id='topic+collect'></span><span id='topic+compute'></span>

<h3>Description</h3>

<p><code>collect</code> retrieves data from a database query (and when run
on a tbl_svy object adjusts weights accordingly). Use collect when
you want to run a function from the survey package on a srvyr db
backed object. <code>compute</code> stores results in a remote temporary
table.
</p>

<hr>
<h2 id='cur_svy'>Get the survey data for the current context</h2><span id='topic+cur_svy'></span><span id='topic+cur_svy_full'></span><span id='topic+current_svy'></span>

<h3>Description</h3>

<p>This is a helper to allow srvyr's syntactic style. In particular, it tells
functions inside of a summarize call what survey to use (for the current
group with <code>cur_svy()</code> or the complete survey for <code>cur_svy_full()</code>.
In general, users will not have to worry about getting (or setting) the current
context's survey, unless they are trying to extend srvyr.
See <code>vignette("extending-srvyr")</code> for more details. <code>current_svy()</code>
is deprecated, but returns the same value as <code>cur_svy()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cur_svy()

cur_svy_full()

current_svy()
</code></pre>


<h3>Value</h3>

<p>a tbl_svy (or error if called with no survey context)
</p>

<hr>
<h2 id='cur_svy_wts'>Get the full-sample weights for the current context</h2><span id='topic+cur_svy_wts'></span>

<h3>Description</h3>

<p>This is a helper to allow srvyr's syntactic style. This function allows quick access
to the full-sample weights for the current group, using <code>cur_svy_wts()</code>,
See <code>vignette("extending-srvyr")</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cur_svy_wts()
</code></pre>


<h3>Value</h3>

<p>a numeric vector containing full-sample weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(api, package = 'survey')

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarize(sum_of_weights = sum(cur_svy_wts()),
            kish_deff = var(cur_svy_wts())/(mean(cur_svy_wts())^2))

</code></pre>

<hr>
<h2 id='dplyr_filter_joins'>Filtering joins from dplyr</h2><span id='topic+dplyr_filter_joins'></span><span id='topic+semi_join'></span><span id='topic+anti_join'></span>

<h3>Description</h3>

<p>These are data manipulation functions designed to work on a <code>tbl_svy</code> object
and another data frame or <code>tbl_svy</code> object.
</p>


<h3>Details</h3>

<p><code>semi_join</code> and <code>anti_join</code> filter certain observations from a <code>tbl_svy</code>
depending on the presence or absence of matches in another table.
See <code><a href="dplyr.html#topic+filter-joins">filter-joins</a></code> for more details.
</p>
<p>Mutating joins (<code>full_join</code>, <code>left_join</code>, etc.) are not implemented
for any <code>tbl_svy</code> objects. These data manipulations
may require modifications to the survey variable specifications and so
cannot be done automatically. Instead, use dplyr to perform them while the
data is still stored in data.frames.
</p>

<hr>
<h2 id='get_var_est'>Get the variance estimates for a survey estimate</h2><span id='topic+get_var_est'></span>

<h3>Description</h3>

<p>This is a helper to allow srvyr's syntactic style. In general, users
will not have to worry about getting survey variance estimates directly
unless they are trying to extend srvyr. This function helps convert from
the result of a survey function into a data.frame with an estimate and
measures of variance around it in a way that summarize expects.
See <code>vignette("extending-srvyr")</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_var_est(
  stat,
  vartype,
  grps = "",
  level = 0.95,
  df = Inf,
  pre_calc_ci = FALSE,
  deff = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_var_est_+3A_stat">stat</code></td>
<td>
<p>A survey statistic object, usually the result of a function from the survey
package or svyby.</p>
</td></tr>
<tr><td><code id="get_var_est_+3A_vartype">vartype</code></td>
<td>
<p>A vector indicating which variance estimates to calculate (options are
se for standard error, ci for confidence interval, var for variance or cv for
coefficient of variation). Multiples are allowed.</p>
</td></tr>
<tr><td><code id="get_var_est_+3A_grps">grps</code></td>
<td>
<p>A vector indicating the names of the grouping variables for grouped
surveys (&quot;&quot; indicates no groups).</p>
</td></tr>
<tr><td><code id="get_var_est_+3A_level">level</code></td>
<td>
<p>One or more levels to calculate a confidence interval.</p>
</td></tr>
<tr><td><code id="get_var_est_+3A_df">df</code></td>
<td>
<p>Degrees of freedom, many survey functions default to Inf, but srvyr functions
generally default to the result of calling degf on the survey object.</p>
</td></tr>
<tr><td><code id="get_var_est_+3A_pre_calc_ci">pre_calc_ci</code></td>
<td>
<p>Whether the confidence interval is pre-calculated (as in svyciprop)</p>
</td></tr>
<tr><td><code id="get_var_est_+3A_deff">deff</code></td>
<td>
<p>Whether to return the design effect (calculated using survey::deff)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tbl_svy with the variables modified
</p>

<hr>
<h2 id='group_by'>Group a (survey) dataset by one or more variables.</h2><span id='topic+group_by'></span><span id='topic+group_by_'></span>

<h3>Description</h3>

<p>Most data operations are useful when done on groups defined by variables
in the dataset. The <code>group_by</code> function takes an existing table (or
svy_table) and converts it to a grouped version, where operations are
performed &quot;by group&quot;.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_by_+3A_.data">.data</code></td>
<td>
<p>A tbl</p>
</td></tr>
<tr><td><code id="group_by_+3A_...">...</code></td>
<td>
<p>variables to group by. All tbls accept variable names, some will
also accept functions of variables. Duplicated groups will be silently dropped.</p>
</td></tr>
<tr><td><code id="group_by_+3A_add">add</code></td>
<td>
<p>By default, when <code>add = FALSE</code>, <code>group_by</code> will override
existing groups. To instead add to the existing groups, use <code>add = TRUE</code></p>
</td></tr>
<tr><td><code id="group_by_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation. See
<code>vignette("nse", package = "dplyr")</code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="dplyr.html#topic+group_by">group_by</a></code> for more information about grouping
regular data tables.
</p>
<p>On <code>tbl_svy</code> objects, <code>group_by</code> sets up the object for
operations similar to those allowed in <code><a href="survey.html#topic+svyby">svyby</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+group_by">group_by</a></code> for information about group_by on normal data tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples of svy_tbl group_by
library(survey)
data(api)
dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw) %&gt;%
  group_by(stype)

  dstrata %&gt;%
    summarise(api_diff = survey_mean(api00 - api99))
</code></pre>

<hr>
<h2 id='group_map_dfr'>Apply a function to each group</h2><span id='topic+group_map_dfr'></span><span id='topic+group_map.tbl_svy'></span>

<h3>Description</h3>

<p><code>group_map()</code>, <code>group_walk</code> and <code>group_map_dfr</code> are purrr-style
functions that can be used to iterate on grouped survey objects (note that
<code>group_map_dfr</code> replaces <code>dplyr::group_modify</code> because we are changing
the data from a <code>tbl_svy</code> to a regular tibble).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_map_dfr(.data, .f, ..., .keep = FALSE)

## S3 method for class 'tbl_svy'
group_map(.data, .f, ..., .keep = FALSE)

group_map_dfr(.data, .f, ..., .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_map_dfr_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl_svy object</code></p>
</td></tr>
<tr><td><code id="group_map_dfr_+3A_.f">.f</code></td>
<td>
<p>A function or purrr-style formula to apply to each group</p>
</td></tr>
<tr><td><code id="group_map_dfr_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>.f</code></p>
</td></tr>
<tr><td><code id="group_map_dfr_+3A_.keep">.keep</code></td>
<td>
<p>Whether the grouping variables are kept when passed into <code>.f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>group_map</code> a list, for <code>group_map_dfr</code> a 'tbl_df', and for
<code>group_walk</code> invisibly the original <code>tbl_svy</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(api, package = "survey")
dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

results &lt;- dstrata %&gt;%
  group_by(both) %&gt;%
  group_map(~survey::svyglm(api00~api99 + stype, .))

# group_map_dfr calls `bind_rows` on the list returned and includes
# grouping variables. This is most useful with a package like `broom`
# but could also be used with survey package functions.
result_coef &lt;- dstrata %&gt;%
  group_by(both) %&gt;%
  group_map_dfr(
    ~data.frame(
      api99_coef = coef(survey::svyglm(api00~api99 + stype, .))[["api99"]]
    )
  )

</code></pre>

<hr>
<h2 id='group_trim'>Single table verbs from dplyr and tidyr</h2><span id='topic+group_trim'></span><span id='topic+dplyr_single'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+select'></span><span id='topic+pull'></span><span id='topic+rename'></span><span id='topic+rename_with'></span><span id='topic+filter'></span><span id='topic+drop_na'></span>

<h3>Description</h3>

<p>These are data manipulation functions designed to work on <code>tbl_svy</code> objects.
</p>


<h3>Details</h3>

<p><code>mutate</code> and <code>transmute</code> can add or modify variables. See
<code><a href="dplyr.html#topic+mutate">mutate</a></code> for more details.
</p>
<p><code>select</code>, <code>rename</code>, and <code>rename_with</code> keep or rename variables. See
<code><a href="dplyr.html#topic+select">select</a></code> for more details.
</p>
<p><code>pull</code> extracts a variable as a vector (whereas <code>select</code> returns a <code>tbl_svy</code>).
See <code><a href="dplyr.html#topic+pull">pull</a></code> for more details.
</p>
<p><code>filter</code> keeps certain observations. See <code><a href="dplyr.html#topic+filter">filter</a></code>
for more details.
</p>
<p>#' <code>drop_na</code> drops observations containing missing values.
See <code><a href="tidyr.html#topic+drop_na">drop_na</a></code> for more details.
</p>
<p><code>arrange</code> is not implemented for <code>tbl_svy</code> objects. Nor are any
two table verbs such as <code>bind_rows</code>, <code>bind_cols</code> or any of the
joins (<code>full_join</code>, <code>left_join</code>, etc.). These data manipulations
may require modifications to the survey variable specifications and so
cannot be done automatically. Instead, use dplyr to perform them while the
data is still stored in data.frames.
</p>

<hr>
<h2 id='groups'>Get/set the grouping variables for tbl.</h2><span id='topic+groups'></span><span id='topic+ungroup'></span><span id='topic+group_vars'></span><span id='topic+group_data'></span><span id='topic+group_keys'></span><span id='topic+group_rows'></span><span id='topic+group_indices'></span><span id='topic+group_size'></span><span id='topic+n_groups'></span>

<h3>Description</h3>

<p>These functions do not perform non-standard evaluation, and
so are useful when programming against <code>tbl</code> objects.
<code>ungroup</code> is a convenient inline way of removing existing
grouping.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="groups_+3A_x">x</code></td>
<td>
<p>data <code><a href="dplyr.html#topic+tbl_df">tbl_df</a></code> or <code><a href="#topic+tbl_svy">tbl_svy</a></code> object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+groups">groups</a></code> for information.
</p>

<hr>
<h2 id='interact'>Create interaction terms to group by when summarizing</h2><span id='topic+interact'></span>

<h3>Description</h3>

<p>Allows multiple grouping by multiple variables as if they were a single
variable, which allows calculating proportions that sum to 100
more than a single grouping variable with <code>survey_mean</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interact(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interact_+3A_...">...</code></td>
<td>
<p>variables to group by. All types of tbls accept variable names, and
most will also accept functions of variables (though some database-backed
tbls do not allow creating variables).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Behind the scenes, this function creates a special column type that is
split back into the component columns automatically by <code>summarize</code>.
</p>


<h3>Value</h3>

<p>A vector of type <code><a href="#topic+srvyr_interaction">srvyr_interaction</a></code>, which is generally
expected to be automatically split apart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(api, package = "survey")

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

# The sum of the whole prop column is equal to 100%
dstrata %&gt;%
  group_by(interact(stype, awards)) %&gt;%
  summarize(prop = survey_mean())

# But if you didn't interact, the sum of each stype's prop is 100%
dstrata %&gt;%
  group_by(stype, awards) %&gt;%
  summarize(prop = survey_mean())
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+group_map'></span><span id='topic+group_modify'></span><span id='topic+group_walk'></span><span id='topic+reframe'></span><span id='topic+group_split'></span><span id='topic+group_nest'></span><span id='topic+nest_by'></span><span id='topic+n'></span><span id='topic+cur_data'></span><span id='topic+cur_group'></span><span id='topic+cur_group_id'></span><span id='topic+cur_column'></span><span id='topic+across'></span><span id='topic+c_across'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+across">across</a></code>, <code><a href="dplyr.html#topic+c_across">c_across</a></code>, <code><a href="dplyr.html#topic+context">cur_column</a></code>, <code><a href="dplyr.html#topic+deprec-context">cur_data</a></code>, <code><a href="dplyr.html#topic+context">cur_group</a></code>, <code><a href="dplyr.html#topic+context">cur_group_id</a></code>, <code><a href="dplyr.html#topic+group_map">group_map</a></code>, <code><a href="dplyr.html#topic+group_map">group_modify</a></code>, <code><a href="dplyr.html#topic+group_nest">group_nest</a></code>, <code><a href="dplyr.html#topic+group_split">group_split</a></code>, <code><a href="dplyr.html#topic+group_map">group_walk</a></code>, <code><a href="dplyr.html#topic+context">n</a></code>, <code><a href="dplyr.html#topic+nest_by">nest_by</a></code>, <code><a href="dplyr.html#topic+reframe">reframe</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rlang-tidyeval'>Tidy eval helpers from rlang</h2><span id='topic+rlang-tidyeval'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+enquo'></span><span id='topic+quo_name'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+expr'></span><span id='topic+exprs'></span><span id='topic+enexpr'></span>

<h3>Description</h3>

<p>These functions are used for tidy evaluation, introduced in rlang
and dplyr 0.7. See the programming vignette from dplyr or
&lt;http://rlang.tidyverse.org/articles/tidy-evaluation.html&gt;
for more details.
</p>

<hr>
<h2 id='set_survey_vars'>Set the variables for the current survey variable</h2><span id='topic+set_survey_vars'></span>

<h3>Description</h3>

<p>This is a helper to allow srvyr's syntactic style. In general, users
will not have to worry about setting variables in a survey object
unless they are trying to extend srvyr. This function helps convert a vector
to a variable in the correct part of a survey object's structure so that
functions can refer to it using the survey package's formula notation.
See <code>vignette("extending-srvyr")</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_survey_vars(.svy, x, name = "__SRVYR_TEMP_VAR__", add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_survey_vars_+3A_.svy">.svy</code></td>
<td>
<p>A survey object</p>
</td></tr>
<tr><td><code id="set_survey_vars_+3A_x">x</code></td>
<td>
<p>A vector to be included in the variables portion of the survey object</p>
</td></tr>
<tr><td><code id="set_survey_vars_+3A_name">name</code></td>
<td>
<p>The name of the variable once it is added. Defaults to '__SRVYR_TEMP_VAR__'
which is formatted weirdly to avoid name collisions.</p>
</td></tr>
<tr><td><code id="set_survey_vars_+3A_add">add</code></td>
<td>
<p>FALSE, the default, overwrite all current variables. If TRUE, will add
this variable instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tbl_svy with the variables modified
</p>

<hr>
<h2 id='srvyr'>srvyr: A package for 'dplyr'-Like Syntax for Summary Statistics of Survey Data.</h2><span id='topic+srvyr'></span>

<h3>Description</h3>

<p>The srvyr package provides a new way of calculating summary statistics
on survey data, based on the dplyr package. There are three stages to using
srvyr functions, creating a survey object, manipulating the data, and
calculating survey statistics.
</p>


<h3>Functions to create a survey object</h3>

<p><code><a href="#topic+as_survey_design">as_survey_design</a></code>, <code><a href="#topic+as_survey_rep">as_survey_rep</a></code>,
and <code><a href="#topic+as_survey_twophase">as_survey_twophase</a></code> are used to create surveys based on
a data.frame and design variables, replicate weights or two phase design
respectively. Each is based on a function in the survey package
(<code><a href="survey.html#topic+svydesign">svydesign</a></code>, <code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code>,
<code><a href="survey.html#topic+twophase">twophase</a></code>), and it is easy to modify code that uses
the survey package so that it works with the srvyr package. See
<code>vignette("srvyr_vs_survey")</code> for more details.
</p>
<p>The function <code><a href="#topic+as_survey">as_survey</a></code> will choose between the other three
functions based on the arguments given to save some typing.
</p>


<h3>Functions to manipulate data in a survey object</h3>

<p>Once you've created a survey object, you can manipulate the data as you would
using dplyr with a data.frame. <code><a href="#topic+mutate">mutate</a></code> modifies or creates a variable,
<code><a href="#topic+select">select</a></code> and <code><a href="#topic+rename">rename</a></code> select or rename variables, and
<code><a href="#topic+filter">filter</a></code> keeps certain observations.
</p>
<p>Note that <code>arrange</code> and two table verbs such as <code>bind_rows</code>,
<code>bind_cols</code>, or any of the joins are not usable on survey objects
because they might require modifications to the definition of your survey. If
you need to use these functions, you should do so before you convert the
data.frame to a survey object.
</p>


<h3>Functions to summarize a survey object</h3>

<p>Now that you have your data set up correctly, you can calculate summary
statistics. To get the statistic over the whole population, use
<code><a href="#topic+summarise">summarise</a></code>, or to calculate it over a set of groups, use
<code><a href="#topic+group_by">group_by</a></code> first.
</p>
<p>You can calculate the mean, (with <code><a href="#topic+survey_mean">survey_mean</a></code>), the total
(<code><a href="#topic+survey_total">survey_total</a></code>), the quantile (<code><a href="#topic+survey_quantile">survey_quantile</a></code>),
or a ratio (<code><a href="#topic+survey_ratio">survey_ratio</a></code>). By default, srvyr will return the
statistic and the standard error around it in a data.frame, but with the
<code>vartype</code> parameter, you can also get a confidence interval (&quot;ci&quot;),
variance (&quot;var&quot;), or coefficient of variation (&quot;cv&quot;).
</p>
<p>Within summarise, you can also use <code><a href="#topic+unweighted">unweighted</a></code>, which calculates
a function without taking into consideration the survey weighting.
</p>

<hr>
<h2 id='srvyr_interaction'>srvyr interaction column</h2><span id='topic+srvyr_interaction'></span>

<h3>Description</h3>

<p><code>srvyr_interaction</code> columns help calculate proportions of the interaction of 2
or more variables. They are created by <code><a href="#topic+interact">interact</a></code>, generally
used as grouping variables in <code><a href="#topic+group_by">group_by</a></code> and then automatically split
apart by <code><a href="#topic+summarise">summarise</a></code>.
</p>

<hr>
<h2 id='srvyr-se-deprecated'>Deprecated SE versions of main srvyr verbs</h2><span id='topic+srvyr-se-deprecated'></span><span id='topic+as_survey_'></span><span id='topic+as_survey_design_'></span><span id='topic+as_survey_rep_'></span><span id='topic+as_survey_twophase_'></span><span id='topic+cascade_'></span><span id='topic+mutate_'></span><span id='topic+transmute_'></span><span id='topic+select_'></span><span id='topic+rename_'></span><span id='topic+filter_'></span><span id='topic+mutate_each_'></span><span id='topic+summarise_each_'></span><span id='topic+summarize_each_'></span><span id='topic+funs_'></span><span id='topic+summarise_'></span><span id='topic+summarize_'></span>

<h3>Description</h3>

<p>srvyr has updated it's standard evaluation semantics to match dplyr 0.7, so
these underscore functions are no longer required (but are still supported
for backward compatibility reasons). See <code><a href="dplyr.html#topic+se-deprecated">se-deprecated</a></code> or the
dplyr vignette on programming (<code>vignette("programming", package =
"dplyr")</code>) for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_survey_(.data, ...)

as_survey_design_(
  .data,
  ids = NULL,
  probs = NULL,
  strata = NULL,
  variables = NULL,
  fpc = NULL,
  nest = FALSE,
  check_strata = !nest,
  weights = NULL,
  pps = FALSE,
  variance = c("HT", "YG")
)

as_survey_rep_(
  .data,
  variables = NULL,
  repweights = NULL,
  weights = NULL,
  type = c("BRR", "Fay", "JK1", "JKn", "bootstrap", "successive-difference", "ACS",
    "other"),
  combined_weights = TRUE,
  rho = NULL,
  bootstrap_average = NULL,
  scale = NULL,
  rscales = NULL,
  fpc = NULL,
  fpctype = c("fraction", "correction"),
  mse = getOption("survey.replicates.mse")
)

as_survey_twophase_(
  .data,
  id,
  strata = NULL,
  probs = NULL,
  weights = NULL,
  fpc = NULL,
  subset,
  method = c("full", "approx", "simple")
)

cascade_(.data, ..., .dots, .fill = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srvyr-se-deprecated_+3A_.data">.data</code></td>
<td>
<p>a data.frame or an object from the survey package</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_...">...</code></td>
<td>
<p>other arguments, see other functions for details</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_ids">ids</code></td>
<td>
<p>Variables specifying cluster ids from largest level to smallest level
(leaving the argument empty, NULL, 1, or 0 indicate no clusters).</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_probs">probs</code></td>
<td>
<p>Variables specifying cluster sampling probabilities.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_strata">strata</code></td>
<td>
<p>Variables specifying strata.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_variables">variables</code></td>
<td>
<p>Variables specifying variables to be included in survey.
Defaults to all variables in .data</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_fpc">fpc</code></td>
<td>
<p>Variables specifying a finite population correct, see
<code><a href="survey.html#topic+svydesign">svydesign</a></code> for more details.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_nest">nest</code></td>
<td>
<p>If <code>TRUE</code>, relabel cluster ids to enforce nesting within strata.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_check_strata">check_strata</code></td>
<td>
<p>If <code>TRUE</code>, check that clusters are nested in strata.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_weights">weights</code></td>
<td>
<p>Variables specifying weights (inverse of probability).</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_pps">pps</code></td>
<td>
<p>&quot;brewer&quot; to use Brewer's approximation for PPS sampling without replacement.
&quot;overton&quot; to use Overton's approximation. An object of class HR to use the Hartley-Rao
approximation. An object of class ppsmat to use the Horvitz-Thompson estimator.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_variance">variance</code></td>
<td>
<p>For pps without replacement, use variance=&quot;YG&quot; for the Yates-Grundy estimator
instead of the Horvitz-Thompson estimator</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_repweights">repweights</code></td>
<td>
<p>Variables specifying the replication weight variables</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_type">type</code></td>
<td>
<p>Type of replication weights</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_combined_weights">combined_weights</code></td>
<td>
<p><code>TRUE</code> if the <code>repweights</code> already
include the sampling weights. This is usually the case.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_rho">rho</code></td>
<td>
<p>Shrinkage factor for weights in Fay's method</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_bootstrap_average">bootstrap_average</code></td>
<td>
<p>For <code>type = "bootstrap"</code>, if the bootstrap
weights have been averaged, gives the number of iterations averaged over.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_scale">scale</code>, <code id="srvyr-se-deprecated_+3A_rscales">rscales</code></td>
<td>
<p>Scaling constant for variance, see
<code><a href="survey.html#topic+svrepdesign">svrepdesign</a></code> for more information.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_fpctype">fpctype</code></td>
<td>
<p>Finite population correction information</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_mse">mse</code></td>
<td>
<p>if <code>TRUE</code>, compute variances based on sum of squares
around the point estimate, rather than the mean of the replicates</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_id">id</code></td>
<td>
<p>list of two sets of variable names for sampling unit identifiers</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_subset">subset</code></td>
<td>
<p>bare name of a variable which specifies which observations are selected in phase 2</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_method">method</code></td>
<td>
<p>&quot;full&quot; requires (much) more memory, but gives unbiased variance estimates for
general multistage designs at both phases. &quot;simple&quot; or &quot;approx&quot; use less memory, and is correct for
designs with simple random sampling at phase one and stratified randoms sampling at phase two. See
<code><a href="survey.html#topic+twophase">twophase</a></code> for more details.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_.dots">.dots</code></td>
<td>
<p>Used to work around non-standard evaluation. See
<code>vignette("nse", package = "dplyr")</code> for details.</p>
</td></tr>
<tr><td><code id="srvyr-se-deprecated_+3A_.fill">.fill</code></td>
<td>
<p>Value to fill in for group summaries</p>
</td></tr>
</table>

<hr>
<h2 id='summarise'>Summarise multiple values to a single value.</h2><span id='topic+summarise'></span><span id='topic+summarize'></span>

<h3>Description</h3>

<p>Summarise multiple values to a single value.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_+3A_.data">.data</code></td>
<td>
<p>tbl A <code>tbl_svy</code> object</p>
</td></tr>
<tr><td><code id="summarise_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summarizing expressions, see details</p>
</td></tr>
<tr><td><code id="summarise_+3A_.groups">.groups</code></td>
<td>
<p>Defaults to &quot;drop_last&quot; in srvyr meaning that the last group is peeled
off, but if there are more groups they will be preserved. Other options are &quot;drop&quot;, which
drops all groups, &quot;keep&quot; which keeps all of them and &quot;rowwise&quot; which converts the object
to a rowwise object (meaning calculations will be performed on each row).</p>
</td></tr>
<tr><td><code id="summarise_+3A_.unpack">.unpack</code></td>
<td>
<p>Whether to &quot;unpack&quot; named <code>data.frame</code> columns. <code>srvyr</code> predates
<code>dplyr</code>'s support for data.frame columns so it does not treat them the same way by
default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarise for <code>tbl_svy</code> objects accepts several specialized functions.
Each of the functions a variable (or two, in the case of
<code>survey_ratio</code>), from the data.frame and default to providing the measure
and its standard error.
</p>
<p>The argument <code>vartype</code> can choose one or more measures of uncertainty,
<code>se</code> for standard error, <code>ci</code> for confidence interval, <code>var</code>
for variance, and <code>cv</code> for coefficient of variation. <code>level</code>
specifies the level for the confidence interval.
</p>
<p>The other arguments correspond to the analogous function arguments from the
survey package.
</p>
<p>The available functions from srvyr are:
</p>

<dl>
<dt><code><a href="#topic+survey_mean">survey_mean</a></code></dt><dd>
<p>Calculate the mean of a numeric variable or the proportion falling into <code>groups</code>
for the entire population or by <code>groups</code>. Based on <code><a href="survey.html#topic+svymean">svymean</a></code>
and <code><a href="survey.html#topic+svyciprop">svyciprop</a></code>.</p>
</dd></dl>
<p>.
</p>
<dl>
<dt><code><a href="#topic+survey_total">survey_total</a></code></dt><dd>
<p>Calculate the survey total of the entire population or by <code>groups</code>.
Based on <code><a href="survey.html#topic+svytotal">svytotal</a></code>.</p>
</dd>
<dt><code><a href="#topic+survey_prop">survey_prop</a></code></dt><dd>
<p>Calculate the proportion of the entire population or by <code>groups</code>.
Based on <code><a href="survey.html#topic+svyciprop">svyciprop</a></code>.</p>
</dd>
<dt><code><a href="#topic+survey_ratio">survey_ratio</a></code></dt><dd>
<p>Calculate the ratio of 2 variables in the entire population or by <code>groups</code>.
Based on <code><a href="survey.html#topic+svyratio">svyratio</a></code>.</p>
</dd>
<dt><code><a href="#topic+survey_quantile">survey_quantile</a></code> &amp; <code><a href="#topic+survey_median">survey_median</a></code></dt><dd>
<p>Calculate quantiles in the entire population or by <code>groups</code>. Based on
<code><a href="survey.html#topic+svyquantile">svyquantile</a></code>.</p>
</dd>
<dt><code><a href="#topic+unweighted">unweighted</a></code></dt><dd>
<p>Calculate an unweighted estimate as you would on a regular <code>tbl_df</code>.
Based on dplyr's <code><a href="dplyr.html#topic+summarise">summarise</a></code>.</p>
</dd>
</dl>

<p>You can use expressions both in the <code>...</code> of <code>summarize</code> and also
in the arguments to the summarizing functions. Though this is valid syntactically
it can also allow you to calculate incorrect results (for example if you multiply
the mean by 100, the standard error is also multiplied by 100, but the variance
is not).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(api, package = "survey")

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(api99_mn = survey_mean(api99),
            api00_mn = survey_mean(api00),
            api_diff = survey_mean(api00 - api99))

dstrata_grp &lt;- dstrata %&gt;%
  group_by(stype)

dstrata_grp %&gt;%
  summarise(api99_mn = survey_mean(api99),
            api00_mn = survey_mean(api00),
            api_diff = survey_mean(api00 - api99))

# `dplyr::across` can be used to programmatically summarize multiple columns
# See https://dplyr.tidyverse.org/articles/colwise.html for details
# A basic example of working on 2 columns at once and then calculating the total
# the mean
total_vars &lt;- c("enroll", "api.stu")
dstrata %&gt;%
  summarize(across(c(all_of(total_vars)), survey_total))

# Expressions are allowed in summarize arguments &amp; inside functions
# Here we can calculate binary variable on the fly and also multiply by 100 to
# get percentages
dstrata %&gt;%
  summarize(api99_over_700_pct = 100 * survey_mean(api99 &gt; 700))

# But be careful, the variance doesn't scale the same way, so this is wrong!
dstrata %&gt;%
  summarize(api99_over_700_pct = 100 * survey_mean(api99 &gt; 700, vartype = "var"))
# Wrong variance!

</code></pre>

<hr>
<h2 id='summarise_all'>Manipulate multiple columns.</h2><span id='topic+summarise_all'></span><span id='topic+summarize_all'></span><span id='topic+summarise_if'></span><span id='topic+summarize_if'></span><span id='topic+summarise_at'></span><span id='topic+summarize_at'></span><span id='topic+mutate_all'></span><span id='topic+mutate_if'></span><span id='topic+mutate_at'></span><span id='topic+filter_all'></span><span id='topic+filter_at'></span><span id='topic+filter_if'></span><span id='topic+select_all'></span><span id='topic+select_at'></span><span id='topic+select_if'></span><span id='topic+rename_all'></span><span id='topic+rename_at'></span><span id='topic+rename_if'></span><span id='topic+group_by_all'></span><span id='topic+group_by_at'></span><span id='topic+group_by_if'></span><span id='topic+mutate_each'></span><span id='topic+summarise_each'></span><span id='topic+summarize_each'></span><span id='topic+funs'></span><span id='topic+vars'></span><span id='topic+all_vars'></span><span id='topic+any_vars'></span>

<h3>Description</h3>

<p>See <code><a href="dplyr.html#topic+summarize_all">summarize_all</a></code> for more details. *_each functions will be deprecated
in favor of *_all/*_if/*_at functions.
</p>

<hr>
<h2 id='survey_corr'>Calculate correlation and its variation using survey methods</h2><span id='topic+survey_corr'></span>

<h3>Description</h3>

<p>Calculate correlation from complex survey data. A wrapper
around <code><a href="survey.html#topic+svyvar">svyvar</a></code>. <code>survey_corr</code> should always be
called from <code><a href="#topic+summarise">summarise</a></code>. Note this is Pearson's correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_corr(
  x,
  y,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_corr_+3A_x">x</code></td>
<td>
<p>A variable or expression</p>
</td></tr>
<tr><td><code id="survey_corr_+3A_y">y</code></td>
<td>
<p>A variable or expression</p>
</td></tr>
<tr><td><code id="survey_corr_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_corr_+3A_vartype">vartype</code></td>
<td>
<p>NULL to report no variability. Otherwise one or more of: standard error (&quot;se&quot;, the default), confidence interval (&quot;ci&quot;), variance (&quot;var&quot;) or coefficient of variation (&quot;cv&quot;).</p>
</td></tr>
<tr><td><code id="survey_corr_+3A_level">level</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A single number or vector of numbers indicating the confidence level</p>
</td></tr>
<tr><td><code id="survey_corr_+3A_df">df</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A numeric value indicating the degrees of freedom for t-distribution. The default (NULL) uses degf, but Inf is the usual survey package's default</p>
</td></tr>
<tr><td><code id="survey_corr_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data('api', package = 'survey')

apisrs %&gt;%
  as_survey_design(.ids = 1) %&gt;%
  summarize(api_corr = survey_corr(x = api00, y = api99))

apisrs %&gt;%
  as_survey_design(.ids = 1) %&gt;%
  group_by(sch.wide) %&gt;%
  summarize(
    api_emer_corr = survey_corr(x = api00, y = emer, na.rm=TRUE, vartype="ci")
  )
</code></pre>

<hr>
<h2 id='survey_mean'>Calculate mean/proportion and its variation using survey methods</h2><span id='topic+survey_mean'></span><span id='topic+survey_prop'></span>

<h3>Description</h3>

<p>Calculate means and proportions from complex survey data.
<code>survey_mean</code> with <code>proportion = FALSE</code> (the default) or <code>survey_prop</code> with <code>proportion = FALSE</code>
is a wrapper around <code><a href="survey.html#topic+svymean">svymean</a></code>.
<code>survey_prop</code> with <code>proportion = TRUE</code> (the default) or <code>survey_mean</code> with <code>proportion = TRUE</code>
is a wrapper around <code><a href="survey.html#topic+svyciprop">svyciprop</a></code>.
<code>survey_mean</code> and <code>survey_prop</code> should always be called from <code><a href="#topic+summarise">summarise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_mean(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = FALSE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean", "xlogit"),
  deff = FALSE,
  df = NULL,
  ...
)

survey_prop(
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  proportion = TRUE,
  prop_method = c("logit", "likelihood", "asin", "beta", "mean", "xlogit"),
  deff = FALSE,
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_mean_+3A_x">x</code></td>
<td>
<p>A variable or expression, or empty</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_vartype">vartype</code></td>
<td>
<p>Report variability as one or more of: standard error (&quot;se&quot;, default),
confidence interval (&quot;ci&quot;), variance (&quot;var&quot;) or coefficient of variation
(&quot;cv&quot;).</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_level">level</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A single number or vector of numbers indicating
the confidence level</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_proportion">proportion</code></td>
<td>
<p>Use methods to calculate the proportion that may have more accurate
confidence intervals near 0 and 1. Based on
<code><a href="survey.html#topic+svyciprop">svyciprop</a></code>.</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_prop_method">prop_method</code></td>
<td>
<p>Type of proportion method to use if proportion is <code>TRUE</code>. See
<code><a href="survey.html#topic+svyciprop">svyciprop</a></code> for details.</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_deff">deff</code></td>
<td>
<p>A logical value to indicate whether the design effect should be returned.</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_df">df</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A numeric value indicating the degrees of freedom
for t-distribution. The default (NULL) uses <code><a href="survey.html#topic+degf">degf</a></code>,
but Inf is the usual survey package's default (except in
<code><a href="survey.html#topic+svyciprop">svyciprop</a></code>.</p>
</td></tr>
<tr><td><code id="survey_mean_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>survey_prop</code> is equivalent to leaving out the <code>x</code> argument in
<code>survey_mean</code> and setting <code>proportion = TRUE</code> and this calculates the proportion represented within the
data, with the last grouping variable &quot;unpeeled&quot;. <code><a href="#topic+interact">interact</a></code>
allows for &quot;unpeeling&quot; multiple variables at once.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(api, package = "survey")

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(api99_mn = survey_mean(api99),
            api_diff = survey_mean(api00 - api99, vartype = c("ci", "cv")))

dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(api00 = survey_mean(api00))

# Use `survey_prop` calculate the proportion in each group
dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(pct = survey_prop())

# Or you can also leave  out `x` in `survey_mean`, so this is equivalent
dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(pct = survey_mean())

# When there's more than one group, the last group is "peeled" off and proportions are
# calculated within that group, each adding up to 100%.
# So in this example, the sum of prop is 200% (100% for awards=="Yes" &amp;
# 100% for awards=="No")
dstrata %&gt;%
  group_by(stype, awards) %&gt;%
  summarize(prop = survey_prop())

# The `interact` function can help you calculate the proportion over
# the interaction of two or more variables
# So in this example, the sum of prop is 100%
dstrata %&gt;%
  group_by(interact(stype, awards)) %&gt;%
  summarize(prop = survey_prop())

# Setting proportion = TRUE uses a different method for calculating confidence intervals
dstrata %&gt;%
  summarise(high_api = survey_mean(api00 &gt; 875, proportion = TRUE, vartype = "ci"))

# level takes a vector for multiple levels of confidence intervals
dstrata %&gt;%
  summarise(api99 = survey_mean(api99, vartype = "ci", level = c(0.95, 0.65)))

# Note that the default degrees of freedom in srvyr is different from
# survey, so your confidence intervals might not be exact matches. To
# Replicate survey's behavior, use df = Inf
dstrata %&gt;%
  summarise(srvyr_default = survey_mean(api99, vartype = "ci"),
            survey_defualt = survey_mean(api99, vartype = "ci", df = Inf))

comparison &lt;- survey::svymean(~api99, dstrata)
confint(comparison) # survey's default
confint(comparison, df = survey::degf(dstrata)) # srvyr's default

</code></pre>

<hr>
<h2 id='survey_old_quantile'>Calculate the quantile and its variation using survey methods</h2><span id='topic+survey_old_quantile'></span><span id='topic+survey_old_median'></span>

<h3>Description</h3>

<p>Calculate quantiles from complex survey data. A wrapper
around <code><a href="survey.html#topic+oldsvyquantile">oldsvyquantile</a></code>, which is a version of the function
from before version 4.1 of the survey package, available for backwards compatibility.
<code>survey_old_quantile</code> and <code>survey_old_median</code> should always be
called from <code><a href="#topic+summarise">summarise</a></code>. See Thomas Lumley's blogpost
&lt;https://notstatschat.rbind.io/2021/07/20/what-s-new-in-the-survey-package/&gt;
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_old_quantile(
  x,
  quantiles,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  q_method = "linear",
  f = 1,
  interval_type = c("Wald", "score", "betaWald", "probability", "quantile"),
  ties = c("discrete", "rounded"),
  df = NULL,
  ...
)

survey_old_median(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci"),
  level = 0.95,
  q_method = "linear",
  f = 1,
  interval_type = c("Wald", "score", "betaWald", "probability", "quantile"),
  ties = c("discrete", "rounded"),
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_old_quantile_+3A_x">x</code></td>
<td>
<p>A variable or expression</p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of quantiles to calculate</p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_vartype">vartype</code></td>
<td>
<p>NULL to report no variability (default), otherwise one or more of:
standard error (&quot;se&quot;) confidence interval (&quot;ci&quot;) (variance and coefficient
of variation not available).</p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_level">level</code></td>
<td>
<p>A single number indicating the confidence level (only one level allowed)</p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_q_method">q_method</code></td>
<td>
<p>See &quot;method&quot; in <code><a href="stats.html#topic+approxfun">approxfun</a></code></p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_f">f</code></td>
<td>
<p>See <code><a href="stats.html#topic+approxfun">approxfun</a></code></p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_interval_type">interval_type</code></td>
<td>
<p>See <code><a href="survey.html#topic+oldsvyquantile">oldsvyquantile</a></code></p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_ties">ties</code></td>
<td>
<p>See <code><a href="survey.html#topic+oldsvyquantile">oldsvyquantile</a></code></p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_df">df</code></td>
<td>
<p>A number indicating the degrees of freedom for t-distribution. The
default, Inf uses the normal distribution (matches the survey package).
Also, has no effect for <code>type = "betaWald"</code>.</p>
</td></tr>
<tr><td><code id="survey_old_quantile_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(api99 = survey_old_quantile(api99, c(0.25, 0.5, 0.75)),
            api00 = survey_old_median(api00, vartype = c("ci")))

dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(api00 = survey_old_median(api00))

</code></pre>

<hr>
<h2 id='survey_quantile'>Calculate the quantile and its variation using survey methods</h2><span id='topic+survey_quantile'></span><span id='topic+survey_median'></span>

<h3>Description</h3>

<p>Calculate quantiles from complex survey data. A wrapper
around <code><a href="survey.html#topic+svyquantile">svyquantile</a></code>. <code>survey_quantile</code> and
<code>survey_median</code> should always be called from <code><a href="#topic+summarise">summarise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_quantile(
  x,
  quantiles,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  interval_type = c("mean", "beta", "xlogit", "asin", "score", "quantile"),
  qrule = c("math", "school", "shahvaish", "hf1", "hf2", "hf3", "hf4", "hf5", "hf6",
    "hf7", "hf8", "hf9"),
  df = NULL,
  ...
)

survey_median(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  interval_type = c("mean", "beta", "xlogit", "asin", "score", "quantile"),
  qrule = c("math", "school", "shahvaish", "hf1", "hf2", "hf3", "hf4", "hf5", "hf6",
    "hf7", "hf8", "hf9"),
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_quantile_+3A_x">x</code></td>
<td>
<p>A variable or expression</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of quantiles to calculate</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_vartype">vartype</code></td>
<td>
<p>NULL to report no variability. Otherwise one or more of: standard error (&quot;se&quot;, the default),
confidence interval (&quot;ci&quot;), variance (&quot;var&quot;) or coefficient of variation
(&quot;cv&quot;).</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_level">level</code></td>
<td>
<p>A single number indicating the confidence level (only one level allowed). Note that this may effect estimated standard errors (see <code><a href="survey.html#topic+svyquantile">svyquantile</a></code> details on <code>alpha</code>, which equals <code>1-level</code>).</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_interval_type">interval_type</code></td>
<td>
<p>See <code><a href="survey.html#topic+svyquantile">svyquantile</a></code>. Note that <code>interval_type = "quantile"</code> is only available for replicate designs, and <code>interval_type = "score"</code> is unavailable for replicate designs.</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_qrule">qrule</code></td>
<td>
<p>See <code><a href="survey.html#topic+svyquantile">svyquantile</a></code></p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_df">df</code></td>
<td>
<p>A number indicating the degrees of freedom for t-distribution. The
default, NULL, uses the design degrees of freedom (matches the survey package).</p>
</td></tr>
<tr><td><code id="survey_quantile_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the behavior of these functions has changed in srvyr version 1.1,
but the old functions are still (currently) supported as
<code><a href="#topic+survey_old_quantile">survey_old_quantile</a></code> and <code>survey_old_median</code> if you need
to replicate the old results. For more details about what has changed, see
Thomas Lumley's blog post on the changes, available here:
&lt;https://notstatschat.rbind.io/2021/07/20/what-s-new-in-the-survey-package/&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(api99 = survey_quantile(api99, c(0.25, 0.5, 0.75)),
            api00 = survey_median(api00, vartype = c("ci")))

dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(api00 = survey_median(api00))

</code></pre>

<hr>
<h2 id='survey_ratio'>Calculate the ratio and its variation using survey methods</h2><span id='topic+survey_ratio'></span>

<h3>Description</h3>

<p>Calculate ratios from complex survey data. A wrapper
around <code><a href="survey.html#topic+svyratio">svyratio</a></code>. <code>survey_ratio</code>
should always be called from <code><a href="#topic+summarise">summarise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_ratio(
  numerator,
  denominator,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_ratio_+3A_numerator">numerator</code></td>
<td>
<p>The numerator of the ratio</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_denominator">denominator</code></td>
<td>
<p>The denominator of the ratio</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_vartype">vartype</code></td>
<td>
<p>Report variability as one or more of: standard error (&quot;se&quot;, default),
confidence interval (&quot;ci&quot;), variance (&quot;var&quot;) or coefficient of variation
(&quot;cv&quot;).</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_level">level</code></td>
<td>
<p>A single number or vector of numbers indicating the confidence level</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_deff">deff</code></td>
<td>
<p>A logical value to indicate whether the design effect should be returned.</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_df">df</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A numeric value indicating the degrees of freedom
for t-distribution. The default (NULL) uses <code><a href="survey.html#topic+degf">degf</a></code>,
but Inf is the usual survey package's default (except in
<code><a href="survey.html#topic+svyciprop">svyciprop</a></code>.</p>
</td></tr>
<tr><td><code id="survey_ratio_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(enroll = survey_ratio(api00, api99, vartype = c("ci", "cv")))

dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(api00 = survey_ratio(api00, api99))

# level takes a vector for multiple levels of confidence intervals
dstrata %&gt;%
  summarise(enroll = survey_ratio(api99, api00, vartype = "ci", level = c(0.95, 0.65)))

# Note that the default degrees of freedom in srvyr is different from
# survey, so your confidence intervals might not exactly match. To
# replicate survey's behavior, use df = Inf
dstrata %&gt;%
  summarise(srvyr_default = survey_total(api99, vartype = "ci"),
            survey_defualt = survey_total(api99, vartype = "ci", df = Inf))

comparison &lt;- survey::svytotal(~api99, dstrata)
confint(comparison) # survey's default
confint(comparison, df = survey::degf(dstrata)) # srvyr's default

</code></pre>

<hr>
<h2 id='survey_tally'>Count/tally survey weighted observations by group</h2><span id='topic+survey_tally'></span><span id='topic+survey_count'></span>

<h3>Description</h3>

<p>Analogous to <code><a href="dplyr.html#topic+tally">tally</a></code> and count, calculates the survey weighted
count of observations. <code>survey_tally</code> will call <code><a href="#topic+survey_total">survey_total</a></code> empty (resulting
in the count of each group) or on <code>wt</code> if it is specified (resulting in the
survey weighted total of <code>wt</code>). <code>survey_count</code> is similar, but calls <code>group_by</code>
before calculating the count and then returns the data to the original groupings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_tally(
  x,
  wt,
  sort = FALSE,
  name = "n",
  vartype = c("se", "ci", "var", "cv")
)

survey_count(
  x,
  ...,
  wt = NULL,
  sort = FALSE,
  name = "n",
  .drop = dplyr::group_by_drop_default(x),
  vartype = c("se", "ci", "var", "cv")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_tally_+3A_x">x</code></td>
<td>
<p>A tbl_svy object, as created by <code>as_survey</code> and related functions.</p>
</td></tr>
<tr><td><code id="survey_tally_+3A_wt">wt</code></td>
<td>
<p>(Optional) A variable to weight on (in addition to the survey weights,
which are always used). If left unspecified, <code>tally()</code> will use a variable
named &quot;n&quot; if one exists, but <code>count()</code> will not. Override this behavior by
specifying <code>wt = NULL</code>.</p>
</td></tr>
<tr><td><code id="survey_tally_+3A_sort">sort</code></td>
<td>
<p>Whether to sort the results (defaults to <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="survey_tally_+3A_name">name</code></td>
<td>
<p>Name of count variable created (defaults to n). If the variable already
exists, will add &quot;n&quot; to the end until it does not.</p>
</td></tr>
<tr><td><code id="survey_tally_+3A_vartype">vartype</code></td>
<td>
<p>What types variation estimates to calculate, passed to
<code><a href="#topic+survey_total">survey_total</a></code>.</p>
</td></tr>
<tr><td><code id="survey_tally_+3A_...">...</code></td>
<td>
<p>Variables to group by, passed to <code>group_by()</code>.</p>
</td></tr>
<tr><td><code id="survey_tally_+3A_.drop">.drop</code></td>
<td>
<p>When .drop = TRUE, empty groups are dropped, see <code><a href="dplyr.html#topic+group_by">group_by</a></code>
documentation for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>n</code> already exists, <code>tally</code> will use it as the weight, but <code>count</code>
will not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  group_by(awards) %&gt;%
  survey_tally()

dstrata %&gt;%
  survey_count(awards)

</code></pre>

<hr>
<h2 id='survey_total'>Calculate the total and its variation using survey methods</h2><span id='topic+survey_total'></span>

<h3>Description</h3>

<p>Calculate totals from complex survey data. A wrapper
around <code><a href="survey.html#topic+svytotal">svytotal</a></code>. <code>survey_total</code> should always be
called from <code><a href="#topic+summarise">summarise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_total(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var", "cv"),
  level = 0.95,
  deff = FALSE,
  df = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_total_+3A_x">x</code></td>
<td>
<p>A variable or expression, or empty</p>
</td></tr>
<tr><td><code id="survey_total_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_total_+3A_vartype">vartype</code></td>
<td>
<p>Report variability as one or more of: standard error (&quot;se&quot;, default),
confidence interval (&quot;ci&quot;), variance (&quot;var&quot;) or coefficient of variation
(&quot;cv&quot;).</p>
</td></tr>
<tr><td><code id="survey_total_+3A_level">level</code></td>
<td>
<p>A single number or vector of numbers indicating the confidence level</p>
</td></tr>
<tr><td><code id="survey_total_+3A_deff">deff</code></td>
<td>
<p>A logical value to indicate whether the design effect should be returned.</p>
</td></tr>
<tr><td><code id="survey_total_+3A_df">df</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A numeric value indicating the degrees of freedom
for t-distribution. The default (NULL) uses <code><a href="survey.html#topic+degf">degf</a></code>,
but Inf is the usual survey package's default.</p>
</td></tr>
<tr><td><code id="survey_total_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(enroll_tot = survey_total(enroll),
            tot_meals = survey_total(enroll * meals / 100, vartype = c("ci", "cv")))

dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(api00 = survey_total(enroll))

# Leave x empty to calculate the total in each group
dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(pct = survey_total())

# level takes a vector for multiple levels of confidence intervals
dstrata %&gt;%
  summarise(enroll = survey_total(enroll, vartype = "ci", level = c(0.95, 0.65)))

# Note that the default degrees of freedom in srvyr is different from
# survey, so your confidence intervals might not exactly match. To
# replicate survey's behavior, use df = Inf
dstrata %&gt;%
  summarise(srvyr_default = survey_total(api99, vartype = "ci"),
            survey_defualt = survey_total(api99, vartype = "ci", df = Inf))

comparison &lt;- survey::svytotal(~api99, dstrata)
confint(comparison) # survey's default
confint(comparison, df = survey::degf(dstrata)) # srvyr's default

</code></pre>

<hr>
<h2 id='survey_var'>Calculate the population variance and its variation using survey methods</h2><span id='topic+survey_var'></span><span id='topic+survey_sd'></span>

<h3>Description</h3>

<p>Calculate population variance from complex survey data. A wrapper
around <code><a href="survey.html#topic+svyvar">svyvar</a></code>. <code>survey_var</code> should always be
called from <code><a href="#topic+summarise">summarise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_var(
  x,
  na.rm = FALSE,
  vartype = c("se", "ci", "var"),
  level = 0.95,
  df = NULL,
  ...
)

survey_sd(x, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survey_var_+3A_x">x</code></td>
<td>
<p>A variable or expression, or empty</p>
</td></tr>
<tr><td><code id="survey_var_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value to indicate whether missing values should be dropped</p>
</td></tr>
<tr><td><code id="survey_var_+3A_vartype">vartype</code></td>
<td>
<p>Report variability as one or more of: standard error (&quot;se&quot;, default)
or variance (&quot;var&quot;) (confidence intervals and coefficient
of variation not available).</p>
</td></tr>
<tr><td><code id="survey_var_+3A_level">level</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A single number or vector of numbers indicating
the confidence level.</p>
</td></tr>
<tr><td><code id="survey_var_+3A_df">df</code></td>
<td>
<p>(For vartype = &quot;ci&quot; only) A numeric value indicating the degrees of freedom
for t-distribution. The default (Inf) is equivalent to using normal
distribution and in case of population variance statistics there is little
reason to use any other values (see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="survey_var_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be aware that confidence intervals for population variance statistic are
computed by package <em>survey</em> using <em>t</em> or normal (with df=Inf)
distribution (i.e. symmetric distributions). <strong>This could be a very poor
approximation</strong> if even one of these conditions is met:
</p>

<ul>
<li><p>there are few sampling design degrees of freedom,
</p>
</li>
<li><p>analyzed variable isn't normally distributed,
</p>
</li>
<li><p>there is huge variation in sampling probabilities of the survey design.
</p>
</li></ul>

<p>Because of this be very careful using confidence intervals for population variance
statistics especially while performing analysis within subsets of data or using
grouped survey objects.
</p>
<p>Sampling distribution of the variance statistic in general is asymmetric
(chi-squared in case of simple random sampling of normally distributed variable)
and if analyzed variable isn't normally distributed or there is huge variation in
sampling probabilities of the survey design (or both) it could converge to
normality only very slowly (with growing number of survey design degrees of
freedom).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(api99_var = survey_var(api99),
            api99_sd = survey_sd(api99))

dstrata %&gt;%
  group_by(awards) %&gt;%
  summarise(api00_var = survey_var(api00),
            api00_sd = survey_sd(api00))

# standard deviation and variance of the population variance estimator
# are available with vartype argument
# (but not for the population standard deviation estimator)
dstrata %&gt;%
  summarise(api99_variance = survey_var(api99, vartype = c("se", "var")))
</code></pre>

<hr>
<h2 id='svychisq'>Chisquared tests of association for survey data.</h2><span id='topic+svychisq'></span>

<h3>Description</h3>

<p>Chisquared tests of association for survey data.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="svychisq_+3A_formula">formula</code></td>
<td>
<p>See details in <code><a href="survey.html#topic+svychisq">svychisq</a></code></p>
</td></tr>
<tr><td><code id="svychisq_+3A_design">design</code></td>
<td>
<p>See details in <code><a href="survey.html#topic+svychisq">svychisq</a></code></p>
</td></tr>
<tr><td><code id="svychisq_+3A_na.rm">na.rm</code></td>
<td>
<p>See details in <code><a href="survey.html#topic+svychisq">svychisq</a></code></p>
</td></tr>
<tr><td><code id="svychisq_+3A_...">...</code></td>
<td>
<p>See details in <code><a href="survey.html#topic+svychisq">svychisq</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='tbl_svy'>tbl_svy object.</h2><span id='topic+tbl_svy'></span>

<h3>Description</h3>

<p>A <code>tbl_svy</code> wraps a locally stored svydesign and adds methods for
dplyr single-table verbs like <code>mutate</code>, <code>group_by</code> and
<code>summarise</code>. Create a <code>tbl_svy</code> using <code><a href="#topic+as_survey_design">as_survey_design</a></code>.
</p>


<h3>Methods</h3>

<p><code>tbl_df</code> implements these methods from dplyr.
</p>

<dl>
<dt><code><a href="dplyr.html#topic+select">select</a></code> or <code><a href="dplyr.html#topic+rename">rename</a></code></dt><dd>
<p>Select or rename variables in a survey's dataset.</p>
</dd>
<dt><code><a href="dplyr.html#topic+mutate">mutate</a></code> or <code><a href="dplyr.html#topic+transmute">transmute</a></code></dt><dd>
<p>Modify and create variables in a survey's dataset.</p>
</dd>
<dt><code><a href="#topic+group_by">group_by</a></code> and <code><a href="#topic+summarise">summarise</a></code></dt><dd>
<p>Get descriptive statistics from survey.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
library(dplyr)
data(api)
svy &lt;- as_survey_design(apistrat, strata = stype, weights = pw)
svy

# Data manipulation verbs ---------------------------------------------------
filter(svy, pcttest &gt; 95)
select(svy, starts_with("acs")) # variables used in survey design are automatically kept
summarise(svy, col.grad = survey_mean(col.grad))
mutate(svy, api_diff = api00 - api99)

# Group by operations -------------------------------------------------------
# To calculate survey
svy_group &lt;- group_by(svy, dname)

summarise(svy, col.grad = survey_mean(col.grad),
          api00 = survey_mean(api00, vartype = "ci"))
</code></pre>

<hr>
<h2 id='tbl_vars'>List variables produced by a tbl.</h2><span id='topic+tbl_vars'></span>

<h3>Description</h3>

<p>List variables produced by a tbl.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_vars_+3A_x">x</code></td>
<td>
<p>A <code>tbl</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='uninteract'>Break interaction vectors back into component columns</h2><span id='topic+uninteract'></span><span id='topic+uninteract.srvyr_interaction'></span><span id='topic+uninteract.data.frame'></span><span id='topic+is.interaction'></span>

<h3>Description</h3>

<p>This function will not generally be needed by users because <code>summarise</code>
automatically un-interacts interaction columns for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uninteract(x)

## S3 method for class 'srvyr_interaction'
uninteract(x)

## S3 method for class 'data.frame'
uninteract(x)

is.interaction(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uninteract_+3A_x">x</code></td>
<td>
<p>Either a <code>srvyr_interaction</code> column or a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>
</p>

<hr>
<h2 id='unweighted'>Calculate the an unweighted summary statistic from a survey</h2><span id='topic+unweighted'></span>

<h3>Description</h3>

<p>Calculate unweighted summaries from a survey dataset, just as on
a normal data.frame with <code><a href="dplyr.html#topic+summarise">summarise</a></code>. Though it is
possible to use regular functions directly, because the survey package
doesn't always remove rows when filtering (instead setting the weight to 0),
this can sometimes give bad results. See examples for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unweighted(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unweighted_+3A_...">...</code></td>
<td>
<p>variables or expressions, calculated on the unweighted data.frame
behind the <code>tbl_svy</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses tidy evaluation semantics and so if you want to use
wrapper functions based on variable names, you must use
tidy evaluation, see the examples here, documentation in
<a href="rlang.html#topic+nse-force">nse-force</a>, or the dplyr vignette called
'programming' for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survey)
library(dplyr)
data(api)

dstrata &lt;- apistrat %&gt;%
  as_survey_design(strata = stype, weights = pw)

dstrata %&gt;%
  summarise(api99_unw = unweighted(mean(api99)),
            n = unweighted(n()))

dstrata %&gt;%
  group_by(stype) %&gt;%
  summarise(api_diff_unw = unweighted(mean(api00 - api99)))


# Some survey designs, like ones with raked weights, are not removed
# when filtered to preserve the structure. So if you don't use `unweighted()`
# your results can be wrong.
# Declare basic clustered design ----
cluster_design &lt;- as_survey_design(
  .data = apiclus1,
  id = dnum,
  weights = pw,
  fpc = fpc
)

# Add raking weights for school type ----
pop.types &lt;- data.frame(stype=c("E","H","M"), Freq=c(4421,755,1018))
pop.schwide &lt;- data.frame(sch.wide=c("No","Yes"), Freq=c(1072,5122))

raked_design &lt;- rake(
  cluster_design,
  sample.margins = list(~stype,~sch.wide),
  population.margins = list(pop.types, pop.schwide)
)

raked_design %&gt;%
filter(cname != "Alameda") %&gt;%
  group_by(cname) %&gt;%
  summarize(
    direct_unw_mean = mean(api99),
    wrapped_unw_mean = unweighted(mean(api99))
  ) %&gt;%
  filter(cname == "Alameda")

# Notice how the results are different when using `unweighted()`

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
