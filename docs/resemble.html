<!DOCTYPE html><html><head><title>Help for package resemble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {resemble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#resemble-package'><p>Overview of the functions in the resemble package</p></a></li>
<li><a href='#+5B.local_ortho_diss'><p>Print method for an object of class <code>local_ortho_diss</code></p></a></li>
<li><a href='#check_pc_arguments'><p>checks the pc_selection argument</p></a></li>
<li><a href='#cor_diss'><p>Correlation and moving correlation dissimilarity measurements (cor_diss)</p></a></li>
<li><a href='#diss_to_neighbors'><p>From dissimilarity matrix to neighbors</p></a></li>
<li><a href='#dissimilarity'><p>Dissimilarity computation between matrices</p></a></li>
<li><a href='#euclid_to_mahal'><p>A function for transforming a matrix from its Euclidean space to</p>
its Mahalanobis space</a></li>
<li><a href='#eval_multi_pc_diss'><p>evaluation of multiple distances obtained with multiple PCs</p></a></li>
<li><a href='#f_diss'><p>Euclidean, Mahalanobis and cosine dissimilarity measurements</p></a></li>
<li><a href='#fast_diss'><p>A fast distance algorithm for two matrices written in C++</p></a></li>
<li><a href='#fast_diss_vector'><p>A fast algorithm of (squared) Euclidean cross-distance for vectors written in C++</p></a></li>
<li><a href='#fit_and_predict'><p>Local multivariate regression</p></a></li>
<li><a href='#format_xr_xu_indices'><p>format internal messages</p></a></li>
<li><a href='#gaussian_pr_cv'><p>Cross validation for Gaussian process regression</p></a></li>
<li><a href='#gaussian_process'><p>Gaussian process regression with linear kernel (gaussian_process)</p></a></li>
<li><a href='#gaussian_process_cv'><p>Internal Cpp function for performing leave-group-out cross</p>
validations for gaussian process</a></li>
<li><a href='#get_col_largest_sd'><p>Function for identifiying the column in a matrix with the largest standard deviation</p></a></li>
<li><a href='#get_col_sds'><p>Standard deviation of columns</p></a></li>
<li><a href='#get_column_means'><p>Function for computing the mean of each column in a matrix</p></a></li>
<li><a href='#get_column_sds'><p>Function for computing the standard deviation of each column in a matrix</p></a></li>
<li><a href='#get_column_sums'><p>Function for computing sum of each column in a matrix</p></a></li>
<li><a href='#get_eval_categorical'><p>get the evaluation results for categorical data</p></a></li>
<li><a href='#get_eval_continuous'><p>get the evaluation results for continuous data</p></a></li>
<li><a href='#get_ith_local_neighbors'><p>A function to obtain the local neighbors based on dissimilarity</p>
matrices from orthogonal projections.</a></li>
<li><a href='#get_local_pls_weights'><p>Internal Cpp function for computing the weights of the PLS components</p>
necessary for weighted average PLS</a></li>
<li><a href='#get_neighbor_info'><p>A function to get the neighbor information</p></a></li>
<li><a href='#get_predictions'><p>Extract predictions from an object of class <code>mbl</code></p></a></li>
<li><a href='#get_sample_strata'><p>A function to assign values to sample distribution strata</p></a></li>
<li><a href='#get_samples_from_strata'><p>A function for stratified calibration/validation sampling</p></a></li>
<li><a href='#get_wapls_weights'><p>Internal function for computing the weights of the PLS components</p>
necessary for weighted average PLS</a></li>
<li><a href='#get_weights'><p>Computes the weights for pls regressions</p></a></li>
<li><a href='#ith_mbl_neighbor'><p>An iterator for local prediction data in mbl</p></a></li>
<li><a href='#ith_subsets_ortho_diss'><p>iterator for nearest neighbor subsets</p></a></li>
<li><a href='#local_fit'><p>Local fit functions</p></a></li>
<li><a href='#local_ortho_diss'><p>local ortho dissimilarity matrices initialized by a global</p>
dissimilarity matrix</a></li>
<li><a href='#mbl'><p>A function for memory-based learning (mbl)</p></a></li>
<li><a href='#mbl_control'><p>A function that controls some few aspects of the memory-based learning</p>
process in the <code>mbl</code> function</a></li>
<li><a href='#moving_cor_diss'><p>Moving/rolling correlation distance of two matrices</p></a></li>
<li><a href='#opls'><p>orthogonal scores algorithn of partial leat squares (opls)</p></a></li>
<li><a href='#opls_cv_cpp'><p>Internal Cpp function for performing leave-group-out cross-validations for pls regression</p></a></li>
<li><a href='#opls_for_projection'><p>orthogonal scores algorithn of partial leat squares (opls) projection</p></a></li>
<li><a href='#opls_get_all'><p>orthogonal scores algorithn of partial leat squares (opls_get_all)</p></a></li>
<li><a href='#opls_get_basics'><p>fast orthogonal scores algorithn of partial leat squares (opls)</p></a></li>
<li><a href='#opls_gs'><p>orthogonal scores algorithm of partial leat squares (opls)</p></a></li>
<li><a href='#optim_sample_strata'><p>A function to construct an optimal strata for the samples, based on</p>
the distribution of the given y.</a></li>
<li><a href='#ortho_diss'><p>A function for computing dissimilarity matrices from orthogonal</p>
projections (ortho_diss)</a></li>
<li><a href='#ortho_projection'><p>Orthogonal projections using principal component analysis and partial</p>
least squares</a></li>
<li><a href='#overall_var'><p>Function for computing the overall variance of a matrix</p></a></li>
<li><a href='#pca_nipals'><p>Principal components based on  the non-linear iterative partial least squares (nipals) algorithm</p></a></li>
<li><a href='#pkg_info'><p>Get the package version info</p></a></li>
<li><a href='#plot.mbl'><p>Plot method for an object of class <code>mbl</code></p></a></li>
<li><a href='#plot.ortho_projection'><p>Plot method for an object of class <code>ortho_projection</code></p></a></li>
<li><a href='#pls_cv'><p>Cross validation for PLS regression</p></a></li>
<li><a href='#predict_gaussian_process'><p>Prediction function for the <code>gaussian_process</code> function (Gaussian process regression with dot product covariance)</p></a></li>
<li><a href='#predict_opls'><p>Prediction function for the <code>opls</code> and <code>fopls</code> functions</p></a></li>
<li><a href='#print.local_fit'><p>Print method for an object of class <code>local_fit</code></p></a></li>
<li><a href='#print.local_ortho_diss'><p>Print method for an object of class <code>ortho_diss</code></p></a></li>
<li><a href='#print.mbl'><p>Print method for an object of class <code>mbl</code></p></a></li>
<li><a href='#print.ortho_projection'><p>Print method for an object of class <code>ortho_projection</code></p></a></li>
<li><a href='#project_opls'><p>Projection function for the <code>opls</code> function</p></a></li>
<li><a href='#reconstruction_error'><p>Projection to pls and then re-construction</p></a></li>
<li><a href='#sample_stratified'><p>A function to create calibration and validation sample sets for</p>
leave-group-out cross-validation</a></li>
<li><a href='#search_neighbors'><p>A function for searching in a given reference set the neighbors of</p>
another given set of observations (search_neighbors)</a></li>
<li><a href='#sid'><p>A function for computing the spectral information divergence between</p>
spectra (sid)</a></li>
<li><a href='#sim_eval'><p>A function for evaluating dissimilarity matrices (sim_eval)</p></a></li>
<li><a href='#sqrt_sm'><p>Square root of (square) symmetric matrices</p></a></li>
<li><a href='#which_min'><p>A function to compute row-wise index of minimum values of a square distance matrix</p></a></li>
<li><a href='#which_min_vector'><p>A function to compute indices of minimum values of a distance vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Memory-Based Learning in Spectral Chemometrics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Leonardo Ramirez-Lopez [aut, cre], 
    Antoine Stevens [aut, ctb],
    Claudio Orellano [ctb],
    Raphael Viscarra Rossel [ctb],
    Zefang Shen [ctb],
    Craig Lobsey [ctb], 
    Alex Wadoux [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leonardo Ramirez-Lopez &lt;ramirez.lopez.leo@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/l-ramirez-lopez/resemble/issues">https://github.com/l-ramirez-lopez/resemble/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>
    Functions for dissimilarity analysis and memory-based learning 
    (MBL, a.k.a local modeling) in complex spectral data sets. 
    Most of these functions are based on the methods presented in 
    Ramirez-Lopez et al. (2013) &lt;<a href="https://doi.org/10.1016%2Fj.geoderma.2012.12.014">doi:10.1016/j.geoderma.2012.12.014</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://l-ramirez-lopez.github.io/resemble/">http://l-ramirez-lopez.github.io/resemble/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, iterators, Rcpp (&ge; 1.0.3), mathjaxr (&ge; 1.0),
magrittr (&ge; 1.5.0), lifecycle (&ge; 0.2.0), data.table (&ge;
1.9.8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>prospectr, parallel, doParallel, testthat, formatR,
rmarkdown, bookdown, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/VersionName:</td>
<td>embryo</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 14:43:13 UTC; leo</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-16 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='resemble-package'>Overview of the functions in the resemble package</h2><span id='topic+resemble-package'></span><span id='topic+resemble'></span>

<h3>Description</h3>

<a href='https://www.tidyverse.org/lifecycle/#maturing'><img src='figures/lifecycle-maturing.svg' alt='Maturing lifecycle'></a>
<p>Functions for memory-based learning
</p>
<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>


<h3>Details</h3>

<p>This is the version
2.2.3 &ndash; embryo
of the package. It implements a number of functions useful for
modeling complex spectral spectra (e.g. NIR, IR).
The package includes functions for dimensionality reduction,
computing spectral dissimilarity matrices, nearest neighbor search,
and modeling spectral data using memory-based learning. This package builds
upon the methods presented in Ramirez-Lopez et al. (2013) doi: <a href="https://doi.org/10.1016/j.geoderma.2012.12.014">10.1016/j.geoderma.2012.12.014</a>.
</p>
<p>Development versions can be found in the github repository of the package
at <a href="https://github.com/l-ramirez-lopez/resemble">https://github.com/l-ramirez-lopez/resemble</a>.
</p>
<p>The functions available for dimensionality reduction are:
</p>

<ul>
<li><p><code><a href="#topic+ortho_projection">ortho_projection</a></code>
</p>
</li>
<li><p><code><a href="#topic+pc_projection">pc_projection</a></code>
</p>
</li>
<li><p><code><a href="#topic+pls_projection">pls_projection</a></code>
</p>
</li>
<li><p><code><a href="#topic+predict.ortho_projection">predict.ortho_projection</a></code>
</p>
</li></ul>

<p>The functions available for computing dissimilarity matrices are:
</p>

<ul>
<li><p><code><a href="#topic+dissimilarity">dissimilarity</a></code>
</p>
</li>
<li><p><code><a href="#topic+f_diss">f_diss</a></code>
</p>
</li>
<li><p><code><a href="#topic+cor_diss">cor_diss</a></code>
</p>
</li>
<li><p><code><a href="#topic+sid">sid</a></code>
</p>
</li>
<li><p><code><a href="#topic+ortho_diss">ortho_diss</a></code>
</p>
</li></ul>

<p>The functions available for evaluating dissimilarity matrices are:
</p>

<ul>
<li><p><code><a href="#topic+sim_eval">sim_eval</a></code>
</p>
</li></ul>

<p>The functions available for nearest neighbor search:
</p>

<ul>
<li><p><code><a href="#topic+search_neighbors">search_neighbors</a></code>
</p>
</li></ul>

<p>The functions available for modeling spectral data:
</p>

<ul>
<li><p><code><a href="#topic+mbl">mbl</a></code>
</p>
</li>
<li><p><code><a href="#topic+mbl_control">mbl_control</a></code>
</p>
</li></ul>

<p>Other supplementary functions:
</p>

<ul>
<li><p><code><a href="#topic+plot.mbl">plot.mbl</a></code>
</p>
</li>
<li><p><code><a href="#topic+plot.ortho_projection">plot.ortho_projection</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer / Creator</strong>: Leonardo Ramirez-Lopez <a href="mailto:ramirez.lopez.leo@gmail.com">ramirez.lopez.leo@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Leonardo Ramirez-Lopez (<a href="https://orcid.org/0000-0002-5369-5120">ORCID</a>)
</p>
</li>
<li><p> Antoine Stevens (<a href="https://orcid.org/0000-0002-1588-7519">ORCID</a>)
</p>
</li>
<li><p> Claudio Orellano
</p>
</li>
<li><p> Raphael Viscarra Rossel (<a href="https://orcid.org/0000-0003-1540-4748">ORCID</a>)
</p>
</li>
<li><p> Zefang Shen
</p>
</li>
<li><p> Craig Lobsey (<a href="https://orcid.org/0000-0001-5416-8640">ORCID</a>)
</p>
</li>
<li><p> Alex Wadoux (<a href="https://orcid.org/0000-0001-7325-9716">ORCID</a>)
</p>
</li></ul>



<h3>References</h3>

<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196,
268-279.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/l-ramirez-lopez/resemble">https://github.com/l-ramirez-lopez/resemble</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/l-ramirez-lopez/resemble/issues">https://github.com/l-ramirez-lopez/resemble/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.local_ortho_diss'>Print method for an object of class <code>local_ortho_diss</code></h2><span id='topic++5B.local_ortho_diss'></span>

<h3>Description</h3>

<p>prints the subsets of local_ortho_diss objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'local_ortho_diss'
x[rows, columns, drop = FALSE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.local_ortho_diss_+3A_x">x</code></td>
<td>
<p><code>local_ortho_diss</code> matrix</p>
</td></tr>
<tr><td><code id="+2B5B.local_ortho_diss_+3A_rows">rows</code></td>
<td>
<p>the indices of the rows</p>
</td></tr>
<tr><td><code id="+2B5B.local_ortho_diss_+3A_columns">columns</code></td>
<td>
<p>the indices of the columns</p>
</td></tr>
<tr><td><code id="+2B5B.local_ortho_diss_+3A_drop">drop</code></td>
<td>
<p>drop argument</p>
</td></tr>
<tr><td><code id="+2B5B.local_ortho_diss_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='check_pc_arguments'>checks the pc_selection argument</h2><span id='topic+check_pc_arguments'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pc_arguments(
  n_rows_x,
  n_cols_x,
  pc_selection,
  default_max_comp = 40,
  default_max_cumvar = 0.99,
  default_max_var = 0.01
)
</code></pre>

<hr>
<h2 id='cor_diss'>Correlation and moving correlation dissimilarity measurements (cor_diss)</h2><span id='topic+cor_diss'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<a href='https://www.tidyverse.org/lifecycle/#satble'><img src='figures/lifecycle-stable.svg' alt='Stable lifecycle'></a>
<p>Computes correlation and moving correlation dissimilarity matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_diss(Xr, Xu = NULL, ws = NULL,
         center = TRUE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_diss_+3A_xr">Xr</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="cor_diss_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix containing data of a second set of observations.</p>
</td></tr>
<tr><td><code id="cor_diss_+3A_ws">ws</code></td>
<td>
<p>for moving correlation dissimilarity, an odd integer value which
specifies the window size. If <code>ws = NULL</code>, then the window size will be
equal to the number of variables (columns), i.e. instead moving correlation,
the normal correlation will be used. See details.</p>
</td></tr>
<tr><td><code id="cor_diss_+3A_center">center</code></td>
<td>
<p>a logical indicating if the spectral data <code>Xr</code> (and
<code>Xu</code> if specified) must be centered. If <code>Xu</code> is provided, the data
is scaled on the basis of \(Xr \cup Xu\).</p>
</td></tr>
<tr><td><code id="cor_diss_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if <code>Xr</code> (and <code>Xu</code> if specified)
must be scaled. If <code>Xu</code> is provided the data is scaled on the basis
of \(Xr \cup Xu\).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation dissimilarity \(d\) between two observations
\(x_i\) and \(x_j\) is based on the Perason's
correlation coefficient (\(\rho\)) and it can be computed as
follows:
</p>
\[d(x_i, x_j) = \frac{1}{2}((1 - \rho(x_i, x_j)))\]
<p>The above formula is used when <code>ws = NULL</code>.
On the other hand (when <code>ws != NULL</code>) the moving correlation
dissimilarity between two observations \(x_i\) and \(x_j\)
is computed as follows:
</p>
\[d(x_i, x_j; ws) = \frac{1}{2 ws}\sum_{k=1}^{p-ws}1 - \rho(x_{i,(k:k+ws)}, x_{j,(k:k+ws)})\]
<p>where \(ws\) represents a given window size which rolls sequentially
from 1 up to \(p - ws\) and  \(p\) is the number of
variables of the observations.
</p>
<p>The function does not accept input data containing missing values.
</p>


<h3>Value</h3>

<p>a matrix of the computed dissimilarities.
</p>


<h3>Author(s)</h3>

<p>Antoine Stevens and <a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)
data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

cor_diss(Xr = Xr)

cor_diss(Xr = Xr, Xu = Xu)

cor_diss(Xr = Xr, ws = 41)

cor_diss(Xr = Xr, Xu = Xu, ws = 41)

</code></pre>

<hr>
<h2 id='diss_to_neighbors'>From dissimilarity matrix to neighbors</h2><span id='topic+diss_to_neighbors'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diss_to_neighbors(
  diss_matrix,
  k = NULL,
  k_diss = NULL,
  k_range = NULL,
  spike = NULL,
  return_dissimilarity = FALSE,
  skip_first = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diss_to_neighbors_+3A_diss_matrix">diss_matrix</code></td>
<td>
<p>a matrix representing the dissimilarities between
observations in a matrix <code>Xu</code> and observations in another matrix
<code>Xr</code>. <code>Xr</code> in rows <code>Xu</code> in columns.</p>
</td></tr>
<tr><td><code id="diss_to_neighbors_+3A_k">k</code></td>
<td>
<p>an integer value indicating the k-nearest neighbors of each
observation in <code>Xu</code> that must be selected from <code>Xr</code>.</p>
</td></tr>
<tr><td><code id="diss_to_neighbors_+3A_k_diss">k_diss</code></td>
<td>
<p>an integer value indicating a dissimilarity treshold.
For each observation in <code>Xu</code>, its nearest neighbors in <code>Xr</code>
are selected as those for which their dissimilarity to <code>Xu</code> is below
this <code>k_diss</code> threshold. This treshold depends on the corresponding
dissimilarity metric specified in <code>diss_method</code>. Either <code>k</code> or
<code>k_diss</code> must be specified.</p>
</td></tr>
<tr><td><code id="diss_to_neighbors_+3A_k_range">k_range</code></td>
<td>
<p>an integer vector of length 2 which specifies the minimum
(first value) and the maximum (second value) number of neighbors to be
retained when the <code>k_diss</code> is given.</p>
</td></tr>
<tr><td><code id="diss_to_neighbors_+3A_spike">spike</code></td>
<td>
<p>a vector of integers indicating what observations in <code>Xr</code>
(and <code>Yr</code>) must be 'forced' to always be part of all the neighborhoods.</p>
</td></tr>
<tr><td><code id="diss_to_neighbors_+3A_return_dissimilarity">return_dissimilarity</code></td>
<td>
<p>logical indicating if the input dissimilarity
must be mirroed in the output.</p>
</td></tr>
<tr><td><code id="diss_to_neighbors_+3A_skip_first">skip_first</code></td>
<td>
<p>a logical indicating whether to skip the first neighbor or
not. Default is <code>FALSE</code>. This is used when the search is being conducted
in symmetric matrix of distances (i.e. to avoid that the nearest neighbor of
each observation is itself).</p>
</td></tr>
</table>

<hr>
<h2 id='dissimilarity'>Dissimilarity computation between matrices</h2><span id='topic+dissimilarity'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This is a wrapper to integrate the different dissimilarity functions of the
offered by package.It computes the dissimilarities between observations in
numerical matrices by using an specifed dissmilarity measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity(Xr, Xu = NULL,
              diss_method = c("pca", "pca.nipals", "pls", "mpls",
                              "cor", "euclid", "cosine", "sid"),
              Yr = NULL, gh = FALSE, pc_selection = list("var", 0.01),
              return_projection = FALSE, ws = NULL,
              center = TRUE, scale = FALSE, documentation = character(),
              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_+3A_xr">Xr</code></td>
<td>
<p>a matrix of containing <code>n</code> observations/rows and <code>p</code>
variables/columns.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix containing data of a second set of observations
with <code>p</code> variables/columns.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_diss_method">diss_method</code></td>
<td>
<p>a character string indicating the method to be used to
compute the dissimilarities between observations. Options are:
</p>

<ul>
<li><p><code>"pca"</code>: Mahalanobis distance
computed on the matrix of scores of a Principal Component (PC)
projection of <code>Xr</code> (and <code>Xu</code> if provided). PC projection is
done using the singular value decomposition (SVD) algorithm.
See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"pca.nipals"</code>: Mahalanobis distance
computed on the matrix of scores of a Principal Component (PC)
projection of <code>Xr</code> (and <code>Xu</code> if provided). PC projection is
done using the non-linear iterative partial least squares (nipals)
algorithm. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"pls"</code>: Mahalanobis distance
computed on the matrix of scores of a partial least squares projection
of <code>Xr</code> (and <code>Xu</code> if provided). In this case, <code>Yr</code> is
always required. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"mpls"</code>: Mahalanobis distance
computed on the matrix of scores of a modified partial least squares
projection (Shenk and Westerhaus, 1991; Westerhaus, 2014)
of <code>Xr</code> (and <code>Xu</code> if provided). In this case, <code>Yr</code> is
always required. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"cor"</code>: based on the correlation coefficient
between observations. See <code><a href="#topic+cor_diss">cor_diss</a></code> function.
</p>
</li>
<li><p><code>"euclid"</code>: Euclidean distance
between observations. See <code><a href="#topic+f_diss">f_diss</a></code> function.
</p>
</li>
<li><p><code>"cosine"</code>: Cosine distance
between observations. See <code><a href="#topic+f_diss">f_diss</a></code> function.
</p>
</li>
<li><p><code>"sid"</code>: spectral information divergence between
observations. See <code><a href="#topic+sid">sid</a></code> function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dissimilarity_+3A_yr">Yr</code></td>
<td>
<p>a numeric matrix of <code>n</code> observations used as side information of
<code>Xr</code> for the <code><a href="#topic+ortho_diss">ortho_diss</a></code> methods (i.e. <code>pca</code>,
<code>pca.nipals</code> or <code>pls</code>). It is required when:
</p>

<ul>
<li><p><code>diss_method = "pls"</code>
</p>
</li>
<li><p><code>diss_method = "pca"</code> with <code>"opc"</code> used as the method
in the <code>pc_selection</code> argument. See <code><a href="#topic+ortho_diss">ortho_diss</a>.</code>
</p>
</li>
<li><p><code>gh = TRUE</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="dissimilarity_+3A_gh">gh</code></td>
<td>
<p>a logical indicating if the Mahalanobis distance (in the pls score
space) between each observation and the pls centre/mean must be
computed.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_pc_selection">pc_selection</code></td>
<td>
<p>a list of length 2 to be passed onto the
<code><a href="#topic+ortho_diss">ortho_diss</a></code> methods. It is required if the method selected in
<code>diss_method</code> is any of <code>"pca"</code>, <code>"pca.nipals"</code> or
<code>"pls"</code> or if <code>gh = TRUE</code>. This argument is used for
optimizing the number of components (principal components or pls factors)
to be retained. This list must contain two elements in the following order:
<code>method</code> (a character indicating the method for selecting the number of
components) and <code>value</code> (a numerical value that complements the selected
method). The methods available are:
</p>

<ul>
<li><p><code>"opc"</code>: optimized principal component selection based on
Ramirez-Lopez et al. (2013a, 2013b). The optimal number of components
(of set of observations) is the one for which its distance matrix
minimizes the differences between the <code>Yr</code> value of each
observation and the <code>Yr</code> value of its closest observation. In this
case <code>value</code> must be a value ((larger than 0 and
below the minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code>
combined) indicating the maximum
number of principal components to be tested. See the
<code><a href="#topic+ortho_projection">ortho_projection</a></code> function for more details.
</p>
</li>
<li><p><code>"cumvar"</code>: selection of the principal components based
on a given cumulative amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of cumulative variance that the
combination of retained components should explain.
</p>
</li>
<li><p><code>"var"</code>: selection of the principal components based
on a given amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of variance that a single component
should explain in order to be retained.
</p>
</li>
<li><p><code>"manual"</code>: for manually specifying a fix number of
principal components. In this case, <code>value</code> must be a value
(larger than 0 and
below the minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code>
combined).
indicating the minimum amount of variance that a component should
explain in order to be retained.
</p>
</li></ul>

<p>The default is <code>list(method = "var", value = 0.01)</code>.
</p>
<p>Optionally, the <code>pc_selection</code> argument admits <code>"opc"</code> or
<code>"cumvar"</code> or <code>"var"</code> or <code>"manual"</code> as a single character
string. In such a case the default <code>"value"</code> when either <code>"opc"</code> or
<code>"manual"</code> are used is 40. When <code>"cumvar"</code> is used the default
<code>"value"</code> is set to 0.99 and when <code>"var"</code> is used, the default
<code>"value"</code> is set to 0.01.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_return_projection">return_projection</code></td>
<td>
<p>a logical indicating if the projection(s) must be
returned. Projections are used if the <code><a href="#topic+ortho_diss">ortho_diss</a></code> methods are
called (i.e. <code>diss_method = "pca"</code>, <code>diss_method = "pca.nipals"</code> or
<code>diss_method = "pls"</code>) or when <code>gh = TRUE</code>.
In case <code>gh = TRUE</code> and a <code><a href="#topic+ortho_diss">ortho_diss</a></code> method is used (in the
<code>diss_method</code> argument), both projections are returned.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_ws">ws</code></td>
<td>
<p>an odd integer value which specifies the window size, when
<code>diss_method = "cor"</code> (<code><a href="#topic+cor_diss">cor_diss</a></code> method) for moving
correlation dissimilarity. If <code>ws = NULL</code> (default), then the window
size will be equal to the number of variables (columns), i.e. instead moving
correlation, the normal correlation will be used. See <code><a href="#topic+cor_diss">cor_diss</a></code>
function.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_center">center</code></td>
<td>
<p>a logical indicating if <code>Xr</code> (and <code>Xu</code> if provided)
must be centered. If <code>Xu</code> is provided the data is centered around the
mean of the pooled <code>Xr</code> and <code>Xu</code> matrices (\(Xr \cup Xu\)). For
dissimilarity computations based on <code>diss_method = pls</code>, the data is
always centered.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if <code>Xr</code> (and <code>Xu</code> if
provided) must be  scaled. If <code>Xu</code> is provided the data is scaled based
on the standard deviation of the the pooled <code>Xr</code> and <code>Xu</code> matrices
(\(Xr \cup Xu\)). If <code>center = TRUE</code>, scaling is applied after
centering.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_documentation">documentation</code></td>
<td>
<p>an optional character string that can be used to
describe anything related to the <code>mbl</code> call (e.g. description of the
input data). Default: <code>character()</code>. NOTE: his is an experimental
argument.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_...">...</code></td>
<td>
<p>other arguments passed to the dissimilarity functions
(<code><a href="#topic+ortho_diss">ortho_diss</a></code>, <code><a href="#topic+cor_diss">cor_diss</a></code>, <code><a href="#topic+f_diss">f_diss</a></code> or
<code><a href="#topic+sid">sid</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for <code><a href="#topic+ortho_diss">ortho_diss</a></code>, <code><a href="#topic+cor_diss">cor_diss</a></code>,
<code><a href="#topic+f_diss">f_diss</a></code>, <code><a href="#topic+sid">sid</a></code>. Check the documentation of these
functions for further details.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<ul>
<li><p><code>dissimilarity</code>: the resulting dissimilarity matrix.
</p>
</li>
<li><p><code>projection</code>: an <code>ortho_projection</code> object. Only output
if <code>return_projection = TRUE</code> and if <code>diss_method = "pca"</code>,
<code>diss_method = "pca.nipals"</code>,  <code>diss_method = "pls"</code> or
<code>diss_method = "mpls"</code>.
This object contains the projection used to compute
the dissimilarity matrix. In case of local dissimilarity matrices,
the projection corresponds to the global projection used to select the
neighborhoods (see <code><a href="#topic+ortho_diss">ortho_diss</a></code> function for further
details).
</p>
</li>
<li><p><code>gh</code>: a list containing the GH distances as well as the
pls projection used to compute the GH.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>References</h3>

<p>Shenk, J., Westerhaus, M., and Berzaghi, P. 1997. Investigation of a LOCAL
calibration procedure for near infrared instruments. Journal of Near Infrared
Spectroscopy, 5, 223-232.
</p>
<p>Westerhaus, M. 2014. Eastern Analytical Symposium Award for outstanding
Wachievements in near infrared spectroscopy: my contributions to
Wnear infrared spectroscopy. NIR news, 25(8), 16-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ortho_diss">ortho_diss</a></code> <code><a href="#topic+cor_diss">cor_diss</a></code> <code><a href="#topic+f_diss">f_diss</a></code>
<code><a href="#topic+sid">sid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(prospectr)
data(NIRsoil)

# Filter the data using the first derivative with Savitzky and Golay
# smoothing filter and a window size of 11 spectral variables and a
# polynomial order of 4
sg &lt;- savitzkyGolay(NIRsoil$spc, m = 1, p = 4, w = 15)

# Replace the original spectra with the filtered ones
NIRsoil$spc &lt;- sg

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Yu &lt;- NIRsoil$CEC[!as.logical(NIRsoil$train)]

Yr &lt;- NIRsoil$CEC[as.logical(NIRsoil$train)]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

Xu &lt;- Xu[!is.na(Yu), ]
Xr &lt;- Xr[!is.na(Yr), ]

Yu &lt;- Yu[!is.na(Yu)]
Yr &lt;- Yr[!is.na(Yr)]

dsm_pca &lt;- dissimilarity(
  Xr = Xr, Xu = Xu,
  diss_method = c("pca"),
  Yr = Yr, gh = TRUE,
  pc_selection = list("opc", 30),
  return_projection = TRUE
)
</code></pre>

<hr>
<h2 id='euclid_to_mahal'>A function for transforming a matrix from its Euclidean space to
its Mahalanobis space</h2><span id='topic+euclid_to_mahal'></span>

<h3>Description</h3>

<p>For internal use only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclid_to_mahal(X, sm_method = c("svd", "eigen"))
</code></pre>

<hr>
<h2 id='eval_multi_pc_diss'>evaluation of multiple distances obtained with multiple PCs</h2><span id='topic+eval_multi_pc_diss'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_multi_pc_diss(
  scores,
  side_info,
  from = 1,
  to = ncol(scores),
  steps = 1,
  method = c("pc", "pls"),
  check_dims = TRUE
)
</code></pre>

<hr>
<h2 id='f_diss'>Euclidean, Mahalanobis and cosine dissimilarity measurements</h2><span id='topic+f_diss'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<a href='https://www.tidyverse.org/lifecycle/#satble'><img src='figures/lifecycle-stable.svg' alt='Stable lifecycle'></a>
<p>This function is used to compute the dissimilarity between observations
based on Euclidean or Mahalanobis distance measures or on cosine
dissimilarity measures (a.k.a spectral angle mapper).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_diss(Xr, Xu = NULL, diss_method = "euclid",
       center = TRUE, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_diss_+3A_xr">Xr</code></td>
<td>
<p>a matrix containing the (reference) data.</p>
</td></tr>
<tr><td><code id="f_diss_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix containing data of a second set of observations
(samples).</p>
</td></tr>
<tr><td><code id="f_diss_+3A_diss_method">diss_method</code></td>
<td>
<p>the method for computing the dissimilarity between
observations.
Options are <code>"euclid"</code> (Euclidean distance), <code>"mahalanobis"</code>
(Mahalanobis distance) and <code>"cosine"</code> (cosine distance, a.k.a spectral
angle mapper). See details.</p>
</td></tr>
<tr><td><code id="f_diss_+3A_center">center</code></td>
<td>
<p>a logical indicating if the spectral data <code>Xr</code> (and
<code>Xu</code> if specified) must be centered. If <code>Xu</code> is provided, the data
is scaled on the basis of \(Xr \cup Xu\).</p>
</td></tr>
<tr><td><code id="f_diss_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if <code>Xr</code> (and <code>Xu</code> if specified)
must be scaled. If <code>Xu</code> is provided the data is scaled on the basis
of \(Xr \cup Xu\).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results obtained for Euclidean dissimilarity are equivalent to those
returned by the <code><a href="stats.html#topic+dist">stats::dist()</a></code> function, but are scaled
differently. However, <code>f_diss</code> is considerably faster (which can be
advantageous when computing dissimilarities for very large matrices). The
final scaling of the dissimilarity scores in <code>f_diss</code> where
the number of variables is used to scale the squared dissimilarity scores. See
the examples section for a comparison between <code><a href="stats.html#topic+dist">stats::dist()</a></code> and
<code>f_diss</code>.
</p>
<p>In the case of both the Euclidean and Mahalanobis distances, the scaled
dissimilarity matrix \(D\) between between observations in a given
matrix \(X\) is computed as follows:
</p>
\[d(x_i, x_j)^{2} = \sum (x_i - x_j)M^{-1}(x_i - x_j)^{\mathrm{T}}\]
\[d_{scaled}(x_i, x_j) = \sqrt{\frac{1}{p}d(x_i, x_j)^{2}}\]
<p>where \(p\) is the number of variables in \(X\), \(M\) is the identity
matrix in the case of the Euclidean distance and the variance-covariance
matrix of \(X\) in the case of the Mahalanobis distance. The Mahalanobis
distance can also be viewed as the Euclidean distance after applying a
linear transformation of the original variables. Such a linear transformation
is done by using a factorization of the inverse covariance matrix as
\(M^{-1} = W^{T}W\), where \(M\) is merely the square root of
\(M^{-1}\) which can be found by using a singular value decomposition.
</p>
<p>Note that when attempting to compute the Mahalanobis distance on a dataset
with highly correlated variables (i.e. spectral variables) the
variance-covariance matrix may result in a singular matrix which cannot be
inverted and therefore the distance cannot be computed.
This is also the case when the number of observations in the dataset is
smaller than the number of variables.
</p>
<p>For the computation of the Mahalanobis distance, the mentioned method is
used.
</p>
<p>The cosine dissimilarity \(c\) between two observations
\(x_i\) and \(x_j\) is computed as follows:
</p>
\[c(x_i, x_j) = cos^{-1}{\frac{\sum_{k=1}^{p}x_{i,k} x_{j,k}}{\sqrt{\sum_{k=1}^{p} x_{i,k}^{2}} \sqrt{\sum_{k=1}^{p} x_{j,k}^{2}}}}\]
<p>where \(p\) is the number of variables of the observations.
The function does not accept input data containing missing values.
NOTE: The computed distances are divided by the number of variables/columns
in <code>Xr</code>.
</p>


<h3>Value</h3>

<p>a matrix of the computed dissimilarities.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a> and Antoine Stevens
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)
data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

# Euclidean distances between all the observations in Xr

ed &lt;- f_diss(Xr = Xr, diss_method = "euclid")

# Equivalence with the dist() fucntion of R base
ed_dist &lt;- (as.matrix(dist(Xr))^2 / ncol(Xr))^0.5
round(ed_dist - ed, 5)

# Comparing the computational time
iter &lt;- 20
tm &lt;- proc.time()
for (i in 1:iter) {
  f_diss(Xr)
}
f_diss_time &lt;- proc.time() - tm

tm_2 &lt;- proc.time()
for (i in 1:iter) {
  dist(Xr)
}
dist_time &lt;- proc.time() - tm_2

f_diss_time
dist_time

# Euclidean distances between observations in Xr and observations in Xu
ed_xr_xu &lt;- f_diss(Xr, Xu)

# Mahalanobis distance computed on the first 20 spectral variables
md_xr_xu &lt;- f_diss(Xr[, 1:20], Xu[, 1:20], "mahalanobis")

# Cosine dissimilarity matrix
cdiss_xr_xu &lt;- f_diss(Xr, Xu, "cosine")

</code></pre>

<hr>
<h2 id='fast_diss'>A fast distance algorithm for two matrices written in C++</h2><span id='topic+fast_diss'></span>

<h3>Description</h3>

<p>Computes distances between two data matrices using
&quot;euclid&quot;, &quot;cor&quot;, &quot;cosine&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_diss(X, Y, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_diss_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="fast_diss_+3A_y">Y</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="fast_diss_+3A_method">method</code></td>
<td>
<p>a <code>string</code> with possible values &quot;euclid&quot;, &quot;cor&quot;, &quot;cosine&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix
</p>


<h3>Author(s)</h3>

<p>Antoine Stevens and Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='fast_diss_vector'>A fast algorithm of (squared) Euclidean cross-distance for vectors written in C++</h2><span id='topic+fast_diss_vector'></span>

<h3>Description</h3>

<p>A fast (parallel for linux) algorithm of (squared) Euclidean cross-distance for vectors written in C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_diss_vector(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_diss_vector_+3A_x">X</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>used internally in ortho_projection
</p>


<h3>Value</h3>

<p>a vector of distance (lower triangle of the distance matrix, stored by column)
</p>


<h3>Author(s)</h3>

<p>Antoine Stevens
</p>

<hr>
<h2 id='fit_and_predict'>Local multivariate regression</h2><span id='topic+fit_and_predict'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_and_predict(
  x,
  y,
  pred_method,
  scale = FALSE,
  weights = NULL,
  newdata,
  pls_c = NULL,
  CV = FALSE,
  tune = FALSE,
  number = 10,
  p = 0.75,
  group = NULL,
  noise_variance = 0.001,
  range_prediction_limits = TRUE,
  pls_max_iter = 1,
  pls_tol = 1e-06,
  modified = FALSE,
  seed = NULL
)
</code></pre>

<hr>
<h2 id='format_xr_xu_indices'>format internal messages</h2><span id='topic+format_xr_xu_indices'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_xr_xu_indices(xr_xu_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_xr_xu_indices_+3A_xr_xu_names">xr_xu_names</code></td>
<td>
<p>the names of Xr and Xu</p>
</td></tr>
</table>

<hr>
<h2 id='gaussian_pr_cv'>Cross validation for Gaussian process regression</h2><span id='topic+gaussian_pr_cv'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_pr_cv(
  x,
  y,
  scale,
  weights = NULL,
  p = 0.75,
  number = 10,
  group = NULL,
  noise_variance = 0.001,
  retrieve = c("final_model", "none"),
  seed = NULL
)
</code></pre>

<hr>
<h2 id='gaussian_process'>Gaussian process regression with linear kernel (gaussian_process)</h2><span id='topic+gaussian_process'></span>

<h3>Description</h3>

<p>Carries out a gaussian process regression with a linear kernel (dot product). For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_process(X, Y, noisev, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_process_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables</p>
</td></tr>
<tr><td><code id="gaussian_process_+3A_y">Y</code></td>
<td>
<p>a matrix with a single response variable</p>
</td></tr>
<tr><td><code id="gaussian_process_+3A_noisev">noisev</code></td>
<td>
<p>a value indicating the variance of the noise for Gaussian process regression. Default is 0.001. a matrix with a single response variable</p>
</td></tr>
<tr><td><code id="gaussian_process_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether both the predictors
and the response variable must be scaled to zero mean and unit variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>b</code>: the regression coefficients.
</p>
</li>
<li><p><code>Xz</code>: the (final transformed) matrix of predictor variables.
</p>
</li>
<li><p><code>alpha</code>: the alpha matrix.
</p>
</li>
<li><p><code>is.scaled</code>: logical indicating whether both the predictors and response variable were scaled to zero mean and unit variance.
</p>
</li>
<li><p><code>Xcenter</code>: if matrix of predictors was scaled, the centering vector used for <code>X</code>.
</p>
</li>
<li><p><code>Xscale</code>: if matrix of predictors was scaled, the scaling vector used for <code>X</code>.
</p>
</li>
<li><p><code>Ycenter</code>: if matrix of predictors was scaled, the centering vector used for <code>Y</code>.
</p>
</li>
<li><p><code>Yscale</code>: if matrix of predictors was scaled, the scaling vector used for <code>Y</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='gaussian_process_cv'>Internal Cpp function for performing leave-group-out cross
validations for gaussian process</h2><span id='topic+gaussian_process_cv'></span>

<h3>Description</h3>

<p>For internal use only!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_process_cv(X, Y, mindices, pindices, noisev = 0.001,  
scale = TRUE, statistics = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_process_cv_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="gaussian_process_cv_+3A_y">Y</code></td>
<td>
<p>a matrix of a single response variable.</p>
</td></tr>
<tr><td><code id="gaussian_process_cv_+3A_mindices">mindices</code></td>
<td>
<p>a matrix with <code>n</code> rows and <code>m</code> columns where <code>m</code> is equivalent to the number of
resampling iterations. The elements of each column indicate the indices of the observations to be used for modeling at each
iteration.</p>
</td></tr>
<tr><td><code id="gaussian_process_cv_+3A_pindices">pindices</code></td>
<td>
<p>a matrix with <code>k</code> rows and <code>m</code> columns where <code>m</code> is equivalent to the number of
resampling iterations. The elements of each column indicate the indices of the observations to be used for predicting at each
iteration.</p>
</td></tr>
<tr><td><code id="gaussian_process_cv_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether both the predictors
and the response variable must be scaled to zero mean and unit variance.</p>
</td></tr>
<tr><td><code id="gaussian_process_cv_+3A_statistics">statistics</code></td>
<td>
<p>a logical value indicating whether the precision and
accuracy statistics are to be returned, otherwise the predictions for each
validation segment are retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following one-row matrices:
</p>

<ul>
<li><p><code>rmse.seg</code>: the RMSEs.
</p>
</li>
<li><p><code>st.rmse.seg</code>: the standardized RMSEs.
</p>
</li>
<li><p><code>rsq.seg</code>: the coefficients of determination.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_col_largest_sd'>Function for identifiying the column in a matrix with the largest standard deviation</h2><span id='topic+get_col_largest_sd'></span>

<h3>Description</h3>

<p>Identifies the column with the largest standard deviation. For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_col_largest_sd(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_col_largest_sd_+3A_x">X</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a value indicating the index of the column with the largest standard deviation.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_col_sds'>Standard deviation of columns</h2><span id='topic+get_col_sds'></span>

<h3>Description</h3>

<p>For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_col_sds(x)
</code></pre>

<hr>
<h2 id='get_column_means'>Function for computing the mean of each column in a matrix</h2><span id='topic+get_column_means'></span>

<h3>Description</h3>

<p>Computes the mean of each column in a matrix. For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_column_means(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_column_means_+3A_x">X</code></td>
<td>
<p>a a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of mean values.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_column_sds'>Function for computing the standard deviation of each column in a matrix</h2><span id='topic+get_column_sds'></span>

<h3>Description</h3>

<p>Computes the standard deviation of each column in a matrix. For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_column_sds(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_column_sds_+3A_x">X</code></td>
<td>
<p>a a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of standard deviation values.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_column_sums'>Function for computing sum of each column in a matrix</h2><span id='topic+get_column_sums'></span>

<h3>Description</h3>

<p>Computes the sum of each column in a matrix. For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_column_sums(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_column_sums_+3A_x">X</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of standard deviation values.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_eval_categorical'>get the evaluation results for categorical data</h2><span id='topic+get_eval_categorical'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eval_categorical(y, indices_closest)
</code></pre>

<hr>
<h2 id='get_eval_continuous'>get the evaluation results for continuous data</h2><span id='topic+get_eval_continuous'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eval_continuous(y, indices_closest)
</code></pre>

<hr>
<h2 id='get_ith_local_neighbors'>A function to obtain the local neighbors based on dissimilarity
matrices from orthogonal projections.</h2><span id='topic+get_ith_local_neighbors'></span>

<h3>Description</h3>

<p>internal function. This function is used to obtain the local
neighbors based on dissimilarity matrices from orthogonal projections. These
neighbors are obatin from an orthogonal projection on a set of precomputed
neighbors. This function is used internally by the mbl fucntion.
ortho_diss(, .local = TRUE) operates in the same way, however for mbl, it is
more efficient to do the re-search of the neighbors inside its main for loop
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ith_local_neighbors(
  ith_xr,
  ith_xu,
  ith_yr,
  ith_yu = NULL,
  diss_usage = "none",
  ith_neig_indices,
  k = NULL,
  k_diss = NULL,
  k_range = NULL,
  spike = NULL,
  diss_method,
  pc_selection,
  ith_group = NULL,
  center,
  scale,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ith_local_neighbors_+3A_ith_xr">ith_xr</code></td>
<td>
<p>the set of neighbors of a Xu observation found in Xr</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_ith_xu">ith_xu</code></td>
<td>
<p>the Xu observation</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_ith_yr">ith_yr</code></td>
<td>
<p>the response values of the set of neighbors of the Xu
observation found in Xr</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_ith_yu">ith_yu</code></td>
<td>
<p>the response value of the xu observation</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_diss_usage">diss_usage</code></td>
<td>
<p>a character string indicating if the dissimilarity data
will be used as predictors (&quot;predictors&quot;) or not (&quot;none&quot;).</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_ith_neig_indices">ith_neig_indices</code></td>
<td>
<p>a vector of the original indices of the Xr neighbors.</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_k">k</code></td>
<td>
<p>the number of nearest neighbors to select from the already
identified neighbors</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_k_diss">k_diss</code></td>
<td>
<p>the distance threshold to select the neighbors from the already
identified neighbors</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_k_range">k_range</code></td>
<td>
<p>a min and max  number of allowed neighbors when <code>k_diss</code>
is used</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_spike">spike</code></td>
<td>
<p>a vector with the indices of the observations forced to be
retained as neighbors. They have to be present in all the neighborhoods and
at the top of <code>neighbor_indices</code>.</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_diss_method">diss_method</code></td>
<td>
<p>the ortho_diss() method</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_pc_selection">pc_selection</code></td>
<td>
<p>the pc_selection argument as in ortho_diss()</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_ith_group">ith_group</code></td>
<td>
<p>the vector containing the group labes of <code>ith_xr</code>.</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_center">center</code></td>
<td>
<p>center the data in the local diss computation?</p>
</td></tr>
<tr><td><code id="get_ith_local_neighbors_+3A_scale">scale</code></td>
<td>
<p>scale the data in the local diss computation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list:
</p>

<ul>
<li><p>ith_xr: the new Xr data of the neighbors for the ith observation (if
<code>diss_usage = "predictors"</code>, this data is combined with the local
dissmilarity scores of the neighbors of Xu)
</p>
</li>
<li><p>ith_yr: the new Yr data of the neighbors for the ith observation
</p>
</li>
<li><p>ith_xu: the ith Xu observation (if <code>diss_usage = "predictors"</code>,
this data is combined with the local dissmilarity scores to its Xr neighbors
</p>
</li>
<li><p>ith_yu: the ith Yu observation
</p>
</li>
<li><p>ith_neigh_diss: the new dissimilarity scores of the neighbors for the ith
observation
</p>
</li>
<li><p>ith_group: the group labels for the new ith_xr
</p>
</li>
<li><p>n_k: the number of neighbors
</p>
</li>
<li><p>ith_components: the number of components used
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_local_pls_weights'>Internal Cpp function for computing the weights of the PLS components
necessary for weighted average PLS</h2><span id='topic+get_local_pls_weights'></span>

<h3>Description</h3>

<p>For internal use only!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_local_pls_weights(projection_mat, 
          xloadings, 
          coefficients, 
          new_x, 
          min_component, 
          max_component, 
          scale, 
          Xcenter, 
          Xscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_local_pls_weights_+3A_projection_mat">projection_mat</code></td>
<td>
<p>the projection matrix generated either by the <code>opls</code> function.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_xloadings">xloadings</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_coefficients">coefficients</code></td>
<td>
<p>the matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_new_x">new_x</code></td>
<td>
<p>a matrix of one new spectra to be predicted.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_min_component">min_component</code></td>
<td>
<p>an integer indicating the minimum number of pls components.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_max_component">max_component</code></td>
<td>
<p>an integer indicating the maximum number of pls components.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the matrix of predictors used to create the regression model was scaled.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_xcenter">Xcenter</code></td>
<td>
<p>a matrix of one row with the values that must be used for centering <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="get_local_pls_weights_+3A_xscale">Xscale</code></td>
<td>
<p>if <code>scale = TRUE</code> a matrix of one row with the values that must be used for scaling <code>newdata</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of one row with the weights for each component between the max. and min. specified.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='get_neighbor_info'>A function to get the neighbor information</h2><span id='topic+get_neighbor_info'></span>

<h3>Description</h3>

<p>This fucntion gathers information of all neighborhoods of the
<code>Xu</code> observations found in <code>Xr</code>. This information is equired during
local regressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighbor_info(
  Xr,
  Xu,
  diss_method,
  Yr = NULL,
  k = NULL,
  k_diss = NULL,
  k_range = NULL,
  spike = NULL,
  pc_selection,
  return_dissimilarity,
  center,
  scale,
  gh,
  diss_usage,
  allow_parallel = FALSE,
  ...
)
</code></pre>


<h3>Details</h3>

<p>For local pca and pls distances, the local dissimilarity matrices are not
computed as it is cheaer to compute them during the local regressions.
Instead the global distances (required for later local dissimilarity matrix
computation are output)
</p>

<hr>
<h2 id='get_predictions'>Extract predictions from an object of class <code>mbl</code></h2><span id='topic+get_predictions'></span>

<h3>Description</h3>

<a href='https://www.tidyverse.org/lifecycle/#satble'><img src='figures/lifecycle-stable.svg' alt='Stable lifecycle'></a>
<p>Extract predictions from an object of class <code>mbl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_predictions(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_predictions_+3A_object">object</code></td>
<td>
<p>an object of class <code>mbl</code> as returned by <code>mbl</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table of predicted values according to either <code>k</code> or <code>k_dist</code>
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a> and Antoine Stevens
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbl">mbl</a></code>
</p>

<hr>
<h2 id='get_sample_strata'>A function to assign values to sample distribution strata</h2><span id='topic+get_sample_strata'></span>

<h3>Description</h3>

<p>for internal use only! This function takes a continuous variable,
creates n strata based on its distribution and assigns the corresponding starta
to every value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sample_strata(y, n = NULL, probs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sample_strata_+3A_y">y</code></td>
<td>
<p>a matrix of one column with the response variable.</p>
</td></tr>
<tr><td><code id="get_sample_strata_+3A_n">n</code></td>
<td>
<p>the number of strata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data table with the input <code>y</code> and the corresponding strata to
every value.
</p>

<hr>
<h2 id='get_samples_from_strata'>A function for stratified calibration/validation sampling</h2><span id='topic+get_samples_from_strata'></span>

<h3>Description</h3>

<p>for internal use only! This function selects samples
based on provided strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_samples_from_strata(
  y,
  original_order,
  strata,
  samples_per_strata,
  sampling_for = c("calibration", "validation"),
  replacement = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_samples_from_strata_+3A_original_order">original_order</code></td>
<td>
<p>a matrix of one column with the response variable.</p>
</td></tr>
<tr><td><code id="get_samples_from_strata_+3A_strata">strata</code></td>
<td>
<p>the number of strata.</p>
</td></tr>
<tr><td><code id="get_samples_from_strata_+3A_sampling_for">sampling_for</code></td>
<td>
<p>sampling to select the calibration samples (&quot;calibration&quot;)
or sampling to select the validation samples (&quot;validation&quot;).</p>
</td></tr>
<tr><td><code id="get_samples_from_strata_+3A_replacement">replacement</code></td>
<td>
<p>logical indicating if sampling with replacement must be
done.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the indices of the calibration and validation samples.
</p>

<hr>
<h2 id='get_wapls_weights'>Internal function for computing the weights of the PLS components
necessary for weighted average PLS</h2><span id='topic+get_wapls_weights'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wapls_weights(pls_model, original_x, type = "w1", new_x = NULL, pls_c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wapls_weights_+3A_pls_model">pls_model</code></td>
<td>
<p>either an object returned by the <code>pls_cv</code> function or an
object as returned by the <code>opls_get_basics</code> function which contains a pls model.</p>
</td></tr>
<tr><td><code id="get_wapls_weights_+3A_original_x">original_x</code></td>
<td>
<p>the original spectral matrix which was used for calibrating the
pls model.</p>
</td></tr>
<tr><td><code id="get_wapls_weights_+3A_type">type</code></td>
<td>
<p>type of weight to be computed. The only available option (for
the moment) is <code>"w1"</code>. See details on the <code>mbl</code> function where it
is explained how <code>"w1"</code> is computed whitin the <code>"wapls"</code>
regression.</p>
</td></tr>
<tr><td><code id="get_wapls_weights_+3A_new_x">new_x</code></td>
<td>
<p>a vector of a new spectral observation. When &quot;w1&quot; is selected, new_x
must be specified.</p>
</td></tr>
<tr><td><code id="get_wapls_weights_+3A_pls_c">pls_c</code></td>
<td>
<p>a vector of length 2 which contains both the minimum and maximum
number of PLS components for which the weights must be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_wapls_weights</code> returns a vector of weights for each PLS
component specified
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>

<hr>
<h2 id='get_weights'>Computes the weights for pls regressions</h2><span id='topic+get_weights'></span>

<h3>Description</h3>

<p>This is an internal function that computes the wights required for obtaining
each vector of pls scores. Implementation is done in C++ for improved performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_weights(X, Y, algorithm = "pls", xls_min_w = 3L, xls_max_w = 15L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_weights_+3A_x">X</code></td>
<td>
<p>a numeric matrix of spectral data.</p>
</td></tr>
<tr><td><code id="get_weights_+3A_y">Y</code></td>
<td>
<p>a matrix of one column with the response variable.</p>
</td></tr>
<tr><td><code id="get_weights_+3A_algorithm">algorithm</code></td>
<td>
<p>a character string indicating what method to use. Options are:
<code>'pls'</code> for pls (using covariance between X and Y),
<code>'mpls'</code> for modified pls (using correlation between X and Y as in
Shenk and Westerhaus, 1991; Westerhaus 2014) or
<code>'xls'</code> for extended pls (as implemented in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="get_weights_+3A_xls_min_w">xls_min_w</code></td>
<td>
<p>an integer indicating the minimum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 3 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="get_weights_+3A_xls_max_w">xls_max_w</code></td>
<td>
<p>an integer indicating the maximum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 15 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>matrix</code> of one column containing the weights.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Claudio Orellano
</p>


<h3>References</h3>

<p>Shenk, J. S., &amp; Westerhaus, M. O. (1991). Populations structuring of
near infrared spectra and modified partial least squares regression.
Crop Science, 31(6), 1548-1555.
</p>
<p>Westerhaus, M. (2014). Eastern Analytical Symposium Award for outstanding
Wachievements in near infrared spectroscopy: my contributions to
Wnear infrared spectroscopy. NIR news, 25(8), 16-20.
</p>

<hr>
<h2 id='ith_mbl_neighbor'>An iterator for local prediction data in mbl</h2><span id='topic+ith_mbl_neighbor'></span>

<h3>Description</h3>

<p>internal function. It collects only the data necessary to
execute a local prediction for the mbl function based on a list of neighbors.
Not valid for local dissmilitary (e.g. for ortho_diss(...., .local = TRUE))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ith_mbl_neighbor(
  Xr,
  Xu = NULL,
  Yr,
  Yu = NULL,
  diss_usage = "none",
  neighbor_indices,
  neighbor_diss = NULL,
  diss_xr_xr = NULL,
  group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ith_mbl_neighbor_+3A_xr">Xr</code></td>
<td>
<p>the Xr matrix in mbl.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_xu">Xu</code></td>
<td>
<p>the Xu matrix in mbl. Default <code>NULL</code>. If not provided, the
function will iterate for each <code>{Yr, Xr}</code> to get the respective neighbors.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_yr">Yr</code></td>
<td>
<p>the Yr matrix in mbl.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_yu">Yu</code></td>
<td>
<p>the Yu matrix in mbl. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_diss_usage">diss_usage</code></td>
<td>
<p>a character string indicating if the dissimilarity data
will be used as predictors (&quot;predictors&quot;) or not (&quot;none&quot;).</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_neighbor_indices">neighbor_indices</code></td>
<td>
<p>a matrix with the indices of neighbors of every Xu
found in Xr.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_neighbor_diss">neighbor_diss</code></td>
<td>
<p>a matrix with the dissimilarity socres for the neighbors
of every Xu found in Xr. This matrix is organized in the same way as
<code>neighbor_indices</code>.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_diss_xr_xr">diss_xr_xr</code></td>
<td>
<p>a dissimilarity matrix between sampes in Xr.</p>
</td></tr>
<tr><td><code id="ith_mbl_neighbor_+3A_group">group</code></td>
<td>
<p>a factor representing the group labels of Xr.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>isubset will look at the order of knn in each col of D and
re-organize the rows of x accordingly
</p>


<h3>Value</h3>

<p>an object of <code>class</code> iterator giving the following list:
</p>

<ul>
<li><p>ith_xr: the Xr data of the neighbors for the ith observation (if
<code>diss_usage = "predictors"</code>, this data is combined with the local
dissmilarity scores of the neighbors of Xu (or Xr if Xu was not provided))
</p>
</li>
<li><p>ith_yr: the Yr data of the neighbors for the ith observation
</p>
</li>
<li><p>ith_xu: the ith Xu observation (or Xr if Xu was not provided).
If <code>diss_usage = "predictors"</code>, this data is combined with the local
dissmilarity scores to its Xr neighbors.
</p>
</li>
<li><p>ith_yu: the ith Yu observation (or Yr observation if Xu was not provided).
</p>
</li>
<li><p>ith_neigh_diss: the dissimilarity scores of the neighbors for the ith
observation.
</p>
</li>
<li><p>ith_group: the group labels for ith_xr.
</p>
</li>
<li><p>n_k: the number of neighbors.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='ith_subsets_ortho_diss'>iterator for nearest neighbor subsets</h2><span id='topic+ith_subsets_ortho_diss'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ith_subsets_ortho_diss(x, xu = NULL, y, kindx, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ith_subsets_ortho_diss_+3A_x">x</code></td>
<td>
<p>a reference matrix</p>
</td></tr>
<tr><td><code id="ith_subsets_ortho_diss_+3A_xu">xu</code></td>
<td>
<p>a second matrix</p>
</td></tr>
<tr><td><code id="ith_subsets_ortho_diss_+3A_y">y</code></td>
<td>
<p>a matrix of side information</p>
</td></tr>
<tr><td><code id="ith_subsets_ortho_diss_+3A_kindx">kindx</code></td>
<td>
<p>a matrix of nearest neighbor indices</p>
</td></tr>
<tr><td><code id="ith_subsets_ortho_diss_+3A_na_rm">na_rm</code></td>
<td>
<p>logical indicating whether NAs must be removed.</p>
</td></tr>
</table>

<hr>
<h2 id='local_fit'>Local fit functions</h2><span id='topic+local_fit'></span><span id='topic+local_fit_pls'></span><span id='topic+local_fit_wapls'></span><span id='topic+local_fit_gpr'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>These functions define the way in which each local fit/prediction is done
within each iteration in the <code><a href="#topic+mbl">mbl</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_fit_pls(pls_c, modified = FALSE, max_iter = 100, tol = 1e-6)

local_fit_wapls(min_pls_c, max_pls_c, modified = FALSE,
                max_iter = 100, tol = 1e-6)

local_fit_gpr(noise_variance = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_fit_+3A_pls_c">pls_c</code></td>
<td>
<p>an integer indicating the number of pls components to be used in
the local regressions when the partial least squares (<code>local_fit_pls</code>)
method is used.</p>
</td></tr>
<tr><td><code id="local_fit_+3A_modified">modified</code></td>
<td>
<p>a logical indicating whether the modified version of the pls
algorithm (Shenk and Westerhaus, 1991 and Westerhaus, 2014). Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="local_fit_+3A_max_iter">max_iter</code></td>
<td>
<p>an integer indicating the maximum number of iterations in
case <code>tol</code> is not reached. Defaul is 100.</p>
</td></tr>
<tr><td><code id="local_fit_+3A_tol">tol</code></td>
<td>
<p>a numeric value indicating the convergence for calculating the
scores. Default is 1-e6.</p>
</td></tr>
<tr><td><code id="local_fit_+3A_min_pls_c">min_pls_c</code></td>
<td>
<p>an integer indicating the minimum number of pls components
to be used in the local regressions when the weighted average partial least
squares (<code>local_fit_wapls</code>) method is used. See details.</p>
</td></tr>
<tr><td><code id="local_fit_+3A_max_pls_c">max_pls_c</code></td>
<td>
<p>integer indicating the maximum number of pls components
to be used in the local regressions when the weighted average partial least
squares (<code>local_fit_wapls</code>) method is used. See details.</p>
</td></tr>
<tr><td><code id="local_fit_+3A_noise_variance">noise_variance</code></td>
<td>
<p>a numeric value indicating the variance of the noise
for Gaussian process local regressions (<code>local_fit_gpr</code>). Default is
0.001.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used to indicate how to fit
the regression models within the <code><a href="#topic+mbl">mbl</a></code> function.
</p>
<p>There are three possible options for performing these regressions:
</p>

<ul>
<li><p>Partial least squares (pls, <code>local_fit_pls</code>): It uses the
orthogonal scores (non-linear iterative partial least squares, nipals)
algorithm. The only parameter which needs to be optimized is the number of
pls components.
</p>
</li>
<li><p>Weighted average pls (<code>local_fit_wapls</code>): This method was
developed by Shenk et al. (1997) and it used as the regression method in the
widely known LOCAL algorithm. It uses multiple models generated by multiple
pls components (i.e. between a minimum and a maximum number of pls
components). At each local partition the final predicted value is a ensemble
(weighted average) of all the predicted values generated by the multiple pls
models. The weight for each component is calculated as follows:
</p>
\[w_{j}  =  \frac{1}{s_{1:j}\times g_{j}}\]
<p>where \(s_{1:j}\) is the root mean square of the
spectral reconstruction error of the unknown (or target) observation(s)
when a total of \(j\) pls components are used and
\(g_{j}\) is the root mean square of the squared regression
coefficients corresponding to the \(j\)th pls component (see
Shenk et al., 1997 for more details).
</p>
</li>
<li><p>Gaussian process with dot product covariance (<code>local_fit_gpr</code>):
Gaussian process regression is a probabilistic and non-parametric Bayesian
method. It is commonly described as a collection of random variables which
have a joint Gaussian distribution and it is characterized by both a mean
and a covariance function (Rasmussen and Williams, 2006). The covariance
function used in the implemented method is the dot product. The only
parameter to be taken into account in this method is the noise. In this
method, the process for predicting the response variable of a new sample
(\(y_u\)) from its predictor variables
(\(x_u\)) is carried out first by computing a prediction
vector (\(A\)). It is derived from a reference/training observations
congaing both a response vector (\(Y\)) and predictors (\(X\)) as follows:
</p>
\[A = (X  X^{T} + \sigma^2 I)^{-1} Y\]
<p>where  \(\sigma^2\) denotes the variance of the noise and \(I\) the
identity matrix (with dimensions equal to the number of observations in
\(X\)). The prediction of \(y_{u}\) is then done as follows:
</p>
\[\hat{y}_{u} = (x_{u}x_{u}^{T}) A\]

</li></ul>

<p>The <code>modified</code> argument in the pls methods (<code>local_fit_pls()</code>
and <code>local_fit_wapls()</code>) is used to indicate if
a modified version of the pls algorithm (modified pls or mpls) is to be used.
The modified pls was proposed Shenk and Westerhaus
(1991, see also Westerhaus, 2014) and it differs from the standard pls method
in the way the weights of the predictors (used to compute the matrix of
scores) are obtained. While pls uses the covariance between  response(s)
and predictors (and later their deflated versions corresponding at each pls
component iteration) to obtain these weights, the modified pls uses the
correlation as weights. The authors indicate that by using correlation,
a larger potion of the response variable(s) can be explained.
</p>


<h3>Value</h3>

<p>An object of class <code>local_fit</code> mirroring the input arguments.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>References</h3>

<p>Shenk, J. S., &amp; Westerhaus, M. O. 1991. Populations structuring of
near infrared spectra and modified partial least squares regression.
Crop Science, 31(6), 1548-1555.
</p>
<p>Shenk, J., Westerhaus, M., and Berzaghi, P. 1997. Investigation of a LOCAL
calibration procedure for near infrared instruments. Journal of Near Infrared
Spectroscopy, 5, 223-232.
</p>
<p>Rasmussen, C.E., Williams, C.K. Gaussian Processes for Machine Learning.
Massachusetts Institute of Technology: MIT-Press, 2006.
</p>
<p>Westerhaus, M. 2014. Eastern Analytical Symposium Award for outstanding
Wachievements in near infrared spectroscopy: my contributions to
Wnear infrared spectroscopy. NIR news, 25(8), 16-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbl">mbl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>local_fit_wapls(min_pls_c = 3, max_pls_c = 12)
</code></pre>

<hr>
<h2 id='local_ortho_diss'>local ortho dissimilarity matrices initialized by a global
dissimilarity matrix</h2><span id='topic+local_ortho_diss'></span>

<h3>Description</h3>

<p>internal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_ortho_diss(
  k_index_matrix,
  Xr,
  Yr,
  Xu,
  diss_method,
  pc_selection,
  center,
  scale,
  allow_parallel,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_ortho_diss_+3A_k_index_matrix">k_index_matrix</code></td>
<td>
<p>a matrix of nearest neighnbor indices</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_xr">Xr</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_yr">Yr</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_xu">Xu</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_diss_method">diss_method</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_pc_selection">pc_selection</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_center">center</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
<tr><td><code id="local_ortho_diss_+3A_scale">scale</code></td>
<td>
<p>argument passed to ortho_projection</p>
</td></tr>
</table>

<hr>
<h2 id='mbl'>A function for memory-based learning (mbl)</h2><span id='topic+mbl'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function is implemented for memory-based learning (a.k.a.
instance-based learning or local regression) which is a non-linear lazy
learning approach for predicting a given response variable from a set of
predictor variables. For each observation in a prediction set, a specific
local regression is carried out based on a subset of similar observations
(nearest neighbors) selected from a reference set. The local model is
then used to predict the response value of the target (prediction)
observation. Therefore this function does not yield a global
regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbl(Xr, Yr, Xu, Yu = NULL, k, k_diss, k_range, spike = NULL,
    method = local_fit_wapls(min_pls_c = 3, max_pls_c = min(dim(Xr), 15)),
    diss_method = "pca", diss_usage = "predictors", gh = TRUE,
    pc_selection = list(method = "opc", value = min(dim(Xr), 40)),
    control = mbl_control(), group = NULL, center = TRUE, scale = FALSE,
    verbose = TRUE, documentation = character(), seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbl_+3A_xr">Xr</code></td>
<td>
<p>a matrix of predictor variables of the reference data
(observations in rows and variables in columns).</p>
</td></tr>
<tr><td><code id="mbl_+3A_yr">Yr</code></td>
<td>
<p>a numeric matrix of one column containing the values of the
response variable corresponding to the reference data.</p>
</td></tr>
<tr><td><code id="mbl_+3A_xu">Xu</code></td>
<td>
<p>a matrix of predictor variables of the data to be predicted
(observations in rows and variables in columns).</p>
</td></tr>
<tr><td><code id="mbl_+3A_yu">Yu</code></td>
<td>
<p>an optional matrix of one column containing the values of the
response variable corresponding to the data to be predicted. Default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="mbl_+3A_k">k</code></td>
<td>
<p>a vector of integers specifying the sequence of k-nearest
neighbors to be tested. Either <code>k</code> or <code>k_diss</code> must be specified.
This vector will be automatically sorted into ascending order. If
non-integer numbers are passed, they will be coerced to the next upper
integers.</p>
</td></tr>
<tr><td><code id="mbl_+3A_k_diss">k_diss</code></td>
<td>
<p>a numeric vector specifying the sequence of dissimilarity
thresholds to be tested for the selection of the nearest neighbors found in
<code>Xr</code> around each observation in <code>Xu</code>. These thresholds depend on
the corresponding dissimilarity measure specified in the object passed to
<code>control</code>. Either <code>k</code> or <code>k_diss</code> must be specified.</p>
</td></tr>
<tr><td><code id="mbl_+3A_k_range">k_range</code></td>
<td>
<p>an integer vector of length 2 which specifies the minimum
(first value) and the maximum (second value) number of neighbors to be
retained when the <code>k_diss</code> is given.</p>
</td></tr>
<tr><td><code id="mbl_+3A_spike">spike</code></td>
<td>
<p>an integer vector (with positive and/or negative values) indicating
the indices of observations in <code>Xr</code> that must be either be forced into
or avoided in the neighborhoods of every <code>Xu</code> observation. Default is
<code>NULL</code> (i.e. no observations are forced or avoided). Note
that this argument is not intended for increasing or reducing the neighborhood
size which is only controlled by <code>k</code> or <code>k_diss</code> and <code>k_range</code>.
By forcing observations into the neighborhood, some of the farthest
observations may be forced out of the neighborhood. In contrast, by avoiding
observations in the neighborhood,  some of farthest
observations may be included into the neighborhood. See details.</p>
</td></tr>
<tr><td><code id="mbl_+3A_method">method</code></td>
<td>
<p>an object of class <code><a href="#topic+local_fit">local_fit</a></code> which indicates the
type of regression to conduct at each local segment as well as additional
parameters affecting this regression. See <code><a href="#topic+local_fit">local_fit</a></code> function.</p>
</td></tr>
<tr><td><code id="mbl_+3A_diss_method">diss_method</code></td>
<td>
<p>a character string indicating the spectral dissimilarity
metric to be used in the selection of the nearest neighbors of each
observation. Options are:
</p>

<ul>
<li><p><code>"pca"</code> (Default): Mahalanobis distance
computed on the matrix of scores of a Principal Component (PC)
projection of <code>Xr</code> and <code>Xu</code>. PC projection is done using the
singular value decomposition (SVD) algorithm.
See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"pca.nipals"</code>: Mahalanobis distance
computed on the matrix of scores of a Principal Component (PC)
projection of <code>Xr</code> and <code>Xu</code>. PC projection is done using the
non-linear iterative partial least squares (nipals) algorithm.
See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"pls"</code>: Mahalanobis distance
computed on the matrix of scores of a partial least squares projection
of <code>Xr</code> and <code>Xu</code>. In this case, <code>Yr</code> is always
required. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"cor"</code>: correlation coefficient
between observations. See <code><a href="#topic+cor_diss">cor_diss</a></code> function.
</p>
</li>
<li><p><code>"euclid"</code>: Euclidean distance
between observations. See <code><a href="#topic+f_diss">f_diss</a></code> function.
</p>
</li>
<li><p><code>"cosine"</code>: Cosine distance
between observations. See <code><a href="#topic+f_diss">f_diss</a></code> function.
</p>
</li>
<li><p><code>"sid"</code>: spectral information divergence between
observations. See <code><a href="#topic+sid">sid</a></code> function.
</p>
</li></ul>

<p>Alternatively, a matrix of dissimilarities can also be passed to this
argument. This matrix is supposed to be a user-defined matrix
representing the dissimilarities between observations in <code>Xr</code> and
<code>Xu</code>. When <code>diss_usage = "predictors"</code>, this matrix must be squared
(derived from a matrix of the form <code>rbind(Xr, Xu)</code>) for which the
diagonal values are zeros (since the dissimilarity between an object and
itself must be 0). On the other hand, if <code>diss_usage</code> is set to either
<code>"weights"</code> or <code>"none"</code>, it must be a matrix representing the
dissimilarity of each observation in <code>Xu</code> to each observation in
<code>Xr</code>. The number of columns of the input matrix must be equal to the
number of rows in <code>Xu</code> and the number of rows equal to the number of
rows in <code>Xr</code>.</p>
</td></tr>
<tr><td><code id="mbl_+3A_diss_usage">diss_usage</code></td>
<td>
<p>a character string specifying how the dissimilarity
information shall be used. The possible options are: <code>"predictors"</code>,
<code>"weights"</code> and <code>"none"</code> (see details below).
Default is <code>"predictors"</code>.</p>
</td></tr>
<tr><td><code id="mbl_+3A_gh">gh</code></td>
<td>
<p>a logical indicating if the global Mahalanobis distance (in the pls
score space) between each observation and the pls mean (centre) must be
computed. This metric is known as the GH distance in the literature. Note
that this computation is based on the number of pls components determined by
using the <code>pc_selection</code> argument. See details.</p>
</td></tr>
<tr><td><code id="mbl_+3A_pc_selection">pc_selection</code></td>
<td>
<p>a list of length 2 used for the computation of GH (if
<code>gh = TRUE</code>) as well as in the computation of the dissimilarity methods
based on <code><a href="#topic+ortho_diss">ortho_diss</a></code> (i.e. when <code>diss_method</code> is one of:
<code>"pca"</code>, <code>"pca.nipals"</code> or <code>"pls"</code>) or when <code>gh = TRUE</code>.
This argument is used for optimizing the number of components (principal
components or pls factors) to be retained for dissimilarity/distance
computation purposes only (i.e not for regression).
This list must contain two elements in the following order:
<code>method</code> (a character indicating the method for selecting the number of
components) and <code>value</code> (a numerical value that complements the selected
method). The methods available are:
</p>

<ul>
<li><p><code>"opc"</code>: optimized principal component selection based
on Ramirez-Lopez et al. (2013a, 2013b). The optimal number of
components (of set of observations) is the one for which its distance
matrix minimizes the differences between the <code>Yr</code> value of each
observation and the <code>Yr</code> value of its closest observation. In
this case <code>value</code> must be a value (larger than 0 and
below the minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code>
combined) indicating the maximum
number of principal components to be tested. See the
<code><a href="#topic+ortho_projection">ortho_projection</a></code> function for more details.
</p>
</li>
<li><p><code>"cumvar"</code>: selection of the principal components based
on a given cumulative amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of cumulative variance that the
combination of retained components should explain.
</p>
</li>
<li><p><code>"var"</code>: selection of the principal components based
on a given amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of variance that a single component
should explain in order to be retained.
</p>
</li>
<li><p><code>"manual"</code>: for manually specifying a fix number of
principal components. In this case, <code>value</code> must be a value
(larger than 0 and below the minimum dimension of <code>Xr</code> or
<code>Xr</code> and <code>Xu</code> combined).
indicating the minimum amount of variance that a component should
explain in order to be retained.
</p>
</li></ul>

<p>The list
<code>list(method = "opc", value = min(dim(Xr), 40))</code> is the default.
Optionally, the <code>pc_selection</code> argument admits <code>"opc"</code> or
<code>"cumvar"</code> or <code>"var"</code> or <code>"manual"</code> as a single character
string. In such a case the default <code>"value"</code> when either <code>"opc"</code> or
<code>"manual"</code> are used is 40. When <code>"cumvar"</code> is used the default
<code>"value"</code> is set to 0.99 and when <code>"var"</code> is used, the default
<code>"value"</code> is set to 0.01.</p>
</td></tr>
<tr><td><code id="mbl_+3A_control">control</code></td>
<td>
<p>a list created with the <code><a href="#topic+mbl_control">mbl_control</a></code> function
which contains additional parameters that control some few aspects of the
<code>mbl</code> function (cross-validation, parameter tuning, etc).
The default list is as returned by <code>mbl_control()</code>.
See the <code><a href="#topic+mbl_control">mbl_control</a></code> function for more details.</p>
</td></tr>
<tr><td><code id="mbl_+3A_group">group</code></td>
<td>
<p>an optional factor (or character vector vector
that can be coerced to <code><a href="base.html#topic+factor">factor</a></code> by <code>as.factor</code>) that
assigns a group/class label to each observation in <code>Xr</code>
(e.g. groups can be given by spectra collected from the same batch of
measurements, from the same observation, from observations with very similar
origin, etc). This is taken into account for internal leave-group-out cross
validation for pls tuning (factor optimization) to avoid pseudo-replication.
When one observation is selected for cross-validation, all observations of
the same group are removed together and assigned to validation. The length
of the vector must be equal to the number of observations in the
reference/training set (i.e. <code>nrow(Xr)</code>). See details.</p>
</td></tr>
<tr><td><code id="mbl_+3A_center">center</code></td>
<td>
<p>a logical if the predictor variables must be centred at each
local segment (before regression). In addition, if <code>TRUE</code>, <code>Xr</code>
and <code>Xu</code> will be centred for  dissimilarity computations.</p>
</td></tr>
<tr><td><code id="mbl_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if the predictor variables must be scaled
to unit variance at each local segment (before regression). In addition, if
<code>TRUE</code>, <code>Xr</code> and <code>Xu</code> will be scaled for  dissimilarity
computations.</p>
</td></tr>
<tr><td><code id="mbl_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating whether or not to print a progress bar
for each observation to be predicted. Default is <code>TRUE</code>. Note: In case
parallel processing is used, these progress bars will not be printed.</p>
</td></tr>
<tr><td><code id="mbl_+3A_documentation">documentation</code></td>
<td>
<p>an optional character string that can be used to
describe anything related to the <code>mbl</code> call (e.g. description of the
input data). Default: <code>character()</code>. NOTE: his is an experimental
argument.</p>
</td></tr>
<tr><td><code id="mbl_+3A_seed">seed</code></td>
<td>
<p>an integer value containing the random number generator (RNG)
state for random number generation. This argument can be used for
reproducibility purposes (for random sampling) in the cross-validation
results. Default is <code>NULL</code>, i.e. no RNG is applied.</p>
</td></tr>
<tr><td><code id="mbl_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code><a href="#topic+dissimilarity">dissimilarity</a></code>
function. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>spike</code> can be used to indicate what reference observations
in <code>Xr</code> must be kept in the neighborhood of every single <code>Xu</code>
observation. If a vector of length \(m\) is passed to this argument,
this means that the \(m\) original neighbors with the largest
dissimilarities to the target observations will be forced out of the
neighborhood. Spiking might be useful in cases where
some reference observations are known to be somehow related to the ones in
<code>Xu</code> and therefore might be relevant for fitting the local models. See
Guerrero et al. (2010) for an example on the benefits of spiking.
</p>
<p>The <code>mbl</code> function uses the <code><a href="#topic+dissimilarity">dissimilarity</a></code> function to
compute the dissimilarities between <code>Xr</code> and <code>Xu</code>. The dissimilarity
method to be used is specified in the <code>diss_method</code> argument.
Arguments to <code><a href="#topic+dissimilarity">dissimilarity</a></code> as well as further arguments to the
functions used inside <code><a href="#topic+dissimilarity">dissimilarity</a></code>
(i.e. <code><a href="#topic+ortho_diss">ortho_diss</a></code> <code><a href="#topic+cor_diss">cor_diss</a></code> <code><a href="#topic+f_diss">f_diss</a></code>
<code><a href="#topic+sid">sid</a></code>) can be passed to those functions by using <code>...</code>.
</p>
<p>The <code>diss_usage</code> argument is used to specify whether the dissimilarity
information must be used within the local regressions and, if so, how.
When <code>diss_usage = "predictors"</code> the local (square symmetric)
dissimilarity matrix corresponding the selected neighborhood is used as
source of additional predictors (i.e the columns of this local matrix are
treated as predictor variables). In some cases this results in an improvement
of the prediction performance (Ramirez-Lopez et al., 2013a).
If <code>diss_usage = "weights"</code>, the neighbors of the query point
(\(xu_{j}\)) are weighted according to their dissimilarity to
\(xu_{j}\) before carrying out each local regression. The following
tricubic function (Cleveland and Delvin, 1988; Naes et al., 1990) is used for
computing the final weights based on the measured dissimilarities:
</p>
\[W_{j}  =  (1 - v^{3})^{3}\]
<p>where if \({xr_{i} \in }\) neighbors of \(xu_{j}\):
</p>
\[v_{j}(xu_{j})  =  d(xr_{i}, xu_{j})\]
<p>otherwise:
</p>
\[v_{j}(xu_{j})  =  0\]
<p>In the above formulas \(d(xr_{i}, xu_{j})\) represents the
dissimilarity between the query point and each object in \(Xr\).
When <code>diss_usage = "none"</code> is chosen the dissimilarity information is
not used.
</p>
<p>The global Mahalanobis distance (a.k.a GH) is computed based on the scores
of a pls projection. A pls projection model is built with for <code>{Yr}, {Xr}</code>
and this model is used to obtain the pls scores of the <code>Xu</code>
observations. The Mahalanobis distance between each <code>Xu</code> observation in
(the pls space) and the centre of <code>Xr</code> is then computed. The number of
pls components is optimized based on the parameters passed to the
<code>pc_selection</code> argument. In addition, the <code>mbl</code> function also
reports the GH distance for the observations in <code>Xr</code>.
</p>
<p>Some aspects of the mbl process, such as the type of internal validation,
parameter tuning, what extra objects to return, permission for parallel
execution, prediction limits, etc, can be specified by using the
<code><a href="#topic+mbl_control">mbl_control</a></code> function.
</p>
<p>By using the <code>group</code> argument one can specify groups of observations
that have something in common (e.g. observations with very similar origin).
The purpose of <code>group</code> is to avoid biased cross-validation results due
to pseudo-replication. This argument allows to select calibration points
that are independent from the validation ones. In this regard, when
<code>validation_type = "local_cv"</code> (used in <code><a href="#topic+mbl_control">mbl_control</a></code>
function), then the <code>p</code> argument refers to the percentage of groups of
observations (rather than single observations) to be retained in each
sampling iteration at each local segment.
</p>


<h3>Value</h3>

<p>a <code>list</code> of class <code>mbl</code> with the following components
(sorted either by <code>k</code> or <code>k_diss</code>):
</p>

<ul>
<li><p><code>call</code>: the call to mbl.
</p>
</li>
<li><p><code>cntrl_param</code>: the list with the control parameters passed to
control.
</p>
</li>
<li><p><code>Xu_neighbors</code>: a list containing two elements: a matrix of
<code>Xr</code> indices corresponding to the neighbors of <code>Xu</code> and a matrix
of dissimilarities between each <code>Xu</code> observation and its corresponding
neighbor in <code>Xr</code>.
</p>
</li>
<li><p><code>dissimilarities</code>: a list with the method used to obtain the
dissimilarity matrices and the dissimilarity matrix corresponding to
\(D(Xr, Xu)\). This object is returned only if the
<code>return_dissimilarity</code> argument in the <code>control</code> list was set
to <code>TRUE</code>.
</p>
</li>
<li><p><code>n_predictions</code>: the total number of observations predicted.
</p>
</li>
<li><p><code>gh</code>: if <code>gh = TRUE</code>, a list containing the global
Mahalanobis distance values for the observations in <code>Xr</code> and <code>Xu</code>
as well as the results of the global pls projection object used to obtain
the GH values.
</p>
</li>
<li><p><code>validation_results</code>: a list of validation results for
&quot;local cross validation&quot; (returned if the <code>validation_type</code> in
<code>control</code> list was set to <code>"local_cv"</code>),
&quot;nearest neighbor validation&quot; (returned if the <code>validation_type</code>
in <code>control</code> list was set to <code>"NNv"</code>) and
&quot;Yu prediction statistics&quot; (returned  if <code>Yu</code> was supplied).&ldquo;
</p>
</li>
<li><p><code>results</code>: a list of data tables containing the results of the
predictions for each either <code>k</code> or <code>k_diss</code>. Each data table
contains the following columns:
</p>

<ul>
<li><p><code>o_index</code>: The index of the predicted observation.
</p>
</li>
<li><p><code>k_diss</code>: This column is only output if the <code>k_diss</code>
argument is used. It indicates the corresponding dissimilarity threshold
for selecting the neighbors.
</p>
</li>
<li><p><code>k_original</code>: This column is only output if the <code>k_diss</code>
argument is used. It indicates the number of neighbors that were originally
found when the given dissimilarity threshold is used.
</p>
</li>
<li><p><code>k</code>: This column indicates the final number of neighbors
used.
</p>
</li>
<li><p><code>npls</code>: This column is only output if the <code>pls</code>
regression method was used. It indicates the final number of pls
components used.
</p>
</li>
<li><p><code>min_pls</code>: This column is only output if <code>wapls</code>
regression method was used. It indicates the final number of minimum pls
components used. If no optimization was set, it retrieves the original
minimum pls components passed to the <code>method</code> argument.
</p>
</li>
<li><p><code>max_pls</code>: This column is only output if the <code>wapls</code>
regression method was used. It indicates the final number of maximum pls
components used. If no optimization was set, it retrieves the original
maximum pls components passed to the <code>method</code> argument.
</p>
</li>
<li><p><code>yu_obs</code>: The input values given in <code>Yu</code> (the response
variable corresponding to the data to be predicted). If <code>Yu = NULL</code>,
then <code>NA</code>s are retrieved.
</p>
</li>
<li><p><code>pred</code>: The predicted Yu values.
</p>
</li>
<li><p><code>yr_min_obs</code>: The minimum reference value (of the response
variable) in the neighborhood.
</p>
</li>
<li><p><code>yr_max_obs</code>: The maximum reference value (of the response
variable) in the neighborhood.
</p>
</li>
<li><p><code>index_nearest_in_Xr</code>: The index of the nearest neighbor found
in <code>Xr</code>.
</p>
</li>
<li><p><code>index_farthest_in_Xr</code>: The index of the farthest neighbor
found in <code>Xr</code>.
</p>
</li>
<li><p><code>y_nearest</code>: The reference value (<code>Yr</code>) corresponding to
the nearest neighbor found in <code>Xr</code>.
</p>
</li>
<li><p><code>y_nearest_pred</code>: This column is only output if the
validation method in the object passed to <code>control</code> was set to
<code>"NNv"</code>. It represents the predicted value of the nearest neighbor
observation found in <code>Xr</code>. This prediction come from model fitted
with the remaining observations in the neighborhood of the target
observation in <code>Xu</code>.
</p>
</li>
<li><p><code>loc_rmse_cv</code>: This column is only output if the validation
method in the object passed to <code>control</code> was set to
<code>'local_cv'</code>. It represents the RMSE of the cross-validation
computed for the neighborhood of the target observation in <code>Xu</code>.
</p>
</li>
<li><p><code>loc_st_rmse_cv</code>: This column is only output if the
validation method in the object passed to <code>control</code> was set to
<code>'local_cv'</code>. It represents the standardized RMSE of the
cross-validation computed for the neighborhood of the target observation
in <code>Xu</code>.
</p>
</li>
<li><p><code>dist_nearest</code>: The distance to the nearest neighbor.
</p>
</li>
<li><p><code>dist_farthest</code>: The distance to the farthest neighbor.
</p>
</li>
<li><p><code>loc_n_components</code>: This column is only output if the
dissimilarity method used is one of <code>"pca"</code>, <code>"pca.nipals"</code> or
<code>"pls"</code> and in addition the dissimilarities are requested to be
computed locally by passing <code>.local = TRUE</code> to the <code>mbl</code>
function.
See <code>.local</code> argument in the <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li></ul>

</li>
<li><p><code>seed</code>: a value mirroring the one passed to seed.
</p>
</li>
<li><p><code>documentation</code>: a character string mirroring the one provided
in the <code>documentation</code> argument.
</p>
</li></ul>

<p>When the <code>k_diss</code> argument is used, the printed results show a table
with a column named '<code>p_bounded</code>. It represents the percentage of
observations for which the neighbors selected by the given dissimilarity
threshold were outside the boundaries specified in the <code>k_range</code>
argument.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
and Antoine Stevens
</p>


<h3>References</h3>

<p>Cleveland, W. S., and Devlin, S. J. 1988. Locally weighted regression: an
approach to regression analysis by local fitting. Journal of the American
Statistical Association, 83, 596-610.
</p>
<p>Guerrero, C., Zornoza, R., Gmez, I., Mataix-Beneyto, J. 2010. Spiking of
NIR regional models using observations from target sites: Effect of model
size on prediction accuracy. Geoderma, 158(1-2), 66-77.
</p>
<p>Naes, T., Isaksson, T., Kowalski, B. 1990. Locally weighted regression and
scatter correction for near-infrared reflectance data. Analytical Chemistry
62, 664-673.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196,
268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R., Dematte,
J. A. M.,  Scholten, T. 2013b. Distance and similarity-search metrics for
use with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>
<p>Rasmussen, C.E., Williams, C.K. Gaussian Processes for Machine Learning.
Massachusetts Institute of Technology: MIT-Press, 2006.
</p>
<p>Shenk, J., Westerhaus, M., and Berzaghi, P. 1997. Investigation of a LOCAL
calibration procedure for near infrared instruments. Journal of Near
Infrared Spectroscopy, 5, 223-232.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbl_control">mbl_control</a></code>, <code><a href="#topic+f_diss">f_diss</a></code>,
<code><a href="#topic+cor_diss">cor_diss</a></code>, <code><a href="#topic+sid">sid</a></code>, <code><a href="#topic+ortho_diss">ortho_diss</a></code>,
<code><a href="#topic+search_neighbors">search_neighbors</a></code>,  <code><a href="#topic+local_fit">local_fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)
data(NIRsoil)

# Proprocess the data using detrend plus first derivative with Savitzky and
# Golay smoothing filter
sg_det &lt;- savitzkyGolay(
  detrend(NIRsoil$spc,
    wav = as.numeric(colnames(NIRsoil$spc))
  ),
  m = 1,
  p = 1,
  w = 7
)

NIRsoil$spc_pr &lt;- sg_det

# split into training and testing sets
test_x &lt;- NIRsoil$spc_pr[NIRsoil$train == 0 &amp; !is.na(NIRsoil$CEC), ]
test_y &lt;- NIRsoil$CEC[NIRsoil$train == 0 &amp; !is.na(NIRsoil$CEC)]

train_y &lt;- NIRsoil$CEC[NIRsoil$train == 1 &amp; !is.na(NIRsoil$CEC)]
train_x &lt;- NIRsoil$spc_pr[NIRsoil$train == 1 &amp; !is.na(NIRsoil$CEC), ]

# Example 1
# A mbl implemented in Ramirez-Lopez et al. (2013,
# the spectrum-based learner)
# Example 1.1
# An exmaple where Yu is supposed to be unknown, but the Xu
# (spectral variables) are known
my_control &lt;- mbl_control(validation_type = "NNv")

## The neighborhood sizes to test
ks &lt;- seq(40, 140, by = 20)

sbl &lt;- mbl(
  Xr = train_x,
  Yr = train_y,
  Xu = test_x,
  k = ks,
  method = local_fit_gpr(),
  control = my_control,
  scale = TRUE
)
sbl
plot(sbl)
get_predictions(sbl)

# Example 1.2
# If Yu is actually known...
sbl_2 &lt;- mbl(
  Xr = train_x,
  Yr = train_y,
  Xu = test_x,
  Yu = test_y,
  k = ks,
  method = local_fit_gpr(),
  control = my_control
)
sbl_2
plot(sbl_2)

# Example 2
# the LOCAL algorithm (Shenk et al., 1997)
local_algorithm &lt;- mbl(
  Xr = train_x,
  Yr = train_y,
  Xu = test_x,
  Yu = test_y,
  k = ks,
  method = local_fit_wapls(min_pls_c = 3, max_pls_c = 15),
  diss_method = "cor",
  diss_usage = "none",
  control = my_control
)
local_algorithm
plot(local_algorithm)

# Example 3
# A variation of the LOCAL algorithm (using the optimized pc
# dissmilarity matrix) and dissimilarity matrix as source of
# additional preditors
local_algorithm_2 &lt;- mbl(
  Xr = train_x,
  Yr = train_y,
  Xu = test_x,
  Yu = test_y,
  k = ks,
  method = local_fit_wapls(min_pls_c = 3, max_pls_c = 15),
  diss_method = "pca",
  diss_usage = "predictors",
  control = my_control
)
local_algorithm_2
plot(local_algorithm_2)

# Example 4
# Running the mbl function in parallel with example 2

n_cores &lt;- 2

if (parallel::detectCores() &lt; 2) {
  n_cores &lt;- 1
}

# Alternatively:
# n_cores &lt;- parallel::detectCores() - 1
# if (n_cores == 0) {
#  n_cores &lt;- 1
# }

library(doParallel)
clust &lt;- makeCluster(n_cores)
registerDoParallel(clust)

# Alernatively:
# library(doSNOW)
# clust &lt;- makeCluster(n_cores, type = "SOCK")
# registerDoSNOW(clust)
# getDoParWorkers()

local_algorithm_par &lt;- mbl(
  Xr = train_x,
  Yr = train_y,
  Xu = test_x,
  Yu = test_y,
  k = ks,
  method = local_fit_wapls(min_pls_c = 3, max_pls_c = 15),
  diss_method = "cor",
  diss_usage = "none",
  control = my_control
)
local_algorithm_par

registerDoSEQ()
try(stopCluster(clust))

# Example 5
# Using local pls distances
with_local_diss &lt;- mbl(
  Xr = train_x,
  Yr = train_y,
  Xu = test_x,
  Yu = test_y,
  k = ks,
  method = local_fit_wapls(min_pls_c = 3, max_pls_c = 15),
  diss_method = "pls",
  diss_usage = "predictors",
  control = my_control,
  .local = TRUE,
  pre_k = 150,
)
with_local_diss
plot(with_local_diss)

</code></pre>

<hr>
<h2 id='mbl_control'>A function that controls some few aspects of the memory-based learning
process in the <code>mbl</code> function</h2><span id='topic+mbl_control'></span>

<h3>Description</h3>

<a href='https://www.tidyverse.org/lifecycle/#experimental'><img src='figures/lifecycle-maturing.svg' alt='Experimental lifecycle'></a>
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function is used to further control some aspects of the memory-based
learning process in the <code>mbl</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbl_control(return_dissimilarity = FALSE,
            validation_type = c("NNv", "local_cv"),
            tune_locally = TRUE,
            number = 10,
            p = 0.75,
            range_prediction_limits = TRUE,
            progress = TRUE,
            allow_parallel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbl_control_+3A_return_dissimilarity">return_dissimilarity</code></td>
<td>
<p>a logical indicating if the dissimilarity matrix
between <code>Xr</code> and <code>Xu</code> must be returned.</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_validation_type">validation_type</code></td>
<td>
<p>a character vector which indicates the (internal) validation
method(s) to be used for assessing the global performance of the local models.
Possible options are: <code>"NNv"</code> and <code>"local_cv"</code>. Alternatively
<code>"none"</code> can be used when cross-validation is not required (see details
below).</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_tune_locally">tune_locally</code></td>
<td>
<p>a logical. It only applies when
<code>validation_type = "local_cv"</code> and &quot;pls&quot; or &quot;wapls&quot; fitting algorithms are
used.  If <code>TRUE</code>, the the parameters of the local pls-based models
(i.e. pls factors for the &quot;pls&quot; method and minimum and maximum pls factors
for the &quot;wapls&quot; method). Default is #' <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_number">number</code></td>
<td>
<p>an integer indicating the number of sampling iterations at
each local segment when <code>"local_cv"</code> is selected in the
<code>validation_type</code> argument. Default is 10.</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_p">p</code></td>
<td>
<p>a numeric value indicating the percentage of observations to be retained
at each sampling iteration at each local segment when <code>"local_cv"</code>
is selected in the <code>validation_type</code> argument. Default is 0.75 %.</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_range_prediction_limits">range_prediction_limits</code></td>
<td>
<p>a logical. It indicates whether the prediction
limits at each local regression are determined by the range of the response
variable within each neighborhood. When the predicted value is outside
this range, it will be automatically replaced with the value of the nearest
range value. If <code>FALSE</code>, no prediction limits are imposed.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_progress">progress</code></td>
<td>
<p>a logical indicating whether or not to print a progress bar
for each observation to be predicted. Default is <code>TRUE</code>. Note: In case
parallel processing is used, these progress bars will not be printed.</p>
</td></tr>
<tr><td><code id="mbl_control_+3A_allow_parallel">allow_parallel</code></td>
<td>
<p>a logical indicating if parallel execution is allowed.
If <code>TRUE</code>, this parallelism is applied to the loop in <code><a href="#topic+mbl">mbl</a></code>
in which each iteration takes care of a single observation in <code>Xu</code>. The
parallelization of this for loop is implemented using the
<a href="foreach.html#topic+foreach">foreach</a> function of the <code><a href="foreach.html#topic+foreach">foreach</a></code> package.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validation methods available for assessing the predictive performance of
the memory-based learning method used are described as follows:
</p>

<ul>
<li><p>Leave-nearest-neighbor-out cross-validation (<code>"NNv"</code>): From
the group of neighbors of each observation to be predicted, the nearest observation
(i.e. the most similar observation) is excluded and then a local model is fitted
using the remaining neighbors. This model is then used to predict the value
of the target response variable of the nearest observation. These predicted
values are finally cross validated with the actual values (See Ramirez-Lopez
et al. (2013a) for additional details). This method is faster than
<code>"local_cv"</code>.
</p>
</li>
<li><p>Local leave-group-out cross-validation (<code>"local_cv"</code>): The
group of neighbors of each observation to be predicted is partitioned into
different equal size subsets. Each partition is selected based on a
stratified random sampling which takes into account the values of the
response variable of the corresponding set of neighbors. The selected
local subset is used as local validation subset and the remaining observations
are used for fitting a model. This model is used to predict the target
response variable values of the local validation subset and the local root
mean square error is computed. This process is repeated \(m\) times and
the final local error is computed as the average of the local root mean
square error of all the \(m\) iterations. In the <code>mbl</code> function
\(m\) is controlled by the <code>number</code> argument and the size of the
subsets is controlled by the <code>p</code> argument which indicates the
percentage of observations to be selected from the subset of nearest neighbours.
The global error of the predictions is computed as the average of the local
root mean square errors.
</p>
</li>
<li><p>No validation (<code>"none"</code>): No validation is carried out.
If <code>"none"</code> is seleceted along with <code>"NNv"</code> and/or
<code>"local_cv"</code>, then it will be ignored and the respective
validation(s) will be carried out.
</p>
</li></ul>



<h3>Value</h3>

<p>a <code>list</code> mirroring the specified parameters
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>


<h3>References</h3>

<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196, 268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R., Dematte,
J. A. M.,  Scholten, T. 2013b. Distance and similarity-search metrics for
use with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f_diss">f_diss</a></code>, <code><a href="#topic+cor_diss">cor_diss</a></code>, <code><a href="#topic+sid">sid</a></code>,
<code><a href="#topic+ortho_diss">ortho_diss</a></code>, <code><a href="#topic+mbl">mbl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A control list with the default parameters
mbl_control()
</code></pre>

<hr>
<h2 id='moving_cor_diss'>Moving/rolling correlation distance of two matrices</h2><span id='topic+moving_cor_diss'></span>

<h3>Description</h3>

<p>Computes a moving window correlation distance between two data matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_cor_diss(X,Y,w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moving_cor_diss_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="moving_cor_diss_+3A_y">Y</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="moving_cor_diss_+3A_w">w</code></td>
<td>
<p>window size (must be odd)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of correlation distance
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>

<hr>
<h2 id='opls'>orthogonal scores algorithn of partial leat squares (opls)</h2><span id='topic+opls'></span>

<h3>Description</h3>

<p>Computes orthogonal socres partial least squares (opls)
regressions with the NIPALS algorithm. It allows multiple response variables.
It does not return the variance information of the components. NOTE: For
internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opls(X, 
     Y, 
     ncomp, 
     scale, 
     maxiter, 
     tol, 
     algorithm = "pls", 
     xls_min_w = 3, 
     xls_max_w = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opls_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="opls_+3A_y">Y</code></td>
<td>
<p>a matrix of either a single or multiple response variables.</p>
</td></tr>
<tr><td><code id="opls_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of pls components.</p>
</td></tr>
<tr><td><code id="opls_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether <code>X</code> must be scaled.</p>
</td></tr>
<tr><td><code id="opls_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="opls_+3A_tol">tol</code></td>
<td>
<p>limit for convergence of the algorithm in the nipals algorithm.</p>
</td></tr>
<tr><td><code id="opls_+3A_algorithm">algorithm</code></td>
<td>
<p>(for weights computation) a character string indicating
what method to use. Options are:
<code>'pls'</code> for pls (using covariance between X and Y),
<code>'mpls'</code> for modified pls (using correlation between X and Y) or
<code>'xls'</code> for extended pls (as implemented in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_+3A_xls_min_w">xls_min_w</code></td>
<td>
<p>(for weights computation) an integer indicating the minimum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 3 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_+3A_xls_max_w">xls_max_w</code></td>
<td>
<p>(for weights computation) an integer indicating the maximum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 15 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>coefficients</code>: the matrix of regression coefficients.
</p>
</li>
<li><p><code>bo</code>: a matrix of one row containing the intercepts for each component.
</p>
</li>
<li><p><code>scores</code>: the matrix of scores.
</p>
</li>
<li><p><code>X_loadings</code>: the matrix of X loadings.
</p>
</li>
<li><p><code>Y_loadings</code>: the matrix of Y loadings.
</p>
</li>
<li><p><code>projection_mat</code>: the projection matrix.
</p>
</li>
<li><p><code>Y</code>: the <code>Y</code> input.
</p>
</li>
<li><p><code>transf</code>: a <code>list</code> conating two objects: <code>Xcenter</code> and <code>Xscale</code>.
</p>
</li>
<li><p><code>weights</code>: the matrix of wheights.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='opls_cv_cpp'>Internal Cpp function for performing leave-group-out cross-validations for pls regression</h2><span id='topic+opls_cv_cpp'></span>

<h3>Description</h3>

<p>For internal use only!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opls_cv_cpp(X, Y, scale, method, 
                  mindices, pindices, 
                  min_component, ncomp, 
                  new_x, 
                  maxiter, tol, 
                  wapls_grid, 
                  algorithm, 
                  statistics = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opls_cv_cpp_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_y">Y</code></td>
<td>
<p>a matrix of a single response variable.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the matrix of predictors
(<code>X</code>) must be scaled.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_method">method</code></td>
<td>
<p>the method used for regression. One of the following options:
<code>'pls'</code> or <code>'wapls'</code> or <code>'completewapls1p'</code>.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_mindices">mindices</code></td>
<td>
<p>a matrix with <code>n</code> rows and <code>m</code> columns where
<code>m</code> is equivalent to the number of resampling iterations. The elements
of each column indicate the indices of the observations to be used for
modeling at each iteration.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_pindices">pindices</code></td>
<td>
<p>a matrix with <code>k</code> rows and <code>m</code> columns where
<code>m</code> is equivalent to the number of
resampling iterations. The elements of each column indicate the indices of
the observations to be used for predicting at each iteration.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_min_component">min_component</code></td>
<td>
<p>an integer indicating the number of minimum pls
components (if the <code>method = 'pls'</code>).</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_ncomp">ncomp</code></td>
<td>
<p>an integer indicating the number of pls components.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_new_x">new_x</code></td>
<td>
<p>a matrix of one row corresponding to the observation to be
predicted (if the <code>method = 'wapls'</code>).</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_tol">tol</code></td>
<td>
<p>limit for convergence of the algorithm in the nipals algorithm.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_wapls_grid">wapls_grid</code></td>
<td>
<p>the grid on which the search for the best combination of
minimum and maximum pls factors of <code>'wapls'</code> is based on in case
<code>method = 'completewapls1p'</code>.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_algorithm">algorithm</code></td>
<td>
<p>either pls (<code>'pls'</code>) or modified pls (<code>'mpls'</code>).
See <code>get_weigths</code> function.</p>
</td></tr>
<tr><td><code id="opls_cv_cpp_+3A_statistics">statistics</code></td>
<td>
<p>a logical value indicating whether the precision and
accuracy statistics are to be returned, otherwise the predictions for each
validation segment are retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>statistics = true</code> a list containing the following one-row matrices:
</p>

<ul>
<li><p><code>rmse_seg</code>: the RMSEs.
</p>
</li>
<li><p><code>st_rmse_seg</code>: the standardized RMSEs.
</p>
</li>
<li><p><code>rsq_seg</code>: the coefficients of determination.
</p>
</li></ul>

<p>if <code>statistics = false</code> a list containing the following one-row matrices:
</p>

<ul>
<li><p><code>predictions</code>: the predictions of each of the validation
segments in <code>pindices</code>. Each column in <code>pindices</code> contains the
validation indices of a segment.
</p>
</li>
<li><p><code>st_rmse_seg</code>: the standardized RMSEs.
</p>
</li>
<li><p><code>rsq_seg</code>: the coefficients of determination.
</p>
</li></ul>

<p>If <code>method = "wapls"</code>, data of the pls weights are output in this
list(<code>compweights</code>).
</p>
<p>If <code>method = "completewapls1"</code>, data of all the combination of
components passed in <code>wapls_grid</code> are
output in this list(<code>complete_compweights</code>).
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='opls_for_projection'>orthogonal scores algorithn of partial leat squares (opls) projection</h2><span id='topic+opls_for_projection'></span>

<h3>Description</h3>

<p>Computes orthogonal socres partial least squares (opls)
projection with the NIPALS algorithm. It allows multiple response variables.
Although the main use of the function is for projection, it also retrieves
regression coefficients. NOTE: For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opls_for_projection(X, Y, ncomp, scale,
                    maxiter, tol,
                    pcSelmethod = "var",
                    pcSelvalue = 0.01, 
                    algorithm = "pls", 
                    xls_min_w = 3, 
                    xls_max_w = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opls_for_projection_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_y">Y</code></td>
<td>
<p>a matrix of either a single or multiple response variables.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of pls components.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether <code>X</code> must be scaled.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_tol">tol</code></td>
<td>
<p>limit for convergence of the algorithm in the nipals algorithm.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_pcselmethod">pcSelmethod</code></td>
<td>
<p>if <code>regression = TRUE</code>, the method for selecting the
number of components.
Options are: <code>'manual'</code>, <code>'cumvar'</code> (for selecting the number of
principal components based on a given  cumulative amount of explained
variance) and <code>'var'</code> (for selecting the number of principal components
based on a given amount of explained variance). Default is <code>'cumvar'</code>.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_pcselvalue">pcSelvalue</code></td>
<td>
<p>a numerical value that complements the selected method
(<code>pcSelmethod</code>).
If <code>'cumvar'</code> is chosen (default), <code>pcSelvalue</code> must be a value
(larger than 0 and below 1) indicating the maximum amount of cumulative
variance that the retained components should explain. Default is 0.99.
If <code>'var'</code> is chosen, <code>pcSelvalue</code> must be a value (larger than 0
and below 1) indicating that components that explain (individually)
a variance lower than this threshold must be excluded. If <code>'manual'</code>
is chosen, <code>pcSelvalue</code> has no effect and the number of components
retrieved are the one specified in <code>ncomp</code>.</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_algorithm">algorithm</code></td>
<td>
<p>(for weights computation) a character string indicating
what method to use. Options are:
<code>'pls'</code> for pls (using covariance between X and Y),
<code>'mpls'</code> for modified pls (using correlation between X and Y) or
<code>'xls'</code> for extended pls (as implemented in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_xls_min_w">xls_min_w</code></td>
<td>
<p>(for weights computation) an integer indicating the minimum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 3 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_for_projection_+3A_xls_max_w">xls_max_w</code></td>
<td>
<p>(for weights computation) an integer indicating the maximum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 15 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>coefficients</code>: the matrix of regression coefficients.
</p>
</li>
<li><p><code>bo</code>: a matrix of one row containing the intercepts for
each component.
</p>
</li>
<li><p><code>scores</code>: the matrix of scores.
</p>
</li>
<li><p><code>X_loadings</code>: the matrix of X loadings.
</p>
</li>
<li><p><code>Y_loadings</code>: the matrix of Y loadings.
</p>
</li>
<li><p><code>projection_mat</code>: the projection matrix.
</p>
</li>
<li><p><code>Y</code>: the <code>Y</code> input.
</p>
</li>
<li><p><code>variance</code>: a <code>list</code> conating two objects: <code>x_var</code>
and <code>y_var</code>.
These objects contain information on the explained variance for the <code>X</code>
and <code>Y</code> matrices respectively.
</p>
</li>
<li><p><code>transf</code>: a <code>list</code> conating two objects: <code>Xcenter</code>
and <code>Xscale</code>.
</p>
</li>
<li><p><code>weights</code>: the matrix of wheights.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='opls_get_all'>orthogonal scores algorithn of partial leat squares (opls_get_all)</h2><span id='topic+opls_get_all'></span>

<h3>Description</h3>

<p>Computes orthogonal socres partial least squares (opls_get_all)
regressions with the NIPALS algorithm. It retrives a comprehensive set of
pls outputs (e.g. vip and sensivity radius). It allows multiple response
variables. NOTE: For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opls_get_all(X, 
             Y, 
             ncomp, 
             scale, 
             maxiter, 
             tol, 
             algorithm = "pls", 
             xls_min_w = 3, 
             xls_max_w = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opls_get_all_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_y">Y</code></td>
<td>
<p>a matrix of either a single or multiple response variables.</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of pls components.</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether <code>X</code> must be scaled.</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_tol">tol</code></td>
<td>
<p>limit for convergence of the algorithm in the nipals algorithm.</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_algorithm">algorithm</code></td>
<td>
<p>(for weights computation) a character string indicating
what method to use. Options are:
<code>'pls'</code> for pls (using covariance between X and Y),
<code>'mpls'</code> for modified pls (using correlation between X and Y) or
<code>'xls'</code> for extended pls (as implemented in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_xls_min_w">xls_min_w</code></td>
<td>
<p>(for weights computation) an integer indicating the minimum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 3 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_get_all_+3A_xls_max_w">xls_max_w</code></td>
<td>
<p>(for weights computation) an integer indicating the maximum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 15 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>ncomp</code>: the number of components used.
</p>
</li>
<li><p><code>coefficients</code>: the matrix of regression coefficients.
</p>
</li>
<li><p><code>bo</code>: a matrix of one row containing the intercepts for each component.
</p>
</li>
<li><p><code>scores</code>: the matrix of scores.
</p>
</li>
<li><p><code>X_loadings</code>: the matrix of X loadings.
</p>
</li>
<li><p><code>Y_loadings</code>: the matrix of Y loadings.
</p>
</li>
<li><p><code>vip</code>: the projection matrix.
</p>
</li>
<li><p><code>selectivity_ratio</code>: the matrix of selectivity ratio (see Rajalahti, Tarja, et al. 2009).
</p>
</li>
<li><p><code>Y</code>: the <code>Y</code> input.
</p>
</li>
<li><p><code>variance</code>: a <code>list</code> conating two objects: <code>x_var</code> and <code>y_var</code>.
These objects contain information on the explained variance for the <code>X</code> and <code>Y</code> matrices respectively.
</p>
</li>
<li><p><code>transf</code>: a <code>list</code> conating two objects: <code>Xcenter</code> and <code>Xscale</code>.
</p>
</li>
<li><p><code>weights</code>: the matrix of wheights.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='opls_get_basics'>fast orthogonal scores algorithn of partial leat squares (opls)</h2><span id='topic+opls_get_basics'></span>

<h3>Description</h3>

<p>Computes orthogonal socres partial least squares (opls)
regressions with the NIPALS algorithm. It allows multiple response variables.
In contrast to <code>opls</code> function, this one does not compute unnecessary
data for (local) regression.
For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opls_get_basics(X, Y, ncomp, scale, 
                maxiter, tol, 
                algorithm = "pls", 
                xls_min_w = 3, 
                xls_max_w = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opls_get_basics_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_y">Y</code></td>
<td>
<p>a matrix of either a single or multiple response variables.</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of pls components.</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether <code>X</code> must be scaled.</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_tol">tol</code></td>
<td>
<p>limit for convergence of the algorithm in the nipals algorithm.</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_algorithm">algorithm</code></td>
<td>
<p>(for weights computation) a character string indicating
what method to use. Options are:
<code>'pls'</code> for pls (using covariance between X and Y),
<code>'mpls'</code> for modified pls (using correlation between X and Y) or
<code>'xls'</code> for extended pls (as implemented in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_xls_min_w">xls_min_w</code></td>
<td>
<p>(for weights computation) an integer indicating the minimum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 3 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
<tr><td><code id="opls_get_basics_+3A_xls_max_w">xls_max_w</code></td>
<td>
<p>(for weights computation) an integer indicating the maximum window size for the &quot;xls&quot;
method. Only used if <code>algorithm = 'xls'</code>. Default is 15 (as in BUCHI NIRWise PLUS software).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>coefficients</code>: the matrix of regression coefficients.
</p>
</li>
<li><p><code>bo</code>: a matrix of one row containing the intercepts for each component.
</p>
</li>
<li><p><code>Y_loadings</code>: the matrix of Y loadings.
</p>
</li>
<li><p><code>projection_mat</code>: the projection matrix.
</p>
</li>
<li><p><code>transf</code>: a <code>list</code> conating two objects: <code>Xcenter</code> and <code>Xscale</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='opls_gs'>orthogonal scores algorithm of partial leat squares (opls)</h2><span id='topic+opls_gs'></span>

<h3>Description</h3>

<p>Computes orthogonal scores partial least squares (opls)
regressions with the NIPALS algorithm. It allows multiple response variables.
It does not return the variance information of the components. NOTE: For
internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opls_gs(Xr, 
        Yr,
        Xu, 
        ncomp,
        scale,     
        response = FALSE, 
        reconstruction = TRUE,
        similarity = TRUE,
        fresponse = TRUE,
        algorithm = "pls")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opls_gs_+3A_xr">Xr</code></td>
<td>
<p>a matrix of predictor variables for the training set.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_yr">Yr</code></td>
<td>
<p>a matrix of a single response variable for the training set.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_xu">Xu</code></td>
<td>
<p>a matrix of predictor variables for the test set.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of pls components.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether <code>X</code> must be scaled.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_response">response</code></td>
<td>
<p>logical indicating whether to compute the prediction of <code>Yu</code>.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_reconstruction">reconstruction</code></td>
<td>
<p>logical indicating whether to compute the reconstruction error of <code>Xu</code>.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_similarity">similarity</code></td>
<td>
<p>logical indicating whether to compute the the distance score between <code>Xr</code> and <code>Xu</code> (in the pls space).</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_fresponse">fresponse</code></td>
<td>
<p>logical indicating whether to compute the score of the variance not explained for <code>Yu</code>.</p>
</td></tr>
<tr><td><code id="opls_gs_+3A_algorithm">algorithm</code></td>
<td>
<p>(for weights computation) a character string indicating
what method to use. Options are:
<code>'pls'</code> for pls (using covariance between X and Y) or
<code>'mpls'</code> for modified pls (using correlation between X and Y).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>ncomp</code>: the number of components.
</p>
</li>
<li><p><code>pred_response</code>: the response predictions for <code>Xu</code>.
</p>
</li>
<li><p><code>rmse_reconstruction</code>: the rmse of the reconstruction for <code>Xu</code>.
</p>
</li>
<li><p><code>score_dissimilarity</code>: the distance score between <code>Xr</code> and <code>Xu</code>.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='optim_sample_strata'>A function to construct an optimal strata for the samples, based on
the distribution of the given y.</h2><span id='topic+optim_sample_strata'></span>

<h3>Description</h3>

<p>for internal use only! This function computes the optimal strata
from the distribution of the given y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_sample_strata(y, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optim_sample_strata_+3A_y">y</code></td>
<td>
<p>a matrix of one column with the response variable.</p>
</td></tr>
<tr><td><code id="optim_sample_strata_+3A_n">n</code></td>
<td>
<p>number of samples that must be sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two <code>data.table</code> objects: <code>sample_strata</code> contains
the optimal strata, whereas <code>samples_to_get</code> contains information on how
many samples per stratum are supposed to be drawn.
</p>

<hr>
<h2 id='ortho_diss'>A function for computing dissimilarity matrices from orthogonal
projections (ortho_diss)</h2><span id='topic+ortho_diss'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function computes dissimilarities (in an orthogonal space) between
either observations in a given set or between observations in two different
sets.The dissimilarities are computed based on either principal component
projection or partial least squares projection of the data. After projecting
the data, the Mahalanobis distance is applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho_diss(Xr, Xu = NULL,
           Yr = NULL,
           pc_selection = list(method = "var", value = 0.01),
           diss_method = "pca",
           .local = FALSE,
           pre_k,
           center = TRUE,
           scale = FALSE,
           compute_all = FALSE,
           return_projection = FALSE,
           allow_parallel = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho_diss_+3A_xr">Xr</code></td>
<td>
<p>a matrix containing <code>n</code> reference observations rows and
<code>p</code> variablescolumns.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix containing data of a second set of observations
with <code>p</code> variables/columns.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_yr">Yr</code></td>
<td>
<p>a matrix of <code>n</code> rows and one or more columns (variables) with
side information corresponding to the observations in <code>Xr</code> (e.g. response
variables). It can be numeric with multiple variables/columns, or character
with one single column. This argument is
required if:
</p>

<ul>
<li><p><code>diss_method == 'pls'</code>: <code>Yr</code> is required to project the variables
to orthogonal directions such that the covariance between the extracted pls
components and <code>Yr</code> is maximized.
</p>
</li>
<li><p><code>pc_selection$method == 'opc'</code>: <code>Yr</code>  is required to optimize
the number of components. The optimal number of projected components is the one
for which its distance matrix minimizes the differences between the <code>Yr</code>
value of each observation and the <code>Yr</code> value of its closest observation.
See <code><a href="#topic+sim_eval">sim_eval</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ortho_diss_+3A_pc_selection">pc_selection</code></td>
<td>
<p>a list of length 2 which specifies the method to be used
for optimizing the number of components (principal components or pls factors)
to be retained. This list must contain two elements (in the following order):
<code>method</code> (a character indicating the method for selecting the number of
components) and <code>value</code> (a numerical value that complements the selected
method). The methods available are:
</p>

<ul>
<li><p><code>"opc"</code>: optimized principal component selection based on
Ramirez-Lopez et al. (2013a, 2013b). The optimal number of components
(of a given set of observations) is the one for which its distance
matrix minimizes the differences between the <code>Yr</code> value of each
observation and the <code>Yr</code> value of its closest observation. In this
case, <code>value</code> must be a value (larger than 0 and
below <code>min(nrow(Xr)</code> <code>+ nrow(Xu),</code> <code>ncol(Xr))</code> indicating the maximum
number of principal components to be tested. See the
<code><a href="#topic+ortho_projection">ortho_projection</a></code> function for more details.
</p>
</li>
<li><p><code>"cumvar"</code>: selection of the principal components based
on a given cumulative amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of cumulative variance that the
combination of retained components should explain.
</p>
</li>
<li><p><code>"var"</code>: selection of the principal components based
on a given amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of variance that a single component
should explain in order to be retained.
</p>
</li>
<li><p><code>"manual"</code>: for manually specifying a fix number of
principal components. In this case, <code>value</code> must be a value
(larger than 0 and
below the minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code>
combined).
indicating the minimum amount of variance that a component should
explain in order to be retained.
</p>
</li></ul>

<p>Default is <code>list(method = "var", value = 0.01)</code>.
</p>
<p>Optionally, the <code>pc_selection</code> argument admits <code>"opc"</code> or
<code>"cumvar"</code> or <code>"var"</code> or <code>"manual"</code> as a single character
string. In such case, the default <code>"value"</code> when either <code>"opc"</code> or
<code>"manual"</code> are used is 40. When <code>"cumvar"</code> is used the default
<code>"value"</code> is set to 0.99 and when <code>"var"</code> is used, the default
<code>"value"</code> is set to 0.01.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_diss_method">diss_method</code></td>
<td>
<p>a character value indicating the type of projection on which
the dissimilarities must be computed. This argument is equivalent to
<code>method</code> argument in the <code><a href="#topic+ortho_projection">ortho_projection</a></code> function.
Options are:
</p>

<ul>
<li><p><code>"pca"</code>: principal component analysis using the singular value
decomposition algorithm)
</p>
</li>
<li><p><code>"pca.nipals"</code>: principal component analysis using
the non-linear iterative partial least squares algorithm.
</p>
</li>
<li><p><code>"pls"</code>: partial least squares.
</p>
</li>
<li><p><code>"mpls"</code>: modified partial least squares (Shenk and Westerhaus,
1991 and Westerhaus, 2014).
</p>
</li></ul>

<p>See the <code><a href="#topic+ortho_projection">ortho_projection</a></code> function for further details on the
projection methods.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_.local">.local</code></td>
<td>
<p>a logical indicating whether or not to compute the dissimilarities
locally (i.e. projecting locally the data) by using the <code>pre_k</code> nearest
neighbor observations of each target observation. Default is <code>FALSE</code>. See details.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_pre_k">pre_k</code></td>
<td>
<p>if <code>.local = TRUE</code> a numeric integer value which indicates the
number of nearest neighbors to (pre-)retain for each observation to
compute the (local) orthogonal dissimilarities to each observation in its
neighborhhod.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_center">center</code></td>
<td>
<p>a logical indicating if the <code>Xr</code> and <code>Xu</code> must be
centered. If <code>Xu</code> is provided the data is centered around the mean of
the pooled <code>Xr</code> and <code>Xu</code> matrices (\(Xr \cup Xu\)). For
dissimilarity computations based on pls, the data is always centered for
the projections.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if the <code>Xr</code> and <code>Xu</code> must be
scaled. If <code>Xu</code> is provided the data is scaled based on the standard
deviation of the the pooled <code>Xr</code> and <code>Xu</code> matrices (\(Xr \cup Xu\)).
if <code>center = TRUE</code>, scaling is applied after centering.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_compute_all">compute_all</code></td>
<td>
<p>a logical. In case <code>Xu</code> is specified it indicates
whether or not the distances between all the elements resulting from the
pooled <code>Xr</code> and <code>Xu</code> matrices (\(Xr \cup Xu\) must be computed).</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_return_projection">return_projection</code></td>
<td>
<p>a logical. If <code>TRUE</code> the <code>ortho_projection</code> object
on which the dissimilarities are computed will be returned. Default is <code>FALSE</code>. Note that
for <code>.local = TRUE</code> only the initial projection is returned (i.e. local
projections are not).</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_allow_parallel">allow_parallel</code></td>
<td>
<p>a logical (default TRUE). It allows parallel computing
of the local distance matrices (i.e. when <code>.local = TRUE</code>). This is done
via <code><a href="foreach.html#topic+foreach">foreach</a></code> function of the 'foreach' package.</p>
</td></tr>
<tr><td><code id="ortho_diss_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the
<code><a href="#topic+ortho_projection">ortho_projection</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>.local = TRUE</code>, first a global dissimilarity matrix is computed based on
the parameters specified. Then, by using this matrix for each target
observation, a given set of nearest neighbors (<code>pre_k</code>) are identified.
These neighbors (together with the target observation) are projected
(from the original data space) onto a (local) orthogonal space (using the
same parameters specified in the function). In this projected space the
Mahalanobis distance between the target observation and its neighbors is
recomputed. A missing value is assigned to the observations that do not belong to
this set of neighbors (non-neighbor observations).
In this case the dissimilarity matrix cannot be considered as a distance
metric since it does not necessarily satisfies the symmetry condition for
distance matrices (i.e. given two observations \(x_i\) and \(x_j\), the local
dissimilarity (\(d\)) between them is relative since generally
\(d(x_i, x_j) \neq d(x_j, x_i)\)). On the other hand, when
<code>.local = FALSE</code>, the dissimilarity matrix obtained can be considered as
a distance matrix.
</p>
<p>In the cases where <code>"Yr"</code> is required to compute the dissimilarities and
if <code>.local = TRUE</code>, care must be taken as some neighborhoods might
not have enough observations with non-missing <code>"Yr"</code> values, which might retrieve
unreliable dissimilarity computations.
</p>
<p>If <code>"opc"</code> or <code>"manual"</code> are used in <code>pc_selection$method</code>
and <code>.local = TRUE</code>, the minimum number of observations with non-missing
<code>"Yr"</code> values at each neighborhood is determined by
<code>pc_selection$value</code> (i.e. the maximum number of components to compute).
</p>


<h3>Value</h3>

<p>a <code>list</code> of class <code>ortho_diss</code> with the following elements:
</p>

<ul>
<li><p><code>n_components</code>: the number of components (either principal
components or partial least squares components) used for computing the
global dissimilarities.
</p>
</li>
<li><p><code>global_variance_info</code>: the information about the expalined
variance(s) of the projection. When <code>.local = TRUE</code>, the information
corresponds to the global projection done prior computing the local
projections.
</p>
</li>
<li><p><code>local_n_components</code>: if <code>.local = TRUE</code>, a data.table
which specifies the number of local components (either principal components
or partial least squares components) used for computing the dissimilarity
between each target observation and its neighbor observations.
</p>
</li>
<li><p><code>dissimilarity</code>: the computed dissimilarity matrix. If
<code>.local = FALSE</code> a distance matrix. If <code>.local = TRUE</code> a matrix of
class <code>local_ortho_diss</code>. In this case, each column represent the dissimilarity
between a target observation and its neighbor observations.
</p>
</li>
<li><p><code>projection</code>: if <code>return_projection = TRUE</code>,
an <code>ortho_projection</code> object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>References</h3>

<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196, 268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R., Dematte,
J. A. M.,  Scholten, T. 2013b. Distance and similarity-search metrics for use
with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ortho_projection">ortho_projection</a></code>, <code><a href="#topic+sim_eval">sim_eval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(prospectr)
data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Yu &lt;- NIRsoil[!as.logical(NIRsoil$train), "CEC", drop = FALSE]
Yr &lt;- NIRsoil[as.logical(NIRsoil$train), "CEC", drop = FALSE]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

Xu &lt;- Xu[!is.na(Yu), ]
Yu &lt;- Yu[!is.na(Yu), , drop = FALSE]

Xr &lt;- Xr[!is.na(Yr), ]
Yr &lt;- Yr[!is.na(Yr), , drop = FALSE]

# Computation of the orthogonal dissimilarity matrix using the
# default parameters
pca_diss &lt;- ortho_diss(Xr, Xu)

# Computation of a principal component dissimilarity matrix using
# the "opc" method for the selection of the principal components
pca_diss_optim &lt;- ortho_diss(
  Xr, Xu, Yr,
  pc_selection = list("opc", 40),
  compute_all = TRUE
)

# Computation of a partial least squares (PLS) dissimilarity
# matrix using the "opc" method for the selection of the PLS
# components
pls_diss_optim &lt;- ortho_diss(
  Xr = Xr, Xu = Xu,
  Yr = Yr,
  pc_selection = list("opc", 40),
  diss_method = "pls"
)
</code></pre>

<hr>
<h2 id='ortho_projection'>Orthogonal projections using principal component analysis and partial
least squares</h2><span id='topic+ortho_projection'></span><span id='topic+pls_projection'></span><span id='topic+pc_projection'></span><span id='topic+predict.ortho_projection'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Functions to perform orthogonal projections of high dimensional data matrices
using principal component analysis (pca) and partial least squares (pls).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho_projection(Xr, Xu = NULL,
                 Yr = NULL,
                 method = "pca",
                 pc_selection = list(method = "var", value = 0.01),
                 center = TRUE, scale = FALSE, ...)

pc_projection(Xr, Xu = NULL, Yr = NULL,
              pc_selection = list(method = "var", value = 0.01),
              center = TRUE, scale = FALSE,
              method = "pca",
              tol = 1e-6, max_iter = 1000, ...)

pls_projection(Xr, Xu = NULL, Yr,
               pc_selection = list(method = "opc", value = min(dim(Xr), 40)),
               scale = FALSE, method = "pls",
               tol = 1e-6, max_iter = 1000, ...)

## S3 method for class 'ortho_projection'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho_projection_+3A_xr">Xr</code></td>
<td>
<p>a matrix of observations.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix containing data of a second set of observations.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_yr">Yr</code></td>
<td>
<p>if the method used in the <code>pc_selection</code> argument is <code>"opc"</code>
or if <code>method = "pls"</code>, then it must be a matrix
containing the side information corresponding to the spectra in <code>Xr</code>.
It is equivalent to the <code>side_info</code> parameter of the <code><a href="#topic+sim_eval">sim_eval</a></code>
function. In case <code>method = "pca"</code>, a matrix (with one or more
continuous variables) can also be used as input. The root mean square of
differences (rmsd) is used for assessing the similarity between the observations
and their corresponding most similar observations in terms of the side information
provided. A single discrete variable of class factor can also be passed. In
that case, the kappa index is used. See <code><a href="#topic+sim_eval">sim_eval</a></code> function for more details.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_method">method</code></td>
<td>
<p>the method for projecting the data. Options are:
</p>

<ul>
<li><p><code>"pca"</code>: principal component analysis using the singular value
decomposition algorithm.
</p>
</li>
<li><p><code>"pca.nipals"</code>: principal component analysis using the
non-linear iterative partial least squares algorithm.
</p>
</li>
<li><p><code>"pls"</code>: partial least squares.
</p>
</li>
<li><p><code>"mpls"</code>: modified partial least squares. See details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ortho_projection_+3A_pc_selection">pc_selection</code></td>
<td>
<p>a list of length 2 which specifies the method to be used
for optimizing the number of components (principal components or pls factors)
to be retained. This list must contain two elements (in the following order):
<code>method</code> (a character indicating the method for selecting the number of
components) and <code>value</code> (a numerical value that complements the selected
method). The methods available are:
</p>

<ul>
<li><p><code>"opc"</code>: optimized principal component selection based on
Ramirez-Lopez et al. (2013a, 2013b). The optimal number of components
of a given set of observations is the one for which its distance matrix
minimizes the differences between the <code>Yr</code> value of each
observation and the <code>Yr</code> value of its closest observation. In this
case <code>value</code> must be a value (larger than 0 and
below <code>min(nrow(Xr)</code> <code>+ nrow(Xu),</code> <code>ncol(Xr))</code> indicating
the maximum number of principal components to be tested. See details.
</p>
</li>
<li><p><code>"cumvar"</code>: selection of the principal components based
on a given cumulative amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of cumulative variance that the
combination of retained components should explain.
</p>
</li>
<li><p><code>"var"</code>: selection of the principal components based
on a given amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of variance that a single component should
explain in order to be retained.
</p>
</li>
<li><p><code>"manual"</code>: for manually specifying a fix number of
principal components. In this case, <code>value</code> must be a value
(larger than 0 and
below the minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code>
combined).
indicating the minimum amount of variance that a component should
explain in order to be retained.
</p>
</li></ul>

<p>The list <code>list(method = "var", value = 0.01)</code> is the default.
Optionally, the <code>pc_selection</code> argument admits <code>"opc"</code> or
<code>"cumvar"</code> or <code>"var"</code> or <code>"manual"</code> as a single character
string. In such a case the default <code>"value"</code> when either <code>"opc"</code> or
<code>"manual"</code> are used is 40. When <code>"cumvar"</code> is used the default
<code>"value"</code> is set to 0.99 and when <code>"var"</code> is used, the default
<code>"value"</code> is set to 0.01.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_center">center</code></td>
<td>
<p>a logical indicating if the data <code>Xr</code> (and <code>Xu</code> if
specified) must be centered. If <code>Xu</code> is specified the data is centered
on the basis of \(Xr \cup Xu\). NOTE: This argument only applies to the
principal components projection. For pls projections the data is always
centered.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if <code>Xr</code> (and <code>Xu</code> if specified)
must be scaled. If <code>Xu</code> is specified the data is scaled on the basis of
\(Xr \cup Xu\).</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed
to <code>pc_projection</code> or <code>pls_projection</code>.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_tol">tol</code></td>
<td>
<p>tolerance limit for convergence of the algorithm in the nipals
algorithm (default is 1e-06). In the case of PLS this applies only to Yr with
more than one variable.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations (default is 1000). In the case of
<code>method = "pls"</code> this applies only to <code>Yr</code> matrices with more than
one variable.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_object">object</code></td>
<td>
<p>object of class <code>"ortho_projection"</code>.</p>
</td></tr>
<tr><td><code id="ortho_projection_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame or matrix in which to look for variables
with which to predict. If omitted, the scores are used. It must contain the
same number of columns, to be used in the same order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of <code>method = "pca"</code>, the algorithm used is the singular value
decomposition in which a given data matrix (\(X\)) is factorized as follows:
</p>
\[X = UDV^{T}\]
<p>where \(U\) and \(V\) are orthogonal matrices, being the left and right
singular vectors of \(X\) respectively, \(D\) is a diagonal matrix
containing the singular values of \(X\) and \(V\) is the is a matrix of
the right singular vectors of \(X\).
The matrix of principal component scores is obtained by a matrix
multiplication of \(U\) and \(D\), and the matrix of principal component
loadings is equivalent to the matrix \(V\).
</p>
<p>When <code>method = "pca.nipals"</code>, the algorithm used for principal component
analysis is the non-linear iterative partial least squares (nipals).
</p>
<p>In the case of the of the partial least squares projection (a.k.a projection
to latent structures) the nipals regression algorithm is used by default.
Details on the &quot;nipals&quot; algorithm are presented in Martens (1991). Another
method called modified pls (<code>'mpls'</code>) can also be used. The modified
pls was proposed Shenk and Westerhaus (1991, see also Westerhaus, 2014) and it
differs from the standard pls method in the way the weights of the <code>Xr</code>
(used to compute the matrix of scores) are obtained. While pls uses the covariance
between  <code>Yr</code> and <code>Xr</code> (and later their deflated versions
corresponding at each pls component iteration) to obtain these weights, the modified pls
uses the correlation as weights. The authors indicate that by using correlation,
a larger potion of the response variable(s) can be explained.
</p>
<p>When <code>method = "opc"</code>, the selection of the components is carried out by
using an iterative method based on the side information concept
(Ramirez-Lopez et al. 2013a, 2013b). First let be \(P\) a sequence of
retained components (so that \(P = 1, 2, ...,k \)).
At each iteration, the function computes a dissimilarity matrix retaining
\(p_i\) components. The values in this side information variable are
compared against the side information values of their most spectrally similar
observations (closest <code>Xr</code> observation).
The optimal number of components retrieved by the function is the one that
minimizes the root mean squared differences (RMSD) in the case of continuous
variables, or maximizes the kappa index in the case of categorical variables.
In this process, the <code><a href="#topic+sim_eval">sim_eval</a></code> function is used.
Note that for the <code>"opc"</code> method <code>Yr</code> is required (i.e. the
side information of the observations).
</p>


<h3>Value</h3>

<p>a <code>list</code> of class <code>ortho_projection</code> with the following
components:
</p>

<ul>
<li><p><code>scores</code>: a matrix of scores corresponding to the observations in
<code>Xr</code> (and <code>Xu</code> if it was provided). The components retrieved
correspond to the ones optimized or specified.
</p>
</li>
<li><p><code>X_loadings</code>: a matrix of loadings corresponding to the
explanatory variables. The components retrieved correspond to the ones
optimized or specified.
</p>
</li>
<li><p><code>Y_loadings</code>: a matrix of partial least squares loadings
corresponding to <code>Yr</code>. The components retrieved  correspond to the
ones optimized or specified.
This object is only returned if the partial least squares algorithm was used.
</p>
</li>
<li><p><code>weigths</code>: a matrix of partial least squares (&quot;pls&quot;) weights.
This object is only returned if the &quot;pls&quot; algorithm was used.
</p>
</li>
<li><p><code>projection_mat</code>: a matrix that can be used to project new data
onto a &quot;pls&quot; space. This object is only returned if the &quot;pls&quot; algorithm was
used.
</p>
</li>
<li><p><code>variance</code>: a list with information on the original variance and
the explained variances. This list contains a matrix indicating the amount of
variance explained by each component (var), the ratio between explained
variance by each single component and the original variance (explained_var) and
the cumulative ratio of explained variance (cumulative_explained_var).
The amount of variance explained by each component is computed by multiplying
its score vector by its corresponding loading vector and calculating the
variance of the result. These values are computed based on the observations
used to create the projection matrices. For example if the &quot;pls&quot; method was
used, then these values are computed  based only on the data that contains
information on <code>Yr</code> (i.e. the  <code>Xr</code> data). If the principal
component method is used, the this data is  computed on the basis of
<code>Xr</code> and <code>Xu</code> (if it applies) since both  matrices are employed in
the computation of the projection matrix (loadings  in this case).
</p>
</li>
<li><p><code>sdv</code>: the standard deviation of the retrieved scores. This vector
can be different from the &quot;sd&quot; in <code>variance</code>.
</p>
</li>
<li><p><code>n_components</code>: the number of components (either principal
components or partial least squares components) used for computing the
global dissimilarity scores.
</p>
</li>
<li><p><code>opc_evaluation</code>: a matrix containing the statistics computed
for optimizing the number of principal components based on the variable(s)
specified in the <code>Yr</code> argument. If <code>Yr</code> was a continuous  was a
continuous vector or matrix then this object indicates the root mean square
of differences (rmse) for each number of components. If <code>Yr</code> was a
categorical variable this object indicates the kappa values for each number
of components. This object is returned only if <code>"opc"</code> was used within
the <code>pc_selection</code> argument. See the <code><a href="#topic+sim_eval">sim_eval</a></code> function for
more details.
</p>
</li>
<li><p><code>method</code>: the <code>ortho_projection</code> method used.
</p>
</li></ul>

<p><code>predict.ortho_projection</code>, returns a matrix of scores proprojected for
<code>newdtata</code>.
</p>


<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>References</h3>

<p>Martens, H. (1991). Multivariate calibration. John Wiley &amp; Sons.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196, 268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R., Dematte,
J. A. M.,  Scholten, T. 2013b. Distance and similarity-search metrics for use
with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>
<p>Shenk, J. S., &amp; Westerhaus, M. O. 1991. Populations structuring of
near infrared spectra and modified partial least squares regression.
Crop Science, 31(6), 1548-1555.
</p>
<p>Shenk, J., Westerhaus, M., and Berzaghi, P. 1997. Investigation of a LOCAL
calibration procedure for near infrared instruments. Journal of Near Infrared
Spectroscopy, 5, 223-232.
</p>
<p>Westerhaus, M. 2014. Eastern Analytical Symposium Award for outstanding
Wachievements in near infrared spectroscopy: my contributions to
Wnear infrared spectroscopy. NIR news, 25(8), 16-20.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ortho_diss">ortho_diss</a></code>, <code><a href="#topic+sim_eval">sim_eval</a></code>, <code><a href="#topic+mbl">mbl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)
data(NIRsoil)

# Proprocess the data using detrend plus first derivative with Savitzky and
# Golay smoothing filter
sg_det &lt;- savitzkyGolay(
  detrend(NIRsoil$spc,
    wav = as.numeric(colnames(NIRsoil$spc))
  ),
  m = 1,
  p = 1,
  w = 7
)
NIRsoil$spc_pr &lt;- sg_det

# split into training and testing sets
test_x &lt;- NIRsoil$spc_pr[NIRsoil$train == 0 &amp; !is.na(NIRsoil$CEC), ]
test_y &lt;- NIRsoil$CEC[NIRsoil$train == 0 &amp; !is.na(NIRsoil$CEC)]

train_y &lt;- NIRsoil$CEC[NIRsoil$train == 1 &amp; !is.na(NIRsoil$CEC)]
train_x &lt;- NIRsoil$spc_pr[NIRsoil$train == 1 &amp; !is.na(NIRsoil$CEC), ]

# A principal component analysis using 5 components
pca_projected &lt;- ortho_projection(train_x, pc_selection = list("manual", 5))
pca_projected

# A principal components projection using the "opc" method
# for the selection of the optimal number of components
pca_projected_2 &lt;- ortho_projection(
  Xr = train_x, Xu = test_x, Yr = train_y,
  method = "pca",
  pc_selection = list("opc", 40)
)
pca_projected_2
plot(pca_projected_2)

# A partial least squares projection using the "opc" method
# for the selection of the optimal number of components
pls_projected &lt;- ortho_projection(
  Xr = train_x, Xu = test_x, Yr = train_y,
  method = "pls",
  pc_selection = list("opc", 40)
)
pls_projected
plot(pls_projected)

# A partial least squares projection using the "cumvar" method
# for the selection of the optimal number of components
pls_projected_2 &lt;- ortho_projection(
  Xr = train_x, Xu = test_x, Yr = train_y,
  method = "pls",
  pc_selection = list("cumvar", 0.99)
)

</code></pre>

<hr>
<h2 id='overall_var'>Function for computing the overall variance of a matrix</h2><span id='topic+overall_var'></span>

<h3>Description</h3>

<p>Computes the variance of a matrix. For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overall_var(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overall_var_+3A_x">X</code></td>
<td>
<p>a matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of standard deviation values.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='pca_nipals'>Principal components based on  the non-linear iterative partial least squares (nipals) algorithm</h2><span id='topic+pca_nipals'></span>

<h3>Description</h3>

<p>Computes orthogonal socres partial least squares (opls) regressions with the NIPALS algorithm. It allows multiple response variables.
For internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_nipals(X, ncomp, center, scale,
           maxiter, tol,
           pcSelmethod = "var",
           pcSelvalue = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_nipals_+3A_x">X</code></td>
<td>
<p>a matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="pca_nipals_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of pls components.</p>
</td></tr>
<tr><td><code id="pca_nipals_+3A_scale">scale</code></td>
<td>
<p>logical indicating whether <code>X</code> must be scaled.</p>
</td></tr>
<tr><td><code id="pca_nipals_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="pca_nipals_+3A_tol">tol</code></td>
<td>
<p>limit for convergence of the algorithm in the nipals algorithm.</p>
</td></tr>
<tr><td><code id="pca_nipals_+3A_pcselmethod">pcSelmethod</code></td>
<td>
<p>the method for selecting the number of components.
Options are: <code>'cumvar'</code> (for selecting the number of principal components based on a given
cumulative amount of explained variance) and <code>"var"</code> (for selecting the number of principal
components based on a given amount of explained variance). Default is <code>'var'</code></p>
</td></tr>
<tr><td><code id="pca_nipals_+3A_pcselvalue">pcSelvalue</code></td>
<td>
<p>a numerical value that complements the selected method (<code>pcSelmethod</code>).
If <code>"cumvar"</code> is chosen, it must be a value (larger than 0 and below 1) indicating the maximum
amount of cumulative variance that the retained components should explain. If <code>"var"</code> is chosen,
it must be a value (larger than 0 and below 1) indicating that components that explain (individually)
a variance lower than this threshold must be excluded. If <code>"manual"</code> is chosen, it must be a value
specifying the desired number of principal components to retain. Default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following elements:
</p>

<ul>
<li><p><code>pc_scores</code>: a matrix of principal component scores.
</p>
</li>
<li><p><code>pc_loadings</code>: a matrix of of principal component loadings.
</p>
</li>
<li><p><code>variance</code>: a matrix of the variance of the principal components.
</p>
</li>
<li><p><code>scale</code>: a <code>list</code> conating two objects: <code>center</code> and <code>scale</code>, which correspond to the vectors used to center and scale the input matrix.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='pkg_info'>Get the package version info</h2><span id='topic+pkg_info'></span>

<h3>Description</h3>

<p>returns package info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkg_info(pkg = "resemble")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkg_info_+3A_pkg">pkg</code></td>
<td>
<p>the package name i.e &quot;resemble&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='plot.mbl'>Plot method for an object of class <code>mbl</code></h2><span id='topic+plot.mbl'></span>

<h3>Description</h3>

<p>Plots the content of an object of class <code>mbl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbl'
plot(x, g = c("validation", "gh"), param = "rmse", pls_c = c(1,2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mbl_+3A_x">x</code></td>
<td>
<p>an object of class <code>mbl</code> (as returned by <code>mbl</code>).</p>
</td></tr>
<tr><td><code id="plot.mbl_+3A_g">g</code></td>
<td>
<p>a character vector indicating what results shall be plotted.
Options are: <code>"validation"</code> (for plotting the validation results) and/or
<code>"gh"</code> (for plotting the pls scores used to compute the GH distance.
See details).</p>
</td></tr>
<tr><td><code id="plot.mbl_+3A_param">param</code></td>
<td>
<p>a character string indicating what validation statistics shall be
plotted. The following options are available: <code>"rmse"</code>, <code>"st_rmse"</code>
or <code>"r2"</code>. These options only available if the <code>mbl</code> object contains
validation results.</p>
</td></tr>
<tr><td><code id="plot.mbl_+3A_pls_c">pls_c</code></td>
<td>
<p>a numeric vector of length one or two indicating the pls factors to be
plotted. Default is <code>c(1, 2)</code>. It is only available if <code>"gh"</code> is
specified in the <code>g</code> argument.</p>
</td></tr>
<tr><td><code id="plot.mbl_+3A_...">...</code></td>
<td>
<p>some arguments to be passed to the plot methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For plotting the pls scores from the pls score matrix (of more than one column),
this matrix is first transformed from the Euclidean space to the Mahalanobis
space. This is done by multiplying the score matrix by the root square of
its covariance matrix. The root square of this matrix is estimated using a
singular value decomposition.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mbl">mbl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)

data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Yu &lt;- NIRsoil$CEC[!as.logical(NIRsoil$train)]
Yr &lt;- NIRsoil$CEC[as.logical(NIRsoil$train)]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

Xu &lt;- Xu[!is.na(Yu), ]
Yu &lt;- Yu[!is.na(Yu)]

Xr &lt;- Xr[!is.na(Yr), ]
Yr &lt;- Yr[!is.na(Yr)]

ctrl &lt;- mbl_control(validation_type = "NNv")

ex_1 &lt;- mbl(
  Yr = Yr, Xr = Xr, Xu = Xu,
  diss_method = "cor",
  diss_usage = "none",
  gh = TRUE,
  mblCtrl = ctrl,
  k = seq(50, 250, 30)
)

plot(ex_1)
plot(ex_1, g = "gh", pls_c = c(2, 3))

</code></pre>

<hr>
<h2 id='plot.ortho_projection'>Plot method for an object of class <code>ortho_projection</code></h2><span id='topic+plot.ortho_projection'></span>

<h3>Description</h3>

<p>Plots objects of class <code>ortho_projection</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ortho_projection'
plot(x, col = "dodgerblue", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ortho_projection_+3A_x">x</code></td>
<td>
<p>an object of class <code>ortho_projection</code> (as returned by <code>ortho_projection</code>).</p>
</td></tr>
<tr><td><code id="plot.ortho_projection_+3A_col">col</code></td>
<td>
<p>the color of the plots (default is &quot;dodgerblue&quot;)</p>
</td></tr>
<tr><td><code id="plot.ortho_projection_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ortho_projection">ortho_projection</a></code>
</p>

<hr>
<h2 id='pls_cv'>Cross validation for PLS regression</h2><span id='topic+pls_cv'></span>

<h3>Description</h3>

<p>for internal use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pls_cv(
  x,
  y,
  ncomp,
  method = c("pls", "wapls"),
  center = TRUE,
  scale,
  min_component = 1,
  new_x = matrix(0, 1, 1),
  weights = NULL,
  p = 0.75,
  number = 10,
  group = NULL,
  retrieve = TRUE,
  tune = TRUE,
  max_iter = 1,
  tol = 1e-06,
  seed = NULL,
  modified = FALSE
)
</code></pre>

<hr>
<h2 id='predict_gaussian_process'>Prediction function for the <code>gaussian_process</code> function (Gaussian process regression with dot product covariance)</h2><span id='topic+predict_gaussian_process'></span>

<h3>Description</h3>

<p>Predicts response values based on a model generated by the <code>gaussian_process</code> function (Gaussian process regression with dot product covariance). For internal use only!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_gaussian_process(Xz, alpha, newdata, scale, Xcenter, Xscale, Ycenter, Yscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_gaussian_process_+3A_newdata">newdata</code></td>
<td>
<p>a matrix containing the predictor variables</p>
</td></tr>
<tr><td><code id="predict_gaussian_process_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the matrix of predictors used to create the regression model
(in the <code>gaussian_process</code> function) was scaled</p>
</td></tr>
<tr><td><code id="predict_gaussian_process_+3A_xcenter">Xcenter</code></td>
<td>
<p>if <code>center = TRUE</code> a matrix of one row with the values that must be used for centering <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict_gaussian_process_+3A_xscale">Xscale</code></td>
<td>
<p>if <code>scale = TRUE</code> a matrix of one row with the values that must be used for scaling <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict_gaussian_process_+3A_ycenter">Ycenter</code></td>
<td>
<p>if <code>center = TRUE</code> a matrix of one row with the values that must be used for accounting for the centering of the response variable.</p>
</td></tr>
<tr><td><code id="predict_gaussian_process_+3A_yscale">Yscale</code></td>
<td>
<p>if <code>scale = TRUE</code> a matrix of one row with the values that must be used  for accounting for the scaling of the response variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of predicted values
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='predict_opls'>Prediction function for the <code>opls</code> and <code>fopls</code> functions</h2><span id='topic+predict_opls'></span>

<h3>Description</h3>

<p>Predicts response values based on a model generated by either by <code>opls</code> or the <code>fopls</code> functions.
For internal use only!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_opls(bo, b, ncomp, newdata, scale, Xscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_opls_+3A_bo">bo</code></td>
<td>
<p>a numeric value indicating the intercept.</p>
</td></tr>
<tr><td><code id="predict_opls_+3A_b">b</code></td>
<td>
<p>the matrix of regression coefficients.</p>
</td></tr>
<tr><td><code id="predict_opls_+3A_ncomp">ncomp</code></td>
<td>
<p>an integer value indicating how may components must be used in the prediction.</p>
</td></tr>
<tr><td><code id="predict_opls_+3A_newdata">newdata</code></td>
<td>
<p>a matrix containing the predictor variables.</p>
</td></tr>
<tr><td><code id="predict_opls_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the matrix of predictors used to create the regression model was scaled.</p>
</td></tr>
<tr><td><code id="predict_opls_+3A_xscale">Xscale</code></td>
<td>
<p>if <code>scale = TRUE</code> a matrix of one row with the values that must be used for scaling <code>newdata</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of predicted values.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='print.local_fit'>Print method for an object of class <code>local_fit</code></h2><span id='topic+print.local_fit'></span>

<h3>Description</h3>

<p>Prints the contents of an object of class <code>local_fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'local_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.local_fit_+3A_x">x</code></td>
<td>
<p>an object of class <code>local_fit</code></p>
</td></tr>
<tr><td><code id="print.local_fit_+3A_...">...</code></td>
<td>
<p>not yet functional.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='print.local_ortho_diss'>Print method for an object of class <code>ortho_diss</code></h2><span id='topic+print.local_ortho_diss'></span>

<h3>Description</h3>

<p>Prints the content of an object of class <code>ortho_diss</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'local_ortho_diss'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.local_ortho_diss_+3A_x">x</code></td>
<td>
<p>an object of class <code>local_ortho_diss</code> (returned by
<code>ortho_diss</code> when it uses <code>.local = TRUE</code>).</p>
</td></tr>
<tr><td><code id="print.local_ortho_diss_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods (not yet functional).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>

<hr>
<h2 id='print.mbl'>Print method for an object of class <code>mbl</code></h2><span id='topic+print.mbl'></span>

<h3>Description</h3>

<p>Prints the content of an object of class <code>mbl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mbl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mbl_+3A_x">x</code></td>
<td>
<p>an object of class <code>mbl</code> (as returned by the <code>mbl</code> function).</p>
</td></tr>
<tr><td><code id="print.mbl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods (not functional).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez and Antoine Stevens
</p>

<hr>
<h2 id='print.ortho_projection'>Print method for an object of class <code>ortho_projection</code></h2><span id='topic+print.ortho_projection'></span>

<h3>Description</h3>

<p>Prints the contents of an object of class <code>ortho_projection</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ortho_projection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ortho_projection_+3A_x">x</code></td>
<td>
<p>an object of class <code>ortho_projection</code> (as returned by the
<code>ortho_projection</code> function).</p>
</td></tr>
<tr><td><code id="print.ortho_projection_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods (not yet functional).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='project_opls'>Projection function for the <code>opls</code> function</h2><span id='topic+project_opls'></span>

<h3>Description</h3>

<p>Projects new spectra onto a PLS space based on a model generated by either by <code>opls</code> or the <code>opls2</code> functions.
For internal use only!.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_opls(projection_mat, ncomp, newdata, scale, Xcenter, Xscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_opls_+3A_projection_mat">projection_mat</code></td>
<td>
<p>the projection matrix generated by the <code>opls</code> function.</p>
</td></tr>
<tr><td><code id="project_opls_+3A_ncomp">ncomp</code></td>
<td>
<p>an integer value indicating how may components must be used in the prediction.</p>
</td></tr>
<tr><td><code id="project_opls_+3A_newdata">newdata</code></td>
<td>
<p>a matrix containing the predictor variables.</p>
</td></tr>
<tr><td><code id="project_opls_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether the matrix of predictors used to create the regression model was scaled.</p>
</td></tr>
<tr><td><code id="project_opls_+3A_xcenter">Xcenter</code></td>
<td>
<p>a matrix of one row with the values that must be used for centering <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="project_opls_+3A_xscale">Xscale</code></td>
<td>
<p>if <code>scale = TRUE</code> a matrix of one row with the values that must be used for scaling <code>newdata</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix corresponding to the new spectra projected onto the PLS space
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='reconstruction_error'>Projection to pls and then re-construction</h2><span id='topic+reconstruction_error'></span>

<h3>Description</h3>

<p>Projects spectra onto a PLS space and then reconstructs it back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruction_error(x, 
                            projection_mat, 
                            xloadings, 
                            scale, 
                            Xcenter, 
                            Xscale, 
                            scale_back = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruction_error_+3A_x">x</code></td>
<td>
<p>a matrix to project.</p>
</td></tr>
<tr><td><code id="reconstruction_error_+3A_projection_mat">projection_mat</code></td>
<td>
<p>the projection matrix generated by the <code>opls_get_basics</code> function.</p>
</td></tr>
<tr><td><code id="reconstruction_error_+3A_xloadings">xloadings</code></td>
<td>
<p>the loadings matrix generated by the <code>opls_get_basics</code> function.</p>
</td></tr>
<tr><td><code id="reconstruction_error_+3A_scale">scale</code></td>
<td>
<p>logical indicating if scaling is required</p>
</td></tr>
<tr><td><code id="reconstruction_error_+3A_xcenter">Xcenter</code></td>
<td>
<p>a matrix of one row with the centering values</p>
</td></tr>
<tr><td><code id="reconstruction_error_+3A_xscale">Xscale</code></td>
<td>
<p>a matrix of one row with the scaling values</p>
</td></tr>
<tr><td><code id="reconstruction_error_+3A_scale_back">scale_back</code></td>
<td>
<p>compute the reconstruction error after de-centering the
data and de-scaling it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of 1 row and 1 column.
</p>


<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>

<hr>
<h2 id='sample_stratified'>A function to create calibration and validation sample sets for
leave-group-out cross-validation</h2><span id='topic+sample_stratified'></span>

<h3>Description</h3>

<p>for internal use only! This is stratified sampling based on the
values of a continuous response variable (y). If group is provided, the
sampling is done based on the groups and the average of y per group. This
function is used to create calibration and validation groups for
leave-group-out cross-validations (or
leave-group-of-groups-out cross-validation if group argument is provided).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_stratified(y, p, number, group = NULL, replacement = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_stratified_+3A_y">y</code></td>
<td>
<p>a matrix of one column with the response variable.</p>
</td></tr>
<tr><td><code id="sample_stratified_+3A_p">p</code></td>
<td>
<p>the percentage of samples (or groups if group argument is used) to
retain in the validation_indices set</p>
</td></tr>
<tr><td><code id="sample_stratified_+3A_number">number</code></td>
<td>
<p>the number of sample groups to be crated</p>
</td></tr>
<tr><td><code id="sample_stratified_+3A_group">group</code></td>
<td>
<p>the labels for each sample in <code>y</code> indicating the group each
observation belongs to.</p>
</td></tr>
<tr><td><code id="sample_stratified_+3A_replacement">replacement</code></td>
<td>
<p>A logical indicating sample replacements for the
calibration set are required.</p>
</td></tr>
<tr><td><code id="sample_stratified_+3A_seed">seed</code></td>
<td>
<p>an integer for random number generator (default <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two matrices (<code>hold_in</code> and
<code>hold_out</code>) giving the indices of the observations in each
column. The number of columns represents the number of sampling repetitions.
</p>

<hr>
<h2 id='search_neighbors'>A function for searching in a given reference set the neighbors of
another given set of observations (search_neighbors)</h2><span id='topic+search_neighbors'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This function searches in a reference set the neighbors of the observations
provided  in another set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_neighbors(Xr, Xu, diss_method = c("pca", "pca.nipals", "pls", "mpls",
                                         "cor", "euclid", "cosine", "sid"),
                 Yr = NULL, k, k_diss, k_range, spike = NULL,
                 pc_selection = list("var", 0.01),
                 return_projection = FALSE, return_dissimilarity = FALSE,
                 ws = NULL,
                 center = TRUE, scale = FALSE,
                 documentation = character(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_neighbors_+3A_xr">Xr</code></td>
<td>
<p>a matrix of reference (spectral) observations where the neighbor
search is to be conducted. See details.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix of (spectral) observations for which its
neighbors are to be searched in <code>Xr</code>. Default is <code>NULL</code>. See details.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_diss_method">diss_method</code></td>
<td>
<p>a character string indicating the spectral dissimilarity metric
to be used in the selection of the nearest neighbors of each observation.
</p>

<ul>
<li><p><code>"pca"</code>:  Mahalanobis distance
computed on the matrix of scores of a Principal Component (PC)
projection of <code>Xr</code> (and <code>Xu</code> if supplied).
PC projection is done using the singular value decomposition (SVD)
algorithm. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"pca.nipals"</code>: Mahalanobis distance
computed on the matrix of scores of a Principal Component (PC)
projection of <code>Xr</code> (and <code>Xu</code> if supplied).
PC projection is done using the
non-linear iterative partial least squares (niapls) algorithm.
See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"pls"</code>: Mahalanobis distance
computed on the matrix of scores of a partial least squares projection
of <code>Xr</code> (and <code>Xu</code> if supplied). In this case, <code>Yr</code>
is always required. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"mpls"</code>: Mahalanobis distance
computed on the matrix of scores of a modified partial least squares
projection (Shenk and Westerhaus, 1991; Westerhaus, 2014)
of <code>Xr</code> (and <code>Xu</code> if provided). In this case, <code>Yr</code> is
always required. See <code><a href="#topic+ortho_diss">ortho_diss</a></code> function.
</p>
</li>
<li><p><code>"cor"</code>: correlation coefficient
between observations. See <code><a href="#topic+cor_diss">cor_diss</a></code> function.
</p>
</li>
<li><p><code>"euclid"</code>: Euclidean distance
between observations. See <code><a href="#topic+f_diss">f_diss</a></code> function.
</p>
</li>
<li><p><code>"cosine"</code>: Cosine distance
between observations. See <code><a href="#topic+f_diss">f_diss</a></code> function.
</p>
</li>
<li><p><code>"sid"</code>: spectral information divergence between observations.
See <code><a href="#topic+sid">sid</a></code> function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="search_neighbors_+3A_yr">Yr</code></td>
<td>
<p>a numeric matrix of <code>n</code> observations used as side information of
<code>Xr</code> for the <code><a href="#topic+ortho_diss">ortho_diss</a></code> methods (i.e. <code>pca</code>,
<code>pca.nipals</code> or <code>pls</code>). It is required when:
</p>

<ul>
<li><p><code>diss_method = "pls"</code>
</p>
</li>
<li><p><code>diss_method = "pca"</code> with <code>"opc"</code> used as the method
in the <code>pc_selection</code> argument. See <code><a href="#topic+ortho_diss">ortho_diss()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="search_neighbors_+3A_k">k</code></td>
<td>
<p>an integer value indicating the k-nearest neighbors of each
observation in <code>Xu</code> that must be selected from <code>Xr</code>.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_k_diss">k_diss</code></td>
<td>
<p>an integer value indicating a dissimilarity treshold.
For each observation in <code>Xu</code>, its nearest neighbors in <code>Xr</code>
are selected as those for which their dissimilarity to <code>Xu</code> is below
this <code>k_diss</code> threshold. This treshold depends on the corresponding
dissimilarity metric specified in <code>diss_method</code>. Either <code>k</code> or
<code>k_diss</code> must be specified.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_k_range">k_range</code></td>
<td>
<p>an integer vector of length 2 which specifies the minimum
(first value) and the maximum (second value) number of neighbors to be
retained when the <code>k_diss</code> is given.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_spike">spike</code></td>
<td>
<p>a vector of integers (with positive and/or negative values)
indicating what observations in <code>Xr</code>
(and <code>Yr</code>) must be forced into or avoided in the neighborhoods.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_pc_selection">pc_selection</code></td>
<td>
<p>a list of length 2 to be passed onto the
<code><a href="#topic+ortho_diss">ortho_diss</a></code> methods. It is required if the method selected in
<code>diss_method</code> is any of <code>"pca"</code>, <code>"pca.nipals"</code> or
<code>"pls"</code>. This argument is used for
optimizing the number of components (principal components or pls factors)
to be retained. This list must contain two elements in the following order:
<code>method</code> (a character indicating the method for selecting the number of
components) and <code>value</code> (a numerical value that complements the selected
method). The methods available are:
</p>

<ul>
<li><p><code>"opc"</code>: optimized principal component selection based on
Ramirez-Lopez et al. (2013a, 2013b). The optimal number of components
(of set of observations) is the one for which its distance matrix
minimizes the differences between the <code>Yr</code> value of each
observation and the <code>Yr</code> value of its closest observation. In this
case <code>value</code> must be a value (larger than 0 and below the
minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code> combined)
indicating the maximum number of principal components to be tested.
See the <code><a href="#topic+ortho_projection">ortho_projection</a></code> function for more details.
</p>
</li>
<li><p><code>"cumvar"</code>: selection of the principal components based
on a given cumulative amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of cumulative variance that the
combination of retained components should explain.
</p>
</li>
<li><p><code>"var"</code>: selection of the principal components based
on a given amount of explained variance. In this case,
<code>value</code> must be a value (larger than 0 and below or equal to 1)
indicating the minimum amount of variance that a single component
should explain in order to be retained.
</p>
</li>
<li><p><code>"manual"</code>: for manually specifying a fix number of
principal components. In this case, <code>value</code> must be a value
(larger than 0 and below the
minimum dimension of <code>Xr</code> or <code>Xr</code> and <code>Xu</code> combined)
indicating the minimum amount of variance that a component should
explain in order to be retained.
</p>
</li></ul>

<p>The default is <code>list(method = "var", value = 0.01)</code>.
</p>
<p>Optionally, the <code>pc_selection</code> argument admits <code>"opc"</code> or
<code>"cumvar"</code> or <code>"var"</code> or <code>"manual"</code> as a single character
string. In such a case the default <code>"value"</code> when either <code>"opc"</code> or
<code>"manual"</code> are used is 40. When <code>"cumvar"</code> is used the default
<code>"value"</code> is set to 0.99 and when <code>"var"</code> is used, the default
<code>"value"</code> is set to 0.01.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_return_projection">return_projection</code></td>
<td>
<p>a logical indicating if the projection(s) must be
returned. Projections are used if the <code><a href="#topic+ortho_diss">ortho_diss</a></code> methods are
called (i.e. <code>method = "pca"</code>, <code>method = "pca.nipals"</code> or
<code>method = "pls"</code>).</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_return_dissimilarity">return_dissimilarity</code></td>
<td>
<p>a logical indicating if the dissimilarity matrix
used for neighbor search must be returned.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_ws">ws</code></td>
<td>
<p>an odd integer value which specifies the window size, when
<code>diss_method = cor</code> (<code><a href="#topic+cor_diss">cor_diss</a></code> method) for moving correlation
dissimilarity. If <code>ws = NULL</code> (default), then the window size will be
equal to the number of variables (columns), i.e. instead moving correlation,
the normal correlation will be used. See <code><a href="#topic+cor_diss">cor_diss</a></code> function.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_center">center</code></td>
<td>
<p>a logical indicating if the <code>Xr</code> and <code>Xu</code> matrices
must be centered. If <code>Xu</code> is provided the data is centered around the
mean of the pooled <code>Xr</code> and <code>Xu</code> matrices (\(Xr \cup Xu\)). For
dissimilarity computations based on <code>diss_method = pls</code>, the data is always
centered.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if the <code>Xr</code> and <code>Xu</code> matrices
must be scaled. If <code>Xu</code> is provided the data is scaled based
on the standard deviation of the the pooled <code>Xr</code> and <code>Xu</code> matrices
(\(Xr \cup Xu\)). If <code>center = TRUE</code>, scaling is applied after
centering.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_documentation">documentation</code></td>
<td>
<p>an optional character string that can be used to
describe anything related to the <code>mbl</code> call (e.g. description of the
input data). Default: <code>character()</code>. NOTE: his is an experimental
argument.</p>
</td></tr>
<tr><td><code id="search_neighbors_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code><a href="#topic+dissimilarity">dissimilarity</a></code>
function. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function may be specially useful when the reference set (<code>Xr</code>) is
very large. In some cases the number of observations in the reference set
can be reduced by removing irrelevant observations (i.e. observations that are not
neighbors of a particular target set). For example, this fucntion can be
used to reduce the size of the reference set before before  running the
<code><a href="#topic+mbl">mbl</a></code> function.
</p>
<p>This function uses the <code><a href="#topic+dissimilarity">dissimilarity</a></code> fucntion to compute the
dissimilarities between <code>Xr</code> and <code>Xu</code>. Arguments to
<code><a href="#topic+dissimilarity">dissimilarity</a></code> as well as further arguments to the functions
used inside <code><a href="#topic+dissimilarity">dissimilarity</a></code> (i.e. <code><a href="#topic+ortho_diss">ortho_diss</a></code>
<code><a href="#topic+cor_diss">cor_diss</a></code> <code><a href="#topic+f_diss">f_diss</a></code> <code><a href="#topic+sid">sid</a></code>) can be passed to
those functions as additional arguments (i.e. <code>...</code>).
</p>
<p>If no matrix is passed to <code>Xu</code>, the neighbor search is conducted for the
observations in <code>Xr</code> that are found whiting that matrix. If a matrix is
passed to <code>Xu</code>,  the neighbors of <code>Xu</code> are searched in the <code>Xr</code>
matrix.
</p>


<h3>Value</h3>

<p>a <code>list</code> containing the following elements:
</p>

<ul>
<li><p><code>neighbors_diss</code>: a matrix of the <code>Xr</code> dissimilarity scores
corresponding to the neighbors of each <code>Xr</code> observation (or <code>Xu</code>
observation, in case <code>Xu</code> was supplied).
The neighbor dissimilarity scores are organized by columns and are sorted
in ascending order.
</p>
</li>
<li><p><code>neighbors</code>: a matrix of the <code>Xr</code> indices corresponding to
the neighbors of each observation in <code>Xu</code>. The neighbor indices are
organized by columns and are sorted in ascending order by their
dissimilarity score.
</p>
</li>
<li><p><code>unique_neighbors</code>: a vector of the indices in <code>Xr</code>
identified as neighbors of any observation in <code>Xr</code> (or in <code>Xu</code>,
in case it was supplied). This is obtained by
converting the <code>neighbors</code> matrix into a vector and applying the
<code><a href="base.html#topic+unique">unique</a></code> function.
</p>
</li>
<li><p><code>k_diss_info</code>: a <code>data.table</code> that is returned only if the
<code>k_diss</code> argument was used. It comprises three columns, the first one
(<code>Xr_index</code> or <code>Xu_index</code>) indicates the index of the observations
in <code>Xr</code> (or in <code>Xu</code>, in case it was suppplied),
the second column (<code>n_k</code>) indicates the number of neighbors found in
<code>Xr</code> and the third column (<code>final_n_k</code>) indicates the final number
of neighbors selected bounded by <code>k_range</code>.
argument.
</p>
</li>
<li><p><code>dissimilarity</code>: If <code>return_dissimilarity = TRUE</code> the
dissimilarity object used (as computed by the <code><a href="#topic+dissimilarity">dissimilarity</a></code>
function.
</p>
</li>
<li><p><code>projection</code>: an <code>ortho_projection</code> object. Only output if
<code>return_projection = TRUE</code> and if <code>diss_method = "pca"</code>,
<code>diss_method = "pca.nipals"</code> or <code>diss_method = "pls"</code>. <br />
This object contains the projection used to compute
the dissimilarity matrix. In case of local dissimilarity matrices,
the projection corresponds to the global projection used to select the
neighborhoods.  (see <code><a href="#topic+ortho_diss">ortho_diss</a></code> function for further
details).
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>.
</p>


<h3>References</h3>

<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex data sets. Geoderma 195-196, 268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R.,
Dematte, J. A. M.,  Scholten, T. 2013b. Distance and similarity-search
metrics for use with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dissimilarity">dissimilarity</a></code> <code><a href="#topic+ortho_diss">ortho_diss</a></code>
<code><a href="#topic+cor_diss">cor_diss</a></code> <code><a href="#topic+f_diss">f_diss</a></code> <code><a href="#topic+sid">sid</a></code>
<code><a href="#topic+mbl">mbl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)

data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Yu &lt;- NIRsoil$CEC[!as.logical(NIRsoil$train)]
Yr &lt;- NIRsoil$CEC[as.logical(NIRsoil$train)]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

Xu &lt;- Xu[!is.na(Yu), ]
Yu &lt;- Yu[!is.na(Yu)]

Xr &lt;- Xr[!is.na(Yr), ]
Yr &lt;- Yr[!is.na(Yr)]

# Identify the neighbor observations using the correlation dissimilarity and
# default parameters
# (In this example all the observations in Xr belong at least to the
# first 100 neighbors of one observation in Xu)
ex1 &lt;- search_neighbors(
  Xr = Xr, Xu = Xu,
  diss_method = "cor",
  k = 40
)

# Identify the neighbor observations using principal component (PC)
# and partial least squares (PLS) dissimilarities, and using the "opc"
# approach for selecting the number of components
ex2 &lt;- search_neighbors(
  Xr = Xr, Xu = Xu,
  diss_method = "pca",
  Yr = Yr, k = 50,
  pc_selection = list("opc", 40),
  scale = TRUE
)

# Observations that do not belong to any neighborhood
seq(1, nrow(Xr))[!seq(1, nrow(Xr)) %in% ex2$unique_neighbors]

ex3 &lt;- search_neighbors(
  Xr = Xr, Xu = Xu,
  diss_method = "pls",
  Yr = Yr, k = 50,
  pc_selection = list("opc", 40),
  scale = TRUE
)
# Observations that do not belong to any neighborhood
seq(1, nrow(Xr))[!seq(1, nrow(Xr)) %in% ex3$unique_neighbors]

# Identify the neighbor observations using local PC dissimialrities
# Here, 150 neighbors are used to compute a local dissimilarity matrix
# and then this matrix is used to select 50 neighbors
ex4 &lt;- search_neighbors(
  Xr = Xr, Xu = Xu,
  diss_method = "pls",
  Yr = Yr, k = 50,
  pc_selection = list("opc", 40),
  scale = TRUE,
  .local = TRUE,
  pre_k = 150
)

</code></pre>

<hr>
<h2 id='sid'>A function for computing the spectral information divergence between
spectra (sid)</h2><span id='topic+sid'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<a href='https://www.tidyverse.org/lifecycle/#experimental'><img src='figures/lifecycle-experimental.svg' alt='Experimental lifecycle'></a>
<p>This function computes the spectral information divergence/dissimilarity between
spectra based on the kullback-leibler divergence algorithm (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sid(Xr, Xu = NULL,
    mode = "density",
    center = FALSE, scale = FALSE,
    kernel = "gaussian",
    n = if(mode == "density") round(0.5 * ncol(Xr)),
    bw = "nrd0",
    reg = 1e-04,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sid_+3A_xr">Xr</code></td>
<td>
<p>a matrix containing the spectral (reference) data.</p>
</td></tr>
<tr><td><code id="sid_+3A_xu">Xu</code></td>
<td>
<p>an optional matrix containing the spectral data of a second set of
observations.</p>
</td></tr>
<tr><td><code id="sid_+3A_mode">mode</code></td>
<td>
<p>the method to be used for computing the spectral information
divergence. Options are <code>"density"</code> (default) for computing the divergence
values on the density distributions of the spectral observations, and
<code>"feature"</code> for computing the divergence vales on the spectral variables.
See details.</p>
</td></tr>
<tr><td><code id="sid_+3A_center">center</code></td>
<td>
<p>a logical indicating if the computations must be carried out on
the centred <code>X</code> and <code>Xu</code> (if specified) matrices. If
<code>mode = "feature"</code> centring is not carried out since this option does
not accept negative values which are generated after centring the matrices.
Default is FALSE. See details.</p>
</td></tr>
<tr><td><code id="sid_+3A_scale">scale</code></td>
<td>
<p>a logical indicating if the computations must be carried out on
the variance scaled <code>X</code> and <code>Xu</code> (if specified) matrices. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="sid_+3A_kernel">kernel</code></td>
<td>
<p>if <code>mode = "density"</code> a character string indicating the
smoothing kernel to be used. It must be one of <code>"gaussian"</code> (default),
<code>"rectangular"</code>, <code>"triangular"</code>, <code>"epanechnikov"</code>,
<code>"biweight"</code>, <code>"cosine"</code> or <code>"optcosine"</code>. See the
<code><a href="stats.html#topic+density">density</a></code> function of the <code>stats</code> package.</p>
</td></tr>
<tr><td><code id="sid_+3A_n">n</code></td>
<td>
<p>if <code>mode = "density"</code> a numerical value indicating the number
of equally spaced points at which the density is to be estimated. See the
<code><a href="stats.html#topic+density">density</a></code> function of the <code>stats</code> package for further
details. Default is <code>round(0.5 * ncol(X))</code>.</p>
</td></tr>
<tr><td><code id="sid_+3A_bw">bw</code></td>
<td>
<p>if <code>mode = "density"</code> a numerical value indicating the
smoothing kernel bandwidth to be used. Optionally the character string
<code>"nrd0"</code> can be used, it computes the bandwidth using the <code>bw.nrd0</code>
function of the <code>stats</code> package (see <code>bw.nrd0</code>). See the
<code><a href="stats.html#topic+density">density</a></code> and the <code>bw.nrd0</code> functions for more
details. By default <code>"nrd0"</code> is used, in this case the bandwidth is
computed as <code>bw.nrd0(as.vector(X))</code>, if <code>Xu</code> is specified the
bandwidth is computed as <code>bw.nrd0(as.vector(rbind(X, Xu)))</code>.</p>
</td></tr>
<tr><td><code id="sid_+3A_reg">reg</code></td>
<td>
<p>a numerical value larger than 0 which indicates a regularization
parameter. Values (probabilities) below this threshold are replaced by this
value for numerical stability. Default is 1e-4.</p>
</td></tr>
<tr><td><code id="sid_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the
<code><a href="stats.html#topic+density">density</a></code> function of the base package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the spectral information divergence (distance)
between spectra.
When <code>mode = "density"</code>, the function first computes the probability
distribution of each spectrum which result in a matrix of density
distribution estimates. The density distributions of all the observations in
the datasets are compared based on the kullback-leibler divergence algorithm.
When <code>mode = "feature"</code>, the kullback-leibler divergence between all
the observations is computed directly on the spectral variables.
The spectral information divergence (SID) algorithm (Chang, 2000) uses the
Kullback-Leibler divergence (\(KL\)) or relative entropy
(Kullback and Leibler, 1951) to account for the vis-NIR information provided
by each spectrum. The SID between two spectra (\(x_{i}\) and
\(x_{j}\)) is computed as follows:
</p>
\[sid(x_{i},x_{j}) = KL(x_{i} \left |\right | x_{j}) + KL(x_{j} \left |\right | x_{i})\]
\[sid(x_{i},x_{j}) = \sum_{l=1}^{k} p_l \ log(\frac{p_l}{q_l}) + \sum_{l=1}^{k} q_l \ log(\frac{q_l}{p_l})\]
<p>where \(k\) represents the number of variables or spectral features,
\(p\) and \(q\) are the probability vectors of \(x_{i}\) and
\(x_{i}\) respectively which are calculated as:
</p>
\[p = \frac{x_i}{\sum_{l=1}^{k} x_{i,l}}\]
\[q = \frac{x_j}{\sum_{l=1}^{k} x_{j,l}}\]
<p>From the above equations it can be seen that the original SID algorithm
assumes that all the components in the data matrices are nonnegative.
Therefore centering cannot be applied when <code>mode = "feature"</code>. If a
data matrix with negative values is provided and <code>mode = "feature"</code>,
the <code>sid</code> function automatically scales the matrix as follows:
</p>
\[X_s = \frac{X-min(X)}{max(X)-min(X)}\]
<p>or
</p>
\[X_{s} = \frac{X-min(X, Xu)}{max(X, Xu)-min(X, Xu)}\]
\[Xu_{s} = \frac{Xu-min(X, Xu)}{max(X, Xu)-min(X, Xu)}\]
<p>if <code>Xu</code> is specified. The 0 values are replaced by a regularization
parameter (<code>reg</code> argument) for numerical stability.
The default of the <code>sid</code> function is to compute the SID based on the
density distributions of the spectra (<code>mode = "density"</code>). For each
spectrum in <code>X</code> the density distribution is computed using the
<code><a href="stats.html#topic+density">density</a></code> function of the <code>stats</code> package.
The 0 values of the estimated density distributions of the spectra are
replaced by a regularization parameter (<code>"reg"</code> argument) for numerical
stability. Finally the divergence between the computed spectral histogramas
is computed using the SID algorithm. Note that if <code>mode = "density"</code>,
the <code>sid</code> function will accept negative values and matrix centering
will be possible.
</p>


<h3>Value</h3>

<p>a <code>list</code> with the following components:
</p>

<ul>
<li><p><code>sid</code>: if only <code>"X"</code> is specified (i.e. <code>Xu = NULL</code>),
a square symmetric matrix of SID distances between all the components in
<code>"X"</code>. If both <code>"X"</code> and <code>"Xu"</code> are specified, a matrix
of SID distances between the components in <code>"X"</code> and the components
in <code>"Xu"</code>) where the rows represent the objects in <code>"X"</code> and the
columns represent the objects in <code>"Xu"</code>
</p>
</li>
<li><p><code>Xr</code>: the (centered and/or scaled if specified) spectral
<code>X</code> matrix
</p>
</li>
<li><p><code>Xu</code>: the (centered and/or scaled if specified) spectral
<code>Xu</code> matrix
</p>
</li>
<li><p><code>densityDisXr</code>: if <code>mode = "density"</code>, the computed
density distributions of <code>Xr</code>
</p>
</li>
<li><p><code>densityDisXu</code>: if <code>mode = "density"</code>, the computed
density distributions of <code>Xu</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Ramirez-Lopez
</p>


<h3>References</h3>

<p>Chang, C.I. 2000. An information theoretic-based approach to
spectral variability, similarity and discriminability for hyperspectral
image analysis. IEEE Transactions on Information Theory 46, 1927-1932.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)

data(NIRsoil)

Xu &lt;- NIRsoil$spc[!as.logical(NIRsoil$train), ]
Yu &lt;- NIRsoil$CEC[!as.logical(NIRsoil$train)]
Yr &lt;- NIRsoil$CEC[as.logical(NIRsoil$train)]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

Xu &lt;- Xu[!is.na(Yu), ]
Xr &lt;- Xr[!is.na(Yr), ]

# Example 1
# Compute the SID distance between all the observations in Xr
xr_sid &lt;- sid(Xr)
xr_sid

# Example 2
# Compute the SID distance between the observations in Xr and the observations
# in Xu
xr_xu_sid &lt;- sid(Xr, Xu)
xr_xu_sid

</code></pre>

<hr>
<h2 id='sim_eval'>A function for evaluating dissimilarity matrices (sim_eval)</h2><span id='topic+sim_eval'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<a href='https://www.tidyverse.org/lifecycle/#satble'><img src='figures/lifecycle-stable.svg' alt='Stable lifecycle'></a>
<p>This function searches for the most similar observation (closest neighbor) of
each observation in a given dataset based on a dissimilarity (e.g. distance
matrix). The observations are compared against their corresponding closest
observations in terms of their side information provided. The root mean
square of differences and the correlation coefficient are used for continuous
variables and for discrete variables the kappa index is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_eval(d, side_info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_eval_+3A_d">d</code></td>
<td>
<p>a symmetric matrix of dissimilarity scores between observations of
a given dataset. Alternatively, a vector of with the dissimilarity
scores of the lower triangle (without the diagonal values) can be used
(see details).</p>
</td></tr>
<tr><td><code id="sim_eval_+3A_side_info">side_info</code></td>
<td>
<p>a matrix containing the side information corresponding to
the observations in the dataset from which the dissimilarity matrix was
computed. It can be either a numeric matrix with one or multiple
columns/variables or a matrix with one character variable (discrete variable).
If it is numeric, the root mean square of differences is used for assessing
the similarity between the observations and their corresponding most similar
observations in terms of the side information provided. If it is a character
variable, then the kappa index is used. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the evaluation of dissimilarity matrices this function uses side
information (information about one variable which is available for a
group of observations, Ramirez-Lopez et al., 2013). It is assumed that there
is a (direct or indirect) correlation between this side informative variable
and the variables from which the dissimilarity was computed.
If <code>side_info</code> is numeric, the root mean square of differences (RMSD)
is used for assessing the similarity between the observations and their
corresponding most similar observations in terms of the side information
provided. It is computed as follows:
</p>
\[j(i) = NN(xr_i, Xr^{{-i}})\]
\[RMSD = \sqrt{\frac{1}{m} \sum_{i=1}^n {(y_i - y_{j(i)})^2}}\]
<p>where \(NN(xr_i, Xr^{-i})\) represents a function to
obtain the index  of the nearest neighbor observation found in \(Xr\)
(excluding the \(i\)th observation) for \(xr_i\),
\(y_{i}\) is the value of the side variable of the \(i\)th
observation, \(y_{j(i)}\) is the value of the side variable of
the nearest neighbor of the \(i\)th observation and \(m\) is
the total number of observations.
</p>
<p>If <code>side_info</code> is a factor the kappa index (\(\kappa\)) is
used instead the RMSD. It is computed as follows:
</p>
\[\kappa = \frac{p_{o}-p_{e}}{1-p_{e}}\]
<p>where both \(p_o\) and \(p_e\) are two different agreement
indices between the the side information of the observations and the side
information of their corresponding nearest observations (i.e. most similar
observations). While \(p_o\) is the relative agreement
\(p_e\) is the the agreement expected by chance.
</p>
<p>This functions accepts vectors to be passed to argument <code>d</code>, in this
case, the vector must represent the lower triangle of a dissimilarity matrix
(e.g. as returned by the <code><a href="stats.html#topic+dist">stats::dist()</a></code> function of <code>stats</code>).
</p>


<h3>Value</h3>

<p><code>sim_eval</code> returns a list with the following components:
</p>

<ul>
<li><p>&quot;<code>eval</code>: either the RMSD (and the correlation coefficient) or
the kappa index
</p>
</li>
<li><p><code>first_nn</code>: a matrix containing the original side
informative variable in the first half of the columns, and the side
informative values of the corresponding nearest neighbors in the second half
of the columns.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><a href="https://orcid.org/0000-0002-5369-5120">Leonardo Ramirez-Lopez</a>
</p>


<h3>References</h3>

<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Stevens, A., Dematte, J.A.M.,
Scholten, T. 2013a. The spectrum-based learner: A new local approach for
modeling soil vis-NIR spectra of complex datasets. Geoderma 195-196, 268-279.
</p>
<p>Ramirez-Lopez, L., Behrens, T., Schmidt, K., Viscarra Rossel, R.,
Dematte, J. A. M.,  Scholten, T. 2013b. Distance and similarity-search
metrics for use with soil vis-NIR spectra. Geoderma 199, 43-53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prospectr)
data(NIRsoil)

sg &lt;- savitzkyGolay(NIRsoil$spc, p = 3, w = 11, m = 0)

# Replace the original spectra with the filtered ones
NIRsoil$spc &lt;- sg

Yr &lt;- NIRsoil$Nt[as.logical(NIRsoil$train)]
Xr &lt;- NIRsoil$spc[as.logical(NIRsoil$train), ]

# Example 1
# Compute a principal components distance
pca_d &lt;- ortho_diss(Xr, pc_selection = list("manual", 8))$dissimilarity

# Example 1.1
# Evaluate the distance matrix on the baisis of the
# side information (Yr) associated with Xr
se &lt;- sim_eval(pca_d, side_info = as.matrix(Yr))

# The final evaluation results
se$eval

# The final values of the side information (Yr) and the values of
# the side information corresponding to the first nearest neighbors
# found by using the distance matrix
se$first_nn

# Example 1.2
# Evaluate the distance matrix on the basis of two side
# information (Yr and Yr2)
# variables associated with Xr
Yr_2 &lt;- NIRsoil$CEC[as.logical(NIRsoil$train)]
se_2 &lt;- sim_eval(d = pca_d, side_info = cbind(Yr, Yr_2))

# The final evaluation results
se_2$eval

# The final values of the side information variables and the values
# of the side information variables corresponding to the first
# nearest neighbors found by using the distance matrix
se_2$first_nn

# Example 2
# Evaluate the distances produced by retaining different number of
# principal components (this is the same principle used in the
# optimized principal components approach ("opc"))

# first project the data
pca_2 &lt;- ortho_projection(Xr, pc_selection = list("manual", 30))

results &lt;- matrix(NA, pca_2$n_components, 3)
colnames(results) &lt;- c("pcs", "rmsd", "r")
results[, 1] &lt;- 1:pca_2$n_components
for (i in 1:pca_2$n_components) {
  ith_d &lt;- f_diss(pca_2$scores[, 1:i, drop = FALSE], scale = TRUE)
  ith_eval &lt;- sim_eval(ith_d, side_info = as.matrix(Yr))
  results[i, 2:3] &lt;- as.vector(ith_eval$eval)
}
plot(results)

# Example 3
# Example 3.1
# Evaluate a dissimilarity matrix computed using the correlation
# method
cd &lt;- cor_diss(Xr)
eval_corr_diss &lt;- sim_eval(cd, side_info = as.matrix(Yr))
eval_corr_diss$eval

</code></pre>

<hr>
<h2 id='sqrt_sm'>Square root of (square) symmetric matrices</h2><span id='topic+sqrt_sm'></span>

<h3>Description</h3>

<p>For internal use only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrt_sm(X, method = c("svd", "eigen"))
</code></pre>

<hr>
<h2 id='which_min'>A function to compute row-wise index of minimum values of a square distance matrix</h2><span id='topic+which_min'></span>

<h3>Description</h3>

<p>For internal use only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_min_+3A_x">X</code></td>
<td>
<p>a square matrix of distances</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally to find the nearest neighbors
</p>


<h3>Value</h3>

<p>a vector of the indices of the minimum value in each row of the input matrix
</p>


<h3>Author(s)</h3>

<p>Antoine Stevens
</p>

<hr>
<h2 id='which_min_vector'>A function to compute indices of minimum values of a distance vector</h2><span id='topic+which_min_vector'></span>

<h3>Description</h3>

<p>For internal use only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min_vector(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_min_vector_+3A_x">X</code></td>
<td>
<p>a vector of distances</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally to find the nearest neighbors.
It searches in lower (or upper) triangular matrix. Therefore this must be the format of the
input data. The piece of code int <code>len = (sqrt(X.size()*8+1)+1)/2</code> generated an error in CRAN
since <code>sqrt</code> cannot be applied to integers.
</p>


<h3>Value</h3>

<p>a vector of the indices of the nearest neighbors
</p>


<h3>Author(s)</h3>

<p>Antoine Stevens
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
