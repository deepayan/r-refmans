<!DOCTYPE html><html lang="en-GB"><head><title>Help for package eyetools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eyetools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eyetools-package'><p>eyetools: Analyse Eye Data</p></a></li>
<li><a href='#AOI_seq'><p>Sequence analysis of area of interest entries</p></a></li>
<li><a href='#AOI_time'><p>Time analysis of area of interest entries</p></a></li>
<li><a href='#AOI_time_binned'><p>Binned time analysis of area of interest entries</p></a></li>
<li><a href='#combine_eyes'><p>Combine binocular data into single X/Y coordinate pairs</p></a></li>
<li><a href='#compare_algorithms'><p>A battery of metrics and plots to compare the two algorithms (dispersion and VTI)</p></a></li>
<li><a href='#conditional_transform'><p>conditional_transform</p></a></li>
<li><a href='#create_AOI_df'><p>Create a blank data frame for populating with AOIs</p></a></li>
<li><a href='#dist_to_visual_angle'><p>Compute visual angle from distance metrics</p></a></li>
<li><a href='#fixation_dispersion'><p>Fixation detection using a dispersion method</p></a></li>
<li><a href='#fixation_VTI'><p>Fixation detection using a velocity threshold identification method</p></a></li>
<li><a href='#HCL'><p>Example dataset from that contains binocular eye data from two participants from a simple contingency learning task</p>
(the data are from Beesley, Nguyen, Pearson, &amp; Le Pelley, 2015). In this task there are two stimuli that appear simultaneously
on each trial (to the left and right of the screen).
Participants look at these cues and then make a decision by selecting an &quot;outcome response&quot; button.</a></li>
<li><a href='#HCL_AOIs'><p>Example AOIs for use with HCL</p></a></li>
<li><a href='#HCL_behavioural'><p>Example dataset of behavioural data to complement dataset HCL.</p></a></li>
<li><a href='#hdf5_get_event'><p>Get messgaes stored in TOBII-generated HDF5 files</p></a></li>
<li><a href='#hdf5_to_df'><p>Convert TOBII-generated HDF5 files to dataframe</p></a></li>
<li><a href='#interpolate'><p>Interpolation of missing data (NAs)</p></a></li>
<li><a href='#plot_AOI_growth'><p>Plots absolute or proportional time spent in AOIs over time</p></a></li>
<li><a href='#plot_heatmap'><p>Plot heatmap of raw data</p></a></li>
<li><a href='#plot_seq'><p>Plot of raw data over time</p></a></li>
<li><a href='#plot_spatial'><p>Plot raw data and fixations</p></a></li>
<li><a href='#saccade_VTI'><p>Velocity threshold identification of saccades</p></a></li>
<li><a href='#smoother'><p>Smoothing of raw data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyse Eye Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables the automation of actions across the pipeline, including 
  initial steps of transforming binocular data and gap repair to event-based 
  processing such as fixations, saccades, and entry/duration in Areas of 
  Interest (AOIs). It also offers visualisation of eye movement and AOI 
  entries. These tools take relatively raw (trial, time, x, and y form) data 
  and can be used to return fixations, saccades, and AOI entries and time spent
  in AOIs. As the tools rely on this basic data format, the functions can work 
  with data from any eye tracking device. Implements fixation and saccade 
  detection using methods proposed by Salvucci and Goldberg (2000) 
  &lt;<a href="https://doi.org/10.1145%2F355017.355028">doi:10.1145/355017.355028</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tombeesley.github.io/eyetools/">https://tombeesley.github.io/eyetools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tombeesley/eyetools/issues">https://github.com/tombeesley/eyetools/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggforce, ggplot2, viridis, glue, hdf5r, lifecycle, magick,
pbapply, rlang, stats, utils, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0),</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-19 15:30:07 UTC; ivorym</td>
</tr>
<tr>
<td>Author:</td>
<td>Tom Beesley [aut, cre],
  Matthew Ivory [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tom Beesley &lt;t.beesley@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-19 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='eyetools-package'>eyetools: Analyse Eye Data</h2><span id='topic+eyetools'></span><span id='topic+eyetools-package'></span>

<h3>Description</h3>

<p>Enables the automation of actions across the pipeline, including initial steps of transforming binocular data and gap repair to event-based processing such as fixations, saccades, and entry/duration in Areas of Interest (AOIs). It also offers visualisation of eye movement and AOI entries. These tools take relatively raw (trial, time, x, and y form) data and can be used to return fixations, saccades, and AOI entries and time spent in AOIs. As the tools rely on this basic data format, the functions can work with data from any eye tracking device. Implements fixation and saccade detection using methods proposed by Salvucci and Goldberg (2000) <a href="https://doi.org/10.1145/355017.355028">doi:10.1145/355017.355028</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tom Beesley <a href="mailto:t.beesley@lancaster.ac.uk">t.beesley@lancaster.ac.uk</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Matthew Ivory <a href="mailto:matthew.ivory@lancaster.ac.uk">matthew.ivory@lancaster.ac.uk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tombeesley.github.io/eyetools/">https://tombeesley.github.io/eyetools/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tombeesley/eyetools/issues">https://github.com/tombeesley/eyetools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AOI_seq'>Sequence analysis of area of interest entries</h2><span id='topic+AOI_seq'></span>

<h3>Description</h3>

<p>Analyses the sequence of entries into defined AOI regions across trials. Can only be used with fixation data with a &quot;fix_n&quot; column denoting fixation events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOI_seq(
  data,
  AOIs,
  AOI_names = NULL,
  participant_ID = "participant_ID",
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AOI_seq_+3A_data">data</code></td>
<td>
<p>A dataframe with fixation data (from fixation_dispersion). Either single or multi participant data</p>
</td></tr>
<tr><td><code id="AOI_seq_+3A_aois">AOIs</code></td>
<td>
<p>A dataframe of areas of interest (AOIs), with one row per AOI (x, y, width_radius, height).</p>
</td></tr>
<tr><td><code id="AOI_seq_+3A_aoi_names">AOI_names</code></td>
<td>
<p>An optional vector of AOI names to replace the default &quot;AOI_1&quot;, &quot;AOI_2&quot;, etc.</p>
</td></tr>
<tr><td><code id="AOI_seq_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
<tr><td><code id="AOI_seq_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the sequence of entries into AOIs on each trial, entry/exit/duration time into AOI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- combine_eyes(HCL)
fix_d &lt;- fixation_dispersion(data, participant_ID = "pNum")

AOI_seq(fix_d, AOIs = HCL_AOIs, participant_ID = "pNum")


</code></pre>

<hr>
<h2 id='AOI_time'>Time analysis of area of interest entries</h2><span id='topic+AOI_time'></span>

<h3>Description</h3>

<p>Analyses total time on defined AOI regions across trials. Works with fixation and raw data as the input (must use one or the other, not both).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOI_time(
  data,
  data_type = NULL,
  AOIs,
  AOI_names = NULL,
  sample_rate = NULL,
  as_prop = FALSE,
  trial_time = NULL,
  participant_ID = "participant_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AOI_time_+3A_data">data</code></td>
<td>
<p>A dataframe  of either fixation data (from fix_dispersion) or raw data</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_data_type">data_type</code></td>
<td>
<p>Whether data is a fixation (&quot;fix&quot;) or raw data (&quot;raw&quot;)</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_aois">AOIs</code></td>
<td>
<p>A dataframe of areas of interest (AOIs), with one row per AOI (x, y, width_radius, height).</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_aoi_names">AOI_names</code></td>
<td>
<p>An optional vector of AOI names to replace the default &quot;AOI_1&quot;, &quot;AOI_2&quot;, etc.</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Optional sample rate of the eye-tracker (Hz) for use with data. If not supplied, the sample rate will be estimated from the time column and the number of samples.</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_as_prop">as_prop</code></td>
<td>
<p>whether to return time in AOI as a proportion of the total time of trial</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_trial_time">trial_time</code></td>
<td>
<p>needed if as_prop is set to TRUE. a vector of the time taken in each trial. Equal to the length of x trials by y participants in the dataset</p>
</td></tr>
<tr><td><code id="AOI_time_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AOI_time can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a dataframe containing the time on the passed AOIs for each trial. One column for each AOI separated by trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data &lt;- combine_eyes(HCL)
fix_d &lt;- fixation_dispersion(data, participant_ID = "pNum")

# fixation data
AOI_time(data = fix_d, data_type = "fix", AOIs = HCL_AOIs, participant_ID = "pNum")

#raw data
AOI_time(data = data, data_type = "raw", AOIs = HCL_AOIs, participant_ID = "pNum")

#as proportional data
AOI_time(data = fix_d, data_type = "fix", AOIs = HCL_AOIs, participant_ID = "pNum",
         as_prop = TRUE, trial_time = HCL_behavioural$RT)

</code></pre>

<hr>
<h2 id='AOI_time_binned'>Binned time analysis of area of interest entries</h2><span id='topic+AOI_time_binned'></span>

<h3>Description</h3>

<p>Analyses total time on defined AOI regions across trials separated into bins. Works with raw data as the input.
Data can be separated into bins of a given length of time and the number of bins per trial is calculated automatically, keeping the bin length
consistent across varying lengths of trial. Any r=data that cannot fill a bin (tpyically the last few milliseconds of the trial) are dropped to
ensure that bins are of a consistent length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AOI_time_binned(
  data,
  AOIs,
  AOI_names = NULL,
  sample_rate = NULL,
  bin_length = NULL,
  max_time = NULL,
  as_prop = FALSE,
  participant_ID = "participant_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AOI_time_binned_+3A_data">data</code></td>
<td>
<p>A dataframe of raw data</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_aois">AOIs</code></td>
<td>
<p>A dataframe of areas of interest (AOIs), with one row per AOI (x, y, width_radius, height).</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_aoi_names">AOI_names</code></td>
<td>
<p>An optional vector of AOI names to replace the default &quot;AOI_1&quot;, &quot;AOI_2&quot;, etc.</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Optional sample rate of the eye-tracker (Hz) for use with data. If not supplied, the sample rate will be estimated from the time column and the number of samples.</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_bin_length">bin_length</code></td>
<td>
<p>the time duration to be used for each bin.</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_max_time">max_time</code></td>
<td>
<p>maximum length of time to use, default is total trial length</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_as_prop">as_prop</code></td>
<td>
<p>whether to return time in AOI as a proportion of the total time of trial</p>
</td></tr>
<tr><td><code id="AOI_time_binned_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>AOI_time_binned can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a dataframe containing the time on the passed AOIs for each trial. One column for each AOI separated by trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data &lt;- combine_eyes(HCL)


#with bins of 100ms each and only for the first 2000ms
AOI_time_binned(data = data, AOIs = HCL_AOIs, participant_ID = "pNum",
    bin_length = 100, max_time = 2000)


</code></pre>

<hr>
<h2 id='combine_eyes'>Combine binocular data into single X/Y coordinate pairs</h2><span id='topic+combine_eyes'></span>

<h3>Description</h3>

<p>Combines the data from binocular samples into X/Y coordinate pairs. Two
methods can be used: &quot;average&quot; or &quot;best_eye&quot;. For &quot;average&quot;, the result is based on the average of the two eyes for each sample,
or for samples where there is data from only a single eye, that eye is used. For &quot;best_eye&quot;, a summary of the proportion of missing samples
is computed, and the eye with the fewest missing samples is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_eyes(data, method = "average")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_eyes_+3A_data">data</code></td>
<td>
<p>raw data with columns time, left_x, left_y, right_x, right_y, and trial</p>
</td></tr>
<tr><td><code id="combine_eyes_+3A_method">method</code></td>
<td>
<p>either &quot;average&quot; or &quot;best_eye&quot; - see description.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of x-2 variables (with left_x and right_x condensed to x, and left_y and right_y condensed to y) and the same number of observations as the input data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>combine_eyes(HCL, method = "average")

</code></pre>

<hr>
<h2 id='compare_algorithms'>A battery of metrics and plots to compare the two algorithms (dispersion and VTI)</h2><span id='topic+compare_algorithms'></span>

<h3>Description</h3>

<p>A tool for comparing the two different algorithms present in this package. This function is useful for assessing the data as well as exploring which algorithm is likely to fit data more appropriately.
The raw data is run through both algorithms (using the same specified dispersion tolerances, etc.) before making comparisons of the underlying data. Can only be used for single participant data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_algorithms(
  data,
  plot_fixations = TRUE,
  print_summary = TRUE,
  sample_rate = NULL,
  threshold = 100,
  min_dur = 150,
  min_dur_sac = 20,
  disp_tol = 100,
  NA_tol = 0.25,
  smooth = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_algorithms_+3A_data">data</code></td>
<td>
<p>A dataframe with raw data (time, x, y, trial) for one participant</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_plot_fixations">plot_fixations</code></td>
<td>
<p>Whether to plot the detected fixations. default as TRUE</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_print_summary">print_summary</code></td>
<td>
<p>Whether to print the summary table. default as TRUE</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sample rate of the eye-tracker. If default of NULL, then it will be computed from the timestamp data and the number of samples. Supplied to the VTI algorithm</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_threshold">threshold</code></td>
<td>
<p>velocity threshold (degrees of VA / sec) to be used for identifying saccades. Supplied to the VTI algorithm</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_min_dur">min_dur</code></td>
<td>
<p>Minimum duration (in milliseconds) of period over which fixations are assessed. Supplied to both algorithms.</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_min_dur_sac">min_dur_sac</code></td>
<td>
<p>Minimum duration (in milliseconds) for saccades to be determined. Supplied to the VTI algorithm</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_disp_tol">disp_tol</code></td>
<td>
<p>Maximum tolerance (in pixels) for the dispersion of values allowed over fixation period. Supplied to both algorithms</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_na_tol">NA_tol</code></td>
<td>
<p>the proportion of NAs tolerated within any window of samples that is evaluated as a fixation. Supplied to the dispersion algorithm</p>
</td></tr>
<tr><td><code id="compare_algorithms_+3A_smooth">smooth</code></td>
<td>
<p>include a call to eyetools::smoother on each trial. Supplied to the VTI algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the fixation data, correlation output, and data used for plotting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- combine_eyes(HCL)
data &lt;- interpolate(data, participant_ID = "pNum")
compare_algorithms(data[data$pNum == 119,])


</code></pre>

<hr>
<h2 id='conditional_transform'>conditional_transform</h2><span id='topic+conditional_transform'></span>

<h3>Description</h3>

<p>A function to perform conditional transformations of the x/y raw data.
The function takes the dataframe and performs a single axis flip based on the values specified in the cond_column.
The primary use of this function is to correct or normalise the data when counterbalancing stimulus placement within experiments (e.g., having a target stimulus appear on the left and right equally often)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_transform(
  data,
  flip = c("x", "y"),
  cond_column,
  cond_values,
  resolution_x = 1920,
  resolution_y = 1080,
  message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_transform_+3A_data">data</code></td>
<td>
<p>a dataframe that includes columns x and y and the column specified in cond_column. Can be raw, fixation, or saccade data.</p>
</td></tr>
<tr><td><code id="conditional_transform_+3A_flip">flip</code></td>
<td>
<p>either &quot;x&quot;, to flip across vertical midline, or &quot;y&quot; to flip across horizontal midline</p>
</td></tr>
<tr><td><code id="conditional_transform_+3A_cond_column">cond_column</code></td>
<td>
<p>a column name, on which the flips are conditional</p>
</td></tr>
<tr><td><code id="conditional_transform_+3A_cond_values">cond_values</code></td>
<td>
<p>a single value or vector stating which values in con_column result in a flip</p>
</td></tr>
<tr><td><code id="conditional_transform_+3A_resolution_x">resolution_x</code></td>
<td>
<p>screen size in pixels for the x axis</p>
</td></tr>
<tr><td><code id="conditional_transform_+3A_resolution_y">resolution_y</code></td>
<td>
<p>screen size in pixels for the y axis</p>
</td></tr>
<tr><td><code id="conditional_transform_+3A_message">message</code></td>
<td>
<p>whether to output messages during function. Useful to turn off when using in a vectorised fashion where it is running multiple times</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of the equivalent format as the input data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- combine_eyes(HCL)
data &lt;- merge(data, HCL_behavioural)
conditional_transform(data, flip = "x",
                      cond_column = "cue_order",
                      cond_values = 2)
</code></pre>

<hr>
<h2 id='create_AOI_df'>Create a blank data frame for populating with AOIs</h2><span id='topic+create_AOI_df'></span>

<h3>Description</h3>

<p>Create a blank data frame for populating with AOIs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_AOI_df(num_AOIs = 3, shape = "rect", AOI_data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_AOI_df_+3A_num_aois">num_AOIs</code></td>
<td>
<p>number of AOIs, setting the number of rows</p>
</td></tr>
<tr><td><code id="create_AOI_df_+3A_shape">shape</code></td>
<td>
<p>whether the AOI is rectangular (&quot;rect&quot;) or circular (&quot;circ&quot;)</p>
</td></tr>
<tr><td><code id="create_AOI_df_+3A_aoi_data">AOI_data</code></td>
<td>
<p>a list of data for each AOI, ordered by x, y, width_radius, and height</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe in the standard format required for eyetools
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an empty data frame with 3 rectangular shaped AOIs
create_AOI_df(3, shape = "rect")

# create an AOI dataframe with data
create_AOI_df(3, shape = "rect",
              AOI_data = list(c(460,840,400,300), c(1460,840,400,300), c(960,270,300,500)))
# creating data for circular AOIs
create_AOI_df(3, shape = "circ",
              AOI_data = list(c(460,840,400), c(1460,840,400), c(960,270,300)))
</code></pre>

<hr>
<h2 id='dist_to_visual_angle'>Compute visual angle from distance metrics</h2><span id='topic+dist_to_visual_angle'></span>

<h3>Description</h3>

<p>Takes a single value or vector of distances and returns the visual angle equivalent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_to_visual_angle(
  vector,
  dist_type = "cm",
  view_dist_cm = 60,
  screen_width_cm = 51,
  screen_width_pixels = 1920
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_to_visual_angle_+3A_vector">vector</code></td>
<td>
<p>vector of distances (or single distance)</p>
</td></tr>
<tr><td><code id="dist_to_visual_angle_+3A_dist_type">dist_type</code></td>
<td>
<p>default is &quot;cm&quot;. Specify &quot;pixel&quot; for conversion from pixel values.</p>
</td></tr>
<tr><td><code id="dist_to_visual_angle_+3A_view_dist_cm">view_dist_cm</code></td>
<td>
<p>viewing distance in cm. Default of 60cm.</p>
</td></tr>
<tr><td><code id="dist_to_visual_angle_+3A_screen_width_cm">screen_width_cm</code></td>
<td>
<p>used in conversion of pixel values. Default is 51 cm (24&quot; monitor).</p>
</td></tr>
<tr><td><code id="dist_to_visual_angle_+3A_screen_width_pixels">screen_width_pixels</code></td>
<td>
<p>used in conversion of pixel values. Default is 1920 pixels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an equivalent-sized object to the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'># calculate visual angle for stimulus of 5cm
dist_to_visual_angle(5)

# calculate visual angle of stimuli 2 and 10cm width at 50 cm viewing angle
dist_to_visual_angle(c(2,10), view_dist_cm = 50)

# calculate visual angle of 150 pixel wide
dist_to_visual_angle(150, dist_type = "pixels")

</code></pre>

<hr>
<h2 id='fixation_dispersion'>Fixation detection using a dispersion method</h2><span id='topic+fixation_dispersion'></span>

<h3>Description</h3>

<p>Detects fixations by assessing dispersion of the eye position, using a method that is similar to that proposed by Salvucci &amp; Goldberg (1996).
Evaluates the maximum dispersion (distance) between x/y coordinates across a window of data. Looks for sufficient periods
in which this maximum dispersion is below the specified dispersion tolerance. NAs are considered breaks
in the data and are not permitted within a valid fixation period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixation_dispersion(
  data,
  min_dur = 150,
  disp_tol = 100,
  NA_tol = 0.25,
  progress = TRUE,
  participant_ID = "participant_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixation_dispersion_+3A_data">data</code></td>
<td>
<p>A dataframe with raw data (time, x, y, trial) for one participant (the standardised raw data form for eyetools)</p>
</td></tr>
<tr><td><code id="fixation_dispersion_+3A_min_dur">min_dur</code></td>
<td>
<p>Minimum duration (in milliseconds) of period over which fixations are assessed</p>
</td></tr>
<tr><td><code id="fixation_dispersion_+3A_disp_tol">disp_tol</code></td>
<td>
<p>Maximum tolerance (in pixels) for the dispersion of values allowed over fixation period</p>
</td></tr>
<tr><td><code id="fixation_dispersion_+3A_na_tol">NA_tol</code></td>
<td>
<p>the proportion of NAs tolerated within any window of samples that is evaluated as a fixation</p>
</td></tr>
<tr><td><code id="fixation_dispersion_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar</p>
</td></tr>
<tr><td><code id="fixation_dispersion_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a dataframe containing each detected fixation by trial, with mean x/y position in pixel, start and end times, and duration.
</p>


<h3>References</h3>

<p>Salvucci, D. D., &amp; Goldberg, J. H. (2000). Identifying fixations and saccades in eye-tracking protocols. Proceedings of the Symposium on Eye Tracking Research &amp; Applications - ETRA '00, 71–78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- combine_eyes(HCL)
fixation_dispersion(data, participant_ID = "pNum")


</code></pre>

<hr>
<h2 id='fixation_VTI'>Fixation detection using a velocity threshold identification method</h2><span id='topic+fixation_VTI'></span>

<h3>Description</h3>

<p>Determine fixations by assessing the velocity of eye-movements, using a method that is similar to that proposed by Salvucci &amp; Goldberg (1996).
Applies the algorithm used in VTI_saccade and removes the identified saccades before assessing whether separated fixations are outside of the dispersion tolerance.
If they are outside of this tolerance, the fixation is treated as a new fixation regardless of the length of saccade separating them.
Compared to fixation_dispersion(), fixation_VTI() is more conservative in determining a fixation as smaller saccades are discounted and the resulting data is
treated as a continued fixation (assuming it is within the pixel tolerance set by disp_tol).
Returns a summary of the fixations found per trial, including start and end coordinates, timing, duration, mean velocity, and peak velocity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixation_VTI(
  data,
  sample_rate = NULL,
  threshold = 100,
  min_dur = 150,
  min_dur_sac = 20,
  disp_tol = 100,
  smooth = FALSE,
  progress = TRUE,
  participant_ID = "participant_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixation_VTI_+3A_data">data</code></td>
<td>
<p>A dataframe with raw data (time, x, y, trial) for one participant</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sample rate of the eye-tracker. If default of NULL, then it will be computed from the timestamp data and the number of samples</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_threshold">threshold</code></td>
<td>
<p>velocity threshold (degrees of VA / sec) to be used for identifying saccades.</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_min_dur">min_dur</code></td>
<td>
<p>Minimum duration (in milliseconds) of period over which fixations are assessed</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_min_dur_sac">min_dur_sac</code></td>
<td>
<p>Minimum duration (in milliseconds) for saccades to be determined</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_disp_tol">disp_tol</code></td>
<td>
<p>Maximum tolerance (in pixels) for the dispersion of values allowed over fixation period</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_smooth">smooth</code></td>
<td>
<p>include a call to eyetools::smoother on each trial</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar</p>
</td></tr>
<tr><td><code id="fixation_VTI_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a dataframe containing each detected fixation by trial, with mean x/y position in pixel, start and end times, and duration.
</p>


<h3>References</h3>

<p>Salvucci, D. D., &amp; Goldberg, J. H. (2000). Identifying fixations and saccades in eye-tracking protocols. Proceedings of the Symposium on Eye Tracking Research &amp; Applications - ETRA '00, 71–78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- combine_eyes(HCL)
data &lt;- interpolate(data, participant_ID = "pNum")
fixation_VTI(data[data$pNum == 119,], participant_ID = "pNum")


</code></pre>

<hr>
<h2 id='HCL'>Example dataset from that contains binocular eye data from two participants from a simple contingency learning task
(the data are from Beesley, Nguyen, Pearson, &amp; Le Pelley, 2015). In this task there are two stimuli that appear simultaneously
on each trial (to the left and right of the screen).
Participants look at these cues and then make a decision by selecting an &quot;outcome response&quot; button.</h2><span id='topic+HCL'></span>

<h3>Description</h3>

<p>The dataset contains data from two participants and the first six trials of the study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCL
</code></pre>


<h3>Format</h3>

<p>A dataframe of 31,041 observations and seven variables
</p>

<dl>
<dt>pNum</dt><dd><p>participant number</p>
</dd>
<dt>time</dt><dd><p>timestamp of the sample (milliseconds)</p>
</dd>
<dt>left_x</dt><dd><p>x coordinate of the left eye</p>
</dd>
<dt>left_y</dt><dd><p>y coordinate of the left eye</p>
</dd>
<dt>right_x</dt><dd><p>x coordinate of the right eye</p>
</dd>
<dt>right_y</dt><dd><p>y coordinate of the right eye</p>
</dd>
<dt>trial</dt><dd><p>trial number</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='HCL_AOIs'>Example AOIs for use with HCL</h2><span id='topic+HCL_AOIs'></span>

<h3>Description</h3>

<p>This dataframe contains three rectangular areas of interest (AOIs), set out for use with the HCL dataset.
Values are in pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCL_AOIs
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 4 variables:
</p>

<dl>
<dt>x</dt><dd><p>centred x coordinate of the AOI</p>
</dd>
<dt>y</dt><dd><p>centred y coordinate of the AOI</p>
</dd>
<dt>width_radius</dt><dd><p>either the width of the AOI, or the radius for circular AOIs</p>
</dd>
<dt>height</dt><dd><p>the height of the AOI; should be NA for circular AOIs</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='HCL_behavioural'>Example dataset of behavioural data to complement dataset HCL.</h2><span id='topic+HCL_behavioural'></span>

<h3>Description</h3>

<p>This contains information on stimuli (such as the side the predictive cue was presented on)
as well as response data, including accuracy and response times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HCL_behavioural
</code></pre>


<h3>Format</h3>

<p>A dataframe of 12 observations and eight variables
</p>

<dl>
<dt>pNum</dt><dd><p>participant number</p>
</dd>
<dt>trial</dt><dd><p>trial number</p>
</dd>
<dt>P_cue</dt><dd><p>Are these necessary columns?</p>
</dd>
<dt>NP_cue</dt><dd><p>Are these necessary columns?</p>
</dd>
<dt>cue_order</dt><dd><p>whether the predictive cue os presented on the left (1) or the right (2)</p>
</dd>
<dt>correct_out</dt><dd><p>NAre these necessary columns?</p>
</dd>
<dt>accuracy</dt><dd><p>response accuracy</p>
</dd>
<dt>RT</dt><dd><p>response time in milliseconds</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='hdf5_get_event'>Get messgaes stored in TOBII-generated HDF5 files</h2><span id='topic+hdf5_get_event'></span>

<h3>Description</h3>

<p>A function to get the message event files from a TOBII-generated hdf5 file to dataframe.
Used when a Psychopy experiment uses the io.sendMessageEvent() to record events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdf5_get_event(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdf5_get_event_+3A_filename">filename</code></td>
<td>
<p>the hdf5 file generated from TOBII</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of message events as recorded by TOBII eye trackers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
raw_data &lt;- hdf5_get_event("example_TOBII.hdf5")

## End(Not run)
</code></pre>

<hr>
<h2 id='hdf5_to_df'>Convert TOBII-generated HDF5 files to dataframe</h2><span id='topic+hdf5_to_df'></span>

<h3>Description</h3>

<p>A function to convert TOBII-generated hdf5 files to a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdf5_to_df(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdf5_to_df_+3A_filename">filename</code></td>
<td>
<p>the hdf5 file generated from TOBII</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dataframes collected from the eyetracker content, if only one eyetracking event is present, return this as a single dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
raw_data &lt;- hdf5_to_df("example_TOBII.hdf5")

## End(Not run)
</code></pre>

<hr>
<h2 id='interpolate'>Interpolation of missing data (NAs)</h2><span id='topic+interpolate'></span>

<h3>Description</h3>

<p>Extends the zoo::na.approx and zoo::na.spline functions to include a report which provides
the proportion of missing data before and after the interpolation process. This is handy
for evaluating the effectiveness of the repair.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate(
  data,
  maxgap = 150,
  method = "approx",
  sample_rate = NULL,
  report = FALSE,
  participant_ID = "participant_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interpolate_+3A_data">data</code></td>
<td>
<p>dataframe with columns time, x, y, trial (the standardised raw data form for eyeproc)</p>
</td></tr>
<tr><td><code id="interpolate_+3A_maxgap">maxgap</code></td>
<td>
<p>maximum time gap of consecutive trackloss to fill (in ms). Any longer gaps will be left unchanged (see zoo package)</p>
</td></tr>
<tr><td><code id="interpolate_+3A_method">method</code></td>
<td>
<p>&quot;approx&quot; for linear interpolation or &quot;spline&quot; for cubic spline interpolation</p>
</td></tr>
<tr><td><code id="interpolate_+3A_sample_rate">sample_rate</code></td>
<td>
<p>Optional sample rate of the eye-tracker (Hz) for use with data. If not supplied, the sample rate will be estimated from the time column and the number of samples.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_report">report</code></td>
<td>
<p>default is FALSE. If TRUE, then the return value is a list containing the returned data frame and the report.</p>
</td></tr>
<tr><td><code id="interpolate_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a dataframe of the same shape of the input data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- combine_eyes(HCL)
interpolate(data, maxgap = 150, participant_ID = "pNum")

</code></pre>

<hr>
<h2 id='plot_AOI_growth'>Plots absolute or proportional time spent in AOIs over time</h2><span id='topic+plot_AOI_growth'></span>

<h3>Description</h3>

<p>A visualisation tool for plotting the changes in defined AOI regions across a single trial time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_AOI_growth(
  data = NULL,
  AOIs = NULL,
  AOI_names = NULL,
  type = NULL,
  trial_number = NULL,
  plot_time_not_in_AOI = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_AOI_growth_+3A_data">data</code></td>
<td>
<p>raw data in standard raw data form (time, x, y, trial)</p>
</td></tr>
<tr><td><code id="plot_AOI_growth_+3A_aois">AOIs</code></td>
<td>
<p>A dataframe of areas of interest (AOIs), with one row per AOI (x, y, width_radius, height)</p>
</td></tr>
<tr><td><code id="plot_AOI_growth_+3A_aoi_names">AOI_names</code></td>
<td>
<p>An optional vector of AOI names to replace the default &quot;AOI_1&quot;, &quot;AOI_2&quot;, etc. To omit AOIs from the plot, use NA in relevant vector position</p>
</td></tr>
<tr><td><code id="plot_AOI_growth_+3A_type">type</code></td>
<td>
<p>either &quot;abs&quot; (absolute) or &quot;prop&quot; (proportion)</p>
</td></tr>
<tr><td><code id="plot_AOI_growth_+3A_trial_number">trial_number</code></td>
<td>
<p>can be used to select particular trials within the data</p>
</td></tr>
<tr><td><code id="plot_AOI_growth_+3A_plot_time_not_in_aoi">plot_time_not_in_AOI</code></td>
<td>
<p>boolean as to whether to include proportion of time spent outside AOIs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the raw data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data &lt;- combine_eyes(HCL)
data &lt;- data[data$pNum == 118 &amp; data$trial == 1,]
data &lt;- interpolate(data)
# plot absolute and then proportional
plot_AOI_growth(data = data, AOIs = HCL_AOIs, type = "abs")
plot_AOI_growth(data = data, AOIs = HCL_AOIs, type = "prop")


</code></pre>

<hr>
<h2 id='plot_heatmap'>Plot heatmap of raw data</h2><span id='topic+plot_heatmap'></span>

<h3>Description</h3>

<p>Plots a heatmap of raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_heatmap(
  data = NULL,
  trial_number = NULL,
  bg_image = NULL,
  res = c(0, 1920, 0, 1080),
  flip_y = FALSE,
  alpha_control = 0.1,
  plot_header = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_heatmap_+3A_data">data</code></td>
<td>
<p>data in standard raw data form (time, x, y, trial)</p>
</td></tr>
<tr><td><code id="plot_heatmap_+3A_trial_number">trial_number</code></td>
<td>
<p>can be used to select particular trials within the data</p>
</td></tr>
<tr><td><code id="plot_heatmap_+3A_bg_image">bg_image</code></td>
<td>
<p>The filepath of an image to be added to the plot, for example to show a screenshot of the task.</p>
</td></tr>
<tr><td><code id="plot_heatmap_+3A_res">res</code></td>
<td>
<p>resolution of the display to be shown, as a vector (xmin, xmax, ymin, ymax)</p>
</td></tr>
<tr><td><code id="plot_heatmap_+3A_flip_y">flip_y</code></td>
<td>
<p>reverse the y axis coordinates (useful if origin is top of the screen)</p>
</td></tr>
<tr><td><code id="plot_heatmap_+3A_alpha_control">alpha_control</code></td>
<td>
<p>a single value to determine how much of the heatmap to obscure. Between 0 and 1. Lower values include more data in the heatmap</p>
</td></tr>
<tr><td><code id="plot_heatmap_+3A_plot_header">plot_header</code></td>
<td>
<p>display the header title text which explains graphical features of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the raw data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- combine_eyes(HCL)
data &lt;- data[data$pNum == 118,]
# plot all trials data
plot_heatmap(data, alpha_control = .01)

#plot one trial
plot_heatmap(data, trial_number = 1)


</code></pre>

<hr>
<h2 id='plot_seq'>Plot of raw data over time</h2><span id='topic+plot_seq'></span>

<h3>Description</h3>

<p>A tool for visualising the timecourse of raw data over a single trial. If data from multiple trials are present, then
a single trial will be sampled at random. Alternatively, the trial_number can be specified. Data can be plotted across the whole
trial, or can be split into bins to present distinct plots for each time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_seq(
  data = NULL,
  trial_number = NULL,
  AOIs = NULL,
  bg_image = NULL,
  res = c(0, 1920, 0, 1080),
  flip_y = FALSE,
  plot_header = FALSE,
  bin_time = NULL,
  bin_range = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_seq_+3A_data">data</code></td>
<td>
<p>A dataframe with raw data. If multiple trials are used, then one trial is sampled at random.</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_trial_number">trial_number</code></td>
<td>
<p>can be used to select a particular trial within the data</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_aois">AOIs</code></td>
<td>
<p>A dataframe of areas of interest (AOIs), with one row per AOI (x, y, width_radius, height).</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_bg_image">bg_image</code></td>
<td>
<p>The filepath of an image to be added to the plot, for example to show a screenshot of the task.</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_res">res</code></td>
<td>
<p>resolution of the display to be shown, as a vector (xmin, xmax, ymin, ymax)</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_flip_y">flip_y</code></td>
<td>
<p>reverse the y axis coordinates (useful if origin is top of the screen)</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_plot_header">plot_header</code></td>
<td>
<p>display the header title text which explains graphical features of the plot.</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_bin_time">bin_time</code></td>
<td>
<p>if wanting to split data into bins, the time (in ms) for each bin of data to be displayed</p>
</td></tr>
<tr><td><code id="plot_seq_+3A_bin_range">bin_range</code></td>
<td>
<p>if wanting to split data into bins, the first and last bin to be display, e.g., c(1,5)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the raw data representing changes over time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- combine_eyes(HCL)

# plot the raw data
plot_seq(data = data[data$pNum == 118,])

# with AOIs
plot_seq(data = data[data$pNum == 118,], AOIs = HCL_AOIs)

# plot raw data with bins
plot_seq(data = data[data$pNum == 118,], bin_time = 500)

</code></pre>

<hr>
<h2 id='plot_spatial'>Plot raw data and fixations</h2><span id='topic+plot_spatial'></span>

<h3>Description</h3>

<p>A tool for visualising raw eye-data, processed fixations, and saccades. Can use all three data types together and independently. Fixations can be labeled
in the order they were made. Can overlay areas of interest (AOIs) and customise the resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spatial(
  raw_data = NULL,
  fix_data = NULL,
  sac_data = NULL,
  AOIs = NULL,
  trial_number = NULL,
  bg_image = NULL,
  res = c(0, 1920, 0, 1080),
  flip_y = FALSE,
  show_fix_order = TRUE,
  plot_header = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_spatial_+3A_raw_data">raw_data</code></td>
<td>
<p>data in standard raw data form (time, x, y, trial)</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_fix_data">fix_data</code></td>
<td>
<p>data output from fixation function</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_sac_data">sac_data</code></td>
<td>
<p>data output from saccade function</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_aois">AOIs</code></td>
<td>
<p>A dataframe of areas of interest (AOIs), with one row per AOI (x, y, width_radius, height). If using circular AOIs, then the 3rd column is used for the radius and the height should be set to NA.</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_trial_number">trial_number</code></td>
<td>
<p>can be used to select particular trials within the data</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_bg_image">bg_image</code></td>
<td>
<p>The filepath of an image to be added to the plot, for example to show a screenshot of the task.</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_res">res</code></td>
<td>
<p>resolution of the display to be shown, as a vector (xmin, xmax, ymin, ymax)</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_flip_y">flip_y</code></td>
<td>
<p>reverse the y axis coordinates (useful if origin is top of the screen)</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_show_fix_order">show_fix_order</code></td>
<td>
<p>label the fixations in the order they were made</p>
</td></tr>
<tr><td><code id="plot_spatial_+3A_plot_header">plot_header</code></td>
<td>
<p>display the header title text which explains graphical features of the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the raw data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data &lt;- combine_eyes(HCL)
data &lt;- data[data$pNum == 118,]
# plot the raw data
plot_spatial(raw_data = data)

# plot both raw and fixation data together
plot_spatial(raw_data = data, fix_data = fixation_dispersion(data))

#plot one trial
plot_spatial(raw_data = data, fix_data = fixation_dispersion(data), trial_number = 1)


</code></pre>

<hr>
<h2 id='saccade_VTI'>Velocity threshold identification of saccades</h2><span id='topic+saccade_VTI'></span>

<h3>Description</h3>

<p>Use the velocity threshold algorithm from Salvucci &amp; Goldberg (1996) to determine saccadic eye movements.
Returns a summary of the saccades found per trial, including start and end coordinates, timing, duration, mean velocity, and peak velocity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saccade_VTI(
  data,
  sample_rate = NULL,
  threshold = 150,
  min_dur = 20,
  participant_ID = "participant_ID"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saccade_VTI_+3A_data">data</code></td>
<td>
<p>A dataframe with raw data (time, x, y, trial) for one participant</p>
</td></tr>
<tr><td><code id="saccade_VTI_+3A_sample_rate">sample_rate</code></td>
<td>
<p>sample rate of the eye-tracker. If default of NULL, then it will be computed from the timestamp data and the number of samples</p>
</td></tr>
<tr><td><code id="saccade_VTI_+3A_threshold">threshold</code></td>
<td>
<p>velocity threshold (degrees of VA / sec) to be used for identifying saccades</p>
</td></tr>
<tr><td><code id="saccade_VTI_+3A_min_dur">min_dur</code></td>
<td>
<p>minimum duration (ms) expected for saccades. This helps to avoid identification of very short saccades occurring at the boundary of velocity threshold</p>
</td></tr>
<tr><td><code id="saccade_VTI_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a data frame giving the saccades found by trial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- combine_eyes(HCL)
saccade_VTI(data, participant_ID = "pNum")
</code></pre>

<hr>
<h2 id='smoother'>Smoothing of raw data</h2><span id='topic+smoother'></span>

<h3>Description</h3>

<p>A wrapper for the stats::loess function, with default parameters suitable for smoothing raw eye data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoother(data, span = 0.1, plot = FALSE, participant_ID = "participant_ID")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smoother_+3A_data">data</code></td>
<td>
<p>A dataframe with raw data (time, x, y, trial) for one participant</p>
</td></tr>
<tr><td><code id="smoother_+3A_span">span</code></td>
<td>
<p>From stats::loess. The parameter alpha which controls the degree of smoothing.</p>
</td></tr>
<tr><td><code id="smoother_+3A_plot">plot</code></td>
<td>
<p>whether to plot the raw and smoothed plot for inspection</p>
</td></tr>
<tr><td><code id="smoother_+3A_participant_id">participant_ID</code></td>
<td>
<p>the variable that determines the participant identifier. If no column present, assumes a single participant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can take either single participant data or multiple participants where there is a variable for unique participant identification.
The function looks for an identifier named <code>participant_ID</code> by default and will treat this as multiple-participant data as default,
if not it is handled as single participant data, or the participant_ID needs to be specified
</p>


<h3>Value</h3>

<p>a dataframe of the same shape as the input data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- combine_eyes(HCL)

smoother(data, participant_ID = "pNum")

#with an inspection plot
smoother(data, span = .02, participant_ID = "pNum", plot = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
