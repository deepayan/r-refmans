<!DOCTYPE html><html><head><title>Help for package dunlin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dunlin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_whisker'><p>Add whisker values</p></a></li>
<li><a href='#as.list.rule'><p>Convert Rule to List</p></a></li>
<li><a href='#assert_all_tablenames'><p>Assert that all names are among names of a <code>list</code> of <code>data.frame</code>.</p></a></li>
<li><a href='#assert_one_tablenames'><p>Assert that at least one name is among table names of a <code>list</code> of <code>data.frame</code>.</p></a></li>
<li><a href='#assert_valid_format'><p>Assert Nested List can be used as Format Argument in Reformat.</p></a></li>
<li><a href='#assert_valid_list_format'><p>Assert List can be Converted into a Nested List Compatible with the Format Argument of Reformat.</p></a></li>
<li><a href='#attr_label'><p>Setting the Label Attribute</p></a></li>
<li><a href='#attr_label_df'><p>Setting the Label Attribute to Data Frame Columns</p></a></li>
<li><a href='#co_relevels'><p>Reorder Two Columns Levels Simultaneously</p></a></li>
<li><a href='#cut_by_group'><p>Cutting data by group</p></a></li>
<li><a href='#dunlin-package'><p><code>Dunlin</code> Package</p></a></li>
<li><a href='#get_log'><p>Get Log</p></a></li>
<li><a href='#h_df_explicit'><p>Encode Categorical Missing Values in a <code>data.frame</code>.</p></a></li>
<li><a href='#h_expand_all_datasets'><p>Propagate the rules for all datasets</p></a></li>
<li><a href='#join_adsub_adsl'><p>Join <code>adsub</code> to <code>adsl</code></p></a></li>
<li><a href='#list2rules'><p>Convert nested list into list of <code>rule</code></p></a></li>
<li><a href='#log_filter'><p>Filter Data with Log</p></a></li>
<li><a href='#ls_explicit_na'><p>Encode Categorical Missing Values in a <code>list</code> of <code>data.frame</code></p></a></li>
<li><a href='#ls_unite'><p>Unite Columns of a Table in a <code>list</code> of <code>data.frame</code>.</p></a></li>
<li><a href='#multi_id_pivot_wider'><p>Transforming data.frame with Multiple Identifying columns into Wide Format</p></a></li>
<li><a href='#poly_pivot_wider'><p>Transforming data.frame with multiple Data Column into Wide Format</p></a></li>
<li><a href='#print_log'><p>Print Log</p></a></li>
<li><a href='#propagate'><p>Propagate Column</p></a></li>
<li><a href='#reformat'><p>Reformat Values</p></a></li>
<li><a href='#remove_whisker'><p>Remove whisker values</p></a></li>
<li><a href='#render_safe'><p>Render whiskers safely</p></a></li>
<li><a href='#rule'><p>Create rule based on mappings</p></a></li>
<li><a href='#safe_transformer'><p>Safe transformer</p></a></li>
<li><a href='#show_whisker'><p>Show Whisker Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Preprocessing Tools for Clinical Trial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-04</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to preprocess data and organize
    them in a format amenable to use by chevron.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://insightsengineering.github.io/dunlin/">https://insightsengineering.github.io/dunlin/</a>,
<a href="https://github.com/insightsengineering/dunlin/">https://github.com/insightsengineering/dunlin/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/insightsengineering/dunlin/issues">https://github.com/insightsengineering/dunlin/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.1.0), dplyr (&ge; 1.1.0), forcats (&ge; 1.0.0),
glue (&ge; 1.0.0), magrittr (&ge; 1.5), methods, rlang (&ge; 1.0.0),
stringr (&ge; 1.4.1), tibble (&ge; 1.2), yaml (&ge; 2.1.15)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.42), rmarkdown (&ge; 2.19), testthat (&ge; 3.0.4),
withr (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/verdepcheck:</td>
<td>mllg/checkmate, tidyverse/dplyr,
tidyverse/forcats, tidyverse/glue, tidyverse/magrittr,
r-lib/rlang, tidyverse/stringr, tidyverse/tibble,
yaml=vubiostat/r-yaml, yihui/knitr, rstudio/rmarkdown,
r-lib/testthat, r-lib/withr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>insightsengineering/nesttemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'assertions.R' 'co_relevels.R' 'cut_by_group.R'
'dunlin-package.R' 'explicit_na.R' 'filter.R'
'join_adsub_adsl.R' 'pivot.R' 'propagate.R' 'reformat.R'
'render_safe.R' 'rules.R' 'unite.R' 'utils.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 02:38:07 UTC; lil128</td>
</tr>
<tr>
<td>Author:</td>
<td>Liming Li [aut, cre],
  Benoit Falquet [aut],
  Xiaoli Duan [ctb],
  Pawel Rucki [ctb],
  F. Hoffmann-La Roche AG [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Liming Li &lt;liming.li@roche.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_whisker'>Add whisker values</h2><span id='topic+add_whisker'></span>

<h3>Description</h3>

<p>Add whisker values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_whisker(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_whisker_+3A_x">x</code></td>
<td>
<p>Named (<code>character</code>) input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the character gives the string to be replaced and the value gives the new string.
</p>


<h3>Value</h3>

<p>invisible <code>NULL</code>. Assign the key-value pair provided as argument in the whisker environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_whiskers &lt;- c(Placeholder = "Replacement", Placeholder2 = "Replacement2")
add_whisker(my_whiskers)
</code></pre>

<hr>
<h2 id='as.list.rule'>Convert Rule to List</h2><span id='topic+as.list.rule'></span>

<h3>Description</h3>

<p>Convert Rule to List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rule'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.rule_+3A_x">x</code></td>
<td>
<p>(<code>rule</code>) to convert.</p>
</td></tr>
<tr><td><code id="as.list.rule_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rule("a" = c("a", "b"), "X" = "x", .to_NA = c("v", "w"))
as.list(x)
</code></pre>

<hr>
<h2 id='assert_all_tablenames'>Assert that all names are among names of a <code>list</code> of <code>data.frame</code>.</h2><span id='topic+assert_all_tablenames'></span>

<h3>Description</h3>

<p>Assert that all names are among names of a <code>list</code> of <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_tablenames(db, tab, null_ok = TRUE, qualifier = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_tablenames_+3A_db">db</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code>) input to check for the presence of tables.</p>
</td></tr>
<tr><td><code id="assert_all_tablenames_+3A_tab">tab</code></td>
<td>
<p>(<code>character</code>) the names of the tables to be checked.</p>
</td></tr>
<tr><td><code id="assert_all_tablenames_+3A_null_ok">null_ok</code></td>
<td>
<p>(<code>flag</code>) can <code>x</code> be NULL.</p>
</td></tr>
<tr><td><code id="assert_all_tablenames_+3A_qualifier">qualifier</code></td>
<td>
<p>(<code>string</code>) to be returned if the check fails.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>TRUE</code> or an error message if the criteria are not fulfilled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lsd &lt;- list(
  mtcars = mtcars,
  iris = iris
)
assert_all_tablenames(lsd, c("mtcars", "iris"), qualifier = "first test:")
</code></pre>

<hr>
<h2 id='assert_one_tablenames'>Assert that at least one name is among table names of a <code>list</code> of <code>data.frame</code>.</h2><span id='topic+assert_one_tablenames'></span>

<h3>Description</h3>

<p>Assert that at least one name is among table names of a <code>list</code> of <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_one_tablenames(db, tab, null_ok = TRUE, qualifier = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_one_tablenames_+3A_db">db</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code>) input to check for the presence or tables.</p>
</td></tr>
<tr><td><code id="assert_one_tablenames_+3A_tab">tab</code></td>
<td>
<p>(<code>character</code>) the names of the tables to be checked.</p>
</td></tr>
<tr><td><code id="assert_one_tablenames_+3A_null_ok">null_ok</code></td>
<td>
<p>(<code>flag</code>) can <code>x</code> be NULL.</p>
</td></tr>
<tr><td><code id="assert_one_tablenames_+3A_qualifier">qualifier</code></td>
<td>
<p>(<code>string</code>) to be returned if the check fails.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>TRUE</code> or an error message if the criteria are not fulfilled.
</p>

<hr>
<h2 id='assert_valid_format'>Assert Nested List can be used as Format Argument in Reformat.</h2><span id='topic+assert_valid_format'></span>

<h3>Description</h3>

<p>Assert Nested List can be used as Format Argument in Reformat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_valid_format(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_valid_format_+3A_object">object</code></td>
<td>
<p>(<code>list</code>) to assert.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>TRUE</code> or an error message if the criteria are not fulfilled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format &lt;- list(
  df1 = list(
    var1 = rule("X" = "x", "N" = c(NA, ""))
  ),
  df2 = list(
    var1 = rule(),
    var2 = rule("f11" = "F11", "NN" = NA)
  ),
  df3 = list()
)

assert_valid_format(format)
</code></pre>

<hr>
<h2 id='assert_valid_list_format'>Assert List can be Converted into a Nested List Compatible with the Format Argument of Reformat.</h2><span id='topic+assert_valid_list_format'></span>

<h3>Description</h3>

<p>Assert List can be Converted into a Nested List Compatible with the Format Argument of Reformat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_valid_list_format(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_valid_list_format_+3A_object">object</code></td>
<td>
<p>(<code>list</code>) to assert.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>TRUE</code> or an error message if the criteria are not fulfilled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format &lt;- list(
  df1 = list(
    var1 = list("X" = "x", "N" = c(NA, ""))
  ),
  df2 = list(
    var1 = list(),
    var2 = list("f11" = "F11", "NN" = NA)
  ),
  df3 = list()
)

assert_valid_list_format(format)
</code></pre>

<hr>
<h2 id='attr_label'>Setting the Label Attribute</h2><span id='topic+attr_label'></span>

<h3>Description</h3>

<p>Setting the Label Attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr_label(var, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr_label_+3A_var">var</code></td>
<td>
<p>(<code>object</code>) whose label attribute can be set.</p>
</td></tr>
<tr><td><code id="attr_label_+3A_label">label</code></td>
<td>
<p>(<code>character</code>) the label to add.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with label attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:10)
attr(x, "label")

y &lt;- attr_label(x, "my_label")
attr(y, "label")
</code></pre>

<hr>
<h2 id='attr_label_df'>Setting the Label Attribute to Data Frame Columns</h2><span id='topic+attr_label_df'></span>

<h3>Description</h3>

<p>Setting the Label Attribute to Data Frame Columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attr_label_df(df, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attr_label_df_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="attr_label_df_+3A_label">label</code></td>
<td>
<p>(<code>character</code>) the labels to add.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with label attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- attr_label_df(mtcars, letters[1:11])
res
lapply(res, attr, "label")
</code></pre>

<hr>
<h2 id='co_relevels'>Reorder Two Columns Levels Simultaneously</h2><span id='topic+co_relevels'></span>

<h3>Description</h3>

<p>Reorder Two Columns Levels Simultaneously
</p>


<h3>Usage</h3>

<pre><code class='language-R'>co_relevels(df, primary, secondary, levels_primary)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="co_relevels_+3A_df">df</code></td>
<td>
<p>(<code>data.frame</code>) with two column whose factors should be reordered.</p>
</td></tr>
<tr><td><code id="co_relevels_+3A_primary">primary</code></td>
<td>
<p>(<code>string</code>) the name of the column on which the levels reordering should be based.</p>
</td></tr>
<tr><td><code id="co_relevels_+3A_secondary">secondary</code></td>
<td>
<p>(<code>string</code>) the name of the column whose levels should be reordered following the levels of the
primary column.</p>
</td></tr>
<tr><td><code id="co_relevels_+3A_levels_primary">levels_primary</code></td>
<td>
<p>(<code>character</code>) the levels in the desired order. Existing levels that are not included will be
placed afterward in their current order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function expect a 1:1 matching between the elements of the two selected column.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with the <code>secondary</code> column converted to factor with reordered levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  SUBJID = 1:3,
  PARAMCD = factor(c("A", "B", "C")),
  PARAM = factor(paste("letter", LETTERS[1:3]))
)
co_relevels(df, "PARAMCD", "PARAM", levels_primary = c("C", "A", "B"))
</code></pre>

<hr>
<h2 id='cut_by_group'>Cutting data by group</h2><span id='topic+cut_by_group'></span>

<h3>Description</h3>

<p>Cutting data by group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_by_group(df, col_data, col_group, group, cat_col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_by_group_+3A_df">df</code></td>
<td>
<p>(<code>dataframe</code>) with a column of data to be cut and a column specifying the group of each observation.</p>
</td></tr>
<tr><td><code id="cut_by_group_+3A_col_data">col_data</code></td>
<td>
<p>(<code>character</code>) the column containing the data to be cut.</p>
</td></tr>
<tr><td><code id="cut_by_group_+3A_col_group">col_group</code></td>
<td>
<p>(<code>character</code>) the column containing the names of the groups according to which the data should be
split.</p>
</td></tr>
<tr><td><code id="cut_by_group_+3A_group">group</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;nested list&#8288;</code>) providing for each parameter value that should be analyzed in a categorical way: the
name of the parameter (<code>character</code>), a series of breakpoints (<code>numeric</code>) where the first breakpoints is typically
<code>-Inf</code> and the last <code>Inf</code>, and a series of name which will describe each category (<code>character</code>).</p>
</td></tr>
<tr><td><code id="cut_by_group_+3A_cat_col">cat_col</code></td>
<td>
<p>(<code>character</code>) the name of the new column in which the cut label should he stored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function used to categorize numeric data stored in long format depending on their group. Intervals are
closed on the right (and open on the left).
</p>


<h3>Value</h3>

<p><code>data.frame</code> with a column containing categorical values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>group &lt;- list(
  list(
    "Height",
    c(-Inf, 150, 170, Inf),
    c("=&lt;150", "150-170", "&gt;170")
  ),
  list(
    "Weight",
    c(-Inf, 65, Inf),
    c("=&lt;65", "&gt;65")
  ),
  list(
    "Age",
    c(-Inf, 31, Inf),
    c("=&lt;31", "&gt;31")
  ),
  list(
    "PreCondition",
    c(-Inf, 1, Inf),
    c("=&lt;1", "&lt;1")
  )
)
data &lt;- data.frame(
  SUBJECT = rep(letters[1:10], 4),
  PARAM = rep(c("Height", "Weight", "Age", "other"), each = 10),
  AVAL = c(rnorm(10, 165, 15), rnorm(10, 65, 5), runif(10, 18, 65), rnorm(10, 0, 1)),
  index = 1:40
)

cut_by_group(data, "AVAL", "PARAM", group, "my_new_categories")
</code></pre>

<hr>
<h2 id='dunlin-package'><code>Dunlin</code> Package</h2><span id='topic+dunlin'></span><span id='topic+dunlin-package'></span>

<h3>Description</h3>

<p>A collection of functions to preprocess data and organize them in a format amenable to use by chevron.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Liming Li <a href="mailto:liming.li@roche.com">liming.li@roche.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Benoit Falquet <a href="mailto:benoit.falquet@roche.com">benoit.falquet@roche.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Xiaoli Duan <a href="mailto:xiaoli.duan@roche.com">xiaoli.duan@roche.com</a> [contributor]
</p>
</li>
<li><p> Pawel Rucki <a href="mailto:pawel.rucki@roche.com">pawel.rucki@roche.com</a> [contributor]
</p>
</li>
<li><p> F. Hoffmann-La Roche AG [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://insightsengineering.github.io/dunlin/">https://insightsengineering.github.io/dunlin/</a>
</p>
</li>
<li> <p><a href="https://github.com/insightsengineering/dunlin/">https://github.com/insightsengineering/dunlin/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/insightsengineering/dunlin/issues">https://github.com/insightsengineering/dunlin/issues</a>
</p>
</li></ul>


<hr>
<h2 id='get_log'>Get Log</h2><span id='topic+get_log'></span><span id='topic+get_log.data.frame'></span><span id='topic+get_log.list'></span>

<h3>Description</h3>

<p>Get Log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_log(data, incl, incl.adsl)

## S3 method for class 'data.frame'
get_log(data, incl = TRUE, incl.adsl = TRUE)

## S3 method for class 'list'
get_log(data, incl = TRUE, incl.adsl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_log_+3A_data">data</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code> or <code>data.frame</code>) filtered with <code>log_filter</code>.</p>
</td></tr>
<tr><td><code id="get_log_+3A_incl">incl</code></td>
<td>
<p>(<code>flag</code>) should information about unfiltered <code>data.frame</code> be printed.</p>
</td></tr>
<tr><td><code id="get_log_+3A_incl.adsl">incl.adsl</code></td>
<td>
<p>(<code>flag</code>) should indication  of filtering performed through <code>adsl</code> be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> or <code style="white-space: pre;">&#8288;list of character&#8288;</code> describing the filtering applied to <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- log_filter(iris, Sepal.Length &gt;= 7, "xx")
data &lt;- log_filter(data, Sepal.Length &lt; 2)
data &lt;- log_filter(data, Sepal.Length &gt;= 2, "yy")
get_log(data)

data &lt;- log_filter(
  list(iris1 = iris, iris2 = iris),
  Sepal.Length &gt;= 7,
  "iris1",
  character(0),
  "Sep"
)
get_log(data)

</code></pre>

<hr>
<h2 id='h_df_explicit'>Encode Categorical Missing Values in a <code>data.frame</code>.</h2><span id='topic+h_df_explicit'></span>

<h3>Description</h3>

<p>Encode Categorical Missing Values in a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_df_explicit(
  df,
  omit_columns = NULL,
  char_as_factor = TRUE,
  na_level = "&lt;Missing&gt;"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_df_explicit_+3A_omit_columns">omit_columns</code></td>
<td>
<p>(<code>character</code>) the names of the columns to omit from processing.</p>
</td></tr>
<tr><td><code id="h_df_explicit_+3A_char_as_factor">char_as_factor</code></td>
<td>
<p>(<code>logical</code>) should character columns be converted into factor.</p>
</td></tr>
<tr><td><code id="h_df_explicit_+3A_na_level">na_level</code></td>
<td>
<p>(<code>string</code>) the label to encode missing levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> object with explicit missing levels.
</p>

<hr>
<h2 id='h_expand_all_datasets'>Propagate the rules for all datasets</h2><span id='topic+h_expand_all_datasets'></span>

<h3>Description</h3>

<p>Propagate the rules for all datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h_expand_all_datasets(format_list, ls_datasets = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h_expand_all_datasets_+3A_ls_datasets">ls_datasets</code></td>
<td>
<p>(<code>character</code>) the name of all datasets in the object to reformat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the rules described  under <code>all_datasets</code> are propagated to all datasets for the corresponding variables
except in datasets where a rule is already attributed to the same variable.
</p>


<h3>Value</h3>

<p>a nested <code>list</code> attributing a rule to be applied to specific variables of specific datasets.
</p>

<hr>
<h2 id='join_adsub_adsl'>Join <code>adsub</code> to <code>adsl</code></h2><span id='topic+join_adsub_adsl'></span><span id='topic+join_adsub_adsl.list'></span>

<h3>Description</h3>

<p>Join <code>adsub</code> to <code>adsl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_adsub_adsl(
  adam_db,
  keys,
  continuous_var,
  categorical_var,
  continuous_suffix,
  categorical_suffix,
  drop_na = TRUE,
  drop_lvl = TRUE
)

## S3 method for class 'list'
join_adsub_adsl(
  adam_db,
  keys = c("USUBJID", "STUDYID"),
  continuous_var = "all",
  categorical_var = "all",
  continuous_suffix = "",
  categorical_suffix = "_CAT",
  drop_na = TRUE,
  drop_lvl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_adsub_adsl_+3A_adam_db">adam_db</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code>) object input with an <code>adsl</code> and <code>adsub</code> table.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_keys">keys</code></td>
<td>
<p>(<code>character</code>) the name of the columns in <code>adsl</code> uniquely identifying a row.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_continuous_var">continuous_var</code></td>
<td>
<p>(<code>character</code>) the value of a parameter in the <code>PARAMCD</code> column of the <code>adsub</code> table from which
columns containing continuous values should be created. If <code>"all"</code>, all parameter values are selected, if <code>NULL</code>,
none are selected.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_categorical_var">categorical_var</code></td>
<td>
<p>(<code>character</code>) the value of a parameter in the <code>PARAMCD</code> column of the <code>adsub</code> table from which
columns containing categorical values should be created. If <code>"all"</code>, all parameter values are selected, if <code>NULL</code>,
none are selected.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_continuous_suffix">continuous_suffix</code></td>
<td>
<p>(<code>string</code>) the suffixes to add to the newly generated columns containing continuous values.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_categorical_suffix">categorical_suffix</code></td>
<td>
<p>(<code>string</code>) the suffixes to add to the newly generated columns containing categorical
values.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_drop_na">drop_na</code></td>
<td>
<p>(<code>logical</code>) whether resulting columns containing only <code>NAs</code> should be dropped.</p>
</td></tr>
<tr><td><code id="join_adsub_adsl_+3A_drop_lvl">drop_lvl</code></td>
<td>
<p>(<code>logical</code>) should missing levels be dropped in the resulting columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of <code>data.frame</code> with new columns in the <code>adsl</code> table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adsl &lt;- data.frame(
  USUBJID = c("S1", "S2", "S3", "S4"),
  STUDYID = "My_study",
  AGE = c(60, 44, 23, 31)
)

adsub &lt;- data.frame(
  USUBJID = c("S1", "S2", "S3", "S4", "S1", "S2", "S3"),
  STUDYID = "My_study",
  PARAM = c("weight", "weight", "weight", "weight", "height", "height", "height"),
  PARAMCD = c("w", "w", "w", "w", "h", "h", "h"),
  AVAL = c(98, 75, 70, 71, 182, 155, 152),
  AVALC = c("&gt;80", "&lt;=80", "&lt;=80", "&lt;=80", "&gt;180", "&lt;=180", "&lt;=180")
)

db &lt;- list(adsl = adsl, adsub = adsub)

x &lt;- join_adsub_adsl(adam_db = db)
x &lt;- join_adsub_adsl(adam_db = db, continuous_var = c("w", "h"), categorical_var = "h")
</code></pre>

<hr>
<h2 id='list2rules'>Convert nested list into list of <code>rule</code></h2><span id='topic+list2rules'></span>

<h3>Description</h3>

<p>Convert nested list into list of <code>rule</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2rules(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2rules_+3A_obj">obj</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;nested list&#8288;</code>) to convert into list of rules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> of <code>rule</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj &lt;- list(
  rule1 = list("X" = c("a", "b"), "Z" = "c", .to_NA = "xxxx"),
  rule2 = list(Missing = c(NA, "")),
  rule3 = list(Missing = c(NA, ""), .drop = TRUE),
  rule4 = list(Absent = c(NA, ""), .drop = TRUE, .to_NA = "yyyy")
)
list2rules(obj)

</code></pre>

<hr>
<h2 id='log_filter'>Filter Data with Log</h2><span id='topic+log_filter'></span><span id='topic+log_filter.data.frame'></span><span id='topic+log_filter.list'></span>

<h3>Description</h3>

<p>Filter Data with Log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_filter(data, condition, ...)

## S3 method for class 'data.frame'
log_filter(data, condition, suffix = NULL, ...)

## S3 method for class 'list'
log_filter(
  data,
  condition,
  table,
  by = c("USUBJID", "STUDYID"),
  suffix = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_filter_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>) input data to subset, or named (<code>list</code> of <code>data.frame</code>).</p>
</td></tr>
<tr><td><code id="log_filter_+3A_condition">condition</code></td>
<td>
<p>(<code>call</code>) of subset condition. Must evaluate as logical.</p>
</td></tr>
<tr><td><code id="log_filter_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="log_filter_+3A_suffix">suffix</code></td>
<td>
<p>(<code>string</code>) optional argument describing the filter.</p>
</td></tr>
<tr><td><code id="log_filter_+3A_table">table</code></td>
<td>
<p>(<code>string</code>) table name.</p>
</td></tr>
<tr><td><code id="log_filter_+3A_by">by</code></td>
<td>
<p>(<code>character</code>) variable names shared by <code>adsl</code> and other datasets for filtering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>log_filter</code> will filter the data/named list of data according to the <code>condition</code>.
All the variables in <code>condition</code> must exist in the data (as variables) or in the parent
frame(e.g., in global environment).
For named list of data, if <code>ADSL</code> is available, <code>log_filter</code> will also try to subset all
other datasets with <code>USUBJID</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> or <code>list</code> of <code>data.frame</code> filtered for the provided conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- iris
attr(data$Sepal.Length, "label") &lt;- "cm"
log_filter(data, Sepal.Length &gt;= 7)

log_filter(list(iris = iris), Sepal.Length &gt;= 7, "iris", character(0))
</code></pre>

<hr>
<h2 id='ls_explicit_na'>Encode Categorical Missing Values in a <code>list</code> of <code>data.frame</code></h2><span id='topic+ls_explicit_na'></span>

<h3>Description</h3>

<p>Encode Categorical Missing Values in a <code>list</code> of <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_explicit_na(
  data,
  omit_tables = NULL,
  omit_columns = NULL,
  char_as_factor = TRUE,
  na_level = "&lt;Missing&gt;"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_explicit_na_+3A_data">data</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code>) to be transformed.</p>
</td></tr>
<tr><td><code id="ls_explicit_na_+3A_omit_tables">omit_tables</code></td>
<td>
<p>(<code>character</code>) the names of the tables to omit from processing.</p>
</td></tr>
<tr><td><code id="ls_explicit_na_+3A_omit_columns">omit_columns</code></td>
<td>
<p>(<code>character</code>) the names of the columns to omit from processing.</p>
</td></tr>
<tr><td><code id="ls_explicit_na_+3A_char_as_factor">char_as_factor</code></td>
<td>
<p>(<code>logical</code>) should character columns be converted into factor.</p>
</td></tr>
<tr><td><code id="ls_explicit_na_+3A_na_level">na_level</code></td>
<td>
<p>(<code>string</code>) the label to encode missing levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper function to encode missing values (i.e <code>NA</code> and <code style="white-space: pre;">&#8288;empty string&#8288;</code>) of every <code>character</code> and
<code>factor</code> variable found in a <code>list</code> of <code>data.frame</code>. The <code>label</code> attribute of the columns is preserved.
</p>


<h3>Value</h3>

<p><code>list</code> of <code>data.frame</code> object with explicit missing levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df1 &lt;- data.frame(
  "char" = c("a", "b", NA, "a", "k", "x"),
  "char2" = c("A", "B", NA, "A", "K", "X"),
  "fact" = factor(c("f1", "f2", NA, NA, "f1", "f1")),
  "logi" = c(NA, FALSE, TRUE, NA, FALSE, NA)
)
df2 &lt;- data.frame(
  "char" = c("a", "b", NA, "a", "k", "x"),
  "fact" = factor(c("f1", "f2", NA, NA, "f1", "f1")),
  "num" = c(1:5, NA)
)
df3 &lt;- data.frame(
  "char" = c(NA, NA, "A")
)

db &lt;- list(df1 = df1, df2 = df2, df3 = df3)

ls_explicit_na(db)
ls_explicit_na(db, omit_tables = "df3", omit_columns = "char2")

</code></pre>

<hr>
<h2 id='ls_unite'>Unite Columns of a Table in a <code>list</code> of <code>data.frame</code>.</h2><span id='topic+ls_unite'></span>

<h3>Description</h3>

<p>Unite Columns of a Table in a <code>list</code> of <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_unite(adam_db, tab, cols, sep = ".", new = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_unite_+3A_adam_db">adam_db</code></td>
<td>
<p>(<code>list</code> of <code>data.frames</code>) to be transformed.</p>
</td></tr>
<tr><td><code id="ls_unite_+3A_tab">tab</code></td>
<td>
<p>(<code>string</code>) the name of a table in the <code>adam_db</code> object.</p>
</td></tr>
<tr><td><code id="ls_unite_+3A_cols">cols</code></td>
<td>
<p>(<code>character</code>) the name of the columns to unite.</p>
</td></tr>
<tr><td><code id="ls_unite_+3A_sep">sep</code></td>
<td>
<p>(<code>string</code>) the separator for the new column name.</p>
</td></tr>
<tr><td><code id="ls_unite_+3A_new">new</code></td>
<td>
<p>(<code>string</code>) the name of the new column. If <code>NULL</code> the concatenation of <code>cols</code> separated by <code>sep</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> of <code>data.frames</code> object with a united column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- list(mtcars = mtcars, iris = iris)

x &lt;- ls_unite(db, "mtcars", c("mpg", "hp"), new = "FUSION")
x$mtcars
</code></pre>

<hr>
<h2 id='multi_id_pivot_wider'>Transforming data.frame with Multiple Identifying columns into Wide Format</h2><span id='topic+multi_id_pivot_wider'></span>

<h3>Description</h3>

<p>Transforming data.frame with Multiple Identifying columns into Wide Format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_id_pivot_wider(
  data,
  id,
  param_from,
  value_from,
  drop_na = FALSE,
  drop_lvl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_id_pivot_wider_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>) to be pivoted.</p>
</td></tr>
<tr><td><code id="multi_id_pivot_wider_+3A_id">id</code></td>
<td>
<p>(<code>character</code>) the name of the columns whose combination uniquely identify the observations.</p>
</td></tr>
<tr><td><code id="multi_id_pivot_wider_+3A_param_from">param_from</code></td>
<td>
<p>(<code>character</code>) the name of the column containing the names of the parameters to be pivoted. The
unique values in this column will become column names in the output.</p>
</td></tr>
<tr><td><code id="multi_id_pivot_wider_+3A_value_from">value_from</code></td>
<td>
<p>(<code>character</code>) the name of the column containing the values that will populate the output.</p>
</td></tr>
<tr><td><code id="multi_id_pivot_wider_+3A_drop_na">drop_na</code></td>
<td>
<p>(<code>logical</code>) should column containing only <code>NAs</code> be dropped.</p>
</td></tr>
<tr><td><code id="multi_id_pivot_wider_+3A_drop_lvl">drop_lvl</code></td>
<td>
<p>(<code>logical</code>) should missing levels be dropped in the columns coming from (<code>value_from</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to identify observations on the basis of several columns. Warning: Instead of nesting
duplicated values, the function will throw an error if the same parameter is provided twice for the same
observation.
</p>


<h3>Value</h3>

<p><code>data.frame</code> in a wide format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_data &lt;- data.frame(
  the_obs = c("A", "A", "A", "B", "B", "B", "C", "D"),
  the_obs2 = c("Ax", "Ax", "Ax", "Bx", "Bx", "Bx", "Cx", "Dx"),
  the_param = c("weight", "height", "gender", "weight", "gender", "height", "height", "other"),
  the_val = c(65, 165, "M", 66, "F", 166, 155, TRUE)
)

multi_id_pivot_wider(test_data, c("the_obs", "the_obs2"), "the_param", "the_val")
multi_id_pivot_wider(test_data, "the_obs2", "the_param", "the_val")
</code></pre>

<hr>
<h2 id='poly_pivot_wider'>Transforming data.frame with multiple Data Column into Wide Format</h2><span id='topic+poly_pivot_wider'></span>

<h3>Description</h3>

<p>Transforming data.frame with multiple Data Column into Wide Format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_pivot_wider(
  data,
  id,
  param_from,
  value_from,
  labels_from = NULL,
  drop_na = TRUE,
  drop_lvl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_pivot_wider_+3A_data">data</code></td>
<td>
<p>(<code>data.frame</code>) to be pivoted.</p>
</td></tr>
<tr><td><code id="poly_pivot_wider_+3A_id">id</code></td>
<td>
<p>(<code>character</code>) the name of the columns whose combination uniquely identify the observations.</p>
</td></tr>
<tr><td><code id="poly_pivot_wider_+3A_param_from">param_from</code></td>
<td>
<p>(<code>character</code>) the name of the columns containing the names of the parameters to be pivoted. The
unique values in this column will become column names in the output.</p>
</td></tr>
<tr><td><code id="poly_pivot_wider_+3A_value_from">value_from</code></td>
<td>
<p>(<code>character</code>) the name of the column containing the values that will populate the output.</p>
</td></tr>
<tr><td><code id="poly_pivot_wider_+3A_labels_from">labels_from</code></td>
<td>
<p>(<code>character</code>) the name of the column congaing the labels of the new columns. from. If not
provided, the labels will be equal to the column names. When several labels are available for the same column, the
first one will be selected.</p>
</td></tr>
<tr><td><code id="poly_pivot_wider_+3A_drop_na">drop_na</code></td>
<td>
<p>(<code>logical</code>) should column containing only <code>NAs</code> be dropped.</p>
</td></tr>
<tr><td><code id="poly_pivot_wider_+3A_drop_lvl">drop_lvl</code></td>
<td>
<p>(<code>logical</code>) should missing levels be dropped in the columns coming from <code>value_from</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is adapted to cases where the data are distributed in several columns while the name of the
parameter is in one. Typical example is <code>adsub</code> where numeric data are stored in <code>AVAL</code> while categorical data are
in <code>AVALC</code>.
</p>


<h3>Value</h3>

<p><code>list</code> of <code>data.frame</code> in a wide format with label attribute attached to each columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_data &lt;- data.frame(
  the_obs = c("A", "A", "A", "B", "B", "B", "C", "D"),
  the_obs2 = c("Ax", "Ax", "Ax", "Bx", "Bx", "Bx", "Cx", "Dx"),
  the_param = c("weight", "height", "gender", "weight", "gender", "height", "height", "other"),
  the_label = c(
    "Weight (Kg)", "Height (cm)", "Gender", "Weight (Kg)",
    "Gender", "Height (cm)", "Height (cm)", "Pre-condition"
  ),
  the_val = c(65, 165, NA, 66, NA, 166, 155, NA),
  the_val2 = c(65, 165, "M", 66, "F", 166, 155, TRUE)
)

x &lt;- poly_pivot_wider(
  test_data,
  c("the_obs", "the_obs2"),
  "the_param",
  c("the_val", "the_val2"),
  "the_label"
)
x
Reduce(function(u, v) merge(u, v, all = TRUE), x)
</code></pre>

<hr>
<h2 id='print_log'>Print Log</h2><span id='topic+print_log'></span><span id='topic+print_log.data.frame'></span><span id='topic+print_log.list'></span>

<h3>Description</h3>

<p>Print Log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_log(data, incl, incl.adsl)

## S3 method for class 'data.frame'
print_log(data, incl = TRUE, incl.adsl = TRUE)

## S3 method for class 'list'
print_log(data, incl = TRUE, incl.adsl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_log_+3A_data">data</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code> or <code>data.frame</code>) filtered with <code>log_filter</code>.</p>
</td></tr>
<tr><td><code id="print_log_+3A_incl">incl</code></td>
<td>
<p>(<code>flag</code>) should information about unfiltered <code>data.frame</code> be printed.</p>
</td></tr>
<tr><td><code id="print_log_+3A_incl.adsl">incl.adsl</code></td>
<td>
<p>(<code>flag</code>) should indication  of filtering performed through <code>adsl</code> be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. Print a description of the filtering applied to <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- log_filter(iris, Sepal.Length &gt;= 7, "Sep")
print_log(data)
data &lt;- log_filter(
  list(
    adsl = iris,
    iris2 = iris,
    mtcars = mtcars,
    iris3 = iris
  ),
  Sepal.Length &gt;= 7,
  "adsl",
  character(0),
  "adsl filter"
)
data &lt;- log_filter(data, Sepal.Length &gt;= 7, "iris2", character(0), "iris2 filter")
print_log(data)
print_log(data, incl = FALSE)
print_log(data, incl.adsl = FALSE, incl = FALSE)
</code></pre>

<hr>
<h2 id='propagate'>Propagate Column</h2><span id='topic+propagate'></span><span id='topic+propagate.list'></span>

<h3>Description</h3>

<p><code>propagate</code>copy columns from a given table of a <code>list</code> of <code>data.frame</code> to all tables based on other
common columns. If several rows are associated with the same key, the rows will be duplicated in the receiving
tables. In safe mode, the key must be unique in the original table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagate(db, from, add, by, safe = TRUE)

## S3 method for class 'list'
propagate(db, from, add, by, safe = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagate_+3A_db">db</code></td>
<td>
<p>(<code>list</code> of <code>data.frame</code>) object for which some variable need to be propagated.</p>
</td></tr>
<tr><td><code id="propagate_+3A_from">from</code></td>
<td>
<p>(<code>string</code>) the name of the table where the variables to propagate are stored.</p>
</td></tr>
<tr><td><code id="propagate_+3A_add">add</code></td>
<td>
<p>(<code>character</code>) the names of the variables to propagate.</p>
</td></tr>
<tr><td><code id="propagate_+3A_by">by</code></td>
<td>
<p>(<code>character</code>) the key binding the <code>from</code> table to the other tables.</p>
</td></tr>
<tr><td><code id="propagate_+3A_safe">safe</code></td>
<td>
<p>(<code>flag</code>) should the key be checked for uniqueness in the <code>from</code> table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated <code>list</code> of <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  id1 = c("a", "a", "c", "d", "e", "f"),
  id2 = c("A", "B", "A", "A", "A", "A"),
  int = c(1, 2, 3, 4, 5, 6),
  bool = c(TRUE, FALSE, TRUE, FALSE, TRUE, FALSE)
)

df2 &lt;- data.frame(
  id1 = c("a", "a", "d", "e", "f", "g"),
  id2 = c("A", "B", "A", "A", "A", "A")
)

df3 &lt;- data.frame(
  id1 = c("a", "c", "d", "e", "f", "x"),
  id2 = c("A", "A", "A", "A", "B", "A"),
  int = c(11, 22, 33, 44, 55, 66)
)

db &lt;- list(df1 = df1, fd2 = df2, df3 = df3)
propagate(db, from = "df1", add = c("int", "bool"), by = c("id1", "id2"))

</code></pre>

<hr>
<h2 id='reformat'>Reformat Values</h2><span id='topic+reformat'></span><span id='topic+reformat.default'></span><span id='topic+reformat.character'></span><span id='topic+reformat.factor'></span><span id='topic+reformat.list'></span>

<h3>Description</h3>

<p>Reformat Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformat(obj, ...)

## Default S3 method:
reformat(obj, format, ...)

## S3 method for class 'character'
reformat(obj, format, ...)

## S3 method for class 'factor'
reformat(obj, format, ...)

## S3 method for class 'list'
reformat(obj, format, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reformat_+3A_obj">obj</code></td>
<td>
<p>(<code>character</code>, <code>factor</code> or <code style="white-space: pre;">&#8288;list of data.frame&#8288;</code>) to reformat.</p>
</td></tr>
<tr><td><code id="reformat_+3A_...">...</code></td>
<td>
<p>for compatibility between methods and pass additional special mapping to transform rules.
</p>

<ul>
<li> <p><code>.string_as_fct</code> (<code>flag</code>) whether the reformatted character object should be converted to factor.
</p>
</li>
<li> <p><code>.to_NA</code> (<code>character</code>) values that should be converted to <code>NA</code>. For <code>factor</code>, the corresponding levels are
dropped. If <code>NULL</code>, the argument will be taken from the <code>to_NA</code>attribute of the rule.
</p>
</li>
<li> <p><code>.drop</code> (<code>flag</code>) whether to drop empty levels. If <code>NULL</code>, the argument will be taken from the <code>drop</code>attribute of
the rule.
</p>
</li>
<li> <p><code>.na_last</code> (<code>flag</code>) whether the level replacing <code>NA</code> should be last.
</p>
</li></ul>
</td></tr>
<tr><td><code id="reformat_+3A_format">format</code></td>
<td>
<p>(<code>rule</code>) or (<code>list</code>) of <code>rule</code> depending on the class of obj.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(<code>character</code>, <code>factor</code> or <code style="white-space: pre;">&#8288;list of data.frame&#8288;</code>) with remapped values.
</p>


<h3>Note</h3>

<p>When the rule is empty rule or when values subject to reformatting are absent from the object, no error is
raised. The conversion to factor if <code>.string_as_fct = TRUE</code>) is still carried out. The conversion of the levels
declared in <code>.to_NA</code> to <code>NA</code> values occurs after the remapping. <code>NA</code> values created this way are not affected by a
rule declaring a remapping of <code>NA</code> values. For factors, level dropping is the last step, hence, levels converted to
<code>NA</code> by the <code>.to_NA</code> argument, will be removed if <code>.drop</code> is <code>TRUE</code>. Arguments passed via <code>reformat</code> override the
ones defined during rule creation.
</p>
<p>the variables listed under the <code>all_dataset</code> keyword will be reformatted with the corresponding rule in every
data set except where another rule is specified for the same variable under a specific data set name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Reformatting of character.
obj &lt;- c("a", "b", "x", NA, "")
attr(obj, "label") &lt;- "my label"
format &lt;- rule("A" = "a", "NN" = NA)

reformat(obj, format)
reformat(obj, format, .string_as_fct = FALSE, .to_NA = NULL)


# Reformatting of factor.
obj &lt;- factor(c("first", "a", "aa", "b", "x", NA), levels = c("first", "x", "b", "aa", "a", "z"))
attr(obj, "label") &lt;- "my label"
format &lt;- rule("A" = c("a", "aa"), "NN" = c(NA, "x"), "Not_present" = "z", "Not_a_level" = "P")

reformat(obj, format)
reformat(obj, format, .na_last = FALSE, .to_NA = "b", .drop = FALSE)


# Reformatting of list of data.frame.
df1 &lt;- data.frame(
  var1 = c("a", "b", NA),
  var2 = factor(c("F1", "F2", NA))
)

df2 &lt;- data.frame(
  var1 = c("x", NA, "y"),
  var2 = factor(c("F11", NA, "F22"))
)

db &lt;- list(df1 = df1, df2 = df2)

format &lt;- list(
  df1 = list(
    var1 = rule("X" = "x", "N" = NA, .to_NA = "b")
  ),
  df2 = list(
    var2 = rule("f11" = "F11", "NN" = NA)
  ),
  all_datasets = list(
    var1 = rule("xx" = "x", "aa" = "a")
  )
)

reformat(db, format)
</code></pre>

<hr>
<h2 id='remove_whisker'>Remove whisker values</h2><span id='topic+remove_whisker'></span>

<h3>Description</h3>

<p>Remove whisker values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_whisker(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_whisker_+3A_x">x</code></td>
<td>
<p>Named (<code>character</code>) input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible <code>NULL</code>. Removes <code>x</code> from the whisker environment.
</p>

<hr>
<h2 id='render_safe'>Render whiskers safely</h2><span id='topic+render_safe'></span>

<h3>Description</h3>

<p>Render whiskers safely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_safe(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="render_safe_+3A_x">x</code></td>
<td>
<p>(<code>character</code>) input to be rendered safely.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> with substituted placeholders.
</p>


<h3>Note</h3>

<p>The strings enclosed in <code>{}</code> are substituted using the key-values pairs set with <code>add_whiskers</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>render_safe("Name of {Patient_label}")
</code></pre>

<hr>
<h2 id='rule'>Create rule based on mappings</h2><span id='topic+rule'></span>

<h3>Description</h3>

<p>Create rule based on mappings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule(
  ...,
  .lst = list(...),
  .string_as_fct = TRUE,
  .na_last = TRUE,
  .drop = FALSE,
  .to_NA = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rule_+3A_...">...</code></td>
<td>
<p>Mapping pairs, the argument name is the transformed while
its values are original values.</p>
</td></tr>
<tr><td><code id="rule_+3A_.lst">.lst</code></td>
<td>
<p>(<code>list</code>) of mapping.</p>
</td></tr>
<tr><td><code id="rule_+3A_.string_as_fct">.string_as_fct</code></td>
<td>
<p>(<code>flag</code>) whether to convert characters to factors.</p>
</td></tr>
<tr><td><code id="rule_+3A_.na_last">.na_last</code></td>
<td>
<p>(<code>flag</code>)  whether the level replacing <code>NA</code> should be last.</p>
</td></tr>
<tr><td><code id="rule_+3A_.drop">.drop</code></td>
<td>
<p>(<code>flag</code>) whether to drop empty levels.</p>
</td></tr>
<tr><td><code id="rule_+3A_.to_na">.to_NA</code></td>
<td>
<p>(<code>character</code>) values that should be converted to <code>NA</code>. Set to <code>NULL</code> if nothing should be converted to
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>rule</code> object.
</p>


<h3>Note</h3>

<p>Conversion to <code>NA</code> is the last step of the remapping process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rule("X" = "x", "Y" = c("y", "z"))
rule("X" = "x", "Y" = c("y", "z"), .drop = TRUE, .to_NA = c("a", "b"), .na_last = FALSE)

</code></pre>

<hr>
<h2 id='safe_transformer'>Safe transformer</h2><span id='topic+safe_transformer'></span>

<h3>Description</h3>

<p>Safe transformer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safe_transformer(text, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safe_transformer_+3A_text">text</code></td>
<td>
<p>(<code>string</code>) to be substituted.</p>
</td></tr>
<tr><td><code id="safe_transformer_+3A_envir">envir</code></td>
<td>
<p>(<code>environment</code>) containing key-value pairs describing the substitution to perform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtain content in global environment by default.
If not found, use the environment here. The function first looks for an exact match. If not found, it searches for a
match in lower case then apply to the result the same case as the original value.
</p>


<h3>Value</h3>

<p><code>string</code> with substituted placeholders.
</p>

<hr>
<h2 id='show_whisker'>Show Whisker Values</h2><span id='topic+show_whisker'></span>

<h3>Description</h3>

<p>Show Whisker Values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_whisker()
</code></pre>


<h3>Value</h3>

<p>invisible <code>NULL</code>. Prints the values stored in the whisker environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show_whisker()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
