<!DOCTYPE html><html lang="en"><head><title>Help for package rangr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rangr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rangr-package'><p>rangr: Mechanistic Simulation of Species Range Dynamics</p></a></li>
<li><a href='#disp'><p>Simulating Dispersal</p></a></li>
<li><a href='#get_observations'><p>Observation Process</p></a></li>
<li><a href='#growth'><p>Population Growth Functions</p></a></li>
<li><a href='#initialise'><p>Prepare Data Required To Perform A Simulation</p></a></li>
<li><a href='#K_big_lon_lat.tif'><p>Example Of Carrying Capacity Map (Big)</p></a></li>
<li><a href='#K_big.tif'><p>Example Of Carrying Capacity Map (Big)</p></a></li>
<li><a href='#K_get_interpolation'><p>Prepare Time-Varying Carrying Capacity Maps</p></a></li>
<li><a href='#K_small_changing_lon_lat.tif'><p>Example Of Changing Carrying Capacity Maps (Small)</p></a></li>
<li><a href='#K_small_changing.tif'><p>Example Of Changing Carrying Capacity Maps (Small)</p></a></li>
<li><a href='#K_small_lon_lat.tif'><p>Example Of Carrying Capacity Map (Small)</p></a></li>
<li><a href='#K_small.tif'><p>Example Of Carrying Capacity Map (Small)</p></a></li>
<li><a href='#n1_big_lon_lat.tif'><p>Example Of Abundance Map At First Time Step Of The Simulation (Big)</p></a></li>
<li><a href='#n1_big.tif'><p>Example Of Abundance Map At First Time Step Of The Simulation (Big)</p></a></li>
<li><a href='#n1_small_lon_lat.tif'><p>Example Of Abundance Map At First Time Step Of The Simulation (Small)</p></a></li>
<li><a href='#n1_small.tif'><p>Example Of Abundance Map At First Time Step Of The Simulation (Small)</p></a></li>
<li><a href='#observations_points'><p>Example Of Observation Points List</p></a></li>
<li><a href='#plot.sim_results'><p>Plot <code>sim_results</code> Object</p></a></li>
<li><a href='#print.sim_data'><p>Print <code>sim_data</code> Object</p></a></li>
<li><a href='#print.sim_results'><p>Print <code>sim_results</code> Object</p></a></li>
<li><a href='#print.summary.sim_data'><p>Print <code>summary.sim_data</code> Object</p></a></li>
<li><a href='#print.summary.sim_results'><p>Print <code>summary.sim_results</code> Object</p></a></li>
<li><a href='#sim'><p>Mechanistic Metapopulation Simulator</p></a></li>
<li><a href='#subset.sim_results'><p>Subset of Given Time Points from <code>sim_results</code> Object</p></a></li>
<li><a href='#summary.sim_data'><p>Summary Of <code>sim_data</code> Object</p></a></li>
<li><a href='#summary.sim_results'><p>Summary Of <code>sim_results</code> Object</p></a></li>
<li><a href='#to_rast'><p>Transformation <code>sim_results</code> To Raster</p></a></li>
<li><a href='#update.sim_data'><p>Update <code>sim_data</code> Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mechanistic Simulation of Species Range Dynamics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Integrates population dynamics and dispersal into a mechanistic 
  virtual species simulator. The package can be used to study the effects of 
  environmental change on population growth and range shifts. It allows for 
  simple and straightforward definition of population dynamics (including 
  positive density dependence), extensive possibilities for defining dispersal 
  kernels, and the ability to generate virtual ecologist data. Learn more about 
  the 'rangr' at <a href="https://docs.ropensci.org/rangr/">https://docs.ropensci.org/rangr/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, pbapply, grDevices, graphics, stats, utils,
zoo, terra, assertthat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), covr, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/rangr">https://github.com/ropensci/rangr</a>,
<a href="https://docs.ropensci.org/rangr/">https://docs.ropensci.org/rangr/</a>,
<a href="https://doi.org/10.1111/2041-210X.14475">https://doi.org/10.1111/2041-210X.14475</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/rangr/issues">https://github.com/ropensci/rangr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-26 19:10:48 UTC; katar</td>
</tr>
<tr>
<td>Author:</td>
<td>Katarzyna Markowska [aut, cre],
  Lechosław Kuczyński [aut],
  Tad Dallas [rev],
  Joanne Potts [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Katarzyna Markowska &lt;katarzyna.markowska@amu.edu.pl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-26 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rangr-package'>rangr: Mechanistic Simulation of Species Range Dynamics</h2><span id='topic+rangr'></span><span id='topic+rangr-package'></span>

<h3>Description</h3>

<p>Integrates population dynamics and dispersal into a mechanistic virtual species simulator. The package can be used to study the effects of environmental change on population growth and range shifts. It allows for simple and straightforward definition of population dynamics (including positive density dependence), extensive possibilities for defining dispersal kernels, and the ability to generate virtual ecologist data. Learn more about the 'rangr' at <a href="https://docs.ropensci.org/rangr/">https://docs.ropensci.org/rangr/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Katarzyna Markowska <a href="mailto:katarzyna.markowska@amu.edu.pl">katarzyna.markowska@amu.edu.pl</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Lechosław Kuczyński <a href="mailto:lechu@amu.edu.pl">lechu@amu.edu.pl</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Tad Dallas [reviewer]
</p>
</li>
<li><p> Joanne Potts [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ropensci/rangr">https://github.com/ropensci/rangr</a>
</p>
</li>
<li> <p><a href="https://docs.ropensci.org/rangr/">https://docs.ropensci.org/rangr/</a>
</p>
</li>
<li> <p><a href="https://doi.org/10.1111/2041-210X.14475">doi:10.1111/2041-210X.14475</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/rangr/issues">https://github.com/ropensci/rangr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='disp'>Simulating Dispersal</h2><span id='topic+disp'></span>

<h3>Description</h3>

<p>This function simulates dispersal for each grid cell by calculating the number
of individuals dispersing out of the cell and the number of individuals
dispersing into the cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disp(
  N_t,
  id,
  id_matrix,
  data_table,
  kernel,
  dens_dep,
  dlist,
  id_within,
  within_mask,
  border,
  planar,
  dist_resolution,
  max_dist,
  dist_bin,
  ncells_in_circle,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disp_+3A_n_t">N_t</code></td>
<td>
<p>integer matrix representing population numbers at a single time step;
NA indicates cells outside the study area</p>
</td></tr>
<tr><td><code id="disp_+3A_id">id</code></td>
<td>
<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object
(of the same size as <code>N_t</code>) with cell identifiers</p>
</td></tr>
<tr><td><code id="disp_+3A_id_matrix">id_matrix</code></td>
<td>
<p><code>id</code> in matrix format</p>
</td></tr>
<tr><td><code id="disp_+3A_data_table">data_table</code></td>
<td>
<p>matrix that contains information about all cells
in current time points</p>
</td></tr>
<tr><td><code id="disp_+3A_kernel">kernel</code></td>
<td>
<p>function defining dispersal kernel</p>
</td></tr>
<tr><td><code id="disp_+3A_dens_dep">dens_dep</code></td>
<td>
<p>character vector of length 1 specifying if the probability
of settling in a target grid cell is (case-sensitive, default <code>"K2N"</code>):
</p>

<ul>
<li><p> &quot;none&quot; - fully random,
</p>
</li>
<li><p> &quot;K&quot; - proportional to the carrying capacity of a target cell,
</p>
</li>
<li><p> &quot;K2N&quot; - density-dependent, i.e. proportional to the ratio of
carrying capacity of a target cell to the number of individuals
already present in a target cell
</p>
</li></ul>
</td></tr>
<tr><td><code id="disp_+3A_dlist">dlist</code></td>
<td>
<p>list with identifiers of target cells at a specified
distance from a focal cell</p>
</td></tr>
<tr><td><code id="disp_+3A_id_within">id_within</code></td>
<td>
<p>integer vector with identifiers of cells inside the
study area</p>
</td></tr>
<tr><td><code id="disp_+3A_within_mask">within_mask</code></td>
<td>
<p>logical matrix that specifies boundaries of the study area</p>
</td></tr>
<tr><td><code id="disp_+3A_border">border</code></td>
<td>
<p>character vector of length 1 defining how to deal
with borders (case-sensitive, default <code>"absorbing"</code>):
</p>

<ul>
<li><p> &quot;reprising&quot; - cells outside the study area are not allowed
as targets for dispersal
</p>
</li>
<li><p> &quot;absorbing&quot; - individuals that disperse outside the study area
are removed from the population
</p>
</li></ul>
</td></tr>
<tr><td><code id="disp_+3A_planar">planar</code></td>
<td>
<p>logical vector of length 1; <code>TRUE</code> if input maps are planar
rasters, <code>FALSE</code> if input maps are lon/lat rasters</p>
</td></tr>
<tr><td><code id="disp_+3A_dist_resolution">dist_resolution</code></td>
<td>
<p>integer vector of length 1; dimension of one side of
one cell of <code>id</code>; in case of an irregular grid or lon/lat raster it is
calculated during <code><a href="#topic+initialise">initialisation</a></code></p>
</td></tr>
<tr><td><code id="disp_+3A_max_dist">max_dist</code></td>
<td>
<p>distance (in the same units as used in the raster <code>id</code>)
specifying the maximum range at which identifiers of target dispersal cells
are determined in advance (see <code><a href="#topic+initialise">initialise</a></code>)</p>
</td></tr>
<tr><td><code id="disp_+3A_dist_bin">dist_bin</code></td>
<td>
<p>numeric vector of length 1 with value <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code>; in case of
an irregular grid or lon/lat raster it is
calculated during <code><a href="#topic+initialise">initialisation</a></code></p>
</td></tr>
<tr><td><code id="disp_+3A_ncells_in_circle">ncells_in_circle</code></td>
<td>
<p>numeric vector; number of cells on each distance</p>
</td></tr>
<tr><td><code id="disp_+3A_cl">cl</code></td>
<td>
<p>if simulation is done in parallel, the name of a cluster object
created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is used by <code><a href="#topic+sim">sim</a></code> internally and is not intended to be
called by the user. The parameters for this function are passed from
a <code>sim_data</code> object created by <code><a href="#topic+initialise">initialise</a></code>.
</p>
<p>Dispersal distance is expressed in original spatial units of the
<code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> provided to the <code><a href="#topic+sim">sim</a></code> function
(<code>n1_map</code> and <code>K_map</code>). However, it is internally converted to units
of the simulation (i.e. the size of a single cell) by calculating <code>round(distance/resolution)</code>. If the selected dispersal distance is
smaller than <code>resolution/2</code>, the individual
does not disperse effectively and remains in the same cell.
The dispersal rate (proportion of dispersing individuals) can be estimated
from the dispersal kernel probability function by calculating the probability
that the dispersal distance is greater than <code>resolution/2</code>.
</p>


<h3>Value</h3>

<p>The function returns a list that contains two matrices:
</p>
<p><code>em</code> - emigration matrix with the number of individuals that dispersed
from each cell
</p>
<p><code>im</code> - immigration matrix with the number of individuals that dispersed
to each cell
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)

# disp
disp_output &lt;- disp(
  N_t = sim_data$n1_map,
  id = unwrap(sim_data$id),
  id_matrix = as.matrix(unwrap(sim_data$id), wide = TRUE),
  data_table = sim_data$data_table,
  kernel = sim_data$kernel,
  dens_dep = sim_data$dens_dep,
  dlist = sim_data$dlist,
  id_within = sim_data$id_within,
  within_mask = sim_data$within_mask,
  border = sim_data$border,
  planar = sim_data$planar,
  dist_resolution = sim_data$dist_resolution,
  max_dist = sim_data$max_dist,
  dist_bin = sim_data$dist_bin,
  ncells_in_circle = sim_data$ncells_in_circle
)

# immigration and emigration matrices
names(disp_output)


</code></pre>

<hr>
<h2 id='get_observations'>Observation Process</h2><span id='topic+get_observations'></span>

<h3>Description</h3>

<p>This function simulates an observation process. It accepts the <code>sim_results</code>
object, which is generated by the <code><a href="#topic+sim">sim</a></code> function, and applies the virtual
ecologist approach on the <code>N_map</code> component of the object. The function
returns a <code>data.frame</code> with the 'observed' abundances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_observations(
  sim_data,
  sim_results,
  type = c("random_one_layer", "random_all_layers", "from_data", "monitoring_based"),
  obs_error = c("rlnorm", "rbinom"),
  obs_error_param = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_observations_+3A_sim_data">sim_data</code></td>
<td>
<p><code>sim_data</code> object from <code><a href="#topic+initialise">initialise</a></code> containing simulation
parameters</p>
</td></tr>
<tr><td><code id="get_observations_+3A_sim_results">sim_results</code></td>
<td>
<p><code>sim_results</code> object; returned by <code><a href="#topic+sim">sim</a></code> function</p>
</td></tr>
<tr><td><code id="get_observations_+3A_type">type</code></td>
<td>
<p>character vector of length 1; describes the sampling type
(case-sensitive):
</p>

<ul>
<li><p> &quot;random_one_layer&quot; - random selection of cells for which abundances
are sampled; the same set of selected cells is used across all time steps.
</p>
</li>
<li><p> &quot;random_all_layers&quot; - random selection of cells for which abundances
are sampled; a new set of cells is selected for each time step.
</p>
</li>
<li><p> &quot;from_data&quot; - user-defined selection of cells for which abundances
are sampled; the user is required to provide a <code>data.frame</code> containing
three columns: &quot;x&quot;, &quot;y&quot; and &quot;time_step&quot;.
</p>
</li>
<li><p> &quot;monitoring_based&quot; - user-defined selection of cells for which
abundances are sampled; the user is required to provide a matrix object
with two columns: &quot;x&quot; and &quot;y&quot;; the abundance from given cell is sampled
by different virtual observers in different time steps; a geometric
distribution (<code><a href="stats.html#topic+Geometric">rgeom</a></code>) is employed to define whether
a survey will be conducted by the same observer for several years or
not conducted at all.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_observations_+3A_obs_error">obs_error</code></td>
<td>
<p>character vector of length 1; type of the distribution
that defines the observation process: &quot;<code><a href="stats.html#topic+Lognormal">rlnorm</a></code>&quot; (the log
normal distribution) or &quot;<code><a href="stats.html#topic+Binomial">rbinom</a></code>&quot; (the binomial
distribution)</p>
</td></tr>
<tr><td><code id="get_observations_+3A_obs_error_param">obs_error_param</code></td>
<td>
<p>numeric vector of length 1; standard deviation
(on a log scale) of the random noise in observation process generated from
the log-normal distribution (<code><a href="stats.html#topic+Lognormal">rlnorm</a></code>) or probability of
detection (success) when the binomial distribution
(&quot;<code><a href="stats.html#topic+Binomial">rbinom</a></code>&quot;) is used.</p>
</td></tr>
<tr><td><code id="get_observations_+3A_...">...</code></td>
<td>
<p>other necessary internal parameters:
</p>

<ul>
<li> <p><code>prop</code>
</p>
<p>numeric vector of length 1; proportion of cells to be sampled
(default <code>prop = 0.1</code>);
used when <code style="white-space: pre;">&#8288;type = "random_one_layer" or "random_all_layers"&#8288;</code>,
</p>
</li>
<li> <p><code>points</code>
</p>
<p><code>data.frame</code> or <code>matrix</code> with 3 numeric columns named &quot;x&quot;, &quot;y&quot;,
and &quot;time_step&quot; containing coordinates and time steps from which
observations should be obtained; used when <code>type = "from_data"</code>,
</p>
</li>
<li> <p><code>cells_coords</code>
</p>
<p><code>data.frame</code> or <code>matrix</code> with 2 columns named &quot;x&quot; and &quot;y&quot;; survey plots
coordinates; used when <code>type = "monitoring_based"</code>
</p>
</li>
<li> <p><code>prob</code>
</p>
<p>numeric vector of length 1; a parameter defining the shape of
<code><a href="stats.html#topic+Geometric">rgeom</a></code> distribution; defines whether an observation
will be made by the same observer for several years, and whether it
will not be made at all (default <code>prob = 0.3</code>);
used when <code>type = "monitoring_based"</code>
</p>
</li>
<li> <p><code>progress_bar</code>
</p>
<p>logical vector of length 1; determines if a progress bar for observation
process should be displayed (default <code>progress_bar = FALSE</code>);
used when <code>type = "monitoring_based"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> object with geographic coordinates, time steps,
estimated abundance, observation error (if <code>obs_error_param</code> is
provided), and observer identifiers (if <code>type = "monitoring_based"</code>). If <code>type = "from_data"</code>, returned object is sorted in the same order as the input <code>points</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(terra)
n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

# prepare data
sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)

sim_1 &lt;- sim(obj = sim_data, time = 110, burn = 10)

# 1. random_one_layer
sample1 &lt;- get_observations(
  sim_data,
  sim_1,
  type = "random_one_layer",
  prop = 0.1
)

# 2. random_all_layers
sample2 &lt;- get_observations(
  sim_data,
  sim_1,
  type = "random_all_layers",
  prop = 0.15
)

# 3. from_data
sample3 &lt;- get_observations(
  sim_data,
  sim_1,
  type = "from_data",
  points = observations_points
)

# 4. monitoring_based
# define observations sites
all_points &lt;- xyFromCell(unwrap(sim_data$id), cells(unwrap(sim_data$K_map)))
sample_idx &lt;- sample(1:nrow(all_points), size = 20)
sample_points &lt;- all_points[sample_idx, ]

sample4 &lt;- get_observations(
  sim_data,
  sim_1,
  type = "monitoring_based",
  cells_coords = sample_points,
  prob = 0.3,
  progress_bar = TRUE
)

# 5. noise "rlnorm"
sample5 &lt;- get_observations(sim_data,
  sim_1,
  type = "random_one_layer",
  obs_error = "rlnorm",
  obs_error_param = log(1.2)
)

# 6. noise "rbinom"
sample6 &lt;- get_observations(sim_data,
  sim_1,
  type = "random_one_layer",
  obs_error = "rbinom",
  obs_error_param = 0.8
)



</code></pre>

<hr>
<h2 id='growth'>Population Growth Functions</h2><span id='topic+growth'></span><span id='topic+exponential'></span><span id='topic+ricker'></span><span id='topic+gompertz'></span>

<h3>Description</h3>

<p>Population growth functions are used during simulation
conducted by the <code><a href="#topic+sim">sim</a></code> function.
The user is required  to specify the name of a growth function while initialising the
<code>sim_data</code> object using <code><a href="#topic+initialise">initialise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential(x, r, ...)

ricker(x, r, K, A = NA)

gompertz(x, r, K, A = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="growth_+3A_x">x</code></td>
<td>
<p>number of individuals</p>
</td></tr>
<tr><td><code id="growth_+3A_r">r</code></td>
<td>
<p>intrinsic population growth rate</p>
</td></tr>
<tr><td><code id="growth_+3A_...">...</code></td>
<td>
<p>not used, added for compatibility reasons</p>
</td></tr>
<tr><td><code id="growth_+3A_k">K</code></td>
<td>
<p>carrying capacity</p>
</td></tr>
<tr><td><code id="growth_+3A_a">A</code></td>
<td>
<p>coefficient of Allee effect (A &lt;= 0: weak, A &gt; 0: strong, NA: none)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code> can be a vector, matrix, <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>
or any other <code>R</code> object for which basic arithmetic operations produce valid results.
These functions are intended to be used in the <code><a href="#topic+sim">sim</a></code> function, where <code>x</code>
is a matrix of the same dimensions as the <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code>
object specified in <code>n1_map</code> parameter.
</p>


<h3>Value</h3>

<p>Object of the same dimensions as <code>x</code> that contains expected number
of individuals in the next time step.
</p>


<h3>References</h3>

<p>Boukal, D. S., &amp; Berec, L. (2002). Single-species models
of the Allee effect: extinction boundaries, sex ratios and mate encounters.
Journal of Theoretical Biology, 218(3), 375-394.
<a href="https://doi.org/10.1006/jtbi.2002.3084">doi:10.1006/jtbi.2002.3084</a>
</p>
<p>Gompertz, B. (1825) On the Nature of the Function Expressive of the Law
of Human Mortality, and on a New Mode of Determining the Value of Life
Contigencies. Philosophical Transactions of the Royal Society of London,
115, 513-583. <a href="https://doi.org/10.1098/rstl.1825.0026">doi:10.1098/rstl.1825.0026</a>
</p>
<p>Ricker, W.E. (1954) Stock and Recruitment. Journal of the Fisheries
Research Board of Canada, 11, 559-623. <a href="https://doi.org/10.1139/f54-039">doi:10.1139/f54-039</a>
</p>
<p>Hostetler, J.A. and Chandler, R.B. (2015), Improved state-space models
for inference about spatial and temporal variation in abundance from
count data. Ecology, 96: 1713-1723. <a href="https://doi.org/10.1890/14-1487.1">doi:10.1890/14-1487.1</a>
</p>
<p>Courchamp, F., L. Berec and J. Gascoigne. 2008. Allee Effects in Ecology
and Conservation. Oxford University Press, New York. 256 pp. ISBN
978-0-19-857030-1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
exponential(x, r = 0.4)

ricker(x, r = 2, K = 5)
ricker(x, r = 2, K = 5, A = -5)

gompertz(x, r = 1.2, K = 5)
gompertz(x, r = 1.2, K = 5, A = 5)

</code></pre>

<hr>
<h2 id='initialise'>Prepare Data Required To Perform A Simulation</h2><span id='topic+initialise'></span>

<h3>Description</h3>

<p>This function generates a <code>sim_data</code> object containing all the necessary
information required to run a simulation by the <code><a href="#topic+sim">sim</a></code> function. The
input maps (<code>n1_map</code> and <code>K_map</code>) can be in the Cartesian or longitude/latitude
coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialise(
  n1_map,
  K_map,
  K_sd = 0,
  r,
  r_sd = 0,
  growth = "gompertz",
  A = NA,
  dens_dep = c("K2N", "K", "none"),
  border = c("reprising", "absorbing"),
  kernel_fun = "rexp",
  ...,
  max_dist = NA,
  calculate_dist = TRUE,
  dlist = NULL,
  progress_bar = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initialise_+3A_n1_map">n1_map</code></td>
<td>
<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with one layer;
population numbers in every grid cell at the first time step</p>
</td></tr>
<tr><td><code id="initialise_+3A_k_map">K_map</code></td>
<td>
<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with one layer;
carrying capacity map (if K is constant across time) or maps (if K is
time-varying)</p>
</td></tr>
<tr><td><code id="initialise_+3A_k_sd">K_sd</code></td>
<td>
<p>numeric vector of length 1 with value <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> (default 0);
this parameter can be used if additional environmental stochasticity
is required; if <code>K_sd &gt; 0</code>, random numbers are generated from a log-normal
distribution with the mean <code>K_map</code> and standard deviation <code>K_sd</code></p>
</td></tr>
<tr><td><code id="initialise_+3A_r">r</code></td>
<td>
<p>numeric vector of length 1; intrinsic population growth rate</p>
</td></tr>
<tr><td><code id="initialise_+3A_r_sd">r_sd</code></td>
<td>
<p>numeric vector of length 1 with value <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code> (default <code>0</code>);
if additional demographic stochasticity is required, <code>r_sd &gt; 0</code> is
the standard deviation for a normal distribution around <code>r</code>
(defined for each time step)</p>
</td></tr>
<tr><td><code id="initialise_+3A_growth">growth</code></td>
<td>
<p>character vector of length 1; the name of a population growth
function, either defined in <code><a href="#topic+growth">growth</a></code> or provided by
the user (case-sensitive, default <code><a href="#topic+growth">&quot;gompertz&quot;</a></code>)</p>
</td></tr>
<tr><td><code id="initialise_+3A_a">A</code></td>
<td>
<p>numeric vector of length 1; strength of the Allee effect
(see the <code><a href="#topic+growth">growth</a></code> function)</p>
</td></tr>
<tr><td><code id="initialise_+3A_dens_dep">dens_dep</code></td>
<td>
<p>character vector of length 1 specifying if the probability
of settling in a target grid cell is (case-sensitive, default <code>"K2N"</code>):
</p>

<ul>
<li><p> &quot;none&quot; - fully random,
</p>
</li>
<li><p> &quot;K&quot; - proportional to the carrying capacity of a target cell,
</p>
</li>
<li><p> &quot;K2N&quot; - density-dependent, i.e. proportional to the ratio of
carrying capacity of a target cell to the number of individuals
already present in a target cell
</p>
</li></ul>
</td></tr>
<tr><td><code id="initialise_+3A_border">border</code></td>
<td>
<p>character vector of length 1 defining how to deal
with borders (case-sensitive, default <code>"absorbing"</code>):
</p>

<ul>
<li><p> &quot;reprising&quot; - cells outside the study area are not allowed
as targets for dispersal
</p>
</li>
<li><p> &quot;absorbing&quot; - individuals that disperse outside the study area
are removed from the population
</p>
</li></ul>
</td></tr>
<tr><td><code id="initialise_+3A_kernel_fun">kernel_fun</code></td>
<td>
<p>character vector of length 1; name of a random number
generation function defining a dispersal kernel (case-sensitive,
default <code>"rexp"</code>)</p>
</td></tr>
<tr><td><code id="initialise_+3A_...">...</code></td>
<td>
<p>any parameters required by <code>kernel_fun</code></p>
</td></tr>
<tr><td><code id="initialise_+3A_max_dist">max_dist</code></td>
<td>
<p>numeric vector of length 1; maximum distance of dispersal
to pre-calculate target cells</p>
</td></tr>
<tr><td><code id="initialise_+3A_calculate_dist">calculate_dist</code></td>
<td>
<p>logical vector of length 1; determines if target cells
will be precalculated</p>
</td></tr>
<tr><td><code id="initialise_+3A_dlist">dlist</code></td>
<td>
<p>list; target cells at a specified distance calculated
for every cell within the study area</p>
</td></tr>
<tr><td><code id="initialise_+3A_progress_bar">progress_bar</code></td>
<td>
<p>logical vector of length 1; determines if progress bar
for calculating distances should be displayed</p>
</td></tr>
<tr><td><code id="initialise_+3A_quiet">quiet</code></td>
<td>
<p>logical vector of length 1; determines if messages should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most time-consuming part of computations performed by the <code><a href="#topic+sim">sim</a></code>
function is the simulation of dispersal. To speed it up, a list containing
indexes of target cells at a specified distance from a focal cell
is calculated in advance and stored in a <code>dlist</code> slot.
The <code>max_dist</code> parameter sets
the maximum distance at which this pre-calculation is performed. If <code>max_dist</code>
is <code>NULL</code>, it is set to 0.99 quantile from the <code>kernel_fun</code>.
All distance calculations are always based on metres if the input maps are
latitude/longitude. For planar input maps, distances are calculated in map
units, which are typically metres, but check the <code><a href="terra.html#topic+crs">crs()</a></code>
if in doubt.
</p>
<p>If the input maps are in the Cartesian coordinate system and the grid cells
are squares, then
the distances between cells are calculated using the <code><a href="terra.html#topic+distance">distance</a></code>
function from the <code>terra</code> package. These distances are later divided by the
resolution of the input maps.
</p>
<p>For input maps with grid cells in shapes other than squares (e.g. with
rectangular cells or longitude/latitude coordinate system), the distance
resolution is calculated by finding the shortest distance between each
&quot;queen&quot; type neighbor. All distances calculated by the <code><a href="terra.html#topic+distance">distance</a></code>
function are further divided by this distance resolution.
To avoid discontinuities in the distances at which the target cells are located,
an additional parameter <code>dist_bin</code> is calculated as half of the maximum
distance between each &quot;queen&quot; type neighbour. It is used to expand the
distances at which target cells are located from a single number to a range.
</p>
<p>NA in the input maps represents cells outside the study area.
</p>
<p>The <code><a href="#topic+K_get_interpolation">K_get_interpolation</a></code> function can be used to prepare <code>K_map</code> that changes
over time. This may be useful, when simulating environmental change or
exploring the effects of ecological disturbances.
</p>


<h3>Value</h3>

<p>Object of class <code>sim_data</code> which inherits from <code>list</code>. This object
contains all necessary information to perform a simulation using
<code><a href="#topic+sim">sim</a></code> function.
</p>


<h3>References</h3>

<p>Hijmans R (2024). terra: Spatial Data Analysis. R package version
1.7-81, <a href="https://rspatial.github.io/terra/">https://rspatial.github.io/terra/</a>, <a href="https://rspatial.org/">https://rspatial.org/</a>
</p>
<p>Solymos P, Zawadzki Z (2023). pbapply: Adding Progress Bar to '*apply' Functions. R
package version 1.7-2, <a href="https://CRAN.R-project.org/package=pbapply">https://CRAN.R-project.org/package=pbapply</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+update.sim_data">update</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# input maps
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))
K_small_changing &lt;- rast(system.file("input_maps/K_small_changing.tif",
                         package = "rangr"))
n1_small_lon_lat &lt;- rast(system.file("input_maps/n1_small_lon_lat.tif", package = "rangr"))
K_small_lon_lat &lt;- rast(system.file("input_maps/K_small_lon_lat.tif", package = "rangr"))

# basic example
sim_data_1 &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)

# example with changing environment
K_interpolated &lt;- K_get_interpolation(
  K_small_changing,
  K_time_points = c(1, 25, 50)
)

sim_data_2 &lt;- initialise(
  n1_map = n1_small,
  K_map = K_interpolated,
  r = log(2),
  rate = 1 / 1e3
)

# example with lon/lat rasters
sim_data_3 &lt;- initialise(
  n1_map = n1_small_lon_lat,
  K_map = K_small_lon_lat,
  r = log(2),
  rate = 1 / 1e3
)

# example without progress bar and messages
sim_data_4 &lt;- initialise(
  n1_map = n1_small, K_map = K_small, K_sd = 0.1, r = log(5),
  r_sd = 4, growth = "ricker", rate = 1 / 200,
  max_dist = 5000, dens_dep = "K2N", progress_bar = FALSE, quiet = TRUE
)



</code></pre>

<hr>
<h2 id='K_big_lon_lat.tif'>Example Of Carrying Capacity Map (Big)</h2><span id='topic+K_big_lon_lat.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object representing a carrying
capacity map projected to WGS 84 (CRS84) from the original raster <code>K_big</code>.
This map can be used as a carrying capacity map to <code><a href="#topic+initialise">initialise</a></code> data necessary
to perform a simulation with the <code><a href="#topic+sim">sim</a></code> function. It is compatible with the <code>n1_big_lon_lat.tif</code> raster.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 74 rows
and 125 columns containing integer values 0-25 and NA's
indicating unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example
(using spatial autocorrelation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/K_big_lon_lat.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='K_big.tif'>Example Of Carrying Capacity Map (Big)</h2><span id='topic+K_big.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object that can be used as a
carrying capacity map to <code><a href="#topic+initialise">initialise</a></code> data necessary
to perform a simulation with the <code><a href="#topic+sim">sim</a></code> function. This map is compatible
with <code><a href="#topic+n1_big.tif">n1_big.tif</a></code>.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 100 rows
and 100 columns containing integer values 0-25 and NA's indicating
unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example
(using spatial autocorrelation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/K_big.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='K_get_interpolation'>Prepare Time-Varying Carrying Capacity Maps</h2><span id='topic+K_get_interpolation'></span>

<h3>Description</h3>

<p>This function linearly interpolates values in a series of carrying
capacity maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>K_get_interpolation(K_map, K_time_points = NULL, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="K_get_interpolation_+3A_k_map">K_map</code></td>
<td>
<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with
carrying capacity maps for each <code>K_time_points</code></p>
</td></tr>
<tr><td><code id="K_get_interpolation_+3A_k_time_points">K_time_points</code></td>
<td>
<p>integer vector; time for each layer in <code>K_map</code>, should
contain unique values</p>
</td></tr>
<tr><td><code id="K_get_interpolation_+3A_time">time</code></td>
<td>
<p>integer vector of length 1; number of total time steps required
(this is defined when evoking the function <code><a href="#topic+sim">sim</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To simulate dynamic environmental scenarios (e.g. climate change, land use
change, ecological disturbance, etc.) one needs to provide time-varying
carrying capacity maps.
</p>
<p>Either <code>K_time_points</code> or the <code>time</code> parameter is needed to perform
interpolation. If the interpolation should be calculated between two carrying
capacity maps, there is no need to pass the time points, because 1 will
be set as the starting time point and <code>time</code> will be used as the ending point.
On the other hand, in the absence of the <code>time</code> argument, the maximum element
of <code>K_time_points</code> is considered to be the ending point for the interpolation.
</p>


<h3>Value</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with number of layers
equal to <code>time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small_changing &lt;- rast(system.file("input_maps/K_small_changing.tif",
package = "rangr"))

K_interpolated_01 &lt;- K_get_interpolation(
  K_small_changing,
  K_time_points = c(1, 10, 15)
)

K_two_layers &lt;- subset(
  K_small_changing,
  c(1, 2)
)
K_interpolated_02 &lt;- K_get_interpolation(
  K_two_layers,
  time = 15
)


</code></pre>

<hr>
<h2 id='K_small_changing_lon_lat.tif'>Example Of Changing Carrying Capacity Maps (Small)</h2><span id='topic+K_small_changing_lon_lat.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object representing changing carrying
capacity maps projected to WGS 84 (CRS84) from the original raster
<code>K_small_changing</code>. These maps can be used as carrying capacity maps to <code><a href="#topic+initialise">initialise</a></code>
data necessary to perform a simulation with the <code><a href="#topic+sim">sim</a></code> function. To utilise
these maps in <code><a href="#topic+initialise">initialise</a></code> the user must first use <code><a href="#topic+K_get_interpolation">K_get_interpolation</a></code>
to generate a map for every time step of the simulation. These maps are
compatible with the <code>n1_small_lon_lat.tif</code> raster.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 3 layers,
each having 12 rows and 14 columns containing integer values 0-170 and NA's indicating unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example
(using spatial autocorrelation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/K_small_changing_lon_lat.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='K_small_changing.tif'>Example Of Changing Carrying Capacity Maps (Small)</h2><span id='topic+K_small_changing.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object that can be used as carrying
capacity maps to <code><a href="#topic+initialise">initialise</a></code> data necessary to perform a simulation
with the <code><a href="#topic+sim">sim</a></code> function.
To utilise these maps in <code><a href="#topic+initialise">initialise</a></code> the user first must
use <code><a href="#topic+K_get_interpolation">K_get_interpolation</a></code> to generate a map for every time step
of the simulation.
These maps are compatible with <code><a href="#topic+n1_small.tif">n1_small.tif</a></code>.
Each subsequent map contains a virtual environment with greater
carrying capacity than the previous one.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 3 layers,
each has 15 rows and 10 columns containing integer values 0-170 and
NA's that indicates unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example
(using spatial autocorrelation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/K_small_changing.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='K_small_lon_lat.tif'>Example Of Carrying Capacity Map (Small)</h2><span id='topic+K_small_lon_lat.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object that represents a carrying
capacity map projected to WGS 84 (CRS84) from the original raster <code>K_small</code>.
This map can be used as a carrying capacity map to <code><a href="#topic+initialise">initialise</a></code> data necessary
to perform a simulation with the <code><a href="#topic+sim">sim</a></code> function. It is compatible with the <code>n1_small_lon_lat.tif</code> raster.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 12 rows
and 14 columns containing integer values 0-100 and NA's indicating unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example
(using spatial autocorrelation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/K_small_lon_lat.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='K_small.tif'>Example Of Carrying Capacity Map (Small)</h2><span id='topic+K_small.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object that can be used a carrying
capacity map to <code><a href="#topic+initialise">initialise</a></code> data necessary to perform a simulation
with the <code><a href="#topic+sim">sim</a></code> function.
This map is compatible with <code><a href="#topic+n1_small.tif">n1_small.tif</a></code>.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 15 rows
and 10 columns containing integer values 0-100 and NA's indicating
unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example
(using spatial autocorrelation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/K_small.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='n1_big_lon_lat.tif'>Example Of Abundance Map At First Time Step Of The Simulation (Big)</h2><span id='topic+n1_big_lon_lat.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object representing an abundance map
at the first time step of the simulation projected to WGS 84 (CRS84) from the
original raster <code>n1_big</code>. This map can be used as a simulation starting point
to <code><a href="#topic+initialise">initialise</a></code> data necessary to perform a simulation with the <code><a href="#topic+sim">sim</a></code>
function. It is compatible with the <code>K_big_lon_lat.tif</code> map.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 74 rows
and 125 columns containing integer values 0-50 and NA's
indicating unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/n1_big_lon_lat.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='n1_big.tif'>Example Of Abundance Map At First Time Step Of The Simulation (Big)</h2><span id='topic+n1_big.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object that can be used a
as simulation starting point to <code><a href="#topic+initialise">initialise</a></code> data necessary
to perform a simulation with the <code><a href="#topic+sim">sim</a></code> function. This map is compatible
with <code><a href="#topic+K_big.tif">K_big.tif</a></code> map.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 100 rows
and 100 columns containing integer values 0-50 and NA's
that indicates unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/n1_big.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='n1_small_lon_lat.tif'>Example Of Abundance Map At First Time Step Of The Simulation (Small)</h2><span id='topic+n1_small_lon_lat.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object representing an abundance map
at the first time step of the simulation projected to WGS 84 (CRS84) from the
original raster <code>n1_small</code>. This map can be used as a simulation starting point
to <code><a href="#topic+initialise">initialise</a></code> data necessary to perform a simulation with the <code><a href="#topic+sim">sim</a></code>
function. It is compatible with the
<code>K_small_lon_lat.tif</code> and <code>K_small_changing_lon_lat.tif</code> maps.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 12 rows
and 14 columns containing integer values 0-10 and NA's
indicating unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/n1_small_lon_lat.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='n1_small.tif'>Example Of Abundance Map At First Time Step Of The Simulation (Small)</h2><span id='topic+n1_small.tif'></span>

<h3>Description</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object that can be used a
as simulation starting point to <code><a href="#topic+initialise">initialise</a></code> data necessary
to perform a simulation with the <code><a href="#topic+sim">sim</a></code> function. This map is compatible
with <code><a href="#topic+K_small.tif">K_small.tif</a></code> and <code><a href="#topic+K_small_changing.tif">K_small_changing.tif</a></code> maps.
</p>


<h3>Format</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with 15 rows
and 10 columns containing integer values 0-10 and NA's
indicating unsuitable areas.
</p>


<h3>Source</h3>

<p>Data generated in-house to serve as an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>system.file("input_maps/n1_small.tif", package = "rangr")

</code></pre>

<hr>
<h2 id='observations_points'>Example Of Observation Points List</h2><span id='topic+observations_points'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> containing a sample input data to the function
<code><a href="#topic+get_observations">get_observations</a></code>  when <code>type</code> argument is set to &quot;from_file&quot;.
This data is compatible with <code><a href="#topic+n1_small.tif">n1_small.tif</a></code>,
<code><a href="#topic+K_small.tif">K_small.tif</a></code> and <code><a href="#topic+K_small_changing.tif">K_small_changing.tif</a></code> maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observations_points
</code></pre>


<h3>Format</h3>

<p>A data frame with 1500 rows and 3 variables:
</p>

<dl>
<dt>x</dt><dd><p>x coordinate</p>
</dd>
<dt>y</dt><dd><p>y coordinate</p>
</dd>
<dt>time_step</dt><dd><p>time_step at which the abundances should be observed</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data generated in-house to serve as an example
</p>

<hr>
<h2 id='plot.sim_results'>Plot <code>sim_results</code> Object</h2><span id='topic+plot.sim_results'></span>

<h3>Description</h3>

<p>Plots abundances obtained during simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_results'
plot(x, template = NULL, time_points = NULL, range, type, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sim_results_+3A_x">x</code></td>
<td>
<p><code>sim_results</code> object; returned by <code><a href="#topic+sim">sim</a></code></p>
</td></tr>
<tr><td><code id="plot.sim_results_+3A_template">template</code></td>
<td>
<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object;
can be used as a template to create returned object</p>
</td></tr>
<tr><td><code id="plot.sim_results_+3A_time_points">time_points</code></td>
<td>
<p>numeric vector; specifies points in time from which
plots will be generated</p>
</td></tr>
<tr><td><code id="plot.sim_results_+3A_range">range</code></td>
<td>
<p>numeric vector of length 2; range of values to be used for the
legend (if <code>type = "continuous"</code>), which by default is calculated from
the N_map slot of <code>sim_result</code> object</p>
</td></tr>
<tr><td><code id="plot.sim_results_+3A_type">type</code></td>
<td>
<p>character vector of length 1; type of map:
&quot;continuous&quot; (default), &quot;classes&quot; or &quot;interval&quot;  (case-sensitive)</p>
</td></tr>
<tr><td><code id="plot.sim_results_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="terra.html#topic+plot">terra::plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object with as many layers
as the length of <code>time_points</code> parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
sim_res &lt;- sim(sim_data, time = 10)
plot(sim_res)
plot(sim_res, template = n1_small, time_points = c(1, 10))

# plot specific area
plot(sim_res, xlim = c(4, 10), ylim = c(0, 10))
plot(sim_res, ext = c(4, 10, 0, 10))
plot(sim_res, template = n1_small, ext = c(274000, 280000, 610000, 620000))


</code></pre>

<hr>
<h2 id='print.sim_data'>Print <code>sim_data</code> Object</h2><span id='topic+print.sim_data'></span>

<h3>Description</h3>

<p>Print <code>sim_data</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sim_data_+3A_x">x</code></td>
<td>
<p><code>sim_data</code> object; returned by the <code><a href="#topic+initialise">initialise</a></code> function</p>
</td></tr>
<tr><td><code id="print.sim_data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods;
currently none specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sim_data</code> object is invisibly returned (the <code>x</code> param)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
print(sim_data)

</code></pre>

<hr>
<h2 id='print.sim_results'>Print <code>sim_results</code> Object</h2><span id='topic+print.sim_results'></span>

<h3>Description</h3>

<p>Print <code>sim_results</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_results'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sim_results_+3A_x">x</code></td>
<td>
<p><code>sim_results</code> object; returned by the <code><a href="#topic+sim">sim</a></code> function</p>
</td></tr>
<tr><td><code id="print.sim_results_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods; none specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sim_results</code> object is invisibly returned (the <code>x</code> param)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
sim_res &lt;- sim(obj = sim_data, time = 20, burn = 5)
print(sim_res)


</code></pre>

<hr>
<h2 id='print.summary.sim_data'>Print <code>summary.sim_data</code> Object</h2><span id='topic+print.summary.sim_data'></span>

<h3>Description</h3>

<p>Print <code>summary.sim_data</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.sim_data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.sim_data_+3A_x">x</code></td>
<td>
<p><code>summary.sim_data</code> object; returned by <code><a href="#topic+summary.sim_data">summary.sim_data</a></code> function</p>
</td></tr>
<tr><td><code id="print.summary.sim_data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods;
currently none specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
summary_sim_data &lt;- summary(sim_data)
print(summary_sim_data)

</code></pre>

<hr>
<h2 id='print.summary.sim_results'>Print <code>summary.sim_results</code> Object</h2><span id='topic+print.summary.sim_results'></span>

<h3>Description</h3>

<p>Print <code>summary.sim_results</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.sim_results'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.sim_results_+3A_x">x</code></td>
<td>
<p><code>summary.sim_results</code> object; returned by
<code><a href="#topic+summary.sim_results">summary.sim_results</a></code> function</p>
</td></tr>
<tr><td><code id="print.summary.sim_results_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods;
currently none specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
sim_results &lt;- sim(sim_data, time = 10)
summary_sim_results &lt;- summary(sim_results)
print(summary_sim_results)

</code></pre>

<hr>
<h2 id='sim'>Mechanistic Metapopulation Simulator</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>This function simulates population growth and dispersal providing a given
environmental scenario. All parameters for the simulation must be set
in advance using <code><a href="#topic+initialise">initialise</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim(
  obj,
  time,
  burn = 0,
  return_mu = FALSE,
  cl = NULL,
  progress_bar = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_+3A_obj">obj</code></td>
<td>
<p><code>sim_data</code> object created by <code><a href="#topic+initialise">initialise</a></code> containing all
simulation parameters and necessary data</p>
</td></tr>
<tr><td><code id="sim_+3A_time">time</code></td>
<td>
<p>positive integer vector of length 1; number of time steps
simulated</p>
</td></tr>
<tr><td><code id="sim_+3A_burn">burn</code></td>
<td>
<p>positive integer vector of length 1; the number of burn-in time
steps that are discarded from the output</p>
</td></tr>
<tr><td><code id="sim_+3A_return_mu">return_mu</code></td>
<td>
<p>logical vector of length 1; if <code>TRUE</code> demographic
process return expected values; if <code>FALSE</code> the <code><a href="stats.html#topic+Poisson">rpois</a></code> function
should be used</p>
</td></tr>
<tr><td><code id="sim_+3A_cl">cl</code></td>
<td>
<p>an optional cluster object created by
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code> needed for parallel calculations</p>
</td></tr>
<tr><td><code id="sim_+3A_progress_bar">progress_bar</code></td>
<td>
<p>logical vector of length 1 determines if progress bar
for simulation should be displayed</p>
</td></tr>
<tr><td><code id="sim_+3A_quiet">quiet</code></td>
<td>
<p>logical vector of length 1; determines if warnings should
be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main simulation module. It takes the <code>sim_data</code> object prepared
by <code><a href="#topic+initialise">initialise</a></code> and runs simulation for a given number of time steps.
The initial (specified by the <code>burn</code> parameter) time steps are skipped
and discarded from the output. Computations can be done in parallel if
the name of a cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>
is provided.
</p>
<p>Generally, at each time step, simulation consists of two phases: local
dynamics and dispersal.
</p>
<p>Local dynamics (which connects habitat patches in time) is defined by
the function <code><a href="#topic+growth">growth</a></code>. This parameter is specified while creating
the <code>obj</code> using <code><a href="#topic+initialise">initialise</a></code>, but can be later modified by using
the <code><a href="stats.html#topic+update">update</a></code> function. Population growth can be either exponential
or density-dependent, and the regulation is implemented by the use of
Gompertz or Ricker models (with a possibility of providing any other,
user defined function). For every cell, the expected population density
during the next time step is calculated from the corresponding number
of individuals currently present in this cell, and the actual number
of individuals is set by drawing a random number from the Poisson
distribution using this expected value. This procedure introduces a realistic
randomness, however additional levels of random variability can be
incorporated by providing parameters of both demographic and environmental
stochasticity while specifying the <code>sim_data</code> object using the <code><a href="#topic+initialise">initialise</a></code>
function (parameters <code>r_sd</code> and <code>K_sd</code>, respectively).
</p>
<p>To simulate dispersal (which connects habitat patches in space), for each
individual in a given cell, a dispersal distance is randomly drawn from
the dispersal kernel density function. Then, each individual is translocated
to a randomly chosen cell at this distance apart from the current location.
For more details, see the <code><a href="#topic+disp">disp</a></code> function.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>sim_results</code> which is
a list containing the following components:
</p>

<ul>
<li> <p><code>extinction</code> - <code>TRUE</code> if population is extinct or <code>FALSE</code> otherwise
</p>
</li>
<li> <p><code>simulated_time</code> - number of simulated time steps without
the burn-in ones
</p>
</li>
<li> <p><code>N_map</code> - 3-dimensional array representing spatio-temporal
variability in population numbers. The first two dimensions correspond to
the spatial aspect of the output and the third dimension represents time.
</p>
</li></ul>

<p>In case of a total extinction, a simulation is stopped before reaching
the specified number of time steps. If the population died out before reaching
the <code>burn</code> threshold, then nothing can be returned and an error occurs.
</p>


<h3>References</h3>

<p>Solymos P, Zawadzki Z (2023). pbapply: Adding Progress Bar to '*apply' Functions. R
package version 1.7-2, <a href="https://CRAN.R-project.org/package=pbapply">https://CRAN.R-project.org/package=pbapply</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_observations">get_observations</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)

# simulation
sim_1 &lt;- sim(obj = sim_data, time = 20)

# simulation with burned time steps
sim_2 &lt;- sim(obj = sim_data, time = 20, burn = 10)

# example with parallelization
library(parallel)
cl &lt;- makeCluster(2)

# parallelized simulation
sim_3 &lt;- sim(obj = sim_data, time = 20, cl = cl)
stopCluster(cl)


# visualisation
plot(
  sim_1,
  time_points = 20,
  template = sim_data$K_map
)

plot(
  sim_1,
  time_points = c(1, 5, 10, 20),
  template = sim_data$K_map
)

plot(
  sim_1,
  template = sim_data$K_map
)



</code></pre>

<hr>
<h2 id='subset.sim_results'>Subset of Given Time Points from <code>sim_results</code> Object</h2><span id='topic+subset.sim_results'></span>

<h3>Description</h3>

<p>This function creates a subset of given time points from the <code>sim_results</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_results'
subset(x, from = NULL, time_points = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subset.sim_results_+3A_x">x</code></td>
<td>
<p><code>sim_results</code> object; returned by the <code><a href="#topic+sim">sim</a></code> function</p>
</td></tr>
<tr><td><code id="subset.sim_results_+3A_from">from</code></td>
<td>
<p>numeric vector of length 1; indicates the starting time point
from which all time point should be kept</p>
</td></tr>
<tr><td><code id="subset.sim_results_+3A_time_points">time_points</code></td>
<td>
<p>numeric vector; indicates all time points to keep</p>
</td></tr>
<tr><td><code id="subset.sim_results_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>from</code> or <code>time_points</code> argument has to be specified.
Time point passed by the <code>from</code> argument will be set as a cutoff point
and all abundances for previous time points will be discarded.
</p>


<h3>Value</h3>

<p><code>sim_results</code> object with only selected <code>time_points</code> present
in the <code>N_map</code> slot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n = n1_small,
  r = log(2),
  K_map = K_small,
  max_dist = 1000,
  rate = 1 / 1e3
)

sim_results &lt;- sim(sim_data, time = 10)
summary(sim_results)

sim_results_cropped &lt;- subset(sim_results, time_points = c(1:2))
summary(sim_results_cropped)


</code></pre>

<hr>
<h2 id='summary.sim_data'>Summary Of <code>sim_data</code> Object</h2><span id='topic+summary.sim_data'></span>

<h3>Description</h3>

<p>Summary Of <code>sim_data</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_data'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sim_data_+3A_object">object</code></td>
<td>
<p><code>sim_data</code> object; returned by <code><a href="#topic+initialise">initialise</a></code> function</p>
</td></tr>
<tr><td><code id="summary.sim_data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods;
currently none specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.sim_data</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
summary(sim_data)

</code></pre>

<hr>
<h2 id='summary.sim_results'>Summary Of <code>sim_results</code> Object</h2><span id='topic+summary.sim_results'></span>

<h3>Description</h3>

<p>Summary Of <code>sim_results</code> Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_results'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sim_results_+3A_object">object</code></td>
<td>
<p><code>sim_results</code> object; returned by <code><a href="#topic+sim">sim</a></code> function</p>
</td></tr>
<tr><td><code id="summary.sim_results_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods; none specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.sim_results</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)

# simulation
sim_results &lt;- sim(sim_data, time = 10)
summary(sim_results)

</code></pre>

<hr>
<h2 id='to_rast'>Transformation <code>sim_results</code> To Raster</h2><span id='topic+to_rast'></span>

<h3>Description</h3>

<p>This function transforms selected subset of abundance matrices from
<code>sim_results</code> into <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object. Layers are
specified by <code>time_points</code>, which can be one or multiple points in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_rast(sim_results, time_points = sim_results$simulated_time, template = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_rast_+3A_sim_results">sim_results</code></td>
<td>
<p><code>sim_results</code> object created by <code><a href="#topic+sim">sim</a></code></p>
</td></tr>
<tr><td><code id="to_rast_+3A_time_points">time_points</code></td>
<td>
<p>numeric vector of length 1 or more; specifies points in
time from which <code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> will be created - as
default the last year of simulation; if <code>length(time_points) &gt; 0</code>
<code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> will be returned with layers for
each element of <code>time_points</code></p>
</td></tr>
<tr><td><code id="to_rast_+3A_template">template</code></td>
<td>
<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> object; can be used
as a template to create returned object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="terra.html#topic+SpatRaster-class">SpatRaster</a></code> based on <code>sim_results</code> object
with layers corresponding to <code>time_points</code>.
</p>


<h3>References</h3>

<p>Hijmans R (2024). terra: Spatial Data Analysis. R package version
1.7-81, <a href="https://rspatial.github.io/terra/">https://rspatial.github.io/terra/</a>, <a href="https://rspatial.org/">https://rspatial.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# data preparation
library(terra)

n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)

# simulation
sim_1 &lt;- sim(obj = sim_data, time = 100)

# raster construction
my_rast &lt;- to_rast(
  sim_1,
  time_points = c(1, 10, 20, 100),
  template = sim_data$K_map
)

# visualization
plot(my_rast, range = range(sim_1$N_map, na.rm = TRUE))



</code></pre>

<hr>
<h2 id='update.sim_data'>Update <code>sim_data</code> Object</h2><span id='topic+update.sim_data'></span>

<h3>Description</h3>

<p>This function updates a <code>sim_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_data'
update(object, ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.sim_data_+3A_object">object</code></td>
<td>
<p><code>sim_data</code> object; returned by <code><a href="#topic+initialise">initialise</a></code> function</p>
</td></tr>
<tr><td><code id="update.sim_data_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods;
currently none specified</p>
</td></tr>
<tr><td><code id="update.sim_data_+3A_evaluate">evaluate</code></td>
<td>
<p>logical vector of length 1; if <code>TRUE</code> evaluates the new call, otherwise
returns the call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>evaluate = TRUE</code> then the updated <code>sim_data</code> object,
otherwise the updated call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# data preparation
library(terra)
n1_small &lt;- rast(system.file("input_maps/n1_small.tif", package = "rangr"))
K_small &lt;- rast(system.file("input_maps/K_small.tif", package = "rangr"))

sim_data_1 &lt;- initialise(
  n1_map = n1_small,
  K_map = K_small,
  r = log(2),
  rate = 1 / 1e3
)
summary(sim_data_1)

sim_data_2 &lt;- update(sim_data_1, max_dist = 3000)
summary(sim_data_2)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
