<!DOCTYPE html><html lang="en"><head><title>Help for package MetabolSSMF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MetabolSSMF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap'><p>Bootstrap algorithm function.</p></a></li>
<li><a href='#diversity'><p>Shannon diversity index</p></a></li>
<li><a href='#fit_boot'><p>Example results of bootstrap.</p></a></li>
<li><a href='#fit_gap'><p>Example results of gap statistic.</p></a></li>
<li><a href='#fit_SSMF'><p>Example results of SSMF.</p></a></li>
<li><a href='#gap'><p>Gap statistic algorithm.</p></a></li>
<li><a href='#init'><p>Initialise the membership matrix <code class="reqn">H</code> or prototype matrix <code class="reqn">W</code>.</p></a></li>
<li><a href='#sARI'><p>Soft adjusted Rand index.</p></a></li>
<li><a href='#SimulatedDataset'><p>A simulated metabolomic dataset.</p></a></li>
<li><a href='#SimulatedMemberships'><p>A simulated membership matrix.</p></a></li>
<li><a href='#SimulatedPrototypes'><p>A simulated prototype matrix.</p></a></li>
<li><a href='#ssmf'><p>Simplex-structured matrix factorisation algorithm (SSMF).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simplex-Structured Matrix Factorisation for Metabolomics
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenxuan Liu &lt;wenxuan.liu@ucdconnect.ie&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework to perform soft clustering using 
        simplex-structured matrix factorisation (SSMF). The package contains a set of functions
        for determining the optimal number of prototypes, the optimal algorithmic
        parameters, the estimation confidence intervals and the diversity of clusters.
        Abdolali, Maryam &amp; Gillis, Nicolas (2020) &lt;<a href="https://doi.org/10.1137%2F20M1354982">doi:10.1137/20M1354982</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>LaplacesDemon, NMF, doParallel, foreach, iterators, lsei,
mclust, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, caroline, ggsci, BiocManager, Biobase</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-04 12:33:25 UTC; vincentlau</td>
</tr>
<tr>
<td>Author:</td>
<td>Wenxuan Liu [aut, cre],
  Thomas Brendan Murphy [aut],
  Lorraine Brennan [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-05 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap'>Bootstrap algorithm function.</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Bootstrap resampling approach to estimate the confidence intervals for the cluster prototypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(data, k, H, mtimes = 50, lr = 0.01, ncore = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootstrap_+3A_data">data</code></td>
<td>
<p>Data matrix or data frame.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_k">k</code></td>
<td>
<p>The number of prototypes/clusters.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_h">H</code></td>
<td>
<p>Matrix, input <code class="reqn">H</code> matrix to start the algorithm. Usually the <code class="reqn">H</code> matrix is the output of the function ssmf( ).
If <code class="reqn">H</code> is not supplied, the bootstrapped <code class="reqn">W</code> matrix might have different prototype orders from the outputs of the function ssmf( ).</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_mtimes">mtimes</code></td>
<td>
<p>Integer, number of bootstrap samples. Default number is 50.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_lr">lr</code></td>
<td>
<p>Optimisation learning rate in ssmf().</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_ncore">ncore</code></td>
<td>
<p>The number of cores to use for parallel execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create bootstrap samples of size <code class="reqn">n</code> by sampling from the data set with replacement and repeat the steps <code class="reqn">M</code> times.
The <code class="reqn">m^{th}</code> bootstrap sample is denoted as
</p>
<p style="text-align: center;"><code class="reqn">X^{{\ast}(m)}=(x_1^{{\ast}(m)}, x_2^{{\ast}(m)},\ldots,x_n^{{\ast}(m)}),</code>
</p>

<p>where each <code class="reqn">x_i^{{\ast}(m)}</code> is a random sample (with replacement) from the data set.
</p>
<p>Then, apply the SSMF algorithm to each bootstrap sample and calculate the <code class="reqn">m^{th}</code> bootstrap replicate of the prototypes matrix,
which is denoted as <code class="reqn">W^{{\ast}(m)}</code>.
</p>
<p>The estimate standard deviation of <code class="reqn">M</code> bootstrap replicates can be calculated by
</p>
<p style="text-align: center;"><code class="reqn">sd(W^{\ast}) =\sqrt {\frac{1}{M-1} \sum_{m=1}^{M} [W^{{\ast}(m)}-\overline{W}^{\ast}]^2 },</code>
</p>

<p>where <code class="reqn">\overline{W}^{\ast}=\frac{1}{M} \sum_{m=1}^{M} W^{{\ast}(m)}</code>. Therefore, the 95% CIs for the prototypes can be calculated by
</p>
<p style="text-align: center;"><code class="reqn">(\overline{W}^{\ast}-t_{(0.025, M-1)} \cdot sd(W^{\ast}),\ \overline{W}^{\ast}+t_{(0.975, M-1)} \cdot sd(W^)),</code>
</p>

<p>where <code class="reqn">t_{(0.025, n-1)}</code> and <code class="reqn">t_{(0.975, n-1)}</code> is the quantiles of student <code class="reqn">t</code> distribution with 95% significance and <code class="reqn">(M-1)</code> degrees of freedom.
</p>


<h3>Value</h3>

<p><code>W.est</code> The <code class="reqn">W</code> matrix estimated by bootstrap.
</p>
<p><code>lower</code> Lower bound of confidence intervals.
</p>
<p><code>upper</code> Upper bound of confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Wenxuan Liu
</p>


<h3>References</h3>

<p>Stine, R. (1989). An Introduction to Bootstrap Methods: Examples and Ideas. Sociological Methods &amp; Research, 18(2-3), 243-291. &lt;doi:10.1177/0049124189018002003&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code

data &lt;- SimulatedDataset

k &lt;- 4

fit &lt;- ssmf(data = data, k = k)

bootstrap(data = data , k = k, H = fit$H)

</code></pre>

<hr>
<h2 id='diversity'>Shannon diversity index</h2><span id='topic+diversity'></span>

<h3>Description</h3>

<p>Calculate the Shannon diversity index of the memberships of an observation. The base of the logarithm is 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity(x, two.power = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diversity_+3A_x">x</code></td>
<td>
<p>A membership vector.</p>
</td></tr>
<tr><td><code id="diversity_+3A_two.power">two.power</code></td>
<td>
<p>Logical, whether return to the value of <code class="reqn">2^{\mathrm{E}(h_{i})}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a membership vector of the <code class="reqn">i^{th}</code> observation <code class="reqn">h_i</code>, the Shannon diversity index is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{E}(h_{i}) = -\sum_{r=1}^k h_{ir} \mathrm{log}_2 (h_{ir}).</code>
</p>

<p>Specifically, in the case of <code class="reqn">h_{ir}=0</code>, the value of <code class="reqn">h_{ir} \mathrm{log}_2 (h_{ir})</code> is taken to be 0.
</p>


<h3>Value</h3>

<p>A numeric value of Shannon diversity index <code class="reqn">\mathrm{E}(h_{i})</code> or <code class="reqn">2^{\mathrm{E}(h_{i})}</code>.
</p>


<h3>Author(s)</h3>

<p>Wenxuan Liu
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Memberships vector
membership1 &lt;- c(0.1, 0.2, 0.3, 0.4)
diversity(membership1)
diversity(membership1, two.power = TRUE)

# Memberships matrix
membership2 &lt;- matrix(c(0.1, 0.2, 0.3, 0.4, 0.3, 0.2, 0.4, 0.1, 0.2, 0.3, 0.1, 0.4),
                      nrow=3, ncol=4, byrow=TRUE)

E &lt;- rep(NA, nrow(membership2))
for(i in 1:nrow(membership2)){
  E[i] &lt;- diversity(membership2[i,])
}
E
</code></pre>

<hr>
<h2 id='fit_boot'>Example results of bootstrap.</h2><span id='topic+fit_boot'></span>

<h3>Description</h3>

<p>A list of the results for bootstrap example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_boot
</code></pre>


<h3>Format</h3>

<p>A list of bootstrap result, including the values of estimated prototype matrix (<code class="reqn">W</code>),
the lower bound of confidence intervals and the upper bound of confidence intervals.
</p>

<hr>
<h2 id='fit_gap'>Example results of gap statistic.</h2><span id='topic+fit_gap'></span>

<h3>Description</h3>

<p>A list of the results for gap statistic example for <code class="reqn">k=1, 2, ..., 10</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_gap
</code></pre>


<h3>Format</h3>

<p>A list of gap statistic result, including the gap value vector,
the optimal number of prototypes/clusters and the Standard error vector.
</p>

<hr>
<h2 id='fit_SSMF'>Example results of SSMF.</h2><span id='topic+fit_SSMF'></span>

<h3>Description</h3>

<p>A list of the results for SSMF example for <code class="reqn">k=1, 2, ..., 10</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_SSMF
</code></pre>


<h3>Format</h3>

<p>A list with 10 items, each item is a results of SSMF,
containing the values of the estimated prototype matrix (<code class="reqn">W</code>) and
the estimated membership matrix (<code class="reqn">H</code>) matrix and the value of
the residuals sum of square (SSE).
</p>

<hr>
<h2 id='gap'>Gap statistic algorithm.</h2><span id='topic+gap'></span>

<h3>Description</h3>

<p>Estimating the number of prototypes/clusters in a data set using the gap statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gap(
  data,
  rss,
  meth = c("kmeans", "uniform", "dirichlet", "nmf"),
  itr = 50,
  lr = 0.01,
  ncore = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gap_+3A_data">data</code></td>
<td>
<p>Data matrix or data frame.</p>
</td></tr>
<tr><td><code id="gap_+3A_rss">rss</code></td>
<td>
<p>Numeric vector, residual sum of squares from ssmf model using the number of clusters <code class="reqn">1,2, \ldots, k</code>.</p>
</td></tr>
<tr><td><code id="gap_+3A_meth">meth</code></td>
<td>
<p>Character, specification of method to initialise the <code class="reqn">W</code> and <code class="reqn">H</code> matrix, see 'method' in init( ).</p>
</td></tr>
<tr><td><code id="gap_+3A_itr">itr</code></td>
<td>
<p>Integer, number of Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="gap_+3A_lr">lr</code></td>
<td>
<p>Optimisation learning rate in ssmf().</p>
</td></tr>
<tr><td><code id="gap_+3A_ncore">ncore</code></td>
<td>
<p>The number of cores to use for parallel execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This gap statistic selects the biggest difference between the original residual sum of squares (RSS) and the RSS under an appropriate null reference distribution of the data, which is defined to be
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{Gap}(k) = \frac{1}{B} \sum_{b=1}^{B} \log(\mathrm{RSS}^*_{kb}) - \log(\mathrm{RSS}_{k}),</code>
</p>

<p>where <code class="reqn">B</code> is the number of samples from the reference distribution;
<code class="reqn">\mathrm{RSS}^*_{kb}</code> is the residual sum of squares of the <code class="reqn">b^th</code> sample from the reference distribution fitted in the SSMF model model using <code class="reqn">k</code> clusters;
<code class="reqn">RSS_{k}</code> is the residual sum of squares for the original data <code class="reqn">X</code> fitted the model using the same <code class="reqn">k</code>.
The estimated gap suggests the number of prototypes/clusters (<code class="reqn">\hat{k}</code>) using
</p>
<p style="text-align: center;"><code class="reqn">\hat{k} = \mathrm{smallest} \ k \  \mathrm{such \ that} \ \mathrm{Gap}(k) \geq \mathrm{Gap}(k+1) - s_{k+1},</code>
</p>

<p>where <code class="reqn">s_{k+1}</code> is standard error that is defined as
</p>
<p style="text-align: center;"><code class="reqn">s_{k+1}=sd_k \sqrt{1+\frac{1}{B}},</code>
</p>

<p>and <code class="reqn">sd_k</code> is the standard deviation:
</p>
<p style="text-align: center;"><code class="reqn">sd_k=\sqrt{ \frac{1}{B} \sum_{b} [\log(\mathrm{RSS}^*_{kb})-\frac{1}{B} \sum_{b} \log(\mathrm{RSS}^*_{kb})]^2}.</code>
</p>



<h3>Value</h3>

<p><code>gap</code> Gap value vector.
</p>
<p><code>optimal.k</code> The optimal number of prototypes/clusters.
</p>
<p><code>standard.error</code> Standard error vector.
</p>


<h3>Author(s)</h3>

<p>Wenxuan Liu
</p>


<h3>References</h3>

<p>Tibshirani, R., Walther, G., &amp; Hastie, T. (2001). Estimating the Number of Clusters in a Data Set via the Gap Statistic. Journal of the Royal Statistical Society. Series B (Statistical Methodology), 63(2), 411–423. &lt;doi:10.1111/1467-9868.00293&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code

data &lt;- SimulatedDataset

k &lt;- 6

rss &lt;- rep(NA, k)
for(i in 1:k){
  rss[i] &lt;- ssmf(data = data, k = i)$SSE
}

gap(data = data, rss = rss)

</code></pre>

<hr>
<h2 id='init'>Initialise the membership matrix <code class="reqn">H</code> or prototype matrix <code class="reqn">W</code>.</h2><span id='topic+init'></span>

<h3>Description</h3>

<p>This function initialises the <code class="reqn">H_{n \times k}</code> matrix
or the <code class="reqn">W_{k \times p}</code> matrix to start the SSMF model.
This function is often used in conjunction with the function ssmf( ). Also, the code can be run separately from the function
ssmf( ). This function returns to simplex-structured soft membership matrix <code class="reqn">H</code> and prototype matrix <code class="reqn">W</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(
  data = NULL,
  k = NULL,
  method = c("kmeans", "uniform", "dirichlet", "nmf")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_+3A_data">data</code></td>
<td>
<p>Data matrix or data frame.</p>
</td></tr>
<tr><td><code id="init_+3A_k">k</code></td>
<td>
<p>The number of prototypes/clusters.</p>
</td></tr>
<tr><td><code id="init_+3A_method">method</code></td>
<td>
<p>Character: 'kmeans', 'uniform', 'dirichlet' or 'nmf'. If there are more than one method,
the default is selecting the first method in the vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'kmeans': create the <code class="reqn">W</code> matrix using the centres of the kmeans output; create the <code class="reqn">H</code> matrix by converting the classification into a binary matrix.
</p>
<p>'uniform': create the <code class="reqn">H</code> matrix by sampling the values from uniform distribution and making the rows of the matrix lie in the unit simplex; group the observations with their maximum memberships
and create the <code class="reqn">W</code> matrix by combining the mean vector in each group.
</p>
<p>'dirichlet': create the <code class="reqn">H</code> matrix by sampling the values from Dirichlet distribution; group the observations with their maximum memberships
and create the <code class="reqn">W</code> matrix by combining the mean vector in each group.
</p>
<p>'nmf': create the <code class="reqn">W</code> matrix using the matrix of basic components from NMF model; the coefficient matrix is acquired from NMF model,
then the <code class="reqn">H</code> is created by making the rows of the coefficient matrix lie in the unit simplex.
</p>


<h3>Value</h3>

<p>Initialised <code class="reqn">H</code>, <code class="reqn">W</code> matrix.
</p>


<h3>Author(s)</h3>

<p>Wenxuan Liu
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example code

init(data = SimulatedDataset, k = 4, method = 'kmeans')

</code></pre>

<hr>
<h2 id='sARI'>Soft adjusted Rand index.</h2><span id='topic+sARI'></span>

<h3>Description</h3>

<p>Soft adjusted Rand index, a soft agreement measure for class partitions incorporating assignment probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sARI(partition1, partition2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sARI_+3A_partition1">partition1</code></td>
<td>
<p>Numeric matrix/data frame of the probabilities of assignment of observations in partition 1 (membership matrix).</p>
</td></tr>
<tr><td><code id="sARI_+3A_partition2">partition2</code></td>
<td>
<p>Numeric matrix/data frame of the probabilities of assignment of observations in partition 2 (membership matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Soft adjusted Rand index.
</p>


<h3>Author(s)</h3>

<p>Wenxuan Liu
</p>


<h3>References</h3>

<p>Flynt, A., Dean, N. &amp; Nugent, R. (2019) sARI: a soft agreement measure for class partitions incorporating assignment probabilities. Adv Data Anal Classif 13, 303–323 (2019). &lt;doi:10.1007/s11634-018-0346-x&gt;
</p>

<hr>
<h2 id='SimulatedDataset'>A simulated metabolomic dataset.</h2><span id='topic+SimulatedDataset'></span>

<h3>Description</h3>

<p>A simulated metabolomic data set containing 138 variables for 177 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimulatedDataset)
</code></pre>


<h3>Format</h3>

<p>A data frame with 177 rows and 138 columns.
</p>

<hr>
<h2 id='SimulatedMemberships'>A simulated membership matrix.</h2><span id='topic+SimulatedMemberships'></span>

<h3>Description</h3>

<p>A simulated membership matrix containing 4 cluster memberships for 177 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimulatedMemberships)
</code></pre>


<h3>Format</h3>

<p>A data frame with 177 rows and 4 columns.
</p>

<hr>
<h2 id='SimulatedPrototypes'>A simulated prototype matrix.</h2><span id='topic+SimulatedPrototypes'></span>

<h3>Description</h3>

<p>A simulated prototype matrix containing 4 cluster prototypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimulatedPrototypes)
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 rows and 138 columns.
</p>

<hr>
<h2 id='ssmf'>Simplex-structured matrix factorisation algorithm (SSMF).</h2><span id='topic+ssmf'></span>

<h3>Description</h3>

<p>This function implements on SSMF on a data matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssmf(
  data,
  k,
  H = NULL,
  W = NULL,
  meth = c("kmeans", "uniform", "dirichlet", "nmf"),
  lr = 0.01,
  nruns = 50
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssmf_+3A_data">data</code></td>
<td>
<p>Data matrix or data frame.</p>
</td></tr>
<tr><td><code id="ssmf_+3A_k">k</code></td>
<td>
<p>The number of prototypes/clusters.</p>
</td></tr>
<tr><td><code id="ssmf_+3A_h">H</code></td>
<td>
<p>Matrix, user input <code class="reqn">H</code> matrix to start the algorithm. If input is empty, the function will initialise <code class="reqn">H</code> matrix automatically.</p>
</td></tr>
<tr><td><code id="ssmf_+3A_w">W</code></td>
<td>
<p>Matrix, user input <code class="reqn">W</code> matrix to start the algorithm. If input is empty, the function will initialise <code class="reqn">W</code> matrix automatically.</p>
</td></tr>
<tr><td><code id="ssmf_+3A_meth">meth</code></td>
<td>
<p>Specification of method to initialise the <code class="reqn">W</code> and <code class="reqn">H</code> matrix, see 'method' in <code>init()</code>.</p>
</td></tr>
<tr><td><code id="ssmf_+3A_lr">lr</code></td>
<td>
<p>Optimisation learning rate.</p>
</td></tr>
<tr><td><code id="ssmf_+3A_nruns">nruns</code></td>
<td>
<p>The maximum times of running the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X \in R^{n \times p}</code> be the data set  with <code class="reqn">n</code> observations and <code class="reqn">p</code> variables.
Given an integer <code class="reqn">k \ll \text{min}(n,p)</code>,
the data set is clustered by simplex-structured matrix factorisation (SSMF), which aims to process soft clustering
and partition the observations into <code class="reqn">k</code> fuzzy clusters such that the sum of squares from observations to the
assigned cluster prototypes is minimised.
SSMF finds <code class="reqn">H_{n \times k}</code> and <code class="reqn">W_{k \times p}</code>,
such that </p>
<p style="text-align: center;"><code class="reqn">X \approx HW,</code>
</p>

<p>A cluster prototype refers to a vector that represent the characteristics of a particular cluster,
denoted by <code class="reqn">w_r \in \mathbb{R}^{p}</code> , where <code class="reqn">r</code> is the <code class="reqn">r^{th}</code> cluster.
A cluster membership vector <code class="reqn">h_i \in \mathbb{R}^{k}</code> describes the proportion of the cluster prototypes
of the <code class="reqn">i^{th}</code> observation. <code class="reqn">W</code> is the prototype matrix where each row is the cluster prototype and
<code class="reqn">H</code> is the soft membership matrix where each row gives the soft cluster membership of each observation.
The problem of finding the approximate matrix factorisation is solved by minising residual sum of squares (RSS), that is
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{RSS} = \| X-HW \|^2 = \sum_{i=1}^{n}\sum_{j=1}^{p} \left\{ X_{ij}-(HW)_{ij}\right\}^2,</code>
</p>

<p>such that <code class="reqn">\sum_{r=1}^k h_{ir}=1</code>  and  <code class="reqn">h_{ir}\geq 0</code>.
</p>


<h3>Value</h3>

<p><code>W</code> The optimised <code class="reqn">W</code> matrix, containing the values of prototypes.
</p>
<p><code>H</code> The optimised <code class="reqn">H</code> matrix, containing the values of soft memberships.
</p>
<p><code>SSE</code> The residuals sum of square.
</p>


<h3>Author(s)</h3>

<p>Wenxuan Liu
</p>


<h3>References</h3>

<p>Abdolali, Maryam &amp; Gillis, Nicolas. (2020). Simplex-Structured Matrix Factorization: Sparsity-based Identifiability and Provably Correct Algorithms. &lt;doi:10.1137/20M1354982&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(MetabolSSMF)

# Initialisation by user
data &lt;- SimulatedDataset
k &lt;- 4

## Initialised by kmeans
fit.km &lt;- kmeans(data, centers = k)

H &lt;- mclust::unmap(fit.km$cluster)
W &lt;- fit.km$centers

fit1 &lt;- ssmf(data, k = k, H = H) #start the algorithm from H
fit2 &lt;- ssmf(data, k = k, W = W) #start the algorithm from W

# Initialisation inside the function
fit3 &lt;- ssmf(data, k = 4, meth = 'dirichlet')
fit4 &lt;- ssmf(data, k = 4)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
