<!DOCTYPE html><html><head><title>Help for package grid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grid-package'>
<p>The Grid Graphics Package</p></a></li>
<li><a href='#absolute.size'><p> Absolute Size of a Grob</p></a></li>
<li><a href='#arrow'><p> Describe arrows to add to a line</p></a></li>
<li><a href='#as.mask'><p> Define a Soft Mask</p></a></li>
<li><a href='#calcStringMetric'><p> Calculate Metric Information for Text</p></a></li>
<li><a href='#dataViewport'><p> Create a Viewport with Scales based on Data</p></a></li>
<li><a href='#depth'>
<p>Determine the number of levels in an object</p></a></li>
<li><a href='#deviceLoc'><p> Convert Viewport Location to Device Location</p></a></li>
<li><a href='#drawDetails'><p> Customising grid Drawing</p></a></li>
<li><a href='#editDetails'><p> Customising grid Editing</p></a></li>
<li><a href='#editViewport'><p> Modify a Viewport</p></a></li>
<li><a href='#explode'>
<p>Explode a path into its components</p></a></li>
<li><a href='#gEdit'><p> Create and Apply Edit Objects</p></a></li>
<li><a href='#getNames'><p> List the names of grobs on the display list</p></a></li>
<li><a href='#gpar'><p>Handling Grid Graphical Parameters</p></a></li>
<li><a href='#gPath'><p> Concatenate Grob Names</p></a></li>
<li><a href='#Grid'><p>Grid Graphics</p></a></li>
<li><a href='#Grid+20Viewports'><p>Create a Grid Viewport</p></a></li>
<li><a href='#grid-defunct'><p>Defunct Functions in Package <span class="pkg">grid</span></p></a></li>
<li><a href='#grid-internal'><p>Internal Grid Functions</p></a></li>
<li><a href='#grid.add'><p>Add a Grid Graphical Object</p></a></li>
<li><a href='#grid.bezier'><p> Draw a Bezier Curve</p></a></li>
<li><a href='#grid.cap'>
<p>Capture a raster image</p></a></li>
<li><a href='#grid.circle'><p> Draw a Circle</p></a></li>
<li><a href='#grid.clip'><p>Set the Clipping Region</p></a></li>
<li><a href='#grid.convert'><p> Convert Between Different grid Coordinate Systems</p></a></li>
<li><a href='#grid.copy'><p>Make a Copy of a Grid Graphical Object</p></a></li>
<li><a href='#grid.curve'><p> Draw a Curve Between Locations</p></a></li>
<li><a href='#grid.delay'><p> Encapsulate calculations and generating a grob</p></a></li>
<li><a href='#grid.display.list'><p>Control the Grid Display List</p></a></li>
<li><a href='#grid.DLapply'><p> Modify the Grid Display List</p></a></li>
<li><a href='#grid.draw'><p>Draw a grid grob</p></a></li>
<li><a href='#grid.edit'><p>Edit the Description of a Grid Graphical Object</p></a></li>
<li><a href='#grid.force'><p> Force a grob into its components</p></a></li>
<li><a href='#grid.frame'><p> Create a Frame for Packing Objects</p></a></li>
<li><a href='#grid.function'><p>Draw a curve representing a function</p></a></li>
<li><a href='#grid.get'><p>Get a Grid Graphical Object</p></a></li>
<li><a href='#grid.glyph'><p>Draw Typeset Glyphs</p></a></li>
<li><a href='#grid.grab'><p> Grab the current grid output</p></a></li>
<li><a href='#grid.grep'>
<p>Search for Grobs and/or Viewports</p></a></li>
<li><a href='#grid.grill'><p>Draw a Grill</p></a></li>
<li><a href='#grid.grob'><p>Create Grid Graphical Objects, aka &quot;Grob&quot;s</p></a></li>
<li><a href='#grid.group'><p> Draw a Group</p></a></li>
<li><a href='#grid.layout'><p>Create a Grid Layout</p></a></li>
<li><a href='#grid.lines'><p>Draw Lines in a Grid Viewport</p></a></li>
<li><a href='#grid.locator'><p> Capture a Mouse Click</p></a></li>
<li><a href='#grid.ls'><p> List the names of grobs or viewports</p></a></li>
<li><a href='#grid.move.to'><p> Move or Draw to a Specified Position</p></a></li>
<li><a href='#grid.newpage'><p>Move to a New Page on a Grid Device</p></a></li>
<li><a href='#grid.null'><p> Null Graphical Object</p></a></li>
<li><a href='#grid.pack'><p> Pack an Object within a Frame</p></a></li>
<li><a href='#grid.path'><p> Draw a Path</p></a></li>
<li><a href='#grid.place'><p> Place an Object within a Frame</p></a></li>
<li><a href='#grid.plot.and.legend'><p> A Simple Plot and Legend Demo</p></a></li>
<li><a href='#grid.points'><p>Draw Data Symbols</p></a></li>
<li><a href='#grid.polygon'><p> Draw a Polygon</p></a></li>
<li><a href='#grid.pretty'><p> Generate a Sensible (&quot;Pretty&quot;) Set of Breakpoints</p></a></li>
<li><a href='#grid.raster'>
<p>Render a raster object</p></a></li>
<li><a href='#grid.record'><p> Encapsulate calculations and drawing</p></a></li>
<li><a href='#grid.rect'><p>Draw rectangles</p></a></li>
<li><a href='#grid.refresh'><p> Refresh the current grid scene</p></a></li>
<li><a href='#grid.remove'><p>Remove a Grid Graphical Object</p></a></li>
<li><a href='#grid.reorder'><p> Reorder the children of a gTree</p></a></li>
<li><a href='#grid.segments'><p> Draw Line Segments</p></a></li>
<li><a href='#grid.set'><p>Set a Grid Graphical Object</p></a></li>
<li><a href='#grid.show.layout'><p>Draw a Diagram of a Grid Layout</p></a></li>
<li><a href='#grid.show.viewport'><p>Draw a Diagram of a Grid Viewport</p></a></li>
<li><a href='#grid.stroke'><p> Stroke or Fill a Path</p></a></li>
<li><a href='#grid.text'><p>Draw Text</p></a></li>
<li><a href='#grid.xaxis'><p>Draw an X-Axis</p></a></li>
<li><a href='#grid.xspline'><p> Draw an Xspline</p></a></li>
<li><a href='#grid.yaxis'><p>Draw a Y-Axis</p></a></li>
<li><a href='#gridCoords'><p>Create Sets of Coordinates for Grid Grobs</p></a></li>
<li><a href='#grobCoords'><p>Calculate Points on the Perimeter of a Grob</p></a></li>
<li><a href='#grobName'><p>Generate a Name for a Grob</p></a></li>
<li><a href='#grobWidth'><p>Create a Unit Describing the Width of a Grob</p></a></li>
<li><a href='#grobX'><p>Create a Unit Describing a Grob Boundary Location</p></a></li>
<li><a href='#legendGrob'><p>Constructing a Legend Grob</p></a></li>
<li><a href='#makeContent'><p> Customised grid Grobs</p></a></li>
<li><a href='#patterns'><p> Define Gradient and Pattern Fills</p></a></li>
<li><a href='#plotViewport'><p> Create a Viewport with a Standard Plot Layout</p></a></li>
<li><a href='#Querying+20the+20Viewport+20Tree'><p>Get the Current Grid Viewport (Tree)</p></a></li>
<li><a href='#resolveRasterSize'>
<p>Utility function to resolve the size of a raster grob</p></a></li>
<li><a href='#roundrect'><p>Draw a rectangle with rounded corners</p></a></li>
<li><a href='#showGrob'>
<p>Label grid grobs</p></a></li>
<li><a href='#showViewport'>
<p>Display grid viewports</p></a></li>
<li><a href='#stringWidth'><p>Create a Unit Describing the Width and Height of a String or Math</p>
Expression</a></li>
<li><a href='#unit'><p>Function to Create a Unit Object</p></a></li>
<li><a href='#unit.c'><p>Combine Unit Objects</p></a></li>
<li><a href='#unit.length'><p>Length of a Unit Object</p></a></li>
<li><a href='#unit.pmin'><p> Parallel Unit Minima and Maxima</p></a></li>
<li><a href='#unit.rep'><p> Replicate Elements of Unit Objects</p></a></li>
<li><a href='#unitType'><p>Return the Units of a Unit Object</p></a></li>
<li><a href='#valid.just'><p>Validate a Justification</p></a></li>
<li><a href='#validDetails'><p> Customising grid grob Validation</p></a></li>
<li><a href='#viewportTransform'><p> Define a Group Transformation</p></a></li>
<li><a href='#vpPath'><p> Concatenate Viewport Names</p></a></li>
<li><a href='#widthDetails'><p> Width and Height of a grid grob</p></a></li>
<li><a href='#Working+20with+20Viewports'><p>Maintaining and Navigating the Grid Viewport Tree</p></a></li>
<li><a href='#xDetails'><p> Boundary of a grid grob</p></a></li>
<li><a href='#xsplinePoints'>
<p>Return the points that would be used to draw an xspline</p>
(or a Bezier curve)</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.5.0</td>
</tr>
<tr>
<td>Priority:</td>
<td>base</td>
</tr>
<tr>
<td>Title:</td>
<td>The Grid Graphics Package</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Murrell &lt;paul@stat.auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>R Core Team &lt;do-use-Contact-address@r-project.org&gt;</td>
</tr>
<tr>
<td>Contact:</td>
<td>R-help mailing list &lt;r-help@r-project.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A rewrite of the graphics layout capabilities, plus some
  support for interaction.</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, utils</td>
</tr>
<tr>
<td>License:</td>
<td>Part of R 4.5.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.5.0; x86_64-pc-linux-gnu; 2024-04-16 07:37:03 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='grid-package'>
The Grid Graphics Package
</h2><span id='topic+grid-package'></span>

<h3>Description</h3>

<p>A rewrite of the graphics layout capabilities, plus some
support for interaction.
</p>


<h3>Details</h3>

<p>This package contains a graphics system which supplements
S-style graphics (see the <span class="pkg">graphics</span> package).
</p>
<p>Further information is available in the following
<a href="utils.html#topic+vignettes">vignettes</a>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>grid</code> </td><td style="text-align: left;"> Introduction to <code>grid</code> (<a href="../doc/grid.pdf">../doc/grid.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>displaylist</code> </td><td style="text-align: left;"> Display Lists in <code>grid</code> (<a href="../doc/displaylist.pdf">../doc/displaylist.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>frame</code> </td><td style="text-align: left;"> Frames and packing grobs (<a href="../doc/frame.pdf">../doc/frame.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>grobs</code> </td><td style="text-align: left;"> Working with <code>grid</code> grobs (<a href="../doc/grobs.pdf">../doc/grobs.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>interactive</code> </td><td style="text-align: left;"> Editing <code>grid</code> Graphics (<a href="../doc/interactive.pdf">../doc/interactive.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>locndimn</code> </td><td style="text-align: left;"> Locations versus Dimensions (<a href="../doc/locndimn.pdf">../doc/locndimn.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>moveline</code> </td><td style="text-align: left;"> Demonstrating move-to and line-to (<a href="../doc/moveline.pdf">../doc/moveline.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nonfinite</code> </td><td style="text-align: left;"> How <code>grid</code> responds to non-finite values (<a href="../doc/nonfinite.pdf">../doc/nonfinite.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>plotexample</code> </td><td style="text-align: left;"> Writing <code>grid</code> Code (<a href="../doc/plotexample.pdf">../doc/plotexample.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rotated</code> </td><td style="text-align: left;"> Rotated Viewports (<a href="../doc/rotated.pdf">../doc/rotated.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>saveload</code> </td><td style="text-align: left;"> Persistent representations (<a href="../doc/saveload.pdf">../doc/saveload.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sharing</code> </td><td style="text-align: left;"> Modifying multiple grobs simultaneously (<a href="../doc/sharing.pdf">../doc/sharing.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>viewports</code> </td><td style="text-align: left;"> Working with <code>grid</code> viewports (<a href="../doc/viewports.pdf">../doc/viewports.pdf</a>)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For a complete list of functions with individual help pages,
use <code>library(help="grid")</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell <a href="mailto:paul@stat.auckland.ac.nz">paul@stat.auckland.ac.nz</a>
</p>
<p>Maintainer: R Core Team <a href="mailto:R-core@r-project.org">R-core@r-project.org</a>
</p>


<h3>References</h3>

<p>Murrell, P. (2005).
<em>R Graphics</em>.
Chapman &amp; Hall/CRC Press.
</p>

<hr>
<h2 id='absolute.size'> Absolute Size of a Grob </h2><span id='topic+absolute.size'></span>

<h3>Description</h3>

<p>This function converts a unit object into absolute units.
Absolute units are unaffected, but non-absolute units are
converted into <code>"null"</code> units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absolute.size(unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absolute.size_+3A_unit">unit</code></td>
<td>
<p> An object of class <code>"unit"</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Absolute units are things like <code>"inches"</code>, <code>"cm"</code>,
and <code>"lines"</code>.  Non-absolute units are <code>"npc"</code>
and <code>"native"</code>.
</p>
<p>This function is designed to be used in <code>widthDetails</code>
and <code>heightDetails</code> methods.
</p>


<h3>Value</h3>

<p>An object of class <code>"unit"</code>.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+widthDetails">widthDetails</a></code>
and <code><a href="#topic+heightDetails">heightDetails</a></code> methods.
</p>

<hr>
<h2 id='arrow'> Describe arrows to add to a line </h2><span id='topic+arrow'></span>

<h3>Description</h3>

<p>Produces a description of what arrows to add to a line.
The result can be passed to a function that draws a line,
e.g., <code><a href="#topic+grid.lines">grid.lines</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrow(angle = 30, length = unit(0.25, "inches"),
      ends = "last", type = "open")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrow_+3A_angle">angle</code></td>
<td>
<p>The angle of the arrow head in degrees (smaller numbers
produce narrower, pointier arrows).  Essentially describes
the width of the arrow head.</p>
</td></tr>
<tr><td><code id="arrow_+3A_length">length</code></td>
<td>
<p>A unit specifying the length of the arrow head (from tip
to base).</p>
</td></tr>
<tr><td><code id="arrow_+3A_ends">ends</code></td>
<td>
<p>One of <code>"last"</code>, <code>"first"</code>, or <code>"both"</code>,
indicating which ends of the line to draw arrow heads.</p>
</td></tr>
<tr><td><code id="arrow_+3A_type">type</code></td>
<td>
<p>One of <code>"open"</code> or <code>"closed"</code> indicating
whether the arrow head should be a closed triangle.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>arrow()
str(arrow(type = "closed"), give.attr=FALSE)
</code></pre>

<hr>
<h2 id='as.mask'> Define a Soft Mask </h2><span id='topic+as.mask'></span>

<h3>Description</h3>

<p>Define either an alpha mask or a luminance mask,
based on a grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.mask(x, type=c("alpha", "luminance"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mask_+3A_x">x</code></td>
<td>
<p>A grob.</p>
</td></tr>
<tr><td><code id="as.mask_+3A_type">type</code></td>
<td>
<p>The type of mask.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A mask may be specified for a viewport either directly as
a grob or using this function.  In the former case, the result
is an alpha mask.  This function allows the user to define
a luminance mask instead.
</p>
<p>Not all graphics devices support masks and those that do
may only support one type of mask: for example
<code>xfig</code> and <code>pictex</code> do not support masks and
Cairo-based devices only support alpha masks.  
</p>


<h3>Value</h3>

<p>A <code>"GridMask"</code> object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: on devices without support for masks normal line segments 
##       will be drawn
grid.newpage()
## Alpha mask
grid.segments(y0=1, y1=0, gp=gpar(col=2, lwd=100))
pushViewport(viewport(mask=circleGrob(gp=gpar(fill=rgb(0,0,0,.5)))))
grid.segments(gp=gpar(col=3, lwd=100))
grid.newpage()
## Luminance mask
grid.segments(y0=1, y1=0, gp=gpar(col=2, lwd=100))
pushViewport(viewport(mask=as.mask(circleGrob(gp=gpar(fill="grey50")),
                                   "luminance")))
grid.segments(gp=gpar(col=3, lwd=100))
</code></pre>

<hr>
<h2 id='calcStringMetric'> Calculate Metric Information for Text </h2><span id='topic+calcStringMetric'></span>

<h3>Description</h3>

<p>This function returns the ascent, descent, and width metric
information for a character or expression vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcStringMetric(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcStringMetric_+3A_text">text</code></td>
<td>
<p> A character or expression vector. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three numeric components named ascent, descent, and width.
All values are in inches.
</p>


<h3>WARNING </h3>

<p> The metric information from this function is based
on the font settings that are in effect when this function is called.
It will not necessarily correspond to the metric information of any
text that is drawn on the page.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+stringAscent">stringAscent</a></code>, <code><a href="#topic+stringDescent">stringDescent</a></code>,
<code><a href="#topic+grobAscent">grobAscent</a></code>, and <code><a href="#topic+grobDescent">grobDescent</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
grid.segments(.01, .5, .99, .5, gp=gpar(col="grey"))
metrics &lt;- calcStringMetric(letters)
grid.rect(x=1:26/27,
          width=unit(metrics$width, "inches"),
          height=unit(metrics$ascent, "inches"),
          just="bottom",
          gp=gpar(col="red"))
grid.rect(x=1:26/27,
          width=unit(metrics$width, "inches"),
          height=unit(metrics$descent, "inches"),
          just="top",
          gp=gpar(col="red"))
grid.text(letters, x=1:26/27, just="bottom")

test &lt;- function(x) {
    grid.text(x, just="bottom")
    metric &lt;- calcStringMetric(x)
    if (is.character(x)) {
        grid.rect(width=unit(metric$width, "inches"),
                  height=unit(metric$ascent, "inches"),
                  just="bottom",
                  gp=gpar(col=rgb(1,0,0,.5)))
        grid.rect(width=unit(metric$width, "inches"),
                  height=unit(metric$descent, "inches"),
                  just="top",
                  gp=gpar(col=rgb(1,0,0,.5)))
    } else {
        grid.rect(width=unit(metric$width, "inches"),
                  y=unit(.5, "npc") + unit(metric[2], "inches"),
                  height=unit(metric$ascent, "inches"),
                  just="bottom",
                  gp=gpar(col=rgb(1,0,0,.5)))
        grid.rect(width=unit(metric$width, "inches"),
                  height=unit(metric$descent, "inches"),
                  just="bottom",
                  gp=gpar(col=rgb(1,0,0,.5)))
    }
}

tests &lt;- list("t",
              "test",
              "testy",
              "test\ntwo",
              expression(x),
              expression(y),
              expression(x + y),
              expression(a + b),
              expression(atop(x + y, 2)))

grid.newpage()
nrowcol &lt;- n2mfrow(length(tests))
pushViewport(viewport(layout=grid.layout(nrowcol[1], nrowcol[2]),
                      gp=gpar(cex=5, lwd=.5)))
for (i in 1:length(tests)) {
    col &lt;- (i - 1) %% nrowcol[2] + 1
    row &lt;- (i - 1) %/% nrowcol[2] + 1
    pushViewport(viewport(layout.pos.row=row, layout.pos.col=col))
    test(tests[[i]])
    popViewport()
}

</code></pre>

<hr>
<h2 id='dataViewport'> Create a Viewport with Scales based on Data </h2><span id='topic+dataViewport'></span>

<h3>Description</h3>

<p>This is a convenience function for producing a viewport with
x- and/or y-scales based on numeric values passed to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataViewport(xData = NULL, yData = NULL, xscale = NULL,
             yscale = NULL, extension = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataViewport_+3A_xdata">xData</code></td>
<td>
<p> A numeric vector of data. </p>
</td></tr>
<tr><td><code id="dataViewport_+3A_ydata">yData</code></td>
<td>
<p> A numeric vector of data. </p>
</td></tr>
<tr><td><code id="dataViewport_+3A_xscale">xscale</code></td>
<td>
<p> A numeric vector (length 2). </p>
</td></tr>
<tr><td><code id="dataViewport_+3A_yscale">yscale</code></td>
<td>
<p> A numeric vector (length 2). </p>
</td></tr>
<tr><td><code id="dataViewport_+3A_extension">extension</code></td>
<td>
<p> A numeric.  If length greater than 1, then
first value is used to extend the xscale and second value
is used to extend the yscale.
</p>
</td></tr>
<tr><td><code id="dataViewport_+3A_...">...</code></td>
<td>
<p> All other arguments will be passed to a call to
the <code>viewport()</code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>xscale</code> is not specified then the values in <code>x</code> are
used to generate an x-scale based on the range of <code>x</code>, extended
by the proportion specified in <code>extension</code>.  Similarly for the
y-scale.
</p>


<h3>Value</h3>

<p>A grid viewport object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code> and
<code><a href="#topic+plotViewport">plotViewport</a></code>.
</p>

<hr>
<h2 id='depth'>
Determine the number of levels in an object
</h2><span id='topic+depth'></span><span id='topic+depth.viewport'></span><span id='topic+depth.path'></span>

<h3>Description</h3>

<p>Determine the number of levels in a viewport stack or tree,
in a viewport path, or in a grob path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depth(x, ...)
## S3 method for class 'viewport'
depth(x, ...)
## S3 method for class 'path'
depth(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_x">x</code></td>
<td>

<p>Typically a viewport or viewport stack or viewport tree or viewport
list, or a viewport path, or a grob path.
</p>
</td></tr>
<tr><td><code id="depth_+3A_...">...</code></td>
<td>
<p> Arguments used by other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depths of paths are pretty straightforward because they contain
no branchings.  The depth of a viewport stack is the sum of the depths
of the components of the stack.  The depth of a viewport tree is
the depth of the parent plus the depth of the children.
The depth of a viewport list is the depth of the last component
of the list.
</p>


<h3>Value</h3>

<p>An integer value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code>, <code><a href="#topic+vpPath">vpPath</a></code>, <code><a href="#topic+gPath">gPath</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vp &lt;- viewport()
depth(vp)
depth(vpStack(vp, vp))
depth(vpList(vpStack(vp, vp), vp))
depth(vpPath("vp"))
depth(vpPath("vp1", "vp2"))
</code></pre>

<hr>
<h2 id='deviceLoc'> Convert Viewport Location to Device Location </h2><span id='topic+deviceLoc'></span><span id='topic+deviceDim'></span>

<h3>Description</h3>

<p>These functions take a pair of unit objects and convert
them to a pair of device locations (or dimensions) in inches
(or native device coordinates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deviceLoc(x, y, valueOnly = FALSE, device = FALSE)
deviceDim(w, h, valueOnly = FALSE, device = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviceLoc_+3A_x">x</code>, <code id="deviceLoc_+3A_y">y</code>, <code id="deviceLoc_+3A_w">w</code>, <code id="deviceLoc_+3A_h">h</code></td>
<td>
<p> A unit object. </p>
</td></tr>
<tr><td><code id="deviceLoc_+3A_valueonly">valueOnly</code></td>
<td>
<p> A logical indicating.  If <code>TRUE</code> then
the function does not return a unit object, but rather only the
converted numeric values. </p>
</td></tr>
<tr><td><code id="deviceLoc_+3A_device">device</code></td>
<td>
<p> A logical indicating whether the returned values should
be in inches or native device units. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions differ from the functions like <code>convertX()</code>
because they convert from the coordinate systems within a viewport
to inches on the device (i.e., from one viewport to another) and
because they only deal with pairs of values (locations or dimensions).
</p>
<p>The functions like <code>convertX()</code> convert between different units within
the same viewport and convert along a single dimension.
</p>


<h3>Value</h3>

<p>A list with two components, both of which are unit object in inches
(unless <code>valueOnly</code> is <code>TRUE</code> in which case
both components are numeric).
</p>


<h3>Warning</h3>

<p>The conversion is only valid for the current device size.
If the device is resized then at least some conversions will
become invalid.
</p>
<p>Furthermore, the returned value only makes sense with respect to
the entire device (i.e., within the context of the root viewport).
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+unit">unit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## A tautology
grid.newpage()
pushViewport(viewport())
deviceLoc(unit(1, "inches"), unit(1, "inches"))

## Something less obvious
grid.newpage()
pushViewport(viewport(width=.5, height=.5))
grid.rect()
x &lt;- unit(1, "in")
y &lt;- unit(1, "in")
grid.circle(x, y, r=unit(2, "mm"))
loc &lt;- deviceLoc(x, y)
loc
upViewport()
grid.circle(loc$x, loc$y, r=unit(1, "mm"), gp=gpar(fill="black"))

## Something even less obvious
grid.newpage()
pushViewport(viewport(width=.5, height=.5, angle=30))
grid.rect()
x &lt;- unit(.2, "npc")
y &lt;- unit(2, "in")
grid.circle(x, y, r=unit(2, "mm"))
loc &lt;- deviceLoc(x, y)
loc
upViewport()
grid.circle(loc$x, loc$y, r=unit(1, "mm"), gp=gpar(fill="black"))
</code></pre>

<hr>
<h2 id='drawDetails'> Customising grid Drawing </h2><span id='topic+drawDetails'></span><span id='topic+preDrawDetails'></span><span id='topic+postDrawDetails'></span>

<h3>Description</h3>

<p>These generic hook functions are called whenever a grid grob is drawn.
They provide an opportunity for customising the drawing of a
new class derived from grob (or gTree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawDetails(x, recording)
preDrawDetails(x)
postDrawDetails(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawDetails_+3A_x">x</code></td>
<td>
<p> A grid grob. </p>
</td></tr>
<tr><td><code id="drawDetails_+3A_recording">recording</code></td>
<td>
<p> A logical value indicating whether a grob
is being added to the display list or redrawn from the display list. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>NOTE:</strong> these functions have been largely superceded by the
<code><a href="#topic+makeContent">makeContent</a></code> and <code><a href="#topic+makeContext">makeContext</a></code> functions,
though they are still run and may still be useful in some contexts.
</p>
<p>These functions are called by the <code>grid.draw</code> methods for grobs
and gTrees.
</p>
<p><code>preDrawDetails</code> is called first during the drawing of a grob.
This is where any additional viewports should be pushed.  Note that
the default behaviour for grobs is to push any viewports in the
<code>vp</code> slot, and for gTrees is to also push and up any viewports in the
<code>childrenvp</code> slot so there is typically nothing to do here.
</p>
<p><code>drawDetails</code> is called next and is where any additional
calculations and graphical output should occur.
Note that the default behaviour
for gTrees is to draw all grobs in the <code>children</code> slot
so there is typically nothing to do here.
</p>
<p><code>postDrawDetails</code> is called last and should reverse anything
done in <code>preDrawDetails</code> (i.e., pop or up any viewports that were
pushed).  Note that the
default behaviour for grobs is to pop any viewports that were pushed
so there is typically nothing to do here.
</p>
<p>Note that <code>preDrawDetails</code> and <code>postDrawDetails</code> are
also called in the calculation of <code>"grobwidth"</code> and
<code>"grobheight"</code> units.
</p>


<h3>Value</h3>

<p>None of these functions are expected to return a value.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>References</h3>

<p> &quot;Changes to grid for R 3.0.0&quot;,
Paul Murrell, <em>The R Journal</em> (2013) 5:2, pages 148-160. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.draw">grid.draw</a></code> and <code><a href="#topic+makeContent">makeContent</a></code> </p>

<hr>
<h2 id='editDetails'> Customising grid Editing </h2><span id='topic+editDetails'></span>

<h3>Description</h3>

<p>This generic hook function is called whenever a grid grob is edited
via <code>grid.edit</code> or <code>editGrob</code>.
This provides an opportunity for customising the editing of a
new class derived from grob (or gTree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editDetails(x, specs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editDetails_+3A_x">x</code></td>
<td>
<p> A grid grob. </p>
</td></tr>
<tr><td><code id="editDetails_+3A_specs">specs</code></td>
<td>
<p> A list of named elements.  The names indicate the
grob slots to modify and the values are the new values for the slots. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>grid.edit</code> and <code>editGrob</code>.
A method should be written for classes derived from grob or gTree
if a change in a slot has an effect on other slots in the grob or
children of a gTree (e.g., see <code>grid:::editDetails.xaxis</code>).
</p>
<p>Note that the slot already has the new value.
</p>


<h3>Value</h3>

<p>The function MUST return the modified grob.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.edit">grid.edit</a></code> </p>

<hr>
<h2 id='editViewport'> Modify a Viewport </h2><span id='topic+editViewport'></span>

<h3>Description</h3>

<p>This is a convenience function for producing a new viewport
from a copy of an existing viewport (by default the current
viewport), with specified modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editViewport(vp=current.viewport(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editViewport_+3A_vp">vp</code></td>
<td>
<p> A viewport object. </p>
</td></tr>
<tr><td><code id="editViewport_+3A_...">...</code></td>
<td>
<p> Modification of the viewport
(should all be valid arguments to
the <code>viewport()</code> function. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid viewport object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code>.
</p>

<hr>
<h2 id='explode'>
Explode a path into its components
</h2><span id='topic+explode'></span><span id='topic+explode.character'></span><span id='topic+explode.path'></span>

<h3>Description</h3>

<p>Explode a viewport path or grob path into its components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explode(x)
## S3 method for class 'character'
explode(x)
## S3 method for class 'path'
explode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explode_+3A_x">x</code></td>
<td>

<p>Typically a viewport path or a grob path, but a character vector
containing zero or more path separators may also be given.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vpPath">vpPath</a></code>, <code><a href="#topic+gPath">gPath</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>explode("vp1::vp2")
explode(vpPath("vp1", "vp2"))
</code></pre>

<hr>
<h2 id='gEdit'> Create and Apply Edit Objects </h2><span id='topic+gEdit'></span><span id='topic+gEditList'></span><span id='topic+applyEdit'></span><span id='topic+applyEdits'></span>

<h3>Description</h3>

<p>The functions <code>gEdit</code> and <code>gEditList</code> create
objects representing an edit operation (essentially a list
of arguments to <code>editGrob</code>).
</p>
<p>The functions <code>applyEdit</code> and <code>applyEdits</code> apply
one or more edit operations to a graphical object.
</p>
<p>These functions are most useful for developers creating new
graphical functions and objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gEdit(...)
gEditList(...)
applyEdit(x, edit)
applyEdits(x, edits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gEdit_+3A_...">...</code></td>
<td>
<p> one or more arguments to the <code>editGrob</code> function
(for <code>gEdit</code>) or one or more <code>"gEdit"</code> objects
(for <code>gEditList</code>).</p>
</td></tr>
<tr><td><code id="gEdit_+3A_x">x</code></td>
<td>
<p> a grob (grid graphical object).</p>
</td></tr>
<tr><td><code id="gEdit_+3A_edit">edit</code></td>
<td>
<p> a <code>"gEdit"</code> object.</p>
</td></tr>
<tr><td><code id="gEdit_+3A_edits">edits</code></td>
<td>
<p> either a <code>"gEdit"</code> object or a <code>"gEditList"</code>
object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gEdit</code> returns an object of class <code>"gEdit"</code>.
</p>
<p><code>gEditList</code> returns an object of class <code>"gEditList"</code>.
</p>
<p><code>applyEdit</code> and <code>applyEditList</code> return the modified grob.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>
<code><a href="#topic+editGrob">editGrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.rect(gp=gpar(col="red"))
# same thing, but more verbose
grid.draw(applyEdit(rectGrob(), gEdit(gp=gpar(col="red"))))
</code></pre>

<hr>
<h2 id='getNames'> List the names of grobs on the display list </h2><span id='topic+getNames'></span>

<h3>Description</h3>

<p>Returns a character vector containing the names of all
top-level grobs on the display list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNames()
</code></pre>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.grill()
getNames()
</code></pre>

<hr>
<h2 id='gpar'>Handling Grid Graphical Parameters</h2><span id='topic+gpar'></span><span id='topic+get.gpar'></span>

<h3>Description</h3>

<p><code>gpar()</code> should be used to create a set of graphical
parameter settings.  It returns an object of class <code>"gpar"</code>.  This is
basically a list of name-value pairs.
</p>
<p><code>get.gpar()</code> can be used to query the current
graphical parameter settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpar(...)
get.gpar(names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpar_+3A_...">...</code></td>
<td>
<p> Any number of named arguments. </p>
</td></tr>
<tr><td><code id="gpar_+3A_names">names</code></td>
<td>
<p>A character vector of valid graphical parameter names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All grid viewports and (predefined) graphical objects have a slot
called <code>gp</code>, which contains a <code>"gpar"</code> object.  When
a viewport is pushed onto the viewport stack and when a graphical object
is drawn, the settings in the <code>"gpar"</code> object are enforced.
In this way, the graphical output is modified by the <code>gp</code>
settings until the graphical object has finished drawing, or until the
viewport is popped off the viewport stack, or until some other
viewport or graphical object is pushed or begins drawing.
</p>
<p>The default parameter settings are defined by the ROOT viewport, which
takes its settings from the graphics device.  These defaults may
differ between devices (e.g., the default <code>fill</code> setting is
different for a PNG device compared to a PDF device).
</p>
<p>Valid parameter names are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>col</code> </td><td style="text-align: left;"> Colour for lines and borders. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fill</code> </td><td style="text-align: left;"> Colour for filling rectangles, polygons, ... </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>alpha</code> </td><td style="text-align: left;"> Alpha channel for transparency </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lty</code> </td><td style="text-align: left;"> Line type </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lwd</code> </td><td style="text-align: left;"> Line width </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lex</code> </td><td style="text-align: left;"> Multiplier applied to line width </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lineend</code> </td><td style="text-align: left;"> Line end style (round, butt, square) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>linejoin</code> </td><td style="text-align: left;"> Line join style (round, mitre, bevel) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>linemitre</code> </td><td style="text-align: left;"> Line mitre limit (number greater than 1) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fontsize</code> </td><td style="text-align: left;"> The size of text (in points) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>cex</code> </td><td style="text-align: left;"> Multiplier applied to <code>fontsize</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fontfamily</code> </td><td style="text-align: left;"> The font family </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>fontface</code> </td><td style="text-align: left;"> The font face (bold, italic, ...) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>lineheight</code> </td><td style="text-align: left;"> The height of a line as a multiple of the size of text </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>font</code> </td><td style="text-align: left;"> Font face (alias for <code>fontface</code>; for backward compatibility) </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For more details of many of these, see the help for the corresponding
graphical parameter <code><a href="graphics.html#topic+par">par</a></code> in base graphics.  (This may
have a slightly different name, e.g. <code>lend</code>, <code>ljoin</code>,
<code>lmitre</code>, <code>family</code>.)
</p>
<p>Colours can be specified in one of the forms returned by
<code><a href="grDevices.html#topic+rgb">rgb</a></code>, as a name (see <code><a href="grDevices.html#topic+colors">colors</a></code>) or as a
non-negative integer index into the current <a href="grDevices.html#topic+palette">palette</a> (with zero
being taken as transparent).  (Negative integer values are now an
error.)
</p>
<p>The <code>alpha</code> setting is combined with the alpha channel for
individual colours by multiplying (with both alpha settings
normalised to the range 0 to 1).
</p>
<p>The <code>fill</code> setting can also be a linear gradient or a radial
gradient or a pattern (see <a href="#topic+pattern">patterns</a>).
</p>
<p>The size of text is <code>fontsize</code>*<code>cex</code>.  The size of a line
is <code>fontsize</code>*<code>cex</code>*<code>lineheight</code>.
</p>
<p>The <code>cex</code> setting is cumulative;  if a viewport is pushed
with a <code>cex</code> of 0.5 then another viewport is pushed with a
<code>cex</code> of 0.5, the effective <code>cex</code> is 0.25.
</p>
<p>The <code>alpha</code> and <code>lex</code> settings are also cumulative.
</p>
<p>Changes to the <code>fontfamily</code> may be ignored by some devices,
but is supported by PostScript, PDF, X11, Windows, and Quartz.  The
<code>fontfamily</code> may be used to specify one
of the Hershey Font families (e.g., <code>HersheySerif</code>)
and this specification will be honoured
on all devices.
</p>
<p>The specification of <code>fontface</code> can be an integer or a string.
If an integer, then it
follows the R base graphics
standard:  1 = plain, 2 = bold, 3 = italic, 4 = bold italic.
If a string, then valid values are: <code>"plain"</code>,
<code>"bold"</code>, <code>"italic"</code>, <code>"oblique"</code>, and
<code>"bold.italic"</code>.
For the special case of the HersheySerif font family,
<code>"cyrillic"</code>, <code>"cyrillic.oblique"</code>, and <code>"EUC"</code>
are also available.
</p>
<p>All parameter values can be vectors of multiple values.  (This will
not always make sense &ndash; for example, viewports will only take
notice of the first parameter value.)
</p>
<p><code>get.gpar()</code> returns all current graphical parameter settings.
</p>


<h3>Value</h3>

<p>An object of class <code>"gpar"</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+Hershey">Hershey</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gp &lt;- get.gpar()
utils::str(gp)
## These *do* nothing but produce a "gpar" object:
gpar(col = "red")
gpar(col = "blue", lty = "solid", lwd = 3, fontsize = 16)
get.gpar(c("col", "lty"))
grid.newpage()
vp &lt;- viewport(width = .8, height = .8, gp = gpar(col="blue"))
grid.draw(gTree(children=gList(rectGrob(gp = gpar(col="red")),
                     textGrob(paste("The rect is its own colour (red)",
                                    "but this text is the colour",
                                    "set by the gTree (green)",
                                    sep = "\n"))),
      gp = gpar(col="green"), vp = vp))
grid.text("This text is the colour set by the viewport (blue)",
          y = 1, just = c("center", "bottom"),
          gp = gpar(fontsize=20), vp = vp)
grid.newpage()
## example with multiple values for a parameter
pushViewport(viewport())
grid.points(1:10/11, 1:10/11, gp = gpar(col=1:10))
popViewport()
</code></pre>

<hr>
<h2 id='gPath'> Concatenate Grob Names </h2><span id='topic+gPath'></span>

<h3>Description</h3>

<p>This function can be used to generate a grob path for use
in <code>grid.edit</code> and friends.
</p>
<p>A grob path is a list of nested grob names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gPath(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gPath_+3A_...">...</code></td>
<td>
<p> Character values which are grob names. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grob names must only be unique amongst grobs which
share the same parent in a gTree.
</p>
<p>This function can be used to generate a specification for
a grob that includes the grob's parent's name
(and the name of its parent and so on).
</p>
<p>For interactive use, it is possible to directly specify
a path, but it is strongly recommended that this function
is used otherwise in case the path separator is changed
in future versions of grid.
</p>


<h3>Value</h3>

<p>A <code> gPath </code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>,
<code><a href="#topic+editGrob">editGrob</a></code>,
<code><a href="#topic+addGrob">addGrob</a></code>,
<code><a href="#topic+removeGrob">removeGrob</a></code>,
<code><a href="#topic+getGrob">getGrob</a></code>,
<code><a href="#topic+setGrob">setGrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gPath("g1", "g2")
</code></pre>

<hr>
<h2 id='Grid'>Grid Graphics</h2><span id='topic+Grid'></span>

<h3>Description</h3>

<p>General information about the grid graphics package.
</p>


<h3>Details</h3>

<p>Grid graphics provides an alternative to the standard R graphics.
The user is able to define arbitrary rectangular regions (called
<em>viewports</em>) on the graphics device and define a number of
coordinate systems for each region.  Drawing can be specified to occur
in any viewport using any of the available coordinate systems.
</p>
<p>Grid graphics and standard R graphics do not mix!
</p>
<p>Type <code>library(help = grid)</code> to see a list of (public)
Grid graphics functions.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+grid.layout">grid.layout</a></code>, and
<code><a href="#topic+unit">unit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Diagram of a simple layout
grid.show.layout(grid.layout(4,2,
                     heights=unit(rep(1, 4),
                                  c("lines", "lines", "lines", "null")),
                     widths=unit(c(1, 1), "inches")))
## Diagram of a sample viewport
grid.show.viewport(viewport(x=0.6, y=0.6,
                            width=unit(1, "inches"), height=unit(1, "inches")))
## A flash plotting example
grid.multipanel(vp=viewport(0.5, 0.5, 0.8, 0.8))
</code></pre>

<hr>
<h2 id='Grid+20Viewports'>Create a Grid Viewport</h2><span id='topic+viewport'></span><span id='topic+vpList'></span><span id='topic+vpStack'></span><span id='topic+vpTree'></span>

<h3>Description</h3>

<p>These functions create viewports, which describe rectangular regions
on a graphics device and define a number of coordinate systems within
those regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewport(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         default.units = "npc", just = "centre",
         gp = gpar(), clip = "inherit", mask = "inherit",
         xscale = c(0, 1), yscale = c(0, 1),
         angle = 0,
         layout = NULL,
         layout.pos.row = NULL, layout.pos.col = NULL,
         name = NULL)
vpList(...)
vpStack(...)
vpTree(parent, children)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Grid+2B20Viewports_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-location.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-location.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_width">width</code></td>
<td>
<p>A numeric vector or unit object specifying width.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_height">height</code></td>
<td>
<p>A numeric vector or unit object specifying height.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_just">just</code></td>
<td>
<p>A string or numeric
vector specifying the justification of the viewport
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left alignment
and 1 means right alignment.
</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_clip">clip</code></td>
<td>
<p>One of <code>"on"</code>, <code>"inherit"</code>, or
<code>"off"</code>, indicating whether to
clip to the extent of this viewport, inherit the clipping region
from the parent viewport, or turn clipping off altogether.
For back-compatibility, a logical value of <code>TRUE</code> corresponds
to <code>"on"</code> and <code>FALSE</code> corresponds to <code>"inherit"</code>.
</p>
<p>May also be a grob (or a gTree) that describes a clipping path
or the result of a call to <code><a href="#topic+as.path">as.path</a></code>.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_mask">mask</code></td>
<td>
<p>One of <code>"none"</code> (or <code>FALSE</code>)
or <code>"inherit"</code> (or <code>TRUE</code>) 
or a grob (or a gTree) or the result of call to
<code><a href="#topic+as.mask">as.mask</a></code>.  This specifies that the viewport
should have no mask, or it should inherit the mask of its parent,
or it should have its own mask, as described by the grob.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_xscale">xscale</code></td>
<td>
<p>A numeric vector of length two indicating the minimum and
maximum on the x-scale.  The limits may not be identical. </p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_yscale">yscale</code></td>
<td>
<p>A numeric vector of length two indicating the minimum
and maximum on the y-scale. The limits may not be identical. </p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_angle">angle</code></td>
<td>
<p>A numeric value indicating the angle of rotation of the
viewport.  Positive values indicate the amount of rotation, in
degrees, anticlockwise from the positive x-axis.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_layout">layout</code></td>
<td>
<p>A Grid layout object which splits the viewport into
subregions.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_layout.pos.row">layout.pos.row</code></td>
<td>
<p>A numeric vector giving the
rows occupied by this viewport in its
parent's layout.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_layout.pos.col">layout.pos.col</code></td>
<td>
<p>A numeric vector giving the
columns occupied by this viewport in its
parent's layout.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_name">name</code></td>
<td>
<p>A character value to uniquely identify the viewport
once it has been pushed onto the viewport tree.  </p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_...">...</code></td>
<td>
<p>Any number of grid viewport objects.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_parent">parent</code></td>
<td>
<p>A grid viewport object.</p>
</td></tr>
<tr><td><code id="Grid+2B20Viewports_+3A_children">children</code></td>
<td>
<p>A vpList object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location and size of a viewport are relative to the coordinate
systems defined by the viewport's parent (either a graphical device
or another viewport).  The location and size can be specified in a
very flexible way by specifying them with unit objects.
When specifying the location of a viewport, specifying
both <code>layout.pos.row</code> and <code>layout.pos.col</code> as <code>NULL</code>
indicates that
the viewport ignores its parent's layout and specifies its own
location and size (via its <code>locn</code>).  If only one of
<code>layout.pos.row</code> and <code>layout.pos.col</code> is <code>NULL</code>, this
means occupy ALL of the appropriate row(s)/column(s).  For example,
<code>layout.pos.row = 1</code> and <code>layout.pos.col = NULL</code> means
occupy all of row 1.  Specifying non-<code>NULL</code> values for both
<code>layout.pos.row</code> and <code>layout.pos.col</code> means occupy the
intersection of the appropriate rows and columns.  If a vector of
length two is
specified for <code>layout.pos.row</code> or <code>layout.pos.col</code>, this
indicates a range of rows or columns to occupy.  For example,
<code>layout.pos.row = c(1, 3)</code> and <code>layout.pos.col = c(2, 4)</code>
means occupy cells in the intersection of rows 1, 2, and 3, and
columns, 2, 3, and 4.
</p>
<p>Clipping obeys only the most recent viewport clip setting.
For example, if you clip to viewport1, then clip to viewport2,
the clipping region is determined wholly by viewport2, the
size and shape of viewport1 is irrelevant (until viewport2
is popped of course).
</p>
<p>If a viewport is rotated (because of its own <code>angle</code> setting
or because it is within another viewport which is rotated) then
the <code>clip</code> flag is ignored.
</p>
<p>If <code>clip</code> is a grob, then that grob (which may be more
than one shape) defines a clipping path.  The function
<code>as.path</code> may be used to specify a fill rule for the path.
</p>
<p>Viewport names need not be unique.  When pushed, viewports
sharing the same parent must have unique names, which means that
if you push a viewport with the same name as an existing viewport,
the existing viewport will be replaced in the viewport tree.
A viewport name can be any string, but
grid uses the
reserved name <code>"ROOT"</code> for the top-level viewport.  Also,
when specifying a viewport name in <code>downViewport</code>
and <code>seekViewport</code>, it is possible to provide a viewport
path, which consists of several names concatenated using the
separator  (currently <code>::</code>).  Consequently, it is not
advisable to use this separator in viewport names.
</p>
<p>The viewports in a <code>vpList</code> are pushed in parallel.  The
viewports in a <code>vpStack</code> are pushed in series.  When a
<code>vpTree</code> is pushed, the parent is pushed first, then the
children are pushed in parallel.
</p>


<h3>Value</h3>

<p>An R object of class <code>viewport</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+pushViewport">pushViewport</a></code>,
<code><a href="#topic+popViewport">popViewport</a></code>,
<code><a href="#topic+downViewport">downViewport</a></code>,
<code><a href="#topic+seekViewport">seekViewport</a></code>,
<code><a href="#topic+upViewport">upViewport</a></code>,
<code><a href="#topic+unit">unit</a></code>,
<code><a href="#topic+grid.layout">grid.layout</a></code>,
<code><a href="#topic+grid.show.layout">grid.show.layout</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Diagram of a sample viewport
grid.show.viewport(viewport(x=0.6, y=0.6,
                   width=unit(1, "inches"), height=unit(1, "inches")))
# Demonstrate viewport clipping
clip.demo &lt;- function(i, j, clip1, clip2) {
  pushViewport(viewport(layout.pos.col=i,
                         layout.pos.row=j))
  pushViewport(viewport(width=0.6, height=0.6, clip=clip1))
  grid.rect(gp=gpar(fill="white"))
  grid.circle(r=0.55, gp=gpar(col="red", fill="pink"))
  popViewport()
  pushViewport(viewport(width=0.6, height=0.6, clip=clip2))
  grid.polygon(x=c(0.5, 1.1, 0.6, 1.1, 0.5, -0.1, 0.4, -0.1),
               y=c(0.6, 1.1, 0.5, -0.1, 0.4, -0.1, 0.5, 1.1),
               gp=gpar(col="blue", fill="light blue"))
  popViewport(2)
}

grid.newpage()
grid.rect(gp=gpar(fill="grey"))
pushViewport(viewport(layout=grid.layout(2, 2)))
clip.demo(1, 1, FALSE, FALSE)
clip.demo(1, 2, TRUE, FALSE)
clip.demo(2, 1, FALSE, TRUE)
clip.demo(2, 2, TRUE, TRUE)
popViewport()
# Demonstrate turning clipping off
grid.newpage()
pushViewport(viewport(width=.5, height=.5, clip="on"))
grid.rect()
grid.circle(r=.6, gp=gpar(lwd=10))
pushViewport(viewport(clip="inherit"))
grid.circle(r=.6, gp=gpar(lwd=5, col="grey"))
pushViewport(viewport(clip="off"))
grid.circle(r=.6)
popViewport(3)
# Demonstrate vpList, vpStack, and vpTree
grid.newpage()
tree &lt;- vpTree(viewport(width=0.8, height=0.8, name="A"),
               vpList(vpStack(viewport(x=0.1, y=0.1, width=0.5, height=0.5,
                                       just=c("left", "bottom"), name="B"),
                              viewport(x=0.1, y=0.1, width=0.5, height=0.5,
                                       just=c("left", "bottom"), name="C"),
                              viewport(x=0.1, y=0.1, width=0.5, height=0.5,
                                       just=c("left", "bottom"), name="D")),
                      viewport(x=0.5, width=0.4, height=0.9,
                               just="left", name="E")))
pushViewport(tree)
for (i in LETTERS[1:5]) {
  seekViewport(i)
  grid.rect()
  grid.text(current.vpTree(FALSE),
            x=unit(1, "mm"), y=unit(1, "npc") - unit(1, "mm"),
            just=c("left", "top"),
            gp=gpar(fontsize=8))
}
</code></pre>

<hr>
<h2 id='grid-defunct'>Defunct Functions in Package <span class="pkg">grid</span></h2><span id='topic+grid-defunct'></span><span id='topic+grid.grob'></span><span id='topic+grid.arrows'></span><span id='topic+arrowsGrob'></span><span id='topic+grid.convert'></span><span id='topic+grid.convertX'></span><span id='topic+grid.convertY'></span><span id='topic+grid.convertWidth'></span><span id='topic+grid.convertHeight'></span><span id='topic+grid.collection'></span><span id='topic+push.viewport'></span><span id='topic+pop.viewport'></span><span id='topic+viewport.transform'></span><span id='topic+draw.details'></span><span id='topic+convertNative'></span>

<h3>Description</h3>

<p>The functions or variables listed here are no longer part of <span class="pkg">grid</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.grob(list.struct, cl = NULL, draw = TRUE) 
grid.arrows(x = c(0.25, 0.75), y = 0.5, default.units = "npc",
            grob = NULL,
            angle = 30, length = unit(0.25, "inches"),
            ends = "last", type = "open", name = NULL,
            gp = gpar(), draw = TRUE, vp = NULL)

arrowsGrob(x = c(0.25, 0.75), y = 0.5, default.units = "npc",
           grob = NULL,
           angle = 30, length = unit(0.25, "inches"),
           ends = "last", type = "open", name = NULL,
           gp = gpar(), vp = NULL)
grid.convertX(x, unitTo, valueOnly = FALSE)
grid.convertY(x, unitTo, valueOnly = FALSE)
grid.convertWidth(x, unitTo, valueOnly = FALSE)
grid.convertHeight(x, unitTo, valueOnly = FALSE)
grid.convert(x, unitTo,
             axisFrom = "x", typeFrom = "location",
             axisTo = axisFrom, typeTo = typeFrom,
             valueOnly = FALSE)
grid.collection(..., gp=gpar(), draw=TRUE, vp=NULL)
push.viewport(..., recording=TRUE)
pop.viewport(n=1, recording=TRUE)
viewport.transform(vp)
draw.details(x, recording)
convertNative(unit, dimension="x", type="location")
</code></pre>

<hr>
<h2 id='grid-internal'>Internal Grid Functions</h2><span id='topic+grid.multipanel'></span><span id='topic+grid.panel'></span><span id='topic+grid.strip'></span><span id='topic+layoutRegion'></span><span id='topic+viewport.layout'></span><span id='topic+layout.heights'></span><span id='topic+layout.widths'></span><span id='topic+layout.torture'></span>

<h3>Description</h3>

<p>Internal Grid functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current.rotation() 
grid.multipanel(x = stats::runif(90), y = stats::runif(90),
                z = stats::runif(90), nplots = 9, nrow = 5, ncol = 2,
                newpage = TRUE, vp = NULL) 
grid.panel(x = stats::runif(10), y = stats::runif(10),
           zrange = c(0, 1), zbin = stats::runif(2),
           xscale = extendrange(x), yscale = extendrange(y), 
           axis.left = TRUE, axis.left.label = TRUE, axis.right = FALSE, 
           axis.right.label = TRUE, axis.bottom = TRUE,
           axis.bottom.label = TRUE, axis.top = FALSE,
           axis.top.label = TRUE, vp = NULL) 
grid.strip(label = "whatever", range.full = c(0, 1),
           range.thumb = c(0.3, 0.6), fill = "#FFBF00",
           thumb = "#FF8000", vp = NULL) 
layout.heights(lay) 
layout.torture() 
layout.widths(lay) 
layoutRegion(layout.pos.row = 1, layout.pos.col = 1) 
viewport.layout(vp)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written :).
</p>

<hr>
<h2 id='grid.add'>Add a Grid Graphical Object</h2><span id='topic+grid.add'></span><span id='topic+addGrob'></span><span id='topic+setChildren'></span>

<h3>Description</h3>

<p>Add a grob to a gTree or a descendant of a gTree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.add(gPath, child, strict = FALSE, grep = FALSE,
         global = FALSE, allDevices = FALSE, redraw = TRUE)

addGrob(gTree, child, gPath = NULL, strict = FALSE, grep = FALSE,
        global = FALSE, warn = TRUE)

setChildren(x, children)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.add_+3A_gtree">gTree</code>, <code id="grid.add_+3A_x">x</code></td>
<td>
<p>A gTree object.</p>
</td></tr>
<tr><td><code id="grid.add_+3A_gpath">gPath</code></td>
<td>
<p> A gPath object. For <code>grid.add</code> this
specifies a gTree on the display list.  For <code>addGrob</code> this
specifies a descendant of the specified gTree. </p>
</td></tr>
<tr><td><code id="grid.add_+3A_child">child</code></td>
<td>
<p> A grob object. </p>
</td></tr>
<tr><td><code id="grid.add_+3A_children">children</code></td>
<td>
<p> A gList object. </p>
</td></tr>
<tr><td><code id="grid.add_+3A_strict">strict</code></td>
<td>
<p> A boolean indicating whether the gPath must be
matched exactly. </p>
</td></tr>
<tr><td><code id="grid.add_+3A_grep">grep</code></td>
<td>
<p>A boolean indicating whether the <code>gPath</code> should
be treated as a regular expression.  Values are recycled across
elements of the <code>gPath</code> (e.g., <code>c(TRUE, FALSE)</code> means
that every odd element of the <code>gPath</code> will be treated as
a regular expression).
</p>
</td></tr>
<tr><td><code id="grid.add_+3A_global">global</code></td>
<td>
<p> A boolean indicating whether the function should affect
just the first match of the <code>gPath</code>, or whether all matches
should be affected.
</p>
</td></tr>
<tr><td><code id="grid.add_+3A_warn">warn</code></td>
<td>
<p>A logical to indicate whether failing to find the
specified gPath should trigger an error.  </p>
</td></tr>
<tr><td><code id="grid.add_+3A_alldevices">allDevices</code></td>
<td>
<p> A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.
</p>
</td></tr>
<tr><td><code id="grid.add_+3A_redraw">redraw</code></td>
<td>
<p>A logical value to indicate whether to redraw the grob. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>addGrob</code> copies the specified grob and returns a modified
grob.
</p>
<p><code>grid.add</code> destructively modifies a grob on the display list.
If <code>redraw</code>
is <code>TRUE</code> it then redraws everything to reflect the change.
</p>
<p><code>setChildren</code> is a basic function for setting all children
of a gTree at once (instead of repeated calls to <code>addGrob</code>).
</p>


<h3>Value</h3>

<p><code>addGrob</code> returns a grob object;  <code>grid.add</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>, <code><a href="#topic+getGrob">getGrob</a></code>,
<code><a href="#topic+addGrob">addGrob</a></code>, <code><a href="#topic+removeGrob">removeGrob</a></code>.
</p>

<hr>
<h2 id='grid.bezier'> Draw a Bezier Curve </h2><span id='topic+grid.bezier'></span><span id='topic+bezierGrob'></span>

<h3>Description</h3>

<p>These functions create and draw Bezier Curves (a curve drawn
relative to 4 control points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.bezier(...)
bezierGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0),
            id = NULL, id.lengths = NULL,
            default.units = "npc", arrow = NULL,
            name = NULL, gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.bezier_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of
spline control points.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of
spline control points.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple beziers.  All locations with the same
<code>id</code> belong to the same bezier.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_id.lengths">id.lengths</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple bezier.  Specifies consecutive blocks of
locations which make up separate beziers.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_arrow">arrow</code></td>
<td>
<p>A list describing arrow heads to place at either end
of the bezier, as produced by the <code>arrow</code> function.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.bezier_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>bezierGrob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a beziergrob (a graphical object describing a
Bezier curve), but only <code>grid.bezier</code>
draws the Bezier curve.
</p>
<p>A Bezier curve is a line drawn relative to 4 control points.
</p>
<p>Missing values are not allowed for <code>x</code> and <code>y</code>
(i.e., it is not valid for a control point to be missing).
</p>
<p>The curve is currently drawn using an approximation based on
X-splines.
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+arrow">arrow</a></code>.
</p>
<p><code><a href="#topic+grid.xspline">grid.xspline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.2, 0.2, 0.4, 0.4)
y &lt;- c(0.2, 0.4, 0.4, 0.2)

grid.newpage()
grid.bezier(x, y)
grid.bezier(c(x, x + .4), c(y + .4, y + .4),
            id=rep(1:2, each=4))
grid.segments(.4, .6, .6, .6)
grid.bezier(x, y,
            gp=gpar(lwd=3, fill="black"),
            arrow=arrow(type="closed"),
            vp=viewport(x=.9))
</code></pre>

<hr>
<h2 id='grid.cap'>
Capture a raster image
</h2><span id='topic+grid.cap'></span>

<h3>Description</h3>

<p>Capture the current contents of a graphics device as a raster
(bitmap) image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.cap()
</code></pre>


<h3>Details</h3>

<p>This function is only implemented for on-screen graphics devices.
</p>


<h3>Value</h3>

<p>A matrix of R colour names, or <code>NULL</code> if not available.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.raster">grid.raster</a></code>
</p>
<p><code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code> to see if it is supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dev.new(width=0.5, height=0.5)
grid.rect()
grid.text("hi")
cap &lt;- grid.cap()
dev.off()

if(!is.null(cap))
    grid.raster(cap, width=0.5, height=0.5, interpolate=FALSE)

</code></pre>

<hr>
<h2 id='grid.circle'> Draw a Circle </h2><span id='topic+grid.circle'></span><span id='topic+circleGrob'></span>

<h3>Description</h3>

<p>Functions to create and draw a circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.circle(x=0.5, y=0.5, r=0.5, default.units="npc", name=NULL,
            gp=gpar(), draw=TRUE, vp=NULL)
circleGrob(x=0.5, y=0.5, r=0.5, default.units="npc", name=NULL,
            gp=gpar(), vp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.circle_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations.</p>
</td></tr>
<tr><td><code id="grid.circle_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations.</p>
</td></tr>
<tr><td><code id="grid.circle_+3A_r">r</code></td>
<td>
<p>A numeric vector or unit object specifying radii.</p>
</td></tr>
<tr><td><code id="grid.circle_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.circle_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.circle_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.circle_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.circle_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a circle grob (a graphical object describing a
circle), but only <code>grid.circle()</code>
draws the circle (and then only if <code>draw</code> is <code>TRUE</code>).
</p>
<p>The radius may be given in any
units;  if the units are <em>relative</em> (e.g., <code>"npc"</code> or
<code>"native"</code>) then the radius will be different depending on
whether it is interpreted as a width or as a height.  In such cases,
the smaller of these two values will be the result.  To see the
effect, type <code>grid.circle()</code> and adjust the size of the window.
</p>
<p>What happens for very small radii is device-dependent: the
circle may become invisible or be shown at a fixed minimum size.
Circles of zero radius will not be plotted.
</p>


<h3>Value</h3>

<p>A circle grob.  <code>grid.circle()</code> returns the value invisibly.
</p>


<h3>Warning</h3>

<p>Negative values for the radius are silently converted to their
absolute value.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>

<hr>
<h2 id='grid.clip'>Set the Clipping Region</h2><span id='topic+grid.clip'></span><span id='topic+clipGrob'></span>

<h3>Description</h3>

<p>These functions set the clipping region within the current viewport
<em>without</em> altering the current coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.clip(...)
clipGrob(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         just = "centre", hjust = NULL, vjust = NULL,
         default.units = "npc", name = NULL, vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.clip_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-location.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-location.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_width">width</code></td>
<td>
<p>A numeric vector or unit object specifying width.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_height">height</code></td>
<td>
<p>A numeric vector or unit object specifying height.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_just">just</code></td>
<td>
<p>The justification of the clip rectangle
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left alignment
and 1 means right alignment.
</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_hjust">hjust</code></td>
<td>
<p>A numeric vector specifying horizontal justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_vjust">vjust</code></td>
<td>
<p>A numeric vector specifying vertical justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.clip_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.clip_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>clipGrob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a clip rectangle (a graphical object describing
a clip rectangle), but only <code>grid.clip</code>
enforces the clipping.
</p>
<p>Pushing or popping a viewport <em>always</em> overrides the clip
region set by a clip grob, regardless of whether that viewport
explicitly enforces a clipping region.
</p>


<h3>Value</h3>

<p><code>clipGrob</code> returns a clip grob.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># draw across entire viewport, but clipped
grid.clip(x = 0.3, width = 0.1)
grid.lines(gp=gpar(col="green", lwd=5))
# draw across entire viewport, but clipped (in different place)
grid.clip(x = 0.7, width = 0.1)
grid.lines(gp=gpar(col="red", lwd=5))
# Viewport sets new clip region
pushViewport(viewport(width=0.5, height=0.5, clip=TRUE))
grid.lines(gp=gpar(col="grey", lwd=3))
# Return to original viewport;  get
# clip region from previous grid.clip()
# (NOT from previous viewport clip region)
popViewport()
grid.lines(gp=gpar(col="black"))
</code></pre>

<hr>
<h2 id='grid.convert'> Convert Between Different grid Coordinate Systems </h2><span id='topic+convertUnit'></span><span id='topic+convertX'></span><span id='topic+convertY'></span><span id='topic+convertWidth'></span><span id='topic+convertHeight'></span>

<h3>Description</h3>

<p>These functions take a unit object and convert it to an
equivalent
unit object in a different coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertX(x, unitTo, valueOnly = FALSE)
convertY(x, unitTo, valueOnly = FALSE)
convertWidth(x, unitTo, valueOnly = FALSE)
convertHeight(x, unitTo, valueOnly = FALSE)
convertUnit(x, unitTo,
             axisFrom = "x", typeFrom = "location",
             axisTo = axisFrom, typeTo = typeFrom,
             valueOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.convert_+3A_x">x</code></td>
<td>
<p> A unit object. </p>
</td></tr>
<tr><td><code id="grid.convert_+3A_unitto">unitTo</code></td>
<td>
<p> The coordinate system to convert the unit to.
See the <code><a href="#topic+unit">unit</a></code> function for valid coordinate systems.</p>
</td></tr>
<tr><td><code id="grid.convert_+3A_axisfrom">axisFrom</code></td>
<td>
<p> Either <code>"x"</code> or <code>"y"</code> to indicate
whether the unit object represents a value in the x- or
y-direction. </p>
</td></tr>
<tr><td><code id="grid.convert_+3A_typefrom">typeFrom</code></td>
<td>
<p> Either <code>"location"</code> or <code>"dimension"</code>
to indicate whether the unit object represents a location or a
length. </p>
</td></tr>
<tr><td><code id="grid.convert_+3A_axisto">axisTo</code></td>
<td>
<p> Same as <code>axisFrom</code>, but applies to the unit object
that is to be created. </p>
</td></tr>
<tr><td><code id="grid.convert_+3A_typeto">typeTo</code></td>
<td>
<p> Same as <code>typeFrom</code>, but applies to the unit object
that is to be created. </p>
</td></tr>
<tr><td><code id="grid.convert_+3A_valueonly">valueOnly</code></td>
<td>
<p> A logical indicating.  If <code>TRUE</code> then
the function does not return a unit object, but rather only the
converted numeric values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>convertUnit</code> function allows for general-purpose
conversions.  The other four functions are just more convenient
front-ends to it for the most common conversions.
</p>
<p>The conversions occur within the current viewport.
</p>
<p>It is not currently possible to convert to all valid coordinate systems
(e.g., <code>"strwidth"</code> or <code>"grobwidth"</code>).  I'm not sure if all of these
are impossible, they just seem implausible at this stage.
</p>
<p>In normal usage of grid, these functions should not be necessary.
If you want to express a location or dimension in inches rather
than user coordinates then you should simply do something like
<code>unit(1, "inches")</code> rather than something like
<code>unit(0.134, "native")</code>.
</p>
<p>In some cases, however, it is necessary for the user to
perform calculations on a unit value and this function becomes
necessary.  In such cases, please take note of the warning below.
</p>


<h3>Value</h3>

<p>A unit object in the specified coordinate system
(unless <code>valueOnly</code> is <code>TRUE</code> in which case
the returned value is a numeric).
</p>


<h3>Warning</h3>

<p>The conversion is only valid for the current device size.
If the device is resized then at least some conversions will
become invalid.  For example, suppose that I create a unit
object as follows: <code>oneinch &lt;- convertUnit(unit(1, "inches"),
    "native")</code>.  Now if I resize the device, the unit object in
<code>oneinch</code> no longer corresponds to a physical length of 1 inch.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+unit">unit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## A tautology
convertX(unit(1, "inches"), "inches")
## The physical units
convertX(unit(2.54, "cm"), "inches")
convertX(unit(25.4, "mm"), "inches")
convertX(unit(72.27, "points"), "inches")
convertX(unit(1/12*72.27, "picas"), "inches")
convertX(unit(72, "bigpts"), "inches")
convertX(unit(1157/1238*72.27, "dida"), "inches")
convertX(unit(1/12*1157/1238*72.27, "cicero"), "inches")
convertX(unit(65536*72.27, "scaledpts"), "inches")
convertX(unit(1/2.54, "inches"), "cm")
convertX(unit(1/25.4, "inches"), "mm")
convertX(unit(1/72.27, "inches"), "points")
convertX(unit(1/(1/12*72.27), "inches"), "picas")
convertX(unit(1/72, "inches"), "bigpts")
convertX(unit(1/(1157/1238*72.27), "inches"), "dida")
convertX(unit(1/(1/12*1157/1238*72.27), "inches"), "cicero")
convertX(unit(1/(65536*72.27), "inches"), "scaledpts")

pushViewport(viewport(width=unit(1, "inches"),
                       height=unit(2, "inches"),
                       xscale=c(0, 1),
                       yscale=c(1, 3)))
  ## Location versus dimension
  convertY(unit(2, "native"), "inches")
  convertHeight(unit(2, "native"), "inches")
  ## From "x" to "y" (the conversion is via "inches")
  convertUnit(unit(1, "native"), "native",
               axisFrom="x", axisTo="y")
  ## Convert several values at once
  convertX(unit(c(0.5, 2.54), c("npc", "cm")),
                c("inches", "native"))
popViewport()
## Convert a complex unit
convertX(unit(1, "strwidth", "Hello"), "native")
</code></pre>

<hr>
<h2 id='grid.copy'>Make a Copy of a Grid Graphical Object</h2><span id='topic+grid.copy'></span>

<h3>Description</h3>

<p>This function is redundant and will disappear in future versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.copy(grob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.copy_+3A_grob">grob</code></td>
<td>
<p>A grob object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of the grob object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.grob">grid.grob</a></code>.
</p>

<hr>
<h2 id='grid.curve'> Draw a Curve Between Locations </h2><span id='topic+grid.curve'></span><span id='topic+curveGrob'></span><span id='topic+arcCurvature'></span>

<h3>Description</h3>

<p>These functions create and draw a curve from one location
to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.curve(...)
curveGrob(x1, y1, x2, y2, default.units = "npc",
          curvature = 1, angle = 90, ncp = 1, shape = 0.5,
          square = TRUE, squareShape = 1,
          inflect = FALSE, arrow = NULL, open = TRUE,
          debug = FALSE,
          name = NULL, gp = gpar(), vp = NULL)
arcCurvature(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.curve_+3A_x1">x1</code></td>
<td>
<p>A numeric vector or unit object specifying the x-location of
the start point.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_y1">y1</code></td>
<td>
<p>A numeric vector or unit object specifying the y-location of
the start point.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_x2">x2</code></td>
<td>
<p>A numeric vector or unit object specifying the x-location of
the end point.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_y2">y2</code></td>
<td>
<p>A numeric vector or unit object specifying the y-location of
the end point.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x1</code>, <code>y1</code>, <code>x2</code> or <code>y2</code>
are only given as numeric values.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_curvature">curvature</code></td>
<td>
<p>A numeric value giving the amount of curvature.
Negative values produce left-hand curves, positive values
produce right-hand curves, and zero produces a straight line.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_angle">angle</code></td>
<td>
<p>A numeric value between 0 and 180,
giving an amount to skew the control
points of the curve.  Values less than 90 skew the curve towards
the start point and values greater than 90 skew the curve
towards the end point.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_ncp">ncp</code></td>
<td>
<p>The number of control points used to draw the curve.
More control points creates a smoother curve.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_shape">shape</code></td>
<td>
<p>A numeric vector of values between -1 and 1, which
control the shape of the curve relative to its control points.
See <code>grid.xspline</code> for more details.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_square">square</code></td>
<td>
<p>A logical value that controls whether control
points for the curve are created city-block fashion or
obliquely.  When <code>ncp</code> is 1 and <code>angle</code> is 90,
this is typically <code>TRUE</code>, otherwise this should probably
be set to <code>FALSE</code> (see Examples below).</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_squareshape">squareShape</code></td>
<td>
<p>A <code>shape</code> value to control the behaviour
of the curve relative to any additional control point that
is inserted if <code>square</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_inflect">inflect</code></td>
<td>
<p>A logical value specifying whether the curve
should be cut in half and inverted (see Examples below).</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_arrow">arrow</code></td>
<td>
<p>A list describing arrow heads to place at either end
of the curve, as produced by the <code>arrow</code> function.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_open">open</code></td>
<td>
<p>A logical value indicating whether to close the curve
(connect the start and end points).</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_debug">debug</code></td>
<td>
<p>A logical value indicating whether debugging
information should be drawn.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.curve_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>curveGrob</code>.</p>
</td></tr>
<tr><td><code id="grid.curve_+3A_theta">theta</code></td>
<td>
<p>An angle (in degrees).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a curve grob (a graphical object describing an
curve), but only <code>grid.curve</code>
draws the curve.
</p>
<p>The <code>arcCurvature</code> function can be used to calculate a
<code>curvature</code> such that control points are generated on
an arc corresponding to angle <code>theta</code>.  This is typically
used in conjunction with a large <code>ncp</code> to produce a curve
corresponding to the desired arc.
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+grid.xspline">grid.xspline</a></code>,
<code><a href="#topic+arrow">arrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curveTest &lt;- function(i, j, ...) {
  pushViewport(viewport(layout.pos.col=j, layout.pos.row=i))
  do.call("grid.curve", c(list(x1=.25, y1=.25, x2=.75, y2=.75), list(...)))
  grid.text(sub("list\\((.*)\\)", "\\1",
                deparse(substitute(list(...)))),
            y=unit(1, "npc"))
  popViewport()
}
# grid.newpage()
pushViewport(plotViewport(c(0, 0, 1, 0),
                          layout=grid.layout(2, 1, heights=c(2, 1))))
pushViewport(viewport(layout.pos.row=1,
                      layout=grid.layout(3, 3, respect=TRUE)))
curveTest(1, 1)
curveTest(1, 2, inflect=TRUE)
curveTest(1, 3, angle=135)
curveTest(2, 1, arrow=arrow())
curveTest(2, 2, ncp=8)
curveTest(2, 3, shape=0)
curveTest(3, 1, curvature=-1)
curveTest(3, 2, square=FALSE)
curveTest(3, 3, debug=TRUE)
popViewport()
pushViewport(viewport(layout.pos.row=2,
                      layout=grid.layout(3, 3)))
curveTest(1, 1)
curveTest(1, 2, inflect=TRUE)
curveTest(1, 3, angle=135)
curveTest(2, 1, arrow=arrow())
curveTest(2, 2, ncp=8)
curveTest(2, 3, shape=0)
curveTest(3, 1, curvature=-1)
curveTest(3, 2, square=FALSE)
curveTest(3, 3, debug=TRUE)
popViewport(2)
</code></pre>

<hr>
<h2 id='grid.delay'> Encapsulate calculations and generating a grob </h2><span id='topic+grid.delay'></span><span id='topic+delayGrob'></span>

<h3>Description</h3>

<p>Evaluates an expression that includes both calculations
and generating a grob that depends on the calculations so that
both the calculations and the grob generation will be rerun when
the scene is redrawn (e.g., device resize or editing).
</p>
<p>Intended <em>only</em> for expert use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delayGrob(expr, list, name=NULL, gp=NULL, vp=NULL)
grid.delay(expr, list, name=NULL, gp=NULL, vp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.delay_+3A_expr">expr</code></td>
<td>
<p>object of mode <code><a href="base.html#topic+expression">expression</a></code> or <code>call</code> or
an unevaluated expression.</p>
</td></tr>
<tr><td><code id="grid.delay_+3A_list">list</code></td>
<td>
<p>a list defining the environment in which <code>expr</code> is to
be evaluated.</p>
</td></tr>
<tr><td><code id="grid.delay_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.delay_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.delay_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grob is created of special class <code>"delayedgrob"</code>
(and drawn, in the case of <code>grid.delay</code>).
The <code>makeContent</code> method for this class
evaluates the expression with the list as the evaluation
environment (and the grid Namespace as the parent of that
environment).
</p>
<p>The <code>expr</code> argument should return a grob as its result.
</p>
<p>These functions are analogues of the <code>grid.record()</code>
and <code>recordGrob()</code> functions;  the difference is that
these functions are based on the <code>makeContent()</code> hook,
while those functions are based on the <code>drawDetails()</code>
hook.
</p>


<h3>Note</h3>

<p> This function <em>must</em> be used instead of the
function <code>recordGraphics</code>;  all of the dire warnings
about using <code>recordGraphics</code> responsibly also apply here.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="grDevices.html#topic+recordGraphics">recordGraphics</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.delay({
              w &lt;- convertWidth(unit(1, "inches"), "npc")
              rectGrob(width=w)
            },
            list())
</code></pre>

<hr>
<h2 id='grid.display.list'>Control the Grid Display List</h2><span id='topic+grid.display.list'></span><span id='topic+engine.display.list'></span>

<h3>Description</h3>

<p>Turn the Grid display list on or off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.display.list(on=TRUE)
engine.display.list(on=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.display.list_+3A_on">on</code></td>
<td>
<p>A logical value to indicate whether the display list
should be on or off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All drawing and viewport-setting operations are (by default)
recorded in the Grid display list.  This allows redrawing
to occur following an editing operation.
</p>
<p>This display list could get very large so it may be useful to
turn it off in some cases;  this will of course disable redrawing.
</p>
<p>All graphics output is also recorded on the main display list
of the R graphics engine (by default).  This supports redrawing
following a device resize and allows copying between devices.
</p>
<p>Turning off this display list means that grid will redraw from its
own display list for device resizes and copies.  This will be slower
than using the graphics engine display list.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>WARNING</h3>

<p>Turning the display list on causes the display list to be erased!
</p>
<p>Turning off both the grid display list and the graphics engine
display list will result in no redrawing whatsoever.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>

<hr>
<h2 id='grid.DLapply'> Modify the Grid Display List </h2><span id='topic+grid.DLapply'></span>

<h3>Description</h3>

<p>Call a function on each element of the current display list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.DLapply(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.DLapply_+3A_fun">FUN</code></td>
<td>
<p>A function;  the first argument to this function
is passed each element of the display list. 
</p>
</td></tr>
<tr><td><code id="grid.DLapply_+3A_...">...</code></td>
<td>
<p>Further arguments to pass to <code>FUN</code> .</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is insanely dangerous (for the grid display list).
</p>
<p>Two token efforts are made to try to avoid ending up with complete
garbage on the display list:
</p>

<ol>
<li><p> The display list is only replaced once all new elements have
been generated (so an error during generation does not result in a
half-finished display list).
</p>
</li>
<li><p> All new elements must be either <code>NULL</code> or inherit from
the class of the element that they are replacing.
</p>
</li></ol>



<h3>Value</h3>

<p>The side effect of these functions
is usually to modify the grid display list.
</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
grid.rect(width=.4, height=.4, x=.25, y=.75, gp=gpar(fill="black"), name="r1")
grid.rect(width=.4, height=.4, x=.5, y=.5, gp=gpar(fill="grey"), name="r2")
grid.rect(width=.4, height=.4, x=.75, y=.25, gp=gpar(fill="white"), name="r3")
grid.DLapply(function(x) { if (is.grob(x)) x$gp &lt;- gpar(); x })
grid.refresh()
</code></pre>

<hr>
<h2 id='grid.draw'>Draw a grid grob</h2><span id='topic+grid.draw'></span>

<h3>Description</h3>

<p>Produces graphical output from a graphical object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.draw(x, recording=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.draw_+3A_x">x</code></td>
<td>
<p>An object of class <code>"grob"</code> or NULL.</p>
</td></tr>
<tr><td><code id="grid.draw_+3A_recording">recording</code></td>
<td>
<p>A logical value to indicate whether the drawing
operation should be recorded on the Grid display list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function with methods for grob and gTree objects.
</p>
<p>The grob and gTree methods automatically push any viewports in a
<code>vp</code> slot and automatically apply any <code>gpar</code> settings
in a <code>gp</code> slot.  In addition, the gTree method pushes and
ups any viewports in a <code>childrenvp</code> slot and automatically
calls <code>grid.draw</code> for any grobs in a <code>children</code> slot.
</p>
<p>The methods for grob and gTree call the generic hook functions
<code>preDrawDetails</code>, <code>drawDetails</code>, and <code>postDrawDetails</code>
to allow classes derived from grob or gTree to perform
additional viewport pushing/popping and produce additional
output beyond the default behaviour for grobs and gTrees.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
## Create a graphical object, but don't draw it
l &lt;- linesGrob()
## Draw it
grid.draw(l)
</code></pre>

<hr>
<h2 id='grid.edit'>Edit the Description of a Grid Graphical Object</h2><span id='topic+grid.edit'></span><span id='topic+grid.gedit'></span><span id='topic+editGrob'></span>

<h3>Description</h3>

<p>Changes the value of one of the slots of a grob
and redraws the grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.edit(gPath, ..., strict = FALSE, grep = FALSE,
          global = FALSE, allDevices = FALSE, redraw = TRUE)

grid.gedit(..., grep = TRUE, global = TRUE)

editGrob(grob, gPath = NULL, ..., strict = FALSE, grep = FALSE,
         global = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.edit_+3A_grob">grob</code></td>
<td>
<p>A grob object.</p>
</td></tr>
<tr><td><code id="grid.edit_+3A_...">...</code></td>
<td>
<p>Zero or more named arguments specifying new slot values.</p>
</td></tr>
<tr><td><code id="grid.edit_+3A_gpath">gPath</code></td>
<td>
<p> A gPath object. For <code>grid.edit</code> this
specifies a grob on the display list.  For <code>editGrob</code> this
specifies a descendant of the specified grob. </p>
</td></tr>
<tr><td><code id="grid.edit_+3A_strict">strict</code></td>
<td>
<p> A boolean indicating whether the gPath must be
matched exactly. </p>
</td></tr>
<tr><td><code id="grid.edit_+3A_grep">grep</code></td>
<td>
<p>A boolean indicating whether the <code>gPath</code> should
be treated as a regular expression.  Values are recycled across
elements of the <code>gPath</code> (e.g., <code>c(TRUE, FALSE)</code> means
that every odd element of the <code>gPath</code> will be treated as
a regular expression).
</p>
</td></tr>
<tr><td><code id="grid.edit_+3A_global">global</code></td>
<td>
<p> A boolean indicating whether the function should affect
just the first match of the <code>gPath</code>, or whether all matches
should be affected.
</p>
</td></tr>
<tr><td><code id="grid.edit_+3A_warn">warn</code></td>
<td>
<p>A logical to indicate whether failing to find the
specified gPath should trigger an error.  </p>
</td></tr>
<tr><td><code id="grid.edit_+3A_alldevices">allDevices</code></td>
<td>
<p> A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.
</p>
</td></tr>
<tr><td><code id="grid.edit_+3A_redraw">redraw</code></td>
<td>
<p>A logical value to indicate whether to redraw the grob. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>editGrob</code> copies the specified grob and returns a modified
grob.
</p>
<p><code>grid.edit</code> destructively modifies a grob on the display list.
If <code>redraw</code>
is <code>TRUE</code> it then redraws everything to reflect the change.
</p>
<p>Both functions call <code>editDetails</code> to allow a grob to perform
custom actions and <code>validDetails</code> to check that the modified grob
is still coherent.
</p>
<p><code>grid.gedit</code> (<code>g</code> for global) is just a convenience wrapper for
<code>grid.edit</code> with different defaults.
</p>


<h3>Value</h3>

<p><code>editGrob</code> returns a grob object;  <code>grid.edit</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>, <code><a href="#topic+getGrob">getGrob</a></code>,
<code><a href="#topic+addGrob">addGrob</a></code>, <code><a href="#topic+removeGrob">removeGrob</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
grid.xaxis(name = "xa", vp = viewport(width=.5, height=.5))
grid.edit("xa", gp = gpar(col="red"))
# won't work because no ticks (at is NULL)
try(grid.edit(gPath("xa", "ticks"), gp = gpar(col="green")))
grid.edit("xa", at = 1:4/5)
# Now it should work
try(grid.edit(gPath("xa", "ticks"), gp = gpar(col="green")))
</code></pre>

<hr>
<h2 id='grid.force'> Force a grob into its components </h2><span id='topic+grid.force'></span><span id='topic+grid.force.default'></span><span id='topic+grid.force.gPath'></span><span id='topic+grid.force.grob'></span><span id='topic+forceGrob'></span><span id='topic+grid.revert'></span><span id='topic+grid.revert.gPath'></span><span id='topic+grid.revert.grob'></span>

<h3>Description</h3>

<p>Some grobs only generate their content to draw at
drawing time;  this function replaces such grobs with
their at-drawing-time content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.force(x, ...)
## Default S3 method:
grid.force(x, redraw = FALSE, ...)
## S3 method for class 'gPath'
grid.force(x, strict = FALSE, grep = FALSE, global = FALSE,
                           redraw = FALSE, ...) 
## S3 method for class 'grob'
grid.force(x, draw = FALSE, ...)
forceGrob(x)
grid.revert(x, ...)
## S3 method for class 'gPath'
grid.revert(x, strict = FALSE, grep = FALSE, global = FALSE,
                            redraw = FALSE, ...) 
## S3 method for class 'grob'
grid.revert(x, draw = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.force_+3A_x">x</code></td>
<td>

<p>For the default method, <code>x</code> should not be specified.
Otherwise, <code>x</code> should be a grob or a gPath.
If <code>x</code> is character, it is assumed to be a gPath.
</p>
</td></tr>
<tr><td><code id="grid.force_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.force_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.force_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
<tr><td><code id="grid.force_+3A_draw">draw</code></td>
<td>
<p>logical value indicating whether a grob should be
drawn after it is forced.
</p>
</td></tr>
<tr><td><code id="grid.force_+3A_redraw">redraw</code></td>
<td>
<p>logical value indicating whether to redraw the
<span class="pkg">grid</span> scene after the forcing operation.
</p>
</td></tr>
<tr><td><code id="grid.force_+3A_...">...</code></td>
<td>
<p> Further arguments for use by methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some grobs wait until drawing time to generate what content
will actually be drawn (an axis, as produced by <code>grid.xaxis()</code>,
with an <code>at</code> or <code>NULL</code> is a good example because it
has to see what viewport it is going to be drawn in before
it can decide what tick marks to draw).
</p>
<p>The content of such grobs (e.g., the tick marks) are not usually
visible to <code>grid.ls()</code> or accessible to <code>grid.edit()</code>.
</p>
<p>The <code>grid.force()</code> function <em>replaces</em> a grob with its
at-drawing-time contents.  For example, an axis will be
replaced by a vanilla gTree with lines and text representing
the axis tick marks that were actually drawn.  This makes
the tick marks
visible to <code>grid.ls()</code> and accessible to <code>grid.edit()</code>.
</p>
<p>The <code>forceGrob()</code> function is the internal work horse for
<code>grid.force()</code>, so will not normally be called directly by
the user.  It is exported so that methods can be written for
custom grob classes if necessary.
</p>
<p>The <code>grid.revert()</code> function reverses the effect of
<code>grid.force()</code>, replacing forced content with the original
grob.
</p>


<h3>Warning</h3>

<p>Forcing an explicit grob produces a result as if the grob were
drawn in the <em>current</em> drawing context.
It may not make sense to draw the result in a different
drawing context.
</p>


<h3>Note</h3>

<p>These functions only have an effect for grobs that generate their content
at drawing time using <code>makeContext()</code> and <code>makeContent()</code>
methods (<em>not</em> for grobs that generate their content
at drawing time using <code>preDrawDetails()</code> and
<code>drawDetails()</code> methods).
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
pushViewport(viewport(width=.5, height=.5))
# Draw xaxis
grid.xaxis(name="xax")
grid.ls()
# Force xaxis
grid.force()
grid.ls()
# Revert xaxis
grid.revert()
grid.ls()
# Draw and force yaxis
grid.force(yaxisGrob(), draw=TRUE)
grid.ls()
# Revert yaxis
grid.revert()
grid.ls()
# Force JUST xaxis
grid.force("xax")
grid.ls()
# Force ALL
grid.force()
grid.ls()
# Revert JUST xaxis
grid.revert("xax")
grid.ls()
</code></pre>

<hr>
<h2 id='grid.frame'> Create a Frame for Packing Objects </h2><span id='topic+grid.frame'></span><span id='topic+frameGrob'></span>

<h3>Description</h3>

<p>These functions, together with <code>grid.pack</code>,
<code>grid.place</code>, <code>packGrob</code>, and <code>placeGrob</code> are part of a
GUI-builder-like interface to constructing graphical images.
The idea is that you create a frame with this function then
use <code>grid.pack</code> or whatever to pack/place objects into the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.frame(layout=NULL, name=NULL, gp=gpar(), vp=NULL, draw=TRUE)
frameGrob(layout=NULL, name=NULL, gp=gpar(), vp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.frame_+3A_layout">layout</code></td>
<td>
<p> A Grid layout, or NULL. This can be used to initialise
the frame with a number of rows and columns, with initial widths
and heights, etc. </p>
</td></tr>
<tr><td><code id="grid.frame_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.frame_+3A_vp">vp</code></td>
<td>
<p> An object of class <code>viewport</code>, or NULL. </p>
</td></tr>
<tr><td><code id="grid.frame_+3A_gp">gp</code></td>
<td>
<p> An object of class <code>"gpar"</code>;  typically the output from
a call to the function <code><a href="#topic+gpar">gpar</a></code>.</p>
</td></tr>
<tr><td><code id="grid.frame_+3A_draw">draw</code></td>
<td>
<p> Should the frame be drawn.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a frame grob (a graphical object describing a
frame), but only <code>grid.frame()</code>
draws the frame (and then only if <code>draw</code> is <code>TRUE</code>).
Nothing will actually be
drawn, but it will put the frame on the display list, which means
that the output will be dynamically updated as objects are packed
into the frame.  Possibly useful for debugging.
</p>


<h3>Value</h3>

<p>A frame grob.  <code>grid.frame()</code> returns the value invisibly.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pack">grid.pack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
grid.frame(name="gf", draw=TRUE)
grid.pack("gf", rectGrob(gp=gpar(fill="grey")), width=unit(1, "null"))
grid.pack("gf", textGrob("hi there"), side="right")
</code></pre>

<hr>
<h2 id='grid.function'>Draw a curve representing a function</h2><span id='topic+grid.function'></span><span id='topic+functionGrob'></span><span id='topic+grid.abline'></span>

<h3>Description</h3>

<p>Draw a curve representing a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.function(...)
functionGrob(f, n = 101, range = "x", units = "native",
             name = NULL, gp=gpar(), vp = NULL)

grid.abline(intercept, slope, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.function_+3A_f">f</code></td>
<td>
<p> A function that must take a single argument
and return a list with two numeric components named <code>x</code> and
<code>y</code>.</p>
</td></tr>
<tr><td><code id="grid.function_+3A_n">n</code></td>
<td>
<p> The number values that will be generated as input
to the function <code>f</code>.</p>
</td></tr>
<tr><td><code id="grid.function_+3A_range">range</code></td>
<td>
<p> Either <code>"x"</code>, <code>"y"</code>, or a numeric vector.
See the &lsquo;Details&rsquo; section.</p>
</td></tr>
<tr><td><code id="grid.function_+3A_units">units</code></td>
<td>
<p>A string indicating the units to use
for the <code>x</code> and <code>y</code> values generated by the function.</p>
</td></tr>
<tr><td><code id="grid.function_+3A_intercept">intercept</code></td>
<td>
<p> Numeric.</p>
</td></tr>
<tr><td><code id="grid.function_+3A_slope">slope</code></td>
<td>
<p> Numeric. </p>
</td></tr>
<tr><td><code id="grid.function_+3A_...">...</code></td>
<td>
<p> Arguments passed to <code>grid.function()</code></p>
</td></tr>
<tr><td><code id="grid.function_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.function_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.function_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n</code> values are generated and passed to the function <code>f</code>
and a series of lines are
drawn through the resulting <code>x</code> and <code>y</code> values.
</p>
<p>The generation of the <code>n</code> values depends on the value of
<code>range</code>.  In the default case, <code>dim</code> is
<code>"x"</code>, which means that a set
of <code>x</code> values are generated covering the range of the current
viewport scale in the x-dimension.  If <code>dim</code> is <code>"y"</code>
then values are generated from the current y-scale instead.
If <code>range</code> is a numeric vector, then values are generated
from that range.
</p>
<p><code>grid.abline()</code> provides a simple front-end for a straight
line parameterized by <code>intercept</code> and <code>slope</code>.
</p>


<h3>Value</h3>

<p>A functiongrob grob.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    # abline
    # NOTE: in ROOT viewport on screen, (0, 0) at top-left
    #       and "native" is pixels!
    grid.function(function(x) list(x=x, y=0 + 1*x))
    # a more "normal" viewport with default normalized "native" coords
    grid.newpage()
    pushViewport(viewport())
    grid.function(function(x) list(x=x, y=0 + 1*x))
    # slightly simpler
    grid.newpage()
    pushViewport(viewport())
    grid.abline()
    # sine curve
    grid.newpage()
    pushViewport(viewport(xscale=c(0, 2*pi), yscale=c(-1, 1)))
    grid.function(function(x) list(x=x, y=sin(x)))
    # constrained sine curve
    grid.newpage()
    pushViewport(viewport(xscale=c(0, 2*pi), yscale=c(-1, 1)))
    grid.function(function(x) list(x=x, y=sin(x)),
                  range=0:1)
    # inverse sine curve
    grid.newpage()
    pushViewport(viewport(xscale=c(-1, 1), yscale=c(0, 2*pi)))
    grid.function(function(y) list(x=sin(y), y=y),
                  range="y")
    # parametric function
    grid.newpage()
    pushViewport(viewport(xscale=c(-1, 1), yscale=c(-1, 1)))
    grid.function(function(t) list(x=cos(t), y=sin(t)),
                  range=c(0, 9*pi/5))
    # physical abline
    grid.newpage()
    grid.function(function(x) list(x=x, y=0 + 1*x),
                  units="in")
</code></pre>

<hr>
<h2 id='grid.get'>Get a Grid Graphical Object</h2><span id='topic+grid.get'></span><span id='topic+grid.gget'></span><span id='topic+getGrob'></span>

<h3>Description</h3>

<p>Retrieve a grob or a descendant of a grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.get(gPath, strict = FALSE, grep = FALSE, global = FALSE,
         allDevices = FALSE)

grid.gget(..., grep = TRUE, global = TRUE)

getGrob(gTree, gPath, strict = FALSE, grep = FALSE, global = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.get_+3A_gtree">gTree</code></td>
<td>
<p>A gTree object.</p>
</td></tr>
<tr><td><code id="grid.get_+3A_gpath">gPath</code></td>
<td>
<p> A gPath object. For <code>grid.get</code> this
specifies a grob on the display list.  For <code>getGrob</code> this
specifies a descendant of the specified gTree. </p>
</td></tr>
<tr><td><code id="grid.get_+3A_strict">strict</code></td>
<td>
<p> A boolean indicating whether the gPath must be
matched exactly. </p>
</td></tr>
<tr><td><code id="grid.get_+3A_grep">grep</code></td>
<td>
<p>A boolean indicating whether the <code>gPath</code> should
be treated as a regular expression.  Values are recycled across
elements of the <code>gPath</code> (e.g., <code>c(TRUE, FALSE)</code> means
that every odd element of the <code>gPath</code> will be treated as
a regular expression).
</p>
</td></tr>
<tr><td><code id="grid.get_+3A_global">global</code></td>
<td>
<p> A boolean indicating whether the function should affect
just the first match of the <code>gPath</code>, or whether all matches
should be affected.
</p>
</td></tr>
<tr><td><code id="grid.get_+3A_alldevices">allDevices</code></td>
<td>
<p> A boolean indicating whether all open devices
should
be searched for matches, or just the current device.
NOT YET IMPLEMENTED.
</p>
</td></tr>
<tr><td><code id="grid.get_+3A_...">...</code></td>
<td>
<p> Arguments that are passed to <code>grid.get</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grid.gget</code> (<code>g</code> for global) is just a convenience wrapper for
<code>grid.get</code> with different defaults.
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>, <code><a href="#topic+getGrob">getGrob</a></code>,
<code><a href="#topic+addGrob">addGrob</a></code>, <code><a href="#topic+removeGrob">removeGrob</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.xaxis(name="xa")
grid.get("xa")
grid.get(gPath("xa", "ticks"))

grid.draw(gTree(name="gt", children=gList(xaxisGrob(name="axis"))))
grid.get(gPath("gt", "axis", "ticks"))
</code></pre>

<hr>
<h2 id='grid.glyph'>Draw Typeset Glyphs</h2><span id='topic+grid.glyph'></span><span id='topic+glyphGrob'></span>

<h3>Description</h3>

<p>These functions create and draw a set of typeset glyphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.glyph(...)
glyphGrob(glyphInfo,
          x=.5, y=.5, default.units="npc",
          hjust="centre", vjust="centre",
          gp=gpar(), vp=NULL, name=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.glyph_+3A_glyphinfo">glyphInfo</code></td>
<td>
<p>An <code>"RGlyphInfo"</code> object from a call to
<code><a href="grDevices.html#topic+glyphInfo">glyphInfo</a></code>.</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-location.</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-location.</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_hjust">hjust</code>, <code id="grid.glyph_+3A_vjust">vjust</code></td>
<td>
<p>The justification of the glyphs
relative to the (<code>x</code>, <code>y</code>) location.
Can be <code>character</code> (e.g., <code>"left"</code>),
numeric (e.g., <code>0</code>), or the result of a call to
<code><a href="grDevices.html#topic+glyphJust">glyphJust</a></code>.
</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.glyph_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>glyphGrob()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a glyph grob (a graphical object describing
glyphs), but only <code>grid.glyph</code>
draws the glyphs.
</p>


<h3>Value</h3>

<p>A glyph grob. 
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="grDevices.html#topic+glyphInfo">glyphInfo</a></code>
</p>

<hr>
<h2 id='grid.grab'> Grab the current grid output </h2><span id='topic+grid.grab'></span><span id='topic+grid.grabExpr'></span>

<h3>Description</h3>

<p>Creates a gTree object from the current grid display list
or from a scene generated by user-specified code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.grab(warn = 2, wrap = wrap.grobs, wrap.grobs = FALSE, ...)
grid.grabExpr(expr, warn = 2, wrap = wrap.grobs, wrap.grobs = FALSE, 
              width = 7, height = 7, device = offscreen, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.grab_+3A_expr">expr</code></td>
<td>
<p> An expression to be evaluated.  Typically,
some calls to grid drawing functions. </p>
</td></tr>
<tr><td><code id="grid.grab_+3A_warn">warn</code></td>
<td>
<p> An integer specifying the amount of warnings
to emit.  0 means no warnings, 1 means warn when it is
certain that the grab will not faithfully represent the
original scene. 2 means warn if there's any possibility
that the grab will not faithfully represent the
original scene.
</p>
</td></tr>
<tr><td><code id="grid.grab_+3A_wrap">wrap</code></td>
<td>
<p> A logical indicating how the output should
be captured. If <code>TRUE</code>, each non-grob element on the
display list is captured by wrapping it in a grob.
</p>
</td></tr>
<tr><td><code id="grid.grab_+3A_wrap.grobs">wrap.grobs</code></td>
<td>
<p> A logical indicating whether, if we are wrapping
elements (<code>wrap=TRUE</code>), we should wrap grobs (or just
wrap viewports).
</p>
</td></tr>
<tr><td><code id="grid.grab_+3A_width">width</code>, <code id="grid.grab_+3A_height">height</code></td>
<td>
<p> Size of the device used for temporary
rendering. </p>
</td></tr>
<tr><td><code id="grid.grab_+3A_device">device</code></td>
<td>
<p> A function that opens a graphics device for temporary
rendering. By default this is an off-screen, in-memory device
based on the <code>pdf</code> device, but this default device may not be
satisfactory when using custom fonts.
</p>
</td></tr>
<tr><td><code id="grid.grab_+3A_...">...</code></td>
<td>
<p> arguments passed to gTree, for example, a
name and/or class for the gTree that is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four ways to capture grid output as a gTree.
</p>
<p>There are two functions for capturing output:
use <code>grid.grab</code> to capture an existing drawing
and <code>grid.grabExpr</code> to capture the output from
an expression (without drawing anything).
</p>
<p>For each of these functions, the output can be captured in
two ways.  One way tries to be clever and make a
gTree with a childrenvp slot containing all viewports on
the display list (including those
that are popped) and every
grob on the display list as a child of the new
gTree;  each child has a vpPath in the vp slot so that it is
drawn in the appropriate viewport.
In other words, the gTree contains all elements on the display
list, but in a slightly altered form.
</p>
<p>The other way, <code>wrap=TRUE</code>,
is to create a grob for every element on the
display list (and make all of those grobs children of the
gTree).  Only viewports are
wrapped unless <code>wrap.grobs</code> is also <code>TRUE</code>.
</p>
<p>The first approach creates a more compact and elegant gTree,
which is more flexible to work with,
but is not guaranteed to faithfully replicate all possible
grid output.  The second approach is more brute force, and
harder to work with, but is more likely to replicate the original
output.
</p>
<p>An example of a case that will NOT be replicated by wrapping,
with <code>wrap.grobs=TRUE</code>, is
a scene where the placement of one grob is dependent on another grob
(e.g., via <code>grobX</code> or <code>grobWidth</code>).
</p>


<h3>Value</h3>

<p>A gTree object.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gTree">gTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pushViewport(viewport(width=.5, height=.5))
grid.rect()
grid.points(stats::runif(10), stats::runif(10))
popViewport()
grab &lt;- grid.grab()
grid.newpage()
grid.draw(grab)
</code></pre>

<hr>
<h2 id='grid.grep'>
Search for Grobs and/or Viewports
</h2><span id='topic+grid.grep'></span>

<h3>Description</h3>

<p>Given a path, find all matching grobs and/or viewports on the display list
or within a given grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.grep(path, x = NULL, grobs = TRUE, viewports = FALSE,
          strict = FALSE, grep = FALSE, global = FALSE,
          no.match = character(), vpPath = viewports)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.grep_+3A_path">path</code></td>
<td>
<p> a gPath or a vpPath or a character value that could be
interpreted as either. </p>
</td></tr>
<tr><td><code id="grid.grep_+3A_x">x</code></td>
<td>
<p> a grob or <code>NULL</code>.  If <code>NULL</code>, the display list
is searched.
</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_grobs">grobs</code></td>
<td>
<p>A logical value indicating whether to search for grobs.</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_viewports">viewports</code></td>
<td>
<p>A logical value indicating whether to search for
viewports.</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_no.match">no.match</code></td>
<td>

<p>The value to return if no matches are found.
</p>
</td></tr>
<tr><td><code id="grid.grep_+3A_vppath">vpPath</code></td>
<td>

<p>A logical value indicating whether to return the vpPath for each
grob as an attribute of the result.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a gPath or a vpPath or,
if <code>global</code> is <code>TRUE</code> a list of gPaths and/or vpPaths.
</p>
<p>If <code>vpPath</code> is <code>TRUE</code>, each gPath result will have an
attribute <code>"vpPath"</code>.
</p>
<p>If there are no matches, <code>no.match</code> is returned.
</p>


<h3>See Also</h3>

<p>grid.ls()
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A gTree, called "grandparent", with child gTree,
# called "parent", with childrenvp vpStack (vp2 within vp1)
# and child grob, called "child", with vp vpPath (down to vp2)
sampleGTree &lt;- gTree(name="grandparent",
                     children=gList(gTree(name="parent",
                          children=gList(grob(name="child", vp="vp1::vp2")),
                          childrenvp=vpStack(viewport(name="vp1"),
                                             viewport(name="vp2")))))
# Searching for grobs
grid.grep("parent", sampleGTree)
grid.grep("parent", sampleGTree, strict=TRUE)
grid.grep("grandparent", sampleGTree, strict=TRUE)
grid.grep("grandparent::parent", sampleGTree)
grid.grep("parent::child", sampleGTree)
grid.grep("[a-z]", sampleGTree, grep=TRUE)
grid.grep("[a-z]", sampleGTree, grep=TRUE, global=TRUE)
# Searching for viewports
grid.grep("vp1", sampleGTree, viewports=TRUE)
grid.grep("vp2", sampleGTree, viewports=TRUE)
grid.grep("vp", sampleGTree, viewports=TRUE, grep=TRUE)
grid.grep("vp2", sampleGTree, viewports=TRUE, strict=TRUE)
grid.grep("vp1::vp2", sampleGTree, viewports=TRUE)
# Searching for both
grid.grep("[a-z]", sampleGTree, viewports=TRUE, grep=TRUE, global=TRUE)
</code></pre>

<hr>
<h2 id='grid.grill'>Draw a Grill</h2><span id='topic+grid.grill'></span>

<h3>Description</h3>

<p>This function draws a grill within a Grid viewport.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.grill(h = unit(seq(0.25, 0.75, 0.25), "npc"),
           v = unit(seq(0.25, 0.75, 0.25), "npc"),
           default.units = "npc", gp=gpar(col = "grey"), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.grill_+3A_h">h</code></td>
<td>
<p>A numeric vector or unit object
indicating the horizontal location of the
vertical grill lines.</p>
</td></tr>
<tr><td><code id="grid.grill_+3A_v">v</code></td>
<td>
<p>A numeric vector or unit object
indicating the vertical location of the
horizontal grill lines.</p>
</td></tr>
<tr><td><code id="grid.grill_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>h</code> or <code>v</code> are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.grill_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.grill_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>.
</p>

<hr>
<h2 id='grid.grob'>Create Grid Graphical Objects, aka &quot;Grob&quot;s</h2><span id='topic+grob'></span><span id='topic+gTree'></span><span id='topic+grobTree'></span><span id='topic+childNames'></span><span id='topic+gList'></span><span id='topic+is.grob'></span>

<h3>Description</h3>

<p>Creating grid graphical objects, short (&ldquo;grob&rdquo;s).
</p>
<p><code>grob()</code> and <code>gTree()</code> are the basic creators,
<code>grobTree()</code> and <code>gList()</code> take several grobs to build a new
one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Grob Creation:

grob (..., name = NULL, gp = NULL, vp = NULL, cl = NULL)
gTree(..., name = NULL, gp = NULL, vp = NULL, children = NULL,
      childrenvp = NULL, cl = NULL)
grobTree(..., name = NULL, gp = NULL, vp = NULL,
         childrenvp = NULL, cl = NULL)
gList(...)

## Grob Properties:
childNames(gTree)
is.grob(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.grob_+3A_...">...</code></td>
<td>
<p>For <code>grob</code> and <code>gTree</code>, the
named slots describing important features of
the graphical object.  For <code>gList</code> and <code>grobTree</code>,
a series of grob objects. </p>
</td></tr>
<tr><td><code id="grid.grob_+3A_name">name</code></td>
<td>
<p>a character identifier for the grob.  Used to find the
grob on the display list and/or as a child of another grob. </p>
</td></tr>
<tr><td><code id="grid.grob_+3A_children">children</code></td>
<td>
<p>a <code>"gList"</code> object. </p>
</td></tr>
<tr><td><code id="grid.grob_+3A_childrenvp">childrenvp</code></td>
<td>
<p>a <code><a href="#topic+viewport">viewport</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="grid.grob_+3A_gp">gp</code></td>
<td>
<p>A <code>"gpar"</code> object, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.grob_+3A_vp">vp</code></td>
<td>
<p>a <code><a href="#topic+viewport">viewport</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="grid.grob_+3A_cl">cl</code></td>
<td>
<p>string giving the class attribute for the new class.</p>
</td></tr>
<tr><td><code id="grid.grob_+3A_gtree">gTree</code></td>
<td>
<p>a <code>"gTree"</code> object.</p>
</td></tr>
<tr><td><code id="grid.grob_+3A_x">x</code></td>
<td>
<p> An <span class="rlang"><b>R</b></span> object. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used to create a basic <code>"grob"</code>,
<code>"gTree"</code>, or <code>"gList"</code> object, or a new class derived from
one of these.
</p>
<p>A grid graphical object (&ldquo;grob&rdquo;) is a description of a graphical
item.  These basic classes provide default behaviour for
validating, drawing,
and modifying graphical objects.  Both <code>grob()</code> and
<code>gTree()</code> call the function <code><a href="#topic+validDetails">validDetails</a></code> to check
that the object returned is internally coherent.
</p>
<p>A <code>"gTree"</code> can have other grobs as children;  when a gTree is drawn, it
draws all of its children.  Before drawing its children, a gTree
pushes its <code>childrenvp</code> slot and then navigates back up (calls
<code><a href="#topic+upViewport">upViewport</a></code>) so that the children can specify their location
within the <code>childrenvp</code> via a <code><a href="#topic+vpPath">vpPath</a></code>.
</p>
<p>Grob names need not be unique in general, but all children of a
gTree must have different names.
A grob name can be any string, though it is not
advisable to use the <code><a href="#topic+gPath">gPath</a></code> separator (currently
<code>::</code>) in grob names.
</p>
<p>The function <code>childNames</code> returns the names of the grobs
which are children of a gTree.
</p>
<p>All grid primitives (<code><a href="#topic+grid.lines">grid.lines</a></code>, <code>grid.rect</code>, ...)
and some higher-level grid components (e.g., <code><a href="#topic+grid.xaxis">grid.xaxis</a></code>
and <code>grid.yaxis</code>) are derived from these classes.
</p>
<p><code>grobTree</code> is just a convenient wrapper for <code>gTree</code>
when the only components of the gTree are grobs (so all
unnamed arguments become children of the gTree).
</p>
<p>The <code>grid.grob</code> function is defunct.
</p>


<h3>Value</h3>

<p>An <span class="rlang"><b>R</b></span> object of class <code>"grob"</code>, a <b>gr</b>aphical <b>ob</b>ject.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.draw">grid.draw</a></code>,
<code><a href="#topic+grid.edit">grid.edit</a></code>,
<code><a href="#topic+grid.get">grid.get</a></code>.
</p>

<hr>
<h2 id='grid.group'> Draw a Group </h2><span id='topic+grid.group'></span><span id='topic+groupGrob'></span><span id='topic+grid.define'></span><span id='topic+defineGrob'></span><span id='topic+grid.use'></span><span id='topic+useGrob'></span>

<h3>Description</h3>

<p>These functions define and draw one or more <dfn>groups</dfn>, where
a group is a grob that is drawn in isolation before being
combined with the main image.  The concept of groups
allows for compositing operators, object reuse, and
affine transformations (see the Details section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupGrob(src, op = "over", dst = NULL, coords = TRUE,
          name = NULL, gp=gpar(), vp=NULL) 
grid.group(src, op = "over", dst = NULL, coords = TRUE,
           name = NULL, gp=gpar(), vp=NULL)

defineGrob(src, op = "over", dst = NULL, coords = TRUE,
           name = NULL, gp=gpar(), vp=NULL) 
grid.define(src, op = "over", dst = NULL, coords = TRUE,
            name = NULL, gp=gpar(), vp=NULL)

useGrob(group, transform=viewportTransform,
        name=NULL, gp=gpar(), vp=NULL) 

grid.use(group, transform=viewportTransform,
         name=NULL, gp=gpar(), vp=NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.group_+3A_src">src</code></td>
<td>
<p>A grob.</p>
</td></tr>
<tr><td><code id="grid.group_+3A_op">op</code></td>
<td>
<p>The name of a compositing operator (see Details).</p>
</td></tr>
<tr><td><code id="grid.group_+3A_dst">dst</code></td>
<td>
<p>A grob.</p>
</td></tr>
<tr><td><code id="grid.group_+3A_coords">coords</code></td>
<td>
<p>A logical indicating whether grob coordinates should be
calculated for the group.</p>
</td></tr>
<tr><td><code id="grid.group_+3A_group">group</code></td>
<td>
<p>A character identified referring to the name of a defined group.</p>
</td></tr>
<tr><td><code id="grid.group_+3A_transform">transform</code></td>
<td>
<p>A function that returns an affine transformation
matrix; see <code><a href="#topic+viewportTransform">viewportTransform</a></code>.</p>
</td></tr>
<tr><td><code id="grid.group_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.group_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.group_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the simplest usage, we can use <code>grid.group()</code> to
specify a grob to be drawn in isolation before being combined
with the main image.  This can be different from normal drawing if,
for example, the grob draws more than one shape and there
is a mask currently in effect.
</p>
<p>Another possible use of <code>grid.group()</code> is to specify
both <code>src</code> and <code>dst</code> and combine them
using a compositing operator other than the default
<code>"over"</code>, before combining the result with the main image.
For example, if we use the <code>"dest.out"</code> operator then <code>dst</code>
is only drawn where it is NOT overlapped by <code>src</code>.
The following (extended) Porter-Duff operators are available:
<code>"clear"</code>, <code>"source"</code>, <code>"over"</code>,
<code>"in"</code>, <code>"out"</code>, <code>"atop"</code>,
<code>"dest"</code>, <code>"dest.over"</code>, <code>"dest.in"</code>,
<code>"dest.out"</code>, <code>"dest.atop"</code>, <code>"xor"</code>,
<code>"add"</code>, and <code>"saturate"</code>.
In addition, there are operators corresponding to PDF blend modes:
<code>"multiply"</code>, <code>"screen"</code>, <code>"overlay"</code>,
<code>"darken"</code>, <code>"lighten"</code>, <code>"color.dodge"</code>, <code>"color.burn"</code>,
<code>"hard.light"</code>, <code>"soft.light"</code>, <code>"difference"</code>, and
<code>"exclusion"</code>.
However, even if a graphics device supports groups, it may not support all
compositing operators;  see <code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code>.
</p>
<p>It is also possible to break the process into two steps by
first using <code>grid.define()</code> to define a group and
then <code>grid.use()</code> to draw the group.  This allows for
reuse of a group (define the group once and use it several times).
</p>
<p>If a group is defined in one viewport and used in a different
viewport, an implicit transformation is applied.  This could
be a simple transformation (if the viewports are in different
locations, but are the same size),
or it could be more complex if the viewports are also different
sizes or at different orientations.
</p>
<p><strong>NOTE:</strong> transformations occur on the graphics device
so affect all aspects of drawing.  For example, text
and line widths are transformed as well as locations.
</p>
<p>See <code><a href="#topic+viewportTransform">viewportTransform</a></code> for more information about
transformations and how to customise them.
</p>
<p>Not all graphics devices support these functions: for example
<code>xfig</code> and <code>pictex</code> do not.  For devices that do
provide support, that support may only be partial (e.g., the
Cairo-based devices support more compositing operators than
the <code>pdf()</code> device).
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: on devices without support for groups (or masks or patterns),
##       there will only be two overlapping opaque circles 
grid.newpage()
pat &lt;- pattern(rasterGrob(matrix(c(.5, 1, 1, .5), nrow=2),
                          width=unit(1, "cm"),
                          height=unit(1, "cm"),
                          interpolate=FALSE),
               width=unit(1, "cm"), height=unit(1, "cm"),
               extend="repeat")
grid.rect(gp=gpar(col=NA, fill=pat))
masks &lt;- dev.capabilities()$masks
if (is.character(masks) &amp;&amp; "luminance" %in% masks) {
  mask &lt;- as.mask(rectGrob(gp=gpar(col=NA, fill="grey50")), type="luminance")
} else {
  mask &lt;- rectGrob(gp=gpar(col=NA, fill=rgb(0,0,0,.5)))
}
pushViewport(viewport(mask=mask))
pushViewport(viewport(y=.5, height=.5, just="bottom"))
grid.circle(1:2/3, r=.45, gp=gpar(fill=2:3))
popViewport()
pushViewport(viewport(y=0, height=.5, just="bottom"))
grid.group(circleGrob(1:2/3, r=.45, gp=gpar(fill=2:3)))
popViewport()
</code></pre>

<hr>
<h2 id='grid.layout'>Create a Grid Layout</h2><span id='topic+grid.layout'></span>

<h3>Description</h3>

<p>This function returns a Grid layout, which describes a subdivision
of a rectangular region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.layout(nrow = 1, ncol = 1,
        widths = unit(rep_len(1, ncol), "null"),
        heights = unit(rep_len(1, nrow), "null"),
        default.units = "null", respect = FALSE,
        just="centre")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.layout_+3A_nrow">nrow</code></td>
<td>
<p>An integer describing the number of rows in the layout.</p>
</td></tr>
<tr><td><code id="grid.layout_+3A_ncol">ncol</code></td>
<td>
<p>An integer describing the number of columns in the layout.</p>
</td></tr>
<tr><td><code id="grid.layout_+3A_widths">widths</code></td>
<td>
<p>A numeric vector or unit object
describing the widths of the columns
in the layout.</p>
</td></tr>
<tr><td><code id="grid.layout_+3A_heights">heights</code></td>
<td>
<p>A numeric vector or unit object
describing the heights of the rows
in the layout.</p>
</td></tr>
<tr><td><code id="grid.layout_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>widths</code> or <code>heights</code> are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.layout_+3A_respect">respect</code></td>
<td>
<p>A logical value or a numeric matrix.
If a logical, this indicates whether
row heights and column widths should respect each other.
If a matrix, non-zero values indicate that the corresponding
row and column should be respected (see examples below).
</p>
</td></tr>
<tr><td><code id="grid.layout_+3A_just">just</code></td>
<td>
<p>A string or numeric
vector specifying how the
layout should be
justified if it is not the same size as its parent viewport.
If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left alignment
and 1 means right alignment. NOTE that in this context,
<code>"left"</code>, for example, means align the left
edge of the left-most layout column with the left edge of the
parent viewport.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unit objects given for the <code>widths</code> and <code>heights</code>
of a layout may use a special <code>units</code> that only has
meaning for layouts.  This is the <code>"null"</code> unit, which
indicates what relative fraction of the available width/height the
column/row occupies.  See the reference for a better description
of relative widths and heights in layouts.
</p>


<h3>Value</h3>

<p>A Grid layout object.
</p>


<h3>WARNING</h3>

<p>This function must NOT be confused with the base R graphics function
<code>layout</code>.  In particular, do not use <code>layout</code> in
combination with Grid graphics.  The documentation for
<code>layout</code> may provide some useful information and this
function should behave identically in comparable situations.  The
<code>grid.layout</code>
function has <em>added</em> the ability to specify a broader range
of units for row heights and column widths, and allows for nested
layouts (see <code>viewport</code>).
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>References</h3>

<p>Murrell, P. R. (1999).
Layouts: A Mechanism for Arranging Plots on a Page.
<em>Journal of Computational and Graphical Statistics</em>, <b>8</b>,
121&ndash;134.
<a href="https://doi.org/10.2307/1390924">doi:10.2307/1390924</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+grid.show.layout">grid.show.layout</a></code>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="graphics.html#topic+layout">layout</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A variety of layouts (some a bit mid-bending ...)
layout.torture()
## Demonstration of layout justification
grid.newpage()
testlay &lt;- function(just="centre") {
  pushViewport(viewport(layout=grid.layout(1, 1, widths=unit(1, "inches"),
                          heights=unit(0.25, "npc"),
                          just=just)))
  pushViewport(viewport(layout.pos.col=1, layout.pos.row=1))
  grid.rect()
  grid.text(paste(just, collapse="-"))
  popViewport(2)
}
testlay()
testlay(c("left", "top"))
testlay(c("right", "top"))
testlay(c("right", "bottom"))
testlay(c("left", "bottom"))
testlay(c("left"))
testlay(c("right"))
testlay(c("bottom"))
testlay(c("top"))
</code></pre>

<hr>
<h2 id='grid.lines'>Draw Lines in a Grid Viewport</h2><span id='topic+grid.lines'></span><span id='topic+linesGrob'></span><span id='topic+grid.polyline'></span><span id='topic+polylineGrob'></span>

<h3>Description</h3>

<p>These functions create and draw a series of lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.lines(x = unit(c(0, 1), "npc"),
          y = unit(c(0, 1), "npc"),
          default.units = "npc",
          arrow = NULL, name = NULL,
          gp=gpar(), draw = TRUE, vp = NULL)
linesGrob(x = unit(c(0, 1), "npc"),
          y = unit(c(0, 1), "npc"),
          default.units = "npc",
          arrow = NULL, name = NULL,
          gp=gpar(), vp = NULL)
grid.polyline(...)
polylineGrob(x = unit(c(0, 1), "npc"),
             y = unit(c(0, 1), "npc"),
             id=NULL, id.lengths=NULL,
             default.units = "npc",
             arrow = NULL, name = NULL,
             gp=gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.lines_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-values.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-values.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code> are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_arrow">arrow</code></td>
<td>
<p>A list describing arrow heads to place at either end
of the line, as produced by the <code>arrow</code> function.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.lines_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple lines.  All locations with the same
<code>id</code> belong to the same line.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_id.lengths">id.lengths</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple lines.  Specifies consecutive blocks of
locations which make up separate lines.</p>
</td></tr>
<tr><td><code id="grid.lines_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>polylineGrob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two functions create a lines grob (a graphical object describing
lines), and <code>grid.lines</code>
draws the lines (if <code>draw</code> is <code>TRUE</code>).
</p>
<p>The second two functions create or draw a polyline grob,
which is just like a lines grob, except that there can be
multiple distinct lines drawn.
</p>


<h3>Value</h3>

<p>A lines grob or a polyline grob.
<code>grid.lines</code> returns a lines grob invisibly.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+arrow">arrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.lines()
# Using id (NOTE: locations are not in consecutive blocks)
grid.newpage()
grid.polyline(x=c((0:4)/10, rep(.5, 5), (10:6)/10, rep(.5, 5)),
             y=c(rep(.5, 5), (10:6/10), rep(.5, 5), (0:4)/10),
             id=rep(1:5, 4),
             gp=gpar(col=1:5, lwd=3))
# Using id.lengths
grid.newpage()
grid.polyline(x=outer(c(0, .5, 1, .5), 5:1/5),
             y=outer(c(.5, 1, .5, 0), 5:1/5),
             id.lengths=rep(4, 5),
             gp=gpar(col=1:5, lwd=3))
</code></pre>

<hr>
<h2 id='grid.locator'> Capture a Mouse Click </h2><span id='topic+grid.locator'></span>

<h3>Description</h3>

<p>Allows the user to click the mouse once within the current
graphics
device and returns the location of the mouse click within the
current viewport, in the specified coordinate system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.locator(unit = "native")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.locator_+3A_unit">unit</code></td>
<td>
<p> The coordinate system in which to return the location
of the mouse click.
See the <code><a href="#topic+unit">unit</a></code> function for valid coordinate systems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is modal (like the graphics package
function <code>locator</code>) so
the command line and graphics drawing is blocked until
the use has clicked the mouse  in the current device.
</p>


<h3>Value</h3>

<p>A unit object representing the location of the mouse click within the
current viewport, in the specified coordinate system.
</p>
<p>If the user did not click mouse button 1, the function
(invisibly) returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+viewport">viewport</a></code>, <code><a href="#topic+unit">unit</a></code>,
<code><a href="graphics.html#topic+locator">locator</a></code> in package <span class="pkg">graphics</span>, and for an application
see <code><a href="lattice.html#topic+interaction">trellis.focus</a></code> and
<code><a href="lattice.html#topic+interaction">panel.identify</a></code> in package
<a href="https://CRAN.R-project.org/package=lattice"><span class="pkg">lattice</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (dev.interactive()) {
  ## Need to write a more sophisticated unit as.character method
  unittrim &lt;- function(unit) {
    sub("^([0-9]+|[0-9]+[.][0-9])[0-9]*", "\\1", as.character(unit))
  }
  do.click &lt;- function(unit) {
    click.locn &lt;- grid.locator(unit)
    grid.segments(unit.c(click.locn$x, unit(0, "npc")),
                  unit.c(unit(0, "npc"), click.locn$y),
                  click.locn$x, click.locn$y,
                  gp=gpar(lty="dashed", col="grey"))
    grid.points(click.locn$x, click.locn$y, pch=16, size=unit(1, "mm"))
    clickx &lt;- unittrim(click.locn$x)
    clicky &lt;- unittrim(click.locn$y)
    grid.text(paste0("(", clickx, ", ", clicky, ")"),
              click.locn$x + unit(2, "mm"), click.locn$y,
              just="left")
  }

  grid.newpage() # (empty slate)
  ## device
  do.click("inches")
  Sys.sleep(1)

  pushViewport(viewport(width=0.5, height=0.5,
                        xscale=c(0, 100), yscale=c(0, 10)))
  grid.rect()
  grid.xaxis()
  grid.yaxis()
  do.click("native")
  popViewport()
}
</code></pre>

<hr>
<h2 id='grid.ls'> List the names of grobs or viewports </h2><span id='topic+grid.ls'></span><span id='topic+nestedListing'></span><span id='topic+pathListing'></span><span id='topic+grobPathListing'></span>

<h3>Description</h3>

<p>Return a listing of the names of grobs or viewports.
</p>
<p>This is a generic function with methods for grobs (including
gTrees) and viewports (including vpTrees).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.ls(x=NULL, grobs=TRUE, viewports=FALSE, fullNames=FALSE,
        recursive=TRUE, print=TRUE, flatten=TRUE, ...)

nestedListing(x, gindent="  ", vpindent=gindent)
pathListing(x, gvpSep=" | ", gAlign=TRUE)
grobPathListing(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.ls_+3A_x">x</code></td>
<td>
<p>A grob or viewport or <code>NULL</code>.  If <code>NULL</code>, the current
grid display list is listed.
</p>
<p>For print functions, this should be the result of a call to
<code>grid.ls</code>.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_grobs">grobs</code></td>
<td>
<p>A logical value indicating whether to list grobs.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_viewports">viewports</code></td>
<td>
<p>A logical value indicating whether to list
viewports.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_fullnames">fullNames</code></td>
<td>
<p>A logical value indicating whether to embellish
object names with information about the object type.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_recursive">recursive</code></td>
<td>
<p>A logical value indicating whether recursive
structures should also list their children.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_print">print</code></td>
<td>
<p>A logical indicating whether to print the listing
or a function that will print the listing.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_flatten">flatten</code></td>
<td>
<p>A logical value indicating whether to flatten
the listing.  Otherwise a more complex hierarchical object is
produced.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_gindent">gindent</code></td>
<td>
<p>The indent used to show nesting in the output for
grobs.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_vpindent">vpindent</code></td>
<td>
<p>The indent used to show nesting in the output for
viewports.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_gvpsep">gvpSep</code></td>
<td>
<p>The string used to separate viewport paths from grob
paths.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_galign">gAlign</code></td>
<td>
<p>Logical indicating whether to align the left hand
edge of all grob paths.</p>
</td></tr>
<tr><td><code id="grid.ls_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>print</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument <code>x</code> is <code>NULL</code>, the current contents
of the grid display list are listed (both viewports and grobs).
In other words, all objects representing the current scene
are listed.
</p>
<p>Otherwise, <code>x</code> should be a grob or a viewport.
</p>
<p>The default behaviour of this function is to print information
about the grobs in the current scene.  It is also possible to
add information about the viewports in the scene.  By default,
the listing is recursive, so all children of gTrees and all
nested viewports are reported.
</p>
<p>The format of the information can be controlled via the <code>print</code>
argument, which can be given a function to perform the formatting.
The <code>nestedListing</code> function produces a line per grob or
viewport, with indenting used to show nesting.  The <code>pathListing</code>
function produces a line per grob or viewport, with viewport paths
and grob paths used to show nesting.  The <code>grobPathListing</code>
is a simple derivation that only shows lines for grobs.  The user
can define new functions.
</p>


<h3>Value</h3>

<p>The result of this function is either a <code>"gridFlatListing"</code>
object (if <code>flatten</code> is <code>TRUE</code>) or a <code>"gridListing"</code>
object.
</p>
<p>The former is a simple (flat) list of vectors.  This is convenient,
for example,
for working programmatically with the list of grob and viewport
names, or for writing a new display function for the listing.
</p>
<p>The latter is a more complex hierarchical object (list of lists),
but it does contain more detailed information so may be of use for
more advanced customisations.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A gTree, called "parent", with childrenvp vpTree (vp2 within vp1)
# and child grob, called "child", with vp vpPath (down to vp2)
sampleGTree &lt;- gTree(name="parent",
                     children=gList(grob(name="child", vp="vp1::vp2")),
                     childrenvp=vpTree(parent=viewport(name="vp1"),
                                       children=vpList(viewport(name="vp2"))))
grid.ls(sampleGTree)
# Show viewports too
grid.ls(sampleGTree, viewports=TRUE)
# Only show viewports
grid.ls(sampleGTree, viewports=TRUE, grobs=FALSE)
# Alternate displays
# nested listing, custom indent
grid.ls(sampleGTree, viewports=TRUE, print=nestedListing, gindent="--")
# path listing
grid.ls(sampleGTree, viewports=TRUE, print=pathListing)
# path listing, without grobs aligned
grid.ls(sampleGTree, viewports=TRUE, print=pathListing, gAlign=FALSE)
# grob path listing
grid.ls(sampleGTree, viewports=TRUE, print=grobPathListing)
# path listing, grobs only
grid.ls(sampleGTree, print=pathListing)
# path listing, viewports only
grid.ls(sampleGTree, viewports=TRUE, grobs=FALSE, print=pathListing)
# raw flat listing
str(grid.ls(sampleGTree, viewports=TRUE, print=FALSE))
</code></pre>

<hr>
<h2 id='grid.move.to'> Move or Draw to a Specified Position </h2><span id='topic+grid.move.to'></span><span id='topic+grid.line.to'></span><span id='topic+moveToGrob'></span><span id='topic+lineToGrob'></span>

<h3>Description</h3>

<p>Grid has the notion of a current location.  These functions
sets that location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.move.to(x = 0, y = 0, default.units = "npc", name = NULL,
             draw = TRUE, vp = NULL)

moveToGrob(x = 0, y = 0, default.units = "npc", name = NULL,
           vp = NULL)

grid.line.to(x = 1, y = 1, default.units = "npc",
             arrow = NULL, name = NULL,
             gp = gpar(), draw = TRUE, vp = NULL)

lineToGrob(x = 1, y = 1, default.units = "npc", arrow = NULL,
           name = NULL, gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.move.to_+3A_x">x</code></td>
<td>
<p>A numeric value or a unit object specifying an x-value.</p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_y">y</code></td>
<td>
<p>A numeric value or a unit object specifying a y-value.</p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code> are only given as numeric values.</p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_arrow">arrow</code></td>
<td>
<p>A list describing arrow heads to place at either end
of the line, as produced by the <code>arrow</code> function.</p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.move.to_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a move.to/line.to grob (a graphical object describing a
move-to/line-to), but only <code>grid.move.to/line.to()</code>
draws the move.to/line.to (and then only if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A move.to/line.to grob.
<code>grid.move.to/line.to()</code> returns the value invisibly.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+arrow">arrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
grid.move.to(0.5, 0.5)
grid.line.to(1, 1)
grid.line.to(0.5, 0)
pushViewport(viewport(x=0, y=0, width=0.25, height=0.25, just=c("left", "bottom")))
grid.rect()
grid.grill()
grid.line.to(0.5, 0.5)
popViewport()
</code></pre>

<hr>
<h2 id='grid.newpage'>Move to a New Page on a Grid Device</h2><span id='topic+grid.newpage'></span>

<h3>Description</h3>

<p>This function erases the current device or moves to a new page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.newpage(recording = TRUE, clearGroups = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.newpage_+3A_recording">recording</code></td>
<td>
<p>A logical value to indicate whether the new-page
operation should be saved onto the Grid display list.</p>
</td></tr>
<tr><td><code id="grid.newpage_+3A_cleargroups">clearGroups</code></td>
<td>
<p>A logical value indicating whether any groups
that have been defined on the current page should be
released (see <code><a href="#topic+grid.group">grid.group</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new page is painted with the fill colour
(<code><a href="#topic+gpar">gpar</a>("fill")</code>), which is often transparent.  For devices
with a <em>canvas</em> colour (the on-screen devices <code>X11</code>,
<code>windows</code> and <code>quartz</code>), the page is first painted with the
canvas colour and then the background colour.
</p>
<p>There are two hooks called <code>"before.grid.newpage"</code> and
<code>"grid.newpage"</code> (see <code><a href="base.html#topic+setHook">setHook</a></code>).  The latter
is used in the testing code to annotate the new page.  The hook
function(s) are called with no argument.  (If the value is a character
string, <code>get</code> is called on it from within the <span class="pkg">grid</span>
namespace.)
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>
</p>

<hr>
<h2 id='grid.null'> Null Graphical Object </h2><span id='topic+grid.null'></span><span id='topic+nullGrob'></span>

<h3>Description</h3>

<p>These functions create a NULL graphical object,
which has zero width, zero height, and draw nothing.
It can be used as a place-holder or as an invisible
reference point for other drawing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullGrob(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         default.units = "npc",
         name = NULL, vp = NULL)
grid.null(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.null_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-location.</p>
</td></tr>
<tr><td><code id="grid.null_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-location.</p>
</td></tr>
<tr><td><code id="grid.null_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.null_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.null_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.null_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>nullGrob()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A null grob.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
grid.null(name="ref")
grid.rect(height=grobHeight("ref"))
grid.segments(0, 0, grobX("ref", 0), grobY("ref", 0))
</code></pre>

<hr>
<h2 id='grid.pack'> Pack an Object within a Frame </h2><span id='topic+grid.pack'></span><span id='topic+packGrob'></span>

<h3>Description</h3>

<p>these functions, together with <code>grid.frame</code> and <code>frameGrob</code>
are part of a
GUI-builder-like interface to constructing graphical images.
The idea is that you create a frame with <code>grid.frame</code> or
<code>frameGrob</code> then
use these functions to pack objects into the frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pack(gPath, grob, redraw = TRUE, side = NULL,
          row = NULL, row.before = NULL, row.after = NULL,
          col = NULL, col.before = NULL, col.after = NULL,
          width = NULL, height = NULL,
          force.width = FALSE, force.height = FALSE, border = NULL,
          dynamic = FALSE)

packGrob(frame, grob, side = NULL,
          row = NULL, row.before = NULL, row.after = NULL,
          col = NULL, col.before = NULL, col.after = NULL,
          width = NULL, height = NULL,
          force.width = FALSE, force.height = FALSE, border = NULL,
          dynamic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pack_+3A_gpath">gPath</code></td>
<td>
<p> A gPath object, which specifies a frame on the
display list.</p>
</td></tr>
<tr><td><code id="grid.pack_+3A_frame">frame</code></td>
<td>
<p> An object of class <code>frame</code>, typically the output
from a call to <code>grid.frame</code>. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_grob">grob</code></td>
<td>
<p> An object of class <code>grob</code>.  The object to be
packed. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_redraw">redraw</code></td>
<td>
<p> A boolean indicating whether the output should be updated. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_side">side</code></td>
<td>
<p> One of <code>"left"</code>, <code>"top"</code>, <code>"right"</code>,
<code>"bottom"</code> to indicate which side to pack the object on. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_row">row</code></td>
<td>
<p> Which row to add the object to.  Must be between 1 and
the-number-of-rows-currently-in-the-frame + 1, or <code>NULL</code> in
which case the object occupies all rows. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_row.before">row.before</code></td>
<td>
<p> Add the object to a new row just before this row. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_row.after">row.after</code></td>
<td>
<p> Add the object to a new row just after this row. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_col">col</code></td>
<td>
<p> Which col to add the object to.  Must be between 1 and
the-number-of-cols-currently-in-the-frame + 1, or <code>NULL</code> in
which case the object occupies all cols.  </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_col.before">col.before</code></td>
<td>
<p>Add the object to a new col just before this col.</p>
</td></tr>
<tr><td><code id="grid.pack_+3A_col.after">col.after</code></td>
<td>
<p> Add the object to a new col just after this col. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_width">width</code></td>
<td>
<p> Specifies the width of the column that the object is
added to (rather than allowing the width to be taken from the object). </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_height">height</code></td>
<td>
<p> Specifies the height of the row that the object is
added to (rather than allowing the height to be taken from the
object). </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_force.width">force.width</code></td>
<td>
<p> A logical value indicating whether the width of
the column that the grob is being packed into should be EITHER the
width specified in the call to <code>grid.pack</code> OR the maximum of
that width and the pre-existing width. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_force.height">force.height</code></td>
<td>
<p> A logical value indicating whether the height of
the column that the grob is being packed into should be EITHER the
height specified in the call to <code>grid.pack</code> OR the maximum of
that height and the pre-existing height. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_border">border</code></td>
<td>
<p> A <code>unit</code> object of length 4 indicating the borders
around the object. </p>
</td></tr>
<tr><td><code id="grid.pack_+3A_dynamic">dynamic</code></td>
<td>
<p> If the width/height is taken from the grob being
packed, this boolean flag indicates whether the
<code>"grobwidth"</code>/<code>"grobheight"</code> 
unit refers directly to the grob, or uses a gPath to the grob.
In the latter case, changes to the grob will trigger a
recalculation of the width/height.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>packGrob</code> modifies the given frame grob and returns the modified
frame grob.
</p>
<p><code>grid.pack</code> destructively modifies a frame grob on the display
list (and redraws the display list if <code>redraw</code> is <code>TRUE</code>).
</p>
<p>These are (meant to be) very flexible functions.  There are many
different
ways to specify where the new object is to be added relative to the
objects already in the frame.  The function checks that the
specification is not self-contradictory.
</p>
<p>NOTE that the width/height of the row/col that the object is added to
is taken from the object itself unless the <code>width</code>/<code>height</code>
is specified.
</p>


<h3>Value</h3>

<p><code>packGrob</code> returns a frame grob, but <code>grid.pack</code> returns
<code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.frame">grid.frame</a></code>,
<code><a href="#topic+grid.place">grid.place</a></code>,
<code><a href="#topic+grid.edit">grid.edit</a></code>, and <code><a href="#topic+gPath">gPath</a></code>.
</p>

<hr>
<h2 id='grid.path'> Draw a Path </h2><span id='topic+grid.path'></span><span id='topic+pathGrob'></span>

<h3>Description</h3>

<p>These functions create and draw one or more paths.
The final point of a path will automatically
be connected to the initial point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathGrob(x, y,
         id=NULL, id.lengths=NULL,
         pathId=NULL, pathId.lengths=NULL,
         rule="winding",
         default.units="npc",
         name=NULL, gp=gpar(), vp=NULL)
grid.path(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.path_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into sub-paths.  All locations with the same
<code>id</code> belong to the same sub-path.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_id.lengths">id.lengths</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into sub-paths.  Specifies consecutive blocks of
locations which make up separate sub-paths.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_pathid">pathId</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into distinct paths.  All locations with the same
<code>pathId</code> belong to the same path.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_pathid.lengths">pathId.lengths</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> 
and <code>y</code> into paths.  Specifies consecutive blocks of locations which 
make up separate paths.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_rule">rule</code></td>
<td>
<p>A character value specifying the fill rule: either
<code>"winding"</code> or <code>"evenodd"</code>.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.path_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.path_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.path_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>pathGrob()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a path grob (a graphical object describing a
path), but only <code>grid.path</code> draws the path (and then only if
<code>draw</code> is <code>TRUE</code>).
</p>
<p>A path is like a polygon except that the former can contain holes, as
interpreted by the fill rule; these fill a region if the path border
encircles it an odd or non-zero number of times, respectively.
</p>
<p>Not all graphics devices support this function: for example
<code>xfig</code> and <code>pictex</code> do not.
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pathSample &lt;- function(x, y, rule, gp = gpar()) {
    if (is.na(rule))
        grid.path(x, y, id = rep(1:2, each = 4), gp = gp)
    else
        grid.path(x, y, id = rep(1:2, each = 4), rule = rule, gp = gp)
    if (!is.na(rule))
        grid.text(paste("Rule:", rule), y = 0, just = "bottom")
}

pathTriplet &lt;- function(x, y, title) {
    pushViewport(viewport(height = 0.9, layout = grid.layout(1, 3),
                          gp = gpar(cex = .7)))
    grid.rect(y = 1, height = unit(1, "char"), just = "top",
              gp = gpar(col = NA, fill = "grey"))
    grid.text(title, y = 1, just = "top")
    pushViewport(viewport(layout.pos.col = 1))
    pathSample(x, y, rule = "winding",
               gp = gpar(fill = "grey"))
    popViewport()
    pushViewport(viewport(layout.pos.col = 2))
    pathSample(x, y, rule = "evenodd",
               gp = gpar(fill = "grey"))
    popViewport()
    pushViewport(viewport(layout.pos.col = 3))
    pathSample(x, y, rule = NA)
    popViewport()
    popViewport()
}

pathTest &lt;- function() {
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(5, 1)))
    pushViewport(viewport(layout.pos.row = 1))
    pathTriplet(c(.1, .1, .9, .9, .2, .2, .8, .8),
                c(.1, .9, .9, .1, .2, .8, .8, .2),
                "Nested rectangles, both clockwise")
    popViewport()
    pushViewport(viewport(layout.pos.row = 2))
    pathTriplet(c(.1, .1, .9, .9, .2, .8, .8, .2),
                c(.1, .9, .9, .1, .2, .2, .8, .8),
                "Nested rectangles, outer clockwise, inner anti-clockwise")
    popViewport()
    pushViewport(viewport(layout.pos.row = 3))
    pathTriplet(c(.1, .1, .4, .4, .6, .9, .9, .6),
                c(.1, .4, .4, .1, .6, .6, .9, .9),
                "Disjoint rectangles")
    popViewport()
    pushViewport(viewport(layout.pos.row = 4))
    pathTriplet(c(.1, .1, .6, .6, .4, .4, .9, .9),
                c(.1, .6, .6, .1, .4, .9, .9, .4),
                "Overlapping rectangles, both clockwise")
    popViewport()
    pushViewport(viewport(layout.pos.row = 5))
    pathTriplet(c(.1, .1, .6, .6, .4, .9, .9, .4),
                c(.1, .6, .6, .1, .4, .4, .9, .9),
                "Overlapping rectangles, one clockwise, other anti-clockwise")
    popViewport()
    popViewport()
}

pathTest()

# Drawing multiple paths at once
holed_rect &lt;- cbind(c(.15, .15, -.15, -.15, .1, .1, -.1, -.1), 
                    c(.15, -.15, -.15, .15, .1, -.1, -.1, .1))
holed_rects &lt;- rbind(
    holed_rect + matrix(c(.7, .2), nrow = 8, ncol = 2, byrow = TRUE),
    holed_rect + matrix(c(.7, .8), nrow = 8, ncol = 2, byrow = TRUE),
    holed_rect + matrix(c(.2, .5), nrow = 8, ncol = 2, byrow = TRUE)
)
grid.newpage()
grid.path(x = holed_rects[, 1], y = holed_rects[, 2], 
          id = rep(1:6, each = 4), pathId = rep(1:3, each = 8),
          gp = gpar(fill = c('red', 'blue', 'green')),
          rule = 'evenodd')

# Not specifying pathId will treat all points as part of the same path, thus 
# having same fill
grid.newpage()
grid.path(x = holed_rects[, 1], y = holed_rects[, 2], 
          id = rep(1:6, each = 4),
          gp = gpar(fill = c('red', 'blue', 'green')),
          rule = 'evenodd')
</code></pre>

<hr>
<h2 id='grid.place'> Place an Object within a Frame </h2><span id='topic+grid.place'></span><span id='topic+placeGrob'></span>

<h3>Description</h3>

<p>These functions provide a simpler (and faster) alternative
to the <code>grid.pack()</code> and <code>packGrob</code>
functions.  They can be used to place objects within the existing
rows and columns of a frame layout.  They do not provide the ability to
add new rows and columns nor do they affect the
heights and widths of the rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.place(gPath, grob, row = 1, col = 1, redraw = TRUE)
placeGrob(frame, grob, row = NULL, col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.place_+3A_gpath">gPath</code></td>
<td>
<p> A gPath object, which specifies a frame on the
display list.</p>
</td></tr>
<tr><td><code id="grid.place_+3A_frame">frame</code></td>
<td>
<p> An object of class <code>frame</code>, typically the output
from a call to <code>grid.frame</code>. </p>
</td></tr>
<tr><td><code id="grid.place_+3A_grob">grob</code></td>
<td>
<p> An object of class <code>grob</code>.  The object to be
placed. </p>
</td></tr>
<tr><td><code id="grid.place_+3A_row">row</code></td>
<td>
<p> Which row to add the object to.  Must be between 1 and
the-number-of-rows-currently-in-the-frame. </p>
</td></tr>
<tr><td><code id="grid.place_+3A_col">col</code></td>
<td>
<p> Which col to add the object to.  Must be between 1 and
the-number-of-cols-currently-in-the-frame.  </p>
</td></tr>
<tr><td><code id="grid.place_+3A_redraw">redraw</code></td>
<td>
<p> A boolean indicating whether the output should be updated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>placeGrob</code> modifies the given frame grob and returns the modified
frame grob.
</p>
<p><code>grid.place</code> destructively modifies a frame grob on the display
list (and redraws the display list if <code>redraw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p><code>placeGrob</code> returns a frame grob, but <code>grid.place</code> returns
<code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.frame">grid.frame</a></code>,
<code><a href="#topic+grid.pack">grid.pack</a></code>,
<code><a href="#topic+grid.edit">grid.edit</a></code>, and <code><a href="#topic+gPath">gPath</a></code>.
</p>

<hr>
<h2 id='grid.plot.and.legend'> A Simple Plot and Legend Demo </h2><span id='topic+grid.plot.and.legend'></span>

<h3>Description</h3>

<p>This function is just a wrapper for a simple demonstration of how
a basic plot and legend can be drawn from scratch using grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.plot.and.legend()
</code></pre>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.plot.and.legend()
</code></pre>

<hr>
<h2 id='grid.points'>Draw Data Symbols</h2><span id='topic+grid.points'></span><span id='topic+pointsGrob'></span>

<h3>Description</h3>

<p>These functions create and draw data symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.points(x = stats::runif(10),
            y = stats::runif(10),
            pch = 1, size = unit(1, "char"),
            default.units = "native", name = NULL,
            gp = gpar(), draw = TRUE, vp = NULL)
pointsGrob(x = stats::runif(10),
           y = stats::runif(10),
           pch = 1, size = unit(1, "char"),
           default.units = "native", name = NULL,
           gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.points_+3A_x">x</code></td>
<td>
<p>numeric vector or unit object specifying x-values.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_y">y</code></td>
<td>
<p>numeric vector or unit object specifying y-values.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_pch">pch</code></td>
<td>
<p>numeric or character vector indicating what sort of
plotting symbol to use.  See <code><a href="graphics.html#topic+points">points</a></code> for the
interpretation of these values, and note <code>fill</code> below.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_size">size</code></td>
<td>
<p>unit object specifying the size of the plotting symbols.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_default.units">default.units</code></td>
<td>
<p>string indicating the default units to use
if <code>x</code> or <code>y</code> are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_name">name</code></td>
<td>
<p>character identifier. </p>
</td></tr>
<tr><td><code id="grid.points_+3A_gp">gp</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings; note that <code>fill</code> (and
not <code>bg</code> as in package <span class="pkg">graphics</span> <code><a href="graphics.html#topic+points">points</a></code>) is
used to &ldquo;fill&rdquo;, i.e., color the background of symbols with
<code>pch = 21:25</code>.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_draw">draw</code></td>
<td>
<p>logical indicating whether graphics output should be produced.</p>
</td></tr>
<tr><td><code id="grid.points_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a points grob (a graphical object describing
points), but only <code>grid.points</code> draws the points (and then only
if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A points <code><a href="#topic+grob">grob</a></code>.  <code>grid.points</code> returns the value invisibly.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>

<hr>
<h2 id='grid.polygon'> Draw a Polygon </h2><span id='topic+grid.polygon'></span><span id='topic+polygonGrob'></span>

<h3>Description</h3>

<p>These functions create and draw a polygon.
The final point will automatically
be connected to the initial point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.polygon(x=c(0, 0.5, 1, 0.5), y=c(0.5, 1, 0.5, 0),
             id=NULL, id.lengths=NULL,
             default.units="npc", name=NULL,
             gp=gpar(), draw=TRUE, vp=NULL)
polygonGrob(x=c(0, 0.5, 1, 0.5), y=c(0.5, 1, 0.5, 0),
             id=NULL, id.lengths=NULL,
             default.units="npc", name=NULL,
             gp=gpar(), vp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.polygon_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple polygons.  All locations with the same
<code>id</code> belong to the same polygon.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_id.lengths">id.lengths</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple polygons.  Specifies consecutive blocks of
locations which make up separate polygons.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.polygon_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a polygon grob (a graphical object describing a
polygon), but only <code>grid.polygon</code>
draws the polygon (and then only if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.polygon()
# Using id (NOTE: locations are not in consecutive blocks)
grid.newpage()
grid.polygon(x=c((0:4)/10, rep(.5, 5), (10:6)/10, rep(.5, 5)),
             y=c(rep(.5, 5), (10:6/10), rep(.5, 5), (0:4)/10),
             id=rep(1:5, 4),
             gp=gpar(fill=1:5))
# Using id.lengths
grid.newpage()
grid.polygon(x=outer(c(0, .5, 1, .5), 5:1/5),
             y=outer(c(.5, 1, .5, 0), 5:1/5),
             id.lengths=rep(4, 5),
             gp=gpar(fill=1:5))
</code></pre>

<hr>
<h2 id='grid.pretty'> Generate a Sensible (&quot;Pretty&quot;) Set of Breakpoints </h2><span id='topic+grid.pretty'></span>

<h3>Description</h3>

<p>Produces a pretty set of approximately <code>n</code> breakpoints within the
range given.
</p>
<p>This is a direct interface to <span class="rlang"><b>R</b></span>'s graphical engine <code>GEpretty()</code>
function, which also underlies base <span class="pkg">graphics</span>' package
<code><a href="graphics.html#topic+axis">axis</a>()</code>, <code><a href="graphics.html#topic+axTicks">axTicks</a>()</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pretty(range, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pretty_+3A_range">range</code></td>
<td>
<p>a numeric vector of length at least two, as e.g., returned
by <code><a href="base.html#topic+range">range</a>()</code>.</p>
</td></tr>
<tr><td><code id="grid.pretty_+3A_n">n</code></td>
<td>
<p>a non-negative integer specifying the <em>approximate</em> number
of breakpoints to be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of &ldquo;pretty&rdquo; breakpoints.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>

<hr>
<h2 id='grid.raster'>
Render a raster object
</h2><span id='topic+grid.raster'></span><span id='topic+rasterGrob'></span>

<h3>Description</h3>

<p>Render a raster object (bitmap image) at the given location, size,
and orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.raster(image,
            x = unit(0.5, "npc"), y = unit(0.5, "npc"),
            width = NULL, height = NULL,
            just = "centre", hjust = NULL, vjust = NULL,
            interpolate = TRUE, default.units = "npc",
            name = NULL, gp = gpar(), vp = NULL)

rasterGrob(image,
           x = unit(0.5, "npc"), y = unit(0.5, "npc"),
           width = NULL, height = NULL,
           just = "centre", hjust = NULL, vjust = NULL,
           interpolate = TRUE, default.units = "npc",
           name = NULL, gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.raster_+3A_image">image</code></td>
<td>

<p>Any R object that can be coerced to a raster object.
</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-location.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-location.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_width">width</code></td>
<td>
<p>A numeric vector or unit object specifying width.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_height">height</code></td>
<td>
<p>A numeric vector or unit object specifying height.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_just">just</code></td>
<td>
<p>The justification of the rectangle
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left alignment
and 1 means right alignment.
</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_hjust">hjust</code></td>
<td>
<p>A numeric vector specifying horizontal justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_vjust">vjust</code></td>
<td>
<p>A numeric vector specifying vertical justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.raster_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.raster_+3A_interpolate">interpolate</code></td>
<td>

<p>A logical value indicating whether to linearly interpolate the
image (the alternative is to use nearest-neighbour interpolation,
which gives a more blocky result).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neither <code>width</code> nor <code>height</code> needs to be specified,
in which case, the aspect ratio of the image is preserved.  If
both <code>width</code> and <code>height</code> are specified, it is likely
that the image will be distorted.
</p>
<p>Not all graphics devices are capable of rendering raster images
and some may not be able to produce rotated images (i.e., if
a raster object is rendered within a rotated viewport).  See also the
comments under <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>.
</p>
<p>All graphical parameter settings in <code>gp</code> will be ignored,
including <code>alpha</code>.
</p>


<h3>Value</h3>

<p>A rastergrob grob.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+as.raster">as.raster</a></code>.
</p>
<p><code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code> to see if it is supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redGradient &lt;- matrix(hcl(0, 80, seq(50, 80, 10)),
                      nrow=4, ncol=5)
# interpolated
grid.newpage()
grid.raster(redGradient)
# blocky
grid.newpage()
grid.raster(redGradient, interpolate=FALSE)
# blocky and stretched
grid.newpage()
grid.raster(redGradient, interpolate=FALSE, height=unit(1, "npc"))

# The same raster drawn several times
grid.newpage()
grid.raster(0, x=1:3/4, y=1:3/4, width=.1, interpolate=FALSE)
</code></pre>

<hr>
<h2 id='grid.record'> Encapsulate calculations and drawing </h2><span id='topic+grid.record'></span><span id='topic+recordGrob'></span>

<h3>Description</h3>

<p>Evaluates an expression that includes both calculations
and drawing that depends on the calculations so that
both the calculations and the drawing will be rerun when
the scene is redrawn (e.g., device resize or editing).
</p>
<p>Intended <em>only</em> for expert use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recordGrob(expr, list, name=NULL, gp=NULL, vp=NULL)
grid.record(expr, list, name=NULL, gp=NULL, vp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.record_+3A_expr">expr</code></td>
<td>
<p>object of mode <code><a href="base.html#topic+expression">expression</a></code> or <code>call</code> or
an unevaluated expression.</p>
</td></tr>
<tr><td><code id="grid.record_+3A_list">list</code></td>
<td>
<p>a list defining the environment in which <code>expr</code> is to
be evaluated.</p>
</td></tr>
<tr><td><code id="grid.record_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.record_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.record_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grob is created of special class <code>"recordedGrob"</code>
(and drawn, in the case of <code>grid.record</code>).
The <code>drawDetails</code> method for this class
evaluates the expression with the list as the evaluation
environment (and the grid Namespace as the parent of that
environment).
</p>


<h3>Note</h3>

<p> This function <em>must</em> be used instead of the
function <code>recordGraphics</code>;  all of the dire warnings
about using <code>recordGraphics</code> responsibly also apply here.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="grDevices.html#topic+recordGraphics">recordGraphics</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.record({
              w &lt;- convertWidth(unit(1, "inches"), "npc")
              grid.rect(width=w)
            },
            list())
</code></pre>

<hr>
<h2 id='grid.rect'>Draw rectangles </h2><span id='topic+grid.rect'></span><span id='topic+rectGrob'></span>

<h3>Description</h3>

<p>These functions create and draw rectangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.rect(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
          width = unit(1, "npc"), height = unit(1, "npc"),
          just = "centre", hjust = NULL, vjust = NULL,
          default.units = "npc", name = NULL,
          gp=gpar(), draw = TRUE, vp = NULL)
rectGrob(x = unit(0.5, "npc"), y = unit(0.5, "npc"),
         width = unit(1, "npc"), height = unit(1, "npc"),
         just = "centre", hjust = NULL, vjust = NULL,
         default.units = "npc", name = NULL,
         gp=gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.rect_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-location.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-location.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_width">width</code></td>
<td>
<p>A numeric vector or unit object specifying width.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_height">height</code></td>
<td>
<p>A numeric vector or unit object specifying height.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_just">just</code></td>
<td>
<p>The justification of the rectangle
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left alignment
and 1 means right alignment.
</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_hjust">hjust</code></td>
<td>
<p>A numeric vector specifying horizontal justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_vjust">vjust</code></td>
<td>
<p>A numeric vector specifying vertical justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.rect_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.rect_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a rect grob (a graphical object describing
rectangles), but only <code>grid.rect</code>
draws the rectangles (and then only if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A rect grob.  <code>grid.rect</code> returns the value invisibly.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>

<hr>
<h2 id='grid.refresh'> Refresh the current grid scene </h2><span id='topic+grid.refresh'></span>

<h3>Description</h3>

<p>Replays the current grid display list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.refresh()
</code></pre>


<h3>Author(s)</h3>

<p> Paul Murrell </p>

<hr>
<h2 id='grid.remove'>Remove a Grid Graphical Object</h2><span id='topic+grid.remove'></span><span id='topic+grid.gremove'></span><span id='topic+removeGrob'></span>

<h3>Description</h3>

<p>Remove a grob from a gTree or a descendant of a gTree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.remove(gPath, warn = TRUE, strict = FALSE, grep = FALSE,
            global = FALSE, allDevices = FALSE, redraw = TRUE)

grid.gremove(..., grep = TRUE, global = TRUE)

removeGrob(gTree, gPath, strict = FALSE, grep = FALSE,
           global = FALSE, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.remove_+3A_gtree">gTree</code></td>
<td>
<p>A gTree object.</p>
</td></tr>
<tr><td><code id="grid.remove_+3A_gpath">gPath</code></td>
<td>
<p>a gPath object. For <code>grid.remove</code> this
specifies a gTree on the display list.  For <code>removeGrob</code> this
specifies a descendant of the specified <code>gTree</code>.</p>
</td></tr>
<tr><td><code id="grid.remove_+3A_strict">strict</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether the <code>gPath</code> must be
matched exactly.</p>
</td></tr>
<tr><td><code id="grid.remove_+3A_grep">grep</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether the <code>gPath</code> should
be treated as a regular expression.  Values are recycled across
elements of the <code>gPath</code> (e.g., <code>c(TRUE, FALSE)</code> means
that every odd element of the <code>gPath</code> will be treated as
a regular expression).
</p>
</td></tr>
<tr><td><code id="grid.remove_+3A_global">global</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether the function should affect
just the first match of the <code>gPath</code>, or whether all matches
should be affected.
</p>
</td></tr>
<tr><td><code id="grid.remove_+3A_alldevices">allDevices</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> indicating whether all open
devices should be searched for matches, or just the current device.
NOT YET IMPLEMENTED.
</p>
</td></tr>
<tr><td><code id="grid.remove_+3A_warn">warn</code></td>
<td>
<p>A logical to indicate whether failing to find the
specified grob should trigger an error.  </p>
</td></tr>
<tr><td><code id="grid.remove_+3A_redraw">redraw</code></td>
<td>
<p>A logical value to indicate whether to redraw the grob. </p>
</td></tr>
<tr><td><code id="grid.remove_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+grid.get">grid.get</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>removeGrob</code> copies the specified grob and returns a modified
grob.
</p>
<p><code>grid.remove</code> destructively modifies a grob on the display list.
If <code>redraw</code>
is <code>TRUE</code> it then redraws everything to reflect the change.
</p>
<p><code>grid.gremove</code> (<code>g</code> for global) is just a convenience wrapper for
<code>grid.remove</code> with different defaults.
</p>


<h3>Value</h3>

<p><code>removeGrob</code> returns a grob object;  <code>grid.remove</code> returns
<code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code>, <code><a href="#topic+getGrob">getGrob</a></code>.
</p>

<hr>
<h2 id='grid.reorder'> Reorder the children of a gTree </h2><span id='topic+grid.reorder'></span><span id='topic+reorderGrob'></span>

<h3>Description</h3>

<p>Change the order in which the children of a gTree get drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.reorder(gPath, order, back=TRUE, grep=FALSE, redraw=TRUE)
reorderGrob(x, order, back=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.reorder_+3A_gpath">gPath</code></td>
<td>
<p>A gPath object specifying a gTree within the current
scene.</p>
</td></tr>
<tr><td><code id="grid.reorder_+3A_x">x</code></td>
<td>
<p>A gTree object to be modified.</p>
</td></tr>
<tr><td><code id="grid.reorder_+3A_order">order</code></td>
<td>
<p>A character vector or a numeric vector that specifies
the new drawing order for the children of the gTree.  May not refer
to all children of the gTree (see Details).</p>
</td></tr>
<tr><td><code id="grid.reorder_+3A_back">back</code></td>
<td>
<p>Controls what happens when the <code>order</code> does not
specify all children of the gTree (see Details).</p>
</td></tr>
<tr><td><code id="grid.reorder_+3A_grep">grep</code></td>
<td>
<p>Should the <code>gPath</code> be treated as a regular expression?</p>
</td></tr>
<tr><td><code id="grid.reorder_+3A_redraw">redraw</code></td>
<td>
<p>Should the modified scene be redrawn?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the simplest case, <code>order</code> specifies a new ordering for all of
the children of the gTree.  The children may be specified either by
name or by existing numerical order.
</p>
<p>If the <code>order</code> does not
specify all children of the gTree then, by default, the children
specified by <code>order</code> are drawn first and then all remaining
children are drawn.  If <code>back=FALSE</code> then the children not
specified in <code>order</code> are drawn first, followed by the specified
children.  This makes it easy to specify a send-to-back or
bring-to-front reordering.  The <code>order</code> argument is <em>always</em>
in back-to-front order.
</p>
<p>It is not possible to reorder the grid display list (the top-level
grobs in the current scene) because the display list is a mixture of
grobs and viewports (so it is not clear what reordering even means and
it would be too easy to end up with a scene that would not draw).
If you want to reorder the grid display list, try <code>grid.grab()</code>
to create a gTree and then reorder (and redraw) that gTree.
</p>


<h3>Value</h3>

<p><code>grid.reorder()</code> is called for its side-effect of modifying the
current scene.
<code>reorderGrob()</code> returns the modified gTree.
</p>


<h3>Warning</h3>

<p>This function may return a gTree that will not draw.  For example, a
gTree has two children, A and B (in that order),
and the width of child B depends on the width of child A (e.g., a box
around a piece of text).  Switching the order so that B is drawn
before A will not allow B to be drawn.  If this happens with
<code>grid.reorder()</code>, the modification will not be performed.  If
this happens with <code>reorderGrob()</code> it should be possible simply to
restore the original order.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>Examples</h3>

<pre><code class='language-R'># gTree with two children, "red-rect" and "blue-rect" (in that order)
gt &lt;- gTree(children=gList(
                rectGrob(gp=gpar(col=NA, fill="red"),
                         width=.8, height=.2, name="red-rect"),
                rectGrob(gp=gpar(col=NA, fill="blue"),
                         width=.2, height=.8, name="blue-rect")),
            name="gt")
grid.newpage()
grid.draw(gt)
# Spec entire order as numeric (blue-rect, red-rect)
grid.reorder("gt", 2:1)
# Spec entire order as character
grid.reorder("gt", c("red-rect", "blue-rect"))
# Only spec the one I want behind as character
grid.reorder("gt", "blue-rect")
# Only spec the one I want in front as character
grid.reorder("gt", "blue-rect", back=FALSE)
</code></pre>

<hr>
<h2 id='grid.segments'> Draw Line Segments </h2><span id='topic+grid.segments'></span><span id='topic+segmentsGrob'></span>

<h3>Description</h3>

<p>These functions create and draw line segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.segments(x0 = unit(0, "npc"), y0 = unit(0, "npc"),
              x1 = unit(1, "npc"), y1 = unit(1, "npc"),
              default.units = "npc",
              arrow = NULL,
              name = NULL, gp = gpar(), draw = TRUE, vp = NULL)
segmentsGrob(x0 = unit(0, "npc"), y0 = unit(0, "npc"),
              x1 = unit(1, "npc"), y1 = unit(1, "npc"),
              default.units = "npc",
              arrow = NULL, name = NULL, gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.segments_+3A_x0">x0</code></td>
<td>
<p> Numeric indicating the starting x-values of the line segments. </p>
</td></tr>
<tr><td><code id="grid.segments_+3A_y0">y0</code></td>
<td>
<p> Numeric indicating the starting y-values of the line
segments. </p>
</td></tr>
<tr><td><code id="grid.segments_+3A_x1">x1</code></td>
<td>
<p> Numeric indicating the stopping x-values of the line
segments. </p>
</td></tr>
<tr><td><code id="grid.segments_+3A_y1">y1</code></td>
<td>
<p> Numeric indicating the stopping y-values of the line segments.</p>
</td></tr>
<tr><td><code id="grid.segments_+3A_default.units">default.units</code></td>
<td>
<p> A string. </p>
</td></tr>
<tr><td><code id="grid.segments_+3A_arrow">arrow</code></td>
<td>
<p>A list describing arrow heads to place at either end
of the line segments, as produced by the <code>arrow</code> function.</p>
</td></tr>
<tr><td><code id="grid.segments_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.segments_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.segments_+3A_draw">draw</code></td>
<td>
<p> A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.segments_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a segments grob (a graphical object describing
segments), but only <code>grid.segments</code>
draws the segments (and then only if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A segments grob.  <code>grid.segments</code> returns the value invisibly.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+arrow">arrow</a></code>
</p>

<hr>
<h2 id='grid.set'>Set a Grid Graphical Object</h2><span id='topic+grid.set'></span><span id='topic+setGrob'></span>

<h3>Description</h3>

<p>Replace a grob or a descendant of a grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.set(gPath, newGrob, strict = FALSE, grep = FALSE,
         redraw = TRUE)

setGrob(gTree, gPath, newGrob, strict = FALSE, grep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.set_+3A_gtree">gTree</code></td>
<td>
<p>A gTree object.</p>
</td></tr>
<tr><td><code id="grid.set_+3A_gpath">gPath</code></td>
<td>
<p> A gPath object. For <code>grid.set</code> this
specifies a grob on the display list.  For <code>setGrob</code> this
specifies a descendant of the specified gTree. </p>
</td></tr>
<tr><td><code id="grid.set_+3A_newgrob">newGrob</code></td>
<td>
<p> A grob object. </p>
</td></tr>
<tr><td><code id="grid.set_+3A_strict">strict</code></td>
<td>
<p> A boolean indicating whether the gPath must be
matched exactly. </p>
</td></tr>
<tr><td><code id="grid.set_+3A_grep">grep</code></td>
<td>
<p>A boolean indicating whether the <code>gPath</code> should
be treated as a regular expression.  Values are recycled across
elements of the <code>gPath</code> (e.g., <code>c(TRUE, FALSE)</code> means
that every odd element of the <code>gPath</code> will be treated as
a regular expression).
</p>
</td></tr>
<tr><td><code id="grid.set_+3A_redraw">redraw</code></td>
<td>
<p>A logical value to indicate whether to redraw the grob. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setGrob</code> copies the specified grob and returns a modified
grob.
</p>
<p><code>grid.set</code> destructively replaces a grob on the display list.
If <code>redraw</code>
is <code>TRUE</code> it then redraws everything to reflect the change.
</p>
<p>These functions should not normally be called by the user.
</p>


<h3>Value</h3>

<p><code>setGrob</code> returns a grob object;  <code>grid.set</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.grob">grid.grob</a></code>.
</p>

<hr>
<h2 id='grid.show.layout'>Draw a Diagram of a Grid Layout</h2><span id='topic+grid.show.layout'></span>

<h3>Description</h3>

<p>This function uses Grid graphics to draw a diagram of a
Grid layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.show.layout(l, newpage=TRUE, vp.ex = 0.8, bg = "light grey",
             cell.border = "blue", cell.fill = "light blue",
             cell.label = TRUE, label.col = "blue",
             unit.col = "red", vp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.show.layout_+3A_l">l</code></td>
<td>
<p>A Grid layout object.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_newpage">newpage</code></td>
<td>
<p>A logical value indicating whether to move on
to a new page before drawing the diagram.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_vp.ex">vp.ex</code></td>
<td>
<p>positive number, typically in <code class="reqn">(0,1]</code>, specifying the
scaling of the layout.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_bg">bg</code></td>
<td>
<p>The colour used for the background.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_cell.border">cell.border</code></td>
<td>
<p>The colour used to draw the borders of the cells
in the layout.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_cell.fill">cell.fill</code></td>
<td>
<p>The colour used to fill the cells in the layout.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_cell.label">cell.label</code></td>
<td>
<p>A logical indicating whether the layout cells
should be labelled.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_label.col">label.col</code></td>
<td>
<p>The colour used for layout cell labels.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_unit.col">unit.col</code></td>
<td>
<p>The colour used for labelling the widths/heights of
columns/rows.</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.show.layout_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>format</code> for formatting the
layout width and height annotations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A viewport is created within <code>vp</code> to provide a margin for
annotation, and the layout is drawn within that new viewport.
The margin is filled with light grey, the new viewport is filled
with white and framed with a black border, and the layout regions
are filled with light blue and framed with a blue border.
The diagram is annotated with the widths and heights (including units)
of the columns and rows of the layout using red text. (All colours
are defaults and may be customised via function arguments.)
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+grid.layout">grid.layout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Diagram of a simple layout
grid.show.layout(grid.layout(4,2,
                     heights=unit(rep(1, 4),
                                  c("lines", "lines", "lines", "null")),
                     widths=unit(c(1, 1), "inches")))
</code></pre>

<hr>
<h2 id='grid.show.viewport'>Draw a Diagram of a Grid Viewport</h2><span id='topic+grid.show.viewport'></span>

<h3>Description</h3>

<p>This function uses Grid graphics to draw a diagram of
a Grid viewport.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.show.viewport(v, parent.layout = NULL, newpage = TRUE,
                   vp.ex = 0.8, border.fill="light grey",
                   vp.col="blue", vp.fill="light blue",
                   scale.col="red",
                   vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.show.viewport_+3A_v">v</code></td>
<td>
<p>A Grid viewport object.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_parent.layout">parent.layout</code></td>
<td>
<p>A grid layout object.  If this is not NULL and
the viewport given in <code>v</code> has its location specified relative
to the layout, then the diagram shows the layout and which cells
<code>v</code> occupies within the layout.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_newpage">newpage</code></td>
<td>
<p>A logical value to indicate whether to move to
a new page before drawing the diagram.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_vp.ex">vp.ex</code></td>
<td>
<p>positive number, typically in <code class="reqn">(0,1]</code>, specifying the
scaling of the layout.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_border.fill">border.fill</code></td>
<td>
<p>Colour to fill the border margin.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_vp.col">vp.col</code></td>
<td>
<p>Colour for the border of the viewport region.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_vp.fill">vp.fill</code></td>
<td>
<p>Colour to fill the viewport region.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_scale.col">scale.col</code></td>
<td>
<p>Colour to draw the viewport axes.</p>
</td></tr>
<tr><td><code id="grid.show.viewport_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A viewport is created within <code>vp</code> to provide a margin for
annotation, and the diagram is drawn within that new viewport.
By default, the margin is filled with light grey, the new viewport is filled
with white and framed with a black border, and the viewport region
is filled with light blue and framed with a blue border.
The diagram is annotated with the width and height (including units)
of the viewport, the (x, y) location of the viewport, and
the x- and y-scales of the viewport, using red lines and text.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Diagram of a sample viewport
grid.show.viewport(viewport(x=0.6, y=0.6,
                            width=unit(1, "inches"), height=unit(1, "inches")))
grid.show.viewport(viewport(layout.pos.row=2, layout.pos.col=2:3),
                   grid.layout(3, 4))
</code></pre>

<hr>
<h2 id='grid.stroke'> Stroke or Fill a Path </h2><span id='topic+grid.stroke'></span><span id='topic+strokeGrob'></span><span id='topic+strokeGrob.grob'></span><span id='topic+strokeGrob.GridPath'></span><span id='topic+grid.fill'></span><span id='topic+fillGrob'></span><span id='topic+fillGrob.grob'></span><span id='topic+fillGrob.GridPath'></span><span id='topic+grid.fillStroke'></span><span id='topic+fillStrokeGrob'></span><span id='topic+fillStrokeGrob.grob'></span><span id='topic+fillStrokeGrob.GridPath'></span><span id='topic+as.path'></span>

<h3>Description</h3>

<p>These functions stroke (draw a line along the border) or
fill (or both) a path, where the path is defined by
a grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strokeGrob(x, ...)
## S3 method for class 'grob'
strokeGrob(x, name=NULL, gp=gpar(), vp=NULL, ...)
## S3 method for class 'GridPath'
strokeGrob(x, name=NULL, vp=NULL, ...)
grid.stroke(...)
fillGrob(x, ...)
## S3 method for class 'grob'
fillGrob(x, rule=c("winding", "evenodd"),
         name=NULL, gp=gpar(), vp=NULL, ...)
## S3 method for class 'GridPath'
fillGrob(x, name=NULL, vp=NULL, ...)
grid.fill(...)
fillStrokeGrob(x, ...)
## S3 method for class 'grob'
fillStrokeGrob(x, rule=c("winding", "evenodd"),
               name=NULL, gp=gpar(), vp=NULL, ...)
## S3 method for class 'GridPath'
fillStrokeGrob(x, name=NULL, vp=NULL, ...)
grid.fillStroke(...)
as.path(x, gp=gpar(), rule=c("winding", "evenodd"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.stroke_+3A_x">x</code></td>
<td>
<p>A grob or the result of a call to <code>as.path()</code>.</p>
</td></tr>
<tr><td><code id="grid.stroke_+3A_rule">rule</code></td>
<td>
<p>A fill rule.</p>
</td></tr>
<tr><td><code id="grid.stroke_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.stroke_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.stroke_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.stroke_+3A_...">...</code></td>
<td>
<p>Arguments to <code>grid.*()</code> passed on to <code>*Grob()</code>,
or additional arguments passed on to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A path is defined by the shapes that the grob given in <code>x</code>
would draw.  The grob only contributes to the outline of the
path;  graphical parameter settings such as line colour and fill
are ignored.
</p>
<p><code>grid.stroke()</code> will only ever draw the border (even when
a fill is specified).
</p>
<p><code>grid.fill()</code> will only ever fill the path (even when a line
colour is specified).
</p>
<p>A stroke will only ever happen if a non-transparent line colour
is specified and a fill will only ever happen if a non-transparent
fill is specified.
</p>
<p><code>as.path()</code> allows graphical parameter settings and a fill
rule to be associated with a grob.  This can be useful when
specifying a clipping path for a viewport (see <code><a href="#topic+viewport">viewport</a></code>).
</p>
<p>Not all graphics devices support these functions: for example
<code>xfig</code> and <code>pictex</code> do not.  
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: on devices without support for stroking and filling
##       nothing will be drawn
grid.newpage()
grid.stroke(textGrob("hello", gp=gpar(cex=10)))
grid.fill(circleGrob(1:2/3, r=.3), gp=gpar(fill=rgb(1,0,0,.5)))
</code></pre>

<hr>
<h2 id='grid.text'>Draw Text</h2><span id='topic+grid.text'></span><span id='topic+textGrob'></span>

<h3>Description</h3>

<p>These functions create and draw text and <a href="grDevices.html#topic+plotmath">plotmath</a> expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.text(label, x = unit(0.5, "npc"), y = unit(0.5, "npc"),
          just = "centre", hjust = NULL, vjust = NULL, rot = 0,
          check.overlap = FALSE, default.units = "npc",
          name = NULL, gp = gpar(), draw = TRUE, vp = NULL)

textGrob(label, x = unit(0.5, "npc"), y = unit(0.5, "npc"),
          just = "centre", hjust = NULL, vjust = NULL, rot = 0,
          check.overlap = FALSE, default.units = "npc",
          name = NULL, gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.text_+3A_label">label</code></td>
<td>
<p>A character or <a href="base.html#topic+expression">expression</a> vector.  Other
objects are coerced by <code><a href="grDevices.html#topic+as.graphicsAnnot">as.graphicsAnnot</a></code>.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-values.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-values.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_just">just</code></td>
<td>
<p>The justification of the text
relative to its (x, y) location.  If there are two values, the first
value specifies horizontal justification and the second value specifies
vertical justification.  Possible string values are: <code>"left"</code>,
<code>"right"</code>, <code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>,
and <code>"top"</code>.  For numeric values, 0 means left (bottom) alignment
and 1 means right (top) alignment.
</p>
</td></tr>
<tr><td><code id="grid.text_+3A_hjust">hjust</code></td>
<td>
<p>A numeric vector specifying horizontal justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_vjust">vjust</code></td>
<td>
<p>A numeric vector specifying vertical justification.
If specified, overrides the <code>just</code> setting.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_rot">rot</code></td>
<td>
<p>The angle to rotate the text.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_check.overlap">check.overlap</code></td>
<td>
<p>A logical value to indicate whether to
check for and omit overlapping text (within that grob).</p>
</td></tr>
<tr><td><code id="grid.text_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.text_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.text_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a text grob (a graphical object describing
text), but only <code>grid.text</code>
draws the text (and then only if <code>draw</code> is <code>TRUE</code>).
</p>
<p>If the <code>label</code> argument is an expression, the output is
formatted as a mathematical annotation, as for base graphics text.
</p>


<h3>Value</h3>

<p>A text grob.  <code>grid.text()</code> returns the value invisibly.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
x &lt;- stats::runif(20)
y &lt;- stats::runif(20)
rot &lt;- stats::runif(20, 0, 360)
grid.text("SOMETHING NICE AND BIG", x=x, y=y, rot=rot,
          gp=gpar(fontsize=20, col="grey"))
grid.text("SOMETHING NICE AND BIG", x=x, y=y, rot=rot,
          gp=gpar(fontsize=20), check.overlap=TRUE)

grid.newpage() ## plotmath example
grid.text(quote(frac(e^{-x^2/2}, sqrt(2*pi))), x=x, y=y, rot=stats::runif(20, -45,45),
          gp=gpar(fontsize=17, col=4), check.overlap=TRUE)

grid.newpage()
draw.text &lt;- function(just, i, j) {
  grid.text("ABCD", x=x[j], y=y[i], just=just)
  grid.text(deparse(substitute(just)), x=x[j], y=y[i] + unit(2, "lines"),
            gp=gpar(col="grey", fontsize=8))
}
x &lt;- unit(1:4/5, "npc")
y &lt;- unit(1:4/5, "npc")
grid.grill(h=y, v=x, gp=gpar(col="grey"))
draw.text(c("bottom"), 1, 1)
draw.text(c("left", "bottom"), 2, 1)
draw.text(c("right", "bottom"), 3, 1)
draw.text(c("centre", "bottom"), 4, 1)
draw.text(c("centre"), 1, 2)
draw.text(c("left", "centre"), 2, 2)
draw.text(c("right", "centre"), 3, 2)
draw.text(c("centre", "centre"), 4, 2)
draw.text(c("top"), 1, 3)
draw.text(c("left", "top"), 2, 3)
draw.text(c("right", "top"), 3, 3)
draw.text(c("centre", "top"), 4, 3)
draw.text(c(), 1, 4)
draw.text(c("left"), 2, 4)
draw.text(c("right"), 3, 4)
draw.text(c("centre"), 4, 4)
</code></pre>

<hr>
<h2 id='grid.xaxis'>Draw an X-Axis</h2><span id='topic+grid.xaxis'></span><span id='topic+xaxisGrob'></span>

<h3>Description</h3>

<p>These functions create and draw an x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.xaxis(at = NULL, label = TRUE, main = TRUE,
           edits = NULL, name = NULL,
           gp = gpar(), draw = TRUE, vp = NULL)

xaxisGrob(at = NULL, label = TRUE, main = TRUE,
          edits = NULL, name = NULL,
          gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.xaxis_+3A_at">at</code></td>
<td>
<p>A numeric vector of x-value locations for the tick marks.</p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_label">label</code></td>
<td>
<p>A logical value indicating whether to draw the labels
on the tick marks, or an expression or character vector which
specify the labels to use.  If not logical, must be the same
length as the <code>at</code> argument.</p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_main">main</code></td>
<td>
<p>A logical value indicating whether to draw the axis
at the bottom (<code>TRUE</code>) or at the top (<code>FALSE</code>) of the
viewport.</p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_edits">edits</code></td>
<td>
<p>A gEdit or gEditList containing edit operations
to apply (to the children of the axis)
when the axis is first created and during redrawing
whenever <code>at</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.xaxis_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create an xaxis grob (a graphical object describing an
xaxis), but only <code>grid.xaxis</code>
draws the xaxis (and then only if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>An xaxis grob.  <code>grid.xaxis</code> returns the value invisibly.
</p>


<h3>Children</h3>

<p>If the <code>at</code> slot of an xaxis grob is not <code>NULL</code> then
the xaxis will have the following children:
</p>

<dl>
<dt>major</dt><dd><p> representing the line at the base of the
tick marks.</p>
</dd>
<dt>ticks</dt><dd><p>representing the tick marks.</p>
</dd>
<dt>labels</dt><dd><p>representing the tick labels.</p>
</dd>
</dl>

<p>If the <code>at</code> slot is <code>NULL</code> then there are no children
and ticks are drawn based on the current viewport scale.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+grid.yaxis">grid.yaxis</a></code>
</p>

<hr>
<h2 id='grid.xspline'> Draw an Xspline </h2><span id='topic+grid.xspline'></span><span id='topic+xsplineGrob'></span>

<h3>Description</h3>

<p>These functions create and draw an xspline, a curve drawn
relative to control points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.xspline(...)
xsplineGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0),
            id = NULL, id.lengths = NULL,
            default.units = "npc",
            shape = 0, open = TRUE, arrow = NULL, repEnds = TRUE,
            name = NULL, gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.xspline_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of
spline control points.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of
spline control points.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple xsplines.  All locations with the same
<code>id</code> belong to the same xspline.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_id.lengths">id.lengths</code></td>
<td>
<p>A numeric vector used to separate locations in <code>x</code> and
<code>y</code> into multiple xsplines.  Specifies consecutive blocks of
locations which make up separate xsplines.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_shape">shape</code></td>
<td>
<p>A numeric vector of values between -1 and 1, which
control the shape of the spline relative to the control points.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_open">open</code></td>
<td>
<p>A logical value indicating whether the spline is
a line or a closed shape.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_arrow">arrow</code></td>
<td>
<p>A list describing arrow heads to place at either end
of the xspline, as produced by the <code>arrow</code> function.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_repends">repEnds</code></td>
<td>
<p>A logical value indicating whether the first and
last control points should be replicated for drawing the curve
(see Details below).</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
<tr><td><code id="grid.xspline_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>xsplineGrob</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create an xspline grob (a graphical object describing an
xspline), but only <code>grid.xspline</code>
draws the xspline.
</p>
<p>An xspline is a line drawn relative to control points.  For each
control point, the line
may pass through (interpolate) the control point or it
may only approach (approximate) the control
point;  the behaviour is determined by a shape parameter for each
control point.
</p>
<p>If the shape parameter is greater than zero, the spline
approximates the control points (and is
very similar to a cubic B-spline when the shape is
1).  If the shape parameter is less than zero, the spline interpolates
the control points (and is very similar to a Catmull-Rom spline when
the shape is -1).  If the shape parameter is 0, the spline forms a
sharp corner at that control point.
</p>
<p>For open xsplines, the start and end control points must have a shape
of 0 (and non-zero values are silently converted to zero without warning).
</p>
<p>For open xsplines, by default the start and end control points are
actually replicated before the curve is drawn.  A curve is drawn
between (interpolating or approximating)
the second and third of each set of four control points, so
this default behaviour ensures that
the resulting curve starts at the first control point you have
specified and ends at the last control point.
The default
behaviour can be turned off via the <code>repEnds</code> argument,
in which case the curve that is drawn starts (approximately) at
the second control point and ends (approximately) at the first and
second-to-last control point.
</p>
<p>The <code>repEnds</code> argument is ignored for closed xsplines.
</p>
<p>Missing values are not allowed for <code>x</code> and <code>y</code>
(i.e., it is not valid for a control point to be missing).
</p>
<p>For closed xsplines, a curve is automatically drawn
between the final control point and the initial control point.
</p>


<h3>Value</h3>

<p>A grob object.
</p>


<h3>References</h3>

<p>Blanc, C. and Schlick, C. (1995),
&quot;X-splines : A Spline Model Designed for the End User&quot;,
in <em>Proceedings of SIGGRAPH 95</em>, pp. 377&ndash;386.
<a href="https://dept-info.labri.fr/~schlick/DOC/sig1.html">https://dept-info.labri.fr/~schlick/DOC/sig1.html</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+arrow">arrow</a></code>.
</p>
<p><code><a href="graphics.html#topic+xspline">xspline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0.25, 0.25, 0.75, 0.75)
y &lt;- c(0.25, 0.75, 0.75, 0.25)

xsplineTest &lt;- function(s, i, j, open) {
  pushViewport(viewport(layout.pos.col=j, layout.pos.row=i))
  grid.points(x, y, default.units="npc", pch=16, size=unit(2, "mm"))
  grid.xspline(x, y, shape=s, open=open, gp=gpar(fill="grey"))
  grid.text(s, gp=gpar(col="grey"),
            x=unit(x, "npc") + unit(c(-1, -1, 1, 1), "mm"),
            y=unit(y, "npc") + unit(c(-1, 1, 1, -1), "mm"),
            hjust=c(1, 1, 0, 0),
            vjust=c(1, 0, 0, 1))
  popViewport()
}

pushViewport(viewport(width=.5, x=0, just="left",
                      layout=grid.layout(3, 3, respect=TRUE)))
pushViewport(viewport(layout.pos.row=1))
grid.text("Open Splines", y=1, just="bottom")
popViewport()
xsplineTest(c(0, -1, -1, 0), 1, 1, TRUE)
xsplineTest(c(0, -1,  0, 0), 1, 2, TRUE)
xsplineTest(c(0, -1,  1, 0), 1, 3, TRUE)
xsplineTest(c(0,  0, -1, 0), 2, 1, TRUE)
xsplineTest(c(0,  0,  0, 0), 2, 2, TRUE)
xsplineTest(c(0,  0,  1, 0), 2, 3, TRUE)
xsplineTest(c(0,  1, -1, 0), 3, 1, TRUE)
xsplineTest(c(0,  1,  0, 0), 3, 2, TRUE)
xsplineTest(c(0,  1,  1, 0), 3, 3, TRUE)
popViewport()
pushViewport(viewport(width=.5, x=1, just="right",
                      layout=grid.layout(3, 3, respect=TRUE)))
pushViewport(viewport(layout.pos.row=1))
grid.text("Closed Splines", y=1, just="bottom")
popViewport()
xsplineTest(c(-1, -1, -1, -1), 1, 1, FALSE)
xsplineTest(c(-1, -1,  0, -1), 1, 2, FALSE)
xsplineTest(c(-1, -1,  1, -1), 1, 3, FALSE)
xsplineTest(c( 0,  0, -1,  0), 2, 1, FALSE)
xsplineTest(c( 0,  0,  0,  0), 2, 2, FALSE)
xsplineTest(c( 0,  0,  1,  0), 2, 3, FALSE)
xsplineTest(c( 1,  1, -1,  1), 3, 1, FALSE)
xsplineTest(c( 1,  1,  0,  1), 3, 2, FALSE)
xsplineTest(c( 1,  1,  1,  1), 3, 3, FALSE)
popViewport()
</code></pre>

<hr>
<h2 id='grid.yaxis'>Draw a Y-Axis</h2><span id='topic+grid.yaxis'></span><span id='topic+yaxisGrob'></span>

<h3>Description</h3>

<p>These functions create and draw a y-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.yaxis(at = NULL, label = TRUE, main = TRUE,
           edits = NULL, name = NULL,
           gp = gpar(), draw = TRUE, vp = NULL)

yaxisGrob(at = NULL, label = TRUE, main = TRUE,
          edits = NULL, name = NULL,
          gp = gpar(), vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.yaxis_+3A_at">at</code></td>
<td>
<p>A numeric vector of y-value locations for the tick marks.</p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_label">label</code></td>
<td>
<p>A logical value indicating whether to draw the labels
on the tick marks, or an expression or character vector which
specify the labels to use.  If not logical, must be the same
length as the <code>at</code> argument.</p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_main">main</code></td>
<td>
<p>A logical value indicating whether to draw the axis
at the left (<code>TRUE</code>) or at the right (<code>FALSE</code>) of the
viewport.</p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_edits">edits</code></td>
<td>
<p>A gEdit or gEditList containing edit operations
to apply (to the children of the axis)
when the axis is first created and during redrawing
whenever <code>at</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.yaxis_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both functions create a yaxis grob (a graphical object describing a
yaxis), but only <code>grid.yaxis</code>
draws the yaxis (and then only if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>Value</h3>

<p>A yaxis grob.  <code>grid.yaxis</code> returns the value invisibly.
</p>


<h3>Children</h3>

<p>If the <code>at</code> slot of an xaxis grob is not <code>NULL</code> then
the xaxis will have the following children:
</p>

<dl>
<dt>major</dt><dd><p> representing the line at the base of the
tick marks.</p>
</dd>
<dt>ticks</dt><dd><p>representing the tick marks.</p>
</dd>
<dt>labels</dt><dd><p>representing the tick labels.</p>
</dd>
</dl>

<p>If the <code>at</code> slot is <code>NULL</code> then there are no children
and ticks are drawn based on the current viewport scale.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>,
<code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+grid.xaxis">grid.xaxis</a></code>
</p>

<hr>
<h2 id='gridCoords'>Create Sets of Coordinates for Grid Grobs</h2><span id='topic+gridCoords'></span><span id='topic+gridGrobCoords'></span><span id='topic+gridGTreeCoords'></span><span id='topic+emptyCoords'></span><span id='topic+emptyGrobCoords'></span><span id='topic+emptyGTreeCoords'></span><span id='topic+isEmptyCoords'></span>

<h3>Description</h3>

<p>These functions support the development of <code><a href="#topic+grobPoints">grobPoints</a></code>
methods for custom grobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridCoords(x, y)
gridGrobCoords(x, name, rule = NULL)
gridGTreeCoords(x, name)
emptyCoords
emptyGrobCoords(name)
emptyGTreeCoords(name)
isEmptyCoords(coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridCoords_+3A_x">x</code></td>
<td>
<p>For <code>gridCoords</code> a numeric vector.  For
<code>gridGrobCoords</code> a list of <code>"GridCoords"</code> objects.
For <code>gridGTreeCoords</code> a list of either <code>"GridGrobCoords"</code>
or <code>"GridGTreeCoords"</code> objects.</p>
</td></tr>
<tr><td><code id="gridCoords_+3A_y">y</code></td>
<td>
<p> A numeric vector.</p>
</td></tr>
<tr><td><code id="gridCoords_+3A_name">name</code></td>
<td>
<p> A character value. </p>
</td></tr>
<tr><td><code id="gridCoords_+3A_rule">rule</code></td>
<td>
<p>A fill rule, either <code>"winding"</code> or <code>"evenodd"</code>,
or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="gridCoords_+3A_coords">coords</code></td>
<td>
<p>A set of grob coordinates (as generated by <code>grobCoords</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions help the developer of a <code>grobPoints</code> method
to generate the coordinates from a custom grob.
</p>
<p>The <code>emptyCoords</code> object can be used to return a &quot;null&quot;
result (e.g., when asking for <code>closed</code> coordinates on an
open line) and the <code>isEmptyCoords</code> function can be used to check for
&quot;null&quot; results.
</p>


<h3>Value</h3>

<p>For <code>gridCoords</code> a <code>"GridCoords"</code> object.
For <code>gridGrobCoords</code> a <code>"GridGrobCoords"</code> object.
For <code>gridGTreeCoords</code> a <code>"GridGTreeCoords"</code> object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>

<hr>
<h2 id='grobCoords'>Calculate Points on the Perimeter of a Grob</h2><span id='topic+grobCoords'></span><span id='topic+grobPoints'></span><span id='topic+isClosed'></span>

<h3>Description</h3>

<p>These functions calculate points along the perimeter (or length) of
a grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grobCoords(x, closed, ...)
grobPoints(x, closed, ...)
isClosed(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grobCoords_+3A_x">x</code></td>
<td>
<p>A grob object.</p>
</td></tr>
<tr><td><code id="grobCoords_+3A_closed">closed</code></td>
<td>
<p>Whether we are asking for points along the perimeter of
a closed object or points along the length of an open object.
Some grobs (e.g., X-splines) can do both.
</p>
<p>This defaults to <code>TRUE</code> except for known cases that are not
closed (e.g., lines and segments).
</p>
</td></tr>
<tr><td><code id="grobCoords_+3A_...">...</code></td>
<td>
<p>Arguments to be used by methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between <code>grobCoords</code> and <code>grobPoints</code>
is that <code>grobCoords</code> performs all pre- and post-drawing operations
on the grob that would normally occur if the grob was being drawn,
then calls <code>grobPoints</code>.  So the former takes into account
any <code>vp</code> and <code>gp</code> settings on the grob.  This means
that users should usually only want to call <code>grobCoords</code>;
only (expert) developers may have a need to call <code>grobPoints</code>.
</p>
<p>Custom grobs can write their own methods for <code>grobPoints</code>
(see <code><a href="#topic+gridCoords">gridCoords</a></code>).
</p>
<p>The <code>isClosed</code> function returns <code>TRUE</code> or <code>FALSE</code>
to indicate whether a grob is a closed shape.  The default response
is <code>TRUE</code>, unless a method has been defined otherwise
(e.g., for lines and line segments).
</p>


<h3>Value</h3>

<p>Either a <code>"GridGrobCoords"</code> object
(a list of lists with components <code>x</code> and <code>y</code>) or
a <code>"GridGTreeCoords"</code> object
(a list of <code>"GridGrobCoords"</code> and/or <code>"GridGTreeCoords"</code>
objects).
</p>
<p>All locations are in inches relative to the current <span class="pkg">grid</span> viewport.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>

<hr>
<h2 id='grobName'>Generate a Name for a Grob</h2><span id='topic+grobName'></span>

<h3>Description</h3>

<p>This function generates a unique (within-session) name for
a grob, based on the grob's class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grobName(grob = NULL, prefix = "GRID")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grobName_+3A_grob">grob</code></td>
<td>
<p>A grob object or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="grobName_+3A_prefix">prefix</code></td>
<td>
<p>The prefix part of the name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of the form <code>prefix.class(grob).index</code>
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>

<hr>
<h2 id='grobWidth'>Create a Unit Describing the Width of a Grob</h2><span id='topic+grobWidth'></span><span id='topic+grobHeight'></span><span id='topic+grobAscent'></span><span id='topic+grobDescent'></span>

<h3>Description</h3>

<p>These functions create a unit object describing the width or height of
a grob.  They are generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grobWidth(x)
grobHeight(x)
grobAscent(x)
grobDescent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grobWidth_+3A_x">x</code></td>
<td>
<p>A grob object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A unit object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit">unit</a></code> and
<code><a href="#topic+stringWidth">stringWidth</a></code>
</p>

<hr>
<h2 id='grobX'>Create a Unit Describing a Grob Boundary Location</h2><span id='topic+grobX'></span><span id='topic+grobY'></span>

<h3>Description</h3>

<p>These functions create a unit object describing a location somewhere
on the boundary of
a grob.  They are generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grobX(x, theta)
grobY(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grobX_+3A_x">x</code></td>
<td>
<p>A grob, or gList, or gTree, or gPath.</p>
</td></tr>
<tr><td><code id="grobX_+3A_theta">theta</code></td>
<td>
<p>An angle indicating where the location is
on the grob boundary.  Can be one of <code>"east"</code>,
<code>"north"</code>, <code>"west"</code>, or <code>"south"</code>,
which correspond to angles 0, 90, 180, and 270,
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The angle is anti-clockwise with zero corresponding to a line
with an origin centred between the extreme
points of the shape, and pointing at 3 o'clock.
</p>
<p>If the grob describes a single shape, the boundary value should
correspond to the exact edge of the shape.
</p>
<p>If the grob describes multiple shapes, the boundary
value will either correspond to the edge of a bounding box around all of
the shapes described by the grob (for multiple rectangles, circles,
xsplines, or text), or to a
convex hull around all vertices of all shapes described by the grob
(for multiple polygons, points, lines, polylines,
and segments).
</p>
<p>Points grobs are currently a special case because the convex hull
is based on the data symbol <em>locations</em> and does not take
into account the extent of the data symbols themselves.
</p>
<p>The extents of any arrow heads are currently <em>not</em> taken into account.
</p>


<h3>Value</h3>

<p>A unit object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit">unit</a></code> and
<code><a href="#topic+grobWidth">grobWidth</a></code>
</p>

<hr>
<h2 id='legendGrob'>Constructing a Legend Grob</h2><span id='topic+legendGrob'></span><span id='topic+grid.legend'></span>

<h3>Description</h3>

<p>Constructing a legend grob (in progress)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendGrob(labels, nrow, ncol, byrow = FALSE,
           do.lines = has.lty || has.lwd, lines.first = TRUE,
           hgap = unit(1, "lines"), vgap = unit(1, "lines"),
           default.units = "lines", pch, gp = gpar(), vp = NULL)

grid.legend(..., draw=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendGrob_+3A_labels">labels</code></td>
<td>
<p>legend labels (expressions)</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_nrow">nrow</code>, <code id="legendGrob_+3A_ncol">ncol</code></td>
<td>
<p>integer; the number of rows or columns, respectively
of the legend &ldquo;layout&rdquo;.  <code>nrow</code> is optional and
typically computed from the number of labels and <code>ncol</code>.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_byrow">byrow</code></td>
<td>
<p>logical indicating whether rows of the legend are filled first.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_do.lines">do.lines</code></td>
<td>
<p>logical indicating whether legend lines are drawn.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_lines.first">lines.first</code></td>
<td>
<p>logical indicating whether legend lines are drawn
first and hence in a plain &ldquo;below&rdquo; legend symbols.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_hgap">hgap</code></td>
<td>
<p>horizontal space between the legend entries</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_vgap">vgap</code></td>
<td>
<p>vertical space between the legend entries</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_default.units">default.units</code></td>
<td>
<p>default units, see <code><a href="#topic+unit">unit</a></code>.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_pch">pch</code></td>
<td>
<p>legend symbol, numeric or character, passed to
<code><a href="#topic+pointsGrob">pointsGrob</a>()</code>; see also <code><a href="graphics.html#topic+points">points</a></code> for
interpretation of the numeric codes.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_gp">gp</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="#topic+gpar">gpar</a></code>, is basically a list of
graphical parameter settings.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_vp">vp</code></td>
<td>
<p>a Grid <code><a href="#topic+viewport">viewport</a></code> object (or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_...">...</code></td>
<td>
<p>for <code>grid.legend()</code>: all the arguments above are
passed to <code>legendGrob()</code>.</p>
</td></tr>
<tr><td><code id="legendGrob_+3A_draw">draw</code></td>
<td>
<p>logical indicating whether graphics output should be produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions create a legend <code><a href="#topic+grob">grob</a></code> (a graphical object
describing a plot legend), but only <code>grid.legend</code> draws it (only
if <code>draw</code> is <code>TRUE</code>).
</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>, <code><a href="#topic+viewport">viewport</a></code>;
<code><a href="#topic+pointsGrob">pointsGrob</a></code>, <code><a href="#topic+linesGrob">linesGrob</a></code>.
</p>
<p><code><a href="#topic+grid.plot.and.legend">grid.plot.and.legend</a></code> contains a simple example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Data:
  n &lt;- 10
  x &lt;- stats::runif(n) ; y1 &lt;- stats::runif(n) ; y2 &lt;- stats::runif(n)
  ## Construct the grobs :
  plot &lt;- gTree(children=gList(rectGrob(),
                  pointsGrob(x, y1, pch=21, gp=gpar(col=2, fill="gray")),
                  pointsGrob(x, y2, pch=22, gp=gpar(col=3, fill="gray")),
                  xaxisGrob(),
                  yaxisGrob()))
  legd &lt;- legendGrob(c("Girls", "Boys", "Other"), pch=21:23,
                     gp=gpar(col = 2:4, fill = "gray"))
  gg &lt;- packGrob(packGrob(frameGrob(), plot),
                 legd, height=unit(1,"null"), side="right")

  ## Now draw it on a new device page:
  grid.newpage()
  pushViewport(viewport(width=0.8, height=0.8))
  grid.draw(gg)
</code></pre>

<hr>
<h2 id='makeContent'> Customised grid Grobs </h2><span id='topic+makeContent'></span><span id='topic+makeContext'></span>

<h3>Description</h3>

<p>These generic hook functions are called whenever a grid grob is drawn.
They provide an opportunity for customising the drawing context
and drawing content of a
new class derived from grob (or gTree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeContext(x)
makeContent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeContent_+3A_x">x</code></td>
<td>
<p> A grid grob. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called by the <code>grid.draw</code> methods for grobs
and gTrees.
</p>
<p><code>makeContext</code> is called first during the drawing of a grob.
This function should be used to <em>modify</em> the <code>vp</code> slot
of <code>x</code> (and/or the <code>childrenvp</code> slot if <code>x</code>
is a gTree).  The function <em>must</em> return the modified <code>x</code>.
Note that
the default behaviour for grobs is to push any viewports in the
<code>vp</code> slot, and for gTrees is to also push and up any viewports in the
<code>childrenvp</code> slot, so this function is used to customise the
drawing context for a grob or gTree.
</p>
<p><code>makeContent</code> is called next and is where any additional
calculations should occur and graphical content should
be generated (see, for example,
<code>grid:::makeContent.xaxis</code>).
This function should be used to <em>modify</em> the <code>children</code>
of a gTree.
The function <em>must</em> return the modified <code>x</code>.
Note that the default behaviour
for gTrees is to draw all grobs in the <code>children</code> slot,
so this function is used to customise the drawing content for a gTree.
It is also possible to customise the drawing content for a simple
grob, but more care needs to be taken;  for example, the function
should return a standard grid primitive with a <code>drawDetails()</code>
method in this case.
</p>
<p>Note that these functions should be <em>cumulative</em> in their
effects, so that the <code>x</code> returned by <code>makeContent()</code>
<em>includes</em> any changes made by <code>makeContext()</code>.
</p>
<p>Note that <code>makeContext</code> is
also called in the calculation of <code>"grobwidth"</code> and
<code>"grobheight"</code> units.
</p>


<h3>Value</h3>

<p>Both functions are expected to return a grob or gTree
(a modified version of <code>x</code>).
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>References</h3>

<p> &quot;Changes to grid for R 3.0.0&quot;,
Paul Murrell, <em>The R Journal</em> (2013) 5:2, pages 148-160. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.draw">grid.draw</a></code> </p>

<hr>
<h2 id='patterns'> Define Gradient and Pattern Fills </h2><span id='topic+patterns'></span><span id='topic+linearGradient'></span><span id='topic+radialGradient'></span><span id='topic+pattern'></span>

<h3>Description</h3>

<p>Functions to define gradient fills and pattern fills.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearGradient(colours = c("black", "white"),
               stops = seq(0, 1, length.out = length(colours)),
               x1 = unit(0, "npc"), y1 = unit(0, "npc"),  
               x2 = unit(1, "npc"), y2 = unit(1, "npc"),
               default.units = "npc",
               extend = c("pad", "repeat", "reflect", "none"),
               group = TRUE) 
radialGradient(colours = c("black", "white"),
               stops = seq(0, 1, length.out = length(colours)),
               cx1 = unit(.5, "npc"), cy1 = unit(.5, "npc"),
               r1 = unit(0, "npc"),
               cx2 = unit(.5, "npc"), cy2 = unit(.5, "npc"),
               r2 = unit(.5, "npc"),
               default.units = "npc",
               extend = c("pad", "repeat", "reflect", "none"),
               group = TRUE) 
pattern(grob,
        x = 0.5, y = 0.5, width = 1, height = 1,
        default.units = "npc",
        just="centre", hjust=NULL, vjust=NULL,
        extend = c("pad", "repeat", "reflect", "none"),
        gp = gpar(fill="transparent"),
        group = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patterns_+3A_colours">colours</code></td>
<td>
<p>Two or more colours for the gradient to transition between.</p>
</td></tr>
<tr><td><code id="patterns_+3A_stops">stops</code></td>
<td>
<p>Locations of the gradient colours between the start and end
points of the gradient (as a proportion of the distance from the
start point to the end point).</p>
</td></tr>
<tr><td><code id="patterns_+3A_x1">x1</code>, <code id="patterns_+3A_y1">y1</code>, <code id="patterns_+3A_x2">x2</code>, <code id="patterns_+3A_y2">y2</code></td>
<td>
<p>The start and end points for a linear gradient.</p>
</td></tr>
<tr><td><code id="patterns_+3A_default.units">default.units</code></td>
<td>
<p>The coordinate system
to use if any location or dimension is
specified as just a numeric value.</p>
</td></tr>
<tr><td><code id="patterns_+3A_extend">extend</code></td>
<td>
<p>What happens outside the start and end of the gradient
(see Details).</p>
</td></tr>
<tr><td><code id="patterns_+3A_cx1">cx1</code>, <code id="patterns_+3A_cy1">cy1</code>, <code id="patterns_+3A_r1">r1</code>, <code id="patterns_+3A_cx2">cx2</code>, <code id="patterns_+3A_cy2">cy2</code>, <code id="patterns_+3A_r2">r2</code></td>
<td>
<p>The centre and radius of the start
and end circles for a radial gradient.</p>
</td></tr>
<tr><td><code id="patterns_+3A_grob">grob</code></td>
<td>
<p>A grob (or a gTree) that will be drawn as the tile in
a pattern fill.</p>
</td></tr>
<tr><td><code id="patterns_+3A_x">x</code>, <code id="patterns_+3A_y">y</code>, <code id="patterns_+3A_width">width</code>, <code id="patterns_+3A_height">height</code></td>
<td>
<p>The size of the tile for a pattern fill.</p>
</td></tr>
<tr><td><code id="patterns_+3A_just">just</code>, <code id="patterns_+3A_hjust">hjust</code>, <code id="patterns_+3A_vjust">vjust</code></td>
<td>
<p>The justification of the tile relative to
its location.</p>
</td></tr>
<tr><td><code id="patterns_+3A_gp">gp</code></td>
<td>
<p>Default graphical parameter settings for the tile.</p>
</td></tr>
<tr><td><code id="patterns_+3A_group">group</code></td>
<td>
<p>A logical indicating whether the gradient or pattern is
relative to the bounding box of the grob or whether
it is relative to individual shapes within the grob.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use these functions to define a gradient fill or pattern fill and
then use the resulting object as the value for <code>fill</code>
in a call to the <code>gpar()</code> function.
</p>
<p>The possible values of extend, and their meanings, are:
</p>

<ul>
<li><p>[<code>pad</code>:] propagate the value of the gradient at its
boundary.
</p>
</li>
<li><p>[<code>none</code>:] produce no fill beyond the limits of the
gradient.
</p>
</li>
<li><p>[<code>repeat</code>:] repeat the fill.
</p>
</li>
<li><p>[<code>reflect</code>:] repeat the fill in reverse.
</p>
</li></ul>

<p>To create a tiling pattern, provide a simple grob (like a circle),
specify the location and size of the pattern to include the simple
grob, and specify <code>extend="repeat"</code>.
</p>
<p>On viewports, gradients and patterns are relative to the entire
viewport, unless <code>group = FALSE</code>, in which case they are
relative to individual grobs as they are drawn.
On gTrees, gradients and patterns are relative to a bounding
box around all of the children of the gTree,
unless <code>group = FALSE</code>, in which case they are
relative to individual children as they are drawn.
On grobs, gradients and patterns are relative to a bounding
box around all of the shapes that are drawn by the grob,
unless <code>group = FALSE</code>, in which case they are
relative to individual shapes.
</p>


<h3>Value</h3>

<p>A linear gradient or radial gradient or pattern object.
</p>


<h3>Warning</h3>

<p>Gradient fills and pattern fills are not supported on all graphics
devices.  Where they are not supported, closed shapes will be
rendered with a transparent fill.  Where they are supported,
not all values of <code>extend</code> are supported.
</p>
<p>On Cairo devices, use of clipping in the pattern definition should be
avoided because it is very likely to result in distortion of the pattern tile.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpar">gpar</a></code>
</p>

<hr>
<h2 id='plotViewport'> Create a Viewport with a Standard Plot Layout </h2><span id='topic+plotViewport'></span>

<h3>Description</h3>

<p>This is a convenience function for producing a viewport with
the common S-style plot layout &ndash; i.e., a central
plot region surrounded by margins given in terms of a
number of lines of text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotViewport(margins=c(5.1, 4.1, 4.1, 2.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotViewport_+3A_margins">margins</code></td>
<td>
<p> A numeric vector interpreted in the same way
as <code>par(mar)</code> in base graphics. </p>
</td></tr>
<tr><td><code id="plotViewport_+3A_...">...</code></td>
<td>
<p> All other arguments will be passed to a call to
the <code>viewport()</code> function. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid viewport object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code> and
<code><a href="#topic+dataViewport">dataViewport</a></code>.
</p>

<hr>
<h2 id='Querying+20the+20Viewport+20Tree'>Get the Current Grid Viewport (Tree)</h2><span id='topic+current.viewport'></span><span id='topic+current.parent'></span><span id='topic+current.vpTree'></span><span id='topic+current.vpPath'></span><span id='topic+current.transform'></span><span id='topic+current.rotation'></span>

<h3>Description</h3>

<p><code>current.viewport()</code>
returns the viewport that Grid is going to draw into.
</p>
<p><code>current.parent</code> returns the parent of the current viewport.
</p>
<p><code>current.vpTree</code> returns the entire Grid viewport tree.
</p>
<p><code>current.vpPath</code> returns the viewport path to the current viewport.
</p>
<p><code>current.transform</code> returns the transformation
matrix for the current viewport.
</p>
<p><code>current.rotation</code> returns the (total) rotation
for the current viewport.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current.viewport()
current.parent(n=1)
current.vpTree(all=TRUE)
current.vpPath()
current.transform()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Querying+2B20the+2B20Viewport+2B20Tree_+3A_n">n</code></td>
<td>
<p> The number of generations to go up.</p>
</td></tr>
<tr><td><code id="Querying+2B20the+2B20Viewport+2B20Tree_+3A_all">all</code></td>
<td>
<p>A logical value indicating whether the entire viewport
tree should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to get the grandparent of the current viewport
(or higher) using the <code>n</code> argument to <code>current.parent()</code>.
</p>
<p>The parent of the ROOT viewport is <code>NULL</code>.
It is an error to request the grandparent of the ROOT viewport.
</p>
<p>If <code>all</code> is <code>FALSE</code> then
<code>current.vpTree</code> only returns the subtree below
the current viewport.
</p>


<h3>Value</h3>

<p>A Grid viewport object from <code>current.viewport</code> or
<code>current.vpTree</code>.
</p>
<p><code>current.transform</code> returns a 4x4 transformation matrix.
</p>
<p>The viewport path returned by <code>current.vpPath</code> is <code>NULL</code>
if the current viewport is the <code>ROOT</code> viewport
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
pushViewport(viewport(width=0.8, height=0.8, name="A"))
pushViewport(viewport(x=0.1, width=0.3, height=0.6,
  just="left", name="B"))
upViewport(1)
pushViewport(viewport(x=0.5, width=0.4, height=0.8,
  just="left", name="C"))
pushViewport(viewport(width=0.8, height=0.8, name="D"))
current.vpPath()
upViewport(1)
current.vpPath()
current.vpTree()
current.viewport()
current.vpTree(all=FALSE)
popViewport(0)
</code></pre>

<hr>
<h2 id='resolveRasterSize'>
Utility function to resolve the size of a raster grob
</h2><span id='topic+resolveRasterSize'></span>

<h3>Description</h3>

<p>Determine the width and height of a raster grob when one or both
are not given explicitly.
</p>
<p>The result depends on both the aspect ratio of the raster image
and the aspect ratio of the physical drawing context, so the
result is only valid for the drawing context in which this
function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolveRasterSize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolveRasterSize_+3A_x">x</code></td>
<td>
<p> A raster grob </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A raster grob can be specified with width and/or height of
<code>NULL</code>, which means that the size at which the raster is
drawn will be decided at drawing time.
</p>


<h3>Value</h3>

<p>A raster grob, with explicit width and height.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.raster">grid.raster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Square raster
rg &lt;- rasterGrob(matrix(0))
# Fill the complete page (if page is square)
grid.newpage()
resolveRasterSize(rg)$height
grid.draw(rg)
# Forced to fit tall thin region
grid.newpage()
pushViewport(viewport(width=.1))
resolveRasterSize(rg)$height
grid.draw(rg)
</code></pre>

<hr>
<h2 id='roundrect'>Draw a rectangle with rounded corners</h2><span id='topic+roundrect'></span><span id='topic+grid.roundrect'></span><span id='topic+roundrectGrob'></span>

<h3>Description</h3>

<p>Draw a <em>single</em> rectangle with rounded corners.</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundrectGrob(x=0.5, y=0.5, width=1, height=1,
              default.units="npc",
              r=unit(0.1, "snpc"),
              just="centre",
              name=NULL, gp=NULL, vp=NULL)
grid.roundrect(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundrect_+3A_x">x</code>, <code id="roundrect_+3A_y">y</code>, <code id="roundrect_+3A_width">width</code>, <code id="roundrect_+3A_height">height</code></td>
<td>
<p>The location and size of the rectangle.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use
if <code>x</code>, <code>y</code>, <code>width</code>, or <code>height</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_r">r</code></td>
<td>
<p>The radius of the rounded corners.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_just">just</code></td>
<td>
<p>The justification of the rectangle relative to its
location.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_name">name</code></td>
<td>
<p>A name to identify the grob.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_gp">gp</code></td>
<td>
<p>Graphical parameters to apply to the grob.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_vp">vp</code></td>
<td>
<p>A viewport object or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="roundrect_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>roundrectGrob()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At present, this function can only be used to draw <em>one</em>
rounded rectangle.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.roundrect(width=.5, height=.5, name="rr")
theta &lt;- seq(0, 360, length.out=50)
for (i in 1:50)
    grid.circle(x=grobX("rr", theta[i]),
                y=grobY("rr", theta[i]),
                r=unit(1, "mm"),
                gp=gpar(fill="black"))
</code></pre>

<hr>
<h2 id='showGrob'>
Label grid grobs
</h2><span id='topic+showGrob'></span>

<h3>Description</h3>

<p>Produces a graphical display of (by default) the current grid scene,
with labels showing the names of each grob in the scene.
It is also possible to label only specific grobs in the scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showGrob(x = NULL,
         gPath = NULL, strict = FALSE, grep = FALSE,
         recurse = TRUE, depth = NULL,
         labelfun = grobLabel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGrob_+3A_x">x</code></td>
<td>

<p>If <code>NULL</code>, the current grid scene is labelled.
Otherwise, a grob (or gTree) to draw and then label.
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_gpath">gPath</code></td>
<td>

<p>A path identifying a subset of the current scene or grob
to be labelled.
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_strict">strict</code></td>
<td>

<p>Logical indicating whether the gPath is strict.
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_grep">grep</code></td>
<td>

<p>Logical indicating whether the gPath is a regular expression.
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_recurse">recurse</code></td>
<td>

<p>Should the children of gTrees also be labelled?
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_depth">depth</code></td>
<td>

<p>Only display grobs at the specified depth (may be a vector
of depths).
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_labelfun">labelfun</code></td>
<td>

<p>Function used to generate a label from each grob.
</p>
</td></tr>
<tr><td><code id="showGrob_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>labelfun</code> to control fine details
of the generated label.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>None of the labelling is recorded on the grid display list so the
original scene can be reproduced by calling <code>grid.refresh</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grob">grob</a></code> and
<code><a href="#topic+gTree">gTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    grid.newpage()
    gt &lt;- gTree(childrenvp=vpStack(
                  viewport(x=0, width=.5, just="left", name="vp"),
                  viewport(y=.5, height=.5, just="bottom", name="vp2")),
                children=gList(rectGrob(vp="vp::vp2", name="child")),
                name="parent")
    grid.draw(gt)
    showGrob()
    showGrob(gPath="child")
    showGrob(recurse=FALSE)
    showGrob(depth=1)
    showGrob(depth=2)
    showGrob(depth=1:2)
    showGrob(gt)
    showGrob(gt, gPath="child")
    showGrob(just="left", gp=gpar(col="red", cex=.5), rot=45)
    showGrob(labelfun=function(grob, ...) {
        x &lt;- grobX(grob, "west")
        y &lt;- grobY(grob, "north")
        gTree(children=gList(rectGrob(x=x, y=y,
                width=stringWidth(grob$name) + unit(2, "mm"),
                height=stringHeight(grob$name) + unit(2, "mm"),
                gp=gpar(col=NA, fill=rgb(1, 0, 0, .5)),
                just=c("left", "top")),
                textGrob(grob$name,
                         x=x + unit(1, "mm"), y=y - unit(1, "mm"),
                         just=c("left", "top"))))
    })

## Not run: 
    # Examples from higher-level packages

    library(lattice)
    # Ctrl-c after first example
    example(histogram)
    showGrob()
    showGrob(gPath="plot_01.ylab")

    library(ggplot2)
    # Ctrl-c after first example
    example(qplot)
    showGrob()
    showGrob(recurse=FALSE)
    showGrob(gPath="panel-3-3")
    showGrob(gPath="axis.title", grep=TRUE)
    showGrob(depth=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='showViewport'>
Display grid viewports
</h2><span id='topic+showViewport'></span>

<h3>Description</h3>

<p>Produces a graphical display of (by default) the current
grid viewport tree.  It is also possible to display only
specific viewports.  Each viewport is drawn as a rectangle
and the leaf viewports are labelled with the viewport name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showViewport(vp = NULL, recurse = TRUE, depth = NULL,
             newpage = FALSE, leaves = FALSE,
             col = rgb(0, 0, 1, 0.2), fill = rgb(0, 0, 1, 0.1),
             label = TRUE, nrow = 3, ncol = nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showViewport_+3A_vp">vp</code></td>
<td>

<p>If <code>NULL</code>, the current viewport tree is displayed.
Otherwise, a viewport (or vpList, or vpStack, or vpTree) or
a vpPath that specifies which viewport to display.
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_recurse">recurse</code></td>
<td>

<p>Should the children of the specified viewport also be displayed?
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_depth">depth</code></td>
<td>

<p>Only display viewports at the specified depth (may be a vector
of depths).
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_newpage">newpage</code></td>
<td>

<p>Start a new page for the display?  Otherwise, the viewports
are displayed on top of the current plot.
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_leaves">leaves</code></td>
<td>

<p>Produce a matrix of smaller displays, with each leaf viewport
in its own display.
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_col">col</code></td>
<td>

<p>The colour used to draw the border of the rectangle for each
viewport <em>and</em> to draw the label for each viewport.
If a vector, then the first colour is used for the
top-level viewport, the second colour is used for its children,
the third colour for their children, and so on.
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_fill">fill</code></td>
<td>

<p>The colour used to fill each viewport.  May be a vector as per
<code>col</code>.
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_label">label</code></td>
<td>

<p>Should the viewports be labelled (with the viewport name)?
</p>
</td></tr>
<tr><td><code id="showViewport_+3A_nrow">nrow</code>, <code id="showViewport_+3A_ncol">ncol</code></td>
<td>

<p>The number of rows and columns when <code>leaves</code> is <code>TRUE</code>.
Otherwise ignored.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code> and
<code><a href="#topic+grid.show.viewport">grid.show.viewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showViewport(viewport(width=.5, height=.5, name="vp"))

grid.newpage()
pushViewport(viewport(width=.5, height=.5, name="vp"))
upViewport()
showViewport(vpPath("vp"))

showViewport(vpStack(viewport(width=.5, height=.5, name="vp1"),
                     viewport(width=.5, height=.5, name="vp2")),
             newpage=TRUE)

showViewport(vpStack(viewport(width=.5, height=.5, name="vp1"),
                     viewport(width=.5, height=.5, name="vp2")),
             fill=rgb(1:0, 0:1, 0, .1),
             newpage=TRUE)
</code></pre>

<hr>
<h2 id='stringWidth'>Create a Unit Describing the Width and Height of a String or Math
Expression</h2><span id='topic+stringWidth'></span><span id='topic+stringHeight'></span><span id='topic+stringAscent'></span><span id='topic+stringDescent'></span>

<h3>Description</h3>

<p>These functions create a unit object describing the width or height of
a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringWidth(string)
stringHeight(string)
stringAscent(string)
stringDescent(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stringWidth_+3A_string">string</code></td>
<td>
<p>A character vector or a language object (as used for
&lsquo;<a href="grDevices.html#topic+plotmath">plotmath</a>&rsquo; calls).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+unit">unit</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit">unit</a></code> and
<code><a href="#topic+grobWidth">grobWidth</a></code>
</p>
<p><code>strwidth</code> in the <span class="pkg">graphics</span> package for more details of the
typographic concepts behind the computations.
</p>

<hr>
<h2 id='unit'>Function to Create a Unit Object</h2><span id='topic+unit'></span><span id='topic+is.unit'></span>

<h3>Description</h3>

<p>This function creates a unit object &mdash; a vector of unit values.
A unit value is typically just a single numeric value with an
associated unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit(x, units, data=NULL)
is.unit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_+3A_x">x</code></td>
<td>
<p>A numeric vector.
</p>
<p>For <code>is.unit</code>, any R object.</p>
</td></tr>
<tr><td><code id="unit_+3A_units">units</code></td>
<td>
<p>A character vector specifying the units for the
corresponding numeric values.</p>
</td></tr>
<tr><td><code id="unit_+3A_data">data</code></td>
<td>
<p>This argument is used to supply extra information
for special <code>unit</code> types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unit objects allow the user to specify locations and dimensions
in a large number of different coordinate systems.  All drawing
occurs relative to a viewport and the <code>units</code> specifies
what coordinate system to use within that viewport.
</p>
<p>Possible <code>units</code> (coordinate systems) are:
</p>

<dl>
<dt><code>"npc"</code></dt><dd><p>Normalised Parent Coordinates (the default).
The origin of the viewport is (0, 0) and the viewport has a width
and height of 1 unit.  For example, (0.5, 0.5) is the centre of
the viewport.</p>
</dd>
<dt><code>"cm"</code></dt><dd><p>Centimetres.</p>
</dd>
<dt><code>"inches"</code></dt><dd><p>Inches.  1 in = 2.54 cm.</p>
</dd>
<dt><code>"mm"</code></dt><dd><p>Millimetres.  10 mm = 1 cm.</p>
</dd>
<dt><code>"points"</code></dt><dd><p>Points.  72.27 pt = 1 in.</p>
</dd>
<dt><code>"picas"</code></dt><dd><p>Picas.  1 <abbr>pc</abbr> = 12 pt.</p>
</dd>
<dt><code>"bigpts"</code></dt><dd><p>Big Points.  72 <abbr>bp</abbr> = 1 in.</p>
</dd>
<dt><code>"dida"</code></dt><dd><p>Dida.  1157 dd = 1238 pt.</p>
</dd>
<dt><code>"cicero"</code></dt><dd><p>Cicero.  1 cc = 12 dd.</p>
</dd>
<dt><code>"scaledpts"</code></dt><dd><p>Scaled Points.  65536 <abbr>sp</abbr> = 1 pt.</p>
</dd>
<dt><code>"lines"</code></dt><dd><p>Lines of text.  Locations and dimensions
are in terms of multiples of the default text size of the viewport
(as specified by the viewport's <code>fontsize</code> and <code>lineheight</code>).</p>
</dd>
<dt><code>"char"</code></dt><dd><p>Multiples of nominal font height of the
viewport (as specified by the viewport's <code>fontsize</code>).</p>
</dd>
<dt><code>"native"</code></dt><dd><p>Locations and dimensions are relative to
the viewport's <code>xscale</code> and <code>yscale</code>.</p>
</dd>
<dt><code>"snpc"</code></dt><dd><p>Square Normalised Parent Coordinates.
Same as Normalised Parent Coordinates, except gives the same answer for
horizontal and vertical locations/dimensions.  It uses the
<em>lesser</em> of <abbr>npc</abbr>-width and <abbr>npc</abbr>-height.  This is useful for making
things which are a proportion of the viewport, but have to be square
(or have a fixed aspect ratio).</p>
</dd>
<dt><code>"strwidth"</code></dt><dd><p>Multiples of the width of the string
specified in the <code>data</code> argument.  The font size is
determined by the pointsize of the viewport.</p>
</dd>
<dt><code>"strheight"</code></dt><dd><p>Multiples of the height of the string
specified in the <code>data</code> argument.  The font size is
determined by the pointsize of the viewport.</p>
</dd>
<dt><code>"grobwidth"</code></dt><dd><p>Multiples of the width of the grob
specified in the <code>data</code> argument.</p>
</dd>
<dt><code>"grobheight"</code></dt><dd><p>Multiples of the height of the grob
specified in the <code>data</code> argument.</p>
</dd>
</dl>

<p>A number of variations are also allowed for the most common units.
For example, it is possible to use <code>"in"</code> or <code>"inch"</code>
instead of <code>"inches"</code> and <code>"centimetre"</code> or
<code>"centimeter"</code> instead of <code>"cm"</code>.
</p>
<p>A special <code>units</code> value of <code>"null"</code> is also allowed,
but only makes sense when used in specifying widths of columns
or heights of rows in grid layouts (see <code><a href="#topic+grid.layout">grid.layout</a></code>).
</p>
<p>The <code>data</code> argument must be a list when the <code>unit.length()</code>
is greater than 1.  For example,
</p>
<pre>  unit(rep(1, 3), c("npc", "strwidth", "inches"),
  data = list(NULL, "my string", NULL))
</pre><p>.
</p>
<p>It is possible to subset unit objects in the normal way and to perform
subassignment (see the examples),
but a special function
<code>unit.c</code> is provided for combining unit objects.
</p>
<p>Certain arithmetic and summary operations are defined for
unit objects.  In particular, it is possible to add and subtract
unit objects (e.g., <code>unit(1, "npc") - unit(1, "inches")</code>),
and to specify the minimum or maximum of a list
of unit objects (e.g., <code>min(unit(0.5, "npc"), unit(1,
    "inches"))</code>).
</p>
<p>There is a <code>format</code> method for units, which should respond to
the arguments for the default <code>format</code> method, e.g.,
<code>digits</code> to control the number of significant digits
printed for numeric values.
</p>
<p>The <code>is.unit()</code> function is a convenience for checking whether
<code>x</code> inherits from the <code>"unit"</code> class.
</p>


<h3>Value</h3>

<p>An object of class <code>"unit"</code>.
</p>


<h3>WARNING</h3>

<p>There is a special function <code>unit.c</code> for concatenating
several unit objects.
</p>
<p>The <code>c</code> function will not give the right answer.
</p>
<p>There used to be <code>"mylines"</code>, <code>"mychar"</code>, <code>"mystrwidth"</code>,
<code>"mystrheight"</code> units.  These will still be accepted, but
work exactly the same as
<code>"lines"</code>, <code>"char"</code>, <code>"strwidth"</code>,
<code>"strheight"</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit.c">unit.c</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unit(1, "npc")
unit(1:3/4, "npc")
unit(1:3/4, "npc") + unit(1, "inches")
min(unit(0.5, "npc"), unit(1, "inches"))
unit.c(unit(0.5, "npc"), unit(2, "inches") + unit(1:3/4, "npc"),
       unit(1, "strwidth", "hi there"))
x &lt;- unit(1:5, "npc")
x[2:4]
x[2:4] &lt;- unit(1, "mm")
x
</code></pre>

<hr>
<h2 id='unit.c'>Combine Unit Objects</h2><span id='topic+unit.c'></span>

<h3>Description</h3>

<p>This function produces a new unit object by combining the
unit objects specified as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit.c(..., check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit.c_+3A_...">...</code></td>
<td>
<p>An arbitrary number of unit objects.</p>
</td></tr>
<tr><td><code id="unit.c_+3A_check">check</code></td>
<td>
<p>Should input be checked? If you are certain all arguments are unit objects this can be set to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>unit</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit">unit</a></code>.
</p>

<hr>
<h2 id='unit.length'>Length of a Unit Object</h2><span id='topic+unit.length'></span>

<h3>Description</h3>

<p>The length of a unit object is defined as the number of unit
values in the unit object.
</p>
<p>This function has been deprecated in favour of a unit method for
the generic <code>length</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit.length(unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit.length_+3A_unit">unit</code></td>
<td>
<p>A unit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer value.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit">unit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>length(unit(1:3, "npc"))
length(unit(1:3, "npc") + unit(1, "inches"))
length(max(unit(1:3, "npc") + unit(1, "inches")))
length(max(unit(1:3, "npc") + unit(1, "strwidth", "a"))*4)
length(unit(1:3, "npc") + unit(1, "strwidth", "a")*4)
</code></pre>

<hr>
<h2 id='unit.pmin'> Parallel Unit Minima and Maxima </h2><span id='topic+unit.pmin'></span><span id='topic+unit.pmax'></span><span id='topic+unit.psum'></span>

<h3>Description</h3>

<p>Returns a unit object whose i-th value is the minimum (or maximum)
of the i-th values of the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit.pmin(...)
unit.pmax(...)
unit.psum(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit.pmin_+3A_...">...</code></td>
<td>
<p> One or more unit objects. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the result is the maximum of the lengths of the
arguments;  shorter arguments are recycled in the usual manner.
</p>


<h3>Value</h3>

<p>A unit object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>Examples</h3>

<pre><code class='language-R'>max(unit(1:3, "cm"), unit(0.5, "npc"))
unit.pmax(unit(1:3, "cm"), unit(0.5, "npc"))
</code></pre>

<hr>
<h2 id='unit.rep'> Replicate Elements of Unit Objects </h2><span id='topic+unit.rep'></span>

<h3>Description</h3>

<p>Replicates the units according to the values given in <code>times</code> and
<code>length.out</code>.
</p>
<p>This function has been deprecated in favour of a unit method for
the generic <code>rep</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit.rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit.rep_+3A_x">x</code></td>
<td>
<p> An object of class <code>"unit"</code>. </p>
</td></tr>
<tr><td><code id="unit.rep_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="base.html#topic+rep">rep</a></code> such as
<code>times</code> and <code>length.out</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"unit"</code>.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rep(unit(1:3, "npc"), 3)
rep(unit(1:3, "npc"), 1:3)
rep(unit(1:3, "npc") + unit(1, "inches"), 3)
rep(max(unit(1:3, "npc") + unit(1, "inches")), 3)
rep(max(unit(1:3, "npc") + unit(1, "strwidth", "a"))*4, 3)
rep(unit(1:3, "npc") + unit(1, "strwidth", "a")*4, 3)
</code></pre>

<hr>
<h2 id='unitType'>Return the Units of a Unit Object</h2><span id='topic+unitType'></span>

<h3>Description</h3>

<p>This function returns the units of a unit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitType(x, recurse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitType_+3A_x">x</code></td>
<td>
<p>A unit object.</p>
</td></tr>
<tr><td><code id="unitType_+3A_recurse">recurse</code></td>
<td>
<p>Whether to recurse into complex units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For simple units, this will be just a vector of coordinate systems,
like <code>"inches"</code> or <code>"npc"</code>.
</p>
<p>More complex units that involve
an operation on units return
an operator, like <code>"sum"</code>, <code>"min"</code>, or <code>"max"</code>.
</p>
<p>When <code>recurse = TRUE</code>, the result is always a list and
more complex units generate sublists (see the Examples below).
</p>


<h3>Author(s)</h3>

<p>Thomas Lin Pedersen and Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+unit">unit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- unit(1:5, c("cm", "mm", "in", "pt", "null"))

unitType(u)
unitType(unit(1, "npc"))
unitType(unit(1:3/4, "npc"))
unitType(unit(1:3/4, "npc") + unit(1, "inches"))
unitType(min(unit(0.5, "npc"), unit(1, "inches")))
unitType(unit.c(unit(0.5, "npc"), unit(2, "inches") + unit(1:3/4, "npc"),
                unit(1, "strwidth", "hi there")))
unitType(min(unit(1, "in"), unit(1, "npc") + unit(1, "mm")))

unitType(u, recurse=TRUE)
unitType(unit(1, "npc"), recurse=TRUE)
unitType(unit(1:3/4, "npc"), recurse=TRUE)
unitType(unit(1:3/4, "npc") + unit(1, "inches"), recurse=TRUE)
unitType(min(unit(0.5, "npc"), unit(1, "inches")), recurse=TRUE)
unitType(unit.c(unit(0.5, "npc"), unit(2, "inches") + unit(1:3/4, "npc"),
                unit(1, "strwidth", "hi there")), recurse=TRUE)
unitType(min(unit(1, "in"), unit(1, "npc") + unit(1, "mm")), recurse=TRUE)
unlist(unitType(min(unit(1, "in"), unit(1, "npc") + unit(1, "mm")),
                recurse=TRUE))
</code></pre>

<hr>
<h2 id='valid.just'>Validate a Justification</h2><span id='topic+valid.just'></span><span id='topic+resolveHJust'></span><span id='topic+resolveVJust'></span>

<h3>Description</h3>

<p>Utility functions for determining
whether a justification specification is valid
and for resolving a single justification value from
a combination of character and numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid.just(just)
resolveHJust(just, hjust) 
resolveVJust(just, vjust) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid.just_+3A_just">just</code></td>
<td>
<p>A justification either as a character value,
e.g., <code>"left"</code>, or as a numeric value, e.g., 0.</p>
</td></tr>
<tr><td><code id="valid.just_+3A_hjust">hjust</code></td>
<td>
<p>A numeric horizontal justification</p>
</td></tr>
<tr><td><code id="valid.just_+3A_vjust">vjust</code></td>
<td>
<p>A numeric vertical justification</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions may be useful within a <code>validDetails</code> method
when writing a new grob class.
</p>


<h3>Value</h3>

<p>A numeric representation of the justification (e.g.,
<code>"left"</code> becomes 0, <code>"right"</code> becomes 1, etc, ...).
An error is given if the justification is not valid.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>

<hr>
<h2 id='validDetails'> Customising grid grob Validation </h2><span id='topic+validDetails'></span>

<h3>Description</h3>

<p>This generic hook function is called whenever a grid grob is created
or
edited
via <code>grob</code>, <code>gTree</code>, <code>grid.edit</code> or <code>editGrob</code>.
This provides an opportunity for customising the validation of a
new class derived from grob (or gTree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validDetails(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validDetails_+3A_x">x</code></td>
<td>
<p> A grid grob. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>grob</code>, <code>gTree</code>,
<code>grid.edit</code> and <code>editGrob</code>.
A method should be written for classes derived from grob or gTree
to validate the values of slots specific to the new class.
(e.g., see <code>grid:::validDetails.axis</code>).
</p>
<p>Note that the standard slots for grobs and gTrees are automatically
validated (e.g., <code>vp</code>, <code>gp</code> slots for grobs and,
in addition, <code>children</code>, and <code>childrenvp</code> slots for
gTrees) so only slots specific to a new class need to be addressed.
</p>


<h3>Value</h3>

<p>The function MUST return the validated grob.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.edit">grid.edit</a></code> </p>

<hr>
<h2 id='viewportTransform'> Define a Group Transformation </h2><span id='topic+viewportTransform'></span><span id='topic+viewportTranslate'></span><span id='topic+viewportScale'></span><span id='topic+viewportRotate'></span><span id='topic+defnTranslate'></span><span id='topic+defnScale'></span><span id='topic+defnRotate'></span><span id='topic+useTranslate'></span><span id='topic+useScale'></span><span id='topic+useRotate'></span><span id='topic+groupTranslate'></span><span id='topic+groupScale'></span><span id='topic+groupRotate'></span><span id='topic+groupShear'></span><span id='topic+groupFlip'></span>

<h3>Description</h3>

<p>These functions define the transformation that will be applied
when a <code>grid.define()</code>d group is <code>grid.use()</code>d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewportTransform(group, shear=groupShear(), flip=groupFlip(), device=TRUE) 
viewportTranslate(group, device=TRUE)
viewportScale(group, device=TRUE)
viewportRotate(group, device=TRUE)
defnTranslate(group, inverse=FALSE, device=TRUE)
defnScale(group, inverse=FALSE)
defnRotate(group, inverse=FALSE, device=TRUE)
useTranslate(inverse=FALSE, device=TRUE)
useScale(inverse=FALSE)
useRotate(inverse=FALSE, device=TRUE)
groupTranslate(dx=0, dy=0)
groupRotate(r=0, device=TRUE)
groupScale(sx=1, sy=1)
groupShear(sx=0, sy=0)
groupFlip(flipX=FALSE, flipY=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewportTransform_+3A_group">group</code></td>
<td>
<p>The group that is being transformed.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_inverse">inverse</code></td>
<td>
<p>A logical indicating whether we want the
forward or backward transformation.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_shear">shear</code></td>
<td>
<p>An affine transformation matrix that describes
a shear transformation.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_flip">flip</code></td>
<td>
<p>An affine transformation matrix that describes
a scaling inversion.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_dx">dx</code>, <code id="viewportTransform_+3A_dy">dy</code></td>
<td>
<p>The translation to apply.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_r">r</code></td>
<td>
<p>The rotation to apply.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_sx">sx</code>, <code id="viewportTransform_+3A_sy">sy</code></td>
<td>
<p>The scaling (or shear) to apply.</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_flipx">flipX</code>, <code id="viewportTransform_+3A_flipy">flipY</code></td>
<td>
<p>Whether to negate the x-scaling or y-scaling
(logical).</p>
</td></tr>
<tr><td><code id="viewportTransform_+3A_device">device</code></td>
<td>
<p>A logical indicating whether transformation should be
relative to the device or relative to the current viewport.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>viewport*()</code> functions are not called directly.  They
are passed as the <code>transform</code> argument to
<code><a href="#topic+grid.use">grid.use</a></code>.
</p>
<p>The <code>defn*()</code> and <code>use*()</code> functions are also not called
directly, but can be useful to create custom transformation
functions.  For example, see the source code for
<code>viewportTransform</code>.
</p>
<p>The <code>group*()</code> functions generate basic affine transformation
matrices and may also be useful to create custom transformation
functions.  For example, the <code>groupShear()</code> function can be
used to specify a shear transform to <code>viewportTransform()</code>.
</p>
<p>It is also possible to define any function that returns a 3x3 matrix
(as long as the last column contains 0, 0, and 1)
and use it as the <code>transform</code> argument to
<code><a href="#topic+grid.use">grid.use</a></code>, but the results will probably be
device-dependent, and may be <em>very</em> difficult
to predict.  The function will be called with two arguments:
<code>group</code> and <code>device</code>.
</p>


<h3>Value</h3>

<p>An affine transformation matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><a href="#topic+Grid">Grid</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## NOTE: on devices without support for groups nothing will be drawn
grid.newpage()
## Define and use group in same viewport
pushViewport(viewport(width=.2, height=.2))
grid.define(circleGrob(gp=gpar(lwd=5)), name="circle")
grid.use("circle")
popViewport()
## Use group in viewport that is translated and scaled
pushViewport(viewport(x=.2, y=.2, width=.1, height=.1))
grid.use("circle")
popViewport()
## Use group in viewport that is translated and scaled
## BUT only make use of the translation
pushViewport(viewport(x=.2, y=.8, width=.1, height=.1))
grid.use("circle", transform=viewportTranslate)
popViewport()
## Use group in viewport that is translated and scaled
## unevenly (distorted)
pushViewport(viewport(x=.8, y=.7, width=.2, height=.4))
grid.use("circle")
popViewport()
</code></pre>

<hr>
<h2 id='vpPath'> Concatenate Viewport Names </h2><span id='topic+vpPath'></span>

<h3>Description</h3>

<p>This function can be used to generate a viewport path for use
in <code>downViewport</code> or <code>seekViewport</code>.
</p>
<p>A viewport path is a list of nested viewport names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vpPath(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vpPath_+3A_...">...</code></td>
<td>
<p> Character values which are viewport names. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Viewport names must only be unique amongst viewports which
share the same parent in the viewport tree.
</p>
<p>This function can be used to generate a specification for
a viewport that includes the viewport's parent's name
(and the name of its parent and so on).
</p>
<p>For interactive use, it is possible to directly specify
a path, but it is strongly recommended that this function
is used otherwise in case the path separator is changed
in future versions of grid.
</p>


<h3>Value</h3>

<p>A <code> vpPath </code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code>,
<code><a href="#topic+pushViewport">pushViewport</a></code>,
<code><a href="#topic+popViewport">popViewport</a></code>,
<code><a href="#topic+downViewport">downViewport</a></code>,
<code><a href="#topic+seekViewport">seekViewport</a></code>,
<code><a href="#topic+upViewport">upViewport</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vpPath("vp1", "vp2")
</code></pre>

<hr>
<h2 id='widthDetails'> Width and Height of a grid grob </h2><span id='topic+widthDetails'></span><span id='topic+heightDetails'></span><span id='topic+ascentDetails'></span><span id='topic+descentDetails'></span>

<h3>Description</h3>

<p>These generic functions are used to determine the size of grid grobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>widthDetails(x)
heightDetails(x)
ascentDetails(x)
descentDetails(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="widthDetails_+3A_x">x</code></td>
<td>
<p> A grid grob. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called in the calculation of
<code>"grobwidth"</code> and <code>"grobheight"</code> units.
Methods should be written for classes derived from grob or gTree
where the size of the grob can be determined (see, for example
<code>grid:::widthDetails.frame</code>).
</p>
<p>The ascent of a grob is the height of the grob by default and
the descent of a grob is zero by default, except for text grobs
where the label is a single character value or expression.
</p>


<h3>Value</h3>

<p>A unit object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+absolute.size">absolute.size</a></code>.
</p>

<hr>
<h2 id='Working+20with+20Viewports'>Maintaining and Navigating the Grid Viewport Tree</h2><span id='topic+pushViewport'></span><span id='topic+downViewport'></span><span id='topic+seekViewport'></span><span id='topic+popViewport'></span><span id='topic+upViewport'></span>

<h3>Description</h3>

<p>Grid maintains a tree of viewports &mdash; nested drawing
contexts.
</p>
<p>These functions provide ways to add or remove viewports
and to navigate amongst viewports in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushViewport(..., recording=TRUE)
popViewport(n = 1, recording=TRUE)
downViewport(name, strict=FALSE, recording=TRUE)
seekViewport(name, recording=TRUE)
upViewport(n = 1, recording=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Working+2B20with+2B20Viewports_+3A_...">...</code></td>
<td>
<p>One or more objects of class <code>"viewport"</code>.</p>
</td></tr>
<tr><td><code id="Working+2B20with+2B20Viewports_+3A_n">n</code></td>
<td>
<p>An integer value indicating how many viewports to
pop or navigate up.  The special value <code>0</code> indicates to
pop or navigate viewports right up to the root viewport.</p>
</td></tr>
<tr><td><code id="Working+2B20with+2B20Viewports_+3A_name">name</code></td>
<td>
<p>A character value to identify a viewport in the tree.</p>
</td></tr>
<tr><td><code id="Working+2B20with+2B20Viewports_+3A_strict">strict</code></td>
<td>
<p> A boolean indicating whether the vpPath must be
matched exactly. </p>
</td></tr>
<tr><td><code id="Working+2B20with+2B20Viewports_+3A_recording">recording</code></td>
<td>
<p>A logical value to indicate whether the viewport
operation should be recorded on the Grid display list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects created by the <code>viewport()</code> function are only
descriptions
of a drawing context.  A viewport object must be pushed onto the
viewport tree before it has any effect on drawing.
</p>
<p>The viewport tree always has a single root viewport (created by the
system) which corresponds to the entire device (and default
graphical parameter settings).  Viewports may be added to the tree
using <code>pushViewport()</code> and removed from the tree using
<code>popViewport()</code>.
</p>
<p>There is only ever one current viewport, which is the current
position within the viewport tree.  All drawing and
viewport operations are relative to the current viewport.
When a viewport is pushed it becomes the current viewport.
When a viewport is popped, the parent viewport becomes
the current viewport.  Use <code>upViewport</code> to navigate to the parent
of the current viewport, without removing the current viewport
from the viewport tree.  Use <code>downViewport</code> to navigate to
a viewport further down the viewport tree and <code>seekViewport</code>
to navigate to a viewport anywhere else in the tree.
</p>
<p>If a viewport is pushed and it has the same <code>name</code> as a
viewport at the same level in the tree, then it replaces the
existing viewport in the tree.
</p>


<h3>Value</h3>

<p><code>downViewport</code> returns the number of viewports it went down.
</p>
<p>This can be useful for returning to your starting point by doing
something like <code>depth &lt;- downViewport()</code> then
<code>upViewport(depth)</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewport">viewport</a></code> and <code><a href="#topic+vpPath">vpPath</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># push the same viewport several times
grid.newpage()
vp &lt;- viewport(width=0.5, height=0.5)
pushViewport(vp)
grid.rect(gp=gpar(col="blue"))
grid.text("Quarter of the device",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="blue"))
pushViewport(vp)
grid.rect(gp=gpar(col="red"))
grid.text("Quarter of the parent viewport",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="red"))
popViewport(2)
# push several viewports then navigate amongst them
grid.newpage()
grid.rect(gp=gpar(col="grey"))
grid.text("Top-level viewport",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="grey"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(width=0.8, height=0.7, name="A"))
grid.rect(gp=gpar(col="blue"))
grid.text("1. Push Viewport A",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="blue"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(x=0.1, width=0.3, height=0.6,
  just="left", name="B"))
grid.rect(gp=gpar(col="red"))
grid.text("2. Push Viewport B (in A)",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="red"))
if (interactive()) Sys.sleep(1.0)
upViewport(1)
grid.text("3. Up from B to A",
  y=unit(1, "npc") - unit(2, "lines"), gp=gpar(col="blue"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(x=0.5, width=0.4, height=0.8,
  just="left", name="C"))
grid.rect(gp=gpar(col="green"))
grid.text("4. Push Viewport C (in A)",
  y=unit(1, "npc") - unit(1, "lines"), gp=gpar(col="green"))
if (interactive()) Sys.sleep(1.0)
pushViewport(viewport(width=0.8, height=0.6, name="D"))
grid.rect()
grid.text("5. Push Viewport D (in C)",
  y=unit(1, "npc") - unit(1, "lines"))
if (interactive()) Sys.sleep(1.0)
upViewport(0)
grid.text("6. Up from D to top-level",
  y=unit(1, "npc") - unit(2, "lines"), gp=gpar(col="grey"))
if (interactive()) Sys.sleep(1.0)
downViewport("D")
grid.text("7. Down from top-level to D",
  y=unit(1, "npc") - unit(2, "lines"))
if (interactive()) Sys.sleep(1.0)
seekViewport("B")
grid.text("8. Seek from D to B",
  y=unit(1, "npc") - unit(2, "lines"), gp=gpar(col="red"))
pushViewport(viewport(width=0.9, height=0.5, name="A"))
grid.rect()
grid.text("9. Push Viewport A (in B)",
  y=unit(1, "npc") - unit(1, "lines"))
if (interactive()) Sys.sleep(1.0)
seekViewport("A")
grid.text("10. Seek from B to A (in ROOT)",
  y=unit(1, "npc") - unit(3, "lines"), gp=gpar(col="blue"))
if (interactive()) Sys.sleep(1.0)
seekViewport(vpPath("B", "A"))
grid.text("11. Seek from\nA (in ROOT)\nto A (in B)")
popViewport(0)
</code></pre>

<hr>
<h2 id='xDetails'> Boundary of a grid grob </h2><span id='topic+xDetails'></span><span id='topic+yDetails'></span>

<h3>Description</h3>

<p>These generic functions are used to determine a location
on the boundary of a grid grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xDetails(x, theta)
yDetails(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xDetails_+3A_x">x</code></td>
<td>
<p> A grid grob. </p>
</td></tr>
<tr><td><code id="xDetails_+3A_theta">theta</code></td>
<td>
<p> A numeric angle, in degrees, measured
anti-clockwise from the 3 o'clock <em>or</em> one of
the following character strings: <code>"north"</code>,
<code>"east"</code>, <code>"west"</code>, <code>"south"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location on the grob boundary is determined by taking
a line from the centre of the grob at the angle <code>theta</code>
and intersecting it with the convex hull of the grob
(for the basic
grob primitives, the centre is
determined as half way between the minimum and maximum values
in x and y directions).
</p>
<p>These functions are called in the calculation of
<code>"grobx"</code> and <code>"groby"</code> units as produced by
the <code>grobX</code> and <code>grobY</code> functions.
Methods should be written for classes derived from grob or gTree
where the boundary of the grob can be determined.
</p>


<h3>Value</h3>

<p>A unit object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

<p><code><a href="#topic+grobX">grobX</a></code>,
<code><a href="#topic+grobY">grobY</a></code>.
</p>

<hr>
<h2 id='xsplinePoints'>
Return the points that would be used to draw an xspline
(or a Bezier curve)
</h2><span id='topic+xsplinePoints'></span><span id='topic+bezierPoints'></span>

<h3>Description</h3>

<p>Rather than drawing an xspline (or Bezier curve), this function returns
the points that would be used to draw the series of line
segments for the xspline.  This may be useful to post-process
the xspline curve, for example, to clip the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xsplinePoints(x)
bezierPoints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xsplinePoints_+3A_x">x</code></td>
<td>

<p>An xspline grob, as produced by the <code>xsplineGrob()</code> function
(or a beziergrob, as produced by the <code>bezierGrob()</code> function).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The points returned by this function will only be relevant
for the drawing context in force when this function was called.
</p>


<h3>Value</h3>

<p>Depends on how many xsplines would be drawn.  If only one, then
a list with two components, named x and y, both of which are
unit objects (in inches).  If several xsplines would be drawn
then the result of this function is a list of lists.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xsplineGrob">xsplineGrob</a></code> and
<code><a href="#topic+bezierGrob">bezierGrob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid.newpage()
xsg &lt;- xsplineGrob(c(.1, .1, .9, .9), c(.1, .9, .9, .1), shape=1)
grid.draw(xsg)
trace &lt;- xsplinePoints(xsg)
grid.circle(trace$x, trace$y, default.units="inches", r=unit(.5, "mm"))

grid.newpage()
vp &lt;- viewport(width=.5)
xg &lt;- xsplineGrob(x=c(0, .2, .4, .2, .5, .7, .9, .7),
                  y=c(.5, 1, .5, 0, .5, 1, .5, 0),
                  id=rep(1:2, each=4),
                  shape=1,
                  vp=vp)
grid.draw(xg)
trace &lt;- xsplinePoints(xg)
pushViewport(vp)
invisible(lapply(trace, function(t) grid.lines(t$x, t$y, gp=gpar(col="red"))))
popViewport()

grid.newpage()
bg &lt;- bezierGrob(c(.2, .2, .8, .8), c(.2, .8, .8, .2))
grid.draw(bg)
trace &lt;- bezierPoints(bg)
grid.circle(trace$x, trace$y, default.units="inches", r=unit(.5, "mm"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
