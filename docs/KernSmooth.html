<!DOCTYPE html><html><head><title>Help for package KernSmooth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KernSmooth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bkde'>
<p>Compute a Binned Kernel Density Estimate</p></a></li>
<li><a href='#bkde2D'>
<p>Compute a 2D Binned Kernel Density Estimate</p></a></li>
<li><a href='#bkfe'>
<p>Compute a Binned Kernel Functional Estimate</p></a></li>
<li><a href='#dpih'>
<p>Select a Histogram Bin Width</p></a></li>
<li><a href='#dpik'>
<p>Select a Bandwidth for Kernel Density Estimation</p></a></li>
<li><a href='#dpill'>
<p>Select a Bandwidth for Local Linear Regression</p></a></li>
<li><a href='#locpoly'>
<p>Estimate Functions Using Local Polynomials</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Priority:</td>
<td>recommended</td>
</tr>
<tr>
<td>Version:</td>
<td>2.23-22</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-10</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Kernel Smoothing Supporting Wand &amp; Jones (1995)</td>
</tr>
<tr>
<td>Note:</td>
<td>Maintainers are not available to give advice on using a package
they did not author.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.5.0), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, carData</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for kernel smoothing (and density estimation)
  corresponding to the book: 
  Wand, M.P. and Jones, M.C. (1995) "Kernel Smoothing".</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-10 11:00:31 UTC; ripley</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Wand [aut],
  Cleve Moler [ctb] (LINPACK routines in src/d*),
  Brian Ripley [trl, cre, ctb] (R port and updates)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian Ripley &lt;ripley@stats.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-10 14:38:27 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-03-26 07:26:29 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='bkde'>
Compute a Binned Kernel Density Estimate
</h2><span id='topic+bkde'></span>

<h3>Description</h3>

<p>Returns x and y coordinates of the binned
kernel density estimate of the probability
density of the data.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkde(x, kernel = "normal", canonical = FALSE, bandwidth,
     gridsize = 401L, range.x, truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkde_+3A_x">x</code></td>
<td>

<p>numeric vector of observations from the distribution whose density is to
be estimated.  Missing values are not allowed.
</p>
</td></tr>
<tr><td><code id="bkde_+3A_bandwidth">bandwidth</code></td>
<td>

<p>the kernel bandwidth smoothing parameter.  Larger values of
<code>bandwidth</code> make smoother estimates, smaller values of
<code>bandwidth</code> make less smooth estimates.  The default is a bandwidth
computed from the variance of <code>x</code>, specifically the
&lsquo;oversmoothed bandwidth selector&rsquo; of Wand and Jones
(1995, page 61).
</p>
</td></tr>
<tr><td><code id="bkde_+3A_kernel">kernel</code></td>
<td>

<p>character string which determines the smoothing kernel.
<code>kernel</code> can be:
<code>"normal"</code> - the Gaussian density function (the default).
<code>"box"</code> - a rectangular box.
<code>"epanech"</code> - the centred beta(2,2) density.
<code>"biweight"</code> - the centred beta(3,3) density.
<code>"triweight"</code> - the centred beta(4,4) density.
This can be abbreviated to any unique abbreviation.
</p>
</td></tr>
<tr><td><code id="bkde_+3A_canonical">canonical</code></td>
<td>

<p>length-one logical vector: if <code>TRUE</code>, canonically scaled kernels are used.
</p>
</td></tr>
<tr><td><code id="bkde_+3A_gridsize">gridsize</code></td>
<td>

<p>the number of equally spaced points at which to estimate the density.
</p>
</td></tr>
<tr><td><code id="bkde_+3A_range.x">range.x</code></td>
<td>

<p>vector containing the minimum and maximum values of <code>x</code>
at which to compute the estimate.
The default is the minimum and maximum data values, extended by the
support of the kernel.
</p>
</td></tr>
<tr><td><code id="bkde_+3A_truncate">truncate</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, data with <code>x</code> values outside the
range specified by <code>range.x</code> are ignored.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This is the binned approximation to the ordinary kernel density estimate.
Linear binning is used to obtain the bin counts.  
For each <code>x</code> value in the sample, the kernel is
centered on that <code>x</code> and the heights of the kernel at each datapoint are summed.
This sum, after a normalization, is the corresponding <code>y</code> value in the output.
</p>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>vector of sorted <code>x</code> values at which the estimate was computed.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>vector of density estimates
at the corresponding <code>x</code>.
</p>
</td></tr></table>


<h3>Background</h3>

<p>Density estimation is a smoothing operation.
Inevitably there is a trade-off between bias in the estimate and the
estimate's variability: large bandwidths will produce smooth estimates that
may hide local features of the density; small bandwidths may introduce
spurious bumps into the estimate.
</p>


<h3>References</h3>

<p>Wand, M. P. and Jones, M. C. (1995).
<em>Kernel Smoothing.</em>
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>, <code><a href="#topic+dpik">dpik</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="stats.html#topic+ksmooth">ksmooth</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package="MASS")
x &lt;- geyser$duration
est &lt;- bkde(x, bandwidth=0.25)
plot(est, type="l")
</code></pre>

<hr>
<h2 id='bkde2D'>
Compute a 2D Binned Kernel Density Estimate
</h2><span id='topic+bkde2D'></span>

<h3>Description</h3>

<p>Returns the set of grid points in each coordinate direction,
and the matrix of density estimates over the mesh induced by
the grid points. The kernel is the standard bivariate normal
density. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkde2D(x, bandwidth, gridsize = c(51L, 51L), range.x, truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkde2D_+3A_x">x</code></td>
<td>

<p>a two-column numeric matrix containing the observations from the  
distribution whose density is to be estimated.
Missing values are not allowed.
</p>
</td></tr>
<tr><td><code id="bkde2D_+3A_bandwidth">bandwidth</code></td>
<td>

<p>numeric vector oflength 2, containing the bandwidth to be used in each coordinate
direction.
</p>
</td></tr>
<tr><td><code id="bkde2D_+3A_gridsize">gridsize</code></td>
<td>

<p>vector containing the number of equally spaced points in each direction
over which the density is to be estimated.
</p>
</td></tr>
<tr><td><code id="bkde2D_+3A_range.x">range.x</code></td>
<td>

<p>a list containing two vectors, where each vector 
contains the minimum and maximum values of <code>x</code>
at which to compute the estimate for each direction.
The default minimum in each direction is minimum
data value minus 1.5 times the bandwidth for
that direction. The default maximum is the maximum
data value plus 1.5 times the bandwidth for
that direction
</p>
</td></tr>
<tr><td><code id="bkde2D_+3A_truncate">truncate</code></td>
<td>

<p>logical flag: if TRUE, data with <code>x</code> values outside the
range specified by <code>range.x</code> are ignored.
</p>
</td></tr></table>


<h3>Value</h3>

<p>a list containing the following components:
</p>
<table>
<tr><td><code>x1</code></td>
<td>

<p>vector of values of the grid points in the first coordinate
direction at which the estimate was computed. 
</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>

<p>vector of values of the grid points in the second coordinate
direction at which the estimate was computed. 
</p>
</td></tr>
<tr><td><code>fhat</code></td>
<td>

<p>matrix of density estimates 
over the mesh induced by <code>x1</code> and <code>x2</code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This is the binned approximation to the 2D kernel density estimate.
Linear binning is used to obtain the bin counts and the
Fast Fourier Transform is used to perform the discrete convolutions.
For each <code>x1</code>,<code>x2</code> pair the bivariate Gaussian kernel is
centered on that location and the heights of the 
kernel, scaled by the bandwidths, at each datapoint are summed.
This sum, after a normalization, is the corresponding 
<code>fhat</code> value in the output.
</p>


<h3>References</h3>

<p>Wand, M. P. (1994).
Fast Computation of Multivariate Kernel Estimators.
<em>Journal of Computational and Graphical Statistics,</em>
<b>3</b>, 433-445.
</p>
<p>Wand, M. P. and Jones, M. C. (1995).
<em>Kernel Smoothing.</em>
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bkde">bkde</a></code>, <code><a href="stats.html#topic+density">density</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package="MASS")
x &lt;- cbind(geyser$duration, geyser$waiting)
est &lt;- bkde2D(x, bandwidth=c(0.7, 7))
contour(est$x1, est$x2, est$fhat)
persp(est$fhat)
</code></pre>

<hr>
<h2 id='bkfe'>
Compute a Binned Kernel Functional Estimate 
</h2><span id='topic+bkfe'></span>

<h3>Description</h3>

<p>Returns an estimate of a binned approximation to
the kernel estimate of the specified density functional. 
The kernel is the standard normal density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bkfe(x, drv, bandwidth, gridsize = 401L, range.x, binned = FALSE,
     truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bkfe_+3A_x">x</code></td>
<td>

<p>numeric vector of observations from the distribution whose density is to
be estimated.
Missing values are not allowed.
</p>
</td></tr>
<tr><td><code id="bkfe_+3A_drv">drv</code></td>
<td>

<p>order of derivative in the density functional. Must be a
non-negative even integer.
</p>
</td></tr>
<tr><td><code id="bkfe_+3A_bandwidth">bandwidth</code></td>
<td>

<p>the kernel bandwidth smoothing parameter.  Must be supplied.
</p>
</td></tr>
<tr><td><code id="bkfe_+3A_gridsize">gridsize</code></td>
<td>

<p>the number of equally-spaced points over which binning is
performed.
</p>
</td></tr>
<tr><td><code id="bkfe_+3A_range.x">range.x</code></td>
<td>

<p>vector containing the minimum and maximum values of <code>x</code>
at which to compute the estimate.
The default is the minimum and maximum data values, extended by the
support of the kernel.
</p>
</td></tr>
<tr><td><code id="bkfe_+3A_binned">binned</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, then <code>x</code> and <code>y</code> are taken to be grid counts
rather than raw data.
</p>
</td></tr>
<tr><td><code id="bkfe_+3A_truncate">truncate</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, data with <code>x</code> values outside the
range specified by <code>range.x</code> are ignored.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The density functional of order <code>drv</code> is the integral of the
product of the density and its <code>drv</code>th derivative. 
The kernel estimates
of such quantities are computed using a binned implementation,
and the kernel is the standard normal density.
</p>


<h3>Value</h3>

<p>the (scalar) estimated functional.
</p>


<h3>Background</h3>

<p>Estimates of this type were proposed by Sheather and
Jones (1991).
</p>


<h3>References</h3>

<p>Sheather, S. J. and Jones, M. C. (1991).
A reliable data-based bandwidth selection method for
kernel density estimation.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>53</b>, 683&ndash;690.
</p>
<p>Wand, M. P. and Jones, M. C. (1995).
<em>Kernel Smoothing.</em>
Chapman and Hall, London.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package="MASS")
x &lt;- geyser$duration
est &lt;- bkfe(x, drv=4, bandwidth=0.3)
</code></pre>

<hr>
<h2 id='dpih'>
Select a Histogram Bin Width 
</h2><span id='topic+dpih'></span>

<h3>Description</h3>

<p>Uses direct plug-in methodology to select the bin width of 
a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpih(x, scalest = "minim", level = 2L, gridsize = 401L, 
     range.x = range(x), truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpih_+3A_x">x</code></td>
<td>

<p>numeric vector containing the sample on which the
histogram is to be constructed.
</p>
</td></tr>
<tr><td><code id="dpih_+3A_scalest">scalest</code></td>
<td>

<p>estimate of scale.
</p>
<p><code>"stdev"</code> - standard deviation is used.
</p>
<p><code>"iqr"</code> - inter-quartile range divided by 1.349 is used.
</p>
<p><code>"minim"</code> - minimum of <code>"stdev"</code> and <code>"iqr"</code> is used.
</p>
</td></tr>
<tr><td><code id="dpih_+3A_level">level</code></td>
<td>

<p>number of levels of functional estimation used in the
plug-in rule.
</p>
</td></tr>
<tr><td><code id="dpih_+3A_gridsize">gridsize</code></td>
<td>

<p>number of grid points used in the binned approximations
to functional estimates.
</p>
</td></tr>
<tr><td><code id="dpih_+3A_range.x">range.x</code></td>
<td>

<p>range over which functional estimates are obtained.
The default is the minimum and maximum data values.
</p>
</td></tr>
<tr><td><code id="dpih_+3A_truncate">truncate</code></td>
<td>

<p>if <code>truncate</code> is <code>TRUE</code> then observations outside
of the interval specified by <code>range.x</code> are omitted.
Otherwise, they are used to weight the extreme grid points.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The direct plug-in approach, where unknown functionals
that appear in expressions for the asymptotically
optimal bin width and bandwidths
are replaced by kernel estimates, is used.
The normal distribution is used to provide an
initial estimate.
</p>


<h3>Value</h3>

<p>the selected bin width.
</p>


<h3>Background</h3>

<p>This method for selecting the bin width of a histogram is
described in Wand (1995). It is an extension of the
normal scale rule of Scott (1979) and uses plug-in ideas
from bandwidth selection for kernel density estimation
(e.g. Sheather and Jones, 1991).
</p>


<h3>References</h3>

<p>Scott, D. W. (1979). 
On optimal and data-based histograms.
<em>Biometrika</em>,
<b>66</b>, 605&ndash;610.
</p>
<p>Sheather, S. J. and Jones, M. C. (1991).
A reliable data-based bandwidth selection method for
kernel density estimation.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>53</b>, 683&ndash;690. 
</p>
<p>Wand, M. P. (1995).
Data-based choice of histogram binwidth.
<em>The American Statistician</em>, <b>51</b>, 59&ndash;64.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package="MASS")
x &lt;- geyser$duration
h &lt;- dpih(x)
bins &lt;- seq(min(x)-h, max(x)+h, by=h)
hist(x, breaks=bins)
</code></pre>

<hr>
<h2 id='dpik'>
Select a Bandwidth for Kernel Density Estimation
</h2><span id='topic+dpik'></span>

<h3>Description</h3>

<p>Use direct plug-in methodology to select the bandwidth
of a kernel density estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpik(x, scalest = "minim", level = 2L, kernel = "normal",   
     canonical = FALSE, gridsize = 401L, range.x = range(x), 
     truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpik_+3A_x">x</code></td>
<td>

<p>numeric vector containing the sample on which the
kernel density estimate is to be constructed.
</p>
</td></tr>
<tr><td><code id="dpik_+3A_scalest">scalest</code></td>
<td>

<p>estimate of scale.
</p>
<p><code>"stdev"</code> - standard deviation is used.
</p>
<p><code>"iqr"</code> - inter-quartile range divided by 1.349 is used.
</p>
<p><code>"minim"</code> - minimum of <code>"stdev"</code> and <code>"iqr"</code> is used.
</p>
</td></tr>
<tr><td><code id="dpik_+3A_level">level</code></td>
<td>

<p>number of levels of functional estimation used in the
plug-in rule.
</p>
</td></tr>
<tr><td><code id="dpik_+3A_kernel">kernel</code></td>
<td>

<p>character string which determines the smoothing kernel.
<code>kernel</code> can be:
<code>"normal"</code> - the Gaussian density function (the default).
<code>"box"</code> - a rectangular box.
<code>"epanech"</code> - the centred beta(2,2) density.
<code>"biweight"</code> - the centred beta(3,3) density.
<code>"triweight"</code> - the centred beta(4,4) density.
This can be abbreviated to any unique abbreviation.
</p>
</td></tr>
<tr><td><code id="dpik_+3A_canonical">canonical</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, canonically scaled kernels are used
</p>
</td></tr>
<tr><td><code id="dpik_+3A_gridsize">gridsize</code></td>
<td>

<p>the number of equally-spaced points over which binning is 
performed to obtain kernel functional approximation. 
</p>
</td></tr>
<tr><td><code id="dpik_+3A_range.x">range.x</code></td>
<td>

<p>vector containing the minimum and maximum values of <code>x</code>
at which to compute the estimate.
The default is the minimum and maximum data values.
</p>
</td></tr>
<tr><td><code id="dpik_+3A_truncate">truncate</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, data with <code>x</code> values outside the
range specified by <code>range.x</code> are ignored.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The direct plug-in approach, where unknown functionals
that appear in expressions for the asymptotically
optimal bandwidths
are replaced by kernel estimates, is used.
The normal distribution is used to provide an
initial estimate.
</p>


<h3>Value</h3>

<p>the selected bandwidth.
</p>


<h3>Background</h3>

<p>This method for selecting the bandwidth of a kernel
density estimate was proposed by Sheather and
Jones (1991)
and is
described in Section 3.6 of Wand and Jones (1995). 
</p>


<h3>References</h3>

<p>Sheather, S. J. and Jones, M. C. (1991).
A reliable data-based bandwidth selection method for
kernel density estimation.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>53</b>, 683&ndash;690.
</p>
<p>Wand, M. P. and Jones, M. C. (1995).
<em>Kernel Smoothing.</em>
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bkde">bkde</a></code>, <code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+ksmooth">ksmooth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package="MASS")
x &lt;- geyser$duration
h &lt;- dpik(x)
est &lt;- bkde(x, bandwidth=h)
plot(est,type="l")
</code></pre>

<hr>
<h2 id='dpill'>
Select a Bandwidth for Local Linear Regression
</h2><span id='topic+dpill'></span>

<h3>Description</h3>

<p>Use direct plug-in methodology to select the bandwidth
of a local linear Gaussian kernel regression estimate, as described
by Ruppert, Sheather and Wand (1995). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpill(x, y, blockmax = 5, divisor = 20, trim = 0.01, proptrun = 0.05, 
      gridsize = 401L, range.x, truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpill_+3A_x">x</code></td>
<td>

<p>numeric vector of x data.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_y">y</code></td>
<td>

<p>numeric vector of y data.
This must be same length as <code>x</code>, and
missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_blockmax">blockmax</code></td>
<td>

<p>the maximum number of blocks of the data for construction
of an initial parametric estimate. 
</p>
</td></tr>
<tr><td><code id="dpill_+3A_divisor">divisor</code></td>
<td>

<p>the value that the sample size is divided by to determine
a lower limit on the number of blocks of the data for
construction of an initial parametric estimate.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_trim">trim</code></td>
<td>

<p>the proportion of the sample trimmed from each end in the
<code>x</code> direction before application of the plug-in methodology.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_proptrun">proptrun</code></td>
<td>

<p>the proportion of the range of <code>x</code> at each end truncated in the
functional estimates.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_gridsize">gridsize</code></td>
<td>

<p>number of equally-spaced grid points over which the
function is to be estimated.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_range.x">range.x</code></td>
<td>

<p>vector containing the minimum and maximum values of <code>x</code> at which to
compute the estimate.
For density estimation the default is the minimum and maximum data values
with 5% of the range added to each end.
For regression estimation the default is the minimum and maximum data values.
</p>
</td></tr>
<tr><td><code id="dpill_+3A_truncate">truncate</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, data with <code>x</code> values outside the
range specified by <code>range.x</code> are ignored.
</p>
</td></tr></table>


<h3>Details</h3>

<p>The direct plug-in approach, where unknown functionals
that appear in expressions for the asymptotically
optimal bandwidths
are replaced by kernel estimates, is used.
The kernel is the standard normal density.
Least squares quartic fits over blocks of data are used to 
obtain an initial estimate. Mallow's <code class="reqn">C_p</code> is used to select
the number of blocks.
</p>


<h3>Value</h3>

<p>the selected bandwidth.
</p>


<h3>Warning</h3>

<p>If there are severe irregularities (i.e. outliers, sparse regions)
in the <code>x</code> values then the local polynomial smooths required for the
bandwidth selection algorithm may become degenerate and the function
will crash. Outliers in the <code>y</code> direction may lead to deterioration
of the quality of the selected bandwidth.
</p>


<h3>References</h3>

<p>Ruppert, D., Sheather, S. J. and Wand, M. P. (1995).
An effective bandwidth selector for local least squares
regression.
<em>Journal of the American Statistical Association</em>,
<b>90</b>, 1257&ndash;1270.
</p>
<p>Wand, M. P. and Jones, M. C. (1995).
<em>Kernel Smoothing.</em>
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ksmooth">ksmooth</a></code>, <code><a href="#topic+locpoly">locpoly</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package = "MASS")
x &lt;- geyser$duration
y &lt;- geyser$waiting
plot(x, y)
h &lt;- dpill(x, y)
fit &lt;- locpoly(x, y, bandwidth = h)
lines(fit)
</code></pre>

<hr>
<h2 id='locpoly'>
Estimate Functions Using Local Polynomials
</h2><span id='topic+locpoly'></span>

<h3>Description</h3>

<p>Estimates a probability density function,  
regression function or their derivatives
using local polynomials. A fast binned implementation
over an equally-spaced grid is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locpoly(x, y, drv = 0L, degree, kernel = "normal", 
        bandwidth, gridsize = 401L, bwdisc = 25, 
        range.x, binned = FALSE, truncate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locpoly_+3A_x">x</code></td>
<td>

<p>numeric vector of x data.
Missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_bandwidth">bandwidth</code></td>
<td>

<p>the kernel bandwidth smoothing parameter.
It may be a single number or an array having
length <code>gridsize</code>, representing a bandwidth
that varies according to the location of
estimation.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_y">y</code></td>
<td>

<p>vector of y data.
This must be same length as <code>x</code>, and
missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_drv">drv</code></td>
<td>

<p>order of derivative to be estimated.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_degree">degree</code></td>
<td>

<p>degree of local polynomial used. Its value
must be greater than or equal to the value
of <code>drv</code>. The default value is of <code>degree</code> is
<code>drv</code> + 1.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_kernel">kernel</code></td>
<td>

<p><code>"normal"</code> - the Gaussian density function.  Currently ignored.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_gridsize">gridsize</code></td>
<td>

<p>number of equally-spaced grid points over which the 
function is to be estimated.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_bwdisc">bwdisc</code></td>
<td>

<p>number of logarithmically-equally-spaced bandwidths
on which <code>bandwidth</code> is discretised, to speed up
computation.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_range.x">range.x</code></td>
<td>

<p>vector containing the minimum and maximum values of <code>x</code> at which to
compute the estimate.
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_binned">binned</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, then <code>x</code> and <code>y</code> are taken to be grid counts
rather than raw data. 
</p>
</td></tr>
<tr><td><code id="locpoly_+3A_truncate">truncate</code></td>
<td>

<p>logical flag: if <code>TRUE</code>, data with <code>x</code> values outside the range specified
by <code>range.x</code> are ignored.
</p>
</td></tr></table>


<h3>Value</h3>

<p>if <code>y</code> is specified, a local polynomial regression estimate of 
E[Y|X] (or its derivative) is computed.
If <code>y</code> is missing, a local polynomial estimate of the density
of <code>x</code> (or its derivative) is computed.
</p>
<p>a list containing the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>vector of sorted x values at which the estimate was computed.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>vector of smoothed estimates for either the density or the regression
at the corresponding <code>x</code>.
</p>
</td></tr></table>


<h3>Details</h3>

<p>Local polynomial fitting with a kernel weight is used to
estimate either a density, regression function or their
derivatives. In the case of density estimation, the 
data are binned and the local fitting procedure is applied to 
the bin counts. In either case, binned approximations over
an equally-spaced grid is used for fast computation. The
bandwidth may be either scalar or a vector of length
<code>gridsize</code>.
</p>


<h3>References</h3>

<p>Wand, M. P. and Jones, M. C. (1995).
<em>Kernel Smoothing.</em>
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bkde">bkde</a></code>, <code><a href="stats.html#topic+density">density</a></code>, <code><a href="#topic+dpill">dpill</a></code>,
<code><a href="stats.html#topic+ksmooth">ksmooth</a></code>, <code><a href="stats.html#topic+loess">loess</a></code>, <code><a href="stats.html#topic+smooth">smooth</a></code>,
<code><a href="stats.html#topic+supsmu">supsmu</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(geyser, package = "MASS")
# local linear density estimate
x &lt;- geyser$duration
est &lt;- locpoly(x, bandwidth = 0.25)
plot(est, type = "l")

# local linear regression estimate
y &lt;- geyser$waiting
plot(x, y)
fit &lt;- locpoly(x, y, bandwidth = 0.25)
lines(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
