<!DOCTYPE html><html><head><title>Help for package mra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mra-package'>
<p>MRA - Mark Recapture Analysis</p></a></li>
<li><a href='#dipper.data'><p>European Dipper data</p></a></li>
<li><a href='#F.3d.model.matrix'><p> 3-Dimensional capture-recapture model matrices</p></a></li>
<li><a href='#F.cjs.covars'><p> F.cjs.covars</p></a></li>
<li><a href='#F.cjs.estim'><p> F.cjs.estim - Cormack-Jolly-Seber estimation</p></a></li>
<li><a href='#F.cjs.gof'><p> F.cjs.gof</p></a></li>
<li><a href='#F.cjs.simulate'>
<p>F.cjs.simulate - Generation of capture histories that follow a CJS model.</p></a></li>
<li><a href='#F.cr.model.avg'><p> F.cr.model.avg - Model averaging of mark-recapture parameters.</p></a></li>
<li><a href='#F.cr.model.matrix'><p> Capture-Recapture model matrix</p></a></li>
<li><a href='#F.fit.table'><p> F.fit.table - Produce a summary table of model fit statistics.</p></a></li>
<li><a href='#F.huggins.estim'><p> F.huggins.estim - Estimation of Huggins closed</p>
population capture-recapture model.</a></li>
<li><a href='#F.sat.lik'><p> F.sat.lik</p></a></li>
<li><a href='#F.step.cjs'><p>F.step.cjs - Stepwise model selection for CJS models.</p></a></li>
<li><a href='#F.update.df'><p> F.update.df - Update degrees of freedom in a Cormack-Jolly-Seber fitted object</p></a></li>
<li><a href='#ivar'><p> Expand Individual-varying covariates in models</p></a></li>
<li><a href='#lines.cjs'><p> lines.cjs</p></a></li>
<li><a href='#mra.control'><p> mra.control - Control over MRA fitting process</p></a></li>
<li><a href='#plot.cjs'><p> Plot CJS Model</p></a></li>
<li><a href='#plot.nhat'><p> Plot size estimates</p></a></li>
<li><a href='#predict.cjs'><p> predict.cjs</p></a></li>
<li><a href='#print.cjs'><p> Print Cormack-Jolly-Seber (CJS) Models</p></a></li>
<li><a href='#print.hug'><p> Print Huggin's Model objects</p></a></li>
<li><a href='#print.nhat'><p> print.nhat</p></a></li>
<li><a href='#residuals.cjs'><p> Residuals for CJS Model</p></a></li>
<li><a href='#tvar'><p> Expand Time-varying covariates in models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mark-Recapture Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2.16.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-01-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Trent McDonald [cre, aut],
  Eric Regehr [ctb],
  Bryan Manly [ctb],
  Jeff Bromaghin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trent McDonald &lt;tmcdonald@west-inc.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Accomplishes mark-recapture analysis with covariates. Models available include the Cormack-Jolly-Seber open population (Cormack (1972) &lt;<a href="https://doi.org/10.2307%2F2556151">doi:10.2307/2556151</a>&gt;; Jolly (1965) &lt;<a href="https://doi.org/10.2307%2F2333826">doi:10.2307/2333826</a>&gt;; Seber (1965) &lt;<a href="https://doi.org/10.2307%2F2333827">doi:10.2307/2333827</a>&gt;) and Huggin's (1989) &lt;<a href="https://doi.org/10.2307%2F2336377">doi:10.2307/2336377</a>&gt; closed population. 
	Link functions include logit, sine, and hazard.  Model selection, model averaging, plot, and simulation routines included. Open population size by the Horvitz-Thompson (1959) &lt;<a href="https://doi.org/10.2307%2F2280784">doi:10.2307/2280784</a>&gt; estimator.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GNU General Public License]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tmcd82070/MRA/issues">https://github.com/tmcd82070/MRA/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-05 00:03:37 UTC; tmcdonald</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-05 13:48:51 UTC</td>
</tr>
</table>
<hr>
<h2 id='mra-package'>
MRA - Mark Recapture Analysis
</h2><span id='topic+mra-package'></span><span id='topic+mra'></span>

<h3>Description</h3>

<p><b>Description</b> - 
This package contains analysis functions, and associated routines, to conduct 
analyses of mark-recapture (capture-recapture) data using individual, 
time, and individual-time varying covariates. In general, these routines 
relate vectors of capture histories to vectors of covariates using 
a regression approach (Amstrup et al. 2005, Ch 9).  All capture, survival, 
transition, etc. parameters are functions of individual and time 
specific covariates, and the estimated parameters 
are coefficients in logistic-linear equations. 
</p>
<p><b>Relationship to MARK</b> - 
For the most part, these routines perform a subset of the analyses available in 
program MARK or via the MARK front-end package, RMark.  
The most significant difference between this package
and MARK is parameterization.  The parameterization used here
does not utilize triangular 
&quot;parameter information matrices&quot; (PIMs) as MARK (and RMark) does.  
Because of this, the &quot;design&quot; matrix utilized by 
this package is not parallel to the &quot;design&quot; matrix of program MARK.  For those new 
to mark-recapture analysis, this parameterization difference will be inconsequential.  
The approach taken here provides equivalent modeling flexibility, yet is 
easier to grasp and visualize, in our opinion. 
For those already familiar with the PIMs used 
by program MARK, it is helpful to view the &quot;PIMs&quot; of this package as 
rectangular matrices of the real parameters. I.e., the &quot;PIMs&quot; of this package are 
rectangular matrices where cell (i,j) contains the real parameter (capture or survival) 
for individual i at capture occasion j. 
</p>
<p>Analyses available here that are <em>not</em> included in program MARK include:
</p>

<ul>
<li><p> Estimation of population size from open population CJS models via 
the Horvitz-Thompson estimator. 
</p>
</li>
<li><p> Residuals, goodness of fit tests, and associated plots for assessing
model fit in open CJS models.
</p>
</li></ul>

<p><b>Future Research</b> - 
The author of MRA welcome interest in and routines that 
perform the 
following analyzes:
</p>

<ul>
<li><p> Continuous time models.  Especially those that allow inclusion of covariates.
</p>
</li>
<li><p> Band recovery models.
</p>
</li>
<li><p> Baysian models.
</p>
</li>
<li><p> Joint live-dead recovery models.
</p>
</li>
<li><p> MCMC methods or routines that can be applied to exiting models. 
</p>
</li>
<li><p> Plotting methods for exiting models.
</p>
</li>
<li><p> Model selection methods for existing models. 
</p>
</li>
<li><p> Simulation methods and routines.
</p>
</li></ul>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mra</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GNU General Public License</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Trent McDonald
</p>
<p>Maintainer: Trent McDonald &lt;tmcdonald@west-inc.com&gt;
</p>


<h3>References</h3>

<p>Amstrup, S.C., T.L. McDonald, and B.F.J. Manly. 2005. <em>Handbook of 
Capture-Recapture Analysis</em>, Princeton: Princeton University Press.
</p>

<hr>
<h2 id='dipper.data'>European Dipper data</h2><span id='topic+dipper.data'></span><span id='topic+dipper.males'></span><span id='topic+dipper.histories'></span>

<h3>Description</h3>

<p>Example capture-recapture data from a study of European dippers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dipper.data)</code></pre>


<h3>Format</h3>

<p>A data frame containing 294 capture histories and the sex designation of 
birds captured.  Capture indicators are either 0 = not captured, 1 = captured, or 
2 = captured but died and not released back into the population. Columns in the data frame are: 
</p>

<dl>
<dt><code>h1</code></dt><dd><p>a numeric vector indicating capture at occasion 1</p>
</dd>
<dt><code>h2</code></dt><dd><p>a numeric vector indicating capture at occasion 2</p>
</dd>
<dt><code>h3</code></dt><dd><p>a numeric vector indicating capture at occasion 3</p>
</dd>
<dt><code>h4</code></dt><dd><p>a numeric vector indicating capture at occasion 4</p>
</dd>
<dt><code>h5</code></dt><dd><p>a numeric vector indicating capture at occasion 5</p>
</dd>
<dt><code>h6</code></dt><dd><p>a numeric vector indicating capture at occasion 6</p>
</dd>
<dt><code>h7</code></dt><dd><p>a numeric vector indicating capture at occasion 7</p>
</dd>
<dt><code>males</code></dt><dd><p>a numeric vector indicating males. 1 = males, 0 = females</p>
</dd>
<dt><code>females</code></dt><dd><p>a numeric vector indicating females. 0 = males, 1 = females</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a popular capture-recapture example data set. It has been analyzed by Lebreton et al. (1992)
Amstrup et al. (2005) and others.   
</p>
<p><code>dipper.males</code> is a vector indicating male birds.  I.e., <code>dipper.males &lt;- dipper.data\$males</code>
</p>
<p><code>dipper.histories</code> is a matrix of just the capture history columns <code>h1 - h7</code>, extracted 
from <code>dipper.data</code> and made into a matrix. This matrix can be fed directly into 
one of the estimation routines, such as <code>F.cjs.estim</code>.
</p>
<p><b>To access</b>: After loading the MRA library (with <code>library(mra)</code>) you must
execute <code>data(dipper.data)</code>, <code>data(dipper.data)</code>, or <code>data(dipper.males)</code>   
to get access to these data frames.  They are not attached when the library is loaded. 
</p>


<h3>Source</h3>

<p>Amstrup, S. C., McDonald, T. L., and Manly, B. F. J. 2005. Handbook of Capture-Recapture Analysis. 
Princeton University Press. [Chapter 9 has several examples 
that use this data.] 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dipper.data)
</code></pre>

<hr>
<h2 id='F.3d.model.matrix'> 3-Dimensional capture-recapture model matrices </h2><span id='topic+F.3d.model.matrix'></span>

<h3>Description</h3>

<p>Returns a 3D model matrix for capture-recapture modeling in the form
of a (giant) 2D matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.3d.model.matrix(formula, d1, d2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.3d.model.matrix_+3A_formula">formula</code></td>
<td>
<p> A formula object specifying covariates in a capture-recapture 
model.  Must not have a response, i.e., ~, followed by the names 
of 2-D arrays or 1-D vectors contained inside calls to <code>ivar</code> or 
<code>tvar</code>.  See <code>help(F.cjs.estim)</code> for examples. </p>
</td></tr>
<tr><td><code id="F.3d.model.matrix_+3A_d1">d1</code></td>
<td>
<p> Magnitude of dimension 1 of the returned matrix.  This is 
always number of rows in the returned matrix. Usually, <code>d1</code> = number 
of individuals = number of rows in capture history matrix. </p>
</td></tr>
<tr><td><code id="F.3d.model.matrix_+3A_d2">d2</code></td>
<td>
<p> Magnitude of dimension 2 of the returned matrix.  This is 
number of columns in the capture history matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is intended to be called internally by the routines
of MRA.  General users should never have to call this routine.
</p>
<p>This routine uses a call to <code>eval</code> with a model frame, and calls the
R internal <code>model.matrix</code> to
resolve the matrices in the formula. All matrices specified in the models
should be in the current scope and accessible to both <code>eval</code> and <code>model.matrix</code>.
</p>
<p>See <code>help(F.cjs.estim)</code> for examples of ways to specify models. 
</p>


<h3>Value</h3>

<p>A (giant) 2-d matrix containing covariate values suitable for passing to 
the Fortran code that does the estimation for MRA.  This matrix has all the 
2-d matrices of the model <code>cbind</code>-ed together.  It's dimension is NAN x 
NS*(number of coefficients).  A convenient way to view the matrix is to assign 
a 3-d dimension.  I.e., if <code>x</code> is the result of a call to this function 
and there are NX coefficients in the model, 
then <code> dim(x) &lt;- c(NAN,NS,NX) </code> makes a 3-d matrix with NAN rows, NS columns, 
and NX pages. View the covariates for a single animal with <code>x[3,,]</code> or similar
statement. 
</p>
<p>Names of variables in the model are returned as attribute &quot;variables&quot;.  Whether 
the model has an intercept is returned as attribute &quot;intercept&quot;. 
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cr.model.matrix">F.cr.model.matrix</a></code>, <code><a href="#topic+tvar">tvar</a></code>, <code><a href="#topic+ivar">ivar</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="base.html#topic+eval">eval</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Synthetic example with 10 animals and 5 occasions
nan &lt;- 10
ns &lt;- 5
sex &lt;- as.factor(as.numeric(runif( nan ) &gt; 0.5))
attr(sex,"ns") &lt;- ns
x &lt;- matrix( runif( nan*ns ) , nrow=nan, ncol=ns )
F.3d.model.matrix( ~ ivar(sex) + x, nan, ns )


</code></pre>

<hr>
<h2 id='F.cjs.covars'> F.cjs.covars </h2><span id='topic+F.cjs.covars'></span>

<h3>Description</h3>

<p>Return an x and y 3-D array for estimation of 
a traditional time-variant Cormack-Jolly-Seber capture-recapture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.cjs.covars(nan, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.cjs.covars_+3A_nan">nan</code></td>
<td>
<p>Number of individuals/animals. </p>
</td></tr>
<tr><td><code id="F.cjs.covars_+3A_ns">ns</code></td>
<td>
<p>Number of trap/mark occasions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pages from <code>\$x</code> are designed to useful 
for fitting classical CJS models with time-variant, but individual-invariant effects. 
To fit a CJS model using this function, the commands would be 
something like: 
</p>
<p><code>tmp&lt;-F.cjs.covars(nan,ns);F.cjs.estim(capture=~tmp\$x[,,2]+tmp\$x[,,3]+ ..., survival=
~tmp\$x[,,1]+tmp\$x[,,2]+ ..., histories=my.histories)</code>
</p>


<h3>Value</h3>

<p>A list containing a single component, <code>\$x</code>, that can be used to 
estimate a classical CJS model when included in a subsequent call to 
<code>F.cjs.estim</code>. The returned component, <code>\$x</code>,
is a 3-D array containing 0's everywhere, except for 1's in certain columns.
<code>\$x</code> has dimension <code>nan</code> X <code>ns</code> X <code>ns</code>.
Element [i,j,k] of <code>\$x</code> is 1 if j == k, and 0 otherwise.  I.e., the k-th &quot;page&quot; of 
the 3-D array has 1's in the k-th column, 0's elsewhere.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST Inc., tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##  Fit CJS model to dipper data, time-varying capture and survivals.
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
dipper.cjs &lt;- F.cjs.estim( capture=~xy$x[,,2]+xy$x[,,3]+xy$x[,,4]+xy$x[,,5]+xy$x[,,6], 
	survival=~xy$x[,,1]+xy$x[,,2]+xy$x[,,3]+xy$x[,,4]+xy$x[,,5], dipper.histories )
print(dipper.cjs)

</code></pre>

<hr>
<h2 id='F.cjs.estim'> F.cjs.estim - Cormack-Jolly-Seber estimation </h2><span id='topic+F.cjs.estim'></span><span id='topic+cr.estim'></span><span id='topic+CJS'></span><span id='topic+cjs'></span><span id='topic+Cormack'></span><span id='topic+Jolly'></span><span id='topic+Seber'></span>

<h3>Description</h3>

<p>Estimates Cormack-Jolly-Seber (CJS) capture-recapture models with individual, time, and
individual-time varying covariates using the &quot;regression&quot; parametrization of 
Amstrup et al (2005, Ch 9). For live recaptures only. Losses on capture allowed.
Uses a logistic link function to relate probability of capture and survival 
to external covariates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.cjs.estim(capture, survival, histories, cap.init, sur.init, group,  nhat.v.meth = 1, 
c.hat = -1, df = NA, intervals=rep(1,ncol(histories)-1), conf=0.95, 
link="logit", control=mra.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.cjs.estim_+3A_capture">capture</code></td>
<td>
<p> Formula specifying the capture probability model.  Must be a formula object with 
no response. I.e.,  &quot;~&quot; followed by the names of 2-D arrays of covariates to fit in the capture model. 
For example: 'capture = ~ age + sex', where age and sex are matrices of size NAN X NS 
containing the age and sex covariate values.  NAN = number of animals = number of rows in 
<code>histories</code> matrix (see below).  NS = number of samples = number of columns in histories
matrix (see below). Number of matrices specified in the capture model is assumed to be NX. Time 
varying and individual varying vectors are fitted using <code>ivar()</code> and <code>tvar()</code> (see Details).
Factors are allowed within <code>ivar()</code> and <code>tvar()</code>. </p>
</td></tr>  
<tr><td><code id="F.cjs.estim_+3A_survival">survival</code></td>
<td>
<p> Formula specifying the survival probability model.  Must be a formula object with 
no response. I.e., &quot;~&quot; followed by the names of 2-D arrays of covariates to fit in the survival model. 
For example: 'survival = ~ year + ageclass' where year and ageclass are matrices of size NAN X NS 
containing year and ageclass covariate values.  Number of matrices specified in the survival 
model is assumed to be NY. 
Time varying and individual varying vectors are fitted using <code>ivar()</code> and <code>tvar()</code> 
(see Details). Factors are allowed within <code>ivar()</code> and <code>tvar()</code>.  </p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_histories">histories</code></td>
<td>
<p> A NAN X NS = (number of animals) X (number of capture occasions) matrix 
containing capture histories.  Capture histories are comprised of 0's, 1',s and 2's. 
0 in cell (i,j) means animal i was not captured on occasion j, 1 in cell (i,j) means animal 
i was captured on occasion j and released live back into the population, 2 in cell (i,j) means 
animal i was captured on occasion j and was not released back into the population (e.g., it died).
Animals with '2' as the last non-zero entry of their history are considered 'censored'. Their 
lack of capture information  
is removed from the likelihood after the occasion with the 2. Rows of all zeros (i.e., no captures) are allowed
in the history matrix, but do not affect coefficient or population size estimates.  A warning is thrown 
if rows of all zeros exist.  Capture and survival probabilities are 
computed for animals with all zero histories.  In this way, it is possible to have the routine 
compute capture or survival estimates for combinations of covariates that do not exist in the data
by associating the covariate combinations with histories that have all zero entries.</p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_cap.init">cap.init</code></td>
<td>
<p> (optional) Vector of initial values for coefficients in the capture model.  One element 
per covariate in <code>capture</code>. The default value usually works. </p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_sur.init">sur.init</code></td>
<td>
<p> (optional) Vector or initial values for coefficients in the survival model.  One element 
per covariate in <code>survival</code>. The default value usually works. </p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_group">group</code></td>
<td>
<p> (optional) A vector of length NAN giving the (non-changing) group membership of every 
captured animal (e.g., sex). Group is used only for computing TEST 2 and TEST 3. 
TEST 2 and TEST 3 are computed separately for each group. E.g., if group=sex, 
TEST 2 and TEST 3 are computed for each sex. TEST 2 and TEST3 are used only
to estimate C-hat. See <code>c.hat</code> for pooling rules for these 
test components to estimate C-hat.</p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_nhat.v.meth">nhat.v.meth</code></td>
<td>
<p> Integer specifying method for computing variance estimates 
of population size estimates. <code>nhat.v.meth</code> = 1 uses the variance estimator of 
Taylor et al. 2002, Ursus, p. 188 which is the so-called Huggins variance estimator, and incorporates 
covariances.  <code>nhat.v.meth</code> = 2 uses the variance estimator of Amstrup et al. 
2005 (p. 244, Eqn. 9.10), which is the same variance estimator as <code>nhat.v.meth</code> = 1 
with more 2nd order approximation terms included.  Method 2 should provide better variances 
than method 1, especially if the coefficient of variation of capture probabilities 
are &gt;1.0, but method 2 has not been studied as much as method 1. 
<code>nhat.v.meth</code> = 3 uses the variance estimator of McDonald and Amstrup, 1999, JABES, which is a 1st order approximation
that does not incorporate covariances. Method 3 is much faster than methods 1 and 2 
and could be easily calculated by hand, but 
should only be used when there is little capture heterogeneity. </p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_c.hat">c.hat</code></td>
<td>
<p> External (override) estimate of variance inflation factor (<code>c.hat</code>) to use
during estimation.  If input value of <code>c.hat</code> is &lt;= 0, MRA computes 
an estimate of variance inflation based on TEST 2 and TEST 3
applied to groups (if called for, see <code>group</code> above) 
using Manly, McDonald, and McDonald, 1993, rules for pooling. I.e., 
all cells in each TEST 2 or TEST 3 Chi-square component table must be 
&gt;= 5 before that component contributes to the estimate of C-hat.   This rules is  
slightly different than program MARK's pooling rules, so MRA's and MARK's
estimates of <code>c.hat</code> will generally be different.  If the input <code>c.hat</code> &gt; 0, 
MRA does not estimate C.hat, and uses the supplied value. </p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_df">df</code></td>
<td>
<p> External (override) model degrees of freedom to use during estimation.  
If <code>df</code> == NA, the number of parameters is estimated from the rank of the 
matrix of 2nd derivatives or Hessian, depending on <code>cov.meth</code> parameter.  
If <code>df</code> &lt;= 0, the number of parameters will be 
set to NX+NY = the number of estimated coefficients. Otherwise, if <code>df</code> &gt; 0, 
the supplied value is used.  Only AIC, QAIC, AICc, and QAICc are dependent on 
this value (in their penalty terms). </p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_intervals">intervals</code></td>
<td>
<p>Time intervals.  This is a vector of length <code>ncol(histories)-1</code> (i.e., 
number of capture occasions minus 1) specifying relative time intervals between occasions. 
For example, if capture occasions occurred in 1999, 2000, 2005, and 2007 <code>intervals</code> would 
be set to <code>c(1,5,2)</code>.  Estimates of survival are adjusted for time intervals between 
occasions assuming an exponential lifetime model, i.e., probability of surviving 
from occasion <code>j</code> to occasion <code>j+1</code> is <code>Phi(j)^(jth interval length)</code>, and 
it is the <code>Phi(j)</code>'s that are related to covariates through the survival model.  In 
other words, all survival estimates are for an interval of length 1.  If an interval 
of 1 is one year, then all survival estimates will be annual survival, with probability 
of surviving 2 years equal to annual survival squared, probability of surviving 3 years 
equal to annual survival cubed, etc.</p>
</td></tr>    
<tr><td><code id="F.cjs.estim_+3A_conf">conf</code></td>
<td>
<p>Confidence level for the confidence intervals placed around estimates 
of population size. Default 95% confidence.</p>
</td></tr>
<tr><td><code id="F.cjs.estim_+3A_link">link</code></td>
<td>
<p>The link function to be used.  The link function converts linear predictors in the 
range (-infinity, infinity) to probabilities in the range (0,1).  Valid values for the link 
function are &quot;logit&quot; (default), &quot;sine&quot;, and &quot;hazard&quot;.  (see Examples for a plot of the link functions)
</p>

<ul>
<li><p> The &quot;logit&quot; link is <code class="reqn">\eta = log( \frac{p}{1 - p} )</code> with 
inverse <code class="reqn">p = \frac{1}{1 + exp(-\eta)}</code>.  
</p>
</li>
<li><p> The &quot;sine&quot; link is <code class="reqn">\eta = \frac{8asin( 2p - 1 )}{\pi}</code>, which ranges from -4 to 4. 
The inverse &quot;sine&quot; link is <code class="reqn">p = \frac{1 + sin( \eta\pi/8 )}{2}</code> for 
values of <code class="reqn">\eta</code> between 
-4 and 4.  For values of <code class="reqn">\eta</code> &lt; -4, <code class="reqn">p</code> = 0.  For values of  <code class="reqn">\eta</code> &gt; 4, <code class="reqn">p</code> = 1.
Scaling of the sine link was chosen to yield coefficients roughly the 
same magnitude as the logit link.
</p>
</li>
<li><p> The &quot;hazard&quot; link is <code class="reqn">\eta = log( -log( 1 - p ))</code>, with inverse 
<code class="reqn">1 - exp( -exp( \eta ))</code>.  The value of <code class="reqn">p</code> from the inverse hazard 
link approaches 0 as <code class="reqn">\eta</code> decreases.  For values of <code class="reqn">\eta</code> &gt; 3, <code class="reqn">p</code> = 1 
for all intents and purposes. 
</p>
</li></ul>

</td></tr> 
<tr><td><code id="F.cjs.estim_+3A_control">control</code></td>
<td>
<p>A list containing named control parameters for the minimization and estimation process. 
Control parameters include number of iterations, covariance estimation method, etc.  
Although the default values work in the vast majority of cases, changes to these 
variables can effect speed and performance for ill-behaved models. See 
<code>mra.control()</code> for a description of the individual control parameters.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This is the work-horse routine for estimating CJS models. It compiles all the 
covariate matrices, then calls a Fortran routine to maximize the CJS likelihood 
and perform goodness-of-fit tests.  Horvitz-Thompson-type population size estimates 
are also computed by default. 
</p>
<p>If <code>control=mra.control(trace=1)</code>, a log file, named <code>mra.log</code>, is written to the current directory.  This file contains
additional details, such as individual Test 2 and Test 3 components, in a semi-friendly 
format.  This file is overwritten each run.  See <code>help(mra.control)</code> for more details. 
</p>
<p><b>Model Specification:</b> Both the <code>capture</code> and <code>survival</code> model can be 
specified as any combination of 2-d matrices (time and individual varying covariates), 
1-d time varying vectors, 1-d individual 
varying vectors, 1-d time varying factors, and 1-d individual varying factors. 
</p>
<p>Specification of time or individual varying effects uses the 
<code>tvar</code> (for 'time varying') and <code>ivar</code> (for 'individual varying') functions. 
These functions expand covariate vectors along the appropriate dimension to 
be 2-d matrices suitable for fitting in the model.  <code>ivar</code> expands 
an individual varying vector to all occasions.  <code>tvar</code> expands a time 
varying covariate to all individuals.  To do the expansion, both <code>tvar</code> 
and <code>ivar</code> need to know the size of the 'other' dimension. Thus, <code>tvar(x,100)</code>
specifies a 2-d matrix with size <code>100</code> by <code>length(x)</code>. 
<code>ivar(x,100)</code>
specifies a 2-d matrix with size <code>length(x)</code> by <code>100</code>. 
</p>
<p>For convenience, the 'other' dimension of time or individual varying covariates 
can be specified as an attribute of the vector.  Assuming <code>x</code> 
is a NS vector and the 'nan' attribute of <code>x</code> has been set as
<code>attr(x,"nan") &lt;- NAN</code>, <code>tvar(x,NAN)</code> and 
<code> tvar(x) </code> are equivalent. Same, but vise-versa, for individual varying 
covariates (i.e., 
assign the number of occasions using <code>attr(x,"ns")&lt;-NS</code>).  This saves 
some typing in model specification.
</p>
<p>Factors are allowed in <code>ivar</code> and <code>tvar</code>.  When a factor is specified, 
the <code>contr.treatment</code> coding is used.  By default, an intercept 
is assumed and the first level of all 
factors are dropped from the model (i.e., first levels are the reference levels, 
the default R action).  However, there are applications where more than one level 
will need to be dropped, and the user has control over this via the <code>drop.levels</code>
argument to <code>ivar</code> and <code>tvar</code>.  For example, 
<code>tvar(x,drop.levels=c(1,2))</code> drops the first 2 levels of factor x.  
<code>tvar(x,drop.levels=length(levels(x)))</code> does the SAS thing and drops 
the last level of factor <code>x</code>.  If <code>drop.levels</code> is outside the range 
[1,<code>length(levels(x))</code>] (e.g., negative or 0), no levels of the factor 
are dropped.  If no intercept is fitted in the model, this results in the 
so-called cell means coding for factors. 
</p>
<p>Example model specifications:  Assume 'age' is a NAN x NS 2-d matrix of ages, 
'effort' is a size NS 1-d vector of efforts, and 'sex' is a size NAN 1-d factor 
of sex designations ('M' and 'F'). 
</p>

<ol>
<li><p> capture= ~ 1 : constant effect over all individuals and time (intercept only model)
</p>
</li>
<li><p> capture= ~ age  : Intercept plus age 
</p>
</li>
<li><p> capture= ~ age + tvar(effort,NAN) : Intercept plus age plus effort
</p>
</li>
<li><p> capture= ~ age + tvar(effort,NAN) + ivar(sex,NS) : Intercept plus age plus effort plus sex. 
Females (1st level) are the reference.
</p>
</li>
<li><p> capture= ~ -1 + ivar(sex,NS,0) : sex as a factor, cell means coding
</p>
</li>
<li><p> capture= ~ tvar(as.factor(1:ncol(histories)),nrow(histories),c(1,2)) : time varying effects
</p>
</li></ol>

<p><b>Values in 2-d Matrix Covariates:</b> Even though covariate matrices are required to 
be NAN x NS (same size as capture histories), there are not that many parameters.
The first capture probability cannot be estimated in CJS models, and the NS-th survival 
parameter does not exist.  When a covariate matrix appears in the <em>capture</em> model,
only values in columns 2:ncol(histories) are used.  When a covariate matrix appears in 
the <em>survival</em> model, only values in columns 1:(ncol(histories)-1) are used. 
See examples for demonstration.
</p>


<h3>Value</h3>

<p>An object (list) of class c(&quot;cjs&quot;,&quot;cr&quot;) with many components.  Use <code>print.cr</code> to print 
it nicely. Use <code>names(fit)</code>, where the call was <code>fit &lt;- F.cr.estim(...)</code>, 
to see names of all returned components. To see values of individual components, 
issue commands like fit$s.hat, fit$se.s.hat, fit$n.hat, etc. 
</p>
<p>Components of the returned object are as follows:
</p>
<table>
<tr><td><code>histories</code></td>
<td>
<p>The input capture history matrix.</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>Auxiliary information about the fit, mostly stored input values. This is a list containing 
the following components:
</p>

<ul>
<li><p> call = original call
</p>
</li>
<li><p> nan = number of animals
</p>
</li>
<li><p> ns = number of samples = number of capture occasions
</p>
</li>
<li><p> nx = number of coefficients in capture model
</p>
</li>
<li><p> ny = number of coefficients in survival model
</p>
</li>
<li><p> cov.name = names of all coefficients
</p>
</li>
<li><p> ic.name = name of capture history matrix. 
</p>
</li>
<li><p> mra.version =	version number of MRA package used to estimate the model
</p>
</li>
<li><p> R.version = R version used for during estimation
</p>
</li>
<li><p> run.date = date the model was estimated.
</p>
</li></ul>

</td></tr>  
<tr><td><code>loglik</code></td>
<td>
<p>Maximized CJS likelihood value for the model</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Model deviance = -2*<code>loglik</code>.  This is relative deviance, see help for 
<code>F.sat.lik</code>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC for the model = <code>deviance</code> + 2*(df).  df is either the estimated number of independent 
parameters (by default), or NX+NY, or a specified value, depending on the input value of DF parameter.</p>
</td></tr>
<tr><td><code>qaic</code></td>
<td>
<p>QAIC (quasi-AIC) = (<code>deviance</code> / <code>vif</code>) + 2(df)</p>
</td></tr>
<tr><td><code>aicc</code></td>
<td>
<p>AIC with small sample correction = AIC + (2*<code>df</code>*(<code>df</code>+1)) / (<code>nan</code> - <code>df</code> - 1)</p>
</td></tr>
<tr><td><code>qaicc</code></td>
<td>
<p>QAIC with small sample correction = QAIC + (2*<code>df</code>*(<code>df</code>+1))/(<code>nan</code> - <code>df</code> - 1)</p>
</td></tr>
<tr><td><code>vif</code></td>
<td>
<p>Variance inflation factor used = estimate of c.hat = <code>chisq.vif</code> / <code>chisq.df</code> </p>
</td></tr>
<tr><td><code>chisq.vif</code></td>
<td>
<p>Composite Chi-square statistic from Test 2 and Test 3 used to compute <code>vif</code>, based 
on pooling rules.</p>
</td></tr>
<tr><td><code>vif.df</code></td>
<td>
<p>Degrees of freedom for composite chi-square statistic from Test 2 and Test 3, based on pooling rules.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>Vector of all coefficient estimates, NX capture probability coefficients first, 
then NY survival coefficients.  This vector is length NX+NY regardless of estimated DF.</p>
</td></tr>   
<tr><td><code>se.param</code></td>
<td>
<p>Standard error estimates for all coefficients.  Length NX+NY.</p>
</td></tr>
<tr><td><code>capcoef</code></td>
<td>
<p>Vector of coefficients in the capture model.  Length NX.</p>
</td></tr>
<tr><td><code>se.capcoef</code></td>
<td>
<p>Vector of standard errors for coefficients in capture model. Length NX.</p>
</td></tr>
<tr><td><code>surcoef</code></td>
<td>
<p>Vector of coefficients in the survival model. Length NY.</p>
</td></tr>
<tr><td><code>se.surcoef</code></td>
<td>
<p>Vector of standard errors for coefficients in survival model. Length NY.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>Variance-covariance matrix for the estimated model coefficients.  
Size (NX+NY) X (NX+NY).</p>
</td></tr>
<tr><td><code>p.hat</code></td>
<td>
<p>Matrix of estimated capture probabilities computed from the model.  
One for each animal each occasion.  Cell (i,j) is estimated capture probability 
for animal i during capture occasion j.
Size NAN X NS.  First column corresponding to first capture probability is NA because
cannot estimate P1 in a CJS model.</p>
</td></tr>
<tr><td><code>se.p.hat</code></td>
<td>
<p>Matrix of standard errors for estimated capture probabilities. One for each animal 
each occasion.	Size NAN X NS.  First column is NA.</p>
</td></tr>
<tr><td><code>s.hat</code></td>
<td>
<p>Matrix of estimated survival probabilities computed from the model.  One for each animal each occasion.
Size NAN X NS.  Cell (i,j) is estimated probability animal i survives from 
occasion j to j+1.  There are only NS-1 intervals between occasions. Last 
column corresponding to survival between occasion NS and NS+1 is NA.</p>
</td></tr>
<tr><td><code>se.s.hat</code></td>
<td>
<p>Matrix of standard errors for estimated survival probabilities. 
Size NAN X NS.  Last column is NA.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of parameters assumed in the model.  This value was used in the penalty term of AIC, AICc, QAIC, and QAICc. 
This value is either the number of independent 
parameters estimated from the rank of the variance-covariance matrix (by default), 
or NX+NY, or a specified value, depending on the input value of DF parameter.  See <code>F.update.df</code> to update this value after 
the model is fitted.</p>
</td></tr> 
<tr><td><code>df.estimated</code></td>
<td>
<p>The number of parameters estimated from the rank of the variance-covariance matrix.  This 
is stored so that <code>df</code> can be updated using <code>F.update.df</code>. </p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>A list containing the input maximization and estimation control parameters.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A vector of strings interpreting various codes about the estimation. 
The messages interpret, in this order, the codes for (1) maximization algorithm used, 
(2) exit code from the maximization algorithm (interprets <code>exit.code</code>), and 
(3) covariance matrix code (interprets <code>cov.code</code>). </p>
</td></tr>
<tr><td><code>exit.code</code></td>
<td>
<p>Exit code from the maximization routine.  Interpretation for <code>exit.code</code> is in <code>message</code>.
Exit codes are as follows: 
</p>

<ul>
<li><p> exit.code = 0: FAILURE: Initial Hessian not positive definite.
</p>
</li>
<li><p> exit.code = 1: SUCCESS: Convergence criterion met.
</p>
</li>
<li><p> exit.code = 2: FAILURE: G'dX &gt; 0, rounding error.
</p>
</li>
<li><p> exit.code = 3: FAILURE: Likelihood evaluated too many times.
</p>
</li>
<li><p> exit.code =-1: FAILURE: Unknown optimization algorithm.&quot;
</p>
</li></ul>
      
</td></tr>
<tr><td><code>cov.code</code></td>
<td>
<p>A code indicating the method used to compute the covariance matrix.</p>
</td></tr>
<tr><td><code>fn.evals</code></td>
<td>
<p>The number of times the likelihood was evaluated prior to exit from the minimization routine. 
If <code>exit.code</code> = 3, <code>fn.evals</code> equals the maximum set in <code>mra.control</code>.  This, in combination 
with the exit codes and execution time, can help detect non-convergence or bad behavior.   </p>
</td></tr>
<tr><td><code>ex.time</code></td>
<td>
<p>Execution time for the maximization routine, in <em>minutes</em>.  This is returned for 
2 reasons.  First, this is useful for benchmarking. Second, in conjunction with 
<code>exit.code</code>, <code>cov.code</code>, and <code>fn.evals</code>, this could be used to detect ill-behaved 
or marginally unstable problems, if you know what you are doing.  Assuming <code>maxfn</code> is set high 
in <code>mra.control()</code> (e.g., 1000), 
if <code>exit.code = 1</code> but the model takes a long time to execute relative to similarly sized problems, 
it could indicate unstable or marginally ill-behaved models. </p>
</td></tr>  
<tr><td><code>n.hat</code></td>
<td>
<p>Vector of Horvitz-Thompson estimates of population size.  The Horvitz-Thompson 
estimator of size is, 
</p>
<p style="text-align: center;"><code class="reqn">\hat{N}_{ij} = \sum_{i=1}^{NAN} \frac{h_{ij}}{\hat{p}_{ij}}</code>
</p>

<p>Length of <code>n.hat</code> = NS.  No estimate for 
first occasion.</p>
</td></tr>
<tr><td><code>se.n.hat</code></td>
<td>
<p>Estimated standard errors for <code>n.hat</code> estimates.  Computed using method 
specified in <code>nhat.v.meth</code>.</p>
</td></tr>
<tr><td><code>n.hat.lower</code></td>
<td>
<p>Lower limit of <code>n.hat.conf</code> percent on <code>n.hat</code>.  Length NS.</p>
</td></tr> 
<tr><td><code>n.hat.upper</code></td>
<td>
<p>Upper limit of <code>n.hat.conf</code> percent on <code>n.hat</code>.  Length NS.</p>
</td></tr> 
<tr><td><code>n.hat.conf</code></td>
<td>
<p>Confidence level of intervals on <code>n.hat</code></p>
</td></tr>
<tr><td><code>nhat.v.meth</code></td>
<td>
<p>Code for method used to compute variance of <code>n.hat</code></p>
</td></tr>
<tr><td><code>num.caught</code></td>
<td>
<p>Vector of observed number of animals captured each occasion.  Length NS.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>Matrix of fitted values for the capture histories.  Size NAN X NS.  
Cell (i,j)
is expected value of capture indicator in cell (i,j) of <code>histories</code> matrix.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Matrix of Pearson residuals defined as, 
</p>
<p style="text-align: center;"><code class="reqn">r_{ij} = \frac{(h_{ij} - \Psi_{ij})^2}{\Psi_{ij}}</code>
</p>
<p>, 
where <code class="reqn">\Psi_{ij}</code> is the expected (or fitted) value for cell 
(i,j) and <code class="reqn">h_{ij}</code> is the capture indicator for 
animal i at occasion j.  This matrix has size NAN X NS. See parts pertaining to the &quot;overall test&quot; in 
documentation for <code>F.cjs.gof</code> for a description of <code class="reqn">\Psi_{ij}</code>. </p>
</td></tr>
<tr><td><code>resid.type</code></td>
<td>
<p>String describing the type of residuals computed.  Currently, only Pearson
residuals are returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>MARK Users:  Due to differences in the way MRA and MARK parameterize the sine link, <em>coefficient</em> 
estimates will differ between the two packages when this link is used to fit the same model in both packages.  
The fit (measured by deviance, AIC, etc.) will agree between the two packages.  Capture and survival probability
estimates will also agree between the two packages.  
</p>
<p>MARK does not contain a hazard rate link function. 
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>References</h3>

 
<p>Taylor, M. K., J. Laake, H. D. Cluff, M. Ramsay, and F. Messier. 2002. Managing the risk from hunting for 
the Viscount Melville Sound polar bear population. Ursus 13:185-202.
</p>
<p>Manly, B. F. J., L. L. McDonald, and T. L. McDonald. 1999. The robustness of mark-recapture methods: a 
case study for the northern spotted owl. Journal of Agricultural, Biological, and Environmental 
Statistics 4:78-101.
</p>
<p>Huggins, R. M. 1989. On the statistical analysis of capture experiments. Biometrika 76:133-140.
</p>
<p>Amstrup, S. C., T. L. McDonald, and B. F. J. Manly (editors). 2005. Handbook of 
Capture-Recapture Analysis. Princeton University Press.
</p>
<p>Peterson. 1986. Statistics and Probability Letters. p.227.
</p>
<p>McDonald, T. L., and S. C. Amstrup. 2001. Estimation of population size using 
open capture-recapture models. Journal of Agricultural, Biological, and Environmental 
Statistics 6:206-220.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+tvar">tvar</a></code>, <code><a href="#topic+ivar">ivar</a></code>, <code><a href="#topic+print.cjs">print.cjs</a></code>, <code><a href="#topic+residuals.cjs">residuals.cjs</a></code>, <code><a href="#topic+plot.cjs">plot.cjs</a></code>, 
<code><a href="#topic+F.cjs.covars">F.cjs.covars</a></code>, <code><a href="#topic+F.cjs.gof">F.cjs.gof</a></code>, <code><a href="#topic+mra.control">mra.control</a></code>, <code><a href="#topic+F.update.df">F.update.df</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Fit CJS model to dipper data, time-varying capture and survivals.
## Method 1 : using factors
data(dipper.histories)
ct &lt;- as.factor( paste("T",1:ncol(dipper.histories), sep=""))
attr(ct,"nan")&lt;-nrow(dipper.histories)
dipper.cjs &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(ct,drop=c(1,6,7)), dipper.histories )

## Method 2 : same thing using 2-d matrices
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
# The following extracts 2-D matrices of 0s and 1s
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x3+x4+x5+x6+x7, ~x2+x3+x4+x5, dipper.histories )

## Values in the 1st column of capture covariates do not matter
x3.a &lt;- x3
x3.a[,1] &lt;- 999
dipper.cjs2 &lt;- F.cjs.estim( ~x3.a+x4+x5+x6+x7, ~x2+x3+x4+x5, dipper.histories )
# compare dipper.cjs2 to dipper.cjs

## Values in the last column of survival covariates do not matter
x3.a &lt;- x3
x3.a[,ncol(dipper.histories)] &lt;- 999
dipper.cjs2 &lt;- F.cjs.estim( ~x3+x4+x5+x6+x7, ~x2+x3.a+x4+x5, dipper.histories )
# compare dipper.cjs2 to dipper.cjs


## A plot to compare the link functions
sine.link &lt;- function(eta){ ifelse( eta &lt; -4, 0, ifelse( eta &gt; 4, 1, .5*(1+sin(eta*pi/8)))) }
eta &lt;- seq(-5,5, length=40)
p1 &lt;- 1 / (1 + exp(-eta))
p2 &lt;- sine.link(eta)
p3 &lt;- 1.0 - exp( -exp( eta ))
plot(eta, p1, type="l" )
lines(eta, p2, col="red" )
lines(eta, p3, col="blue" )
legend( "topleft", legend=c("logit", "sine", "hazard"), col=c("black", "red", "blue"), lty=1)




</code></pre>

<hr>
<h2 id='F.cjs.gof'> F.cjs.gof </h2><span id='topic+F.cjs.gof'></span>

<h3>Description</h3>

<p>Goodness of fit measures for a CJS open-population capture recapture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.cjs.gof( cjsobj, resid.type="pearson", rule.of.thumb = 2, HL.breaks = "deciles" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.cjs.gof_+3A_cjsobj">cjsobj</code></td>
<td>
<p>A CJS capture-recapture fitted object from a previous call to <code>F.cjs.estim</code></p>
</td></tr>
<tr><td><code id="F.cjs.gof_+3A_resid.type">resid.type</code></td>
<td>
<p>Type of residual to return.  <code>resid.type</code> = 'pearson' produces 
Pearson residuals.  <code>resid.type</code> = 'deviance' produces deviance residuals.
Anything other than 'deviance' gives you Pearson residuals.</p>
</td></tr>
<tr><td><code id="F.cjs.gof_+3A_rule.of.thumb">rule.of.thumb</code></td>
<td>
<p>Rule of thumb to include a cell in one of the chi-square statistics. For example, 
if <code>rule.of.thumb</code> = 2, the expected count in a cell has to be greater than 
2 in order for the cell to be included in the overall Chi-square statistic for 
that table. No pooling of cells is done. Cells with expected values less than 
<code>rule.of.thumb</code> are dropped.</p>
</td></tr>
<tr><td><code id="F.cjs.gof_+3A_hl.breaks">HL.breaks</code></td>
<td>
<p>vector of bin break points to use in the Hosmer-Lemeshow statistic.  This must 
be a partition of the interval [0,1], with 0 as lowest break and 1 as max.
E.g., if HL.breaks = c(.25,.75), the bins used are [0,.25),[.25,.75),[.75,1].
The default, &quot;deciles&quot;, calculates breakpoints such that 10
values are in each. I.e., approximately <code>0.1 * n</code> expected values
are in each of 10 cells. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;overall&quot; Chi-square test computes the sum of [(h(ij) - Psi(ij))*(h(ij) - Psi(ij))] / Psi(ij) over 
all &quot;live&quot; cells in the capture-recapture problem.  &quot;Live&quot; cells are those following 
initial captures, prior to and including the occasion when an animal was censoring 
(died on capture and removed).  If an animal was not censored, the &quot;live&quot; cells for it
extend from occasion following initial capture to the end of the study. In the above,
h(ij) is the 0-1 capture indicator for animal i at occasion j.  Psi(ij) is the expected 
value of h(ij), and is computed as the produce of survival estimates from initial capture 
to occasion j, times probability of capture at occasion j.  Assuming animal i was initially
captured at the a-th occasion, Psi(ij) is computed as 
phi(ia) * phi(i(a+1)) * ... * phi(i(j-1)) * p(ij), where phi(ij) is the modeled estimate of 
survival for animal i from occasion j to occasion j+1, and p(ij) is the probability of 
capturing animal i during occasion j.  
</p>
<p>The other derived GOF tests computed here use h(ij) and its expected value Psi(ij).  Test 4 
sums observed and expected over individuals.  Test 5 sums observed and expected over occasions. 
The other 3 tests were borrowed from logistic regression by viewing h(ij) as a binary response, 
and Psi(ij) as its expected value. 
</p>


<h3>Value</h3>

<p>A CJS object equivalent to the input crobj, with additional components for 
GOF testing. Additional components are a variety of goodness of fit statistics.  Goodness
of tests included are: (1) &quot;Overall&quot; = Chi-square test of overall goodness of fit 
based on all &quot;live&quot; cells in the capture histories, (2) &quot;Osius and Rojek&quot; = Osius and Rojeck
correction to the overall chi-square test, (3) &quot;Test 4&quot; = Chi-square of observed and expected captures 
by occasion, (4) &quot;Test 5&quot; = Chi-square of observed and expected captures by individual, summed 
over animals, (5) &quot;Hosmer-Lemeshow&quot; = Hosmer-Lemeshow Chi-square GOF over all occasions 
and animals, and (6) &quot;ROC&quot; = area under the curve overall classification accuracy of expected 
values for capture histories. Tests (2), (5), and (6) are based on methods in chapter 5
of Hosmer and Lemeshow (2000).
</p>
<p>Specifically, the output object has class c(&quot;cjsgof&quot;, &quot;cjs&quot;, &quot;cr&quot;), contains 
all the components of the original CJS object, plus the following components:
</p>
<table>
<tr><td><code>gof.chi</code></td>
<td>
<p>Chi-square statistic for overall goodness of fit based on all &quot;live&quot; cells
in the capture-recapture histories.</p>
</td></tr>
<tr><td><code>gof.df</code></td>
<td>
<p>Degrees of freedom for overall goodness of fit test.</p>
</td></tr>
<tr><td><code>gof.pvalue</code></td>
<td>
<p>P-value for overall goodness of fit.</p>
</td></tr>
<tr><td><code>or.table</code></td>
<td>
<p>Chi-square table for the Osius and Rojek correction 
to the overall GOF test (See p. 153 of Hosmer and Lemeshow (2000)).</p>
</td></tr>
<tr><td><code>or.chi</code></td>
<td>
<p>Chi-square statistic for the Osius and Rojek test.</p>
</td></tr>
<tr><td><code>or.df</code></td>
<td>
<p>Degrees of freedom for the Osius and Rojek test.</p>
</td></tr>
<tr><td><code>or.correction</code></td>
<td>
<p>Correction to the Osius and Rojek test. This is computed as 
number of unique expected values minus the sum of 1 over the individual 
cell counts.</p>
</td></tr> 
<tr><td><code>or.rss</code></td>
<td>
<p>Root sum-of-squares for the Osius and Rojek test, obtained from 
weighted regression.</p>
</td></tr>
<tr><td><code>or.z</code></td>
<td>
<p>Osius and Rojek Z statistic.  This is computed as 
(or.chi - or.df) / sqrt( or.correction + or.rss )</p>
</td></tr>
<tr><td><code>or.pvalue</code></td>
<td>
<p>2-tailed Osius and Rojek p-value computed from standard normal 
distribution and the Osius and Rojek Z statistic.</p>
</td></tr>
<tr><td><code>t4.table</code></td>
<td>
<p>Chi-square table for Test 4, which sums observed and expected 
captures over individuals.  This table has one cell for each occasion.</p>
</td></tr>
<tr><td><code>t4.chi</code></td>
<td>
<p>Chi-square statistic for Test 4, computed from <code>t4.table</code> by 
summing the chi-square contributions over cells that meet the <code>rule.of.thumb</code>. </p>
</td></tr>
<tr><td><code>t4.df</code></td>
<td>
<p>Degrees of freedom for Test 4. Equal to number of cells meeting <code>rule.of.thumb</code> 
minus 1.</p>
</td></tr>
<tr><td><code>t4.pvalue</code></td>
<td>
<p>P-value for Test 4 computed from Chi-squared distribution.</p>
</td></tr>
<tr><td><code>t5.table</code></td>
<td>
<p>Chi-square table for Test 5, which sums observed and expected 
captures over occasions.  This table has one cell for each individual.</p>
</td></tr>
<tr><td><code>t5.chi</code></td>
<td>
<p>Chi-square statistic for Test 5, compute from <code>t5.table</code> by 
summing the chi-square contributions over cells that meet the <code>rule.of.thumb</code>.</p>
</td></tr>
<tr><td><code>t5.df</code></td>
<td>
<p>Degrees of freedom for Test 5. Equal to number of cells meeting <code>rule.of.thumb</code> 
minus 1.</p>
</td></tr>
<tr><td><code>t5.pvalue</code></td>
<td>
<p>P-value for Test 5 computed from Chi-squared distribution.</p>
</td></tr>
<tr><td><code>HL.table</code></td>
<td>
<p>Chi-square table for the Hosmer-Lemeshow test.</p>
</td></tr>
<tr><td><code>HL.chi</code></td>
<td>
<p>Chi-square statistic for the Hosmer-Lemeshow test.</p>
</td></tr>
<tr><td><code>HL.df</code></td>
<td>
<p>Degrees of freedom for the Hosmer-Lemeshow test.</p>
</td></tr>
<tr><td><code>HL.pvalue</code></td>
<td>
<p>P-value for the Hosmer-Lemeshow test.</p>
</td></tr>
<tr><td><code>roc</code></td>
<td>
<p>Area under the curve statistic for the ability of the &quot;live&quot; cell expected values 
to classify captures. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Future plans include adding the following: 
(1) Osius-Rojek = Overall z statistic for GOF over all occasions and animals; and (2)
Stukel = Overall z test for appropriateness of the logistic link.
</p>
<p>Future plans also include a plot method whereby all tests, especially the ROC, could be 
assessed graphically. 
</p>
<p>Print the GOF results in a nice format using <code>print.cjs</code>.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST Inc., tmcdonald@west-inc.com </p>


<h3>References</h3>

 
<p>Hosmer, D. W. and S. Lemeshow. 2000. Applied Logistic Regression, 2nd edition. 
New York: John Wiley and Sons. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+print.cjs">print.cjs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
dipper.cjs.gof &lt;- F.cjs.gof( dipper.cjs )
print(dipper.cjs.gof)

</code></pre>

<hr>
<h2 id='F.cjs.simulate'>
F.cjs.simulate - Generation of capture histories that follow a CJS model.
</h2><span id='topic+F.cjs.simulate'></span>

<h3>Description</h3>

<p>This function generates capture history matrices that 
follow open Cormack-Jolly-Seber (CJS) models.  A super-population 
approach is taken wherein individuals with unique capture and survival 
probabilities are randomly 'born' into the 
realized population and captured. Any CJS model, including those with 
heterogeneous survival or capture probabilities, can be 
simulated.  Closed populations can also be simulated.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.cjs.simulate(super.p, super.s, fit, N1 = 1000, 
  births.per.indiv = "constant.popln", R = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.cjs.simulate_+3A_super.p">super.p</code></td>
<td>
<p>A matrix or vector of true capture probabilities in the super-population of individuals.
</p>

<ul>
<li><p> If <code>super.p</code> is a VECTOR, all individuals in the realized population will have the 
same true capture probabilities, but capture probabilities can vary by occasion.  In this case, 
<code>length(super.p)</code> capture occasions will be simulated.  
</p>
</li>
<li><p> If <code>super.p</code> is a MATRIX, the rows of <code>super.p</code> will be 
randomly selected and used for the capture probabilities of individuals 
when they are 'born' into the population.  
Number of rows in <code>super.p</code> must be 
greater than or equal to 1, and does not need to match number of rows in <code>super.s</code>.
When <code>super.p</code> is a matrix, <code>ncol(super.p)</code> capture occasions will be simulated.  
</p>
</li></ul>

</td></tr>
<tr><td><code id="F.cjs.simulate_+3A_super.s">super.s</code></td>
<td>
<p>A matrix or vector of true survival probabilities in the super-population of individuals.
</p>

<ul>
<li><p> If <code>super.s</code> is a VECTOR, all individuals in the realized population will have the 
same true survival probabilities after they are 'born' into the realized population.  
If the number of occasions to simulate is NS (see <code>super.p</code> above),
<code>super.s</code> must be of length <code class="reqn">NS - 1</code>.
</p>
</li>
<li><p> If <code>super.p</code> is a MATRIX, the rows of <code>super.p</code> will be 
randomly selected and used as survival probabilities for individuals when they 
are 'born' into the population.  If the number of occasions to simulate 
is NS, <code>super.s</code> must have <code class="reqn">NS - 1</code> columns. The vector
<code>super.s[,j]</code> is the set of true survival probabilities for animals alive just after 
occasion <code>j</code> until just before occasion <code>j+1</code>. Number of rows in <code>super.s</code> must be 
greater than or equal to 1, and does not need to match number of rows in <code>super.p</code>.
</p>
</li></ul>

<p>Number of survival probabilities in <code>super.s</code> is one less than NS because 
survival probabilities apply between capture occasions. </p>
</td></tr>
<tr><td><code id="F.cjs.simulate_+3A_fit">fit</code></td>
<td>
<p>A previously estimated CJS object.  Instead of specifying <code>super.p</code> and <code>super.s</code>,
a fitted CJS model can be specified.  If either one of <code>super.p</code> or <code>super.s</code> is missing, 
the (estimated) probabilities in <code>fit</code> will be used for their respective place.  That is, 
if <code>super.p</code> is missing, <code>fit</code> must be present and <code>fit$p.hat</code> will be used for the 
matrix of true capture probabilities. If <code>super.p</code> is missing, <code>fit</code> must be present and 
<code>fit$s.hat</code> will be used for the 
matrix of true survival probabilities. Because capture probabilities for the 
first occasion are not usually estimable by CJS models, capture 
probabilities for the first occasion are set equal to 1.0.  All members of the realized population 
will be observed on the first occasion in this case. </p>
</td></tr>
<tr><td><code id="F.cjs.simulate_+3A_n1">N1</code></td>
<td>
<p>A scalar specifying the initial population size.  I.e., <code>N1</code> individuals will be 
'born' into the realized population just before the first sampling occasion.</p>
</td></tr>
<tr><td><code id="F.cjs.simulate_+3A_births.per.indiv">births.per.indiv</code></td>
<td>
<p>Either a vector of births per individual in the realized population, or 
the string &quot;constant.popln&quot; (the default).  If 
<code>births.per.indiv</code> = &quot;constant.popln&quot;, the total number of births into the realized population between capture occasions 
will equal the number of deaths between occasions.  In this case,  
true realized population size will be (exactly) constant through time.  If <code>births.per.indiv</code> is 
a vector of length <code class="reqn">NS - 1</code>, then round( <code class="reqn">N_j</code>*<code>births.per.indiv[,j]</code> ) births 
will occur between occasions <code>j</code> and <code>j+1</code>, where <code class="reqn">N_j</code> is the true number of 
individuals in the realized population at occasion <code>j</code>.  Values in <code>birth.rate</code> must  
be 0 or greater.  As an example, all animals in the realized population have one offspring  
between occasions if <code>births.per.indiv = rep(1,NS)</code>.  Assuming a sex ratio of 50%, all females 
alive in the population between occasions have one offspring if <code>births.per.indiv</code> = 0.5. All females 
in the population have two offspring if <code>births.per.indiv</code> = 1.</p>
</td></tr>
<tr><td><code id="F.cjs.simulate_+3A_r">R</code></td>
<td>
<p>A scalar specifying the number of replications for the simulation. A total of <code>R</code> 
independent capture history matrices will be generated. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some examples: A two-group heterogeneous population contains one group of individuals with one common
set of capture probabilities, and another group of individuals with another set of common 
capture probabilities.  A population with one group of individuals having capture probability equal 
to 0.25, and another group with capture probability equal to 0.75 can be simulated using 
</p>
 <ul>
<li><p> F.cjs.simulate( rbind( rep(0.25,10),rep(0.75,10) ), rep(s,9) ). </p>
</li></ul>
<p>,
where <code>s</code> is some survival probability between 0 and 1. If <code>s</code> = 1, a 
closed (no births or deaths) two-group heterogeneous model is simulated.  In this example, the 
realized population is sampled for 10 occasions. 
</p>
<p>Non-equal sized heterogeneous groups can be simulated using        
</p>
 <ul>
<li><p> F.cjs.simulate( rbind( matrix(0.25,1,10),matrix(0.75,9,10) ), rep(1,9) ). </p>
</li></ul>

<p>Using this call, approximately 10% of individuals in the realized population will have capture probabilities 
equal to 0.25, while 90% will have capture probabilities equal to 0.75. Additional 
groups can be included by including more rows with distinct probabilities in <code>super.p</code>.
</p>
<p>A population with heterogeneous capture probabilities proportional to a vector <code>w</code> can be simulated using 
</p>
 <ul>
<li><p> F.cjs.simulate( matrix( w/sum(x), length(w), 10), rep(s,9) ) </p>
</li></ul>
<p>.  
</p>
<p>A stochastic population that varies around a specified size of <code>N1</code> = 1000
can be simulated with a statement like 
</p>
 <ul>
<li><p> F.cjs.simulate( rep(0.25,10), rep(s,9), N1=1000, births.per.indiv=rep((1-s)/s,9) ). </p>
</li></ul>

<p>In this simulation, N(j)*(1-s) individuals die between each occasion, but are replaced because the N(j)*s
surviving individuals each have (1-s)/s offspring. 
</p>
<p>Because of the super-population approach taken here, it is not possible to specify which individuals 
have which survival or capture probabilities, nor to guarantee that a certain number of individuals 
in the realized population have capture probabilities equal to any particular value.  
</p>


<h3>Value</h3>

<p>A list of length <code>R</code>.  Each component of this list is a list of length 2. 
Each of these <code>R</code> sublists contains the following components:  
</p>
<table>
<tr><td><code>hists</code></td>
<td>
<p>The simulated capture histories for a particular iteration. This is 
a matrix with a random number of rows (due to the stochastic nature of captures) 
and NS columns.</p>
</td></tr>
<tr><td><code>popln.n</code></td>
<td>
<p>A vector of length NS containing the true population sizes at each 
sampling occasion.</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Trent McDonald, WEST Inc. (tmcdonald@west-inc.com)</p>


<h3>See Also</h3>

<p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## Don't run specified because these examples can take &gt; 10 seconds. 

## Simulate constant model, and analyze


ns &lt;- 10
N &lt;- 100
sim.list &lt;- F.cjs.simulate( rep(0.3,ns), rep(0.9,ns-1), N1=N, R=100 )

f.analyze &lt;- function(x){
    fit &lt;- F.cjs.estim( ~1, ~1, x$hists, control=mra.control(maxfn=200, cov.meth=2) )
    if( fit$exit.code == 1 ){
        return( fit$n.hat )
    } else {
        return( rep(NA,ncol(x$hists)) )
    }
}
results &lt;- t(sapply(sim.list, f.analyze))
plot( 1:10, colMeans(results, na.rm=TRUE), xlab="Occasion", 
  ylab="Mean population estimate", col="red", type="b")
abline( h=N )

## Plot RMSE by occasion
std &lt;- apply(results, 2, sd, na.rm=TRUE)
bias &lt;- apply(results - N, 2, mean, na.rm=TRUE)
plot( std, bias, type="n" )
text( std, bias, 2:10 )
abline(h=0)
title(main="RMSE by Sample Occasion")

## Show bias when heterogeniety is present
sim.list &lt;- F.cjs.simulate( matrix(c(0.3,.7,.7,.7),4,ns), rep(0.9,ns-1), N1=N, R=100 ) 
results &lt;- t(sapply(sim.list, f.analyze))
mean.N &lt;- colMeans(results, na.rm=TRUE)
plot( 1:length(mean.N), mean.N, ylim=range(c(mean.N,N),na.rm=TRUE), 
  xlab="Occasion", ylab="Mean population estimate", col="red", type="b")
abline( h=N )
abline( h=mean(mean.N), col="red", lty=2)
title(main="Heterogeniety causes negative bias")


## Simulate CJS model, first estimate one
data(dipper.histories)
ct &lt;- as.factor( paste("T",1:ncol(dipper.histories), sep=""))
attr(ct,"nan")&lt;-nrow(dipper.histories)
dipper.cjs &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(ct,drop=c(1,6,7)), dipper.histories )

## Now generate histories from it.
sim.list &lt;- F.cjs.simulate( fit=dipper.cjs, N1=100, birth.rate=rep(1,6), R=100 )

## Now analyze generated histories using lapply or sapply.  Can fit any model. 
## Here we fit the correct model.
f.analyze &lt;- function(x){
    #   write a counter to console, this is not necessary
    i &lt;- get("i", env=.GlobalEnv) + 1
    cat(paste("Iteration", i, "\n"))
    assign("i",i,env=.GlobalEnv)
    
    ct &lt;- as.factor( 1:ncol(x$hists) )
    fit &lt;- F.cjs.estim( ~tvar(ct,nan=nrow(x$hists),drop=c(1,2)), 
        ~tvar(ct,nan=nrow(x$hists),drop=c(1,6,7)), 
        x$hists, control=mra.control(maxfn=200, cov.meth=2) )
    if( fit$exit.code == 1 ){
        return( fit$n.hat )
    } else {
        return( rep(NA,ncol(x$hists)) )
    }
}
i &lt;- 0
results &lt;- t(sapply(sim.list, f.analyze))
mean.N &lt;- colMeans(results, na.rm=TRUE)
plot( 1:length(mean.N), mean.N, ylim=range(c(mean.N,N),na.rm=TRUE), 
  xlab="Occasion", ylab="Mean population estimate", col="red", type="b")
abline( h=N )
title(main="Time varying CJS model")

## End(Not run)

</code></pre>

<hr>
<h2 id='F.cr.model.avg'> F.cr.model.avg - Model averaging of mark-recapture parameters. </h2><span id='topic+F.cr.model.avg'></span>

<h3>Description</h3>

<p>Computes model averaged estimates of survival, capture probability, or population size
estimates from a set of previously fitted MRA objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.cr.model.avg( fits=ls(pattern="^fit"), what="survival", fit.stat="qaicc" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.cr.model.avg_+3A_fits">fits</code></td>
<td>
<p>A character vector of MRA fitted object names.  Each will be retrieved from the global environment
(i.e., .GlobalEnv) using <code>get</code> and tested to make sure they are MRA fitted objects.  If not, a warning is 
issued and the object is ignored.  If the object is an MRA model, it is included in
model averaging. The default value
will use any object whose name starts with &quot;fit&quot;.
For example, if fitted objects are named
&quot;fit1.01&quot;, &quot;fit1.02&quot;, and &quot;fit1.03&quot;, <code>fits</code> equal to <code>c("fit1.01", "fit1.02", "fit1.03")</code>
or <code>ls(pat="^fit1")</code>, will average statistics in these three objects.  </p>
</td></tr>
<tr><td><code id="F.cr.model.avg_+3A_what">what</code></td>
<td>
<p>A text string naming the parameter to average.  Choices are &quot;survival&quot; (the 
default), &quot;capture&quot;, and &quot;n.hat&quot;.  Only the first character is inspected (e.g., &quot;c&quot; is 
equivalent to &quot;capture&quot;). </p>
</td></tr>  
<tr><td><code id="F.cr.model.avg_+3A_fit.stat">fit.stat</code></td>
<td>
<p>A string (scalar) naming the model fit statistic to use when computing 
model weights.  Possible values
are: &quot;qaicc&quot; (the default), &quot;qaic&quot;, &quot;aicc&quot;, and &quot;aic&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each model is checked for convergence prior to including in the model averaging process.   
The test for whether a model converged is
<code>(fit$exit.code == 1) &amp; (fit$cov.code == 0) &amp; (fit$df &gt; 0)</code>, where <code>fit</code> is
the fitted object. If the model did not converge, 
it is excluded from model averaging.
</p>
<p>Conditional and unconditional variance estimates are computed following Burnham and 
Anderson 2002 (pages 150 and 162 and surrounding). 
</p>
<p>If <code>what</code> = &quot;n.hat&quot;, the returned object is suitable for printing using <code>print.nhat</code> and plotting using <code>plot.cjs</code>. 
If <code>what</code> = &quot;survival&quot; or &quot;capture&quot;, the returned object is unclassed and the user is responsible for printing and plotting.
</p>


<h3>Value</h3>

<p>If <code>what</code> = &quot;survival&quot; or &quot;capture&quot;, the return is a list object containing the following components: 
</p>
<table>
<tr><td><code>fit.table</code></td>
<td>
<p>A data frame, sorted by <code>fit.stat</code>, containing model names, fit statistics, delta fit statistics, and 
model averaging weights. </p>
</td></tr>
<tr><td><code>s.hat or p.hat</code></td>
<td>
<p>A matrix of size <code>nan</code> X <code>ns</code> containing model averaged estimates of survival 
or capture probability.</p>
</td></tr>
<tr><td><code>se.s.hat or se.p.hat</code></td>
<td>
<p>A matrix of size <code>nan</code> X <code>ns</code> containing the unconditional (on model selection) estimate of 
standard error for the corresponding model averaged statistic in <code>s.hat</code> or <code>p.hat</code>. Unconditional variances 
are computed using formulas in Burnham and Anderson (2002, pages 150 and 162)</p>
</td></tr>
<tr><td><code>se.s.hat.conditional or se.p.hat.conditional</code></td>
<td>
<p>A matrix of size <code>nan</code> X <code>ns</code> containing the conditional estimate of 
standard error for the corresponding model averaged statistic in <code>s.hat</code> or <code>p.hat</code>. These estimates of variance 
are conditional on model selection. </p>
</td></tr>
<tr><td><code>mod.selection.proportion</code></td>
<td>
<p>A matrix of size <code>nan</code> X <code>ns</code> containing the proportion of variance due to model selection uncertainty. 
Values in this matrix are simply the difference between unconditional variance and conditional variance, divided by the unconditional variance.</p>
</td></tr>
</table>
<p>If <code>what</code> = &quot;n.hat&quot;, the return is a list of class &quot;n.hat&quot; containing the following components: 
</p>
<table>
<tr><td><code>fit.table</code></td>
<td>
<p>A data frame, sorted by <code>fit.stat</code>, containing model names, fit statistics, delta fit statistics, and 
model averaging weights. </p>
</td></tr>
<tr><td><code>n.hat</code></td>
<td>
<p>A vector of length <code>ns</code> containing model averaged estimates of population size.</p>
</td></tr>
<tr><td><code>se.n.hat</code></td>
<td>
<p>A vector of length <code>ns</code> containing the unconditional (on model selection) estimate of 
standard error for the corresponding model averaged population size.</p>
</td></tr>
<tr><td><code>se.n.hat.conditional</code></td>
<td>
<p>A vector of length <code>ns</code> containing the conditional estimate of 
standard error for the corresponding model averaged population size. </p>
</td></tr>
<tr><td><code>mod.selection.proportion</code></td>
<td>
<p>A vector of length<code>ns</code> containing the proportion of variance due to model selection uncertainty. 
Values in this matrix are simply the difference between unconditional variance and conditional variance, divided by the unconditional variance.</p>
</td></tr>
<tr><td><code>n.hat.lower</code></td>
<td>
<p>A vector of length <code>ns</code> containing lower 95% confidence limits for the corresponding population size estimate.</p>
</td></tr>
<tr><td><code>n.hat.upper</code></td>
<td>
<p>A vector of length <code>ns</code> containing upper 95% confidence limits for the corresponding population size estimate.</p>
</td></tr>
<tr><td><code>nhat.v.meth</code></td>
<td>
<p>Scalar indicating the type of variance estimate used.  Values are: <code>4</code> = &quot;(Model averaged Huggins variance)&quot;, 
<code>5</code> = &quot;(Model averaged Huggins variance + higher terms)&quot;, or <code>6</code> = &quot;(Model averaged McDonald and Amstrup)&quot;. See help for 
<code>F.cjs.estim</code> for more explanation.</p>
</td></tr>   
</table>


<h3>Author(s)</h3>

<p> Original routine by Eric Regehr, US Fish and Wildlife.  
Modified for MRA by Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>References</h3>

<p>Burnham, K. and D. Anderson (2002) &quot;Model Selection: A practical guide&quot;. Cambridge University Press.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+F.huggins.estim">F.huggins.estim</a></code>, <code><a href="#topic+F.fit.table">F.fit.table</a></code>, 
<code><a href="#topic+plot.cjs">plot.cjs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Fit several CJS model to dipper data. Model average survival

## Time varying survival and capture (true CJS model)
data(dipper.histories)
ct &lt;- as.factor( paste("T",1:ncol(dipper.histories), sep=""))
attr(ct,"nan")&lt;-nrow(dipper.histories)
dipper.01 &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(ct,drop=c(1,6,7)), dipper.histories )

## Linear trend in survival
cT &lt;- 1:ncol(dipper.histories)
dipper.02 &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(cT, nan=nrow(dipper.histories)), 
  dipper.histories )

## No trend in survival
dipper.03 &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~1, dipper.histories )

## Model average
mod.avg.surv &lt;- F.cr.model.avg( ls(pat="^dipper.[0-9]"), what="s", fit.stat="aicc" )

mod.avg.n &lt;- F.cr.model.avg( ls(pat="^dipper.[0-9]"), what="n", fit.stat="aicc" )

## Plot
plot(mod.avg.n)



</code></pre>

<hr>
<h2 id='F.cr.model.matrix'> Capture-Recapture model matrix </h2><span id='topic+F.cr.model.matrix'></span>

<h3>Description</h3>

 
<p>Returns two model matrices for capture-recapture modeling. Both are 
in the form 
of (giant) 2D matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
F.cr.model.matrix(capture, survival, nan, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.cr.model.matrix_+3A_capture">capture</code></td>
<td>
<p> Formula for the capture model.  Must be a formula object with 
no response, then ~, followed by the names of 2-D arrays of covariates to fit in 
the capture model. 
For example: capture = ~ age + sex, where age and sex are matrices.  </p>
</td></tr>
<tr><td><code id="F.cr.model.matrix_+3A_survival">survival</code></td>
<td>
<p> Formula for the survival model. Must be a formula object with 
no response, then ~, followed by the names of 2-D arrays of covariates to fit in 
the survival model. 
For example: capture = ~ age + sex, where age and sex are matrices.  </p>
</td></tr>
<tr><td><code id="F.cr.model.matrix_+3A_nan">nan</code></td>
<td>
<p> Number of individuals in the model. This is necessary for the 
<code>ivar</code> and <code>tvar</code> functions to work.  Normally, <code>nan</code> = 
number of rows in capture history matrix.  No default value. </p>
</td></tr>
<tr><td><code id="F.cr.model.matrix_+3A_ns">ns</code></td>
<td>
<p> Number of sampling occasions.  Normally, <code>ns</code> = number of 
columns in the capture history matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine is intended to be called internally by model fitting routines 
of MRA.  General users should never have to call this routine.
</p>
<p>This routine uses a call to <code>eval</code> with a model frame, and calls the 
R internal <code>model.matrix</code> to 
resolve the matrices in the formula. All matrices specified in the models 
should be in the current scope and accessible to both <code>eval</code> and <code>model.matrix</code>.  
</p>
<p>This routine calls <code>F.3d.model.matrix</code> twice.  <code>F.3d.model.matrix</code> 
does all the work. 
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>capX</code></td>
<td>
<p> A NAN by IX+(NX*NS) matrix containing covariate values for the capture 
model.  Matrices specified in the model are column appended together.  
NAN = <code>nrow(x)</code> where <code>x</code> is a 2-D matrix in the model (i.e., 
number of animals). NS = <code>ncol(x)</code> (i.e., number of capture occasions). 
NX = number of matrices specified in the model.  IX = 1 if an intercept is included, 
0 otherwise.  The j-th covariate matrix specified in the model can be accessed directly with 
<code>capX[, IX+1+(NS*(j-1)):(NS*j) ]</code>.  </p>
</td></tr>
<tr><td><code>surX</code></td>
<td>
<p> A NAN by IY+(NY*NS) matrix containing covariate values for the survival 
model.  Matrices specified in the model are column appended together.  
NAN = <code>nrow(x)</code> where <code>y</code> is a 2-D matrix in the model (i.e., 
number of animals). NS = <code>ncol(y)</code> (i.e., number of capture occasions). 
NY = number of matrices specified in the model.  IY = 1 if an intercept is included, 
0 otherwise.  The j-th covariate matrix specified in the model can be accessed directly with 
<code>capY[, IY+1+(NS*(j-1)):(NS*j) ]</code>.</p>
</td></tr> 
<tr><td><code>n.cap.covars</code></td>
<td>
<p>Number of matrices specified in the capture model (NX above).</p>
</td></tr>
<tr><td><code>n.sur.covars</code></td>
<td>
<p>Number of matrices specified in the survival model (NY above).</p>
</td></tr>
<tr><td><code>cap.intercept</code></td>
<td>
<p>TRUE or FALSE depending on whether an intercept was included in the 
capture model</p>
</td></tr>
<tr><td><code>sur.intercept</code></td>
<td>
<p>TRUE or FALSE depending on whether an intercept was included in the 
survival model</p>
</td></tr>
<tr><td><code>cap.vars</code></td>
<td>
<p>Vector of names for the NX covariates in the capture model.</p>
</td></tr>
<tr><td><code>sur.vars</code></td>
<td>
<p>Vector of names for the NY covariates in the survival model.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="base.html#topic+eval">eval</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 


# Synthetic example with 10 animals and 5 occasions
nan &lt;- 10
ns &lt;- 5
sex &lt;- matrix( as.numeric(runif( nan ) &gt; 0.5), nrow=nan, ncol=ns )
x &lt;- matrix( runif( nan*ns ) , nrow=nan, ncol=ns )
F.cr.model.matrix( capture= ~ sex + x, survival= ~ -1 + x, nan, ns )


</code></pre>

<hr>
<h2 id='F.fit.table'> F.fit.table - Produce a summary table of model fit statistics. </h2><span id='topic+F.fit.table'></span>

<h3>Description</h3>

<p>A utility function to compile a table of fit statistics from a list of MRA fitted objects contained in the 
.GlobalEnv (i.e., 'working') environment.  The table produced by this routine 
contains model name, fit statistics (AICc or QAICc), and is ranked by
(sorted by) one of these fit statistics.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.fit.table( fits=ls(pattern="^fit"), rank.by= "qaicc", plausible.p=0.01 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.fit.table_+3A_fits">fits</code></td>
<td>
<p>A character vector of MRA fitted object names to include in the 
summary table. These names do not need to have a common root name.  The default value 
will use any object whose name starts with &quot;fit&quot; in the working directory (.GlobalEnv).
An an example, if fitted objects are named 
&quot;fit1.01&quot;, &quot;fit1.02&quot;, and &quot;fit1.03&quot;, <code>fits</code> should equal <code>c("fit1.01", "fit1.02", "fit1.03")</code>, 
or <code>ls(pat="^fit1")</code>, assuming no other objects in the working directory start with &quot;fit1&quot;.</p>
</td></tr>
<tr><td><code id="F.fit.table_+3A_rank.by">rank.by</code></td>
<td>
<p>A string (scalar) naming the model fit statistic to include
in the summary table.  The resulting table is sorted by this statistic. Possible values 
are: &quot;qaicc&quot; (the default), and &quot;aicc&quot;.</p>
</td></tr>
<tr><td><code id="F.fit.table_+3A_plausible.p">plausible.p</code></td>
<td>
<p>A scalar specifying the cut-point in <code>rank.by</code> weight to use during 
determination of 'plausible' models. A model is defined to be 'plausible' if it has <code>rank.by</code> 
weight greater than <code>plausible.p</code> OR if 
the model's log-likelihood is greater than the minimum log likelihood amongst those that 
have <code>rank.by</code> weight greater than <code>plausible.p</code>.  See explanation of <code>plausible</code> 
in Value section below.    
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A rudimentary check for convergence is done on each fitted model.  If this routine believes
a model did not converge, the model is included in the table, but the model's fit 
statistics are set to <code>Inf</code>. The test for whether a model converged is 
<code>(fit$exit.code == 1) &amp; (fit$cov.code == 0) &amp; (fit$df &gt; 0)</code>, where <code>fit</code> is 
the fitted object.
</p>
<p>Fitted objects are pulled from the <code>.GlobalEnv</code> environment.  Usually, this is the 
current working directory.  Currently, there is no way to pull fits from another environment, but 
a savvy R programmer could modify the <code>where</code> argument of the <code>get</code> command embedded in 
this routine.
</p>


<h3>Value</h3>

<p>A data frame, sorted by <code>rank.by</code>, with the following columns
</p>
<table>
<tr><td><code>model.num</code></td>
<td>
<p>Model number assigned by this routine, equal to the position of the 
model in the input list of fits.</p>
</td></tr>
<tr><td><code>model.name</code></td>
<td>
<p>Name of the fitted object.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical values indicating whether this routine thinks the model 
converged or not.  Value is TRUE if the this routine thinks the model converged, 
FALSE otherwise. </p>
</td></tr>
<tr><td><code>n.est.parameters</code></td>
<td>
<p>Number of estimable parameters in the model.  This is MRA's guess at the number 
of estimable parameters in the model, not length of the coefficient vector.</p>
</td></tr>
<tr><td><code>n.coefficients</code></td>
<td>
<p>Number of coefficients in the model.  This is length of the coefficient 
vector without regard to number of estimable parameters.  If <code>n.coefficients</code> &gt; <code>n.est.parameters</code>, 
the model is not full rank, and at least one coefficient is probably not estimable.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>value of the log likelihood evaluated at the maximum likelihood parameters.</p>
</td></tr>  
<tr><td><code>aicc</code></td>
<td>
<p>AIC of the model including the small sample correction = 
AIC + (2*<code>df</code>*(<code>df</code>+1)) / (<code>nan</code> - <code>df</code> - 1)</p>
</td></tr>
<tr><td><code>delta.aicc</code></td>
<td>
<p>Difference between AICc for the model and the minimum AICc in the table.</p>
</td></tr>  
<tr><td><code>aicc.wgt</code></td>
<td>
<p>AICc model weights.  These weights equal exp(-.5*(delta.aicc)), scaled to sum to 1.0,</p>
</td></tr>
<tr><td><code>qaicc</code></td>
<td>
<p>QAIC of the model including the small sample correction = 
QAIC + (2*<code>df</code>*(<code>df</code>+1))/(<code>nan</code> - <code>df</code> - 1)</p>
</td></tr>
<tr><td><code>delta.qaicc</code></td>
<td>
<p>Difference between QAICc for the model and the minimum QAICc in the table.</p>
</td></tr>
<tr><td><code>qaicc.wgt</code></td>
<td>
<p>QAICc model weights.  These weights equal exp(-.5*(delta.qaicc)), scaled to sum to 1.0,</p>
</td></tr>
<tr><td><code>plausible</code></td>
<td>
<p>Indicates &lsquo;plausible&rsquo; models as defined by Bromaghin et al. (2013).  The value 
in this column is TRUE if the model has <code>rank.by</code> weight greater than <code>plausible.p</code> OR if 
the model's log-likelihood is greater than the minimum log likelihood amongst those that 
have <code>rank.by</code> weight greater than <code>plausible.p</code>. The second condition in this scheme includes a model structure as 'plausible' 
when its log-likelihood is relatively high but it has been heavily penalized by the number of parameters.  When 
the likelihood is parameterized to contain two or more linear models, this second condition is a reasonable 
criterion when model selection is done in a step-wise fashion on each model separately (see Bromaghin et al., 2013). 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>References</h3>

<p> Bromaghin, J.F., McDonald, T. L., and Amstrup, S. C., (2013) &quot;Plausible Combinations: An 
improved methods to evaluate the covariate structure of Cormack-Jolly-Seber mark-recapture models&quot;, 
Open Journal of Ecology, v.3, p. 11-22.  (included in vignettes)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+F.huggins.estim">F.huggins.estim</a></code>, <code>vignette("Bromaghin_etal_2013_OJE")</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Fit several CJS model to dipper data. Summarize fits.

## Time varying survival and capture (true CJS model)
data(dipper.histories)
ct &lt;- as.factor( paste("T",1:ncol(dipper.histories), sep=""))
attr(ct,"nan")&lt;-nrow(dipper.histories)
dipr.01 &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(ct,drop=c(1,6,7)), dipper.histories )

## Linear trend in survival
cT &lt;- 1:ncol(dipper.histories)
dipr.02 &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(cT, nan=nrow(dipper.histories)), 
  dipper.histories )

## No trend in survival
dipr.03 &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~1, dipper.histories )

## Summary table
F.fit.table( ls(pat="^dipr") )


</code></pre>

<hr>
<h2 id='F.huggins.estim'> F.huggins.estim - Estimation of Huggins closed 
population capture-recapture model. </h2><span id='topic+F.huggins.estim'></span><span id='topic+huggins.estim'></span><span id='topic+huggins'></span><span id='topic+Huggins'></span>

<h3>Description</h3>

<p>Estimates Huggin's closed population capture-recapture models with individual, time, and
individual-time varying covariates using the &quot;regression&quot; parameterization of 
Amstrup et al (2006, Ch 9). For live recaptures only. 
A logistic link function is used to relate probability of capture 
to external covariates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.huggins.estim(capture, recapture=NULL, histories, remove=FALSE, cap.init, recap.init,
    nhat.v.meth=1, df=NA, link="logit", control=mra.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.huggins.estim_+3A_capture">capture</code></td>
<td>
<p> Formula specifying covariates to included in the initial 
capture probability model.  Must be a formula object without 
a response. Specify ~, followed by the names of 2-D arrays of covariates to relate to 
initial capture probability. 
For example: 'capture = ~ age + sex', where age and sex are matrices of size NAN X NS 
containing the age and sex covariate values.  NAN = number of individuals = number of rows in 
<code>histories</code> matrix (see below).  NS = number of samples = number of columns in histories
matrix (see below). Number of matrices specified in the initial capture model is 
assumed to be NX. Specify 
intercept only model as 'capture = ~ 1'.  Specify model without an intercept 
using 'capture = ~ -1 + x'.  </p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_recapture">recapture</code></td>
<td>
<p> Formula specifying covariates to included in the 
recapture probability model, or NULL.  Should be specified the same way as the 
<code>capture</code> model.  
For example: 'recapture = ~ behave + sex'. The number of covariates specified in
the recapture model is NY.  Total number of parameters this routine 
attempts to estimate is NX+NY. See <code>df</code> argument. If <code>recapture=NULL</code>, 
no recapture model (or the empty model) is estimated.  In this case, 
recapture probabilities equal initial capture probabilities and both depend on the 
model in <code>capture</code>. Note that NULL models are specified without the ~.</p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_histories">histories</code></td>
<td>
<p> A NAN X NS = (number of individuals) X (number of capture occasions) matrix 
containing capture histories.  Capture histories are comprised of 0's and 1's only. 
0 in cell (i,j) of this matrix means individual i was not captured on occasion j, 
1 in cell (i,j) means individual 
i was captured on occasion j and released live back into the population.  Because 
the population 
being sampled is assumed closed, deaths on capture (known removals) are not allowed. 
If deaths on capture occurred and an estimate of N at the beginning 
of the 
study is sought, remove the entire history, estimate N using this routine from
the remaining histories, and add back the number of deleted histories.</p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_remove">remove</code></td>
<td>
<p>A logical scalar, or vector of logical values, specifying which 
<code>capture</code> covariates to remove from the <code>recapture</code> model. By default
(<code>remove=FALSE</code>), no capture covariates are removed, meaning all terms
in the model for initial capture also appear in the model for recaptures 
<em>with the same coefficient values</em>.  See Details section.  If <code>remove</code>
is a vector, each entry specifies whether the corresponding effect in <code>capture</code> 
should be removed from the <code>recapture</code> model.  
If <code>remove</code> is shorter than NX (the number of matrices in 
<code>capture</code>), it is replicated to have length NX.</p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_cap.init">cap.init</code></td>
<td>
<p> (optional) Vector of initial values for coefficients in the initial 
capture model.  One element 
per covariate in <code>capture</code>. This parameter does not usually need to be specified. </p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_recap.init">recap.init</code></td>
<td>
<p> (optional) Vector of initial values for coefficients in the 
recapture model.  One element 
per covariate in <code>recapture</code>. This parameter does not usually need to be specified. </p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_nhat.v.meth">nhat.v.meth</code></td>
<td>
<p> Integer specifying method for computing variance estimate 
for the population size estimate. Currently, only <code>nhat.v.meth</code> = 1 is implemented. 
Plans are for <code>nhat.v.meth</code> = 2 to be a boot strap estimate of variance.
<code>nhat.v.meth</code> = 1 is a delta method estimator utilizing the derivative of 
P(ever captured) w.r.t. the capture parameters.  This is the same estimator as 
used in program MARK. </p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_df">df</code></td>
<td>
<p> External (override) model degrees of freedom to use during estimation.  
If <code>df</code> == NA, the number of parameters is estimated from the rank of the 
matrix of 2nd derivatives or Hessian, depending on <code>cov.meth</code> parameter.  
If <code>df</code> &lt;= 0, the number of parameters will be 
set to NX+NY = the number of estimated coefficients. Otherwise, if <code>df</code> &gt; 0, 
the supplied value is used.  Only AIC, QAIC, AICc, and QAICc are dependent on 
this value (in their penalty terms). </p>
</td></tr>
<tr><td><code id="F.huggins.estim_+3A_link">link</code></td>
<td>
<p>The link function to be used.  The link function converts linear predictors in the 
range (-infinity, infinity) to probabilities in the range (0,1).  Valid values for the link 
function are &quot;logit&quot; (default), &quot;sine&quot;, and &quot;hazard&quot;.  (see Examples in help for <code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code> 
for a plot of the link functions)
</p>

<ul>
<li><p> The &quot;logit&quot; link is <code class="reqn">\eta = log( \frac{p}{1 - p} )</code> with 
inverse <code class="reqn">p = \frac{1}{1 + exp(-\eta)}</code>.  
</p>
</li>
<li><p> The &quot;sine&quot; link is <code class="reqn">\eta = \frac{8asin( 2p - 1 )}{\pi}</code>, which ranges from -4 to 4. 
The inverse &quot;sine&quot; link is <code class="reqn">p = \frac{1 + sin( \eta\pi/8 )}{2}</code> for 
values of <code class="reqn">\eta</code> between 
-4 and 4.  For values of <code class="reqn">\eta</code> &lt; -4, <code class="reqn">p</code> = 0.  For values of  <code class="reqn">\eta</code> &gt; 4, <code class="reqn">p</code> = 1.
Scaling of the sine link was chosen to yield coefficients roughly the 
same magnitude as the logit link.
</p>
</li>
<li><p> The &quot;hazard&quot; link is <code class="reqn">\eta = log( -log( 1 - p ))</code>, with inverse 
<code class="reqn">1 - exp( -exp( \eta ))</code>.  The value of <code class="reqn">p</code> from the inverse hazard 
link approaches 0 as <code class="reqn">\eta</code> decreases.  For values of <code class="reqn">\eta</code> &gt; 3, <code class="reqn">p</code> = 1 
for all intents and purposes. 
</p>
</li></ul>

</td></tr>     
<tr><td><code id="F.huggins.estim_+3A_control">control</code></td>
<td>
<p>A list containing named control parameters for the minimization and estimation process. 
Control parameters include number of iterations, covariance estimation method, etc.  
Although the default values work in the vast majority of cases, changes to these 
variables can effect speed and performance for ill-behaved models. See 
<code>mra.control()</code> for a description of the individual control parameters.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This routine compiles all the 
covariate matrices, then calls a Fortran routine to maximize the 
Huggins closed population likelihood. So-called heterogeneous models 
that utilize mixture distributions for probability of capture cannot be
fitted via this routine.  
</p>
<p>If <code>remove=FALSE</code> (default) the models for initial capture and 
subsequent recapture are,
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = \beta_0 + \beta_1 x_{ij1} + \ldots + \beta_a x_{ija}</code>
</p>

<p>and     
</p>
<p style="text-align: center;"><code class="reqn">c_{ij} = \beta_0 + \beta_1 x_{ij1} + \ldots + \beta_a x_{ija} + 
        \gamma_0 + \gamma_1 z_{ij1} + \ldots + \gamma_b z_{ijb}</code>
</p>

<p>where the x's and z's are covariate values specified in <code>capture</code> 
and <code>recapture</code>, respectively, and the <code class="reqn">\beta</code>'s and 
<code class="reqn">\gamma</code>'s are estimated coefficients. (For brevity, 
'<em>a</em>' has been substituted for NX, '<em>b</em>' for NY.) In other words, by default 
all effects in the capture model also appear in the recapture model 
<em>with the same estimated coefficients</em>.  This is done so that 
capture and recapture probabilities can be constrained to equal one another. 
If <code>capture=~1</code> and <code>recapture=NULL</code>, capture and recapture 
probabilities are constant and equal to one another. 
If <code>capture=~x1</code> and <code>recapture=NULL</code>, capture and recapture 
probabilities are equal, and both are the exact same function of 
covariate <code>x1</code>. A simple additive 
behavioral (trap happy or trap shy) effect is fitted by specifying an 
intercept-only model for recaptures, i.e.,
<code>capture=~x1+x2+...+xp</code> and <code>recapture=~1</code>.  
</p>
<p>When a Huggin's model object is printed using the default 
print method (<code>print.hug</code>), a &quot;C&quot; (for &quot;capture&quot;) appears next to coefficients
in the recapture model that are also in the initial capture model.  These 
coefficients are fixed in the recapture model.  A &quot;B&quot; (for &quot;behavioral&quot;)
appears next to free coefficients in the recapture model that <em>do not</em>
appear in the initial capture model.  
</p>
<p>If <code>remove</code> is something other than FALSE, it is extended to have length
NX, and if element <em>i</em> equals TRUE, the <em>i</em>-th 
effect in the capture model is removed from the recapture model.  If 
<code>remove=c(FALSE, TRUE, FALSE)</code>, <code>capture=~x1+x2</code>, and 
<code>recapture=~x1+x3</code>, the models for initial capture and subsequent 
recapture are, 
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = \beta_0 + \beta_1 x_{ij1} + \beta_2 x_{ij2}</code>
</p>

<p>and     
</p>
<p style="text-align: center;"><code class="reqn">c_{ij} = \beta_0 + \beta_2 x_{ij2} + \gamma_0 + \gamma_1 x_{ij1} + \gamma_2 x_{ij3}.</code>
</p>

<p>Note that <code>x1</code> appears in the recapture equation, but with a 
different estimated coefficient. If <code>remove=TRUE</code>, all capture effects
are removed from the recapture model and the models are completely separate.
</p>
<p>The ability to remove terms from the recapture model adds modeling flexibility. 
For example, if initial captures were hypothesized to depend on the variable 
<code>sex</code>, but recaptures were hypothesized to be constant (no <code>sex</code> effect), 
the arguments to fit this model would be <code>capture=~sex</code>, <code>recapture=~1</code>, 
and <code>remove=TRUE</code>.  A pure time-varying model with different time 
effects in the initial and subsequent capture models can be fitted using 
<code>capture=~tvar(1:ns,nan)</code>, <code>recapture=~tvar(1:ns,nan)</code>, 
and <code>remove=TRUE</code>.  In this case, the same model, but parameterized differently, 
can be fitted with <code>remove=FALSE</code>.  
</p>
<p>See Details of <code>help(F.cjs.estim)</code> for ways that 2-d matrices, 1-d 
vectors, and 1-d factors can be specified in the capture and recapture
models.  
</p>
<p>If argument <code>trace</code> in a call to <code>mra.control</code> is set to something 
other than 0, a log file named <code>mra.log</code> is written to the current directory.  
See <code><a href="#topic+mra.control">mra.control</a></code> for actions associated with values of <code>trace</code>.
CAREFUL: <code>mra.log</code> is overwritten each run. 
</p>
<p>Values in 2-d Matrix Covariates: Even though covariate 
matrices are required to be NAN x NS (same size as capture histories), 
there are not that many recapture parameters. 
Recapture parameters for the first occasion are not defined. 
For all covariates in the recapture model, only values in 
columns 2:ncol(histories) are used.  See examples for demonstration. 
</p>


<h3>Value</h3>

<p>An object (list) of class c(&quot;hug&quot;,&quot;cr&quot;) with many components.
Use <code>print.hug</code> to print
it nicely. Use <code>names(fit)</code>, where the call was <code>fit &lt;- F.huggins.estim(...)</code>,
to see names of all returned components. To see values of individual components,
issue commands like fit\$n.hat, fit\$se.n.hat, etc.
</p>
<p>Components of the returned object are as follows:
</p>
<table>
<tr><td><code>histories</code></td>
<td>
<p>The input capture history matrix. Size NAN x NS</p>
</td></tr>
<tr><td><code>aux</code></td>
<td>
<p>Auxiliary information, mostly stored input values.
This is a list containing:
\$call,
\$nan=number of individuals,
\$ns=number of samples,
\$nx=number of coefficients in the initial capture model,
\$ny=number of coefficients in recapture model,
\$cov.name=names of the covariates in both models (initial capture covariates first, then recapture
covariates),
\$ic.name=name of capture history matrix,
\$mra.version=version number of this package,
\$R.version=R version used,
\$run.date=date the model was estimated.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Value of the Huggins log likelihood at it's maximum.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Model deviance = -2*<code>loglik</code>.  This is relative deviance
because all covariates are individual and time varying.  When individual
covariates are present, a saturated likelihood cannot be computed.  Use this
to compute deviance differences only.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC for the model = <code>deviance</code> + 2*(df).  df is either the estimated
number of independent parameters (by default), or NX+NY, or a specified value,
depending on the input value of <code>df</code> parameter.</p>
</td></tr>
<tr><td><code>aicc</code></td>
<td>
<p>AIC with small sample correction = AIC + (2*<code>df</code>*(<code>df</code>+1))
/ (<code>NAN</code> - <code>df</code> - 1)</p>
</td></tr>
<tr><td><code>capcoef</code></td>
<td>
<p>Vector of estimated coefficients in the initial capture model.
Length NX.</p>
</td></tr>
<tr><td><code>se.capcoef</code></td>
<td>
<p>Vector of estimated standard errors for coefficients in
initial capture model. Length NX.</p>
</td></tr>
<tr><td><code>recapcoef</code></td>
<td>
<p>Vector of estimated coefficients in the recapture model.
Length NY.</p>
</td></tr>
<tr><td><code>se.surcoef</code></td>
<td>
<p>Vector of standard errors for coefficients in recapture model.
Length NY.</p>
</td></tr>
<tr><td><code>covariance</code></td>
<td>
<p>Variance-covariance matrix for the estimated model coefficients.
Size (NX+NY) X (NX+NY).</p>
</td></tr>
<tr><td><code>p.hat</code></td>
<td>
<p>Matrix of estimated initial capture probabilities
computed from the model.  Size of this matrix is NAN x NS.
Cell (i,j) is estimated probability of first capture for individual i
during capture occasion j.</p>
</td></tr>
<tr><td><code>se.p.hat</code></td>
<td>
<p>Matrix of standard errors for estimated initial capture probabilities.
Size NAN x NS.</p>
</td></tr>
<tr><td><code>c.hat</code></td>
<td>
<p>Matrix of estimated recapture probabilities computed from the model.
Size NAN x NS.  Cell (i,j) is estimated probability of capturing individual i
during occasion j given that it was initially captured prior to j. </p>
</td></tr>
<tr><td><code>se.c.hat</code></td>
<td>
<p>Matrix of standard errors for estimated recapture probabilities.
Size NAN X NS.  </p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Number of estimable parameters in the model. <code>df</code> is either
the estimated number of independent parameters (by default) based on rank
of the variance matrix,
or NX+NY, or a specified value, depending on the input value of <code>df</code> parameter.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>A string indicating whether the maximization routine converged.</p>
</td></tr>
<tr><td><code>exit.code</code></td>
<td>
<p>Exit code from the maximization routine.
Interpretation for <code>exit.code</code> is in <code>message</code>.</p>
</td></tr>
<tr><td><code>cov.code</code></td>
<td>
<p>A code indicating the method used to compute the covariance matrix.</p>
</td></tr>
<tr><td><code>cov.meth</code></td>
<td>
<p>String indicating method used to compute covariance matrix.
Interprets <code>cov.code</code>.</p>
</td></tr>
<tr><td><code>n.hat</code></td>
<td>
<p>The Huggins estimate of population size.  This estimate is
sum( 1/ pstar(i) ), where pstar(i) is probability of observing individual i,
which equals 1 - p.hat[i,1]*p.hat[i,2]* ... *p.hat[i,NS], where p.hat is the
returned value of <code>p.hat</code>.</p>
</td></tr>
<tr><td><code>se.n.hat</code></td>
<td>
<p>Estimated standard error of <code>n.hat</code>.  Computed using method
specified in <code>nhat.v.meth</code>.</p>
</td></tr>
<tr><td><code>n.hat.lower</code></td>
<td>
<p>Lower limit of log based confidence interval for
<code>n.hat</code>.  </p>
</td></tr>
<tr><td><code>n.hat.upper</code></td>
<td>
<p>Upper limit of log based confidence interval for
<code>n.hat</code>.</p>
</td></tr>
<tr><td><code>n.hat.conf</code></td>
<td>
<p>Confidence level for the interval on <code>n.hat</code>.
Currently, confidence level cannot be changed
from 95%. </p>
</td></tr>
<tr><td><code>nhat.v.meth</code></td>
<td>
<p>Code for method used to compute variance of <code>n.hat</code>.  Currently,
this is 1 only.</p>
</td></tr>
<tr><td><code>num.caught</code></td>
<td>
<p>Number of individuals ever captured = number of
rows in the <code>histories</code> matrix.</p>
</td></tr>
<tr><td><code>n.effective</code></td>
<td>
<p>Effective sample size = number of observed individuals times
number of occasions = NAN * NS</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>References</h3>

 
<p>Huggins, R. M. 1989. On the statistical analysis of capture experiments. Biometrika 76:133-140.
</p>
<p>Amstrup, S. C., T. L. McDonald, and B. F. J. Manly (editors). 2005. Handbook of 
Capture-Recapture Analysis. Princeton University Press.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.hug">print.hug</a></code>, 
<code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fake the data for these examples
set.seed(3425)
ch.mat &lt;- matrix( round(runif(30*5)), nrow=30, ncol=5)
ch.mat &lt;- ch.mat[ apply(ch.mat,1,sum) &gt; 0, ]  # no zero rows allowed
ct &lt;- as.factor(1:ncol(ch.mat))
attr(ct,"nan") &lt;- nrow(ch.mat)   # used to fit time varying factor
sex &lt;- round(runif(nrow(ch.mat)))   # fake sex 
attr(sex,"ns") &lt;- ncol(ch.mat)

# Models parallel to the 8 Otis et al. models.
# see Amstrup et al. (2005, p. 77)

# Constant model (model M(0)).
hug.0 &lt;- F.huggins.estim( ~1, NULL, ch.mat )

# Time varying model (model M(t))
hug.t &lt;- F.huggins.estim( ~tvar(ct), NULL, ch.mat)

# Additive Behavioral model (model M(b))
hug.b &lt;- F.huggins.estim( ~1, ~1, ch.mat )

# Time and Behavioral model (model M(tb))
hug.tb &lt;- F.huggins.estim( ~tvar(ct), ~1, ch.mat )

# Individual effects (model M(h))
hug.h &lt;- F.huggins.estim( ~ivar(sex), NULL, ch.mat )

# Individual and Behavioral effects (model M(bh))
hug.bh &lt;- F.huggins.estim( ~ivar(sex), ~1, ch.mat )

# Individual and time effects (model M(th))
hug.th &lt;- F.huggins.estim( ~ivar(sex)+tvar(ct), NULL, ch.mat )

# Individual, time, and behavoral effects (model M(tbh))
hug.tbh &lt;- F.huggins.estim( ~ivar(sex)+tvar(ct), ~1, ch.mat )

# Time varying initial captures, recaptures are constant and depend on sex.
hug.custom1 &lt;- F.huggins.estim( ~tvar(ct), ~ivar(sex), ch.mat, remove=TRUE )

# Compare hug.custom1 to the following: Time varying initial captures with 
# time varying recaptures that depend on sex.
hug.custom2 &lt;- F.huggins.estim( ~tvar(ct), ~ivar(sex), ch.mat, remove=FALSE )

# Values in first column of recapture covariates do not matter. 
# Below, mod.1 and mod.2 are identical.
mod.1 &lt;- F.huggins.estim( ~tvar(ct), ~tvar( c( 0,1,2,3,4), nrow(ch.mat)), ch.mat, remove=TRUE)
mod.2 &lt;- F.huggins.estim( ~tvar(ct), ~tvar( c(-9,1,2,3,4), nrow(ch.mat)), ch.mat, remove=TRUE)




</code></pre>

<hr>
<h2 id='F.sat.lik'> F.sat.lik </h2><span id='topic+F.sat.lik'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of a fully saturated time varying CJS
model. Use to convert the relative deviance output by <code>F.cjs.estim</code> to
actual deviance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.sat.lik(ch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.sat.lik_+3A_ch">ch</code></td>
<td>
<p> A capture history matrix consisting of 0's, 1's, and 2's. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number reported as <code>deviance</code> by <code>F.cjs.estim</code> is relative 
deviance, calculated as -2*log(likelihood).  IF THERE ARE NO INDIVIDUAL-VARYING 
COVARIATES in the model, it is possible to compute the theoretical log-likelihood
for a set of data assuming perfect prediction.  This is the saturated log-likelihood. 
The actual deviance of a model is the deviance of the model relative to this 
theoretical maximum, computed as -2*((saturated log-likelihood) - 
2*(model log-likelihood)).  
</p>
<p>In the parameterization of <code>F.cjs.estim</code>, all covariates are potentially individual and 
time varying, and in this case the saturated log-likelihood is unknown. Consequently, 
the saturated likelihood is not often needed in MRA.  This routine was included 
as a utility function because the saturated likelihood is handy in some cases, including
parametric bootstrapping to estimate C-hat. 
</p>
<p>Assuming <code>cjs.fit</code> is an estimated CJS model with time varying
covariates only fit to histories in <code>cjs.hists</code>, compute deviance as 
</p>
<p><code>-F.sat.lik(cjs.hists) - 2*cjs.fit\$loglik</code> = 
<code>cjs.fit\$deviance - F.sat.lik(cjs.hists)</code>
</p>


<h3>Value</h3>

<p>A scalar equal to the value of the saturated CJS log-likelihood.  The 
saturated log-likelihood is the theoretical best predictive model possible, 
and actual deviance is calculated relative to this.  See Examples.
</p>


<h3>Note</h3>

 
<p>CAUTION: This routine works for time varying models only. If 
individual-varying or individual-and-time-varying covariates are fitted 
in the model, 
the routine cannot sense it and will run but yield an incorrect answer. 
Use relative deviance reported by <code>F.cjs.estim</code> in this case.
</p>
<p>Also, this routine will not run if animals have been removed (censored). I.e., the 
capture history matrix cannot have any 2's in it. Use relative deviance reported 
by <code>F.cjs.estim</code> when animals have been removed. 
</p>


<h3>Author(s)</h3>

<p> Eric V. Regehr (USGS, eregehr@usgs.gov) and Trent McDonald (WEST Inc., tmcdonald@west-inc.com) </p>


<h3>References</h3>

<p> Look up &quot;saturated model&quot; in the program MARK help file
for the equations implemented by this function. 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
deviance &lt;- -F.sat.lik( dipper.histories ) - 2*dipper.cjs$loglik
 </code></pre>

<hr>
<h2 id='F.step.cjs'>F.step.cjs - Stepwise model selection for CJS models.</h2><span id='topic+F.step.cjs'></span>

<h3>Description</h3>

<p>Conducts automated stepwise model selection of CJS models.  Selection includes
forward steps followed by backward looks.  Steps consider covariates in both the survival 
and probability of capture models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.step.cjs(cap.covars, surv.covars, fit.crit = "qaicc", signif.drop = 0, 
  signif.increase = 0, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.step.cjs_+3A_cap.covars">cap.covars</code></td>
<td>
<p>A character vector containing the names of single covariates or combinations of covariates 
to consider in the capture equation. See Details.</p>
</td></tr>
<tr><td><code id="F.step.cjs_+3A_surv.covars">surv.covars</code></td>
<td>
<p>A character vector containing the names of single covariates or combinations of covariates 
to consider in the survival equation. See Details.</p>
</td></tr>
<tr><td><code id="F.step.cjs_+3A_fit.crit">fit.crit</code></td>
<td>
<p>A character scalar specifying the model fit criterion to use during each step. This criterion 
will be used to rank variables 
during the forward steps and backward looks.  Possible values are &quot;qaicc&quot; (the default), 
&quot;aic&quot;, &quot;qaic&quot;, and &quot;aicc&quot;.  During forward (addition) steps, the variable(s) that 
decreased <code>fit.crit</code> the most will be added to the model, assuming that the decrease is greater
than or equal to <code>abs(signif.drop)</code> (see <code>signif.drop</code> for more). 
During backward (elimination) looks, the variable that increases <code>fit.crit</code> the most will be removed 
from the model, assuming 
that the increase is greater than or equal to <code>abs(signif.increase)</code>.  </p>
</td></tr>
<tr><td><code id="F.step.cjs_+3A_signif.drop">signif.drop</code></td>
<td>
<p>A scalar specifying the decrease in <code>fit.crit</code> that should be considered &quot;significant&quot; during 
forward steps. 
This argument controls stopping and is functionally equivalent to the alpha-to-enter  
parameter of classical stepwise routines. Stepwise selection stops
when the minimum <code>fit.crit</code> on the current iteration minus the minimum <code>fit.crit</code> 
on the previous iteration is greater than or equal to <code>signif.drop</code>. 
This means <code>signif.drop</code> should be less than or equal to 0, unless for some odd reason, 
steps that add variables without predictive abilities are desired.
If <code>signif.drop</code> = 0 (the default), steps are halted when no variables decrease <code>fit.crit</code>.  
Thus, the default method yields the minimum <code>fit.crit</code> model among those considered during 
stepwise selection.  If <code>signif.drop</code> = -2, steps are halted when <code>fit.crit</code> decreases by less than 
2 (or increases) between the 
current and previous steps.  </p>
</td></tr>
<tr><td><code id="F.step.cjs_+3A_signif.increase">signif.increase</code></td>
<td>
<p>A scalar specifying the increase in <code>fit.crit</code> that should be is considered 
&quot;significant&quot; during backward looks.  This argument controls elimination, 
but not stoppage.  A variable in the current model is a candidate for removal if, 
upon removal, <code>fit.crit</code> 
increases by less than or equal to <code>signif.increase</code>.  This means <code>signif.increase</code>
should be greater than or equal to 0 to be meaningful, unless no variables should be removed, 
in which case set <code>signif.increase = -Inf</code> (or some other negative number). If 2 or more 
variables are candidates for removal during a single backward look step, the variable which 
increases <code>fit.crit</code> the most will be removed (the other will remain).
If <code>signif.increase</code> = 0 (the default), variables are left in the model if they 
increase <code>fit.crit</code> when removed.  If <code>signif.increase</code> = 2, variables in the current model 
are left in the model if they increase <code>fit.crit</code> by more than 2 units when removed.</p>
</td></tr>
<tr><td><code id="F.step.cjs_+3A_plot">plot</code></td>
<td>
<p>A scalar specifying whether the minimum <code>fit.crit</code> at the end on each forward-backward step should be plotted. 
This plot can be useful for assessing which variable(s) cause relatively &quot;big&quot; and which cause 
relatively &quot;little&quot; jumps in <code>fit.crit</code>.</p>
</td></tr>
<tr><td><code id="F.step.cjs_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>F.cjs.estim</code>, like histories= , nhat.v.meth=, c.hat=, control=, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements of both the <code>cap.covars</code> and <code>surv.covars</code> 
arguments can specify the names of single covariates or sets of 
covariates to consider as a group to be included or excluded 
together. For example, if <code>cap.covars = c("sex", 
"ageclass1 + ageclass2 + ageclass3" )</code>, the routine will 
include and exclude <code>sex</code> as a single covariate with 1 
estimated coefficient and <code>ageclass1 + ageclass2 + 
ageclass3</code> as a set of 3 covariates (with 3 estimated 
coefficients) to be included and excluded as a set.  This is 
useful if factor covariates are pre-coded as indicator variables. In the 
example above, specifying <code>ageclass1 + ageclass2 + 
ageclass3</code> would make sense if age of an individual was 
classified into 1 of 4 classes, and <code>ageclassX</code> was a 
matrix with elements equal to 1 if the individual was in age 
class X during a capture occasion, and 0 otherwise.  
</p>
<p>Specifying a term like <code>a + 
b + ab</code> would ensure that main effect matrices (<code>a</code> 
and <code>b</code>) are included whenever the interaction matrix 
(<code>ab</code>) is included during model selection. However, this way 
of including interactions will only be useful if the main effects 
are not considered separately.  That is, specifying 
<code>cap.covars = c("a", "b", "a + b + ab")</code> will not work 
because the routine does not know that &quot;a&quot; and &quot;b&quot; are 
components of &quot;a + b + ab&quot;.  Nonsense models like 
&quot;a + b + ab + a + b&quot; could result. Thus, this routine is 
likely only useful for terms that do not include interactions. 
A useful way to proceed in this case may be to use stepwise 
to select a model of main effects, then consider interactions.  
</p>
<p>Time varying and individual varying variables can be specified 
using the <code>tvar</code> and <code>ivar</code> functions in the elements 
of <code>cap.covars</code> and <code>surv.covars</code>. For example, 
specifying <code>"tvar(year,nan=nrow(ch))"</code> as an element of 
<code>surv.covars</code>, where <code>year = 1:ncol(ch)</code> and 
<code>ch</code> is the capture history matrix,  will fit a linear 
year effect (1 coefficient) when this element is added during 
stepwise selection.  Likewise, factors are preserved during 
selection. If <code>year</code> in the above example had been a 
factor (i.e., <code>year = as.factor(1:ncol(ch))</code>), separate 
effects for each year (<code>ncol(ch) - 1</code> coefficients) would 
have been fitted when this effect came up for consideration 
during stepwise selection.   
</p>
<p>The variable to add or eliminate is selected after all variables 
in both the capture and survival models are considered.  That is, the
variable that decreases (or increases) <code>fit.crit</code> the most over both 
models is added. 
Selection does not iteratively fix one model and select variables 
in the other.  For example, on one step, the variable that decreases <code>fit.crit</code>
the most may be a survival covariate, while on the next step
the variable that decreases <code>fit.crit</code>
the most may be a capture covariate.    
</p>


<h3>Value</h3>

<p>The final CJS model resulting from application of stepwise model selection.  This object 
is a valid MRA CJS model and has class 'cjs'.  See help for <code>F.cjs.estim</code> for a 
description of the components of this object. </p>


<h3>Author(s)</h3>

<p>Trent McDonald, WEST-INC, tmcdonald@west-inc.com
</p>


<h3>See Also</h3>

<p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+F.fit.table">F.fit.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#   Aquire data and intermediate variables
data(dipper.histories)
data(dipper.males)
ch &lt;- dipper.histories
males &lt;- dipper.males
ns &lt;- ncol(ch)
nan &lt;- nrow(ch)

#   Construct covariates
small.t &lt;- as.factor( paste("T",1:ns, sep=""))
post.flood &lt;- as.numeric( 1:ns &gt;= 4 )
year &lt;- 1:ns - (ns / 2)
males.postflood &lt;- outer( c(males), post.flood ) # individual and time varying

print(dim(males.postflood))

#   Attach attributes to covariates.  For convienence only.
attr(small.t, "nan") &lt;- nan
attr(small.t, "drop") &lt;- c(1,2)
attr(year, "nan") &lt;- nan
attr(post.flood, "nan") &lt;- nan
attr(males, "ns") &lt;- ns

#   Define pool of variables to be considered in each model
cap.vars &lt;- c("tvar(small.t)","tvar(year)")
surv.vars &lt;- c("tvar(small.t)","tvar(year)", "tvar(post.flood)", "ivar(males)",
  "males.postflood")

#   Do stepwise selection
final.fit &lt;- F.step.cjs( cap.vars, surv.vars, histories=ch, 
  control=mra.control(maxfn=500, cov.meth=2) )


</code></pre>

<hr>
<h2 id='F.update.df'> F.update.df - Update degrees of freedom in a Cormack-Jolly-Seber fitted object </h2><span id='topic+F.update.df'></span>

<h3>Description</h3>

<p>Updates the degrees of freedom in a fitted object to either the value estimated from the rank of the variance-covariance matrix, the
number of coefficients, or a user-specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F.update.df(fit, df=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F.update.df_+3A_fit">fit</code></td>
<td>
<p> An MRA fitted CJS model.  Class must be c(&quot;cjs&quot;, &quot;cr&quot;). These are produced by <code>F.cjs.estim</code>. </p>
</td></tr>
<tr><td><code id="F.update.df_+3A_df">df</code></td>
<td>
<p> The new value for degrees of freedom.
If <code>df</code> == NA, the number of parameters estimated from the rank of the
matrix of 2nd derivatives or Hessian, depending on <code>cov.meth</code> parameter.
If <code>df</code> &lt;= 0, the number of parameters will be
set to NX+NY = the number of estimated coefficients. Otherwise, if <code>df</code> &gt; 0,
the supplied value is used.  The penalty terms of AIC, QAIC, AICc, and QAICc are recomputed using this value.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object (list) of class c(&quot;cjs&quot;,&quot;cr&quot;) with degrees of freedom, AIC, QAIC, AICc, and QAICc updated. </p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Fit CJS model to dipper data, time-varying capture and survivals.
data(dipper.histories)
ct &lt;- as.factor( paste("T",1:ncol(dipper.histories), sep=""))
attr(ct,"nan")&lt;-nrow(dipper.histories)
dipper.cjs &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(ct,drop=c(1,6,7)), dipper.histories )

## Update the degrees of freedom
dipper.cjs &lt;- F.update.df( dipper.cjs, -1 )

</code></pre>

<hr>
<h2 id='ivar'> Expand Individual-varying covariates in models </h2><span id='topic+ivar'></span>

<h3>Description</h3>

<p>Expands a vector of individual-varying values into a 2-d matrix 
of the appropriate size for use in MRA model formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivar(x, ns=attr(x,"ns"), drop.levels=attr(x,"drop.levels"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivar_+3A_x">x</code></td>
<td>
<p> The vector of individual varying values to expand.  This can be 
a factor (see <code>as.factor</code>). It is assumed that <code>length(x)</code> = 
number of individuals.  If not, an error will occur in whatever routine 
called this function (e.g., <code>F.3d.model.matrix</code>). </p>
</td></tr>
<tr><td><code id="ivar_+3A_ns">ns</code></td>
<td>
<p> Number of sampling occasions. Default is to use the 'ns' attribute 
of <code>x</code>.  If <code>ns</code> is not specified or is not an attribute of <code>x</code>, 
an error is thrown. </p>
</td></tr>
<tr><td><code id="ivar_+3A_drop.levels">drop.levels</code></td>
<td>
<p> A vector of integers specifying which levels of a factor 
to drop.  Only applicable if <code>x</code> is a factor.  By default, the 
the 'drop.levels' attribute of <code>x</code> is used.  If <code>x</code> does not 
have a 'drop.levels' attribute, the first level of the factor is dropped. 
<code>drop.levels=length(levels(x))</code>
does the SAS thing and drops the last level of a factor.  Specifying multiple 
levels to drop is acceptable. E.g., <code>drop.levels=c(1,2,7)</code> drops 
the 1st, 2nd, and 7th levels of the factor, whatever they are.  First level 
of a factor is first element of <code>levels(x)</code>.  Second level 
of a factor is second element of <code>levels(x)</code>, and so on.  Setting  
<code>drop.levels</code> to 0, a negative number, or a number greater than the number 
of levels will not drop any levels (this is so-called cell mean coding). 
Keep in mind presence of the intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-d matrix of size <code>length(x)</code> x <code>ns</code> suitable for passing to the 
Fortran DLL of MRA for estimation.  Values within rows are constant, values 
across rows vary according to <code>x</code>. If <code>x</code> is a factor, this matrix 
contains 0-1 indicator functions necessary to fit the factor. 
</p>
<p>If <code>x</code> is a factor, attributes of the returned matrix are 
&quot;levels&quot; = levels of the factor and &quot;contr&quot; = contrasts used in the coding (always
<code>contr.treatment</code>).  For other contrast coding of factors, make your own 
2-d matrix with a call to the appropriate function (like <code>contr.poly</code>).     
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+tvar">tvar</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
nan &lt;- 30
ns &lt;- 5
age &lt;- as.factor(sample( c("J","S1","S2","Adult"), size=nan, replace=TRUE ))
attr(age,"ns") &lt;- ns

# Note that levels get reordered (by R default, alphabetically)
attr(age,"drop.levels") &lt;- (1:length(levels(age)))[ levels(age) == "J" ]

age.mat &lt;- ivar(age)  # level J is the reference
age.mat &lt;- ivar(age, drop=4) # level S2 is the reference

# Look at 3-D matrix produced when called with a factor.
dim(age.mat) &lt;- c(nan,ns,length(levels(age))-1)
print(age.mat)  # each page is the 2-d matrix used in the fit.
print(age.mat[1,,])

age.mat &lt;- ivar(age, drop=c(3,4))  # level S1 and S2 are combined and are the reference

# compare above to 
ivar( c(1,1,2,2,3,3), 5 )

</code></pre>

<hr>
<h2 id='lines.cjs'> lines.cjs </h2><span id='topic+lines.cjs'></span>

<h3>Description</h3>

<p>Add a line to an existing CJS capture-recapture plot showing either N or survival estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'cjs'
lines( x, what="n", animals=-1, occasions=-1, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.cjs_+3A_x">x</code></td>
<td>
<p> CJS object from <code>F.cr.estim</code> </p>
</td></tr>
<tr><td><code id="lines.cjs_+3A_what">what</code></td>
<td>
<p> Indicator for what to plot.  what = &quot;n&quot; plots estimates of size (i.e,. \$n.hat). 
what = &quot;s&quot; plots estimates of survival. </p>
</td></tr>
<tr><td><code id="lines.cjs_+3A_animals">animals</code></td>
<td>
<p> Index of animals to plot.  This is the row number for 
animals to include.  E.g., if <code>animals = c(1,4,10)</code>, the 1st, 4th, and 10th animals
represented in the 1st, 4th, and 10th rows of the capture history matrix are plotted. 
Applies to survival estimates only. </p>
</td></tr>
<tr><td><code id="lines.cjs_+3A_occasions">occasions</code></td>
<td>
<p> Sampling occasions to plot.  This must match the occasions argument to 
the last <code>plot.cjs</code>.  If the first element of <code>occasions</code> is &lt;= 0, 
all occasions are plotted.  Otherwise, only occasions listed in <code>occasions</code>
are plotted.</p>
</td></tr>
<tr><td><code id="lines.cjs_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>lines</code> (for N estimates) or <code>matlines</code> (for survival 
estimates).  Arguments like <code>col=</code> and <code>lty=</code> may prove useful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility function for plotting.  Lines are added to the current plot.  
A current plot must be displayed.  
</p>


<h3>Value</h3>

<p>Nothing.  A value of 1 is invisibly returned. 
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST Inc., tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cjs">plot.cjs</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+matlines">matlines</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 

# Fit constant capture probability, period (i.e., flood) effects on survival
dipper.cjs &lt;- F.cjs.estim( ~1, ~x2+x3, dipper.histories )  

plot(dipper.cjs, type="s", animals=1)
lines(dipper.cjs, what="s", animals=c(4, 10))

</code></pre>

<hr>
<h2 id='mra.control'> mra.control - Control over MRA fitting process</h2><span id='topic+mra.control'></span>

<h3>Description</h3>

<p>Auxiliary function providing a user interface for 
<code>mra</code> fitting. Typically only used when calling one of the 
<code>*.estim</code> routines. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra.control(algorithm=1, maxfn=1000, cov.meth=1, trace=0, tol=1e-07 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra.control_+3A_algorithm">algorithm</code></td>
<td>
<p> Integer specifying the maximization algorithm to use.  If <code>algorithm</code> = 1, 
the VA09AD algorithm from the HSL library is used. The VA09AD algorithm is very reliable, 
has been tested extensively (same algorithm as Program MARK), and will almost always find the 
maximum likelihood estimates. This parameter was added to allow easy addition of other 
algorithms in the future, but no other options are currently implemented because VA09AD 
works so well. Anything other than 1 throws a warning and resets the value 
to 1.  </p>
</td></tr>
<tr><td><code id="mra.control_+3A_maxfn">maxfn</code></td>
<td>
<p>Maximum number of likelihood evaluations allowed during the fitting process.
This determines when the minimization routine stops and concludes that the problem 
will not converge.  The routine stops after the likelihood has been evaluated 
<code>maxfn</code> times within the minimization routine (but not the hessian or gradient routine).    
Decreasing this value will cause the fitting routine to give up on badly-behaved 
models quicker and return faster.  In some simulation where ill-conditioned data 
can be generated, decreasing this parameter can speed up the 
simulation tremendously. 
Increasing this value may allow marginally-behaved (slow to converge) models to converge. 
</p>
</td></tr>
<tr><td><code id="mra.control_+3A_cov.meth">cov.meth</code></td>
<td>
<p> Integer specifying the covariance estimation method. <code>cov.meth</code> = 1 
takes numerical 2nd partial derivatives.  <code>cov.meth</code> = 2 inverts the Hessian 
of the maximization.  Method 1 (numeric 2nd derivatives) is the preferred method, but
is computationally expensive and therefore slower than method 2.  The difference in 
speed is minimal when number of parameters &lt; 15. Method 2 variances are 
generally very close to method 1 variances, and could be used during initial model 
fitting stages when exact estimation of variance may not be necessary.    </p>
</td></tr>
<tr><td><code id="mra.control_+3A_trace">trace</code></td>
<td>
<p>Integer controlling output of intermediate results. If <code>trace</code> != 0, 
a few lines will be written to the R console and a log file (named <code>mra.log</code>) will be 
opened in the current directory and details of the fitting process will 
be written there.  The level of detail written to the log depends on the value of trace. 
If <code>trace</code> == 1, details written to the log include TEST2 and TEST3 results used to determine 
c-hat, details from the fitting algorithm, the variance covariance matrix, 
singular values of the VC matrix used to determine <code>df</code>, and other 
statistics. If <code>trace</code> == 2, all trace == 1 details plus the likelihood output is written 
to the log.  If <code>trace</code> == 3, all trace == 2 details plus the gradient is written 
to the log.  
</p>
<p>When using <code>algorithm</code> = 1 (VA09AD), <code>trace</code> has additional meaning. If <code>trace</code> &gt; 3, 
the coefficient and gradient vectors are written every |trace| iterations and also on exit.
Output is of the form: Function value, beta(1), beta(2), ..., beta(n), G(1), ...G(n). 
Coefficient and gradient values are suppressed if <code>trace</code> &lt; 0 (only final results printed).  
Intermediate values from within VA09AD are suppressed if <code>trace</code> &gt; <code>maxit</code> + 1, but 
other intermediate values are output. 
</p>
<p><code>trace</code> &gt; 1 probably produces more output than the casual (non-geek statistician) wants 
to look at. But, geek statisticians may find <code>trace</code> &gt; 3 useful for assessing stability and 
determining when the routine gets stuck in a local minima. 
</p>
</td></tr>
<tr><td><code id="mra.control_+3A_tol">tol</code></td>
<td>
<p>Vector or scalar of tolerance(s) for coefficients in the model.  Minimization stops and 
concludes it has converged when |delta.b(i)| &lt; tol(i) for all i, where delta.b(i) is
change in parameter i on an iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the input arguments as components.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

<p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+F.huggins.estim">F.huggins.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dipper.histories)
ct &lt;- as.factor( paste("T",1:ncol(dipper.histories), sep=""))
attr(ct,"nan")&lt;-nrow(dipper.histories)
dipper.cjs &lt;- F.cjs.estim( ~tvar(ct,drop=c(1,2)), ~tvar(ct,drop=c(1,6,7)), 
  dipper.histories, control=mra.control(trace=1, maxfn=200) )

</code></pre>

<hr>
<h2 id='plot.cjs'> Plot CJS Model </h2><span id='topic+plot.cjs'></span>

<h3>Description</h3>

<p>Plot the population size or survival estimates for a Cormack-Jolly-Seber 
model estimated by F.cjs.estim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cjs'
plot(x, type="n", ci = TRUE, smooth = TRUE, occasions = -1, 
	animals = -1, smubass = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cjs_+3A_x">x</code></td>
<td>
<p> An object of class 'cjs'.  Objects of this 
class are estimated open population Cormack-Jolly-Seber models produced by F.cjs.estim.</p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_type">type</code></td>
<td>
<p> Type of estimates to plot.  type = &quot;n&quot; (the default) produces 
a plot of population size estimates versus capture occasion. 
type = &quot;s&quot; produces
a plot of survival estimates versus capture occasion.  </p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_ci">ci</code></td>
<td>
<p>Plot confidence intervals? If ci=TRUE, confidence intervals 
around population size or survival estimates are plotted (depending on 'type='), otherwise, only 
confidence intervals are not plotted.</p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_smooth">smooth</code></td>
<td>
<p>Smooth estimates of population size? If type=&quot;n&quot;, smooth=TRUE will produce 
a smoothed (supsmu) line through plotted size estimates. Ignored for type=&quot;s&quot;. </p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_occasions">occasions</code></td>
<td>
<p>Vector of occasion numbers to use in plot. If any(occasions &lt;= 0), 
all occasions are plotted.  Otherwise, plot the occasions specified. For example, 
if occasions = c(1,3,5), only estimates from the 1st, 3rd, and 5th capture 
occasion are plotted.  If type = &quot;n&quot;, occasion = 1 (1st occasion) cannot 
be plotted because it can't be estimated.  If type = &quot;s&quot;, occasion = ncol(y) 
(last occasion) cannot 
be plotted because no survival interval exist beyond the end of the study.</p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_animals">animals</code></td>
<td>
<p>Vector of individuals to plot.  This parameter is used only when plotting
survival estimates.  For example, animals = c(1,2,10) plots the 
survival estimates of the 1st, 2nd, and 10th animals (rows 1, 2, and 10 of the survival 
estimate matrix).</p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_smubass">smubass</code></td>
<td>
<p>Bass parameter for super-smoothed line, if called for by smooth=TRUE. 
Must be between 0
and 10.  Larger numbers produce smoother lines.</p>
</td></tr>
<tr><td><code id="plot.cjs_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot</code> (for size estimates) or <code>matplot</code> (for 
survival estimates). Options such as ylim=, col=, cex.axis=, etc. may be useful. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence intervals on survival estimates cannot be plotted with this routine. To plot confidence
intervals surrounding survival estimates, call this routine with type=&quot;s&quot;, then compute 
confidence intervals for survival estimates, and use <code>lines</code> to add lines to the plot.
</p>


<h3>Value</h3>

<p>For type=&quot;s&quot;, the survival estimate matrix that was plotted is 
is invisibly returned.  For type = &quot;n&quot;, the smooth fit is invisibly returned if called for 
by smooth = TRUE, otherwise NA is invisibly returned if smooth = FALSE.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) }
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
plot(dipper.cjs)
print(dipper.cjs$s.hat)
plot(dipper.cjs, type="s", animals=1)
 </code></pre>

<hr>
<h2 id='plot.nhat'> Plot size estimates </h2><span id='topic+plot.nhat'></span>

<h3>Description</h3>

<p>Plot the population size estimates for a Cormack-Jolly-Seber 
model estimated by F.cjs.estim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nhat'
plot(x, ci = TRUE, smooth = TRUE, occasions = -1, 
	smubass = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.nhat_+3A_x">x</code></td>
<td>
<p> An object of class 'nhat', which inherits from 'cjs'.  Objects of this 
class are estimated open population Cormack-Jolly-Seber models produced by F.cjs.estim.</p>
</td></tr>
<tr><td><code id="plot.nhat_+3A_ci">ci</code></td>
<td>
<p>Plot confidence intervals? If ci=TRUE, confidence intervals 
around population size or survival estimates are plotted (depending on 'type='), otherwise, only 
confidence intervals are not plotted.</p>
</td></tr>
<tr><td><code id="plot.nhat_+3A_smooth">smooth</code></td>
<td>
<p>Smooth estimates of population size? If type=&quot;n&quot;, smooth=TRUE will produce 
a smoothed (supsmu) line through plotted size estimates. Ignored for type=&quot;s&quot;. </p>
</td></tr>
<tr><td><code id="plot.nhat_+3A_occasions">occasions</code></td>
<td>
<p>Vector of occasion numbers to use in plot. If any(occasions &lt;= 0), 
all occasions are plotted.  Otherwise, plot the occasions specified. For example, 
if occasions = c(1,3,5), only estimates from the 1st, 3rd, and 5th capture 
occasion are plotted.  If type = &quot;n&quot;, occasion = 1 (1st occasion) cannot 
be plotted because it can't be estimated.  If type = &quot;s&quot;, occasion = ncol(y) 
(last occasion) cannot 
be plotted because no survival interval exist beyond the end of the study.</p>
</td></tr>
<tr><td><code id="plot.nhat_+3A_smubass">smubass</code></td>
<td>
<p>Bass parameter for super-smoothed line, if called for by smooth=TRUE. 
Must be between 0
and 10.  Larger numbers produce smoother lines.</p>
</td></tr>
<tr><td><code id="plot.nhat_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot</code> (for size estimates) or <code>matplot</code> (for 
survival estimates). Options such as ylim=, col=, cex.axis=, etc. may be useful. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The smooth fit is invisibly returned if called for 
by smooth = TRUE, otherwise NA is invisibly returned.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+plot.cjs">plot.cjs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(dipper.histories)
dipper.cjs &lt;- F.cjs.estim( ~1, ~1, dipper.histories )
plot(dipper.cjs,type="n")

# See examples for F.cr.model.avg for a way to plot model averaged population size estimates.

</code></pre>

<hr>
<h2 id='predict.cjs'> predict.cjs </h2><span id='topic+predict.cjs'></span>

<h3>Description</h3>

 
<p>Predictor method for CJS capture-recapture objects.  Return expected 
values for all active cells in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cjs'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cjs_+3A_object">object</code></td>
<td>
<p>CJS capture-recapture model as output from F.cjs.estim </p>
</td></tr>
<tr><td><code id="predict.cjs_+3A_...">...</code></td>
<td>
<p> Additional arguments to other functions.  Not used, but must be here 
for compatibility with the generic <code>predict</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only components of <code>cjsobj</code> needed are <code>$histories</code>, <code>$p.hat</code>, <code>$s.hat</code>
</p>


<h3>Value</h3>

<p>A nan X ns matrix of fitted values (=cell expected value), where 
nan=number of animals and ns=number of samples.  Fitted values in the 
non-active cells are set to NA.  Non-active 
cells are those prior to and including the initial capture, and after 
the occasion on which an animal is known to have died.  Computation of 
expected values is described in the <code>details</code> section of the help file 
for <code>F.cjs.gof</code>.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST Inc., tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+F.cjs.gof">F.cjs.gof</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit CJS model to dipper data, time-varying capture and survivals.
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
dipper.expected &lt;- predict(dipper.cjs)

</code></pre>

<hr>
<h2 id='print.cjs'> Print Cormack-Jolly-Seber (CJS) Models </h2><span id='topic+print.cjs'></span>

<h3>Description</h3>

<p>Print method for Cormack-Jolly-Seber (CJS) models estimated by F.cjs.estim().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cjs'
print(x, alpha=c(0.05,0.01), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cjs_+3A_x">x</code></td>
<td>
<p> An object of class &quot;cjs&quot; produced by F.cjs.estim()</p>
</td></tr>
<tr><td><code id="print.cjs_+3A_alpha">alpha</code></td>
<td>
<p> A vector with length either 2 or 3 containing alpha levels 
used to put &quot;*&quot; or &quot;**&quot; beside the GOF results. 
One * is printed if significance is between alpha[1] and alpha[2] 
(i.e., if alpha[2] &lt; p &lt; alpha[1]).  Two ** are printed if significance 
is less than alpha[2] (p &lt; alpha[2]).
</p>
</td></tr>
<tr><td><code id="print.cjs_+3A_...">...</code></td>
<td>
<p> Arguments to other functions called by this one. Currently no other 
functions are called, so this is not used, but must be here 
for compatibility with the generic <code>print</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.  This function is used exclusively for its side effects.  It prints
an object of class &quot;cjs&quot; in a nice human-readable format.  If goodness-of-fit tests are present, 
they are printed.  If population size estimates are present, they are printed. 
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, Ph.D., WEST-INC, tmcdonald@west-inc.com  </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+plot.cjs">plot.cjs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Fit CJS model to dipper data, time-varying capture and survivals.
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
print(dipper.cjs)
 </code></pre>

<hr>
<h2 id='print.hug'> Print Huggin's Model objects </h2><span id='topic+print.hug'></span>

<h3>Description</h3>

<p>Print method for Huggin's closed population model objects 
estimated by F.huggins.estim().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hug'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hug_+3A_x">x</code></td>
<td>
<p> An object of class &quot;hug&quot; produced by F.huggins.estim()</p>
</td></tr>
<tr><td><code id="print.hug_+3A_...">...</code></td>
<td>
<p> Arguments to other functions called by this one. Currently no other 
functions are called, so this is not used, but must be here 
for compatibility with the generic <code>print</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are no free covariates in the recapture model (i.e., <code>recapture=NULL</code>), 
only the combined capture and recapture model is printed. If the recapture 
model has coefficients, coefficients in both are printed in separate columns. 
</p>
<p>When a recapture model has free coefficients, 
a &quot;C&quot; (for &quot;capture&quot;) appears next to coefficients
in the recapture model that also appear in the capture model.  These 
coefficients are fixed in the recapture model because they 
are not free.  These values were estimated from initial capture information.  
A &quot;B&quot; (for &quot;behavioral&quot;)
appears next to free coefficients in the recapture model that <em>do not</em>
appear in the initial capture model.  
</p>


<h3>Value</h3>

<p>Nothing is returned.  This function is used exclusively for its side effects.  It prints
an object of class &quot;hug&quot; in a nice human-readable format.  
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, Ph.D., WEST-INC, tmcdonald@west-inc.com  </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.huggins.estim">F.huggins.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 

data(dipper.histories)
dipper.fit &lt;- F.huggins.estim( ~1, histories= dipper.histories )
print(dipper.fit)

 </code></pre>

<hr>
<h2 id='print.nhat'> print.nhat </h2><span id='topic+print.nhat'></span>

<h3>Description</h3>

<p>Print the estimates of N from a CJS object in a nice format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
## S3 method for class 'nhat'
print(x, width=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.nhat_+3A_x">x</code></td>
<td>
<p>An object of class &quot;nhat&quot;, which inherits from class &quot;cr&quot;.  This class of object is 
output from <code>F.cr.model.avg</code>. </p>
</td></tr>
<tr><td><code id="print.nhat_+3A_width">width</code></td>
<td>
<p>The minimum width of columns in the table printed by this routine.</p>
</td></tr> 
<tr><td><code id="print.nhat_+3A_...">...</code></td>
<td>
<p>Arguments to other functions called by this one. Currently no other 
functions are called, so this is not used, but must be here 
for compatibility with the generic <code>print</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Horvitz-Thompson estimates of N, along with 
standard errors, are printed.  <code>print.cjs</code> also prints N estimates, if present, 
but as a brief, one-row summary.  This routine prints a more complete table.  Numerical 
values of the <code>supsmu</code> smooth of N estimates (<code>bass</code> = 0.5) associated with 
plots produced by <code>plot.cjs</code> are printed. 
</p>


<h3>Value</h3>

<p> Nothing.  Run for side effects </p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.cjs">plot.cjs</a></code>, <code><a href="#topic+print.cjs">print.cjs</a></code>, <code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit CJS model to dipper data, time-varying capture and survivals.
data(dipper.histories)

# Method 1: explicit matricies
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
print(dipper.cjs)

# Method 2: indicator vectors
x &lt;- factor(1:ncol(dipper.histories), labels=paste("t",1:ncol(dipper.histories),sep=""))
nd &lt;- nrow(dipper.histories)
dipper.cjs &lt;- F.cjs.estim( ~tvar(x,nan=nd,drop=c(1,7)), ~tvar(x,nan=nd,drop=c(6,7)), 
    dipper.histories)
print(dipper.cjs)

</code></pre>

<hr>
<h2 id='residuals.cjs'> Residuals for CJS Model </h2><span id='topic+residuals.cjs'></span>

<h3>Description</h3>

<p>Residual extraction routine for a CJS object. Returns Pearson or deviance residuals 
of a CJS capture-recapture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cjs'
residuals(object, type="pearson", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.cjs_+3A_object">object</code></td>
<td>
<p> a CJS (Cormack-Jolly-Seber capture-recapture) object, which is usually 
the result of calling F.cjs.estim  </p>
</td></tr>
<tr><td><code id="residuals.cjs_+3A_type">type</code></td>
<td>
<p> string indicating type of residual to return.  Either &quot;pearson&quot; for Pearson
residuals (i.e., (o - e)/sqrt(e*(1-e))) or &quot;deviance&quot; for deviance 
residuals (i.e., 2*sign(o-e)*sqrt(o*log(o/e) + (1-o)*log((1-o)/(1-e))) ) </p>
</td></tr>
<tr><td><code id="residuals.cjs_+3A_...">...</code></td>
<td>
<p> Additional arguments to other functions. Not used, but must be here 
for compatibility with the generic <code>residuals</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In almost all cases, a CJS model fitted by F.cjs.estim already has a <code>$residuals</code> component.  This 
routine either extracts this component, or computes residuals of the component if not found.
</p>
<p>Observed component (o(ij)) in formulas above is the capture indicator for animal i during occasion j.  If animal i 
was seen during occasion j, o(ij) = 1.  Otherwise, o(ij) = 0.
</p>
<p>Expected component (e(ij)) in formula above is the expected value of the capture indicator for animal 
i during occasion j.  In other words, o(ij) is a binomial random variable with expected 
value e(ij).  Under the assumptions of a CJS model, e(ij) is computed as 
phi(i(1)) * phi(i(2)) * ... * phi(i(j-1)) * p(ij), where 
p(ij) is the estimated capture probability of animal i during occasion j, and phi(i(1)) is estimated survival during the first interval 
following initial capture of the animal, phi(i(2)) is survival during the second interval 
after initial capture, 
and phi(i(j-1)) is survival during the interval just prior to occasion j.      
</p>


<h3>Value</h3>

<p>A NAN X NS matrix of residuals, where NAN = number of animals and NS = number of
capture occasions.  Residuals in the non-active cells are set to NA.  Non-active 
cells are those prior to and including the initial capture, and after 
the occasion on which an animal is known to have died.
</p>
<p>If type = &quot;pearson&quot;, the residual for active cell (i,j) is 
(o(ij) - e(ij)) / sqrt(e(ij) * (1 - e(ij))). 
</p>
<p>If type = &quot;deviance&quot;, the residual for active cell (i,j) is 
2 * sign(o(ij) - e(ij)) * sqrt(o(ij)*log(o(ij) / e(ij)) + (1 - o(ij)) * log((1 - o(ij)) / (1 - e(ij)))). 
</p>
<p>Observed (o(ij)) and expected (e(ij)) are defined in Details.
</p>


<h3>Author(s)</h3>

<p> Trent McDonald </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+predict.cjs">predict.cjs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit CJS model to dipper data, time-varying capture and survivals.
data(dipper.histories)
xy &lt;- F.cjs.covars( nrow(dipper.histories), ncol(dipper.histories) )
for(j in 1:ncol(dipper.histories)){ assign(paste("x",j,sep=""), xy$x[,,j]) } 
dipper.cjs &lt;- F.cjs.estim( ~x2+x3+x4+x5+x6, ~x1+x2+x3+x4+x5, dipper.histories )
residuals(dipper.cjs)

</code></pre>

<hr>
<h2 id='tvar'> Expand Time-varying covariates in models </h2><span id='topic+tvar'></span>

<h3>Description</h3>

<p>Expands a vector of time-varying values into a 2-d matrix 
for use in MRA model formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvar(x, nan=attr(x,"nan"), drop.levels=attr(x,"drop.levels"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvar_+3A_x">x</code></td>
<td>
<p> The vector of time varying values to expand.  This can be 
a factor (see <code>as.factor</code>). It is assumed that <code>length(x)</code> = 
number of sampling occasions.  If not, an error will occur in whatever routine 
called this function (e.g., <code>F.3d.model.matrix</code>). </p>
</td></tr>
<tr><td><code id="tvar_+3A_nan">nan</code></td>
<td>
<p> Number of individuals. Default is to use the 'nan' attribute 
of <code>x</code>.  If <code>nan</code> is not specified or is not an attribute of <code>x</code>, 
an error is thrown. </p>
</td></tr>
<tr><td><code id="tvar_+3A_drop.levels">drop.levels</code></td>
<td>
<p> A vector of integers specifying which levels of a factor 
to drop.  Only applicable if <code>x</code> is a factor.  By default, the 
the 'drop.levels' attribute of <code>x</code> is used.  If <code>x</code> does not 
have a 'drop.levels' attribute, the first level of the factor is dropped.  
<code>drop.levels=length(levels(x))</code>
does the SAS thing and drops the last level of a factor.  Specifying multiple 
levels to drop is acceptable.
E.g., <code>drop.levels=c(1,2,7)</code> drops 
the 1st, 2nd, and 7th levels of the factor.  First level 
of a factor is first element of <code>levels(x)</code>.  Second level 
of a factor is second element of <code>levels(x)</code>, and so on.  Setting  
<code>drop.levels</code> to 0, a negative number, or a number greater than the number 
of levels will not drop any levels (this is so-called cell mean coding). 
Keep in mind presence of the intercept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-d matrix of size <code>nan</code> x <code>length(x)</code> suitable for passing to the 
Fortran DLL of MRA for estimation.  Values within columns are constant, values 
across columns vary according to <code>x</code>. If <code>x</code> is a factor, this matrix 
contains 0-1 indicator functions necessary to fit the factor. 
</p>
<p>If <code>x</code> is a factor, attributes of the returned matrix are 
&quot;levels&quot; = levels of the factor and &quot;contr&quot; = contrasts used in the coding (always
<code>contr.treatment</code>).  For other contrast coding of factors, make your own 
2-d matrix with a call to the appropriate function (like <code>contr.poly</code>).     
</p>


<h3>Author(s)</h3>

<p> Trent McDonald, WEST-INC, tmcdonald@west-inc.com </p>


<h3>See Also</h3>

 <p><code><a href="#topic+F.cjs.estim">F.cjs.estim</a></code>, <code><a href="#topic+tvar">tvar</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
nan &lt;- 30
ns &lt;- 5
time.occ &lt;- as.factor(paste("T",1:ns, sep=""))
attr(time.occ,"nan") &lt;- nan
attr(time.occ,"drop.levels") &lt;- ns

time.mat &lt;- tvar(time.occ) # Last occasion is the reference, the SAS and MARK default.

time.mat &lt;- tvar(as.factor(1:ns),nan,ns) #equivalent to above.

#   Look at 3-d matrix produced when called with factors
dim(time.mat) &lt;- c(nan,ns,length(levels(time.occ))-1)
print(time.mat)  # each page is the 2-d matrix used in the fit.
print(time.mat[1,,])

#  compare above to 
tvar( 1:ns, nan )


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
