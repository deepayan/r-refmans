<!DOCTYPE html><html><head><title>Help for package stochvol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stochvol}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#exrates'><p>Euro exchange rate data</p></a></li>
<li><a href='#extractors'><p>Common Extractors for 'svdraws' and 'svpredict' Objects</p></a></li>
<li><a href='#get_default_fast_sv'><p>Default Values for the Expert Settings</p></a></li>
<li><a href='#logret'><p>Computes the Log Returns of a Time Series</p></a></li>
<li><a href='#paradensplot'><p>Probability Density Function Plot for the Parameter Posteriors</p></a></li>
<li><a href='#paratraceplot'><p>Trace Plot of MCMC Draws from the Parameter Posteriors</p></a></li>
<li><a href='#paratraceplot.svdraws'><p>Trace Plot of MCMC Draws from the Parameter Posteriors</p></a></li>
<li><a href='#plot.svdraws'><p>Graphical Summary of the Posterior Distribution</p></a></li>
<li><a href='#plot.svpredict'><p>Graphical Summary of the Posterior Predictive Distribution</p></a></li>
<li><a href='#predict.svdraws'><p>Prediction of Future Returns and Log-Volatilities</p></a></li>
<li><a href='#specify_priors'><p>Specify Prior Distributions for SV Models</p></a></li>
<li><a href='#stochvol-package'><p>Efficient Bayesian Inference for Stochastic Volatility (SV) Models</p></a></li>
<li><a href='#sv_constant'><p>Prior Distributions in <code>stochvol</code></p></a></li>
<li><a href='#svlm'><p>Markov Chain Monte Carlo (MCMC) Sampling for the Stochastic Volatility (SV)</p>
Model</a></li>
<li><a href='#svsample'><p>Markov Chain Monte Carlo (MCMC) Sampling for the Stochastic Volatility (SV)</p>
Model</a></li>
<li><a href='#svsample_fast_cpp'><p>Bindings to <code>C++</code> Functions in <code>stochvol</code></p></a></li>
<li><a href='#svsample_roll'><p>Rolling Estimation of Stochastic Volatility Models</p></a></li>
<li><a href='#svsim'><p>Simulating a Stochastic Volatility Process</p></a></li>
<li><a href='#update_fast_sv'><p>Single MCMC Update Using Fast SV</p></a></li>
<li><a href='#update_general_sv'><p>Single MCMC Update Using General SV</p></a></li>
<li><a href='#update_regressors'><p>Single MCMC update of Bayesian linear regression</p></a></li>
<li><a href='#update_t_error'><p>Single MCMC update to Student's t-distribution</p></a></li>
<li><a href='#updatesummary'><p>Updating the Summary of MCMC Draws</p></a></li>
<li><a href='#validate_and_process_expert'><p>Validate and Process Argument 'expert'</p></a></li>
<li><a href='#volplot'><p>Plotting Quantiles of the Latent Volatilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Bayesian Inference for Stochastic Volatility (SV)
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient algorithms for fully Bayesian estimation of stochastic volatility (SV) models with and without asymmetry (leverage) via Markov chain Monte Carlo (MCMC) methods. Methodological details are given in Kastner and Fr√ºhwirth-Schnatter (2014) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>&gt; and Hosszejni and Kastner (2019) &lt;<a href="https://doi.org/10.1007%2F978-3-030-30611-3_8">doi:10.1007/978-3-030-30611-3_8</a>&gt;; the most common use cases are described in Hosszejni and Kastner (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i12">doi:10.18637/jss.v100.i12</a>&gt; and Kastner (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v069.i05">doi:10.18637/jss.v069.i05</a>&gt; and the package examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0), coda (&ge; 0.19), graphics, stats, utils,
grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.3.2), mvtnorm, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo (&ge; 0.9.900)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>best</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gregorkastner/stochvol/issues">https://github.com/gregorkastner/stochvol/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gregorkastner.github.io/stochvol/">https://gregorkastner.github.io/stochvol/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 11:30:25 UTC; darjushosszejni</td>
</tr>
<tr>
<td>Author:</td>
<td>Darjus Hosszejni <a href="https://orcid.org/0000-0002-3803-691X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Gregor Kastner <a href="https://orcid.org/0000-0002-8237-8271"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Darjus Hosszejni &lt;darjus.hosszejni@icloud.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 12:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='exrates'>Euro exchange rate data</h2><span id='topic+exrates'></span>

<h3>Description</h3>

<p>The data set contains the daily bilateral prices of one Euro in 23
currencies from January 3, 2000, until April 4, 2012. Conversions to New
Turkish Lira and Fourth Romanian Leu have been incorporated.
</p>


<h3>Source</h3>

<p>ECB Statistical Data Warehouse (<a href="https://sdw.ecb.europa.eu">https://sdw.ecb.europa.eu</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svsample">svsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(exrates)
dat &lt;- logret(exrates$USD, demean = TRUE)  ## de-meaned log-returns
res &lt;- svsample(dat)                       ## run MCMC sampler
plot(res, forecast = 100)                  ## display results

## End(Not run)

</code></pre>

<hr>
<h2 id='extractors'>Common Extractors for 'svdraws' and 'svpredict' Objects</h2><span id='topic+extractors'></span><span id='topic+para'></span><span id='topic+latent'></span><span id='topic+latent0'></span><span id='topic+priors'></span><span id='topic+thinning'></span><span id='topic+runtime'></span><span id='topic+svbeta'></span><span id='topic+observations'></span><span id='topic+vola'></span><span id='topic+svtau'></span><span id='topic+sampled_parameters'></span><span id='topic+predy'></span><span id='topic+predlatent'></span><span id='topic+predvola'></span>

<h3>Description</h3>

<p>Some simple extractors returning the corresponding element of an
<code>svdraws</code> and <code>svpredict</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>para(x, chain = "concatenated")

latent0(x, chain = "concatenated")

latent(x, chain = "concatenated")

vola(x, chain = "concatenated")

svbeta(x, chain = "concatenated")

svtau(x, chain = "concatenated")

priors(x)

thinning(x)

runtime(x)

sampled_parameters(x)

predy(y, chain = "concatenated")

predlatent(y, chain = "concatenated")

predvola(y, chain = "concatenated")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractors_+3A_x">x</code></td>
<td>
<p><code>svdraws</code> object.</p>
</td></tr>
<tr><td><code id="extractors_+3A_chain">chain</code></td>
<td>
<p><em>optional</em> either a positive integer or the string
<code>"concatenated"</code> (default) or the string <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="extractors_+3A_y">y</code></td>
<td>
<p><code>svpredict</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value depends on the actual funtion.
</p>
<table>
<tr><td><code>para(x</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the parameter draws.</p>
</td></tr>
<tr><td><code>latent(x</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the latent contemporaneous
log-volatility draws.</p>
</td></tr>
<tr><td><code>latent0(x</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the latent initial log-volatility draws.</p>
</td></tr>
<tr><td><code>svbeta(x</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the linear regression coefficient draws.</p>
</td></tr>
<tr><td><code>svtau(x</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the tau draws.</p>
</td></tr>
<tr><td><code>vola(x</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts standard deviation draws.</p>
</td></tr>
<tr><td><code>priors(x)</code></td>
<td>
<p>extracts the prior
parameters used and returns them in a <code>prior_spec</code> object as generated by
<a href="#topic+specify_priors">specify_priors</a>.</p>
</td></tr>
<tr><td><code>thinning(x)</code></td>
<td>
<p>extracts the thinning parameters used and returns them in
a <code>list</code>.</p>
</td></tr>
<tr><td><code>runtime(x)</code></td>
<td>
<p>extracts the runtime and returns it as a
<code>proc_time</code> object.</p>
</td></tr>
<tr><td><code>sampled_parameters(x)</code></td>
<td>
<p>returns the names of time independent model
parameters that were actually sampled by <code>svsample</code>.</p>
</td></tr>
<tr><td><code>predlatent(y</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the predicted latent contemporaneous
log-volatility draws.</p>
</td></tr>
<tr><td><code>predvola(y</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts predicted standard deviation draws.</p>
</td></tr>
<tr><td><code>predy(y</code>, <code>chain = "concatenated")</code></td>
<td>
<p>extracts the predicted observation draws.</p>
</td></tr>
</table>
<p>Functions that have input parameter <code>chain</code> return
an <code>mcmc.list</code> object if <code>chain=="all"</code> and
return an <code>mcmc</code> object otherwise. If <code>chain</code> is
an integer, then the specified chain is selected from
all chains. If <code>chain</code> is <code>"concatenated"</code>,
then all chains are merged into one <code>mcmc</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+specify_priors">specify_priors</a>, <a href="#topic+svsample">svsample</a>, <a href="#topic+predict.svdraws">predict.svdraws</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data
sim &lt;- svsim(150)

# Draw from vanilla SV
draws &lt;- svsample(sim, draws = 2000)

## Summarize all estimated parameter draws as a merged mcmc object
summary(para(draws)[, sampled_parameters(draws)])
## Extract the draws as an mcmc.list object
params &lt;- para(draws, chain = "all")[, sampled_parameters(draws)]


options(max.print = 100)
## Further short examples
summary(latent0(draws))
summary(latent(draws))
summary(vola(draws))
sampled_parameters(draws)
priors(draws)

# Draw 3 independent chains from heavy-tailed and asymmetric SV with AR(2) structure
draws &lt;- svsample(sim, draws = 20000, burnin = 3000,
                  designmatrix = "ar2",
                  priornu = 0.1, priorrho = c(4, 4),
                  n_chains = 3)

## Extract beta draws from the second chain
svbeta(draws, chain = 2)
## ... tau draws from all chains merged/concatenated together
svtau(draws)
## Create a new svdraws object from the first and third chain
second_chain_excluded &lt;- draws[c(1, 3)]

# Draw from the predictive distribution
pred &lt;- predict(draws, steps = 2)

## Extract the predicted observations as an mcmc.list object
predicted_y &lt;- predy(pred, chain = "all")
## ... the predicted standard deviations from the second chain
predicted_sd &lt;- predvola(pred, chain = 2)
## Create a new svpredict object from the first and third chain
second_chain_excluded &lt;- pred[c(1, 3)]


</code></pre>

<hr>
<h2 id='get_default_fast_sv'>Default Values for the Expert Settings</h2><span id='topic+get_default_fast_sv'></span><span id='topic+get_default_general_sv'></span><span id='topic+default_fast_sv'></span>

<h3>Description</h3>

<p>These functions define meaningful expert settings for
argument <code>expert</code> of <code><a href="#topic+svsample">svsample</a></code> and its derivatives.
The result of <code>get_default_fast_sv</code> should be provided as
<code>expert$fast_sv</code> and <code>get_default_general_sv</code> as <code>expert$general_sv</code>
when relevant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_default_fast_sv()

get_default_general_sv(priorspec)

default_fast_sv
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_default_fast_sv_+3A_priorspec">priorspec</code></td>
<td>
<p>a <code>priorspec</code> object created by
<code><a href="#topic+specify_priors">specify_priors</a></code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 11.
</p>


<h3>Note</h3>

<p><code><a href="#topic+default_fast_sv">default_fast_sv</a></code> is deprecated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svsample">svsample</a></code>, <code><a href="#topic+specify_priors">specify_priors</a></code>, <code><a href="#topic+svsample_roll">svsample_roll</a></code>, <code><a href="#topic+svsample_fast_cpp">svsample_fast_cpp</a></code>, <code><a href="#topic+svsample_general_cpp">svsample_general_cpp</a></code>
</p>

<hr>
<h2 id='logret'>Computes the Log Returns of a Time Series</h2><span id='topic+logret'></span><span id='topic+logret.default'></span>

<h3>Description</h3>

<p><code>logret</code> computes the log returns of a time
series, with optional de-meaning and/or standardization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logret(dat, demean = FALSE, standardize = FALSE, ...)

## Default S3 method:
logret(dat, demean = FALSE, standardize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logret_+3A_dat">dat</code></td>
<td>
<p>The raw data.</p>
</td></tr>
<tr><td><code id="logret_+3A_demean">demean</code></td>
<td>
<p>Logical value indicating whether the data should
be de-meaned.</p>
</td></tr>
<tr><td><code id="logret_+3A_standardize">standardize</code></td>
<td>
<p>Logical value indicating whether the data should
be standardized (in the sense that each component series has an empirical
variance equal to one).</p>
</td></tr>
<tr><td><code id="logret_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Log returns of the (de-meaned / standardized) data.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>logret(default)</code>: Log returns of vectors
</p>
</li></ul>

<hr>
<h2 id='paradensplot'>Probability Density Function Plot for the Parameter Posteriors</h2><span id='topic+paradensplot'></span>

<h3>Description</h3>

<p>Displays a plot of the density estimate for the posterior distribution of
the parameters <code>mu</code>, <code>phi</code>, <code>sigma</code> (and potentially
<code>nu</code> or <code>rho</code>), computed by the <code><a href="stats.html#topic+density">density</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paradensplot(
  x,
  showobs = TRUE,
  showprior = TRUE,
  showxlab = TRUE,
  mar = c(1.9, 1.9, 1.9, 0.5),
  mgp = c(2, 0.6, 0),
  simobj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paradensplot_+3A_x">x</code></td>
<td>
<p><code>svdraws</code> object.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_showobs">showobs</code></td>
<td>
<p>logical value, indicating whether the observations should be
displayed along the x-axis. If many draws have been obtained, the default
(<code>TRUE</code>) can render the plotting to be quite slow, and you might want
to try setting <code>showobs</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_showprior">showprior</code></td>
<td>
<p>logical value, indicating whether the prior distribution
should be displayed. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_showxlab">showxlab</code></td>
<td>
<p>logical value, indicating whether the x-axis should be
labelled with the number of iterations and the bandwith obtained from
<code><a href="stats.html#topic+density">density</a></code>. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_mar">mar</code></td>
<td>
<p>numerical vector of length 4, indicating the plot margins. See
<code><a href="graphics.html#topic+par">par</a></code> for details. The default value is <code>c(1.9,
1.9, 1.9, 0.5)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_mgp">mgp</code></td>
<td>
<p>numerical vector of length 3, indicating the axis and label
positions. See <code><a href="graphics.html#topic+par">par</a></code> for details. The default value is
<code>c(2, 0.6, 0)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_simobj">simobj</code></td>
<td>
<p>object of class <code>svsim</code> as returned by the SV simulation
function <code><a href="#topic+svsim">svsim</a></code>. If provided, &ldquo;true&rdquo; data generating values
will be added to the plots.</p>
</td></tr>
<tr><td><code id="paradensplot_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the invoked <code>plot</code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>paradensplot</code> is modeled after <code><a href="coda.html#topic+densplot">densplot</a></code> in the
<code>coda</code> package, with some modifications for parameters that have
(half-)bounded support.
</p>


<h3>Value</h3>

<p>Called for its side effects. Returns argument <code>x</code> invisibly.
</p>


<h3>Note</h3>

<p>You can call this function directly, but it is more commonly called by
the <code><a href="#topic+plot.svdraws">plot.svdraws</a></code> method.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.svdraws">plot.svdraws</a>()</code>,
<code><a href="#topic+plot.svpredict">plot.svpredict</a>()</code>,
<code><a href="#topic+volplot">volplot</a>()</code>
</p>

<hr>
<h2 id='paratraceplot'>Trace Plot of MCMC Draws from the Parameter Posteriors</h2><span id='topic+paratraceplot'></span>

<h3>Description</h3>

<p>Generic function for plotting iterations vs. sampled parameter values.
A detailed help for the method implemented in <span class="pkg">stochvol</span> can be found in
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paratraceplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paratraceplot_+3A_x">x</code></td>
<td>
<p>An object used to select a method.</p>
</td></tr>
<tr><td><code id="paratraceplot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effects. Returns argument <code>x</code> invisibly.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+paradensplot">paradensplot</a>()</code>,
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a>()</code>,
<code><a href="#topic+plot.svdraws">plot.svdraws</a>()</code>,
<code><a href="#topic+plot.svpredict">plot.svpredict</a>()</code>,
<code><a href="#topic+volplot">volplot</a>()</code>
</p>

<hr>
<h2 id='paratraceplot.svdraws'>Trace Plot of MCMC Draws from the Parameter Posteriors</h2><span id='topic+paratraceplot.svdraws'></span>

<h3>Description</h3>

<p>Displays a plot of iterations vs. sampled values the parameters <code>mu</code>,
<code>phi</code>, <code>sigma</code> (and potentially <code>nu</code> or <code>rho</code>), with a separate plot
per variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svdraws'
paratraceplot(
  x,
  mar = c(1.9, 1.9, 1.9, 0.5),
  mgp = c(2, 0.6, 0),
  simobj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paratraceplot.svdraws_+3A_x">x</code></td>
<td>
<p><code>svdraws</code> object.</p>
</td></tr>
<tr><td><code id="paratraceplot.svdraws_+3A_mar">mar</code></td>
<td>
<p>numerical vector of length 4, indicating the plot margins. See
<code><a href="graphics.html#topic+par">par</a></code> for details. The default value is <code>c(1.9,
1.9, 1.9, 0.5)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="paratraceplot.svdraws_+3A_mgp">mgp</code></td>
<td>
<p>numerical vector of length 3, indicating the axis and label
positions. See <code><a href="graphics.html#topic+par">par</a></code> for details. The default value is
<code>c(2, 0.6, 0)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="paratraceplot.svdraws_+3A_simobj">simobj</code></td>
<td>
<p>object of class <code>svsim</code> as returned by the SV simulation
function <code><a href="#topic+svsim">svsim</a></code>. If provided, &ldquo;true&rdquo; data generating values
will be added to the plots.</p>
</td></tr>
<tr><td><code id="paratraceplot.svdraws_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the invoked <code>matplot</code>
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>paratraceplot</code> is modeled after <code><a href="coda.html#topic+traceplot">traceplot</a></code> in the
<code>coda</code> package, with very minor modifications.
</p>


<h3>Value</h3>

<p>Called for its side effects. Returns argument <code>x</code> invisibly.
</p>


<h3>Note</h3>

<p>You can call this function directly, but it is more commonly called by
the <code><a href="#topic+plot.svdraws">plot.svdraws</a></code> method.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+paradensplot">paradensplot</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.svdraws">plot.svdraws</a>()</code>,
<code><a href="#topic+plot.svpredict">plot.svpredict</a>()</code>,
<code><a href="#topic+volplot">volplot</a>()</code>
</p>

<hr>
<h2 id='plot.svdraws'>Graphical Summary of the Posterior Distribution</h2><span id='topic+plot.svdraws'></span>

<h3>Description</h3>

<p><code>plot.svdraws</code> and <code>plot.svldraws</code> generate some plots visualizing the posterior
distribution and can also be used to display predictive distributions of
future volatilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svdraws'
plot(
  x,
  forecast = NULL,
  dates = NULL,
  show0 = FALSE,
  showobs = TRUE,
  showprior = TRUE,
  forecastlty = NULL,
  tcl = -0.4,
  mar = c(1.9, 1.9, 1.7, 0.5),
  mgp = c(2, 0.6, 0),
  simobj = NULL,
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.svdraws_+3A_x">x</code></td>
<td>
<p><code>svdraws</code> object.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_forecast">forecast</code></td>
<td>
<p>nonnegative integer or object of class <code>svpredict</code>, as
returned by <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>. If an integer greater than 0 is
provided, <code><a href="#topic+predict.svdraws">predict.svdraws</a></code> is invoked to obtain the
<code>forecast</code>-step-ahead prediction. The default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_dates">dates</code></td>
<td>
<p>vector of length <code>ncol(x$latent)</code>, providing optional
dates for labelling the x-axis. The default value is <code>NULL</code>; in this
case, the axis will be labelled with numbers.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_show0">show0</code></td>
<td>
<p>logical value, indicating whether the initial volatility
<code>exp(h_0/2)</code> should be displayed. The default value is <code>FALSE</code>.
Only available for inputs <code>x</code> of class <code>svdraws</code>.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_showobs">showobs</code></td>
<td>
<p>logical value, indicating whether the observations should be
displayed along the x-axis. If many draws have been obtained, the default
(<code>TRUE</code>) can render the plotting to be quite slow, and you might want
to try setting <code>showobs</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_showprior">showprior</code></td>
<td>
<p>logical value, indicating whether the prior distribution
should be displayed. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_forecastlty">forecastlty</code></td>
<td>
<p>vector of line type values (see
<code><a href="graphics.html#topic+par">par</a></code>) used for plotting quantiles of predictive
distributions. The default value <code>NULL</code> results in dashed lines.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_tcl">tcl</code></td>
<td>
<p>The length of tick marks as a fraction of the height of a line of
text. See <code><a href="graphics.html#topic+par">par</a></code> for details. The default value is
<code>-0.4</code>, which results in slightly shorter tick marks than usual.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_mar">mar</code></td>
<td>
<p>numerical vector of length 4, indicating the plot margins. See
<code><a href="graphics.html#topic+par">par</a></code> for details. The default value is <code>c(1.9,
1.9, 1.9, 0.5)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_mgp">mgp</code></td>
<td>
<p>numerical vector of length 3, indicating the axis and label
positions. See <code><a href="graphics.html#topic+par">par</a></code> for details. The default value is
<code>c(2, 0.6, 0)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_simobj">simobj</code></td>
<td>
<p>object of class <code>svsim</code> as returned by the SV simulation
function <code><a href="#topic+svsim">svsim</a></code>. If provided, the &ldquo;true&rdquo; data generating
values will be added to the plots.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_newdata">newdata</code></td>
<td>
<p>corresponds to parameter <code>newdata</code> in <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>.
<em>Only if <code>forecast</code> is a positive integer and <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>
needs a <code>newdata</code> object.</em> Corresponds to input
parameter <code>designmatrix</code> in <code><a href="#topic+svsample">svsample</a></code>.
A matrix of regressors with number of rows equal to parameter <code>forecast</code>.</p>
</td></tr>
<tr><td><code id="plot.svdraws_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the invoked plotting
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions set up the page layout and call <code><a href="#topic+volplot">volplot</a></code>,
<code><a href="#topic+paratraceplot">paratraceplot</a></code> and <code><a href="#topic+paradensplot">paradensplot</a></code>.
</p>


<h3>Value</h3>

<p>Called for its side effects. Returns argument <code>x</code> invisibly.
</p>


<h3>Note</h3>

<p>In case you want different quantiles to be plotted, use
<code><a href="#topic+updatesummary">updatesummary</a></code> on the <code>svdraws</code> object first. An example
of doing so is given in the Examples section.
</p>


<h3>Author(s)</h3>

<p>Gregor Kastner <a href="mailto:gregor.kastner@wu.ac.at">gregor.kastner@wu.ac.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updatesummary">updatesummary</a></code>, <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>
</p>
<p>Other plotting: 
<code><a href="#topic+paradensplot">paradensplot</a>()</code>,
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.svpredict">plot.svpredict</a>()</code>,
<code><a href="#topic+volplot">volplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate a short and highly persistent SV process
sim &lt;- svsim(100, mu = -10, phi = 0.99, sigma = 0.2)

## Obtain 5000 draws from the sampler (that's not a lot)
draws &lt;- svsample(sim$y, draws = 5000, burnin = 1000,
  priormu = c(-10, 1), priorphi = c(20, 1.5), priorsigma = 0.2)

## Plot the latent volatilities and some forecasts
plot(draws, forecast = 10)

## Re-plot with different quantiles
newquants &lt;- c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99)
draws &lt;- updatesummary(draws, quantiles = newquants)

plot(draws, forecast = 20, showobs = FALSE,
     forecastlty = 3, showprior = FALSE)

</code></pre>

<hr>
<h2 id='plot.svpredict'>Graphical Summary of the Posterior Predictive Distribution</h2><span id='topic+plot.svpredict'></span>

<h3>Description</h3>

<p><code>plot.svpredict</code> and <code>plot.svlpredict</code> generate some plots
visualizing the posterior predictive distribution of future volatilites and
future observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svpredict'
plot(x, quantiles = c(0.05, 0.25, 0.5, 0.75, 0.95), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.svpredict_+3A_x">x</code></td>
<td>
<p><code>svpredict</code> or <code>svlpredict</code> object.</p>
</td></tr>
<tr><td><code id="plot.svpredict_+3A_quantiles">quantiles</code></td>
<td>
<p>Which quantiles to plot? Defaults to
<code>c(.05, .25, .5, .75, .95)</code>.</p>
</td></tr>
<tr><td><code id="plot.svpredict_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the invoked
<code><a href="stats.html#topic+ts.plot">ts.plot</a></code> or <code><a href="graphics.html#topic+boxplot">boxplot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effects. Returns argument <code>x</code> invisibly.
</p>


<h3>Note</h3>

<p>Note that <code>svpredict</code> or <code>svlpredict</code> objects can also be
used within <code><a href="#topic+plot.svdraws">plot.svdraws</a></code> for a possibly more useful
visualization. See the examples in <code><a href="#topic+predict.svdraws">predict.svdraws</a></code> and
those below for use cases.
</p>


<h3>See Also</h3>

<p>Other plotting: 
<code><a href="#topic+paradensplot">paradensplot</a>()</code>,
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.svdraws">plot.svdraws</a>()</code>,
<code><a href="#topic+volplot">volplot</a>()</code>
</p>
<p>Other plotting: 
<code><a href="#topic+paradensplot">paradensplot</a>()</code>,
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.svdraws">plot.svdraws</a>()</code>,
<code><a href="#topic+volplot">volplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate a short and highly persistent SV process
sim &lt;- svsim(100, mu = -10, phi = 0.99, sigma = 0.1)

## Obtain 5000 draws from the sampler (that's not a lot)
draws &lt;- svsample(sim$y, draws = 5000, burnin = 1000)

## Predict 10 steps ahead
pred &lt;- predict(draws, 10)

## Visualize the predicted distributions
plot(pred)

## Plot the latent volatilities and some forecasts
plot(draws, forecast = pred)

</code></pre>

<hr>
<h2 id='predict.svdraws'>Prediction of Future Returns and Log-Volatilities</h2><span id='topic+predict.svdraws'></span>

<h3>Description</h3>

<p>Simulates draws from the predictive density of the returns and the latent log-volatility
process. The same mean model is used for prediction as was used for fitting, which is
either a) no mean parameter, b) constant mean, c) AR(k) structure, or d) general
Bayesian regression. In the last case, new regressors need to be provided for prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svdraws'
predict(object, steps = 1L, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.svdraws_+3A_object">object</code></td>
<td>
<p><code>svdraws</code> or <code>svldraws</code> object.</p>
</td></tr>
<tr><td><code id="predict.svdraws_+3A_steps">steps</code></td>
<td>
<p><em>optional</em> single number, coercible to integer. Denotes the number of
steps to forecast.</p>
</td></tr>
<tr><td><code id="predict.svdraws_+3A_newdata">newdata</code></td>
<td>
<p><em>only in case d) of the description</em> corresponds to input
parameter <code>designmatrix</code> in <code><a href="#topic+svsample">svsample</a></code>.
A matrix of regressors with number of rows equal to parameter <code>steps</code>.</p>
</td></tr>
<tr><td><code id="predict.svdraws_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>svpredict</code>, a list containing
three elements:
</p>
<table>
<tr><td><code>vol</code></td>
<td>
<p><code>mcmc.list</code> object of simulations from the predictive density of the standard deviations <code>sd_(n+1),...,sd_(n+steps)</code></p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p><code>mcmc.list</code> object of simulations from the predictive density of <code>h_(n+1),...,h_(n+steps)</code></p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p><code>mcmc.list</code> object of simulations from the predictive density of <code>y_(n+1),...,y_(n+steps)</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>You can use the resulting object within <code><a href="#topic+plot.svdraws">plot.svdraws</a></code> (see example below), or use
the list items in the usual <code>coda</code> methods for <code>mcmc</code> objects to
print, plot, or summarize the predictions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.svdraws">plot.svdraws</a></code>, <code><a href="#topic+volplot">volplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
## Simulate a short and highly persistent SV process 
sim &lt;- svsim(100, mu = -10, phi = 0.99, sigma = 0.2)

## Obtain 5000 draws from the sampler (that's not a lot)
draws &lt;- svsample(sim$y, draws = 5000, burnin = 100,
  priormu = c(-10, 1), priorphi = c(20, 1.5), priorsigma = 0.2)

## Predict 10 days ahead
fore &lt;- predict(draws, 10)

## Check out the results
summary(predlatent(fore))
summary(predy(fore))
plot(draws, forecast = fore)


# Example 2
## Simulate now an SV process with an AR(1) mean structure
len &lt;- 109L
simar &lt;- svsim(len, phi = 0.93, sigma = 0.15, mu = -9)
for (i in 2:len) {
  simar$y[i] &lt;- 0.1 - 0.7 * simar$y[i-1] + simar$vol[i] * rnorm(1)
}

## Obtain 7000 draws
drawsar &lt;- svsample(simar$y, draws = 7000, burnin = 300,
  designmatrix = "ar1", priormu = c(-10, 1), priorphi = c(20, 1.5),
  priorsigma = 0.2)

## Predict 7 days ahead (using AR(1) mean for the returns)
forear &lt;- predict(drawsar, 7)

## Check out the results
plot(forear)
plot(drawsar, forecast = forear)

## Not run: 
# Example 3
## Simulate now an SV process with leverage and with non-zero mean
len &lt;- 96L
regressors &lt;- cbind(rep_len(1, len), rgamma(len, 0.5, 0.25))
betas &lt;- rbind(-1.1, 2)
simreg &lt;- svsim(len, rho = -0.42)
simreg$y &lt;- simreg$y + as.numeric(regressors %*% betas)

## Obtain 12000 draws
drawsreg &lt;- svsample(simreg$y, draws = 12000, burnin = 3000,
  designmatrix = regressors, priormu = c(-10, 1), priorphi = c(20, 1.5),
  priorsigma = 0.2, priorrho = c(4, 4))

## Predict 5 days ahead using new regressors
predlen &lt;- 5L
predregressors &lt;- cbind(rep_len(1, predlen), rgamma(predlen, 0.5, 0.25))
forereg &lt;- predict(drawsreg, predlen, predregressors)

## Check out the results
summary(predlatent(forereg))
summary(predy(forereg))
plot(forereg)
plot(drawsreg, forecast = forereg)

## End(Not run)

</code></pre>

<hr>
<h2 id='specify_priors'>Specify Prior Distributions for SV Models</h2><span id='topic+specify_priors'></span>

<h3>Description</h3>

<p>This function gives access to a larger set of prior distributions
in case the default choice is unsatisfactory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_priors(
  mu = sv_normal(mean = 0, sd = 100),
  phi = sv_beta(shape1 = 5, shape2 = 1.5),
  sigma2 = sv_gamma(shape = 0.5, rate = 0.5),
  nu = sv_infinity(),
  rho = sv_constant(0),
  latent0_variance = "stationary",
  beta = sv_multinormal(mean = 0, sd = 10000, dim = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specify_priors_+3A_mu">mu</code></td>
<td>
<p>one of <code>sv_normal</code> or <code>sv_constant</code></p>
</td></tr>
<tr><td><code id="specify_priors_+3A_phi">phi</code></td>
<td>
<p>one of <code>sv_beta</code>, <code>sv_normal</code>, or <code>sv_constant</code>. If <code>sv_beta</code>, then the specified beta distribution is the prior for <code>(phi+1)/2</code></p>
</td></tr>
<tr><td><code id="specify_priors_+3A_sigma2">sigma2</code></td>
<td>
<p>one of <code>sv_gamma</code>, <code>sv_inverse_gamma</code>, or <code>sv_constant</code></p>
</td></tr>
<tr><td><code id="specify_priors_+3A_nu">nu</code></td>
<td>
<p>one of <code>sv_infinity</code>, <code>sv_exponential</code>, or <code>sv_constant</code>. If <code>sv_exponential</code>, then the specified exponential distribution is the prior for <code>nu-2</code></p>
</td></tr>
<tr><td><code id="specify_priors_+3A_rho">rho</code></td>
<td>
<p>one of <code>sv_beta</code> or <code>sv_constant</code>. If <code>sv_beta</code>, then the specified beta distribution is the prior for <code>(rho+1)/2</code></p>
</td></tr>
<tr><td><code id="specify_priors_+3A_latent0_variance">latent0_variance</code></td>
<td>
<p>either the character string <code>"stationary"</code> or an <code>sv_constant</code> object.
If <code>"stationary"</code>, then h0 ~ N(<code>mu</code>, <code>sigma^2/(1-phi^2)</code>). If an <code>sv_constant</code> object with value <code>v</code>, then h0 ~ N(<code>mu</code>, <code>sigma^2/v</code>).
Here, N(b, B) stands for mean b and variance B</p>
</td></tr>
<tr><td><code id="specify_priors_+3A_beta">beta</code></td>
<td>
<p>an <code>sv_multinormal</code> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other priors: 
<code><a href="#topic+sv_constant">sv_constant</a>()</code>
</p>

<hr>
<h2 id='stochvol-package'>Efficient Bayesian Inference for Stochastic Volatility (SV) Models</h2><span id='topic+stochvol-package'></span><span id='topic+stochvol'></span>

<h3>Description</h3>

<p>This package provides an efficient algorithm for fully Bayesian estimation
of stochastic volatility (SV) models via Markov chain Monte Carlo (MCMC)
methods. Methodological details are given in Kastner and Fr√ºhwirth-Schnatter
(2014); the most common use cases are described in Kastner (2016). Recently,
the package has been extended to allow for the leverage effect.
</p>


<h3>Details</h3>

<p>Bayesian inference for stochastic volatility models using MCMC methods
highly depends on actual parameter values in terms of sampling efficiency.
While draws from the posterior utilizing the standard centered
parameterization break down when the volatility of volatility parameter in
the latent state equation is small, non-centered versions of the model show
deficiencies for highly persistent latent variable series. The novel
approach of ancillarity-sufficiency interweaving (Yu and Meng, 2011) has
recently been shown to aid in overcoming these issues for a broad class of
multilevel models. This package provides software for &ldquo;combining best of
different worlds&rdquo; which allows for inference for parameter constellations
that have previously been infeasible to estimate without the need to select
a particular parameterization beforehand.
</p>


<h3>Note</h3>

<p>This package is currently in active development. Your comments,
suggestions and requests are warmly welcome!
</p>


<h3>Author(s)</h3>

<p>Gregor Kastner <a href="mailto:gregor.kastner@wu.ac.at">gregor.kastner@wu.ac.at</a>, Darjus Hosszejni <a href="mailto:darjus.hosszejni@wu.ac.at">darjus.hosszejni@wu.ac.at</a>
</p>


<h3>References</h3>

<p>Kastner, G. and Fr√ºhwirth-Schnatter, S. (2014).
Ancillarity-Sufficiency Interweaving Strategy (ASIS) for Boosting MCMC
Estimation of Stochastic Volatility Models. <em>Computational Statistics &amp;
Data Analysis</em>, <b>76</b>, 408&ndash;423,
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Kastner, G. (2016). Dealing with Stochastic Volatility in Time Series Using the R Package stochvol.
<em>Journal of Statistical Software</em>, <b>69</b>(5), 1&ndash;30,
<a href="https://doi.org/10.18637/jss.v069.i05">doi:10.18637/jss.v069.i05</a>.
</p>
<p>Yu, Y. and Meng, X.-L. (2011). To Center or Not to Center: That is Not the
Question&mdash;An Ancillarity-Suffiency Interweaving Strategy (ASIS) for
Boosting MCMC Efficiency. <em>Journal of Computational and Graphical
Statistics</em>, <b>20</b>(3), 531&ndash;570,
<a href="https://doi.org/10.1198/jcgs.2011.203main">doi:10.1198/jcgs.2011.203main</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a highly persistent SV process 
sim &lt;- svsim(500, mu = -10, phi = 0.99, sigma = 0.2)
 
## Obtain 4000 draws from the sampler (that's too few!)
draws &lt;- svsample(sim$y, draws = 4000, burnin = 100, priormu = c(-10, 1),
                 priorphi = c(20, 1.2), priorsigma = 0.2)
 
## Predict 20 days ahead
fore &lt;- predict(draws, 20)
 
## plot the results
plot(draws, forecast = fore)
 
## Not run: 
## Simulate an SV process with leverage
sim &lt;- svsim(500, mu = -10, phi = 0.95, sigma = 0.2, rho=-0.5)
 
## Obtain 8000 draws from the sampler (that's too little!)
draws &lt;- svsample(sim$y, draws = 4000, burnin = 3000, priormu = c(-10, 1),
                  priorphi = c(20, 1.2), priorsigma = 0.2,
                  priorrho = c(1, 1))
 
## Predict 20 days ahead
fore &lt;- predict(draws, 20)
 
## plot the results
plot(draws, forecast = fore)

## End(Not run)
</code></pre>

<hr>
<h2 id='sv_constant'>Prior Distributions in <code>stochvol</code></h2><span id='topic+sv_constant'></span><span id='topic+sv_normal'></span><span id='topic+sv_multinormal'></span><span id='topic+sv_gamma'></span><span id='topic+sv_inverse_gamma'></span><span id='topic+sv_beta'></span><span id='topic+sv_exponential'></span><span id='topic+sv_infinity'></span>

<h3>Description</h3>

<p>The functions below can be supplied to <code><a href="#topic+specify_priors">specify_priors</a></code>
to overwrite the default set of prior distributions in <code><a href="#topic+svsample">svsample</a></code>.
The functions have <code>mean</code>, <code>range</code>, <code>density</code>, and
<code>print</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_constant(value)

sv_normal(mean = 0, sd = 1)

sv_multinormal(mean = 0, precision = NULL, sd = 1, dim = NA)

sv_gamma(shape, rate)

sv_inverse_gamma(shape, scale)

sv_beta(shape1, shape2)

sv_exponential(rate)

sv_infinity()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_constant_+3A_value">value</code></td>
<td>
<p>The constant value for the degenerate constant distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_mean">mean</code></td>
<td>
<p>Expected value for the univariate normal distribution or mean vector of the multivariate normal distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for the univariate normal distribution or constant scale of the multivariate normal distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_precision">precision</code></td>
<td>
<p>Precision matrix for the multivariate normal distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_dim">dim</code></td>
<td>
<p>(optional) Dimension of the multivariate distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for the distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_rate">rate</code></td>
<td>
<p>Rate parameter for the distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_scale">scale</code></td>
<td>
<p>Scale parameter for the distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_shape1">shape1</code></td>
<td>
<p>First shape parameter for the distribution</p>
</td></tr>
<tr><td><code id="sv_constant_+3A_shape2">shape2</code></td>
<td>
<p>Second shape parameter for the distribution</p>
</td></tr>
</table>


<h3>Multivariate Normal</h3>

<p>Multivariate normal objects can be specified several ways. The most general way is by calling
<code>sv_multinormal(mean, precision)</code>, which allows for arbitrary mean and (valid) precision
arguments. Constant mean vectors and constant diagonal precision matrices of dimension <code>D</code>
can be created two ways: either <code>sv_multinormal(mean, sd, dim = D)</code> or
<code>rep(sv_normal(mean, sd), length.out = D)</code>.
</p>


<h3>See Also</h3>

<p>Other priors: 
<code><a href="#topic+specify_priors">specify_priors</a>()</code>
</p>

<hr>
<h2 id='svlm'>Markov Chain Monte Carlo (MCMC) Sampling for the Stochastic Volatility (SV)
Model</h2><span id='topic+svlm'></span>

<h3>Description</h3>

<p><code>svlm</code> is a wrapper around <code><a href="#topic+svsample">svsample</a></code> with a formula interface.
The name derives from SV and <code><a href="stats.html#topic+lm">lm</a></code> because a linear model with SV residuals is fitted.
The function simulates from the joint posterior distribution of the regression coefficients and the SV
parameters <code>mu</code>, <code>phi</code>, <code>sigma</code> (and potentially <code>nu</code> and <code>rho</code>),
along with the latent log-volatilities <code>h_0,...,h_n</code> and returns the
MCMC draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svlm(
  formula,
  data,
  draws = 10000,
  burnin = 1000,
  heavytails = FALSE,
  asymmetry = FALSE,
  priorspec = NULL,
  thin = 1,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svlm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"formula"</code>, as in <code><a href="stats.html#topic+lm">lm</a></code>.</p>
</td></tr>
<tr><td><code id="svlm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code>as.data.frame</code> to a data frame) containing the
variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>, typically
the environment from which <code>svlm</code> is called.</p>
</td></tr>
<tr><td><code id="svlm_+3A_draws">draws</code></td>
<td>
<p>single number greater or equal to 1, indicating the number of
draws after burn-in (see below). Will be automatically coerced to integer.
The default value is 10000.</p>
</td></tr>
<tr><td><code id="svlm_+3A_burnin">burnin</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of
draws discarded as burn-in. Will be automatically coerced to integer. The
default value is 1000.</p>
</td></tr>
<tr><td><code id="svlm_+3A_heavytails">heavytails</code></td>
<td>
<p>if <code>TRUE</code>, then the residuals of the linear model
will follow a t-distribution conditional on the latent volatility process.
This model is usually called SV-t. If <code>priorspec</code> is given, then
<code>heavytails</code> is ignored.</p>
</td></tr>
<tr><td><code id="svlm_+3A_asymmetry">asymmetry</code></td>
<td>
<p>if <code>TRUE</code>, then the residuals of the linear model
will follow an SV process with leverage. If <code>priorspec</code> is given, then
<code>heavytails</code> is ignored.</p>
</td></tr>
<tr><td><code id="svlm_+3A_priorspec">priorspec</code></td>
<td>
<p>using the smart constructor <code><a href="#topic+specify_priors">specify_priors</a></code>,
one can set the details of the prior distribution.</p>
</td></tr>
<tr><td><code id="svlm_+3A_thin">thin</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinpara</code>th parameter and latent draw is kept and returned. The default
value is 1, corresponding to no thinning of the parameter draws i.e. every
draw is stored.</p>
</td></tr>
<tr><td><code id="svlm_+3A_keeptime">keeptime</code></td>
<td>
<p>Either 'all' (the default) or 'last'. Indicates which latent
volatility draws should be stored.</p>
</td></tr>
<tr><td><code id="svlm_+3A_quiet">quiet</code></td>
<td>
<p>logical value indicating whether the progress bar and other
informative output during sampling should be omitted. The default value is
<code>FALSE</code>, implying verbose output.</p>
</td></tr>
<tr><td><code id="svlm_+3A_startpara">startpara</code></td>
<td>
<p><em>optional</em> named list, containing the starting values
for the parameter draws. If supplied, <code>startpara</code> may contain
elements named <code>mu</code>, <code>phi</code>, <code>sigma</code>, <code>nu</code>, <code>rho</code>,
<code>beta</code>, and <code>latent0</code>.
The default value is equal to the prior mean.
In case of parallel execution with <code>cl</code> provided, <code>startpara</code> can be a list of
named lists that initialize the parallel chains.</p>
</td></tr>
<tr><td><code id="svlm_+3A_startlatent">startlatent</code></td>
<td>
<p><em>optional</em> vector of length <code>length(y)</code>,
containing the starting values for the latent log-volatility draws. The
default value is <code>rep(-10, length(y))</code>.
In case of parallel execution with <code>cl</code> provided, <code>startlatent</code> can be a list of
named lists that initialize the parallel chains.</p>
</td></tr>
<tr><td><code id="svlm_+3A_parallel">parallel</code></td>
<td>
<p><em>optional</em> one of <code>"no"</code> (default), <code>"multicore"</code>, or <code>"snow"</code>,
indicating what type of parallellism is to be applied. Option
<code>"multicore"</code> is not available on Windows.</p>
</td></tr>
<tr><td><code id="svlm_+3A_n_cpus">n_cpus</code></td>
<td>
<p><em>optional</em> positive integer, the number of CPUs to be used in case of
parallel computations. Defaults to <code>1L</code>. Ignored if parameter
<code>cl</code> is supplied and <code>parallel != "snow"</code>.</p>
</td></tr>
<tr><td><code id="svlm_+3A_cl">cl</code></td>
<td>
<p><em>optional</em> so-called SNOW cluster object as implemented in package
<code>parallel</code>. Ignored unless <code>parallel == "snow"</code>.</p>
</td></tr>
<tr><td><code id="svlm_+3A_n_chains">n_chains</code></td>
<td>
<p><em>optional</em> positive integer specifying the number of independent MCMC chains</p>
</td></tr>
<tr><td><code id="svlm_+3A_print_progress">print_progress</code></td>
<td>
<p><em>optional</em> one of <code>"automatic"</code>, <code>"progressbar"</code>,
or <code>"iteration"</code>, controls the output. Ignored if <code>quiet</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="svlm_+3A_expert">expert</code></td>
<td>
<p><em>optional</em> named list of expert parameters. For most
applications, the default values probably work best. Interested users are
referred to the literature provided in the References section. If
<code>expert</code> is provided, it may contain the following named elements:
</p>

<dl>
<dt>interweave</dt><dd><p>Logical value. If <code>TRUE</code> (the default),
then ancillarity-sufficiency interweaving strategy (ASIS) is applied
to improve on the sampling efficiency for the parameters.
Otherwise one parameterization is used.</p>
</dd>
<dt>correct_model_misspecification</dt><dd><p>Logical value. If <code>FALSE</code>
(the default), then auxiliary mixture sampling is used to sample the latent
states. If <code>TRUE</code>, extra computations are made to correct for model
misspecification either ex-post by reweighting or on-line using a
Metropolis-Hastings step.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="svlm_+3A_...">...</code></td>
<td>
<p>Any extra arguments will be forwarded to
<code><a href="#topic+updatesummary">updatesummary</a></code>, controlling the type of statistics calculated
for the posterior draws.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details concerning the algorithm please see the paper by Kastner and
Fr√ºhwirth-Schnatter (2014) and Hosszejni and Kastner (2019).
</p>


<h3>Value</h3>

<p>The value returned is a list object of class <code>svdraws</code> holding
</p>
<table>
<tr><td><code>para</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>parameter</em> draws from
the posterior distribution.</p>
</td></tr>
<tr><td><code>latent</code></td>
<td>
<p><code>mcmc.list</code> object containing the
<em>latent instantaneous log-volatility</em> draws from the posterior
distribution.</p>
</td></tr>
<tr><td><code>latent0</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>latent
initial log-volatility</em> draws from the posterior distribution.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>latent variance inflation
factors</em> for the sampler with conditional t-innovations <em>(optional)</em>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>regression coefficient</em>
draws from the posterior distribution <em>(optional)</em>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the left hand side of the observation equation, usually
the argument <code>y</code>. In case of an AR(<code>k</code>) specification, the
first <code>k</code> elements are removed.</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p><code>proc_time</code> object containing the
run time of the sampler.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>a <code>priorspec</code> object containing the parameter
values of the prior distributions for <code>mu</code>,
<code>phi</code>, <code>sigma</code>, <code>nu</code>, <code>rho</code>, and
<code>beta</code>s, and the variance of specification for <code>latent0</code>.</p>
</td></tr>
<tr><td><code>thinning</code></td>
<td>
<p><code>list</code> containing the thinning
parameters, i.e. the arguments <code>thinpara</code>, <code>thinlatent</code> and
<code>keeptime</code>.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p><code>list</code> containing a collection of
summary statistics of the posterior draws for <code>para</code>, <code>latent</code>,
and <code>latent0</code>.</p>
</td></tr>
<tr><td><code>meanmodel</code></td>
<td>
<p><code>character</code> containing information about how <code>designmatrix</code>
was employed.</p>
</td></tr>
<tr><td><code>svlm</code></td>
<td>
<p>a flag for the use of <code>svlm</code></p>
</td></tr>
<tr><td><code>model_terms</code></td>
<td>
<p>helper object that represents the formula</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>argument <code>formula</code></p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>helper object that is needed to interpret the formula</p>
</td></tr>
</table>
<p>To display the output, use <code>print</code>, <code>summary</code> and <code>plot</code>. The
<code>print</code> method simply prints the posterior draws (which is very likely
a lot of output); the <code>summary</code> method displays the summary statistics
currently stored in the object; the <code>plot</code> method
<code><a href="#topic+plot.svdraws">plot.svdraws</a></code> gives a graphical overview of the posterior
distribution by calling <code><a href="#topic+volplot">volplot</a></code>, <code>traceplot</code> and
<code>densplot</code> and displaying the results on a single page.
</p>


<h3>References</h3>

<p>Kastner, G. and Fr√ºhwirth-Schnatter, S. (2014).
Ancillarity-sufficiency interweaving strategy (ASIS) for boosting MCMC
estimation of stochastic volatility models. <em>Computational Statistics &amp;
Data Analysis</em>, <b>76</b>, 408&ndash;423,
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Hosszejni, D. and Kastner, G. (2019).
Approaches Toward the Bayesian Estimation of the Stochastic Volatility Model with Leverage.
<em>Springer Proceedings in Mathematics &amp; Statistics</em>, <b>296</b>, 75&ndash;83,
<a href="https://doi.org/10.1007/978-3-030-30611-3_8">doi:10.1007/978-3-030-30611-3_8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svsample">svsample</a></code>, <code><a href="#topic+svsim">svsim</a></code>, <code><a href="#topic+specify_priors">specify_priors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data
n &lt;- 50L
dat &lt;- data.frame(x = runif(n, 3, 4),
                  z = runif(n, -1, -0.5))
designmatrix &lt;- matrix(c(dat$x, dat$x^2, log10(dat$x),
                         dat$z), ncol = 4)
betas &lt;- matrix(c(-1, 1, 2, 0), ncol = 1)
y &lt;- designmatrix %*% betas + svsim(n)$y
dat$y &lt;- y
# Formula interface
res &lt;- svlm(y ~ 0 + x + I(x^2) + log10(x) + z, data = dat)
# Prediction
predn &lt;- 10L
preddat &lt;- data.frame(x = runif(predn, 3, 4),
                      z = runif(predn, -1, -0.5))
pred &lt;- predict(res, newdata = preddat, steps = predn)
</code></pre>

<hr>
<h2 id='svsample'>Markov Chain Monte Carlo (MCMC) Sampling for the Stochastic Volatility (SV)
Model</h2><span id='topic+svsample'></span><span id='topic+svtsample'></span><span id='topic+svlsample'></span><span id='topic+svtlsample'></span><span id='topic+svsample2'></span>

<h3>Description</h3>

<p><code>svsample</code> simulates from the joint posterior distribution of the SV
parameters <code>mu</code>, <code>phi</code>, <code>sigma</code> (and potentially <code>nu</code> and <code>rho</code>),
along with the latent log-volatilities <code>h_0,...,h_n</code> and returns the
MCMC draws. If a design matrix is provided, simple Bayesian regression can
also be conducted. For similar functionality with a formula interface,
see <code><a href="#topic+svlm">svlm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svsample(
  y,
  draws = 10000,
  burnin = 1000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0,
  priorrho = NA,
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svtsample(
  y,
  draws = 10000,
  burnin = 1000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0.1,
  priorrho = NA,
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svlsample(
  y,
  draws = 20000,
  burnin = 2000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0,
  priorrho = c(4, 4),
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svtlsample(
  y,
  draws = 20000,
  burnin = 2000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0.1,
  priorrho = c(4, 4),
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  priorspec = NULL,
  thin = 1,
  thinpara = thin,
  thinlatent = thin,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  n_chains = 1L,
  print_progress = "automatic",
  expert = NULL,
  ...
)

svsample2(
  y,
  draws = 10000,
  burnin = 1000,
  designmatrix = NA,
  priormu = c(0, 100),
  priorphi = c(5, 1.5),
  priorsigma = 1,
  priornu = 0,
  priorrho = NA,
  priorbeta = c(0, 10000),
  priorlatent0 = "stationary",
  thinpara = 1,
  thinlatent = 1,
  keeptime = "all",
  quiet = FALSE,
  startpara = NULL,
  startlatent = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svsample_+3A_y">y</code></td>
<td>
<p>numeric vector containing the data (usually log-returns), which
must not contain zeros. Alternatively, <code>y</code> can be an <code>svsim</code>
object. In this case, the returns will be extracted and a message is signalled.</p>
</td></tr>
<tr><td><code id="svsample_+3A_draws">draws</code></td>
<td>
<p>single number greater or equal to 1, indicating the number of
draws after burn-in (see below). Will be automatically coerced to integer.
The default value is 10000.</p>
</td></tr>
<tr><td><code id="svsample_+3A_burnin">burnin</code></td>
<td>
<p>single number greater or equal to 0, indicating the number of
draws discarded as burn-in. Will be automatically coerced to integer. The
default value is 1000.</p>
</td></tr>
<tr><td><code id="svsample_+3A_designmatrix">designmatrix</code></td>
<td>
<p>regression design matrix for modeling the mean. Must
have <code>length(y)</code> rows. Alternatively, <code>designmatrix</code> may be a
string of the form <code>"arX"</code>, where <code>X</code> is a nonnegative integer. To
fit a constant mean model, use <code>designmatrix = "ar0"</code> (which is
equivalent to <code>designmatrix = matrix(1, nrow = length(y))</code>). To fit an
AR(1) model, use <code>designmatrix = "ar1"</code>, and so on. If some elements of
<code>designmatrix</code> are <code>NA</code>, the mean is fixed to zero (pre-1.2.0
behavior of <span class="pkg">stochvol</span>).</p>
</td></tr>
<tr><td><code id="svsample_+3A_priormu">priormu</code></td>
<td>
<p>numeric vector of length 2, indicating mean and standard
deviation for the Gaussian prior distribution of the parameter <code>mu</code>,
the level of the log-volatility. The default value is <code>c(0, 100)</code>,
which constitutes a practically uninformative prior for common exchange rate
datasets, stock returns and the like.</p>
</td></tr>
<tr><td><code id="svsample_+3A_priorphi">priorphi</code></td>
<td>
<p>numeric vector of length 2, indicating the shape parameters
for the Beta prior distribution of the transformed parameter
<code>(phi + 1) / 2</code>, where <code>phi</code> denotes the persistence of the
log-volatility. The default value is <code>c(5, 1.5)</code>, which constitutes a
prior that puts some belief in a persistent log-volatility but also
encompasses the region where <code>phi</code> is around 0.</p>
</td></tr>
<tr><td><code id="svsample_+3A_priorsigma">priorsigma</code></td>
<td>
<p>single positive real number, which stands for the scaling
of the transformed parameter <code>sigma^2</code>, where <code>sigma</code> denotes the
volatility of log-volatility. More precisely, <code>sigma^2 ~ priorsigma *
chisq(df = 1)</code>. The default value is <code>1</code>, which constitutes a
reasonably vague prior for many common exchange rate datasets, stock returns
and the like.</p>
</td></tr>
<tr><td><code id="svsample_+3A_priornu">priornu</code></td>
<td>
<p>single non-negative number, indicating the rate parameter
for the exponential prior distribution of the parameter; can be <code>Inf</code>
<code>nu</code>, the degrees-of-freedom parameter of the conditional innovations
t-distribution. The default value is <code>0</code>, fixing the
degrees-of-freedom to infinity. This corresponds to conditional standard
normal innovations, the pre-1.1.0 behavior of <span class="pkg">stochvol</span>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_priorrho">priorrho</code></td>
<td>
<p>either <code>NA</code> for the no-leverage case or a numeric
vector of length 2 that specify the beta prior distribution for
<code>(rho+1)/2</code></p>
</td></tr>
<tr><td><code id="svsample_+3A_priorbeta">priorbeta</code></td>
<td>
<p>numeric vector of length 2, indicating the mean and
standard deviation of the Gaussian prior for the regression parameters. The
default value is <code>c(0, 10000)</code>, which constitutes a very vague prior
for many common datasets. Not used if <code>designmatrix</code> is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_priorlatent0">priorlatent0</code></td>
<td>
<p>either a single non-negative number or the string
<code>'stationary'</code> (the default, also the behavior before version 1.3.0).
When <code>priorlatent0</code> is equal to <code>'stationary'</code>, the stationary
distribution of the latent AR(1)-process is used as the prior for the
initial log-volatility <code>h_0</code>. When <code>priorlatent0</code> is equal to a
number <code class="reqn">B</code>, we have <code class="reqn">h_0 \sim N(\mu, B\sigma^2)</code> a priori.</p>
</td></tr>
<tr><td><code id="svsample_+3A_priorspec">priorspec</code></td>
<td>
<p>in case one needs different prior distributions than the
ones specified by <code>priormu</code>, <code>...</code>, <code>priorrho</code>, a <code>priorspec</code>
object can be supplied here. A smart constructor for this usecase is
<a href="#topic+specify_priors">specify_priors</a>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_thin">thin</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinpara</code>th parameter and latent draw is kept and returned. The default
value is 1, corresponding to no thinning of the parameter draws i.e. every
draw is stored.</p>
</td></tr>
<tr><td><code id="svsample_+3A_thinpara">thinpara</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinpara</code>th parameter draw is kept and returned. The default
value is <code>thin</code>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_thinlatent">thinlatent</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinlatent</code>th latent variable draw is kept and returned. The
default value is <code>thin</code></p>
</td></tr>
<tr><td><code id="svsample_+3A_keeptime">keeptime</code></td>
<td>
<p>Either 'all' (the default) or 'last'. Indicates which latent
volatility draws should be stored.</p>
</td></tr>
<tr><td><code id="svsample_+3A_quiet">quiet</code></td>
<td>
<p>logical value indicating whether the progress bar and other
informative output during sampling should be omitted. The default value is
<code>FALSE</code>, implying verbose output.</p>
</td></tr>
<tr><td><code id="svsample_+3A_startpara">startpara</code></td>
<td>
<p><em>optional</em> named list, containing the starting values
for the parameter draws. If supplied, <code>startpara</code> may contain
elements named <code>mu</code>, <code>phi</code>, <code>sigma</code>, <code>nu</code>, <code>rho</code>,
<code>beta</code>, and <code>latent0</code>.
The default value is equal to the prior mean.
In case of parallel execution with <code>cl</code> provided, <code>startpara</code> can be a list of
named lists that initialize the parallel chains.</p>
</td></tr>
<tr><td><code id="svsample_+3A_startlatent">startlatent</code></td>
<td>
<p><em>optional</em> vector of length <code>length(y)</code>,
containing the starting values for the latent log-volatility draws. The
default value is <code>rep(-10, length(y))</code>.
In case of parallel execution with <code>cl</code> provided, <code>startlatent</code> can be a list of
numeric vectors that initialize the parallel chains.</p>
</td></tr>
<tr><td><code id="svsample_+3A_parallel">parallel</code></td>
<td>
<p><em>optional</em> one of <code>"no"</code> (default), <code>"multicore"</code>, or <code>"snow"</code>,
indicating what type of parallellism is to be applied. Option
<code>"multicore"</code> is not available on Windows.</p>
</td></tr>
<tr><td><code id="svsample_+3A_n_cpus">n_cpus</code></td>
<td>
<p><em>optional</em> positive integer, the number of CPUs to be used in case of
parallel computations. Defaults to <code>1L</code>. Ignored if parameter
<code>cl</code> is supplied and <code>parallel != "snow"</code>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_cl">cl</code></td>
<td>
<p><em>optional</em> so-called SNOW cluster object as implemented in package
<code>parallel</code>. Ignored unless <code>parallel == "snow"</code>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_n_chains">n_chains</code></td>
<td>
<p><em>optional</em> positive integer specifying the number of independent MCMC chains</p>
</td></tr>
<tr><td><code id="svsample_+3A_print_progress">print_progress</code></td>
<td>
<p><em>optional</em> one of <code>"automatic"</code>, <code>"progressbar"</code>,
or <code>"iteration"</code>, controls the output. Ignored if <code>quiet</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="svsample_+3A_expert">expert</code></td>
<td>
<p><em>optional</em> named list of expert parameters. For most
applications, the default values probably work best. Interested users are
referred to the literature provided in the References section. If
<code>expert</code> is provided, it may contain the following named elements:
</p>

<dl>
<dt>interweave</dt><dd><p> Logical value. If <code>TRUE</code> (the default),
then ancillarity-sufficiency interweaving strategy (ASIS) is applied
to improve on the sampling efficiency for the parameters.
Otherwise one parameterization is used.</p>
</dd>
<dt>correct_model_misspecification</dt><dd><p> Logical value. If <code>FALSE</code>
(the default), then auxiliary mixture sampling is used to sample the latent
states. If <code>TRUE</code>, extra computations are made to correct for model
misspecification either ex-post by reweighting or on-line using a
Metropolis-Hastings step.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="svsample_+3A_...">...</code></td>
<td>
<p>Any extra arguments will be forwarded to
<code><a href="#topic+updatesummary">updatesummary</a></code>, controlling the type of statistics calculated
for the posterior draws.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>svtsample</code>, <code>svlsample</code>, and <code>svtlsample</code> are
wrappers around <code>svsample</code> with convenient default values for the SV
model with t-errors, leverage, and both t-errors and leverage, respectively.
</p>
<p>For details concerning the algorithm please see the paper by Kastner and
Fr√ºhwirth-Schnatter (2014) and Hosszejni and Kastner (2019).
</p>


<h3>Value</h3>

<p>The value returned is a list object of class <code>svdraws</code> holding
</p>
<table>
<tr><td><code>para</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>parameter</em> draws from
the posterior distribution.</p>
</td></tr>
<tr><td><code>latent</code></td>
<td>
<p><code>mcmc.list</code> object containing the
<em>latent instantaneous log-volatility</em> draws from the posterior
distribution.</p>
</td></tr>
<tr><td><code>latent0</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>latent
initial log-volatility</em> draws from the posterior distribution.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>latent variance inflation
factors</em> for the sampler with conditional t-innovations <em>(optional)</em>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p><code>mcmc.list</code> object containing the <em>regression coefficient</em>
draws from the posterior distribution <em>(optional)</em>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the left hand side of the observation equation, usually
the argument <code>y</code>. In case of an AR(<code>k</code>) specification, the
first <code>k</code> elements are removed.</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p><code>proc_time</code> object containing the
run time of the sampler.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>a <code>priorspec</code> object containing the parameter
values of the prior distributions for <code>mu</code>,
<code>phi</code>, <code>sigma</code>, <code>nu</code>, <code>rho</code>, and
<code>beta</code>s, and the variance of specification for <code>latent0</code>.</p>
</td></tr>
<tr><td><code>thinning</code></td>
<td>
<p><code>list</code> containing the thinning
parameters, i.e. the arguments <code>thinpara</code>, <code>thinlatent</code> and
<code>keeptime</code>.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p><code>list</code> containing a collection of
summary statistics of the posterior draws for <code>para</code>, <code>latent</code>,
and <code>latent0</code>.</p>
</td></tr>
<tr><td><code>meanmodel</code></td>
<td>
<p><code>character</code> containing information about how <code>designmatrix</code>
was employed.</p>
</td></tr>
</table>
<p>To display the output, use <code>print</code>, <code>summary</code> and <code>plot</code>. The
<code>print</code> method simply prints the posterior draws (which is very likely
a lot of output); the <code>summary</code> method displays the summary statistics
currently stored in the object; the <code>plot</code> method
<code><a href="#topic+plot.svdraws">plot.svdraws</a></code> gives a graphical overview of the posterior
distribution by calling <code><a href="#topic+volplot">volplot</a></code>, <code>traceplot</code> and
<code>densplot</code> and displaying the results on a single page.
</p>


<h3>Note</h3>

<p>If <code>y</code> contains zeros, you might want to consider de-meaning your
returns or use <code>designmatrix = "ar0"</code>.
</p>
<p><code><a href="#topic+svsample2">svsample2</a></code> is deprecated.
</p>


<h3>References</h3>

<p>Kastner, G. and Fr√ºhwirth-Schnatter, S. (2014).
Ancillarity-sufficiency interweaving strategy (ASIS) for boosting MCMC
estimation of stochastic volatility models. <em>Computational Statistics &amp;
Data Analysis</em>, <b>76</b>, 408&ndash;423,
<a href="https://doi.org/10.1016/j.csda.2013.01.002">doi:10.1016/j.csda.2013.01.002</a>.
</p>
<p>Hosszejni, D. and Kastner, G. (2019).
Approaches Toward the Bayesian Estimation of the Stochastic Volatility Model with Leverage.
<em>Springer Proceedings in Mathematics &amp; Statistics</em>, <b>296</b>, 75&ndash;83,
<a href="https://doi.org/10.1007/978-3-030-30611-3_8">doi:10.1007/978-3-030-30611-3_8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svlm">svlm</a></code>, <code><a href="#topic+svsim">svsim</a></code>, <code><a href="#topic+specify_priors">specify_priors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###############
# Full examples
###############

# Example 1
## Simulate a short and highly persistent SV process 
sim &lt;- svsim(100, mu = -10, phi = 0.99, sigma = 0.2)

## Obtain 5000 draws from the sampler (that's not a lot)
draws &lt;-
  svsample(sim, draws = 5000, burnin = 100,
           priormu = c(-10, 1), priorphi = c(20, 1.5), priorsigma = 0.2)

## Check out the results
summary(draws)
plot(draws)



# Example 2
## Simulate an asymmetric and conditionally heavy-tailed SV process
sim &lt;- svsim(150, mu = -10, phi = 0.96, sigma = 0.3, nu = 10, rho = -0.3)

## Obtain 10000 draws from the sampler
## Use more advanced prior settings
## Run two parallel MCMC chains
advanced_draws &lt;-
  svsample(sim, draws = 10000, burnin = 5000,
           priorspec = specify_priors(mu = sv_normal(-10, 1),
                                      sigma2 = sv_gamma(0.5, 2),
                                      rho = sv_beta(4, 4),
                                      nu = sv_constant(5)),
           parallel = "snow", n_chains = 2, n_cpus = 2)

## Check out the results
summary(advanced_draws)
plot(advanced_draws)


# Example 3
## AR(1) structure for the mean
data(exrates)
len &lt;- 3000
ahead &lt;- 100
y &lt;- head(exrates$USD, len)

## Fit AR(1)-SVL model to EUR-USD exchange rates
res &lt;- svsample(y, designmatrix = "ar1")

## Use predict.svdraws to obtain predictive distributions
preddraws &lt;- predict(res, steps = ahead)

## Calculate predictive quantiles
predquants &lt;- apply(predy(preddraws), 2, quantile, c(.1, .5, .9))

## Visualize
expost &lt;- tail(head(exrates$USD, len+ahead), ahead)
ts.plot(y, xlim = c(length(y)-4*ahead, length(y)+ahead),
	       ylim = range(c(predquants, expost, tail(y, 4*ahead))))
for (i in 1:3) {
  lines((length(y)+1):(length(y)+ahead), predquants[i,],
        col = 3, lty = c(2, 1, 2)[i])
}
lines((length(y)+1):(length(y)+ahead), expost,
      col = 2)


# Example 4
## Predicting USD based on JPY and GBP in the mean
data(exrates)
len &lt;- 3000
ahead &lt;- 30
## Calculate log-returns
logreturns &lt;- apply(exrates[, c("USD", "JPY", "GBP")], 2,
                    function (x) diff(log(x)))
logretUSD &lt;- logreturns[2:(len+1), "USD"]
regressors &lt;- cbind(1, as.matrix(logreturns[1:len, ]))  # lagged by 1 day

## Fit SV model to EUR-USD exchange rates
res &lt;- svsample(logretUSD, designmatrix = regressors)

## Use predict.svdraws to obtain predictive distributions
predregressors &lt;- cbind(1, as.matrix(logreturns[(len+1):(len+ahead), ]))
preddraws &lt;- predict(res, steps = ahead,
                     newdata = predregressors)
predprice &lt;- exrates[len+2, "USD"] * exp(t(apply(predy(preddraws), 1, cumsum)))

## Calculate predictive quantiles
predquants &lt;- apply(predprice, 2, quantile, c(.1, .5, .9))

## Visualize
priceUSD &lt;- exrates[3:(len+2), "USD"]
expost &lt;- exrates[(len+3):(len+ahead+2), "USD"]
ts.plot(priceUSD, xlim = c(len-4*ahead, len+ahead+1),
	       ylim = range(c(expost, predquants, tail(priceUSD, 4*ahead))))
for (i in 1:3) {
  lines(len:(len+ahead), c(tail(priceUSD, 1), predquants[i,]),
        col = 3, lty = c(2, 1, 2)[i])
}
lines(len:(len+ahead), c(tail(priceUSD, 1), expost),
      col = 2)


########################
# Further short examples
########################

y &lt;- svsim(50, nu = 10, rho = -0.1)$y

# Supply initial values
res &lt;- svsample(y,
                startpara = list(mu = -10, sigma = 1))


# Supply initial values for parallel chains
res &lt;- svsample(y,
                startpara = list(list(mu = -10, sigma = 1),
                                 list(mu = -11, sigma = .1, phi = 0.9),
                                 list(mu = -9, sigma = .3, phi = 0.7)),
                parallel = "snow", n_chains = 3, n_cpus = 2)

# Parallel chains with with a pre-defined cluster object
cl &lt;- parallel::makeCluster(2, "PSOCK", outfile = NULL)  # print to console
res &lt;- svsample(y,
                parallel = "snow", n_chains = 3, cl = cl)
parallel::stopCluster(cl)


# Turn on correction for model misspecification
## Since the approximate model is fast and it is working very
##   well in practice, this is turned off by default
res &lt;- svsample(y,
                expert = list(correct_model_misspecification = TRUE))
print(res)

## Not run: 
# Parallel multicore chains (not available on Windows)
res &lt;- svsample(y, draws = 30000, burnin = 10000,
                parallel = "multicore", n_chains = 3, n_cpus = 2)

# Plot using a color palette
palette(rainbow(coda::nchain(para(res, "all"))))
plot(res)

# Use functionality from package 'coda'
## E.g. Geweke's convergence diagnostics
coda::geweke.diag(para(res, "all")[, c("mu", "phi", "sigma")])

# Use functionality from package 'bayesplot'
bayesplot::mcmc_pairs(res, pars = c("sigma", "mu", "phi", "h_0", "h_15"))

## End(Not run)

</code></pre>

<hr>
<h2 id='svsample_fast_cpp'>Bindings to <code>C++</code> Functions in <code>stochvol</code></h2><span id='topic+svsample_fast_cpp'></span><span id='topic+svsample_general_cpp'></span>

<h3>Description</h3>

<p>All the heavy lifting in <code>stochvol</code> is implemented in <code>C++</code>
with the help of <code>R</code> packages <code>Rcpp</code> and <code>RcppArmadillo</code>.
These functions call the MCMC samplers in <code>C++</code> directly without any
any validation and transformations, expert use only!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svsample_fast_cpp(
  y,
  draws = 1,
  burnin = 0,
  designmatrix = matrix(NA),
  priorspec = specify_priors(),
  thinpara = 1,
  thinlatent = 1,
  keeptime = "all",
  startpara,
  startlatent,
  keeptau = !inherits(priorspec$nu, "sv_infinity"),
  print_settings = list(quiet = TRUE, n_chains = 1, chain = 1),
  correct_model_misspecification = FALSE,
  interweave = TRUE,
  myoffset = 0,
  fast_sv = get_default_fast_sv()
)

svsample_general_cpp(
  y,
  draws = 1,
  burnin = 0,
  designmatrix = matrix(NA),
  priorspec = specify_priors(),
  thinpara = 1,
  thinlatent = 1,
  keeptime = "all",
  startpara,
  startlatent,
  keeptau = !inherits(priorspec$nu, "sv_infinity"),
  print_settings = list(quiet = TRUE, n_chains = 1, chain = 1),
  correct_model_misspecification = FALSE,
  interweave = TRUE,
  myoffset = 0,
  general_sv = get_default_general_sv(priorspec)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svsample_fast_cpp_+3A_y">y</code></td>
<td>
<p>numeric vector of the observations</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_draws">draws</code></td>
<td>
<p>single positive integer, the number of draws to
return (after the burn-in)</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_burnin">burnin</code></td>
<td>
<p>single positive integer, length of warm-up
period, this number of draws are discarded from the beginning</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_designmatrix">designmatrix</code></td>
<td>
<p>numeric matrix of covariates. Dimensions:
<code>length(y)</code> times the number of covariates. If there are
no covariates then this should be <code>matrix(NA)</code></p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_priorspec">priorspec</code></td>
<td>
<p>a <code>priorspec</code> object created by
<code><a href="#topic+specify_priors">specify_priors</a></code></p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_thinpara">thinpara</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinpara</code>th parameter draw is kept and returned. The default
value is 1, corresponding to no thinning of the parameter draws i.e. every
draw is stored.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_thinlatent">thinlatent</code></td>
<td>
<p>single number greater or equal to 1, coercible to integer.
Every <code>thinlatent</code>th latent variable draw is kept and returned. The
default value is 1, corresponding to no thinning of the latent variable
draws, i.e. every draw is kept.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_keeptime">keeptime</code></td>
<td>
<p>Either 'all' (the default) or 'last'. Indicates which latent
volatility draws should be stored.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_startpara">startpara</code></td>
<td>
<p>named list, containing the starting values
for the parameter draws. It must contain
elements
</p>

<ul>
<li><p>mu: an arbitrary numerical value
</p>
</li>
<li><p>phi: real number between <code>-1</code> and <code>1</code>
</p>
</li>
<li><p>sigma: a positive real number
</p>
</li>
<li><p>nu: a number larger than <code>2</code>; can be <code>Inf</code>
</p>
</li>
<li><p>rho: real number between <code>-1</code> and <code>1</code>
</p>
</li>
<li><p>beta: a numeric vector of the same length as the number of covariates
</p>
</li>
<li><p>latent0: a single number, the initial value for <code>h0</code></p>
</li></ul>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_startlatent">startlatent</code></td>
<td>
<p>vector of length <code>length(y)</code>,
containing the starting values for the latent log-volatility draws.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_keeptau">keeptau</code></td>
<td>
<p>Logical value indicating whether the 'variance inflation
factors' should be stored (used for the sampler with conditional t
innovations only). This may be useful to check at what point(s) in time the
normal disturbance had to be 'upscaled' by a mixture factor and when the
series behaved 'normally'.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_print_settings">print_settings</code></td>
<td>
<p>List of three elements:
</p>

<ul>
<li><p>quiet: logical value indicating whether the progress bar and other
informative output during sampling should be omitted
</p>
</li>
<li><p>n_chains: number of independent MCMC chains
</p>
</li>
<li><p>chain: index of this chain</p>
</li></ul>

<p>Please note that this function does not run multiple independent chains
but <code><a href="#topic+svsample">svsample</a></code> offers different printing functionality depending on
whether it is executed as part of several MCMC chains in parallel
(chain specific messages) or simply as a single chain (progress bar).</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_correct_model_misspecification">correct_model_misspecification</code></td>
<td>
<p>Logical value. If <code>FALSE</code>,
then auxiliary mixture sampling is used to sample the latent
states. If <code>TRUE</code>, extra computations are made to correct for model
misspecification either ex-post by reweighting or on-line using a
Metropolis-Hastings step.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_interweave">interweave</code></td>
<td>
<p>Logical value. If <code>TRUE</code>,
then ancillarity-sufficiency interweaving strategy (ASIS) is applied
to improve on the sampling efficiency for the parameters.
Otherwise one parameterization is used.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_myoffset">myoffset</code></td>
<td>
<p>Single non-negative number that is used in
<code>log(y^2 + myoffset)</code> to prevent <code>-Inf</code> values in the auxiliary
mixture sampling scheme.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_fast_sv">fast_sv</code></td>
<td>
<p>named list of expert settings. We recommend the use of <code><a href="#topic+get_default_fast_sv">get_default_fast_sv</a></code>.</p>
</td></tr>
<tr><td><code id="svsample_fast_cpp_+3A_general_sv">general_sv</code></td>
<td>
<p>named list of expert settings. We recommend the use of <code><a href="#topic+get_default_general_sv">get_default_general_sv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling functions are separated into fast SV and general SV. See more details
in the sections below.
</p>


<h3>Fast SV</h3>

<p>Fast SV was developed in Kastner and Fruehwirth-Schnatter (2014). Fast SV estimates an
approximate SV model without leverage, where the approximation comes in through
auxiliary mixture approximations to the exact SV model. The sampler uses
the ancillarity-sufficiency interweaving strategy (ASIS) to improve on the sampling
efficiency of the model parameters, and it employs all-without-a-loop (AWOL)
for computationally efficient Kalman filtering of the conditionally Gaussian state space.
Correction for model misspecification happens as a post-processing step.
</p>
<p>Fast SV employs sampling strategies that have been fine-tuned and specified for
vanilla SV (no leverage), and hence it can be fast and efficient but also more limited
in its feature set. The conditions for the fast SV sampler: <code>rho == 0</code>; <code>mu</code>
has either a normal prior or it is also constant <code>0</code>; the prior for <code>phi</code>
is a beta distribution; the prior for <code>sigma^2</code> is either a gamma distribution
with shape <code>0.5</code> or a mean- and variance-matched inverse gamma distribution;
either <code>keeptime == 'all'</code> or <code>correct_model_misspecification == FALSE</code>.
These criteria are NOT VALIDATED by fast SV on the <code>C++</code> level!
</p>


<h3>General SV</h3>

<p>General SV also estimates an
approximate SV model without leverage, where the approximation comes in through
auxiliary mixture approximations to the exact SV model. The sampler uses
both ASIS and AWOL.
</p>
<p>General SV employs adapted random walk Metropolis-Hastings as the proposal for
the parameters <code>mu</code>, <code>phi</code>, <code>sigma</code>, and <code>rho</code>. Therefore,
more general prior distributions are allowed in this case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Draw one sample using fast SV and general SV
y &lt;- svsim(40)$y
params &lt;- list(mu = -10, phi = 0.9, sigma = 0.1,
               nu = Inf, rho = 0, beta = NA,
               latent0 = -10)
res_fast &lt;- svsample_fast_cpp(y,
  startpara = params, startlatent = rep(-10, 40))
res_gen &lt;- svsample_general_cpp(y,
  startpara = params, startlatent = rep(-10, 40))

# Embed SV in another sampling scheme
## vanilla SV
len &lt;- 40L
draws &lt;- 1000L
burnin &lt;- 200L
param_store &lt;- matrix(NA, draws, 3,
                      dimnames = list(NULL,
                                      c("mu", "phi", "sigma")))
startpara &lt;- list(mu = 0, phi = 0.9, sigma = 0.1,
                  nu = Inf, rho = 0, beta = NA,
                  latent0 = 0)
startlatent &lt;- rep(0, len)
for (i in seq_len(burnin+draws)) {
  # draw the data in the bigger sampling scheme
  # now we simulate y from vanilla SV
  y &lt;- svsim(len, mu = 0, phi = 0.9, sigma = 0.1)$y
  # call SV sampler
  res &lt;- svsample_fast_cpp(y, startpara = startpara,
                           startlatent = startlatent)
  # administrate values
  startpara[c("mu","phi","sigma")] &lt;-
    as.list(res$para[, c("mu", "phi", "sigma")])
  startlatent &lt;- drop(res$latent)
  # store draws after the burnin
  if (i &gt; burnin) {
    param_store[i-burnin, ] &lt;-
      res$para[, c("mu", "phi", "sigma")]
  }
}
### quick look at the traceplots
ts.plot(param_store, col = 1:3)

</code></pre>

<hr>
<h2 id='svsample_roll'>Rolling Estimation of Stochastic Volatility Models</h2><span id='topic+svsample_roll'></span><span id='topic+svtsample_roll'></span><span id='topic+svlsample_roll'></span><span id='topic+svtlsample_roll'></span>

<h3>Description</h3>

<p><code>svsample_roll</code> performs rolling window estimation based on <a href="#topic+svsample">svsample</a>.
A convenience function for backtesting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)

svtsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)

svlsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)

svtlsample_roll(
  y,
  designmatrix = NA,
  n_ahead = 1,
  forecast_length = 500,
  n_start = NULL,
  refit_every = 1,
  refit_window = c("moving", "expanding"),
  calculate_quantile = c(0.01),
  calculate_predictive_likelihood = TRUE,
  keep_draws = FALSE,
  parallel = c("no", "multicore", "snow"),
  n_cpus = 1L,
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svsample_roll_+3A_y">y</code></td>
<td>
<p>numeric vector containing the data (usually log-returns), which
must not contain zeros. Alternatively, <code>y</code> can be an <code>svsim</code>
object. In this case, the returns will be extracted and a message is signalled.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_designmatrix">designmatrix</code></td>
<td>
<p>regression design matrix for modeling the mean. Must
have <code>length(y)</code> rows. Alternatively, <code>designmatrix</code> may be a
string of the form <code>"arX"</code>, where <code>X</code> is a nonnegative integer. To
fit a constant mean model, use <code>designmatrix = "ar0"</code> (which is
equivalent to <code>designmatrix = matrix(1, nrow = length(y))</code>). To fit an
AR(1) model, use <code>designmatrix = "ar1"</code>, and so on. If some elements of
<code>designmatrix</code> are <code>NA</code>, the mean is fixed to zero (pre-1.2.0
behavior of <span class="pkg">stochvol</span>).</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_n_ahead">n_ahead</code></td>
<td>
<p>number of time steps to predict from each time window.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_forecast_length">forecast_length</code></td>
<td>
<p>the time horizon at the end of the data set
that is used for backtesting.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_n_start">n_start</code></td>
<td>
<p><em>optional</em> the starting time point for backtesting.
Computed from <code>forecast_length</code> if omitted.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_refit_every">refit_every</code></td>
<td>
<p>the SV model is refit every <code>refit_every</code> time steps.
Only the value <code>1</code> is allowed.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_refit_window">refit_window</code></td>
<td>
<p>one of <code>"moving"</code> or <code>"expanding"</code>. If
<code>"expanding"</code>, then the start of the time window stays
at the beginning of the data set. If <code>"moving"</code>, then the
length of the time window is constant throughout backtesting.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_calculate_quantile">calculate_quantile</code></td>
<td>
<p>vector of numbers between 0 and 1.
These quantiles are predicted using <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>
for each time window.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_calculate_predictive_likelihood">calculate_predictive_likelihood</code></td>
<td>
<p>boolean. If <code>TRUE</code>,
the <code>n_ahead</code> predictive density is evaluated at the
<code>n_ahead</code> time observation after each time window.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_keep_draws">keep_draws</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the <code>svdraws</code> and
the <code>svpredict</code> objects are kept from each time window.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_parallel">parallel</code></td>
<td>
<p>one of <code>"no"</code> (default), <code>"multicore"</code>, or <code>"snow"</code>,
indicating what type of parallellism is to be applied. Option
<code>"multicore"</code> is not available on Windows.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_n_cpus">n_cpus</code></td>
<td>
<p><em>optional</em> positive integer, the number of CPUs to be used in case of
parallel computations. Defaults to <code>1L</code>. Ignored if parameter
<code>cl</code> is supplied and <code>parallel != "snow"</code>.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_cl">cl</code></td>
<td>
<p><em>optional</em> so-called SNOW cluster object as implemented in package
<code>parallel</code>. Ignored unless <code>parallel == "snow"</code>.</p>
</td></tr>
<tr><td><code id="svsample_roll_+3A_...">...</code></td>
<td>
<p>Any extra arguments will be forwarded to
<code><a href="#topic+svsample">svsample</a></code>, controlling the prior setup, the starting values for the
MCMC chains, the number of independent MCMC chains, thinning and other expert
settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>svtsample_roll</code>, <code>svlsample_roll</code>, and <code>svtlsample_roll</code> are
wrappers around <code>svsample_roll</code> with convenient default values for the SV
model with t-errors, leverage, and both t-errors and leverage, respectively.
</p>


<h3>Value</h3>

<p>The value returned is a list object of class <code>svdraws_roll</code>
holding a list item for every time window. The elements of these list items are
</p>
<table>
<tr><td><code>indices</code></td>
<td>
<p>a list object containing two elements: <code>train</code> is the vector
of indices used for fitting the model, and <code>test</code> is the vector of indices
used for prediction. The latter is mainly useful if a <code>designmatrix</code> is provided.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>the input parameter <code>calculate_quantiles</code>.</p>
</td></tr>
<tr><td><code>refit_every</code></td>
<td>
<p>the input parameter <code>refit_every</code>.</p>
</td></tr>
<tr><td><code>predictive_likelihood</code></td>
<td>
<p>present only if <code>calculate_predictive_likelihood</code>
is <code>TRUE</code>. Then it is a number, the expected predictive density
of the observation. The expecation is taken over the joint <code>n_ahead</code> predictive
distribution of all model parameters.</p>
</td></tr>
<tr><td><code>predictive_quantile</code></td>
<td>
<p>present only if <code>calculate_quantile</code> is a non-empty
vector. Then it is a vector of quantiles from the <code>n_ahead</code> predictive
distribution of <code>y</code>. It is based on MCMC simulation by using <code><a href="stats.html#topic+predict">predict</a></code>.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>present only if <code>keep_draws</code> is <code>TRUE</code>. Then it is an
<code>svdraws</code> object as returned by <code><a href="#topic+svsample">svsample</a></code>.</p>
</td></tr>
<tr><td><code>prediction</code></td>
<td>
<p>present only if <code>keep_draws</code> is <code>TRUE</code>. Then it is an
<code>svpredict</code> object as returned by <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>.</p>
</td></tr>
</table>
<p>To display the output, use <code>print</code> and <code>summary</code>. The
<code>print</code> method simply prints a short summary of the setup;
the <code>summary</code> method displays the summary statistics
of the backtesting.
</p>


<h3>Note</h3>

<p>The function executes <code><a href="#topic+svsample">svsample</a></code> <code>(length(y) - arorder - n_ahead - n_start + 2) %/% refit_every</code> times.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svsim">svsim</a></code>, <code><a href="#topic+specify_priors">specify_priors</a></code>, <code><a href="#topic+svsample">svsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate from the true model
sim &lt;- svsim(200)

# Perform rolling estimation using the vanilla SV
# model and default priors
roll &lt;- svsample_roll(sim, draws = 5000, burnin = 2000,
                      keep_draws = TRUE,
                      forecast_length = 10,
                      n_ahead = 1, refit_every = 1,
                      refit_window = "moving",
                      calculate_predictive_likelihood = TRUE,
                      calculate_quantile = c(0.01, 0.05))

# Perform rolling estimation by making use
# of two CPU cores, advanced priors, and multiple
# chains with pre-set initial values. Let us combine
# that with an AR(2) specification
prior_beta &lt;- sv_multinormal(c(1,0,-1), rbind(c(1, 0, 0.1),
                                              c(0, 0.3, -0.04),
                                              c(0.1, -0.04, 0.1)))
priorspec &lt;- specify_priors(rho = sv_beta(4, 4),
                            latent0_variance = sv_constant(1),
                            beta = prior_beta,
                            nu = sv_exponential(0.05))
startpara &lt;- list(list(mu = -9, phi = 0.3),
                  list(mu = -11, sigma = 0.1, phi = 0.95),
                  list(phi = 0.99))
roll &lt;- svsample_roll(sim, draws = 5000, burnin = 2000,
                      designmatrix = "ar2",
                      priorspec = priorspec,
                      startpara = startpara,
                      parallel = "snow", n_cpus = 2,
                      n_chains = 3,
                      keep_draws = TRUE,
                      forecast_length = 10,
                      n_ahead = 1, refit_every = 1,
                      refit_window = "expanding",
                      calculate_predictive_likelihood = TRUE,
                      calculate_quantile = c(0.01, 0.05))

</code></pre>

<hr>
<h2 id='svsim'>Simulating a Stochastic Volatility Process</h2><span id='topic+svsim'></span>

<h3>Description</h3>

<p><code>svsim</code> is used to produce realizations of a stochastic volatility (SV)
process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svsim(len, mu = -10, phi = 0.98, sigma = 0.2, nu = Inf, rho = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svsim_+3A_len">len</code></td>
<td>
<p>length of the simulated time series.</p>
</td></tr>
<tr><td><code id="svsim_+3A_mu">mu</code></td>
<td>
<p>level of the latent log-volatility AR(1) process. The defaults
value is <code>-10</code>.</p>
</td></tr>
<tr><td><code id="svsim_+3A_phi">phi</code></td>
<td>
<p>persistence of the latent log-volatility AR(1) process. The
default value is <code>0.98</code>.</p>
</td></tr>
<tr><td><code id="svsim_+3A_sigma">sigma</code></td>
<td>
<p>volatility of the latent log-volatility AR(1) process. The
default value is <code>0.2</code>.</p>
</td></tr>
<tr><td><code id="svsim_+3A_nu">nu</code></td>
<td>
<p>degrees-of-freedom for the conditional innovations distribution.
The default value is <code>Inf</code>, corresponding to standard normal
conditional innovations.</p>
</td></tr>
<tr><td><code id="svsim_+3A_rho">rho</code></td>
<td>
<p>correlation between the observation and the increment of the
log-volatility. The default value is <code>0</code>, corresponding to the basic
SV model with symmetric &ldquo;log-returns&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function draws an initial log-volatility <code>h_0</code> from the stationary
distribution of the AR(1) process defined by <code>phi</code>, <code>sigma</code>, and <code>mu</code>.
Then the function jointly simulates the log-volatility series
<code>h_1,...,h_n</code> with the given AR(1) structure, and the &ldquo;log-return&rdquo; series
<code>y_1,...,y_n</code> with mean 0 and standard deviation <code>exp(h/2)</code>.
Additionally, for each index <code>i</code>, <code>y_i</code> can be set to have a conditionally heavy-tailed
residual (through <code>nu</code>) and/or to be correlated with <code>(h_{i+1}-h_i)</code>
(through <code>rho</code>, the so-called leverage effect, resulting in asymmetric &ldquo;log-returns&rdquo;).
</p>


<h3>Value</h3>

<p>The output is a list object of class <code>svsim</code> containing
</p>

<dl>
<dt>y</dt><dd><p>vector of length <code>len</code> containing the simulated data,
usually interpreted as &ldquo;log-returns&rdquo;.</p>
</dd>
<dt>vol</dt><dd><p>vector of length
<code>len</code> containing the simulated instantaneous volatilities.
These are <code class="reqn">e^{h_t/2}</code> if <code>nu == Inf</code>, and they are
<code class="reqn">e^{h_t/2} \sqrt{\tau_t}</code> for finite <code>nu</code>.</p>
</dd>
<dt>vol0</dt><dd><p>The initial volatility <code>exp(h_0/2)</code>,
drawn from the stationary distribution of the latent AR(1) process.</p>
</dd>
<dt>para</dt><dd><p>a named list with five elements <code>mu</code>, <code>phi</code>,
<code>sigma</code>, <code>nu</code>, and <code>rho</code>, containing
the corresponding arguments.</p>
</dd>
<dt>latent</dt><dd><p>vector of the latent state space <code class="reqn">h_t</code> for <code class="reqn">t &gt; 0</code>.</p>
</dd>
<dt>latent0</dt><dd><p>initial element of the latent state space <code class="reqn">h_0</code>.</p>
</dd>
<dt>tau</dt><dd><p>vector of length <code>len</code> containing the simulated auxiliary
variables for the Student-t residuals when <code>nu</code> is finite. More precisely,
<code class="reqn">\tau_t\sim\text{Gamma}^{-1}(\text{shape}=\nu/2, \text{rate}=\nu/2-1)</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The function generates the &ldquo;log-returns&rdquo; by
<code>y &lt;- exp(-h/2)*rt(h, df=nu)</code>. That means that in the case of <code>nu &lt; Inf</code>
the (conditional) volatility is <code>sqrt(nu/(nu-2))*exp(h/2)</code>, and that corrected value
is shown in the <code>print</code>, <code>summary</code> and <code>plot</code> methods.
</p>
<p>To display the output use <code>print</code>, <code>summary</code> and <code>plot</code>. The
<code>print</code> method simply prints the content of the object in a moderately
formatted manner. The <code>summary</code> method provides some summary statistics
(in %), and the <code>plot</code> method plots the the simulated 'log-returns'
<code>y</code> along with the corresponding volatilities <code>vol</code>.
</p>


<h3>Author(s)</h3>

<p>Gregor Kastner <a href="mailto:gregor.kastner@wu.ac.at">gregor.kastner@wu.ac.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svsample">svsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a highly persistent SV process of length 500
sim &lt;- svsim(500, phi = 0.99, sigma = 0.1)

print(sim)
summary(sim)
plot(sim)

## Simulate an SV process with leverage
sim &lt;- svsim(200, phi = 0.94, sigma = 0.15, rho = -0.6)

print(sim)
summary(sim)
plot(sim)

## Simulate an SV process with conditionally heavy-tails
sim &lt;- svsim(250, phi = 0.91, sigma = 0.05, nu = 5)

print(sim)
summary(sim)
plot(sim)

</code></pre>

<hr>
<h2 id='update_fast_sv'>Single MCMC Update Using Fast SV</h2><span id='topic+update_fast_sv'></span>

<h3>Description</h3>

<p>Samples the mixture indicators, the latent variables, and the model independent
parameters mu, phi, and sigma. The input is the logarithm of the squared de-meaned
observations. An approximate SV model is estimated instead of the exact SV model
by the use of auxiliary mixture sampling.
Depending on the prior specification, mu might not be updated.
Depending on the expert settings, the function might follow the ancillarity-sufficiency
interweaving strategy (ASIS, Yu and Meng, 2011) for sampling mu, phi, and sigma.
Furthermore, the user can turn off the sampling of the parameters, the latents, or the
mixture indicators in the expert settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_fast_sv(log_data2, mu, phi, sigma, h0, h, r, prior_spec, expert)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_fast_sv_+3A_log_data2">log_data2</code></td>
<td>
<p>log(data^2), where data is the vector of de-meaned observations</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_mu">mu</code></td>
<td>
<p>parameter mu. Level of the latent process h. Updated in place</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_phi">phi</code></td>
<td>
<p>parameter phi, persistence of the latent process h. Updated in place</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_sigma">sigma</code></td>
<td>
<p>parameter sigma, volatility of the latent process h, also called volvol. Updated in place</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_h0">h0</code></td>
<td>
<p>parameter h0, the initial value of the latent process h. Updated in place</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_h">h</code></td>
<td>
<p>the vector of the latent process. Updated in place</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_r">r</code></td>
<td>
<p>the vector of the mixture indicators. Updated in place</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_prior_spec">prior_spec</code></td>
<td>
<p>prior specification object. See type_definitions.h</p>
</td></tr>
<tr><td><code id="update_fast_sv_+3A_expert">expert</code></td>
<td>
<p>expert settings for this function. See type_definitions.h</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other stochvol_cpp: 
<code><a href="#topic+update_general_sv">update_general_sv</a>()</code>,
<code><a href="#topic+update_regressors">update_regressors</a>()</code>,
<code><a href="#topic+update_t_error">update_t_error</a>()</code>
</p>

<hr>
<h2 id='update_general_sv'>Single MCMC Update Using General SV</h2><span id='topic+update_general_sv'></span>

<h3>Description</h3>

<p>Samples the latent variables and the model independent parameters mu, phi, sigma,
and rho. The observations need to be provided in different formats for efficiency.
An approximate SV model is as the default posterior distribution for the latent vector; however,
there is the option to correct for model misspecification through the expert settings.
Depending on the prior specification, some of mu, phi, sigma, and rho might not be updated.
Depending on the expert settings, the function might follow the ancillarity-sufficiency
interweaving strategy (ASIS, Yu and Meng, 2011) for sampling mu, phi, sigma, and rho.
Also controlled by the expert settings, 
Furthermore, the user can turn off the sampling of the parameters, the latents, or the
mixture indicators in the expert settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_general_sv(
  data,
  log_data2,
  sign_data,
  mu,
  phi,
  sigma,
  rho,
  h0,
  h,
  adaptation,
  prior_spec,
  expert
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_general_sv_+3A_data">data</code></td>
<td>
<p>the vector of de-meaned observations</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_log_data2">log_data2</code></td>
<td>
<p>log(data^2), where data is the vector of de-meaned observations</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_sign_data">sign_data</code></td>
<td>
<p>the sign of the data</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_mu">mu</code></td>
<td>
<p>parameter mu. Level of the latent process h. Updated in place</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_phi">phi</code></td>
<td>
<p>parameter phi, persistence of the latent process h. Updated in place</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_sigma">sigma</code></td>
<td>
<p>parameter sigma, volatility of the latent process h, also called volvol. Updated in place</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_rho">rho</code></td>
<td>
<p>parameter rho. Accounts for asymmetry/the leverage effect. Updated in place</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_h0">h0</code></td>
<td>
<p>parameter h0, the initial value of the latent process h. Updated in place</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_h">h</code></td>
<td>
<p>the vector of the latent process. Updated in place</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_adaptation">adaptation</code></td>
<td>
<p>object implementing the adaptive Metropolis-Hastings scheme. Updated in place. See adaptation.hpp</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_prior_spec">prior_spec</code></td>
<td>
<p>prior specification object. See type_definitions.h</p>
</td></tr>
<tr><td><code id="update_general_sv_+3A_expert">expert</code></td>
<td>
<p>expert settings for this function. See type_definitions.h</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other stochvol_cpp: 
<code><a href="#topic+update_fast_sv">update_fast_sv</a>()</code>,
<code><a href="#topic+update_regressors">update_regressors</a>()</code>,
<code><a href="#topic+update_t_error">update_t_error</a>()</code>
</p>

<hr>
<h2 id='update_regressors'>Single MCMC update of Bayesian linear regression</h2><span id='topic+update_regressors'></span>

<h3>Description</h3>

<p>Samples the coefficients of a linear regression. The prior
distribution is multivariate normal and it is specified in
prior_spec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_regressors(dependent_variable, independent_variables, beta, prior_spec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_regressors_+3A_dependent_variable">dependent_variable</code></td>
<td>
<p>the left hand side</p>
</td></tr>
<tr><td><code id="update_regressors_+3A_independent_variables">independent_variables</code></td>
<td>
<p>the matrix of the independent variables. Has to be of same height as the length of the dependent variable</p>
</td></tr>
<tr><td><code id="update_regressors_+3A_beta">beta</code></td>
<td>
<p>the vector of the latent states used in MDA. Updated in place</p>
</td></tr>
<tr><td><code id="update_regressors_+3A_prior_spec">prior_spec</code></td>
<td>
<p>prior specification object. See type_definitions.h</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other stochvol_cpp: 
<code><a href="#topic+update_fast_sv">update_fast_sv</a>()</code>,
<code><a href="#topic+update_general_sv">update_general_sv</a>()</code>,
<code><a href="#topic+update_t_error">update_t_error</a>()</code>
</p>

<hr>
<h2 id='update_t_error'>Single MCMC update to Student's t-distribution</h2><span id='topic+update_t_error'></span>

<h3>Description</h3>

<p>Samples the degrees of freedom parameter of standardized and homoskedastic
t-distributed input variates. Marginal data augmentation (MDA) is applied, tau
is the vector of auxiliary latent states.
Depending on the prior specification, nu might not be updated, just tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_t_error(
  homosked_data,
  tau,
  mean,
  sd,
  nu,
  prior_spec,
  do_tau_acceptance_rejection = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_t_error_+3A_homosked_data">homosked_data</code></td>
<td>
<p>de-meaned and homoskedastic observations</p>
</td></tr>
<tr><td><code id="update_t_error_+3A_tau">tau</code></td>
<td>
<p>the vector of the latent states used in MDA. Updated in place</p>
</td></tr>
<tr><td><code id="update_t_error_+3A_mean">mean</code></td>
<td>
<p>the vector of the conditional means  // TODO update docs in R</p>
</td></tr>
<tr><td><code id="update_t_error_+3A_sd">sd</code></td>
<td>
<p>the vector of the conditional standard deviations</p>
</td></tr>
<tr><td><code id="update_t_error_+3A_nu">nu</code></td>
<td>
<p>parameter nu. The degrees of freedom for the t-distribution. Updated in place</p>
</td></tr>
<tr><td><code id="update_t_error_+3A_prior_spec">prior_spec</code></td>
<td>
<p>prior specification object. See type_definitions.h</p>
</td></tr>
<tr><td><code id="update_t_error_+3A_do_tau_acceptance_rejection">do_tau_acceptance_rejection</code></td>
<td>
<p>boolean. If <code>TRUE</code>, there is a correction for non-zero <code>mean</code> and non-unit <code>sd</code>, otherwise the proposal distribution is used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function samples tau and nu from the following hierarchical model:
homosked_data_i = sqrt(tau_i) * (mean_i + sd_i * N(0, 1))
tau_i ~ InvGamma(.5*nu, .5*(nu-2))
Naming: The data is homoskedastic ex ante in the model, mean_i and sd_i are conditional
on some other parameter in the model.
The prior on tau corresponds to a standardized t-distributed heavy tail on the data.
</p>


<h3>See Also</h3>

<p>Other stochvol_cpp: 
<code><a href="#topic+update_fast_sv">update_fast_sv</a>()</code>,
<code><a href="#topic+update_general_sv">update_general_sv</a>()</code>,
<code><a href="#topic+update_regressors">update_regressors</a>()</code>
</p>

<hr>
<h2 id='updatesummary'>Updating the Summary of MCMC Draws</h2><span id='topic+updatesummary'></span>

<h3>Description</h3>

<p>Creates or updates a summary of an <code>svdraws</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatesummary(
  x,
  quantiles = c(0.05, 0.5, 0.95),
  esspara = TRUE,
  esslatent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatesummary_+3A_x">x</code></td>
<td>
<p><code>svdraws</code> object.</p>
</td></tr>
<tr><td><code id="updatesummary_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector of posterior quantiles to be computed. The
default is <code>c(0.05, 0.5, 0.95)</code>.</p>
</td></tr>
<tr><td><code id="updatesummary_+3A_esspara">esspara</code></td>
<td>
<p>logical value which indicates whether the effective sample
size (ESS) should be calculated for the <em>parameter draws</em>. This is
achieved by calling <code><a href="coda.html#topic+effectiveSize">effectiveSize</a></code> from the <code>coda</code>
package. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="updatesummary_+3A_esslatent">esslatent</code></td>
<td>
<p>logical value which indicates whether the effective sample
size (ESS) should be calculated for the <em>latent log-volatility</em> draws.
This is achieved by calling <code><a href="coda.html#topic+effectiveSize">effectiveSize</a></code> from the
<code>coda</code> package. The default is <code>FALSE</code>, because this can be quite
time-consuming when many latent variables are present.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>updatesummary</code> will always calculate the posterior mean and the
posterior standard deviation of the raw draws and some common
transformations thereof. Moroever, the posterior quantiles, specified by the
argument <code>quantiles</code>, are computed. If <code>esspara</code> and/or
<code>esslatent</code> are <code>TRUE</code>, the corresponding effective sample size
(ESS) will also be included.
</p>


<h3>Value</h3>

<p>The value returned is an updated list object of class <code>svdraws</code>
holding </p>
<table>
<tr><td><code>para</code></td>
<td>
<p><code>mcmc</code> object containing the <em>parameter</em> draws
from the posterior distribution.</p>
</td></tr> <tr><td><code>latent</code></td>
<td>
<p><code>mcmc</code> object
containing the <em>latent instantaneous log-volatility</em> draws from the
posterior distribution.</p>
</td></tr> <tr><td><code>latent0</code></td>
<td>
<p><code>mcmc</code> object containing the
<em>latent initial log-volatility</em> draws from the posterior distribution.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>argument <code>y</code>.</p>
</td></tr> <tr><td><code>runtime</code></td>
<td>
<p><code>"proc_time"</code> object
containing the run time of the sampler.</p>
</td></tr> <tr><td><code>priors</code></td>
<td>
<p><code>list</code>
containing the parameter values of the prior distribution, i.e. the
arguments <code>priormu</code>, <code>priorphi</code>, <code>priorsigma</code> (and
potentially <code>nu</code>).</p>
</td></tr> <tr><td><code>thinning</code></td>
<td>
<p><code>list</code> containing the thinning
parameters, i.e. the arguments <code>thinpara</code>, <code>thinlatent</code> and
<code>keeptime</code>.</p>
</td></tr> <tr><td><code>summary</code></td>
<td>
<p><code>list</code> containing a collection of
summary statistics of the posterior draws for <code>para</code>, <code>latent</code>,
and <code>latent0</code>.</p>
</td></tr>
</table>
<p>To display the output, use <code>print</code>, <code>summary</code> and <code>plot</code>. The
<code>print</code> method simply prints the posterior draws (which is very likely
a lot of output); the <code>summary</code> method displays the summary statistics
currently stored in the object; the <code>plot</code> method gives a graphical
overview of the posterior distribution by calling <code><a href="#topic+volplot">volplot</a></code>,
<code>traceplot</code> and <code>densplot</code> and displaying the
results on a single page.
</p>


<h3>Note</h3>

<p><code>updatesummary</code> does not actually overwrite the object's current
summary, but in fact creates a new object with an updated summary. Thus,
don't forget to overwrite the old object if this is want you intend to do.
See the examples below for more details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svsample">svsample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Here is a baby-example to illustrate the idea.
## Simulate an SV time series of length 51 with default parameters:
sim &lt;- svsim(51)

## Draw from the posterior:
res &lt;- svsample(sim$y, draws = 2000, priorphi = c(10, 1.5))

## Check out the results:
summary(res)
plot(res)

## Look at other quantiles and calculate ESS of latents:
newquants &lt;- c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99)
res &lt;- updatesummary(res, quantiles = newquants, esslatent = TRUE)

## See the difference?
summary(res)
plot(res)

</code></pre>

<hr>
<h2 id='validate_and_process_expert'>Validate and Process Argument 'expert'</h2><span id='topic+validate_and_process_expert'></span>

<h3>Description</h3>

<p>A helper function that validates the input and extends it with
default values if there are missing parts for argument 'expert'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_and_process_expert(expert = NULL, priorspec = specify_priors())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_and_process_expert_+3A_expert">expert</code></td>
<td>
<p>list, the input values for expert.</p>
</td></tr>
<tr><td><code id="validate_and_process_expert_+3A_priorspec">priorspec</code></td>
<td>
<p>a <code>priorspec</code> object created by
<code><a href="#topic+specify_priors">specify_priors</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that is the input extended by default values. If
the input is invalid, an error is thrown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+specify_priors">specify_priors</a></code>
</p>

<hr>
<h2 id='volplot'>Plotting Quantiles of the Latent Volatilities</h2><span id='topic+volplot'></span>

<h3>Description</h3>

<p>Displays quantiles of the posterior distribution of the volatilities over
time as well as predictive distributions of future volatilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volplot(
  x,
  forecast = 0,
  dates = NULL,
  show0 = FALSE,
  forecastlty = NULL,
  tcl = -0.4,
  mar = c(1.9, 1.9, 1.9, 0.5),
  mgp = c(2, 0.6, 0),
  simobj = NULL,
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volplot_+3A_x">x</code></td>
<td>
<p><code>svdraws</code> object.</p>
</td></tr>
<tr><td><code id="volplot_+3A_forecast">forecast</code></td>
<td>
<p>nonnegative integer or object of class <code>svpredict</code>, as
returned by <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>. If an integer greater than 0 is
provided, <code><a href="#topic+predict.svdraws">predict.svdraws</a></code> is invoked to obtain the
<code>forecast</code>-step-ahead prediction. The default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="volplot_+3A_dates">dates</code></td>
<td>
<p>vector of length <code>ncol(x$latent)</code>, providing optional
dates for labeling the x-axis. The default value is <code>NULL</code>; in this
case, the axis will be labeled with numbers.</p>
</td></tr>
<tr><td><code id="volplot_+3A_show0">show0</code></td>
<td>
<p>logical value, indicating whether the initial volatility
<code>exp(h_0/2)</code> should be displayed. The default value is <code>FALSE</code>.
Only available for inputs <code>x</code> of class <code>svdraws</code>.</p>
</td></tr>
<tr><td><code id="volplot_+3A_forecastlty">forecastlty</code></td>
<td>
<p>vector of line type values (see
<code><a href="graphics.html#topic+par">par</a></code>) used for plotting quantiles of predictive
distributions. The default value <code>NULL</code> results in dashed lines.</p>
</td></tr>
<tr><td><code id="volplot_+3A_tcl">tcl</code></td>
<td>
<p>The length of tick marks as a fraction of the height of a line of
text. See <code><a href="graphics.html#topic+par">par</a></code> for details. The default value is
<code>-0.4</code>, which results in slightly shorter tick marks than usual.</p>
</td></tr>
<tr><td><code id="volplot_+3A_mar">mar</code></td>
<td>
<p>numerical vector of length 4, indicating the plot margins. See
<code><a href="graphics.html#topic+par">par</a></code> for details. The default value is <code>c(1.9,
1.9, 1.9, 0.5)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="volplot_+3A_mgp">mgp</code></td>
<td>
<p>numerical vector of length 3, indicating the axis and label
positions. See <code><a href="graphics.html#topic+par">par</a></code> for details. The default value is
<code>c(2, 0.6, 0)</code>, which is slightly smaller than the R-defaults.</p>
</td></tr>
<tr><td><code id="volplot_+3A_simobj">simobj</code></td>
<td>
<p>object of class <code>svsim</code> as returned by the SV simulation
function <code><a href="#topic+svsim">svsim</a></code>. If provided, &ldquo;true&rdquo; data generating values
will be added to the plot(s).</p>
</td></tr>
<tr><td><code id="volplot_+3A_newdata">newdata</code></td>
<td>
<p>corresponds to parameter <code>newdata</code> in <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>.
<em>Only if <code>forecast</code> is a positive integer and <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>
needs a <code>newdata</code> object.</em> Corresponds to input
parameter <code>designmatrix</code> in <code><a href="#topic+svsample">svsample</a></code>.
A matrix of regressors with number of rows equal to parameter <code>forecast</code>.</p>
</td></tr>
<tr><td><code id="volplot_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the invoked <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effects. Returns argument <code>x</code> invisibly.
</p>


<h3>Note</h3>

<p>In case you want different quantiles to be plotted, use
<code><a href="#topic+updatesummary">updatesummary</a></code> on the <code>svdraws</code> object first. An example
of doing so is given below.
</p>


<h3>Author(s)</h3>

<p>Gregor Kastner <a href="mailto:gregor.kastner@wu.ac.at">gregor.kastner@wu.ac.at</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updatesummary">updatesummary</a></code>, <code><a href="#topic+predict.svdraws">predict.svdraws</a></code>
</p>
<p>Other plotting: 
<code><a href="#topic+paradensplot">paradensplot</a>()</code>,
<code><a href="#topic+paratraceplot.svdraws">paratraceplot.svdraws</a>()</code>,
<code><a href="#topic+paratraceplot">paratraceplot</a>()</code>,
<code><a href="#topic+plot.svdraws">plot.svdraws</a>()</code>,
<code><a href="#topic+plot.svpredict">plot.svpredict</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate a short and highly persistent SV process
sim &lt;- svsim(100, mu = -10, phi = 0.99, sigma = 0.2)

## Obtain 5000 draws from the sampler (that's not a lot)
draws &lt;- svsample(sim$y, draws = 5000, burnin = 100,
		  priormu = c(-10, 1), priorphi = c(20, 1.5),
		  priorsigma = 0.2)

## Plot the latent volatilities and some forecasts
volplot(draws, forecast = 10)

## Re-plot with different quantiles
newquants &lt;- c(0.01, 0.05, 0.25, 0.5, 0.75, 0.95, 0.99)
draws &lt;- updatesummary(draws, quantiles = newquants)

volplot(draws, forecast = 10)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
