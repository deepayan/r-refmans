<!DOCTYPE html><html><head><title>Help for package cgAUC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cgAUC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#c_cntin'>
<p>c_cntin</p></a></li>
<li><a href='#c_d_theta_sh_h_p'>
<p>c_d_theta_sh_h_p</p></a></li>
<li><a href='#c_dscrt'>
<p>c_dscrt</p></a></li>
<li><a href='#c_s_h'>
<p>c_s_h</p></a></li>
<li><a href='#cgAUC'>
<p>Calculate AUC when gold standard is continuous with large variables.</p></a></li>
<li><a href='#cgAUC-package'>
<p>Calculate AUC when gold standard is continuous with large variables.</p></a></li>
<li><a href='#optimal.delta'>
<p>optimal.delta</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculate AUC-type measure when gold standard is continuous and
the corresponding optimal linear combination of variables with
respect to it.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2014-08-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuan-chin I. Chang, Yu-chia Chang, and Ling-wan Chen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yu-chia Chang &lt;curare7177@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The cgAUC can calculate the AUC-type measure of Obuchowski(2006) when gold standard is continuous, and find the optimal linear combination of variables with respect to this measure.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2014-08-28 01:58:35 UTC; Optiplex960</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2014-08-28 07:01:42</td>
</tr>
</table>
<hr>
<h2 id='c_cntin'>
c_cntin</h2><span id='topic+c_cntin'></span>

<h3>Description</h3>

<p>Continue function, when variable was continue.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_cntin(y, z, l, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_cntin_+3A_y">y</code></td>
<td>
<p>The potential variables. It is a matrix with column of values of a variables. It should be standardized in this application.
</p>
</td></tr>
<tr><td><code id="c_cntin_+3A_z">z</code></td>
<td>

<p>The gold standard variable. It should be standardized.</p>
</td></tr>
<tr><td><code id="c_cntin_+3A_l">l</code></td>
<td>

<p>Linear combination. A vector.</p>
</td></tr>
<tr><td><code id="c_cntin_+3A_h">h</code></td>
<td>

<p>The value of h falls into (n^(-1/2), n^(-1/5)).</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>theta.sh.h.p</code></td>
<td>
<p>The estimate of the theta of Chang(2012).</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The variance of estimate of the theta of Chang(2012).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(y, z, l, h) {
    .Call('cgAUC_c_cntin', PACKAGE = 'cgAUC', y, z, l, h)
}
</code></pre>

<hr>
<h2 id='c_d_theta_sh_h_p'>
c_d_theta_sh_h_p</h2><span id='topic+c_d_theta_sh_h_p'></span>

<h3>Description</h3>

<p>Compute the c_d_theta_sh_h_p.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_d_theta_sh_h_p(y, z, l, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_d_theta_sh_h_p_+3A_y">y</code></td>
<td>

<p>The potential variables. It is a matrix with column of values of a variables. It should be standardized in this application.</p>
</td></tr>
<tr><td><code id="c_d_theta_sh_h_p_+3A_z">z</code></td>
<td>

<p>The gold standard variable. It should be standardized.</p>
</td></tr>
<tr><td><code id="c_d_theta_sh_h_p_+3A_l">l</code></td>
<td>

<p>Linear combination. A vector.</p>
</td></tr>
<tr><td><code id="c_d_theta_sh_h_p_+3A_h">h</code></td>
<td>

<p>The value of h falls into (n^(-1/2), n^(-1/5)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the c_d_theta_sh_h_p Come from differential.</p>


<h3>Value</h3>



<table>
<tr><td><code>d.theta.sh.h.p</code></td>
<td>
<p>Theta after differential.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(y, z, l, h) {
    .Call('cgAUC_c_d_theta_sh_h_p', PACKAGE = 'cgAUC', y, z, l, h)
}
</code></pre>

<hr>
<h2 id='c_dscrt'>
c_dscrt</h2><span id='topic+c_dscrt'></span>

<h3>Description</h3>

<p>discrete function, when variable is discrete.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_dscrt(y, z, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_dscrt_+3A_y">y</code></td>
<td>

<p>The potential variables. It is a matrix with column of values of a variables. It should be standardized in this application.</p>
</td></tr>
<tr><td><code id="c_dscrt_+3A_z">z</code></td>
<td>

<p>The gold standard variable. It should be standardized.</p>
</td></tr>
<tr><td><code id="c_dscrt_+3A_l">l</code></td>
<td>

<p>Linear combination. A vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discrete function, when variable is discrete.</p>


<h3>Value</h3>



<table>
<tr><td><code>theta.h.p</code></td>
<td>
<p>The estimate of theta when variable is discrete.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>The variance of estimate of theta.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(y, z, l) {
    .Call('cgAUC_c_dscrt', PACKAGE = 'cgAUC', y, z, l)
}
</code></pre>

<hr>
<h2 id='c_s_h'>
c_s_h</h2><span id='topic+c_s_h'></span>

<h3>Description</h3>

<p>Smooth function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_s_h(t, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_s_h_+3A_t">t</code></td>
<td>

<p>A value, the difference between any two subjects.</p>
</td></tr>
<tr><td><code id="c_s_h_+3A_h">h</code></td>
<td>

<p>The value of h falls into (n^(-1/2), n^(-1/5)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smooth function.</p>


<h3>Value</h3>



<table>
<tr><td><code>s_h</code></td>
<td>
<p>The value of smooth function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(t, h) {
    .Call('cgAUC_c_s_h', PACKAGE = 'cgAUC', t, h)
}
</code></pre>

<hr>
<h2 id='cgAUC'>
Calculate AUC when gold standard is continuous with large variables.</h2><span id='topic+cgAUC'></span>

<h3>Description</h3>

<p>The cgAUC can calculate the AUC-type measure of Obuchowski(2006) when gold standard is continuous, and find the optimal linear combination of variables with respect to this measure.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgAUC(x, z, h, delta = 1, auto = FALSE, tau = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cgAUC_+3A_x">x</code></td>
<td>

<p>The potential variables. It is a matrix with column of values of a variables. It should be standardized in this application.</p>
</td></tr>
<tr><td><code id="cgAUC_+3A_z">z</code></td>
<td>

<p>The gold standard variable. It should be standardized.</p>
</td></tr>
<tr><td><code id="cgAUC_+3A_h">h</code></td>
<td>

<p>The parameter controls the window width of smoothing function.</p>
</td></tr>
<tr><td><code id="cgAUC_+3A_delta">delta</code></td>
<td>

<p>The parameter be used in TGDM. The default value is one.</p>
</td></tr>
<tr><td><code id="cgAUC_+3A_auto">auto</code></td>
<td>

<p>Find the optimal delta in TGDN using cross-validation. If the auto is TRUE. The default is FALSE.</p>
</td></tr>
<tr><td><code id="cgAUC_+3A_tau">tau</code></td>
<td>

<p>The parameter used in TGDM. The default value is one.</p>
</td></tr>
<tr><td><code id="cgAUC_+3A_scale">scale</code></td>
<td>

<p>Scaling data when scale = 1, no scaling data when scale = 0. The default value is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this package, we use the TGDM to find the optimal linear combination of variables in order to maximize the AUC-type measure. Before using this function, all of variables, including gold standard variable, should be standardized first. Below are parameters used in the algorithm:</p>


<h3>Value</h3>

<table>
<tr><td><code>Rev</code></td>
<td>
<p>When Rev = 0 means l * 1; otherwise, l * -1.</p>
</td></tr>
<tr><td><code>l</code></td>
<td>
<p>The estimate of coefficients for the optimal linear combination of variables.</p>
</td></tr>
<tr><td><code>theta.sh.h.p</code></td>
<td>
<p>The estimate of the theta of Chang(2012) for the optimal linear combination of variables.</p>
</td></tr>
<tr><td><code>theta.sh.h.p.var</code></td>
<td>
<p>The estimate of variance for the theta of Chang(2012).</p>
</td></tr>
<tr><td><code>cntin.ri</code></td>
<td>
<p>The estimate of the theta of Chang(2012) for each single vaiable.</p>
</td></tr>
<tr><td><code>theta.h.p</code></td>
<td>
<p>The estimate of the theta of Obuchowski(2006) for the optimal linear combination of variables.</p>
</td></tr>
<tr><td><code>theta.h.p.var</code></td>
<td>
<p>The estimate of variance for the theta of Obuchowski(2006).</p>
</td></tr>
<tr><td><code>dscrt.ri</code></td>
<td>
<p>The estimate of the theta of Obuchowski(2006) for each single vaiable.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>The value of delta.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

# n = 100; p = 5;
# r.x = matrix(rnorm(n * p), , p) # raw data
# r.z = r.x[ ,1] + rnorm(n) # gold standard
# x = scale(r.x) # standardized of raw data
# z = scale(r.z) # standardized of gold standard
# h = n^(-1 / 2)
# t1 = cgAUC(r.x, r.z, h, delta = 1, auto = FALSE, tau = 1, scale = 1) # the delta be constant
# t1
# t2 = cgAUC(r.x, r.z, h, delta = 1, auto = TRUE, tau = 1, scale = 1) # the delta be variable
# t2

## The function is currently defined as
function (x, z, h, delta = 1, auto = FALSE, tau = 1)
{
	x = scale(x)
	z = scale(z)
	conv = FALSE
	n = dim(x)[1]
	p = dim(x)[2]
	cntin.ri = dscrt.ri = rep(0, p)
	id = diag(p)
	for (i in 1:p) {
		dscrt.ri[i] = dscrt(x, z, id[i, ])$theta.h.p
		cntin.ri[i] = cntin(x, z, id[i, ], h)$theta.sh.h.p
	}
	beta.i = ifelse(cntin.ri &gt; 0.5, 1, -1)
	dscrt.ri = ifelse(dscrt.ri &gt; 0.5, dscrt.ri, (1 - dscrt.ri))
	cntin.ri = ifelse(cntin.ri &gt; 0.5, cntin.ri, (1 - cntin.ri))
	y = x * matrix(beta.i, n, p, byrow = TRUE)
	max.x = which(cntin.ri == max(cntin.ri))
	theta.sh.h.p = 0
	l = id[max.x, ]
	while (conv == FALSE) {
		d.l = d.theta.sh.h.p(y, z, l, h)
		max.d.l = max(d.l)
		ind.d.l = ifelse(d.l &gt;= (tau * max.d.l), 1, 0) * d.l
		if (auto == TRUE) {
			delta = optimal.delta(y, z, l, h, ind.d.l)
		}
		l = l + delta * ind.d.l
		l = l/max(l)
		theta.temp = cntin(y, z, l, h)$theta.sh.h.p
		ifelse(abs(theta.temp - theta.sh.h.p) &lt; 1e-04, conv &lt;- TRUE, conv &lt;- FALSE)
		theta.sh.h.p = theta.temp
	}
	optimal.dscrt = dscrt(y, z, l)
	theta.sh.h.p.var = cntin(y, z, l, h)$var
	l = l * beta.i
	return(list(l = l, theta.sh.h.p = theta.sh.h.p, theta.sh.h.p.var = theta.sh.h.p.var,
				cntin.ri = cntin.ri, theta.h.p = optimal.dscrt$theta.h.p,
				theta.h.p.var = optimal.dscrt$var, dscrt.ri = dscrt.ri,
				delta = delta))
}
## The function is currently defined as
function (x, z, h, delta = 1, auto = FALSE, tau = 1) 
{
    x = scale(x)
    z = scale(z)
    conv = FALSE
    n = dim(x)[1]
    p = dim(x)[2]
    cntin.ri = dscrt.ri = rep(0, p)
    id = diag(p)
    for (i in 1:p) {
        dscrt.ri[i] = dscrt(x, z, id[i, ])$theta.h.p
        cntin.ri[i] = cntin(x, z, id[i, ], h)$theta.sh.h.p
    }
    beta.i = ifelse(cntin.ri &gt; 0.5, 1, -1)
    dscrt.ri = ifelse(dscrt.ri &gt; 0.5, dscrt.ri, (1 - dscrt.ri))
    cntin.ri = ifelse(cntin.ri &gt; 0.5, cntin.ri, (1 - cntin.ri))
    y = x * matrix(beta.i, n, p, byrow = TRUE)
    max.x = which(cntin.ri == max(cntin.ri))
    theta.sh.h.p = 0
    l = id[max.x, ]
    while (conv == FALSE) {
        d.l = d.theta.sh.h.p(y, z, l, h)
        max.d.l = max(d.l)
        ind.d.l = ifelse(d.l &gt;= (tau * max.d.l), 1, 0) * d.l
        if (auto == TRUE) {
            delta = optimal.delta(y, z, l, h, ind.d.l)
        }
        l = l + delta * ind.d.l
        l = l/max(l)
        theta.temp = cntin(y, z, l, h)$theta.sh.h.p
        ifelse(abs(theta.temp - theta.sh.h.p) &lt; 1e-04, conv &lt;- TRUE, 
            conv &lt;- FALSE)
        theta.sh.h.p = theta.temp
    }
    optimal.dscrt = dscrt(y, z, l)
    theta.sh.h.p.var = cntin(y, z, l, h)$var
    l = l * beta.i
    return(list(l = l, theta.sh.h.p = theta.sh.h.p, theta.sh.h.p.var = theta.sh.h.p.var, 
        cntin.ri = cntin.ri, theta.h.p = optimal.dscrt$theta.h.p, 
        theta.h.p.var = optimal.dscrt$var, dscrt.ri = dscrt.ri, 
        delta = delta))
  }
</code></pre>

<hr>
<h2 id='cgAUC-package'>
Calculate AUC when gold standard is continuous with large variables.
</h2><span id='topic+cgAUC-package'></span>

<h3>Description</h3>

<p>In this package, the cgAUC is used to calculate the AUC-type measure raised in Obuchowski(2006) when gold standard is continuous.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cgAUC</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-08-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Yuan-chin I. Chang, Yu-chia Chang, and Ling-wan Chen
</p>
<p>Maintainer: Yu-chia Chang &lt;curare7177@gmail.com&gt;
</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# n = 100; p = 5;
# r.x = matrix(rnorm(n * p), , p) # raw data
# r.z = r.x[ ,1] + rnorm(n) # gold standard
# x = scale(r.x) # standardized of raw data
# z = scale(r.z) # standardized of gold standard
# h = n^(-1 / 2)
# t1 = cgAUC(r.x, r.z, h, delta = 1, auto = FALSE, tau = 1, scale = 1) # the delta be constant
# t1
# t2 = cgAUC(r.x, r.z, h, delta = 1, auto = TRUE, tau = 1, scale = 1) # the delta be variable
# t2
</code></pre>

<hr>
<h2 id='optimal.delta'>
optimal.delta</h2><span id='topic+optimal.delta'></span>

<h3>Description</h3>

<p>Find the optimal delta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal.delta(y, z, l, h, ind.d.l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal.delta_+3A_y">y</code></td>
<td>

<p>The potential variables. It is a matrix with column of values of a variables. It should be standardized in this application.</p>
</td></tr>
<tr><td><code id="optimal.delta_+3A_z">z</code></td>
<td>

<p>The gold standard variable. It should be standardized.</p>
</td></tr>
<tr><td><code id="optimal.delta_+3A_l">l</code></td>
<td>

<p>Linear combination. A vector.</p>
</td></tr>
<tr><td><code id="optimal.delta_+3A_h">h</code></td>
<td>

<p>The value of h falls into (n^(-1/2), n^(-1/5)).</p>
</td></tr>
<tr><td><code id="optimal.delta_+3A_ind.d.l">ind.d.l</code></td>
<td>

<p>Void</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>delta.star</code></td>
<td>
<p>Optimal delta.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yu-chia Chang</p>


<h3>References</h3>

<p>Chang, YCI. Maximizing an ROC type measure via linear combination of markers when the gold reference is continuous. Statistics in Medicine 2012.<br />
Obuchowski NA. An ROC-type measure of diagnostic accuracy when the gold standard is continuous-scale. Statistics in Medicine 2006; 25:481&ndash;493.<br />
Obuchowski N. Estimating and comparing diagnostic tests accuracy when the gold standard is not binary. Statistics in Medicine 2005; 20:3261&ndash;3278.<br />
Friedman JH, Popescu BE. Gradient directed regularization for linear regression and classification. Technical Report, Department of Statistics, Stanford University, 2004.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (y, z, l, h, ind.d.l) 
{
    l.i = matrix(rep(l, times = 50), nrow = 50, byrow = TRUE)
    delta = seq(0, 5, length = 50)
    m = delta %*% t(ind.d.l)
    l.i = l.i + m
    l.i.max = apply(l.i, 1, max)
    l.i = l.i/l.i.max
    theta = rep(0, 50)
    for (i in 2:50) {
        theta[i] = cntin(y, z, l.i[i, ], h)$theta.sh.h.p
    }
    delta.star = delta[which(theta == max(theta))]
    return(delta.star)
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
