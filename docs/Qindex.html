<!DOCTYPE html><html lang="en-US"><head><title>Help for package Qindex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Qindex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Qindex-package'><p>Continuous and Dichotomized Index Predictors Based on Distribution Quantiles</p></a></li>
<li><a href='#BBC_cutoff'><p>Bootstrap Cutoff</p></a></li>
<li><a href='#BBC_dichotom'><p>Bootstrap-based Optimism Correction for Dichotomization</p></a></li>
<li><a href='#bootid'><p>Bootstrap Indices</p></a></li>
<li><a href='#clusterQp'><p>Cluster-Specific Sample Quantiles</p></a></li>
<li><a href='#defunct'><p>Back Compatibility</p></a></li>
<li><a href='#integrandSurface'><p>Integrand Surface(s) of Sign-Adjusted Quantile Indices Qindex</p></a></li>
<li><a href='#optimSplit_dichotom'><p>Optimal Dichotomizing Predictors via Repeated Sample Splits</p></a></li>
<li><a href='#predict.optimSplit_dichotom'><p>Regression Models with Optimal Dichotomizing Predictors</p></a></li>
<li><a href='#predict.Qindex'><p>Predicted Sign-Adjusted Quantile Indices</p></a></li>
<li><a href='#Qindex'><p>Sign-Adjusted Quantile Indices</p></a></li>
<li><a href='#Qindex_graphics'><p>Visualize Qindex object using R package <span class="pkg">graphics</span></p></a></li>
<li><a href='#rpartD'><p>Dichotomize via Recursive Partitioning</p></a></li>
<li><a href='#rSplit'><p>Stratified Random Split Sampling</p></a></li>
<li><a href='#show+2CQindex-method'><p>Show Qindex Object</p></a></li>
<li><a href='#std_'><p>Alternative Standardization Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous and Dichotomized Index Predictors Based on
Distribution Quantiles</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Select optimal functional regression or dichotomized
       quantile predictors for survival/logistic/numeric outcome
       and perform optimistic bias correction for any optimally
       dichotomized numeric predictor(s), as in Yi, et. al.
       (2023) &lt;<a href="https://doi.org/10.1016%2Fj.labinv.2023.100158">doi:10.1016/j.labinv.2023.100158</a>&gt;.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4),</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats, methods, mgcv, plotly, rpart, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, boot, htmlwidgets, Qindex.data</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-14 19:55:29 UTC; tingtingzhan</td>
</tr>
<tr>
<td>Author:</td>
<td>Tingting Zhan <a href="https://orcid.org/0000-0001-9971-4844"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Misung Yi <a href="https://orcid.org/0000-0002-4007-5408"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Inna Chervoneva <a href="https://orcid.org/0000-0002-9104-4505"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tingting Zhan &lt;tingtingzhan@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-14 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Qindex-package'>Continuous and Dichotomized Index Predictors Based on Distribution Quantiles</h2><span id='topic+Qindex-package'></span>

<h3>Description</h3>

<p>Continuous and dichotomized index predictors based on distribution quantiles.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tingting Zhan <a href="mailto:tingtingzhan@gmail.com">tingtingzhan@gmail.com</a> (<a href="https://orcid.org/0000-0001-9971-4844">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Misung Yi <a href="mailto:misung.yi@dankook.ac.kr">misung.yi@dankook.ac.kr</a> (<a href="https://orcid.org/0000-0002-4007-5408">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Inna Chervoneva <a href="mailto:Inna.Chervoneva@jefferson.edu">Inna.Chervoneva@jefferson.edu</a> (<a href="https://orcid.org/0000-0002-9104-4505">ORCID</a>) [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p><em>Selection of optimal quantile protein biomarkers based on cell-level immunohistochemistry data</em>.
Misung Yi, Tingting Zhan, Amy P. Peck, Jeffrey A. Hooke, Albert J. Kovatich, Craig D. Shriver,
Hai Hu, Yunguang Sun, Hallgeir Rui and Inna Chervoneva. BMC Bioinformatics, 2023. <a href="https://doi.org/10.1186/s12859-023-05408-8">doi:10.1186/s12859-023-05408-8</a>
</p>
<p><em>Quantile index biomarkers based on single-cell expression data</em>.
Misung Yi, Tingting Zhan, Amy P. Peck, Jeffrey A. Hooke, Albert J. Kovatich, Craig D. Shriver,
Hai Hu, Yunguang Sun, Hallgeir Rui and Inna Chervoneva.
Laboratory Investigation, 2023. <a href="https://doi.org/10.1016/j.labinv.2023.100158">doi:10.1016/j.labinv.2023.100158</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Data Preparation

library(survival)
data(Ki67, package = 'Qindex.data')
Ki67c = within(Ki67[complete.cases(Ki67), , drop = FALSE], expr = {
  marker = log1p(Marker); Marker = NULL
  PFS = Surv(RECFREESURV_MO, RECURRENCE)
})
(npt = length(unique(Ki67c$PATIENT_ID))) # 592

### Step 1: Cluster-Specific Sample Quantiles

Ki67q = clusterQp(marker ~ . - tissueID - inner_x - inner_y | PATIENT_ID, data = Ki67c)
stopifnot(is.matrix(Ki67q$marker))
head(Ki67q$marker, n = c(4L, 6L))

set.seed(234); id = sort.int(sample.int(n = npt, size = 480L))
Ki67q_0 = Ki67q[id, , drop = FALSE] # training set
Ki67q_1 = Ki67q[-id, , drop = FALSE] # test set

### Step 2 (after Step 1)

## Step 2a: Linear Sign-Adjusted Quantile Indices
(fr = Qindex(PFS ~ marker, data = Ki67q_0))
stopifnot(all.equal.numeric(c(fr), predict(fr)))
integrandSurface(fr)
integrandSurface(fr, newdata = Ki67q_1)

## Step 2b: Non-Linear Sign-Adjusted Quantile Indices
(nlfr = Qindex(PFS ~ marker, data = Ki67q_0, nonlinear = TRUE))
stopifnot(all.equal.numeric(c(nlfr), predict(nlfr)))
integrandSurface(nlfr)
integrandSurface(nlfr, newdata = Ki67q_1)

## view linear and non-linear sign-adjusted quantile indices together
integrandSurface(fr, nlfr)


### Step 2c: Optimal Dichotomizing
set.seed(14837); (m1 = optimSplit_dichotom(
  PFS ~ marker, data = Ki67q_0, nsplit = 20L, top = 2L)) 
predict(m1)
predict(m1, boolean = FALSE)
predict(m1, newdata = Ki67q_1)


### Step 3 (after Step 1 &amp; 2)

Ki67q_0a = within.data.frame(Ki67q_0, expr = {
  FR = std_IQR(fr) 
  nlFR = std_IQR(nlfr)
  optS = std_IQR(marker[,'0.27'])
})
Ki67q_1a = within.data.frame(Ki67q_1, expr = {
  FR = std_IQR(predict(fr, newdata = Ki67q_1))
  nlFR = std_IQR(predict(nlfr, newdata = Ki67q_1))
  optS = std_IQR(marker[,'0.27']) 
})
# `optS`: use the best quantile but discard the cutoff identified by [optimSplit_dichotom]
# all models below can also be used on training data `Ki67q_0a`
# naive use
summary(coxph(PFS ~ NodeSt + Tstage + FR, data = Ki67q_1a))
summary(coxph(PFS ~ NodeSt + Tstage + nlFR, data = Ki67q_1a))
summary(coxph(PFS ~ NodeSt + Tstage + optS, data = Ki67q_1a))
# set.seed if necessary
summary(BBC_dichotom(PFS ~ NodeSt + Tstage ~ FR, data = Ki67q_1a))
# `NodeSt`, `Tstage`: predctors to be used as-is
# `FR` to be dichotomized
# set.seed if necessary
summary(BBC_dichotom(PFS ~ NodeSt + Tstage ~ nlFR, data = Ki67q_1a))
# set.seed if necessary
summary(BBC_dichotom(PFS ~ NodeSt + Tstage ~ optS, data = Ki67q_1a)) # statistically rigorous 

# Option 1
summary(BBC_dichotom(PFS ~ NodeSt + Tstage ~ FR, data = Ki67q_1a))

# Option 2:
summary(tmp &lt;- BBC_dichotom(PFS ~ NodeSt + Tstage ~ FR, data = Ki67q_0a))
#coxph(PFS ~ NodeSt + Tstage + I(FR &gt; attr(tmp, 'apparent_cutoff')), data = Ki67q_1a)
coxph(PFS ~ NodeSt + Tstage + I(FR &gt; matrixStats::colMedians(BBC_cutoff(tmp))), data = Ki67q_1a)


# Option 1 and 2 are also applicable to `nlFR` and `optS`

</code></pre>

<hr>
<h2 id='BBC_cutoff'>Bootstrap Cutoff</h2><span id='topic+BBC_cutoff'></span>

<h3>Description</h3>

<p>..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBC_cutoff(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BBC_cutoff_+3A_object">object</code></td>
<td>
<p>returned value from function <a href="#topic+BBC_dichotom">BBC_dichotom</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>we use the output of <a href="#topic+BBC_dichotom">BBC_dichotom</a>.
</p>
<p>but actually this works on the output of <a href="#topic+optimism_dichotom">optimism_dichotom</a>.
</p>


<h3>Value</h3>

<p>Function <a href="#topic+BBC_cutoff">BBC_cutoff</a> returns a <a href="base.html#topic+matrix">matrix</a> of bootstrap cutoffs.
</p>

<hr>
<h2 id='BBC_dichotom'>Bootstrap-based Optimism Correction for Dichotomization</h2><span id='topic+BBC_dichotom'></span><span id='topic+optimism_dichotom'></span><span id='topic+coef_dichotom'></span>

<h3>Description</h3>

<p>Multivariable regression model with bootstrap-based optimism correction on the dichotomized predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBC_dichotom(formula, data, ...)

optimism_dichotom(fom, X, data, R = 100L, ...)

coef_dichotom(fom, X., data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BBC_dichotom_+3A_formula">formula</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>, e.g., <code>y~z~x</code> or <code>y~1~x</code>.
Response <code class="reqn">y</code> may be <a href="base.html#topic+double">double</a>, <a href="base.html#topic+logical">logical</a> and <a href="survival.html#topic+Surv">Surv</a>.
Predictors <code class="reqn">x</code>'s to be dichotomized may be one or more <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>s and/or one <a href="base.html#topic+matrix">matrix</a>.
Additional predictors <code class="reqn">z</code>'s, if any, may be of any type.</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a></p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_fom">fom</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>, e.g., <code>y~z</code> or <code>y~1</code>, for helper functions, with the response <code class="reqn">y</code> and additional predictors <code class="reqn">z</code>'s, if any</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_x">X</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">k</code> columns,
<a href="base.html#topic+numeric">numeric</a> predictors <code class="reqn">x_1,\cdots,x_k</code> to be dichotomized</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_r">R</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar,
number of bootstrap replicates <code class="reqn">R</code>, default <code>100L</code></p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_x.">X.</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> <a href="base.html#topic+matrix">matrix</a> <code class="reqn">\tilde{X}</code> of <code class="reqn">k</code> columns,
dichotomized predictors <code class="reqn">\tilde{x}_1,\cdots,\tilde{x}_k</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <a href="#topic+BBC_dichotom">BBC_dichotom</a> obtains a multivariable regression model with
bootstrap-based optimism correction on the dichotomized predictors.
Specifically,
</p>

<ol>
<li><p>Obtain the dichotomizing rules <code class="reqn">\mathbf{\mathcal{D}}</code> of predictors <code class="reqn">x_1,\cdots,x_k</code> based on response <code class="reqn">y</code> (via <a href="#topic+m_rpartD">m_rpartD</a>).
Multivariable regression (with additional predictors <code class="reqn">z</code>, if any)
with dichotomized predictors <code class="reqn">\left(\tilde{x}_1,\cdots,\tilde{x}_k\right) = \mathcal{D}\left(x_1,\cdots,x_k\right)</code> (via helper function <a href="#topic+coef_dichotom">coef_dichotom</a>)
is the <em><strong>apparent performance</strong></em>.
</p>
</li>
<li><p>Obtain the bootstrap-based optimism based on <code class="reqn">R</code> copies of bootstrap samples (via helper function <a href="#topic+optimism_dichotom">optimism_dichotom</a>).
The <a href="stats.html#topic+median">median</a> of bootstrap-based optimism over <code class="reqn">R</code> bootstrap copies
is the <em><strong>optimism-correction</strong></em> of the dichotomized predictors <code class="reqn">\tilde{x}_1,\cdots,\tilde{x}_k</code>.
</p>
</li>
<li><p>Subtract the optimism-correction (in Step 2) from the apparent performance estimates (in Step 1),
only for <code class="reqn">\tilde{x}_1,\cdots,\tilde{x}_k</code>.
The apparent performance estimates for additional predictors <code class="reqn">z</code>'s, if any, are not modified.
Neither the variance-covariance (<a href="stats.html#topic+vcov">vcov</a>) estimates
nor the other regression diagnostics, e.g.,
<a href="stats.html#topic+resid">resid</a>uals,
<a href="stats.html#topic+logLik">logLik</a>elihood,
etc.,
of the apparent performance are modified for now.
This coefficient-only, partially-modified regression model is
the <em><strong>optimism-corrected performance</strong></em>.

</p>
</li></ol>



<h3>Value</h3>

<p>Function <a href="#topic+BBC_dichotom">BBC_dichotom</a> returns a
<a href="survival.html#topic+coxph">coxph</a>, <a href="stats.html#topic+glm">glm</a> or <a href="stats.html#topic+lm">lm</a> regression model,
with <a href="base.html#topic+attributes">attributes</a>,
</p>

<dl>
<dt><code>attr(,'optimism')</code></dt><dd><p>the returned object from <a href="#topic+optimism_dichotom">optimism_dichotom</a></p>
</dd>
<dt><code>attr(,'apparent_cutoff')</code></dt><dd><p>a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
cutoff thresholds for the <code class="reqn">k</code> predictors in the apparent model</p>
</dd>
</dl>



<h3>Details on Helper Functions</h3>



<h4>Bootstrap-Based Optimism</h4>

<p>Helper function <a href="#topic+optimism_dichotom">optimism_dichotom</a> computes the bootstrap-based optimism
of the dichotomized predictors. Specifically,
</p>

<ol>
<li><p><code class="reqn">R</code> copies of bootstrap samples are generated. In the <code class="reqn">j</code>-th bootstrap sample,
</p>

<ol>
<li><p>obtain the dichotomizing rules <code class="reqn">\mathbf{\mathcal{D}}^{(j)}</code> of predictors <code class="reqn">x_1^{(j)},\cdots,x_k^{(j)}</code> based on response <code class="reqn">y^{(j)}</code> (via <a href="#topic+m_rpartD">m_rpartD</a>)
</p>
</li>
<li><p>multivariable regression (with additional predictors <code class="reqn">z^{(j)}</code>, if any) coefficient estimates <code class="reqn">\mathbf{\hat{\beta}}^{(j)} = \left(\hat{\beta}_1^{(j)},\cdots,\hat{\beta}_k^{(j)}\right)^t</code> of
the dichotomized predictors <code class="reqn">\left(\tilde{x}_1^{(j)},\cdots,\tilde{x}_k^{(j)}\right) = \mathcal{D}^{(j)}\left(x_1^{(j)},\cdots,x_k^{(j)}\right)</code> (via <a href="#topic+coef_dichotom">coef_dichotom</a>)
are the <em><strong>bootstrap performance estimate</strong></em>.
</p>
</li></ol>


</li>
<li><p>Dichotomize <code class="reqn">x_1,\cdots,x_k</code> in the <em>entire data</em> using each of the bootstrap rules <code class="reqn">\mathcal{D}^{(1)},\cdots,\mathcal{D}^{(R)}</code>.
Multivariable regression (with additional predictors <code class="reqn">z</code>, if any) coefficient estimates <code class="reqn">\mathbf{\hat{\beta}}^{[j]} = \left(\hat{\beta}_1^{[j]},\cdots,\hat{\beta}_k^{[j]}\right)^t</code> of
the dichotomized predictors <code class="reqn">\left(\tilde{x}_1^{[j]},\cdots,\tilde{x}_k^{[j]}\right) = \mathcal{D}^{(j)}\left(x_1,\cdots,x_k\right)</code> (via <a href="#topic+coef_dichotom">coef_dichotom</a>)
are the <em><strong>test performance estimate</strong></em>.
</p>
</li>
<li><p>Difference between the bootstrap and test performance estimates,
an <code class="reqn">R\times k</code> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">\left(\mathbf{\hat{\beta}}^{(1)},\cdots,\mathbf{\hat{\beta}}^{(R)}\right)</code> minus
another <code class="reqn">R\times k</code> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">\left(\mathbf{\hat{\beta}}^{[1]},\cdots,\mathbf{\hat{\beta}}^{[R]}\right)</code>,
are the <em><strong>bootstrap-based optimism</strong></em>.
</p>
</li></ol>




<h4>Multivariable Regression Coefficient Estimates of Dichotomized Predictors <code class="reqn">\tilde{x}</code>'s</h4>

<p>Helper function <a href="#topic+coef_dichotom">coef_dichotom</a>
fits a multivariable Cox proportional hazards (<a href="survival.html#topic+coxph">coxph</a>) model for <a href="survival.html#topic+Surv">Surv</a> response,
logistic (<a href="stats.html#topic+glm">glm</a>) regression model for <a href="base.html#topic+logical">logical</a> response,
or linear (<a href="stats.html#topic+lm">lm</a>) regression model for <a href="stats.html#topic+gaussian">gaussian</a> response,
with
the dichotomized predictors <code class="reqn">\tilde{x}_1,\cdots,\tilde{x}_k</code> as well as
the additional predictors <code class="reqn">z</code>'s.
</p>
<p>It is almost inevitable to have duplicates among the dichotomized predictors <code class="reqn">\tilde{x}_1,\cdots,\tilde{x}_k</code>.
In such case, the multivariable model is fitted using the unique <code class="reqn">\tilde{x}</code>'s.
</p>



<h3>Returns of Helper Functions</h3>



<h4>Of helper function <a href="#topic+optimism_dichotom">optimism_dichotom</a></h4>

<p>Helper function <a href="#topic+optimism_dichotom">optimism_dichotom</a> returns an <code class="reqn">R\times k</code> <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of
bootstrap-based optimism,
with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'cutoff')</code></dt><dd><p>an <code class="reqn">R\times k</code> <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a>,
the <code class="reqn">R</code> copies of bootstrap cutoff thresholds for the <code class="reqn">k</code> predictors.
See attribute <code>'cutoff'</code> of function <a href="#topic+m_rpartD">m_rpartD</a></p>
</dd>
</dl>




<h4>Of helper function <a href="#topic+coef_dichotom">coef_dichotom</a></h4>

<p>Helper function <a href="#topic+coef_dichotom">coef_dichotom</a> returns a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a> of
the regression <a href="stats.html#topic+coef">coef</a>ficients of dichotomized predictors <code class="reqn">\tilde{x}</code>'s, with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'model')</code></dt><dd><p>the <a href="survival.html#topic+coxph">coxph</a>, <a href="stats.html#topic+glm">glm</a> or <a href="stats.html#topic+lm">lm</a> regression model</p>
</dd>
</dl>

<p>In the case of duplicated <code class="reqn">\tilde{x}</code>'s, the regression coefficients of the unique <code class="reqn">\tilde{x}</code>'s are duplicated for those duplicates in <code class="reqn">\tilde{x}</code>'s.
</p>



<h3>References</h3>



<h4>For helper function <a href="#topic+optimism_dichotom">optimism_dichotom</a></h4>

<p>Ewout W. Steyerberg (2009) Clinical Prediction Models.
<a href="https://doi.org/10.1007/978-0-387-77244-8">doi:10.1007/978-0-387-77244-8</a>
</p>
<p>Frank E. Harrell Jr., Kerry L. Lee, Daniel B. Mark. (1996)
Multivariable prognostic models: issues in developing models, evaluating
assumptions and adequacy, and measuring and reducing errors.
<a href="https://doi.org/10.1002/%28SICI%291097-0258%2819960229%2915%3A4%3C361%3A%3AAID-SIM168%3E3.0.CO%3B2-4">doi:10.1002/(SICI)1097-0258(19960229)15:4&lt;361::AID-SIM168&gt;3.0.CO;2-4</a>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(flchain, package = 'survival') # see more details from ?survival::flchain
head(flchain2 &lt;- within.data.frame(flchain, expr = {
  mgus = as.logical(mgus)
}))
dim(flchain3 &lt;- subset(flchain2, futime &gt; 0)) # required by ?rpart::rpart
dim(flchain_Circulatory &lt;- subset(flchain3, chapter == 'Circulatory'))

m1 = BBC_dichotom(Surv(futime, death) ~ age + sex + mgus ~ kappa + lambda, 
 data = flchain_Circulatory, R = 1e2L)
summary(m1)
matrixStats::colMedians(BBC_cutoff(m1)) # median bootstrap cutoff
attr(m1, 'apparent_cutoff')

</code></pre>

<hr>
<h2 id='bootid'>Bootstrap Indices</h2><span id='topic+bootid'></span>

<h3>Description</h3>

<p>Generate a series of <a href="boot.html#topic+boot">boot</a>strap indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootid(n, R)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bootid_+3A_n">n</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, sample size <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="bootid_+3A_r">R</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, number of bootstrap replicates <code class="reqn">R</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <a href="#topic+bootid">bootid</a> generates the same bootstrap indices as
those generated from the default options of function <a href="boot.html#topic+boot">boot</a>
(i.e., <code>sim = 'ordinary'</code> and <code>m = 0</code>).
</p>


<h3>Value</h3>

<p>Function <a href="#topic+bootid">bootid</a> returns a length-<code class="reqn">R</code> <a href="base.html#topic+list">list</a> of
positive <a href="base.html#topic+integer">integer</a> <a href="base.html#topic+vector">vector</a>s.
Each element is the length-<code class="reqn">n</code> indices of each bootstrap sample.
</p>


<h3>See Also</h3>

<p>Function <a href="#topic+bootid">bootid</a> is inspired by functions <code>boot:::index.array</code> and <code>boot:::ordinary.array</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1345); (bt1 = boot::boot(data = 1:10, statistic = function(data, ind) ind, R = 3L)[['t']])
set.seed(1345); (bt2 = do.call(rbind, bootid(10L, R = 3L)))
stopifnot(identical(bt1, bt2))
</code></pre>

<hr>
<h2 id='clusterQp'>Cluster-Specific Sample Quantiles</h2><span id='topic+clusterQp'></span>

<h3>Description</h3>

<p>Sample <a href="stats.html#topic+quantile">quantile</a>s in each cluster of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterQp(
  formula,
  data,
  f_sum_ = mean.default,
  probs = seq.int(from = 0.01, to = 0.99, by = 0.01),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clusterQp_+3A_formula">formula</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>,
including response <code class="reqn">y</code>, cluster(s) <code class="reqn">c</code>'s,
cluster-specific covariate(s) <code class="reqn">x</code>'s to be retained, and
cluster-specific covariate(s) <code class="reqn">z</code>'s to be removed
from <code>data</code>, e.g.,
</p>

<dl>
<dt><code>y ~ 1 | c1</code></dt><dd><p>cluster <code class="reqn">c_1</code>, without cluster-specific covariate</p>
</dd>
<dt><code>y ~ 1 | c1/c2</code></dt><dd><p>cluster <code class="reqn">c_1</code>, and cluster <code class="reqn">c_2</code> nested in <code class="reqn">c_1</code>, without cluster-specific covariate</p>
</dd>
<dt><code>y ~ x1 + x2 | c1</code></dt><dd><p>cluster <code class="reqn">c_1</code>, and cluster-specific covariates <code class="reqn">x_1</code> and <code class="reqn">x_2</code></p>
</dd>
<dt><code>y ~ . | c1</code></dt><dd><p>cluster <code class="reqn">c_1</code>, and all (supposedly cluster-specific) covariates from <code>data</code></p>
</dd>
<dt><code>y ~ . - z1 - z2 | c1</code></dt><dd><p>cluster <code class="reqn">c_1</code>, and all (supposedly cluster-specific) covariates, except for <code class="reqn">z_1</code> and <code class="reqn">z_2</code>, from <code>data</code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="clusterQp_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a></p>
</td></tr>
<tr><td><code id="clusterQp_+3A_f_sum_">f_sum_</code></td>
<td>
<p><a href="base.html#topic+function">function</a> to summarize the sample <a href="stats.html#topic+quantile">quantile</a>s from
lower-level cluster <code class="reqn">c_2</code> (if present),
such as <a href="base.html#topic+mean.default">mean.default</a> (default), <a href="stats.html#topic+median.default">median.default</a>, <a href="base.html#topic+max">max</a>, <a href="base.html#topic+min">min</a>, etc.</p>
</td></tr>
<tr><td><code id="clusterQp_+3A_probs">probs</code></td>
<td>
<p><a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
probabilities <code class="reqn">\mathbf{p} = (p_1,\cdots,p_N)'</code>
shared across all clusters,
where the cluster-specific sample <a href="stats.html#topic+quantile">quantile</a>s
of response <code class="reqn">y</code> are calculated.
Default <code>seq(.01, .99, by = .01)</code></p>
</td></tr>
<tr><td><code id="clusterQp_+3A_...">...</code></td>
<td>
<p>additional parameters of function <a href="stats.html#topic+quantile">quantile</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <a href="#topic+clusterQp">clusterQp</a> returns an <a href="stats.html#topic+aggregate">aggregate</a>d <a href="base.html#topic+data.frame">data.frame</a>,
in which
</p>

<ul>
<li> <p>the highest cluster <code class="reqn">c_1</code> and cluster-specific covariate(s) <code class="reqn">x</code>'s
are retained.
</p>

<ul>
<li> <p>If the input <code>formula</code> takes form of <code>y ~ . | c1</code> or <code>y ~ . - z1 | c1</code>,
then all covariates (except for <code class="reqn">z_1</code>) are considered cluster-specific;
</p>
</li>
<li> <p>Sample quantiles from lower-level clusters (e.g., <code class="reqn">c_2</code>) are point-wise summarized using function <code>f_sum_</code>.
</p>
</li></ul>


</li>
<li> <p>response <code class="reqn">y</code> is removed; instead,  a <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">N</code> columns stores
the cluster-specific sample <a href="stats.html#topic+quantile">quantile</a>s.
This <a href="base.html#topic+matrix">matrix</a>
</p>

<ul>
<li> <p>is named after the <a href="base.html#topic+parse">parse</a>d <a href="base.html#topic+expression">expression</a> of response <code class="reqn">y</code> in <code>formula</code>;
</p>
</li>
<li> <p><a href="base.html#topic+colnames">colnames</a> are the probabilities <code class="reqn">\mathbf{p}</code>, for the ease of subsequent programming.
</p>
</li></ul>


</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># see ?`Qindex-package` for examples
</code></pre>

<hr>
<h2 id='defunct'>Back Compatibility</h2><span id='topic+defunct'></span><span id='topic+FRindex'></span><span id='topic+predict.FRindex'></span><span id='topic+optim_splitSample_dichotom'></span>

<h3>Description</h3>

<p>Functions that have been <a href="base.html#topic+.Defunct">.Defunct</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FRindex(...)

## S3 method for class 'FRindex'
predict(...)

optim_splitSample_dichotom(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defunct_+3A_...">...</code></td>
<td>
<p>parameters that have been <a href="base.html#topic+.Defunct">.Defunct</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='integrandSurface'>Integrand Surface(s) of Sign-Adjusted Quantile Indices <a href="#topic+Qindex-class">Qindex</a></h2><span id='topic+integrandSurface'></span>

<h3>Description</h3>

<p>An interactive <a href="https://CRAN.R-project.org/package=htmlwidgets"><span class="pkg">htmlwidgets</span></a> of the <a href="graphics.html#topic+persp">persp</a>ective plot for
<a href="#topic+Qindex-class">Qindex</a> model(s)
using package <a href="https://CRAN.R-project.org/package=plotly"><span class="pkg">plotly</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrandSurface(
  ...,
  newdata = data,
  proj_Q_p = TRUE,
  proj_S_p = TRUE,
  proj_beta = TRUE,
  n = 501L,
  newid = seq_len(min(50L, .row_names_info(newdata, type = 2L))),
  qlim = range(X, newX),
  axis_col = c("dodgerblue", "deeppink", "darkolivegreen"),
  beta_col = "purple",
  surface_col = c("white", "lightgreen")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integrandSurface_+3A_...">...</code></td>
<td>
<p>one or more <a href="#topic+Qindex-class">Qindex</a> models
based on <em>a same training set</em>.</p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_newdata">newdata</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, with at least
the response <code class="reqn">y^{\text{new}}</code> and
the <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of
functional predictor values <code class="reqn">X^{\text{new}}</code>
of the <em>test set</em>.
The predictor <code class="reqn">X^{\text{new}}</code> are
tabulated on the same <code class="reqn">p</code>-grid as
the training functional predictor values <code class="reqn">X</code>.
If missing, the training set will be used.</p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_proj_q_p">proj_Q_p</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, whether to show
the projection of <code class="reqn">\hat{S}\big(p, Q_i(p)\big)</code>
(see sections <strong>Details</strong> and <strong>Value</strong>)
to the <code class="reqn">(p,q)</code>-plain, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_proj_s_p">proj_S_p</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, whether to show
the projection of <code class="reqn">\hat{S}\big(p, Q_i(p)\big)</code> to the <code class="reqn">(p,s)</code>-plain, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_proj_beta">proj_beta</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, whether to show
<code class="reqn">\hat{\beta}(p)</code> on the <code class="reqn">(p,s)</code>-plain when applicable, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> scalar, fineness of visualization,
default <code>501L</code>. See parameter <code>n.grid</code> of function <a href="mgcv.html#topic+vis.gam">vis.gam</a>.</p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_newid">newid</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> scalar or <a href="base.html#topic+vector">vector</a>,
row indices of <code>newdata</code> to be visualized.
Default <code>1:2</code>, i.e., the first two test subjects.
Use <code>newid = NULL</code> to disable visualization of <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_qlim">qlim</code></td>
<td>
<p><a href="base.html#topic+length">length</a>-2 <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
range on <code class="reqn">q</code>-axis. Default is the range of <code class="reqn">X</code> and <code class="reqn">X^{\text{new}}</code> combined.</p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_axis_col">axis_col</code></td>
<td>
<p><a href="base.html#topic+length">length</a>-3 <a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a>,
colors of the <code class="reqn">(p,q,s)</code> axes</p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_beta_col">beta_col</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, color
of <code class="reqn">\hat{\beta(p)}</code></p>
</td></tr>
<tr><td><code id="integrandSurface_+3A_surface_col">surface_col</code></td>
<td>
<p><a href="base.html#topic+length">length</a>-2 <a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a>,
color of the integrand surface(s), for lowest and highest surface values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <a href="#topic+integrandSurface">integrandSurface</a> returns a pretty <a href="https://CRAN.R-project.org/package=htmlwidgets"><span class="pkg">htmlwidgets</span></a> created by <strong>R</strong> package <a href="https://CRAN.R-project.org/package=plotly"><span class="pkg">plotly</span></a>
to showcase the <a href="graphics.html#topic+persp">persp</a>ective plot of the
estimated sign-adjusted integrand surface <code class="reqn">\hat{S}(p,q)</code>.
</p>
<p>If a set of training/test subjects is selected (via parameter <code>newid</code>), then
</p>

<ul>
<li> <p>the estimated <strong>sign-adjusted line integrand curve</strong> <code class="reqn">\hat{S}\big(p, Q_i(p)\big)</code>
of subject <code class="reqn">i</code>
is displayed on the surface <code class="reqn">\hat{S}(p,q)</code>;
</p>
</li>
<li> <p>the quantile curve <code class="reqn">Q_i(p)</code>
is projected on the <code class="reqn">(p,q)</code>-plain of the 3-dimensional <code class="reqn">(p,q,s)</code> cube,
if <code>proj_Q_p=TRUE</code> (default);
</p>
</li>
<li> <p>the user-specified <code class="reqn">\tilde{p}</code> is marked on the <code class="reqn">(p,q)</code>-plain of the 3D cube,
if <code>proj_Q_p=TRUE</code> (default);
</p>
</li>
<li> <p><code class="reqn">\hat{S}\big(p, Q_i(p)\big)</code>
is projected on the <code class="reqn">(p,s)</code>-plain of the 3-dimensional <code class="reqn">(p,q,s)</code> cube,
if one and only one <a href="#topic+Qindex-class">Qindex</a> model is provided in in
put argument <code>...</code> and <code>proj_S_p=TRUE</code> (default);
</p>
</li>
<li> <p>the estimated <em>linear functional coefficient</em> <code class="reqn">\hat{\beta}(p)</code> is shown on the <code class="reqn">(p,s)</code>-plain of the 3D cube,
if one and only one <em>linear</em> <a href="#topic+Qindex-class">Qindex</a> model is provided in input argument <code>...</code> and <code>proj_beta=TRUE</code> (default).
</p>
</li></ul>



<h3>Integrand Surface</h3>

<p>The quantile index (QI),
</p>
<p style="text-align: center;"><code class="reqn">\text{QI}=\displaystyle\int_0^1\beta(p)\cdot Q(p)\,dp</code>
</p>

<p>with a linear functional coefficient <code class="reqn">\beta(p)</code>
can be estimated by fitting a functional generalized linear model (FGLM, James, 2002) to exponential-family outcomes,
or by fitting a linear functional Cox model (LFCM, Gellar et al., 2015) to survival outcomes.
More flexible non-linear quantile index (nlQI)
</p>
<p style="text-align: center;"><code class="reqn">
\text{nlQI}=\displaystyle\int_0^1 F\big(p, Q(p)\big)\,dp
</code>
</p>

<p>with a bivariate twice differentiable function <code class="reqn">F(\cdot,\cdot)</code>
can be estimated by fitting a functional generalized additive model (FGAM, McLean et al., 2014) to exponential-family outcomes,
or by fitting an additive functional Cox model (AFCM, Cui et al., 2021) to survival outcomes.
</p>
<p>The estimated <strong>integrand surface</strong> of quantile indices and non-linear quantile indices, defined on
<code class="reqn">p\in[0,1]</code> and
<code class="reqn">q\in\text{range}\big(Q_i(p)\big)</code> for all training subjects <code class="reqn">i=1,\cdots,n</code>,
is
</p>
<p style="text-align: center;"><code class="reqn">
\hat{S}_0(p,q) = 
\begin{cases}
\hat{\beta}(p)\cdot q &amp; \text{for QI}\\
\hat{F}(p,q) &amp; \text{for nlQI}
\end{cases}
</code>
</p>



<h3>Sign-Adjustment</h3>

<p>Ideally, we would wish that, <em>in the training set</em>, the estimated linear and/or non-linear quantile indices
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{\text{QI}}_i = \displaystyle\int_0^1 \hat{S}_0\big(p, Q_i(p)\big)dp
</code>
</p>

<p>be <em>positively correlated</em> with a more intuitive quantity, e.g., quantiles <code class="reqn">Q_i(\tilde{p})</code> at a user-specified <code class="reqn">\tilde{p}</code>, for the interpretation of downstream analysis,
Therefore, we define the sign-adjustment term
</p>
<p style="text-align: center;"><code class="reqn">
\hat{c} = \text{sign}\left(\text{corr}\left(Q_i(\tilde{p}), \widehat{\text{QI}}_i\right)\right),\quad i =1,\cdots,n
</code>
</p>

<p>as the <a href="base.html#topic+sign">sign</a> of the <a href="stats.html#topic+cor">cor</a>relation between
the estimated quantile index <code class="reqn">\widehat{\text{QI}}_i</code>
and the quantile <code class="reqn">Q_i(\tilde{p})</code>,
for training subjects <code class="reqn">i=1,\cdots,n</code>.
</p>
<p>The estimated <strong>sign-adjusted integrand surface</strong> is
<code class="reqn">\hat{S}(p,q) = \hat{c} \cdot \hat{S}_0(p,q)</code>.
</p>
<p>The estimated <strong>sign-adjusted quantile indices</strong>
<code class="reqn">\int_0^1 \hat{S}\big(p, Q_i(p)\big)dp</code>
are positively correlated with subject-specific sample medians
(default <code class="reqn">\tilde{p} = .5</code>) in the training set.
</p>


<h3>Note</h3>

<p>The maintainer is not aware of any functionality of projection of arbitrary curves in package <a href="https://CRAN.R-project.org/package=plotly"><span class="pkg">plotly</span></a>.
Currently, the projection to <code class="reqn">(p,q)</code>-plain is hard coded on <code class="reqn">(p,q,s=\text{min}(s))</code>-plain.
</p>


<h3>References</h3>

<p>James, G. M. (2002). <em>Generalized Linear Models with Functional Predictors</em>,
<a href="https://doi.org/10.1111/1467-9868.00342">doi:10.1111/1467-9868.00342</a>
</p>
<p>Gellar, J. E., et al. (2015). <em>Cox regression models with functional covariates for survival data</em>,
<a href="https://doi.org/10.1177/1471082X14565526">doi:10.1177/1471082X14565526</a>
</p>
<p>Mathew W. M., et al. (2014) <em>Functional Generalized Additive Models</em>,
<a href="https://doi.org/10.1080/10618600.2012.729985">doi:10.1080/10618600.2012.729985</a>
</p>
<p>Cui, E., et al. (2021). <em>Additive Functional Cox Model</em>,
<a href="https://doi.org/10.1080/10618600.2020.1853550">doi:10.1080/10618600.2020.1853550</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see ?`Qindex-package`
</code></pre>

<hr>
<h2 id='optimSplit_dichotom'>Optimal Dichotomizing Predictors via Repeated Sample Splits</h2><span id='topic+optimSplit_dichotom'></span><span id='topic+split_dichotom'></span><span id='topic+splits_dichotom'></span><span id='topic+quantile.splits_dichotom'></span>

<h3>Description</h3>

<p>To identify the optimal dichotomizing predictors using repeated sample splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimSplit_dichotom(
  formula,
  data,
  include = quote(p1 &gt; 0.15 &amp; p1 &lt; 0.85),
  top = 1L,
  nsplit,
  ...
)

split_dichotom(y, x, id, ...)

splits_dichotom(y, x, ids = rSplit(y, ...), ...)

## S3 method for class 'splits_dichotom'
quantile(x, probs = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimSplit_dichotom_+3A_formula">formula</code>, <code id="optimSplit_dichotom_+3A_y">y</code>, <code id="optimSplit_dichotom_+3A_x">x</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>, e.g., <code>y~X</code> or <code>y~x1+x2</code>.
Response <code class="reqn">y</code> may be <a href="base.html#topic+double">double</a>, <a href="base.html#topic+logical">logical</a> and <a href="survival.html#topic+Surv">Surv</a>.
Candidate <a href="base.html#topic+numeric">numeric</a> predictors <code class="reqn">x</code>'s may be specified as the columns of one <a href="base.html#topic+matrix">matrix</a> column, e.g., <code>y~X</code>; or as several <a href="base.html#topic+vector">vector</a> columns, e.g., <code>y~x1+x2</code>.
In helper functions, <code>x</code> is a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>.</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_include">include</code></td>
<td>
<p>(optional) <a href="base.html#topic+language">language</a>, inclusion criteria.
Default <code>(p1&gt;.15 &amp; p1&lt;.85)</code> specifies a user-desired range of <code class="reqn">p_1</code>
for the candidate dichotomizing predictors.
See explanation of <code class="reqn">p_1</code> in section <strong>Returns of Helper Functions</strong>.</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_top">top</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, number of optimal dichotomizing predictors, default <code>1L</code></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_nsplit">nsplit</code>, <code id="optimSplit_dichotom_+3A_...">...</code></td>
<td>
<p>additional parameters for function <a href="#topic+rSplit">rSplit</a></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_id">id</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a> for helper function <a href="#topic+split_dichotom">split_dichotom</a>, indices of training (<code>TRUE</code>) and test (<code>FALSE</code>) subjects</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_ids">ids</code></td>
<td>
<p>(optional) <a href="base.html#topic+list">list</a> of <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>s for helper function <a href="#topic+splits_dichotom">splits_dichotom</a>, multiple copies of indices of repeated training-test sample splits.</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_probs">probs</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar for helper function <a href="#topic+quantile.splits_dichotom">quantile.splits_dichotom</a>, see <a href="stats.html#topic+quantile">quantile</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <a href="#topic+optimSplit_dichotom">optimSplit_dichotom</a> identifies the optimal dichotomizing predictors via repeated sample splits. Specifically,
</p>

<ol>
<li><p> Generate multiple, i.e., repeated, training-test sample splits (via <a href="#topic+rSplit">rSplit</a>)
</p>
</li>
<li><p> For each candidate predictor <code class="reqn">x_i</code>, find the <em><strong>median-split-dichotomized regression model</strong></em> based on the repeated sample splits, see details in section <strong>Details on Helper Functions</strong>
</p>
</li>
<li><p> Limit the selection of the candidate predictors <code class="reqn">x</code>'s to a user-desired range of <code class="reqn">p_1</code> of the split-dichotomized regression models, see explanations of <code class="reqn">p_1</code> in section <strong>Returns of Helper Functions</strong>
</p>
</li>
<li><p> Rank the candidate predictors <code class="reqn">x</code>'s by the decreasing order of the <a href="base.html#topic+abs">abs</a>olute values of the regression coefficient estimate of the median-split-dichotomized regression models.  On the top of this rank are the <em><strong>optimal dichotomizing predictors</strong></em>.
</p>
</li></ol>



<h3>Value</h3>

<p>Function <a href="#topic+optimSplit_dichotom">optimSplit_dichotom</a> returns an object of <a href="base.html#topic+class">class</a> <code>'optimSplit_dichotom'</code>, which is a <a href="base.html#topic+list">list</a> of dichotomizing <a href="base.html#topic+function">function</a>s,
with the input <code>formula</code> and <code>data</code> as additional <a href="base.html#topic+attributes">attributes</a>.
</p>


<h3>Details on Helper Functions</h3>



<h4>Split-Dichotomized Regression Model</h4>

<p>Helper function <a href="#topic+split_dichotom">split_dichotom</a> performs a univariable regression model on the test set with a dichotomized predictor, using a dichotomizing rule determined by a recursive partitioning of the training set.
Specifically, given a training-test sample split,
</p>

<ol>
<li><p> find the <em>dichotomizing rule</em> <code class="reqn">\mathcal{D}</code> of the predictor <code class="reqn">x_0</code> given the response <code class="reqn">y_0</code> in the training set (via <a href="#topic+rpartD">rpartD</a>);
</p>
</li>
<li><p> fit a univariable regression model of the response <code class="reqn">y_1</code> with the dichotomized predictor <code class="reqn">\mathcal{D}(x_1)</code> in the test set.
</p>
</li></ol>

<p>Currently the Cox proportional hazards (<a href="survival.html#topic+coxph">coxph</a>) regression for <a href="survival.html#topic+Surv">Surv</a> response, logistic (<a href="stats.html#topic+glm">glm</a>) regression for <a href="base.html#topic+logical">logical</a> response and linear (<a href="stats.html#topic+lm">lm</a>) regression for <a href="stats.html#topic+gaussian">gaussian</a> response are supported.
</p>



<h4>Split-Dichotomized Regression Models based on Repeated Training-Test Sample Splits</h4>

<p>Helper function <a href="#topic+splits_dichotom">splits_dichotom</a> fits multiple split-dichotomized regression models <a href="#topic+split_dichotom">split_dichotom</a> on the response <code class="reqn">y</code> and predictor <code class="reqn">x</code>, based on each copy of the repeated training-test sample splits.
</p>



<h4>Quantile of Split-Dichotomized Regression Models</h4>

<p>Helper function <a href="#topic+quantile.splits_dichotom">quantile.splits_dichotom</a> is a method dispatch of the S3 generic function <a href="stats.html#topic+quantile">quantile</a> on <a href="#topic+splits_dichotom">splits_dichotom</a> object.
Specifically,
</p>

<ol>
<li> <p>collect the univariable regression coefficient estimate from each one of the split-dichotomized regression models;
</p>
</li>
<li> <p>find the nearest-even (i.e., <code>type = 3</code>) <a href="stats.html#topic+quantile">quantile</a> of the coefficients from Step 1. By default, we use the <a href="stats.html#topic+median">median</a> (i.e., <code>prob = .5</code>);
</p>
</li>
<li> <p>the split-dichotomized regression model corresponding to the selected coefficient quantile in Step 2, is returned.
</p>
</li></ol>




<h3>Returns of Helper Functions</h3>

<p>Helper function <a href="#topic+split_dichotom">split_dichotom</a> returns a split-dichotomized regression model, which is either a Cox proportional hazards (<a href="survival.html#topic+coxph">coxph</a>), a logistic (<a href="stats.html#topic+glm">glm</a>), or a linear (<a href="stats.html#topic+lm">lm</a>) regression model, with additional <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'rule')</code></dt><dd><p><a href="base.html#topic+function">function</a>, dichotomizing rule <code class="reqn">\mathcal{D}</code> based on the training set</p>
</dd>
<dt><code>attr(,'text')</code></dt><dd><p><a href="base.html#topic+character">character</a> scalar, human-friendly description of <code class="reqn">\mathcal{D}</code></p>
</dd>
<dt><code>attr(,'p1')</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar, <code class="reqn">p_1 = \text{Pr}(\mathcal{D}(x_1)=1)</code></p>
</dd>
<dt><code>attr(,'coef')</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar, univariable regression coefficient estimate of <code class="reqn">y_1\sim\mathcal{D}(x_1)</code></p>
</dd>
</dl>

<p>Helper function <a href="#topic+splits_dichotom">splits_dichotom</a> returns a <a href="base.html#topic+list">list</a> of split-dichotomized regression models (<a href="#topic+split_dichotom">split_dichotom</a>).
</p>
<p>Helper function <a href="#topic+quantile.splits_dichotom">quantile.splits_dichotom</a> returns a split-dichotomized regression model (<a href="#topic+split_dichotom">split_dichotom</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see ?`Qindex-package`
</code></pre>

<hr>
<h2 id='predict.optimSplit_dichotom'>Regression Models with Optimal Dichotomizing Predictors</h2><span id='topic+predict.optimSplit_dichotom'></span>

<h3>Description</h3>

<p>Regression models with optimal dichotomizing predictor(s), used either as boolean or continuous predictor(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optimSplit_dichotom'
predict(
  object,
  formula = attr(object, which = "formula", exact = TRUE),
  newdata = attr(object, which = "data", exact = TRUE),
  boolean = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.optimSplit_dichotom_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+optimSplit_dichotom">optimSplit_dichotom</a> object</p>
</td></tr>
<tr><td><code id="predict.optimSplit_dichotom_+3A_formula">formula</code></td>
<td>
<p>(optional) <a href="stats.html#topic+formula">formula</a> to specify the response in test data. If missing, the model formula of training data is used</p>
</td></tr>
<tr><td><code id="predict.optimSplit_dichotom_+3A_newdata">newdata</code></td>
<td>
<p>(optional) test <a href="base.html#topic+data.frame">data.frame</a>, candidate <a href="base.html#topic+numeric">numeric</a> predictors <code class="reqn">x</code>'s must have the same <a href="base.html#topic+name">name</a> and <a href="base.html#topic+dim">dim</a>ension as the training data. If missing, the training data is used</p>
</td></tr>
<tr><td><code id="predict.optimSplit_dichotom_+3A_boolean">boolean</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, whether to use the <em>dichotomized</em> predictor (default, <code>TRUE</code>), or the continuous predictor (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="predict.optimSplit_dichotom_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <a href="#topic+predict.optimSplit_dichotom">predict.optimSplit_dichotom</a> returns a <a href="base.html#topic+list">list</a> of regression models, <a href="survival.html#topic+coxph">coxph</a> model for <a href="survival.html#topic+Surv">Surv</a> response, <a href="stats.html#topic+glm">glm</a> for <a href="base.html#topic+logical">logical</a> response, and <a href="stats.html#topic+lm">lm</a> model for <a href="base.html#topic+numeric">numeric</a> response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see ?`Qindex-package`
</code></pre>

<hr>
<h2 id='predict.Qindex'>Predicted Sign-Adjusted Quantile Indices</h2><span id='topic+predict.Qindex'></span>

<h3>Description</h3>

<p>To predict sign-adjusted quantile indices of a test set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Qindex'
predict(object, newdata = object@gam$data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.Qindex_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+Qindex-class">Qindex</a> object based on the training set.</p>
</td></tr>
<tr><td><code id="predict.Qindex_+3A_newdata">newdata</code></td>
<td>
<p>test <a href="base.html#topic+data.frame">data.frame</a>, with at least
the response <code class="reqn">y^{\text{new}}</code> and
the <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of
functional predictor values <code class="reqn">X^{\text{new}}</code>
of the test set, tabulated on the same <code class="reqn">p</code>-grid as the training set <code class="reqn">X</code>.
If missing, the training set <code>object@gam$data</code> will be used.</p>
</td></tr>
<tr><td><code id="predict.Qindex_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <a href="#topic+predict.Qindex">predict.Qindex</a> computes
the predicted sign-adjusted quantile indices on the test set,
which is
the product of function <a href="mgcv.html#topic+predict.gam">predict.gam</a> return
and the correlation sign based on training set
(<code>object@sign</code>, see Step 3 of section <strong>Details</strong> of function <a href="#topic+Qindex">Qindex</a>).
Multiplication by <code>object@sign</code> is required to ensure
that the predicted sign-adjusted quantile indices
are positively associated with the <strong>training</strong> functional predictor values
at the selected tabulating grid.
</p>


<h3>Value</h3>

<p>Function <a href="#topic+predict.Qindex">predict.Qindex</a> returns a
<a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
which is the predicted sign-adjusted quantile indices on the test set.
</p>

<hr>
<h2 id='Qindex'>Sign-Adjusted Quantile Indices</h2><span id='topic+Qindex'></span><span id='topic+Qindex-class'></span><span id='topic+Qindex_prefit_'></span>

<h3>Description</h3>

<p>Sign-adjusted quantile indices
based on linear and/or nonlinear functional predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qindex(formula, data, sign_prob = 0.5, ...)

Qindex_prefit_(formula, data, family, nonlinear = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qindex_+3A_formula">formula</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>, e.g., <code>y~X</code>.
Response <code class="reqn">y</code> may be <a href="base.html#topic+double">double</a>, <a href="base.html#topic+logical">logical</a> and <a href="survival.html#topic+Surv">Surv</a>.
Functional predictor <code class="reqn">X</code> is a tabulated <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a>;
the rows of <code class="reqn">X</code> correspond to the subjects,
while the columns of <code class="reqn">X</code> correspond to a <em>common tabulating grid</em> shared by all subjects.
The <a href="base.html#topic+numeric">numeric</a> values of the grid are in the <a href="base.html#topic+colnames">colnames</a> of <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="Qindex_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, must be a returned object from function <a href="#topic+clusterQp">clusterQp</a></p>
</td></tr>
<tr><td><code id="Qindex_+3A_sign_prob">sign_prob</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar between 0 and 1,
user-specified probability <code class="reqn">\tilde{p}</code>
for the nearest-even <a href="stats.html#topic+quantile">quantile</a> in the grid,
which is used to determine the <a href="base.html#topic+sign">sign</a>-adjustment.
Default is <code>.5</code>, i.e., the nearest-even <a href="stats.html#topic+median">median</a> of the grid</p>
</td></tr>
<tr><td><code id="Qindex_+3A_...">...</code></td>
<td>
<p>additional parameters for functions <a href="mgcv.html#topic+s">s</a> and <a href="mgcv.html#topic+ti">ti</a>,
most importantly <code>k</code></p>
</td></tr>
<tr><td><code id="Qindex_+3A_family">family</code></td>
<td>
<p><a href="stats.html#topic+family">family</a> object,
see function <a href="mgcv.html#topic+gam">gam</a>.
Default values are
</p>

<ul>
<li> <p><code>mgcv::cox.ph()</code> for <a href="survival.html#topic+Surv">Surv</a> response <code class="reqn">y</code>;
</p>
</li>
<li> <p><code>binomial(link = 'logit')</code> for <a href="base.html#topic+logical">logical</a> response <code class="reqn">y</code>;
</p>
</li>
<li> <p><code>gaussian(link = 'identity')</code> for <a href="base.html#topic+double">double</a> response <code class="reqn">y</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="Qindex_+3A_nonlinear">nonlinear</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar,
whether to use nonlinear or linear functional model.
Default <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <a href="#topic+Qindex">Qindex</a> returns an <a href="#topic+Qindex-class">Qindex</a> object,
which is an instance of an <a href="base.html#topic+S4">S4</a> class.
See section <strong>Slots</strong> for details.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p><a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
sign-adjusted quantile indices, see section <strong>Details</strong> of function <a href="#topic+integrandSurface">integrandSurface</a></p>
</dd>
<dt><code>formula</code></dt><dd><p>see section <strong>Arguments</strong>, parameter <code>formula</code></p>
</dd>
<dt><code>gam</code></dt><dd><p>a <a href="mgcv.html#topic+gam">gam</a> object</p>
</dd>
<dt><code>gpf</code></dt><dd><p>a <code>'gam.prefit'</code> object, which is the returned object
from function <a href="mgcv.html#topic+gam">gam</a> with argument <code>fit = FALSE</code></p>
</dd>
<dt><code>p.value</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> scalar,
<code class="reqn">p</code>-value for the test of significance of the functional predictor,
based on slot <code style="white-space: pre;">&#8288;@gam&#8288;</code></p>
</dd>
<dt><code>sign</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar of either 1 or -1,
<a href="base.html#topic+sign">sign</a>-adjustment, see section <strong>Details</strong> of function <a href="#topic+integrandSurface">integrandSurface</a></p>
</dd>
<dt><code>sign_prob</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar, section <strong>Arguments</strong>, parameter <code>sign_prob</code></p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'># see ?`Qindex-package`
</code></pre>

<hr>
<h2 id='Qindex_graphics'>Visualize <a href="#topic+Qindex-class">Qindex</a> object using R package <span class="pkg">graphics</span></h2><span id='topic+Qindex_graphics'></span><span id='topic+persp.Qindex'></span><span id='topic+contour.Qindex'></span>

<h3>Description</h3>

<p>Create <a href="graphics.html#topic+persp">persp</a>ective and <a href="graphics.html#topic+contour">contour</a>
plots of FR-index integrand using R package <span class="pkg">graphics</span>.
</p>
<p>End users are encouraged to use function <a href="#topic+integrandSurface">integrandSurface</a>
with <a href="https://CRAN.R-project.org/package=plotly"><span class="pkg">plotly</span></a> work horse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Qindex'
persp(
  x,
  n = 31L,
  xlab = "Percentages",
  ylab = "Quantiles",
  zlab = "Integrand of FR-index",
  ...
)

## S3 method for class 'Qindex'
contour(
  x,
  n = 501L,
  image_col = topo.colors(20L),
  xlab = "Percentages",
  ylab = "Quantiles",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qindex_graphics_+3A_x">x</code></td>
<td>
<p><a href="#topic+Qindex-class">Qindex</a> object</p>
</td></tr>
<tr><td><code id="Qindex_graphics_+3A_n">n</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> scalar, fineness of visualization,
default <code>501L</code>. See parameter <code>n.grid</code> of function <a href="mgcv.html#topic+vis.gam">vis.gam</a>.</p>
</td></tr>
<tr><td><code id="Qindex_graphics_+3A_xlab">xlab</code>, <code id="Qindex_graphics_+3A_ylab">ylab</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalars</p>
</td></tr>
<tr><td><code id="Qindex_graphics_+3A_zlab">zlab</code></td>
<td>
<p><a href="base.html#topic+character">character</a> scalar, for function <a href="#topic+persp.Qindex">persp.Qindex</a></p>
</td></tr>
<tr><td><code id="Qindex_graphics_+3A_...">...</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code id="Qindex_graphics_+3A_image_col">image_col</code></td>
<td>
<p>argument <code>col</code> of <a href="graphics.html#topic+image.default">image.default</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <a href="#topic+persp.Qindex">persp.Qindex</a>,
a method dispatch of S3 generic <a href="graphics.html#topic+persp">persp</a>,
does not have a return value.
</p>
<p>Function <a href="#topic+contour.Qindex">contour.Qindex</a>,
a method dispatch of S3 generic <a href="graphics.html#topic+contour">contour</a>,
does not have a return value
</p>

<hr>
<h2 id='rpartD'>Dichotomize via Recursive Partitioning</h2><span id='topic+rpartD'></span><span id='topic+m_rpartD'></span>

<h3>Description</h3>

<p>Dichotomize one or more predictors of
a <a href="survival.html#topic+Surv">Surv</a>, a <a href="base.html#topic+logical">logical</a>, or a <a href="base.html#topic+double">double</a> response,
using recursive partitioning and regression tree <a href="rpart.html#topic+rpart">rpart</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpartD(
  y,
  x,
  check_degeneracy = TRUE,
  cp = .Machine$double.eps,
  maxdepth = 2L,
  ...
)

m_rpartD(y, X, check_degeneracy = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpartD_+3A_y">y</code></td>
<td>
<p>a <a href="survival.html#topic+Surv">Surv</a> object,
a <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
or a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>, the response <code class="reqn">y</code></p>
</td></tr>
<tr><td><code id="rpartD_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, one predictor <code class="reqn">x</code></p>
</td></tr>
<tr><td><code id="rpartD_+3A_check_degeneracy">check_degeneracy</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, whether to allow the
dichotomized value to be all-<code>FALSE</code> or all-<code>TRUE</code> (i.e., degenerate)
for any one of the predictors.
Default <code>TRUE</code> to produce a <a href="base.html#topic+warning">warning</a> message for degeneracy.</p>
</td></tr>
<tr><td><code id="rpartD_+3A_cp">cp</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar, complexity parameter, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.
Default <code>.Machine$double.eps</code>, so that a split is enforced
no matter how small improvement in overall <code class="reqn">R^2</code> is</p>
</td></tr>
<tr><td><code id="rpartD_+3A_maxdepth">maxdepth</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, maximum depth of any node, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.
Default <code>2L</code>, because only the first node is needed</p>
</td></tr>
<tr><td><code id="rpartD_+3A_...">...</code></td>
<td>
<p>additional parameters of <a href="rpart.html#topic+rpart">rpart</a> and/or <a href="rpart.html#topic+rpart.control">rpart.control</a></p>
</td></tr>
<tr><td><code id="rpartD_+3A_x">X</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+matrix">matrix</a>,
a set of predictors.
Each column of <code class="reqn">X</code> is one predictor.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Dichotomize Single Predictor</h4>

<p>Function <a href="#topic+rpartD">rpartD</a> dichotomizes one predictor in the following steps,
</p>

<ol>
<li> <p>Recursive partitioning and regression tree <a href="rpart.html#topic+rpart">rpart</a> analysis is
performed for the response <code class="reqn">y</code> and the predictor <code class="reqn">x</code>.
</p>
</li>
<li> <p>The <a href="rpart.html#topic+labels.rpart">labels.rpart</a> of the first node of
the <a href="rpart.html#topic+rpart">rpart</a> tree
is considered as the dichotomizing rule of the <a href="base.html#topic+double">double</a> predictor <code class="reqn">x</code>.
The term <em>dichotomizing rule</em> indicates the combination of an inequality sign
(<a href="base.html#topic++3E">&gt;</a>, <a href="base.html#topic++3E+3D">&gt;=</a>, <a href="base.html#topic++3C">&lt;</a> and <a href="base.html#topic++3C+3D">&lt;=</a>)
and a <a href="base.html#topic+double">double</a> cutoff threshold <code class="reqn">a</code>
</p>
</li>
<li> <p>The dichotomizing rule from Step 2 is further processed, such that
</p>

<ul>
<li> <p><code class="reqn">&lt;a</code> is regarded as <code class="reqn">\geq a</code>
</p>
</li>
<li> <p><code class="reqn">\leq a</code> is regarded as <code class="reqn">&gt;a</code>
</p>
</li>
<li> <p><code class="reqn">&gt; a</code> and <code class="reqn">\geq a</code> are regarded as is.
</p>
</li></ul>

<p>This step is necessary for a narrative of
<em>greater than</em> or <em>greater than or equal to</em>
the threshold <code class="reqn">a</code>.
</p>
</li>
<li> <p>A <a href="base.html#topic+warning">warning</a> message is produced,
if the dichotomizing rule, applied to a new <a href="base.html#topic+double">double</a> predictor <code>newx</code>, creates
an all-<code>TRUE</code> or all-<code>FALSE</code> result.
We do not make the algorithm <a href="base.html#topic+stop">stop</a>,
as most regression models in R are capable of handling
an all-<code>TRUE</code> or all-<code>FALSE</code> predictor,
by returning a <code>NA_real_</code> regression coefficient estimate.

</p>
</li></ol>




<h4>Dichotomize Multiple Predictors</h4>

<p>Function <a href="#topic+m_rpartD">m_rpartD</a> dichotomizes
each predictor <code>X[,i]</code> based on the response <code class="reqn">y</code>
using function <a href="#topic+rpartD">rpartD</a>.
Applying the multiple dichotomizing rules to a new set of predictors <code>newX</code>,
</p>

<ul>
<li> <p>A <a href="base.html#topic+warning">warning</a> message is produced,
if at least one of the dichotomized predictors is all-<code>TRUE</code> or all-<code>FALSE</code>.
</p>
</li>
<li> <p>We do not check if more than one of the dichotomized predictors
are <a href="base.html#topic+identical">identical</a> to each other.
We take care of this situation in helper function <a href="#topic+coef_dichotom">coef_dichotom</a>
</p>
</li></ul>




<h3>Value</h3>



<h4>Dichotomize Single Predictor</h4>

<p>Function <a href="#topic+rpartD">rpartD</a> returns a <a href="base.html#topic+function">function</a>,
with a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a> parameter <code>newx</code>.
The returned value of <code>rpartD(y,x)(newx)</code> is a
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>
with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'cutoff')</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar, the cutoff value for <code>newx</code></p>
</dd>
</dl>




<h4>Dichotomize Multiple Predictors</h4>

<p>Function <a href="#topic+m_rpartD">m_rpartD</a> returns a <a href="base.html#topic+function">function</a>,
with a <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> parameter <code>newX</code>.
The argument for <code>newX</code> must have
the same number of columns and the same column names as
the input <a href="base.html#topic+matrix">matrix</a> <code class="reqn">X</code>.
The returned value of <code>m_rpartD(y,X)(newX)</code> is a
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+matrix">matrix</a>
with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'cutoff')</code></dt><dd>
<p>named <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
the cutoff values for each predictor in <code>newX</code></p>
</dd>
</dl>




<h3>Note</h3>

<p>In future <a href="base.html#topic+integer">integer</a> and <a href="base.html#topic+factor">factor</a> predictors will be supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dichotomize Single Predictor
data(cu.summary, package = 'rpart') # see more details from ?rpart::cu.summary
with(cu.summary, rpartD(y = Price, x = Mileage, check_degeneracy = FALSE))
(foo = with(cu.summary, rpartD(y = Price, x = Mileage)))
foo(rnorm(10, mean = 24.5))
## Dichotomize Multiple Predictors
library(survival)
data(stagec, package = 'rpart') # see more details from ?rpart::stagec
nrow(stagec) # 146
(foo = with(stagec[1:100,], m_rpartD(y = Surv(pgtime, pgstat), X = cbind(age, g2, gleason))))
foo(as.matrix(stagec[-(1:100), c('age', 'g2', 'gleason')]))
</code></pre>

<hr>
<h2 id='rSplit'>Stratified Random Split Sampling</h2><span id='topic+rSplit'></span>

<h3>Description</h3>

<p>Random split sampling, stratified based on the type of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSplit(y, nsplit, stratify = TRUE, s_ratio = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rSplit_+3A_y">y</code></td>
<td>
<p>a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
a <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
a <a href="base.html#topic+factor">factor</a>,
or a <a href="survival.html#topic+Surv">Surv</a> object,
response <code class="reqn">y</code></p>
</td></tr>
<tr><td><code id="rSplit_+3A_nsplit">nsplit</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, number of <a href="base.html#topic+replicate">replicate</a>s of random splits to be performed</p>
</td></tr>
<tr><td><code id="rSplit_+3A_stratify">stratify</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar,
whether stratification based on response <code class="reqn">y</code> needs to be implemented, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rSplit_+3A_s_ratio">s_ratio</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar between 0 and 1,
split ratio, i.e., percentage of training subjects <code class="reqn">p</code>, default <code>.8</code></p>
</td></tr>
<tr><td><code id="rSplit_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <a href="#topic+rSplit">rSplit</a> performs random split sampling,
with or without stratification. Specifically,
</p>

<ul>
<li><p> If <code>stratify = FALSE</code>,
or if we have a <a href="base.html#topic+double">double</a> response <code class="reqn">y</code>,
then split the sample into a training and a test set by odds <code class="reqn">p/(1-p)</code>, without stratification.
</p>
</li>
<li><p> Otherwise, split a <a href="survival.html#topic+Surv">Surv</a> response <code class="reqn">y</code>, stratified by its censoring status.
Specifically,
split subjects with observed event into a training and a test set by odds <code class="reqn">p/(1-p)</code>,
and split the censored subjects into a training and a test set by odds <code class="reqn">p/(1-p)</code>.
Then combine the training sets from subjects with observed events and censored subjects,
and combine the test sets from subjects with observed events and censored subjects.
</p>
</li>
<li><p> Otherwise, split a <a href="base.html#topic+logical">logical</a> response <code class="reqn">y</code>, stratified by itself.
Specifically,
split the subjects with <code>TRUE</code> response into a training and a test set by odds <code class="reqn">p/(1-p)</code>,
and split the subjects with <code>FALSE</code> response into a training and a test set by odds <code class="reqn">p/(1-p)</code>.
Then combine the training sets, and the test sets, in a similar fashion as described above.
</p>
</li>
<li><p> Otherwise, split a <a href="base.html#topic+factor">factor</a> response <code class="reqn">y</code>, stratified by its <a href="base.html#topic+levels">levels</a>.
Specifically,
split the subjects in each level of <code class="reqn">y</code> into a training and a test set by odds <code class="reqn">p/(1-p)</code>.
Then combine the training sets, and the test sets, from all levels of <code class="reqn">y</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Function <a href="#topic+rSplit">rSplit</a> returns a length-<code>nsplit</code> <a href="base.html#topic+list">list</a> of
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>s.
In each <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
the <code>TRUE</code> elements indicate training subjects and
the <code>FALSE</code> elements indicate test subjects.
</p>


<h3>Note</h3>

<p><code>caTools::sample.split</code> is not what we need.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+split">split</a>, <code>caret::createDataPartition</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rSplit(y = rep(c(TRUE, FALSE), times = c(20, 30)), nsplit = 3L)

</code></pre>

<hr>
<h2 id='show+2CQindex-method'>Show <a href="#topic+Qindex-class">Qindex</a> Object</h2><span id='topic+show+2CQindex-method'></span>

<h3>Description</h3>

<p>Show <a href="#topic+Qindex-class">Qindex</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Qindex'
show(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="show+2B2CQindex-method_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+Qindex-class">Qindex</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="base.html#topic+S4">S4</a> <a href="methods.html#topic+show">show</a> method of <a href="#topic+Qindex-class">Qindex</a> object
does not have a returned value.
</p>

<hr>
<h2 id='std_'>Alternative Standardization Methods</h2><span id='topic+std_'></span><span id='topic+std_IQR'></span><span id='topic+std_mad'></span>

<h3>Description</h3>

<p>Alternative standardization using <a href="stats.html#topic+median">median</a>, <a href="stats.html#topic+IQR">IQR</a> and <a href="stats.html#topic+mad">mad</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_IQR(x, na.rm = TRUE, ...)

std_mad(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std__+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a></p>
</td></tr>
<tr><td><code id="std__+3A_na.rm">na.rm</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar,
see functions <a href="stats.html#topic+quantile">quantile</a>, <a href="stats.html#topic+median">median</a> and <a href="stats.html#topic+mad">mad</a>.
Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="std__+3A_...">...</code></td>
<td>
<p>additional parameters of functions <a href="stats.html#topic+quantile">quantile</a> and/or <a href="stats.html#topic+mad">mad</a></p>
</td></tr>
</table>


<h3>Value</h3>



<h4>Standardize using <a href="stats.html#topic+median">median</a> and <a href="stats.html#topic+IQR">IQR</a></h4>

<p>Function <a href="#topic+std_IQR">std_IQR</a> returns a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of the same length as <code>x</code>.
</p>



<h4>Standardize using <a href="stats.html#topic+median">median</a> and <a href="stats.html#topic+mad">mad</a></h4>

<p>Function <a href="#topic+std_mad">std_mad</a> returns a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of the same length as <code>x</code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>std_IQR(rnorm(20))
std_mad(rnorm(20))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
