<!DOCTYPE html><html><head><title>Help for package Qindex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Qindex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BBC_dichotom'><p>Bootstrap-based Optimism Correction for Dichotomization</p></a></li>
<li><a href='#bootIDX'><p>Generate Bootstrap Indices</p></a></li>
<li><a href='#celldata'><p>Ki67 Data</p></a></li>
<li><a href='#clusterQp'><p>Cluster-Specific Sample Quantiles</p></a></li>
<li><a href='#FRindex'><p>Functional Regression Indices &amp; Weights</p></a></li>
<li><a href='#gam2beta'><p>Extract Functional Coefficient from gam Return</p></a></li>
<li><a href='#nlFRindex'><p>Nonlinear Functional Regression Indices</p></a></li>
<li><a href='#optimSplit_dichotom'><p>Optimal Dichotomizing Predictors via Repeated Sample Splits</p></a></li>
<li><a href='#Qindex-package'><p>Continuous and Dichotomized Index Predictors Based on Distribution Quantiles</p></a></li>
<li><a href='#rpartD'><p>Dichotomize via Recursive Partitioning</p></a></li>
<li><a href='#rSplit'><p>Random Split Sampling with Stratification</p></a></li>
<li><a href='#show,FRindex-method'><p>Show FRindex Object</p></a></li>
<li><a href='#std_'><p>Alternative Standardization Methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous and Dichotomized Index Predictors Based on
Distribution Quantiles</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Tingting Zhan <a href="https://orcid.org/0000-0001-9971-4844"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Misung Yi <a href="https://orcid.org/0000-0002-4007-5408"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Inna Chervoneva <a href="https://orcid.org/0000-0002-9104-4505"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tingting Zhan &lt;tingtingzhan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Select optimal functional regression or dichotomized quantile
        predictors for survival/logistic/numeric outcome and perform
        optimistic bias correction for any optimally dichotomized numeric
        predictor(s), as in Yi, et. al. (2023)
        &lt;<a href="https://doi.org/10.1016%2Fj.labinv.2023.100158">doi:10.1016/j.labinv.2023.100158</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2),</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, matrixStats, methods, mgcv, pracma, rpart, stats,
survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, boot</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-17 19:09:46 UTC; txz003</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-17 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BBC_dichotom'>Bootstrap-based Optimism Correction for Dichotomization</h2><span id='topic+BBC_dichotom'></span><span id='topic+optimism_dichotom'></span><span id='topic+coef_dichotom'></span>

<h3>Description</h3>

<p>Functions explained in this documentation are,
</p>

<dl>
<dt><code>BBC_dichotom()</code></dt><dd>
<p>to obtain a multivariable regression model with
bootstrap-based optimism correction
on the dichotomized predictors.</p>
</dd>
<dt><code>optimism_dichotom()</code></dt><dd>
<p>a helper function to compute the bootstrap-based optimism
of the dichotomized predictors.</p>
</dd>
<dt><code>coef_dichotom()</code></dt><dd>
<p>a helper function to obtain the
estimated multivariable regression coefficients of the dichotomized predictors.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>BBC_dichotom(formula, dichotom, data, ...)

optimism_dichotom(formula, X, data, R = 100L, ...)

coef_dichotom(formula, dX, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BBC_dichotom_+3A_formula">formula</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>,
left-hand-side being the response <code class="reqn">y</code> and
right-hand-side being the predictors <em>in addition to</em>
the predictors to be <code>dichotom</code>ized.
If there is no additional predictor, use <code>y ~ 1</code></p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_dichotom">dichotom</code></td>
<td>
<p>one-sided <a href="stats.html#topic+formula">formula</a>
of the set of predictors to be dichotomized.
These predictors can be stored in <code>data</code> as
one or more <a href="base.html#topic+numeric">numeric</a> columns and/or
one <a href="base.html#topic+matrix">matrix</a> column</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, containing the response <code class="reqn">y</code> and predictors in <code>formula</code>,
as well as the predictors to be <code>dichotom</code>ized</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_x">X</code></td>
<td>
<p>(for helper function <code><a href="#topic+optimism_dichotom">optimism_dichotom()</a></code>)
<a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">k</code> columns,
a set of <code class="reqn">k</code> <a href="base.html#topic+numeric">numeric</a> predictors</p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_r">R</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar,
number of bootstrap replicates <code class="reqn">R</code>, default <code>100L</code></p>
</td></tr>
<tr><td><code id="BBC_dichotom_+3A_dx">dX</code></td>
<td>
<p>(for helper function <code><a href="#topic+coef_dichotom">coef_dichotom()</a></code>)
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">k</code> columns,
a set of <code class="reqn">k</code> dichotomized predictors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+BBC_dichotom">BBC_dichotom()</a></code> obtains a multivariable regression model with
bootstrap-based optimism correction on the dichotomized predictors.
Specifically,
</p>

<ol>
<li><p> Dichotomize the <code class="reqn">k</code> predictors in the <em>entire data</em> (using function <code><a href="#topic+m_rpartD">m_rpartD()</a></code>).
Fit a regression model to the entire data with the <code class="reqn">k</code> dichotomized predictors
as well as the additional predictors, if any (using helper function <code><a href="#topic+coef_dichotom">coef_dichotom()</a></code>).
The estimated regression model is referred to as the <em>apparent performance</em>.
</p>
</li>
<li><p> Obtain the bootstrap-based optimism based on <code class="reqn">R</code> copies of bootstrap samples,
using <a href="#topic+optimism_dichotom">optimism_dichotom</a>.
Calculate the <a href="stats.html#topic+median">median</a> of bootstrap-based optimism,
specific to each of the dichotomized predictors.
In future, we may expand the options to include the use of trimmed-mean
<a href="base.html#topic+mean.default">mean.default</a><code style="white-space: pre;">&#8288;(, trim)&#8288;</code>, etc.
For now, let's refer to the median optimism as
the <em>optimism-correction</em> of the <code class="reqn">k</code> dichotomized predictors.
</p>
</li></ol>

<p>Subtract the optimism-correction (in Step 2)
from the apparent performance estimates (in Step 1),
<em>only for the <code class="reqn">k</code> dichotomized predictors</em>.
The apparent performance estimates for the additional predictors, if any,
are not modified.
The variance-covariance (<a href="stats.html#topic+vcov">vcov</a>) estimates of the apparent performance
is not modified, for now.
None of the other regression model diagnostics, such as
<a href="stats.html#topic+resid">resid</a>uals,
<a href="stats.html#topic+logLik">logLik</a>elihood,
etc.,
are modified neither, for now.
The coefficient-only, partially-modified regression model is referred to as
the <em>optimism-corrected performance</em>.
</p>


<h3>Value</h3>

<p>Function <a href="#topic+BBC_dichotom">BBC_dichotom</a> returns a
<a href="survival.html#topic+coxph">coxph</a>, <a href="stats.html#topic+glm">glm</a> or <a href="stats.html#topic+lm">lm</a> regression model,
with <a href="base.html#topic+attributes">attributes</a>,
</p>

<dl>
<dt><code>attr(,'optimism')</code></dt><dd><p>the returned object from <a href="#topic+optimism_dichotom">optimism_dichotom</a></p>
</dd>
<dt><code>attr(,'apparent_cutoff')</code></dt><dd><p>a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
cutoff thresholds for the <code class="reqn">k</code> predictors in the apparent model</p>
</dd>
</dl>



<h3>Details of Helper Function <code>optimism_dichotom()</code></h3>

<p>Function <a href="#topic+optimism_dichotom">optimism_dichotom</a> computes the bootstrap-based optimism
of the dichotomized predictors.
First, <code class="reqn">R</code> bootstrap samples are generated,
for which the end-user may specify a <a href="base.html#topic+Random">Random</a> seed, if needed.
Then,
</p>

<ol>
<li><p> From each of the <code class="reqn">R</code> bootstrap samples,
obtain the dichotomizing branches for the <code class="reqn">k</code> predictors to be dichotomized,
using function <code><a href="#topic+m_rpartD">m_rpartD()</a></code>
</p>
</li>
<li><p> Dichotomize the <code class="reqn">k</code> predictors in each <em>bootstrap sample</em>
using the respective dichotomizing branches from Step 1.
The regression coefficients estimate for the <code class="reqn">k</code> dichotomized predictors
(using helper function <code><a href="#topic+coef_dichotom">coef_dichotom()</a></code>)
is referred to as the <em>bootstrap performance estimate</em>.
</p>
</li>
<li><p> Dichotomize the <code class="reqn">k</code> predictors in the <em>entire data</em>
using each of the bootstrap dichotomizing branches from Step 1.
The regression coefficients estimate for the <code class="reqn">k</code> dichotomized predictors
(using helper function <code><a href="#topic+coef_dichotom">coef_dichotom()</a></code>)
is referred to as the <em>test performance estimate</em>.
</p>
</li></ol>

<p>The difference between the bootstrap and test performance estimates,
based on each of the <code class="reqn">R</code> bootstrap samples,
are referred to as the bootstrap-based <em>optimism</em> or optimistic bias.
</p>


<h3>Details of Helper Function <code>coef_dichotom()</code></h3>

<p>Function <a href="#topic+coef_dichotom">coef_dichotom</a> obtains the
estimated multivariable regression coefficients of the dichotomized predictors.
A Cox proportional hazards (<a href="survival.html#topic+coxph">coxph</a>) regression for <a href="survival.html#topic+Surv">Surv</a> response,
a logistic (<a href="stats.html#topic+glm">glm</a>) regression for <a href="base.html#topic+logical">logical</a> response,
or a linear (<a href="stats.html#topic+lm">lm</a>) regression for <a href="stats.html#topic+gaussian">gaussian</a> response
is performed with
</p>

<ul>
<li><p> the dichotomous <a href="base.html#topic+logical">logical</a> predictors, given as the columns of <code>dX</code>, and
</p>
</li>
<li><p> the additional predictors specified in <code>formula</code>
</p>
</li></ul>

<p>When <code>dX</code> has duplicated columns,
the regression model is fitted using the <em>unique</em> columns of <code>dX</code> and the
additional predictors in <code>formula</code>.
The returned coefficient estimates repeat the corresponding estimates of the unique columns of <code>dX</code>.
</p>


<h3>Returns of Helper Functions</h3>

<p>Helper function <code><a href="#topic+optimism_dichotom">optimism_dichotom()</a></code> returns an <code class="reqn">R\times k</code> <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of
bootstrap-based optimism,
with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'cutoff')</code></dt><dd><p>an <code class="reqn">R\times k</code> <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a>,
the <code class="reqn">R</code> copies of bootstrap cutoff thresholds for the <code class="reqn">k</code> predictors.
See attribute <code>'cutoff'</code> of function <code><a href="#topic+m_rpartD">m_rpartD()</a></code></p>
</dd>
</dl>

<p>Helper function <code><a href="#topic+coef_dichotom">coef_dichotom()</a></code> returns a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a> of the
coefficients of the dichotomized predictors, with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'model')</code></dt><dd><p>the <a href="survival.html#topic+coxph">coxph</a>, <a href="stats.html#topic+glm">glm</a> or <a href="stats.html#topic+lm">lm</a> regression model</p>
</dd>
</dl>



<h3>References on Helper Function <code>optimism_dichotom()</code></h3>

<p>Ewout W. Steyerberg (2009) Clinical Prediction Models.
<a href="https://doi.org/10.1007/978-0-387-77244-8">doi:10.1007/978-0-387-77244-8</a>
</p>
<p>Frank E. Harrell Jr., Kerry L. Lee, Daniel B. Mark. (1996)
Multivariable prognostic models: issues in developing models, evaluating
assumptions and adequacy, and measuring and reducing errors.
<a href="https://doi.org/10.1002/%28SICI%291097-0258%2819960229%2915%3A4%3C361%3A%3AAID-SIM168%3E3.0.CO%3B2-4">doi:10.1002/(SICI)1097-0258(19960229)15:4&lt;361::AID-SIM168&gt;3.0.CO;2-4</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(flchain, package = 'survival') # see more details from ?survival::flchain
head(flchain2 &lt;- within.data.frame(flchain, expr = {
  mgus = as.logical(mgus)
}))
dim(flchain3 &lt;- subset(flchain2, futime &gt; 0)) # required by ?rpart::rpart
dim(flchain_Circulatory &lt;- subset(flchain3, chapter == 'Circulatory'))

m1 = BBC_dichotom(Surv(futime, death) ~ age + sex + mgus, 
 data = flchain_Circulatory, dichotom = ~ kappa + lambda)
summary(m1)
attr(attr(m1, 'optimism'), 'cutoff')
attr(m1, 'apparent_cutoff')

</code></pre>

<hr>
<h2 id='bootIDX'>Generate Bootstrap Indices</h2><span id='topic+bootIDX'></span>

<h3>Description</h3>

<p>Generate a series of <a href="boot.html#topic+boot">boot</a>strap indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootIDX(n, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootIDX_+3A_n">n</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, sample size</p>
</td></tr>
<tr><td><code id="bootIDX_+3A_r">R</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, number of bootstrap replicates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+bootIDX">bootIDX()</a></code> is designed to generate the same bootstrap indices as
from the default options of function <a href="boot.html#topic+boot">boot</a>,
given the same <a href="base.html#topic+Random">Random</a> seed.
</p>
<p>See details in <code>boot:::index.array()</code> and <code>boot:::ordinary.array()</code>.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+bootIDX">bootIDX()</a></code> returns a <a href="base.html#topic+list">list</a> of positive <a href="base.html#topic+integer">integer</a> <a href="base.html#topic+vector">vector</a>s.
Each element is the indices of one bootstrap sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1345); boot::boot(data = 1:10, statistic = function(data, ind) ind, R = 3L)[['t']]
set.seed(1345); bootIDX(10L, R = 3L) # same copies of indices

</code></pre>

<hr>
<h2 id='celldata'>Ki67 Data</h2><span id='topic+celldata'></span><span id='topic+Ki67'></span>

<h3>Description</h3>

<p>Ki67 cell data containing 622 patients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ki67
</code></pre>


<h3>Format</h3>


<dl>
<dt><code>PATIENT_ID</code></dt><dd><p><a href="base.html#topic+factor">factor</a>, unique patient identifier</p>
</dd>
<dt><code>tissueID</code></dt><dd><p><a href="base.html#topic+factor">factor</a>, TMA core identifier</p>
</dd>
<dt><code>RECURRENCE</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, recurrence indicator, 1 = Recurred, 0 = not Recurred</p>
</dd>
<dt><code>RECFREESURV_MO</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, recurrence-free survival time in months</p>
</dd>
<dt><code>Marker</code></dt><dd><p><a href="base.html#topic+double">double</a>, cell signal intensity of the protein immunofloerscence signal</p>
</dd>
<dt><code>inner_x</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, <code class="reqn">x</code>-coordinate in the cell centroid in the TMA core</p>
</dd>
<dt><code>inner_y</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, <code class="reqn">y</code>-coordinate in the cell centroid in the TMA core</p>
</dd>
<dt><code>AGE_AT_DX</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, age at diagnosis</p>
</dd>
<dt><code>Tstage</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, tumor stage</p>
</dd>
<dt><code>NodeSt</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, node stage, -1 = unknown, 0 = Node Negative, 1 = Node Positive</p>
</dd>
<dt><code>HRpos</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, indicator of hormone positive status (ER+ or PR+), 1 = positive, 0 = negative</p>
</dd>
<dt><code>HistologicalGrade</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, histology grade</p>
</dd>
<dt><code>Her2_path_qIF</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, Her2 status, 1 = positive, 0 = negative</p>
</dd>
<dt><code>RACE</code></dt><dd><p><a href="base.html#topic+character">character</a>, race, White, Black, Asian, Native Hawaiian or Other Pacific Islander, American Indian or Alaska Native, Unknown</p>
</dd>
<dt><code>RadjCHEMO</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, adjuvant chemo treatment, 0 = unknown,  1 = done, 2 = NOT done</p>
</dd>
<dt><code>RadjRAD</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, adjuvant radiation treatment, 0 = unknown,  1 = done, 2 = NOT done</p>
</dd>
<dt><code>HORM_4cat</code></dt><dd><p><a href="base.html#topic+integer">integer</a>, hormone treatment, 0 = unknown, 1 = not indicated, 2 = done, 3 = recommended, but not done</p>
</dd>
<dt><code>MSI</code></dt><dd><p><a href="base.html#topic+double">double</a>, mean signal intensity (mean over all cells in the TMA core)</p>
</dd>
</dl>


<hr>
<h2 id='clusterQp'>Cluster-Specific Sample Quantiles</h2><span id='topic+clusterQp'></span>

<h3>Description</h3>

<p>Obtain vectors of sample <a href="stats.html#topic+quantile">quantile</a>s in each cluster of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterQp(
  formula,
  data,
  exclude,
  from = 0.01,
  to = 0.99,
  by = 0.01,
  type = 7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterQp_+3A_formula">formula</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a> passed to <a href="stats.html#topic+aggregate.formula">aggregate.formula</a>.
To calculate the cluster-specific statistics
for response <code class="reqn">y</code>, the user may use
</p>

<dl>
<dt><code>y ~ id</code></dt><dd><p>to retain only the cluster <code>id</code> in the returned value</p>
</dd>
<dt><code>y ~ id + x1 + x2</code></dt><dd><p>to retain the cluster <code>id</code> and cluster-specific variables <code class="reqn">x_1</code> and <code class="reqn">x_2</code> in the returned value</p>
</dd>
<dt><code>y ~ .</code></dt><dd><p>to retain all (supposedly cluster-specific) variables from <code>data</code> in the returned value</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="clusterQp_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a></p>
</td></tr>
<tr><td><code id="clusterQp_+3A_exclude">exclude</code></td>
<td>
<p>(optional) <a href="stats.html#topic+formula">formula</a> or <a href="base.html#topic+character">character</a> <a href="base.html#topic+vector">vector</a>,
(supposedly non-cluster-specific) variables to be excluded from aggregation.
To remove variables <code class="reqn">z_1</code> and <code class="reqn">z_2</code>, the user may use either
</p>

<ul>
<li> <p><code>exclude = c('z1', 'z2')</code>; or
</p>
</li>
<li> <p><code>exclude = . ~ . - z1 - z2</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="clusterQp_+3A_from">from</code>, <code id="clusterQp_+3A_to">to</code>, <code id="clusterQp_+3A_by">by</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalars,
the starting, end, and increment values
to specify a <a href="base.html#topic+seq">seq</a>uence of probabilities
<code class="reqn">p = (p_1,\cdots,p_N)'</code>
for the sample <a href="stats.html#topic+quantile">quantile</a>s <code class="reqn">q = (q_1,\cdots,q_N)'</code></p>
</td></tr>
<tr><td><code id="clusterQp_+3A_type">type</code></td>
<td>
<p><a href="base.html#topic+integer">integer</a> scalar, type of <a href="stats.html#topic+quantile">quantile</a> algorithm</p>
</td></tr>
<tr><td><code id="clusterQp_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+clusterQp">clusterQp()</a></code> calculates <code class="reqn">N</code> sample <a href="stats.html#topic+quantile">quantile</a>s
in each <a href="stats.html#topic+aggregate">aggregate</a>d cluster of observations.
The aggregation is specified by parameters <code>formula</code> and <code>exclude</code>.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+clusterQp">clusterQp()</a></code> returns an <a href="stats.html#topic+aggregate">aggregate</a>d <a href="base.html#topic+data.frame">data.frame</a>.
A <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of <code class="reqn">N</code> columns is created to store
the sample <a href="stats.html#topic+quantile">quantile</a>s <code class="reqn">q</code> of each <a href="stats.html#topic+aggregate">aggregate</a>d cluster.
The column names of this quantile <a href="base.html#topic+matrix">matrix</a> are the probabilities <code class="reqn">p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ki67q = clusterQp(Marker ~ ., data = Ki67, exclude = c('tissueID','inner_x','inner_y'))
tmp = clusterQp(Marker ~ ., data = Ki67, exclude = . ~ . - tissueID - inner_x - inner_y)
# stopifnot(identical(Ki67q, tmp))
# stopifnot(!anyDuplicated.default(Ki67q$subjID))
head(Ki67q)
sapply(Ki67q, FUN = class)

</code></pre>

<hr>
<h2 id='FRindex'>Functional Regression Indices &amp; Weights</h2><span id='topic+FRindex'></span><span id='topic+FRindex-class'></span><span id='topic+FR_gam'></span><span id='topic+predict.FRindex'></span>

<h3>Description</h3>

<p>Functions explained in this documentation are,
</p>

<dl>
<dt><code><a href="#topic+FRindex">FRindex()</a></code></dt><dd>
<p>to compute the functional regression indices and weights based on the functional predictors.</p>
</dd>
<dt><code><a href="#topic+predict.FRindex">predict.FRindex()</a></code></dt><dd>
<p>to compute the predicted values based on functional regression indices and weights model.</p>
</dd>
<dt><code><a href="#topic+FR_gam">FR_gam()</a></code></dt><dd>
<p>a helper function to fit a functional regression model
using generalized additive models with integrated smoothness estimation (<a href="mgcv.html#topic+gam">gam</a>).</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>FRindex(formula, data, sign_prob = 0.5, ...)

FR_gam(
  formula,
  data,
  xarg = as.double(colnames(X)),
  family,
  knot_pct = 0.4,
  knot.value = ceiling(length(xarg) * knot_pct),
  ...
)

## S3 method for class 'FRindex'
predict(
  object,
  newdata = object@data,
  newX = newdata[[object@formula[[3L]]]],
  new_xarg = as.double(colnames(newX)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FRindex_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a>.
</p>

<dl>
<dt>Left-hand-side</dt><dd><p>is the <a href="base.html#topic+name">name</a> of the response <code class="reqn">y</code>.
Supported types of responses are <a href="base.html#topic+double">double</a>, <a href="base.html#topic+logical">logical</a> and <a href="survival.html#topic+Surv">Surv</a>.</p>
</dd>
<dt>Right-hand-side</dt><dd><p>is the <a href="base.html#topic+name">name</a>
of the tabulated <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> <code class="reqn">X</code> of functional predictor values.
Each row of <code class="reqn">X</code> represents the tabulated values for a subject.
All rows/subjects are tabulated on a common grid <code>xarg</code>.
Each column of <code class="reqn">X</code> represents the tabulated values at a point on the common grid for each subject.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="FRindex_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, with
the response <code class="reqn">y</code> and the tabulated functional predictor values <code class="reqn">X</code>
specified in <code>formula</code>.
If the functional predictor is the <a href="stats.html#topic+quantile">quantile</a> function,
then <code>data</code> is preferably the returned object of <code><a href="#topic+clusterQp">clusterQp()</a></code>.</p>
</td></tr>
<tr><td><code id="FRindex_+3A_sign_prob">sign_prob</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar between 0 and 1,
probability corresponding to the selected nearest-even quantile in <code>xarg</code>,
which is used to define the <a href="base.html#topic+sign">sign</a> of the functional regression weights.
Default is <code>.5</code>, i.e., the nearest-even <a href="stats.html#topic+median">median</a> of <code>xarg</code></p>
</td></tr>
<tr><td><code id="FRindex_+3A_...">...</code></td>
<td>
<p>for function <code><a href="#topic+predict.FRindex">predict.FRindex()</a></code> and helper function <code><a href="#topic+FR_gam">FR_gam()</a></code>,
these are currently not in use.
For function <code><a href="#topic+FRindex">FRindex()</a></code>, see a detailed explanation in section <strong>Using <code>...</code> in <code>FRindex()</code></strong></p>
</td></tr>
<tr><td><code id="FRindex_+3A_xarg">xarg</code></td>
<td>
<p>strictly increasing <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
the common grid on which the functional predictor values <code class="reqn">X</code> are tabulated</p>
</td></tr>
<tr><td><code id="FRindex_+3A_family">family</code></td>
<td>
<p><a href="stats.html#topic+family">family</a> object, the distribution
and link function to be used in <a href="mgcv.html#topic+gam">gam</a>.
Default family for <a href="survival.html#topic+Surv">Surv</a> response is <code>mgcv::cox.ph()</code>,
for <a href="base.html#topic+logical">logical</a> response is <code>binomial(link = 'logit')</code>,
for <a href="base.html#topic+double">double</a> response is <code>gaussian(link = 'identity')</code>.</p>
</td></tr>
<tr><td><code id="FRindex_+3A_knot_pct">knot_pct</code></td>
<td>
<p>positive <a href="base.html#topic+double">double</a> scalar,
percentage of the number of columns of <code class="reqn">X</code>,
to be used as <code>knot.value</code>.
Default is <code class="reqn">40\%</code>.
If <code>knot.value</code> is provided by the end-user, then <code>knot_pct</code> is ignored.</p>
</td></tr>
<tr><td><code id="FRindex_+3A_knot.value">knot.value</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, number of knots
(i.e., parameter <code>k</code> in the spline smooth function <a href="mgcv.html#topic+s">s</a>)
used in <a href="mgcv.html#topic+gam">gam</a>.
Default is the <a href="base.html#topic+ceiling">ceiling</a> of <code>knot_pct</code> of
the column dimension of <code class="reqn">X</code></p>
</td></tr>
<tr><td><code id="FRindex_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+FRindex-class">FRindex</a> object for the <a href="stats.html#topic+predict">predict</a> method,
the returned object from function <code><a href="#topic+FRindex">FRindex()</a></code></p>
</td></tr>
<tr><td><code id="FRindex_+3A_newdata">newdata</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, with at least
the tabulated functional predictor values <code class="reqn">X^{new}</code>
based on <code>object@formula</code></p>
</td></tr>
<tr><td><code id="FRindex_+3A_newx">newX</code></td>
<td>
<p><a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a>,
functional predictor values <code class="reqn">X^{new}</code> for a set of new subjects.
Each row of <code class="reqn">X^{new}</code> represents the tabulated values for a new subject.
All rows/subjects are tabulated on a common grid <code>new_xarg</code>.
Each column of <code class="reqn">X^{new}</code> represents the tabulated values at a point on the common grid for each new subject.</p>
</td></tr>
<tr><td><code id="FRindex_+3A_new_xarg">new_xarg</code></td>
<td>
<p>strictly increasing <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
the common grid on which the functional predictor values <code class="reqn">X^{new}</code> are tabulated.
The length of <code>new_xarg</code>
does not need to be the same as the length of <code>object@xarg</code>,
but they must share the same range.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Functional regression indices &amp; weights model</h4>

<p>Function <code><a href="#topic+FRindex">FRindex()</a></code> defines and calculates
the functional regression indices and weights in the following steps.
</p>

<ol>
<li><p> Fit a functional regression model to the response <code class="reqn">y</code>
using the functional predictor <code class="reqn">X</code>,
with tabulated tabulated on a same grid <code>xarg</code> for all subjects,
using helper function <code><a href="#topic+FR_gam">FR_gam()</a></code>
</p>
</li>
<li><p> Select one point in the tabulating grid <code>xarg</code>.
For one-dimensional domain,
we select the nearest-even <a href="stats.html#topic+quantile">quantile</a> of the tabulating grid <code>xarg</code>,
corresponding to the user-specified probability <code>sign_prob</code>.
Default <code>sign_prob = .5</code> indicates the <a href="stats.html#topic+median">median</a> of <code>xarg</code>.
</p>
</li>
<li><p> Obtain the fitted coefficient function <code class="reqn">\hat\beta(x)</code>,
tabulated on the grid <code>xarg</code>,
using internal helper function <code><a href="#topic+gam2beta">gam2beta()</a></code>
</p>
</li>
<li><p> Calculate the integral of the product of
the fitted coefficient function <code class="reqn">\hat\beta(x)</code> (from Step 3) and
the functional predictor values <code class="reqn">X</code>,
using the <a href="pracma.html#topic+trapz">trapz</a>oid rule
</p>
</li>
<li><p> Obtain the <a href="base.html#topic+sign">sign</a> of the <a href="stats.html#topic+cor">cor</a>relation between
</p>

<ul>
<li><p> the subject-specific functional predictor <em>values</em>,
at the selected quantile of <code>xarg</code> (from Step 2), and
</p>
</li>
<li><p> the subject-specific integrals from Step 4
</p>
</li></ul>

</li></ol>

<p><em>Functional regression weights</em> (slot <code style="white-space: pre;">&#8288;@weight&#8288;</code>)
are the tabulated weight function on the grid <code>xarg</code>.
These weights are defined as the product of
<code>sign</code> (from Step 5) and <code class="reqn">\hat\beta(x)</code> (from Step 3).
</p>
<p><em>Functional regression indices</em> (slot <code style="white-space: pre;">&#8288;@index&#8288;</code>)
are defined as the product of
<code>sign</code> (from Step 5) and <code>intg</code> (from Step 4).
Multiplication by <code>sign</code> is required to ensure
that the resulting functional regression indices
are positively associated with the functional predictor values
at the selected quantile of <code>xarg</code> (from Step 2).
</p>



<h4>Predict method for functional regression indices &amp; weights</h4>

<p>Function <code><a href="#topic+predict.FRindex">predict.FRindex()</a></code> computes functional regression indices and weights
based on the tabulated functional predictors <code class="reqn">X^{new}</code> in a new sets of subjects.
It's important that the new tabulation grid <code>new_xarg</code> must have the same <a href="base.html#topic+range">range</a>
as the model tabulation grid <code>object@xarg</code>.
Then,
</p>

<ol>
<li><p> Obtain the fitted coefficient function <code class="reqn">\hat\beta(x^{new})</code>
of the existing generalized additive model <code>object@gam</code>,
but tabulated on the new grid <code>new_xarg</code>,
using internal helper function <code><a href="#topic+gam2beta">gam2beta()</a></code>
</p>
</li>
<li><p> Calculate the integral of the product of
the fitted coefficient function <code class="reqn">\hat\beta(x^{new})</code> (from Step 1) and
the new functional predictor values <code class="reqn">X^{new}</code>,
using the <a href="pracma.html#topic+trapz">trapz</a>oid rule
</p>
</li></ol>

<p>Predicted functional regression weights
are the tabulated weight function on the new grid <code>new_xarg</code>.
These weights are defined as the product of
<code>object@sign</code> and <code class="reqn">\hat\beta(x^{new})</code> (from Step 1).
</p>
<p>Predicted functional regression indices
are defined as the product of
<code>object@sign</code> and <code>intg</code> (from Step 2).
Multiplication by <code>object@sign</code> is required to ensure
that the resulting functional regression indices
are positively associated with the functional predictor values
at the selected quantile of <code>object@xarg</code>.
</p>



<h3>Value</h3>



<h4>Functional regression indices &amp; weights model</h4>

<p>Function <code><a href="#topic+FRindex">FRindex()</a></code> returns an <a href="base.html#topic+S4">S4</a> <a href="#topic+FRindex-class">FRindex</a> object.
The slots of <a href="base.html#topic+S4">S4</a> class <a href="#topic+FRindex-class">FRindex</a> are described in section <strong>Slots</strong>.
</p>



<h4>Predict method for functional regression indices &amp; weights</h4>

<p>Function <code><a href="#topic+predict.FRindex">predict.FRindex()</a></code> returns a
<a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
which is the predicted functional regression indices.
The returned object contains an <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'weight')</code></dt><dd><p><a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
the predicted functional regression weights</p>
</dd>
</dl>




<h3>Slots</h3>


<dl>
<dt><code>formula,data,xarg</code></dt><dd><p>see explanations in section <strong>Arguments</strong></p>
</dd>
<dt><code>gam</code></dt><dd><p><a href="mgcv.html#topic+gam">gam</a> object, the returned object of helper function <code><a href="#topic+FR_gam">FR_gam()</a></code></p>
</dd>
<dt><code>sign</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar of either 1 or -1,
see Step 5 in section <strong>Details</strong> on function <code><a href="#topic+FRindex">FRindex()</a></code></p>
</dd>
<dt><code>index,weight</code></dt><dd><p><a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>s,
functional regression indices and functional regression weights, respectively.
See section <strong>Details</strong> on function <code><a href="#topic+FRindex">FRindex()</a></code></p>
</dd>
</dl>


<h3>Using <code>...</code> in <code>FRindex()</code></h3>

<p>Function <code><a href="#topic+FRindex">FRindex()</a></code> passes the parameters
<code>xarg</code>, <code>family</code>, <code>knot_pct</code> and <code>knot.value</code>
into helper function <code><a href="#topic+FR_gam">FR_gam()</a></code> through three dots <code>...</code>.
</p>
<p>The most important parameter among them is <code>xarg</code>.
The default argument of the parameter <code>xarg</code> comes
from the column names of the <a href="base.html#topic+matrix">matrix</a> of
tabulated functional predictor values <code class="reqn">X</code>.
This is particularly convenient when
the functional predictor is the <a href="stats.html#topic+quantile">quantile</a> function,
and <code>data</code> is the returned object of function <code><a href="#topic+clusterQp">clusterQp()</a></code>.
</p>
<p>Both <code><a href="#topic+FRindex">FRindex()</a></code> and helper function <code><a href="#topic+FR_gam">FR_gam()</a></code> accept user-provided <code>xarg</code>.
In such case, the provided values will be checked such that
</p>

<ol>
<li> <p><code>xarg</code> is a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> without missingness
</p>
</li>
<li> <p><a href="base.html#topic+length">length</a> of <code>xarg</code> is the same as the number of columns of <a href="base.html#topic+matrix">matrix</a> <code class="reqn">X</code>
</p>
</li>
<li> <p><code>xarg</code> must be strictly sorted (see <a href="base.html#topic+is.unsorted">is.unsorted</a>)
</p>
</li></ol>

<p>Otherwise, an error message will be returned.
</p>


<h3>Details of Helper Function</h3>

<p>Helper function <code><a href="#topic+FR_gam">FR_gam()</a></code> uses <a href="mgcv.html#topic+gam">gam</a> to estimate the functional coefficient by fitting functional regression model.
</p>


<h3>Returns of Helper Functions</h3>

<p>Helper function <code><a href="#topic+FR_gam">FR_gam()</a></code> returns a <a href="mgcv.html#topic+gam">gam</a> object, with additional <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'X')</code></dt><dd><p><a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> of tabulated functional predictor values <code class="reqn">X</code></p>
</dd>
<dt><code>attr(,'xarg')</code></dt><dd><p><a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>, see explanation of parameter <code>xarg</code></p>
</dd>
</dl>



<h3>References</h3>

<p>Cui, E., Crainiceanu, C. M., &amp; Leroux, A. (2021).
Additive Functional Cox Model. Journal of Computational and Graphical Statistics.
<a href="https://doi.org/10.1080/10618600.2020.1853550">doi:10.1080/10618600.2020.1853550</a>
</p>
<p>Gellar, J. E., Colantuoni, E., Needham, D. M., &amp; Crainiceanu, C. M. (2015).
Cox regression models with functional covariates for survival data. Statistical Modelling.
<a href="https://doi.org/10.1177/1471082X14565526">doi:10.1177/1471082X14565526</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)

pt = unique(Ki67$PATIENT_ID)
length(pt) # 622
# set.seed if necessary
train_pt = sample(pt, size = 500L)
Ki67q = clusterQp(Marker ~ ., data = Ki67, exclude = c('tissueID','inner_x','inner_y'))
train_q = subset(Ki67q, PATIENT_ID %in% train_pt)
test_q = subset(Ki67q, !(PATIENT_ID %in% train_pt))
train_q$Marker = log1p(train_q$Marker)
test_q$Marker = log1p(test_q$Marker)

FRi = FRindex(Surv(RECFREESURV_MO, RECURRENCE) ~ Marker, data = train_q)
FRi@index # functional regression index
FRi@weight # functional regression weights
head(show(FRi)) # append `FRi` to the data

(FRi_test = predict(FRi, newdata = test_q))

FRi_train = predict(FRi)
# stopifnot(identical(FRi@index, c(FRi_train)), 
#  identical(FRi@weight, attr(FRi_train, 'weight')))

# set.seed if necessary
Ki67bbc_v2 = BBC_dichotom(Surv(RECFREESURV_MO, RECURRENCE) ~ NodeSt + Tstage, 
  data = data.frame(train_q, FRi_std = std_IQR(FRi_train)), 
  dichotom = ~ FRi_std)
summary(Ki67bbc_v2)

Ki67q = clusterQp(Marker ~ ., data = Ki67, exclude = c('tissueID','inner_x','inner_y'))
Ki67q$Marker = log1p(Ki67q$Marker)

library(survival)
FR_gam(Surv(RECFREESURV_MO, RECURRENCE) ~ Marker, data = Ki67q)

</code></pre>

<hr>
<h2 id='gam2beta'>Extract Functional Coefficient from <a href="mgcv.html#topic+gam">gam</a> Return</h2><span id='topic+gam2beta'></span>

<h3>Description</h3>

<p>Extract the function coefficient from <a href="mgcv.html#topic+gam">gam</a> return
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam2beta(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam2beta_+3A_object">object</code></td>
<td>
<p>a <a href="mgcv.html#topic+gam">gam</a> object</p>
</td></tr>
<tr><td><code id="gam2beta_+3A_...">...</code></td>
<td>
<p>additional parameters of <a href="mgcv.html#topic+plot.gam">plot.gam</a>,
most importantly <code>n</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract beta function from <a href="mgcv.html#topic+gam">gam</a> return, using <a href="mgcv.html#topic+plot.gam">plot.gam</a>.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+gam2beta">gam2beta()</a></code> returns a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>.
</p>


<h3>Note</h3>

<p>Suppress the figure from printing; inspired by <code>oddsratio::no_plot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcv)


# one dimensional
# ?mgcv::gam examples
set.seed(0)
f1 = function(x) {exp(2 * x)}
f2 = function(x) 0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10 
f3 = function(x) {x*0}
n = 200
sig2 = 4
x0 = rep(1:4,50)
x1 = runif(n, 0, 1)
x2 = runif(n, 0, 1)
x3 = runif(n, 0, 1)
e = rnorm(n, 0, sqrt(sig2))
y = 2*x0 + f1(x1) + f2(x2) + f3(x3) + e
x0 = factor(x0)
b = gam(y~x0+s(x1)+s(x2)+s(x3))
vis.gam(b)
gam2beta(b)


# two dimensional
# ?mgcv::ti examples
test1 &lt;- function(x,z,sx=0.3,sz=0.4) { 
x &lt;- x*20
(pi**sx*sz)*(1.2*exp(-(x-0.2)^2/sx^2-(z-0.3)^2/sz^2)+0.8*exp(-(x-0.7)^2/sx^2-(z-0.8)^2/sz^2))
}
n &lt;- 500
x &lt;- runif(n)/20;z &lt;- runif(n);
xs &lt;- seq(0,1,length=30)/20;zs &lt;- seq(0,1,length=30)
pr &lt;- data.frame(x=rep(xs,30),z=rep(zs,rep(30,30)))
truth &lt;- matrix(test1(pr$x,pr$z),30,30)
f &lt;- test1(x,z)
y &lt;- f + rnorm(n)*0.2

b2 &lt;- gam(y ~ te(x,z))
vis.gam(b2)
dim(gam2beta(b2)) # works


b3 &lt;- gam(y ~ ti(x) + ti(z) + ti(x,z))
vis.gam(b3)
plot(b3)
# debug(gam2beta); gam2beta(b3) # not working yet!



## now illustrate partial ANOVA decomp...
b4 &lt;- gam(y~ ti(x) + ti(x,z,mc=c(0,1))) ## note z constrained!
vis.gam(b4)
# debug(gam2beta); gam2beta(b4) # not working yet!



</code></pre>

<hr>
<h2 id='nlFRindex'>Nonlinear Functional Regression Indices</h2><span id='topic+nlFRindex'></span><span id='topic+nlFRindex-class'></span><span id='topic+predict.nlFRindex'></span>

<h3>Description</h3>

<p>Functions explained in this documentation are,
</p>

<dl>
<dt><code><a href="#topic+nlFRindex">nlFRindex()</a></code></dt><dd>
<p>to compute the non-linear functional regression indices based on the functional predictors.</p>
</dd>
<dt><code><a href="#topic+predict.FRindex">predict.FRindex()</a></code></dt><dd>
<p>to compute the predicted values based on functional regression indices model.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>nlFRindex(
  formula,
  data,
  xarg = as.double(colnames(X)),
  family,
  fit = TRUE,
  ...
)

## S3 method for class 'nlFRindex'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlFRindex_+3A_formula">formula</code></td>
<td>
<p>a two-sided <a href="stats.html#topic+formula">formula</a>.
</p>

<dl>
<dt>Left-hand-side</dt><dd><p>is the <a href="base.html#topic+name">name</a> of the response <code class="reqn">y</code>.
Supported types of responses are <a href="base.html#topic+double">double</a>, <a href="base.html#topic+logical">logical</a> and <a href="survival.html#topic+Surv">Surv</a>.</p>
</dd>
<dt>Right-hand-side</dt><dd><p>is the <a href="base.html#topic+name">name</a>
of the tabulated <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> <code class="reqn">X</code> of functional predictor values.
Each row of <code class="reqn">X</code> represents the tabulated values for a subject.
All rows/subjects are tabulated on a common grid <code>xarg</code>.
Each column of <code class="reqn">X</code> represents the tabulated values at a point on the common grid for each subject.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nlFRindex_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, with
the response <code class="reqn">y</code> and the tabulated functional predictor values <code class="reqn">X</code>
specified in <code>formula</code>.
If the functional predictor is the <a href="stats.html#topic+quantile">quantile</a> function,
then <code>data</code> is preferably the returned object of <code><a href="#topic+clusterQp">clusterQp()</a></code>.</p>
</td></tr>
<tr><td><code id="nlFRindex_+3A_xarg">xarg</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>.
The default argument comes from the column names of the <a href="base.html#topic+matrix">matrix</a> of
tabulated functional predictor values <code class="reqn">X</code>.
This is particularly convenient when
the functional predictor is the <a href="stats.html#topic+quantile">quantile</a> function,
and <code>data</code> is the returned object of function <code><a href="#topic+clusterQp">clusterQp()</a></code>.
The user-provided <code>xarg</code> will be checked such that
</p>

<ol>
<li> <p><code>xarg</code> is a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> without missingness
</p>
</li>
<li> <p><a href="base.html#topic+length">length</a> of <code>xarg</code> is the same as the number of columns of <a href="base.html#topic+matrix">matrix</a> <code class="reqn">X</code>
</p>
</li>
<li> <p><code>xarg</code> must be strictly sorted (see <a href="base.html#topic+is.unsorted">is.unsorted</a>)
</p>
</li></ol>

<p>Otherwise, an error message will be returned.</p>
</td></tr>
<tr><td><code id="nlFRindex_+3A_family">family</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code id="nlFRindex_+3A_fit">fit</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, see <a href="mgcv.html#topic+gam">gam</a></p>
</td></tr>
<tr><td><code id="nlFRindex_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
<tr><td><code id="nlFRindex_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+nlFRindex-class">nlFRindex</a> object for the <a href="stats.html#topic+predict">predict</a> method,
the returned object from function <code><a href="#topic+nlFRindex">nlFRindex()</a></code></p>
</td></tr>
<tr><td><code id="nlFRindex_+3A_newdata">newdata</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, with at least
the tabulated functional predictor values <code class="reqn">X^{new}</code>
based on <code>object@formula</code></p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Functional regression indices &amp; weights model</h4>

<p>Function <code><a href="#topic+nlFRindex">nlFRindex()</a></code> fits a non-linear functional regression model to the response <code class="reqn">y</code>
using the functional predictor <code class="reqn">X</code>,
with values tabulated on a same grid <code>xarg</code> for all subjects (Cui et al, 2021).
</p>



<h4>Predict method for non-linear functional regression indices</h4>

<p>Function <code><a href="#topic+predict.nlFRindex">predict.nlFRindex()</a></code> computes non-linear functional regression indices
based on the tabulated functional predictors <code class="reqn">X^{new}</code> in a new sets of subjects.
It's important that the new tabulation grid must be exactly the same
as the model tabulation grid <code>object@xarg</code>.
</p>



<h3>Value</h3>



<h4>Functional regression indices &amp; weights model</h4>

<p>Function <code><a href="#topic+nlFRindex">nlFRindex()</a></code> returns an <a href="base.html#topic+S4">S4</a> <a href="#topic+nlFRindex-class">nlFRindex</a> object.
The slots of <a href="base.html#topic+S4">S4</a> class <a href="#topic+nlFRindex-class">nlFRindex</a> are described in section <strong>Slots</strong>.
</p>



<h4>Predict method for non-linear functional regression indices</h4>

<p>Function <code><a href="#topic+predict.nlFRindex">predict.nlFRindex()</a></code> returns a
<a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
which is the predicted non-linear functional regression indices.
</p>



<h3>Slots</h3>


<dl>
<dt><code>formula,data,xarg</code></dt><dd><p>see explanations in section <strong>Arguments</strong></p>
</dd>
<dt><code>gam</code></dt><dd><p><a href="mgcv.html#topic+gam">gam</a> object</p>
</dd>
<dt><code>p.value</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> scalar,
<code class="reqn">p</code>-value for the test of significance of the functional predictor</p>
</dd>
<dt><code>index</code></dt><dd><p><a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
functional regression indices.</p>
</dd>
</dl>


<h3>References</h3>

<p>Cui, E., Crainiceanu, C. M., &amp; Leroux, A. (2021).
Additive Functional Cox Model. Journal of Computational and Graphical Statistics.
<a href="https://doi.org/10.1080/10618600.2020.1853550">doi:10.1080/10618600.2020.1853550</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pt = unique(Ki67$PATIENT_ID)
length(pt) # 622
# set.seed if necessary
train_pt = sample(pt, size = 500L)
Ki67q = clusterQp(Marker ~ ., data = Ki67, exclude = c('tissueID','inner_x','inner_y'))
train_q = subset(Ki67q, PATIENT_ID %in% train_pt)
test_q = subset(Ki67q, !(PATIENT_ID %in% train_pt))
train_q$Marker = log1p(train_q$Marker)
test_q$Marker = log1p(test_q$Marker)

# using Cox model
m = nlFRindex(Surv(RECFREESURV_MO, RECURRENCE) ~ Marker, data = train_q)
m@p.value # test significance of `Marker` as a functional predictor
train_index = predict(m, newdata = train_q) # non-linear FR index of training data
# stopifnot(identical(train_index, m@index))
predict(m, newdata = test_q) # non-linear FR index of test data

# using logistic regression model
nlFRindex(RECURRENCE ~ Marker, data = train_q)

# using Gaussian model
nlFRindex(RECFREESURV_MO ~ Marker, data = train_q)

</code></pre>

<hr>
<h2 id='optimSplit_dichotom'>Optimal Dichotomizing Predictors via Repeated Sample Splits</h2><span id='topic+optimSplit_dichotom'></span><span id='topic+split_dichotom'></span><span id='topic+quantile_split_dichotom'></span>

<h3>Description</h3>

<p>Functions explained in this documentation are,
</p>

<dl>
<dt><code>optimSplit_dichotom()</code></dt><dd>
<p>to identify the optimal dichotomizing predictors using repeated sample splits.</p>
</dd>
<dt><code>split_dichotom()</code></dt><dd>
<p>a helper function to perform a univariable regression model on the test set
with a dichotomized predictor,
using a dichotomizing rule determined
by a recursive partitioning of the training set.</p>
</dd>
<dt><code>quantile_split_dichotom()</code></dt><dd>
<p>a helper function to locate a quantile of multiple <a href="#topic+split_dichotom">split_dichotom</a> objects,
based on the estimated univariable regression coefficient.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>optimSplit_dichotom(formula, data, include, top = 1L, nsplit, ...)

split_dichotom(y, x, index, ...)

quantile_split_dichotom(y, x, indices = rSplit(y, ...), probs = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimSplit_dichotom_+3A_formula">formula</code></td>
<td>
<p><a href="stats.html#topic+formula">formula</a>.
Left-hand-side is the <a href="base.html#topic+name">name</a> of
a <a href="survival.html#topic+Surv">Surv</a>, <a href="base.html#topic+logical">logical</a>, or <a href="base.html#topic+double">double</a> response <code class="reqn">y</code>.
Right-hand-side is the candidate <a href="base.html#topic+numeric">numeric</a> predictors in <code>data</code>,
given either as the <a href="base.html#topic+name">name</a> of a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+matrix">matrix</a> column
(e.g., <code>y ~ X</code>),
or as the names of several <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> columns
(e.g., <code>y ~ x1 + x2 + x3</code>)</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, containing the response and predictors in <code>formula</code></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_include">include</code></td>
<td>
<p><a href="base.html#topic+language">language</a> object,
inclusion criteria for the optimal dichotomizing predictors.
A suggested choice is <code>(highX&gt;.15 &amp; highX&lt;.85)</code>
to guarantee a user-desired range of proportions in <code>highX</code>.
See explanation of <code>highX</code> in helper function <code><a href="#topic+split_dichotom">split_dichotom()</a></code>.</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_top">top</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, number of optimal dichotomizing predictors, default <code>1L</code></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_nsplit">nsplit</code>, <code id="optimSplit_dichotom_+3A_...">...</code></td>
<td>
<p>additional parameters for function <code><a href="#topic+rSplit">rSplit()</a></code></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_y">y</code></td>
<td>
<p>(for helper functions)
a <a href="survival.html#topic+Surv">Surv</a> object, a <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
or a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>, the response <code class="reqn">y</code></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_x">x</code></td>
<td>
<p>(for helper functions)
<a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, a single predictor <code class="reqn">x</code></p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_index">index</code></td>
<td>
<p>(for helper function <code><a href="#topic+split_dichotom">split_dichotom()</a></code>)
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
indices of training and test set.
<code>TRUE</code> elements indicate training subjects and
<code>FALSE</code> elements indicate test subjects.</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_indices">indices</code></td>
<td>
<p>(optional, for helper function <code><a href="#topic+quantile_split_dichotom">quantile_split_dichotom()</a></code>)
a <a href="base.html#topic+list">list</a> of <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>s,
the indices of multiple training-test sample splits.
Default value is provided by function <code><a href="#topic+rSplit">rSplit()</a></code>.</p>
</td></tr>
<tr><td><code id="optimSplit_dichotom_+3A_probs">probs</code></td>
<td>
<p>(for helper function <code><a href="#topic+quantile_split_dichotom">quantile_split_dichotom()</a></code>)
<a href="base.html#topic+double">double</a> scalar, see <a href="stats.html#topic+quantile">quantile</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+optimSplit_dichotom">optimSplit_dichotom()</a></code> selects the optimal dichotomizing predictors via repeated sample splits.
Specifically,
</p>

<ol>
<li><p> Generate multiple training-test sample splits using function <code><a href="#topic+rSplit">rSplit()</a></code>
</p>
</li>
<li><p> For each candidate predictor,
find the median <a href="#topic+split_dichotom">split_dichotom</a>
(using helper function <code><a href="#topic+quantile_split_dichotom">quantile_split_dichotom()</a></code>)
of the multiple sample splits from Step 1.
</p>
</li>
<li><p> (Optional) limit the selection in a subset of the candidate predictors.
Typically, we would prefer to guarantee
a user-desired range of <code>highX</code>
(see explanations on <code>highX</code> in section <strong>Returns of Helper Functions</strong>).
A suggested choice is <code>(highX&gt;.15 &amp; highX&lt;.85)</code>.
</p>
</li>
<li><p> Rank the candidate predictors, from either Step 2 or Step 3,
by the decreasing order of the <a href="base.html#topic+abs">abs</a>olute values of
the estimated univariable regression coefficients of the corresponding <a href="#topic+split_dichotom">split_dichotom</a> objects.
</p>
</li></ol>

<p>The <em>optimal dichotomizing predictors</em> are the ones
with the largest <a href="base.html#topic+abs">abs</a>olute values of
the estimated univariable regression coefficients
of the corresponding <a href="#topic+split_dichotom">split_dichotom</a> objects.
</p>


<h3>Value</h3>

<p>Function <code><a href="#topic+optimSplit_dichotom">optimSplit_dichotom()</a></code> returns a <a href="base.html#topic+data.frame">data.frame</a>,
which contains the response,
and only the optimal dichotomizing predictors out of all candidate predictors.
Other variables in <code>data</code>, which are not specified in <code>formula</code>, are retained.
In addition, the dichotomized values of the optimal dichotomizing predictors,
according to their respective dichotomizing rules, are also included.
The returned value has <a href="base.html#topic+attributes">attributes</a>,
</p>

<dl>
<dt><code>attr(,'id_top')</code></dt><dd>
<p>positive <a href="base.html#topic+integer">integer</a> scalar or <a href="base.html#topic+vector">vector</a>,
the indices of the optimal dichotomizing predictors out of all candidate predictors.</p>
</dd>
<dt><code>attr(,'top')</code></dt><dd>
<p>a diagnostic <a href="base.html#topic+data.frame">data.frame</a> of
the median <a href="#topic+split_dichotom">split_dichotom</a>s of each of the optimal dichotomizing predictors,
with columns
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$cutoff&#8288;</code></dt><dd><p>the cutoff threshold, identified in the training set</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$highX&#8288;</code></dt><dd>
<p>proportion of the dichotomizing predictors
greater-than or greater-than-or-equal-to the cutoff threshold, in the test set</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$coef&#8288;</code></dt><dd>
<p>the estimated univariable regression coefficient of
the dichotomized predictor, in the test set</p>
</dd>
</dl>

</dd>
</dl>



<h3>Details on Helper Functions</h3>



<h4>Univariable regression model with a dichotomized predictor</h4>

<p>Helper function <code><a href="#topic+split_dichotom">split_dichotom()</a></code> performs a univariable regression model on the test set
with a dichotomized predictor,
using a dichotomizing rule determined
by a recursive partitioning of the training set.
Currently the Cox proportional hazards (<a href="survival.html#topic+coxph">coxph</a>) regression for <a href="survival.html#topic+Surv">Surv</a> response,
logistic (<a href="stats.html#topic+glm">glm</a>) regression for <a href="base.html#topic+logical">logical</a> response and
linear (<a href="stats.html#topic+lm">lm</a>) regression for <a href="stats.html#topic+gaussian">gaussian</a> response
are supported.
Specifically, given a training-test sample split,
</p>

<ol>
<li><p> find the dichotomizing rule of the response <code class="reqn">y</code>
given the predictor <code class="reqn">x</code>, using function <code><a href="#topic+rpartD">rpartD()</a></code>, in the training set
</p>
</li>
<li><p> dichotomize the predictor <code class="reqn">x</code> using the rule identified in Step 1,
in the test set.
</p>
</li>
<li><p> run a univariable regression model on the response <code class="reqn">y</code>
on the dichotomized predictor from Step 2, in the test set.
</p>
</li></ol>




<h4>Quantile of <a href="#topic+split_dichotom">split_dichotom</a> objects</h4>

<p>Helper function <code><a href="#topic+quantile_split_dichotom">quantile_split_dichotom()</a></code> finds the <a href="stats.html#topic+quantile">quantile</a>
of the univariable regression coefficient (i.e., effect size) of a dichotomized predictor,
based on multiple given training-test sample splits.
Specifically,
</p>

<ol>
<li> <p>for each training-test sample split,
fit the univariable regression model based on the dichotomized predictor,
using helper function <code><a href="#topic+split_dichotom">split_dichotom()</a></code>
</p>
</li>
<li> <p>finds the nearest-even (<code>type = 3</code>) <a href="stats.html#topic+quantile">quantile</a>
of the estimated univariable regression coefficients obtained in Step 1,
based on the user-specified probability <code>prob</code>
</p>
</li></ol>

<p>The <a href="#topic+split_dichotom">split_dichotom</a> object from Step 1,
whose estimated univariable regression coefficient equals to
the specified quantile identified in Step 2,
is referred to as the quantile of <a href="#topic+split_dichotom">split_dichotom</a> objects
based on the multiple given training-test sample splits.
</p>



<h3>Returns of Helper Functions</h3>

<p>Helper function <code><a href="#topic+split_dichotom">split_dichotom()</a></code>, as well as helper function <code><a href="#topic+quantile_split_dichotom">quantile_split_dichotom()</a></code>, returns
a Cox proportional hazards (<a href="survival.html#topic+coxph">coxph</a>),
or a logistic (<a href="stats.html#topic+glm">glm</a>),
or a linear (<a href="stats.html#topic+lm">lm</a>)
regression model,
with additional <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'rule')</code></dt><dd><p><a href="base.html#topic+function">function</a>,
the dichotomizing rule based on the training set</p>
</dd>
<dt><code>attr(,'cutoff')</code></dt><dd><p><a href="base.html#topic+numeric">numeric</a> scalar,
the cutoff threshold based on the training set</p>
</dd>
<dt><code>attr(,'highX')</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar,
proportion of <a href="base.html#topic+numeric">numeric</a> predictor <code class="reqn">x</code>, in the test set, which is greater-than or greater-than-or-equal-to
the cutoff threshold <code>attr(, 'cutoff')</code></p>
</dd>
<dt><code>attr(,'coef')</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar,
the estimated univariable regression coefficient of the dichotomized predictor in the test set</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data(pbc, package = 'survival') # see more details from ?survival::pbc
head(pbc2 &lt;- within.data.frame(subset(pbc, status != 1L), expr = {
  death = (status == 2L)
  trt = structure(trt, levels = c('D-penicillmain', 'placebo'), class = 'factor')
  trt = relevel(trt, ref = 'placebo')
}))

# set.seed if needed
m1 = optimSplit_dichotom(
  Surv(time, death) ~ bili + chol + albumin + copper + alk.phos + ast + trig + platelet + protime, 
  data = pbc2, nsplit = 20L, include = (highX &gt; .15 &amp; highX &lt; .85), top = 2L) 
head(m1, n = 10L)
attr(m1, 'top')

</code></pre>

<hr>
<h2 id='Qindex-package'>Continuous and Dichotomized Index Predictors Based on Distribution Quantiles</h2><span id='topic+Qindex-package'></span>

<h3>Description</h3>

<p>Primary functions in this package are
</p>

<dl>
<dt><code><a href="#topic+optimSplit_dichotom">optimSplit_dichotom()</a></code></dt><dd>
<p>optimal dichotomizing predictor(s) selection via dichotomizing split sample
<strong>Still need? Select optimal functional regression or dichotomized quantile predictors for survival/logistic/numeric outcome</strong>
</p>
</dd>
<dt><code><a href="#topic+BBC_dichotom">BBC_dichotom()</a></code></dt><dd>
<p>Bootstrap-based optimism correction for dichotomizing selected predictor(s)
<strong>Still need? perform optimism correction for any optimal dichotomizing predictor(s)</strong>
</p>
</dd>
<dt><code><a href="#topic+clusterQp">clusterQp()</a></code></dt><dd><p>calculate user-selected sample quantiles in each cluster of observations.</p>
</dd>
<dt><code><a href="#topic+FRindex">FRindex()</a></code></dt><dd><p>Functional regression index as a predictor in the functional regression model</p>
</dd>
</dl>



<h3>References</h3>

<p>Selection of optimal quantile protein biomarkers based on cell-level immunohistochemistry data.
Misung Yi, Tingting Zhan , Amy P. Peck, Jeffrey A. Hooke, Albert J. Kovatich, Craig D. Shriver,
Hai Hu, Yunguang Sun, Hallgeir Rui and Inna Chervoneva.  Under revision
</p>
<p>Quantile index biomarkers based on single-cell expression data.
Misung Yi, Tingting Zhan, Amy P. Peck, Jeffrey A. Hooke, Albert J. Kovatich, Craig D. Shriver,
Hai Hu, Yunguang Sun, Hallgeir Rui and Inna Chervoneva.
Laboratory Investigation, 2023. <a href="https://doi.org/10.1016/j.labinv.2023.100158">doi:10.1016/j.labinv.2023.100158</a>
</p>

<hr>
<h2 id='rpartD'>Dichotomize via Recursive Partitioning</h2><span id='topic+rpartD'></span><span id='topic+m_rpartD'></span>

<h3>Description</h3>

<p>Dichotomize one or more predictors of
a <a href="survival.html#topic+Surv">Surv</a>, a <a href="base.html#topic+logical">logical</a>, or a <a href="base.html#topic+double">double</a> response,
using recursive partitioning and regression tree <a href="rpart.html#topic+rpart">rpart</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpartD(
  y,
  x,
  check_degeneracy = TRUE,
  cp = .Machine$double.eps,
  maxdepth = 2L,
  ...
)

m_rpartD(y, X, check_degeneracy = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpartD_+3A_y">y</code></td>
<td>
<p>a <a href="survival.html#topic+Surv">Surv</a> object,
a <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
or a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>, the response <code class="reqn">y</code></p>
</td></tr>
<tr><td><code id="rpartD_+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a>, one predictor <code class="reqn">x</code></p>
</td></tr>
<tr><td><code id="rpartD_+3A_check_degeneracy">check_degeneracy</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar, whether to allow the
dichotomized value to be all-<code>FALSE</code> or all-<code>TRUE</code> (i.e., degenerate)
for any one of the predictors.
Default <code>TRUE</code> to produce a <a href="base.html#topic+warning">warning</a> message for degeneracy.</p>
</td></tr>
<tr><td><code id="rpartD_+3A_cp">cp</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar, complexity parameter, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.
Default <code>.Machine$double.eps</code>, so that a split is enforced
no matter how small improvement in overall <code class="reqn">R^2</code> is</p>
</td></tr>
<tr><td><code id="rpartD_+3A_maxdepth">maxdepth</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar, maximum depth of any node, see <a href="rpart.html#topic+rpart.control">rpart.control</a>.
Default <code>2L</code>, because only the first node is needed</p>
</td></tr>
<tr><td><code id="rpartD_+3A_...">...</code></td>
<td>
<p>additional parameters of <a href="rpart.html#topic+rpart">rpart</a> and/or <a href="rpart.html#topic+rpart.control">rpart.control</a></p>
</td></tr>
<tr><td><code id="rpartD_+3A_x">X</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+matrix">matrix</a>,
a set of predictors.
Each column of <code class="reqn">X</code> is one predictor.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Dichotomize Single Predictor</h4>

<p>Function <code><a href="#topic+rpartD">rpartD()</a></code> dichotomizes one predictor in the following steps,
</p>

<ol>
<li> <p>Recursive partitioning and regression tree <a href="rpart.html#topic+rpart">rpart</a> analysis is
performed for the response <code class="reqn">y</code> and the predictor <code class="reqn">x</code>.
</p>
</li>
<li> <p>The <a href="rpart.html#topic+labels.rpart">labels.rpart</a> of the first node of
the <a href="rpart.html#topic+rpart">rpart</a> tree
is considered as the dichotomizing rule of the <a href="base.html#topic+double">double</a> predictor <code class="reqn">x</code>.
The term <em>dichotomizing rule</em> indicates the combination of an inequality sign
(<a href="base.html#topic++3E">&gt;</a>, <a href="base.html#topic++3E+3D">&gt;=</a>, <a href="base.html#topic++3C">&lt;</a> and <a href="base.html#topic++3C+3D">&lt;=</a>)
and a <a href="base.html#topic+double">double</a> cutoff threshold <code class="reqn">a</code>
</p>
</li>
<li> <p>The dichotomizing rule from Step 2 is further processed, such that
</p>

<ul>
<li> <p><code class="reqn">&lt;a</code> is regarded as <code class="reqn">\geq a</code>
</p>
</li>
<li> <p><code class="reqn">\leq a</code> is regarded as <code class="reqn">&gt;a</code>
</p>
</li>
<li> <p><code class="reqn">&gt; a</code> and <code class="reqn">\geq a</code> are regarded as is.
</p>
</li></ul>

<p>This step is necessary for a narrative of
<em>greater than</em> or <em>greater than or equal to</em>
the threshold <code class="reqn">a</code>.
</p>
</li>
<li> <p>A <a href="base.html#topic+warning">warning</a> message is produced,
if the dichotomizing rule, applied to a new <a href="base.html#topic+double">double</a> predictor <code>newx</code>, creates
an all-<code>TRUE</code> or all-<code>FALSE</code> result.
We do not make the algorithm <a href="base.html#topic+stop">stop</a>,
as most regression models in R are capable of handling
an all-<code>TRUE</code> or all-<code>FALSE</code> predictor,
by returning a <code>NA_real_</code> regression coefficient estimate.

</p>
</li></ol>




<h4>Dichotomize Multiple Predictors</h4>

<p>Function <code><a href="#topic+m_rpartD">m_rpartD()</a></code> dichotomizes
each predictor <code>X[,i]</code> based on the response <code class="reqn">y</code>
using function <code><a href="#topic+rpartD">rpartD()</a></code>.
Applying the multiple dichotomizing rules to a new set of predictors <code>newX</code>,
</p>

<ul>
<li> <p>A <a href="base.html#topic+warning">warning</a> message is produced,
if at least one of the dichotomized predictors is all-<code>TRUE</code> or all-<code>FALSE</code>.
</p>
</li>
<li> <p>We do not check if more than one of the dichotomized predictors
are <a href="base.html#topic+identical">identical</a> to each other.
We take care of this situation in helper function <code><a href="#topic+coef_dichotom">coef_dichotom()</a></code>
</p>
</li></ul>




<h3>Value</h3>



<h4>Dichotomize Single Predictor</h4>

<p>Function <code><a href="#topic+rpartD">rpartD()</a></code> returns a <a href="base.html#topic+function">function</a>,
with a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a> parameter <code>newx</code>.
The returned value of <code>rpartD(y,x)(newx)</code> is a
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>
with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'cutoff')</code></dt><dd><p><a href="base.html#topic+double">double</a> scalar, the cutoff value for <code>newx</code></p>
</dd>
</dl>




<h4>Dichotomize Multiple Predictors</h4>

<p>Function <code><a href="#topic+m_rpartD">m_rpartD()</a></code> returns a <a href="base.html#topic+function">function</a>,
with a <a href="base.html#topic+double">double</a> <a href="base.html#topic+matrix">matrix</a> parameter <code>newX</code>.
The argument for <code>newX</code> must have
the same number of columns and the same column names as
the input <a href="base.html#topic+matrix">matrix</a> <code class="reqn">X</code>.
The returned value of <code>m_rpartD(y,X)(newX)</code> is a
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+matrix">matrix</a>
with <a href="base.html#topic+attributes">attributes</a>
</p>

<dl>
<dt><code>attr(,'cutoff')</code></dt><dd>
<p>named <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
the cutoff values for each predictor in <code>newX</code></p>
</dd>
</dl>




<h3>Note</h3>

<p>In future <a href="base.html#topic+integer">integer</a> and <a href="base.html#topic+factor">factor</a> predictors will be supported.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dichotomize Single Predictor
data(cu.summary, package = 'rpart') # see more details from ?rpart::cu.summary
with(cu.summary, rpartD(y = Price, x = Mileage, check_degeneracy = FALSE))
(foo = with(cu.summary, rpartD(y = Price, x = Mileage)))
foo(rnorm(10, mean = 24.5))

## Dichotomize Multiple Predictors
library(survival)
data(stagec, package = 'rpart') # see more details from ?rpart::stagec
nrow(stagec) # 146
(foo = with(stagec[1:100,], m_rpartD(y = Surv(pgtime, pgstat), X = cbind(age, g2, gleason))))
foo(as.matrix(stagec[-(1:100), c('age', 'g2', 'gleason')]))

</code></pre>

<hr>
<h2 id='rSplit'>Random Split Sampling with Stratification</h2><span id='topic+rSplit'></span>

<h3>Description</h3>

<p>Random split sampling, stratified based on the type of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSplit(y, nsplit, stratified = TRUE, trainFrac = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSplit_+3A_y">y</code></td>
<td>
<p>a <a href="base.html#topic+double">double</a> <a href="base.html#topic+vector">vector</a>,
a <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
a <a href="base.html#topic+factor">factor</a>,
or a <a href="survival.html#topic+Surv">Surv</a> object,
response <code class="reqn">y</code></p>
</td></tr>
<tr><td><code id="rSplit_+3A_nsplit">nsplit</code></td>
<td>
<p>positive <a href="base.html#topic+integer">integer</a> scalar,
<a href="base.html#topic+replicate">replicate</a>s of random splits to be performed</p>
</td></tr>
<tr><td><code id="rSplit_+3A_stratified">stratified</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar,
whether stratification based on response <code class="reqn">y</code> needs to be implemented, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rSplit_+3A_trainfrac">trainFrac</code></td>
<td>
<p><a href="base.html#topic+double">double</a> scalar between 0 and 1,
fraction of the training set, default <code>.8</code></p>
</td></tr>
<tr><td><code id="rSplit_+3A_...">...</code></td>
<td>
<p>additional parameters, currently not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="#topic+rSplit">rSplit()</a></code> performs random split sampling,
with or without stratification. Specifically,
</p>

<ul>
<li><p> If <code>stratified = FALSE</code>,
or if we have a <a href="base.html#topic+double">double</a> response <code class="reqn">y</code>,
then split the sample into a training and a test set by ratio <code>trainFrac</code>, without stratification.
</p>
</li>
<li><p> Otherwise, split a <a href="survival.html#topic+Surv">Surv</a> response <code class="reqn">y</code>, stratified by its censoring status.
Specifically,
split subjects with observed event into a training and a test set with training set fraction <code>trainFrac</code>,
and split the censored subjects into a training and a test set with training set fraction <code>trainFrac</code>.
Then combine the training sets from subjects with observed events and censored subjects,
and combine the test sets from subjects with observed events and censored subjects.
</p>
</li>
<li><p> Otherwise, split a <a href="base.html#topic+logical">logical</a> response <code class="reqn">y</code>, stratified by itself.
Specifically,
split the subjects with <code>TRUE</code> response into a training and a test set with training set fraction <code>trainFrac</code>,
and split the subjects with <code>FALSE</code> response into a training and a test set with training set fraction <code>trainFrac</code>.
Then combine the training sets, and the test sets, in a similar fashion as described above.
</p>
</li>
<li><p> Otherwise, split a <a href="base.html#topic+factor">factor</a> response <code class="reqn">y</code>, stratified by its <a href="base.html#topic+levels">levels</a>.
Specifically,
split the subjects in each level of <code class="reqn">y</code> into a training and a test set by ratio <code>trainFrac</code>.
Then combine the training sets, and the test sets, from all levels of <code class="reqn">y</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Function <code><a href="#topic+rSplit">rSplit()</a></code> returns a length-<code>nsplit</code> <a href="base.html#topic+list">list</a> of
<a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>s.
In each <a href="base.html#topic+logical">logical</a> <a href="base.html#topic+vector">vector</a>,
the <code>TRUE</code> elements indicate training subjects and
the <code>FALSE</code> elements indicate test subjects.
</p>


<h3>Note</h3>

<p><code>caTools::sample.split()</code> is not what we need.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+split">split</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rSplit(y = rep(c(TRUE, FALSE), times = c(20, 30)), nsplit = 3L)

</code></pre>

<hr>
<h2 id='show+2CFRindex-method'>Show <a href="#topic+FRindex-class">FRindex</a> Object</h2><span id='topic+show+2CFRindex-method'></span>

<h3>Description</h3>

<p>Show <a href="#topic+FRindex-class">FRindex</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'FRindex'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CFRindex-method_+3A_object">object</code></td>
<td>
<p>an <a href="#topic+FRindex-class">FRindex</a> object, returned from function <code><a href="#topic+FRindex">FRindex()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="base.html#topic+S4">S4</a> <a href="methods.html#topic+show">show</a> method of <a href="#topic+FRindex-class">FRindex</a> object returns a <a href="base.html#topic+data.frame">data.frame</a>.
This is the input <code>data</code> with the functional predictor values <code class="reqn">X</code> removed,
and the functional regression indices <code style="white-space: pre;">&#8288;@index&#8288;</code> appended.
</p>

<hr>
<h2 id='std_'>Alternative Standardization Methods</h2><span id='topic+std_'></span><span id='topic+std_IQR'></span><span id='topic+std_mad'></span>

<h3>Description</h3>

<p>Alternative standardize using <a href="stats.html#topic+median">median</a>, <a href="stats.html#topic+IQR">IQR</a> and <a href="stats.html#topic+mad">mad</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std_IQR(x, na.rm = TRUE, ...)

std_mad(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std__+3A_x">x</code></td>
<td>
<p><a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a></p>
</td></tr>
<tr><td><code id="std__+3A_na.rm">na.rm</code></td>
<td>
<p><a href="base.html#topic+logical">logical</a> scalar,
see <a href="stats.html#topic+quantile">quantile</a>, <a href="stats.html#topic+median">median</a> and <a href="stats.html#topic+mad">mad</a>.
Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="std__+3A_...">...</code></td>
<td>
<p>additional parameters of <a href="stats.html#topic+quantile">quantile</a> and/or <a href="stats.html#topic+mad">mad</a></p>
</td></tr>
</table>


<h3>Value</h3>



<h4>Standardize using <a href="stats.html#topic+median">median</a> and <a href="stats.html#topic+IQR">IQR</a></h4>

<p>Function <code><a href="#topic+std_IQR">std_IQR()</a></code> returns a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of the same length as <code>x</code>.
</p>



<h4>Standardize using <a href="stats.html#topic+median">median</a> and <a href="stats.html#topic+mad">mad</a></h4>

<p>Function <code><a href="#topic+std_mad">std_mad()</a></code> returns a <a href="base.html#topic+numeric">numeric</a> <a href="base.html#topic+vector">vector</a> of the same length as <code>x</code>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>std_IQR(rnorm(20))
std_mad(rnorm(20))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
