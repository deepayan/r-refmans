<!DOCTYPE html><html><head><title>Help for package centiserve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {centiserve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#centiserve-package'>
<p>Functions to find graph centrality indices</p></a></li>
<li><a href='#averagedis'><p>Find the average distance of a node</p></a></li>
<li><a href='#barycenter'><p>Find the barycenter centrality score</p></a></li>
<li><a href='#bottleneck'><p>Find the BottleNeck centrality score</p></a></li>
<li><a href='#centroid'><p>Find the centroid value of graph vertices</p></a></li>
<li><a href='#closeness.currentflow'><p>Find current-flow closeness centrality</p></a></li>
<li><a href='#closeness.freeman'><p>Find the closeness centrality in a strongly connected graph</p></a></li>
<li><a href='#closeness.latora'><p>Find the variant (Latora) closeness centrality in a disconnected graph</p></a></li>
<li><a href='#closeness.residual'><p>Find the residual closeness centrality</p></a></li>
<li><a href='#closeness.vitality'><p>Find the closeness vitality centrality in a strongly connected graph</p></a></li>
<li><a href='#clusterrank'><p>Find the ClusterRank ranks in a graph</p></a></li>
<li><a href='#communibet'><p>Find the communicability betweenness centrality</p></a></li>
<li><a href='#communitycent'><p>Find the community-based node centrality</p></a></li>
<li><a href='#crossclique'><p>Find the cross-clique connectivity (centrality)</p></a></li>
<li><a href='#decay'><p>Find the decay centrality of a given vertex</p></a></li>
<li><a href='#diffusion.degree'><p>Find the variant (Latora) closeness centrality in a disconnected graph</p></a></li>
<li><a href='#dmnc'><p>Find the density of maximum neighborhood component (DMNC) in a graph</p></a></li>
<li><a href='#entropy'><p>Find the entropy centrality in a graph</p></a></li>
<li><a href='#epc'><p>Find the edge percolated component (EPC) in a graph</p></a></li>
<li><a href='#geokpath'><p>Find the geodesic k-path centrality</p></a></li>
<li><a href='#hubbell'><p>Find the Hubbell centrality or the Hubbell Index</p></a></li>
<li><a href='#katzcent'><p>Find the Katz centrality (Katz Status Index)</p></a></li>
<li><a href='#laplacian'><p>Find the laplacian centrality</p></a></li>
<li><a href='#leaderrank'><p>Find the LeaderRank in a directed graph</p></a></li>
<li><a href='#leverage'><p>Find the leverage centrality</p></a></li>
<li><a href='#lincent'><p>Find the lin centrality in a graph</p></a></li>
<li><a href='#lobby'><p>Find the lobby index (centrality)</p></a></li>
<li><a href='#markovcent'><p>Find the markov centrality score</p></a></li>
<li><a href='#mnc'><p>Find the maximum neighborhood component (MNC)</p></a></li>
<li><a href='#pairwisedis'><p>Find the pairwise disconnectivity index</p></a></li>
<li><a href='#radiality'><p>Find the radiality centrality in a graph</p></a></li>
<li><a href='#salsa'><p>Find the SALSA as 'hub' or 'authority' score</p></a></li>
<li><a href='#semilocal'><p>Find the semi local centrality (or local centrality)</p></a></li>
<li><a href='#topocoefficient'><p>Find the topological coefficient of a node in a undirected graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Find Graph Centrality Indices</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph (&ge; 0.7.1), Matrix (&ge; 1.1-4)</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-07-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Mahdi Jalili &lt;m_jalili@farabi.tums.ac.ir&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mahdi Jalili &lt;m_jalili@farabi.tums.ac.ir&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates centrality indices additional to the 'igraph' package centrality functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>expm (&ge; 0.99-1.1), linkcomm (&ge; 1.0-11)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.centiserver.org/">http://www.centiserver.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://www.centiserver.org/?q1=contact">http://www.centiserver.org/?q1=contact</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-15 09:19:59 UTC; Mahdi</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-15 09:34:41 UTC</td>
</tr>
</table>
<hr>
<h2 id='centiserve-package'>
Functions to find graph centrality indices
</h2><span id='topic+centiserve-package'></span><span id='topic+centiserve'></span>

<h3>Description</h3>

<p>Find centrality indices (measures) additional to the igraph package centrality functions. The centiserve is a part of <a href="http://www.centiserver.org/">www.CentiServer.org</a> project which is a comprehensive centrality measures resource and a web based application for finding graph centrality measures.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> centiserve</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-12-30</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a><br />
Adapted algorithms and sources are referenced in function document.
</p>
<p>Maintainer:
Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Csardi G, Nepusz T: The igraph software package for complex network research, InterJournal, Complex Systems 1695. 2006. http://igraph.org
</p>
<p>Adapted algorithms and sources are referenced in function document.
</p>

<hr>
<h2 id='averagedis'>Find the average distance of a node</h2><span id='topic+averagedis'></span>

<h3>Description</h3>

<p>This function return average distance of a node in a strongly connected and loop free graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averagedis(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="averagedis_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="averagedis_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="averagedis_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="averagedis_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Average distance of node <code class="reqn">u</code> to the rest of nodes in the net defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{u}=\frac{\sum_{w\in V}dis(u,w)}{n-1}</code>
</p>

<p>It is invers of closeness centrality. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Average_Distance">Average Distance</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>del Rio, Gabriel, Dirk Koschutzki, and Gerardo Coello. &quot;How to identify essential genes from molecular networks?.&quot; BMC systems biology 3.1 (2009): 102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
averagedis(g)
</code></pre>

<hr>
<h2 id='barycenter'>Find the barycenter centrality score</h2><span id='topic+barycenter'></span>

<h3>Description</h3>

<p>Barycenter scores are calculated as 1 / (total distance from vertex v to all other vertices) in a strongly connected network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barycenter(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barycenter_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="barycenter_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="barycenter_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="barycenter_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 2 types of distance centrality scores, Closeness Centrality and Barycenter Centrality. <br />
Barycenter Centrality for vertex <code class="reqn">v</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">1 / (total distance from v to all other vertices)</code>
</p>

<p>Closeness scores are calculated using the formula <code class="reqn">1 / (average distance from vertex v to all other vertices)</code> and Barycenter scores are calculated as <code class="reqn">1 / (total distance from vertex v to all other vertices)</code>. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Barycenter_Centrality">Barycenter Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Viswanath, Meghana. Ontology-based automatic text summarization. Diss. University of Georgia, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
barycenter(g)
</code></pre>

<hr>
<h2 id='bottleneck'>Find the BottleNeck centrality score</h2><span id='topic+bottleneck'></span>

<h3>Description</h3>

<p>BottleNeck Centrality for vertex v defined as:
</p>
<p style="text-align: center;"><code class="reqn">BN(v) = \sum_{s\in v} P_{s}(v)</code>
</p>

<p>Let <code class="reqn">T_{s}</code> be a shortest path tree rooted at node <code class="reqn">s</code>.
<code class="reqn">P_{s}(v) = 1</code> if more than <code class="reqn">|V(T{s})|/4</code> paths from node <code class="reqn">s</code> to other nodes in <code class="reqn">T_{s}</code> meet at the vertex <code class="reqn">v</code>, otherwise <code class="reqn">P_{s}(v) = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottleneck(graph, vids = V(graph), mode = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bottleneck_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="bottleneck_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="bottleneck_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each node <code class="reqn">v</code> in the graph, construct a tree <code class="reqn">T_{v}</code> of shortest paths from that node to all other nodes in the graph. For a node <code class="reqn">v</code>, <code class="reqn">n_{v}</code> is the number of nodes that are directly or indirectly connected to node <code class="reqn">v</code> (i.e. the tree <code class="reqn">T_{v}</code> contains <code class="reqn">n_{v}</code> nodes). So extract all nodes <code class="reqn">w</code> on the above defined tree <code class="reqn">T_{v}</code> of shortest paths from node <code class="reqn">v</code>, such that more than <code class="reqn">n_{v}/4</code> paths from <code class="reqn">v</code> to other nodes in the tree meet at node <code class="reqn">w</code>. Nodes <code class="reqn">w</code> extracted in this way represent 'bottle necks' of the shortest path tree <code class="reqn">T_{v}</code> rooted at node <code class="reqn">v</code>, since at least <code class="reqn">n_{v}/4</code> paths of the <code class="reqn">n_{v}-node</code> tree <code class="reqn">T_{v}</code> 'meet' at <code class="reqn">w</code>. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=BottleNeck">BottleNeck</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Przulj, N., Dennis A. Wigle, and Igor Jurisica. &quot;Functional topology in a network of protein interactions.&quot; Bioinformatics 20.3 (2004): 340-348.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
bottleneck(g)
</code></pre>

<hr>
<h2 id='centroid'>Find the centroid value of graph vertices</h2><span id='topic+centroid'></span>

<h3>Description</h3>

<p>Centroid value C_cen(v) for node v defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{cen}(v) : = min{f(v, w) : w \in V{v}}</code>
</p>

<p>where <code class="reqn">f(v, w) : = \gamma_{v}(w) - \gamma_{w}(v)</code>, and <code class="reqn">\gamma_{v}(w)</code> is the number of vertex closer to <code class="reqn">v</code> than to <code class="reqn">w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="centroid_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="centroid_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="centroid_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centroid value computed by focusing the calculus on couples of nodes <code class="reqn">(v,w)</code> and systematically counting the nodes that are closer (in term of shortest path) to <code class="reqn">v</code> or to <code class="reqn">w</code>. The calculus proceeds by comparing the node distance from other nodes with the distance of all other nodes from the others, such that a high centroid value indicates that a node <code class="reqn">v</code> is much closer to other nodes. Thus, the centroid value provides a centrality index always weighted with the values of all other nodes in the graph. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Centroid_value">Centroid value</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Algorithm adapted from CentiLib (Grabler, Johannes, 2012).
</p>


<h3>References</h3>

<p>Scardoni, Giovanni, Michele Petterlini, and Carlo Laudanna. &quot;Analyzing biological network parameters with CentiScaPe.&quot; Bioinformatics 25.21 (2009): 2857-2859.
</p>
<p>Grabler, Johannes, Dirk Koschutzki, and Falk Schreiber. &quot;CentiLib: comprehensive analysis and exploration of network centralities.&quot; Bioinformatics 28.8 (2012): 1178-1179.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
centroid(g)
</code></pre>

<hr>
<h2 id='closeness.currentflow'>Find current-flow closeness centrality</h2><span id='topic+closeness.currentflow'></span>

<h3>Description</h3>

<p>Current-flow closeness centrality is defined by:
</p>
<p style="text-align: center;"><code class="reqn">C_{cc}(s)=\frac{n-1}{\sum_{s\neq t}p_{st}(s)-p_{st}(t)} for all: s \in V</code>
</p>

<p>where <code class="reqn">(n-1)</code> is a normalizing factor, <code class="reqn">p_{st}(s)</code> is the absolute electrical potential of vertex s based on the electrical current supply from vertex <code class="reqn">s</code> to vertex <code class="reqn">t</code>, and <code class="reqn">p_{st}(s) - p_{st}(t)</code> corresponds to the effective resistance typically measured as voltage, which can be interpreted as an alternative measure of distance between <code class="reqn">s</code> and <code class="reqn">t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeness.currentflow(graph, vids = V(graph), weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness.currentflow_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="closeness.currentflow_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="closeness.currentflow_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The closeness index based on shortest paths can also be transformed to a measure based on electrical current. For the electrical current model set, Brandes et al. developed an alternative measure of the distance between two vertices <code class="reqn">s</code> and <code class="reqn">t</code>, which is defined as the difference of their electrical potentials. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Current-Flow_Closeness_Centrality">Current-Flow Closeness Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Note: This implementation is based on Daniel Fleischer's implementation for yFiles and JMP which convert to java implementation for CentiLib by Johannes Graessler and Dirk Koschuetzki.
</p>


<h3>References</h3>

<p>Brandes, Ulrik, and Daniel Fleischer. Centrality measures based on current flow. Springer Berlin Heidelberg, 2005.
</p>
<p>Grabler, Johannes, Dirk Koschutzki, and Falk Schreiber. &quot;CentiLib: comprehensive analysis and exploration of network centralities.&quot; Bioinformatics 28.8 (2012): 1178-1179.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
closeness.currentflow(g)
</code></pre>

<hr>
<h2 id='closeness.freeman'>Find the closeness centrality in a strongly connected graph</h2><span id='topic+closeness.freeman'></span>

<h3>Description</h3>

<p>Freeman closeness centrality defined as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\sum_{i\neq v}d(v,i)}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>closeness.freeman(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL, normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness.freeman_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="closeness.freeman_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="closeness.freeman_+3A_mode">mode</code></td>
<td>
<p>Character string, defined the types of the paths used for measuring the distance in directed graphs. 'in' measures the paths to a vertex, 'out' measures paths from a vertex, all uses undirected paths. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="closeness.freeman_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
<tr><td><code id="closeness.freeman_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to calculate the normalized score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because closeness is infinite if there is no path between two vertex so freeman closeness require a strongly connected graph. In igraph if there is no (directed) path between vertex <code class="reqn">v</code> and <code class="reqn">i</code> then the total number of vertices is used in the formula instead of the path length. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Closeness_Centrality">Closeness Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Use igraph package closeness function.
</p>


<h3>References</h3>

<p>Freeman, Linton C. &quot;Centrality in social networks conceptual clarification.&quot; Social networks 1.3 (1979): 215-239.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
closeness.freeman(g)
</code></pre>

<hr>
<h2 id='closeness.latora'>Find the variant (Latora) closeness centrality in a disconnected graph</h2><span id='topic+closeness.latora'></span>

<h3>Description</h3>

<p>Variant (Latora) closeness centrality defined as:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i \neq v}\frac{1}{d(v,i)}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>closeness.latora(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL, normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness.latora_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="closeness.latora_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="closeness.latora_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="closeness.latora_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
<tr><td><code id="closeness.latora_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to calculate the normalized score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This variant (sum of inversed distances to all other nodes instead of the inversed of the sum of distances to all other nodes) applicable to both connected and unconnected graphs. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Closeness_Centrality">Closeness Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Latora V., Marchiori M., Efficient behavior of small-world networks, Physical Review Letters, V. 87, p. 19, 2001.
</p>
<p>Opsahl, Tore, Filip Agneessens, and John Skvoretz. &quot;Node centrality in weighted networks: Generalizing degree and shortest paths.&quot; Social Networks 32.3 (2010): 245-251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
closeness.latora(g)
</code></pre>

<hr>
<h2 id='closeness.residual'>Find the residual closeness centrality</h2><span id='topic+closeness.residual'></span>

<h3>Description</h3>

<p>Residual closeness centrality defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{i}=\sum_{j\neq i}\frac{1}{2^{d(i,j)}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>closeness.residual(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness.residual_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="closeness.residual_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="closeness.residual_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="closeness.residual_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculate closeness of a vertex as Dangalchev defination. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Residual_Closeness_Centrality">Residual Closeness Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Dangalchev, Chavdar. &quot;Residual closeness in networks.&quot; Physica A: Statistical Mechanics and its Applications 365.2 (2006): 556-564.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
closeness.residual(g)
</code></pre>

<hr>
<h2 id='closeness.vitality'>Find the closeness vitality centrality in a strongly connected graph</h2><span id='topic+closeness.vitality'></span>

<h3>Description</h3>

<p>Closeness vitality of a node is the change in the sum of distances between all node pairs when excluding that node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeness.vitality(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness.vitality_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="closeness.vitality_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="closeness.vitality_+3A_mode">mode</code></td>
<td>
<p>Character string, defined the types of the paths used for measuring the distance in directed graphs. 'in' measures the paths to a vertex, 'out' measures paths from a vertex, all uses undirected paths. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="closeness.vitality_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Closeness_Vitality">Closeness Vitality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Brandes, U. &amp; Erlebach, T. 2005. Network Analysis: Methodological Foundations, U.S. Government Printing Office.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2,1,4), directed=FALSE)
closeness.vitality(g)
</code></pre>

<hr>
<h2 id='clusterrank'>Find the ClusterRank ranks in a graph</h2><span id='topic+clusterrank'></span>

<h3>Description</h3>

<p>Mathematically, the ClusterRank score <code class="reqn">s_{i}</code> of node <code class="reqn">i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">s_{i} = f(c_{i})\sum_{j\in \tau _{i}}(k_{out}^{j}+1)</code>
</p>

<p>where the term f(c_i) accounts for the effect of i's local clustering and the term '+1' results from the contribution of <code class="reqn">j</code> itself. <br />
Here <code class="reqn">f(c_{i}) = 10^{-c_{i}}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterrank(graph, vids = V(graph), directed = TRUE, loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterrank_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="clusterrank_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="clusterrank_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to directed graph is analyzed. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="clusterrank_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ClusterRank is a local ranking algorithm which takes into account not only the number of neighbors and the neighbors' influences, but also the clustering coefficient. <br />
ClusterRank can also be applied to undirected networks where the superiority of ClusterRank is significant compared with degree centrality and k-core decomposition. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=ClusterRank">ClusterRank</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Chen, Duan-Bing, et al. &quot;Identifying influential nodes in large-scale directed networks: the role of clustering.&quot; PloS one 8.10 (2013): e77455.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2,2,5,5,3,4,1,4,3,1,6,6,3,3,6,2,6,5,6))
clusterrank(g)
</code></pre>

<hr>
<h2 id='communibet'>Find the communicability betweenness centrality</h2><span id='topic+communibet'></span>

<h3>Description</h3>

<p>The communicability betweenness of a node r is:
</p>
<p style="text-align: center;"><code class="reqn">\omega_{r} = \frac{1}{C} \sum_{p}\sum_{q}\frac{G_{prq}}{G_{pq}}, p\neq q,p\neq r, q\neq r</code>
</p>

<p>where where <code class="reqn">G_{prq} = (e^{A})_{pq} - (e^{A+E(r)})_{pq}</code> is the number of walks involving node <code class="reqn">r</code>, <code class="reqn">G_{pq} = (e^{A})_{pq}</code> is the number of closed walks starting at node p and ending at node <code class="reqn">q</code>, and <code class="reqn">C = (n-1)^{2}-(n-1)</code> is a normalization factor equal to the number of terms in the sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communibet(graph, vids = V(graph), normalized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communibet_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="communibet_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="communibet_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to calculate the normalized score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Communicability betweenness measure makes use of the number of walks connecting every pair of nodes as the basis of a betweenness centrality measure. <br />
The resulting <code class="reqn">\omega_{r}</code> takes values between zero and one. The lower bound cannot be attained for a connected graph, and the upper bound is attained in the star graph. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Communicability_Betweenness_Centrality">Communicability Betweenness Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Algorithm adapted from NetworkX 1.9 (Hagberg, A. 2008).
</p>


<h3>References</h3>

<p>Estrada, Ernesto, Desmond J. Higham, and Naomichi Hatano. &quot;Communicability betweenness in complex networks.&quot; Physica A: Statistical Mechanics and its Applications 388.5 (2009): 764-774.
</p>
<p>Hagberg, Aric, Pieter Swart, and Daniel S Chult. Exploring network structure, dynamics, and function using NetworkX. No. LA-UR-08-05495; LA-UR-08-5495. Los Alamos National Laboratory (LANL), 2008.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- graph(c(1,2,2,3,2,6,6,5,3,5,3,4,5,4,4,7), directed=FALSE)
communibet(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='communitycent'>Find the community-based node centrality</h2><span id='topic+communitycent'></span>

<h3>Description</h3>

<p>This function returns community-based node centrality measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communitycent(graph, vids = V(graph), type = c("commweight", "commconn"),
  normalise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communitycent_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="communitycent_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="communitycent_+3A_type">type</code></td>
<td>
<p>A character string naming the community centrality measure. Can be one of &quot;commweight&quot; or &quot;commconn&quot;</p>
</td></tr>
<tr><td><code id="communitycent_+3A_normalise">normalise</code></td>
<td>
<p>Logical, whether to normalise community connectedness for &quot;commconn&quot;. Defaults to TRUE. Will be ignored for &quot;commweight&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;commweight&quot; type weights each community that a node belongs to by how similar that community is to each of the other communities to which the node also belongs.
For node <code class="reqn">i</code> the community centrality is:
</p>
<p style="text-align: center;"><code class="reqn">C_{c}(i)=\sum_{i \in j}^{N}(1 - \frac{1}{m}\sum_{i \in j\cap k}^{m}S(j,k))</code>
</p>

<p>where the main sum is over the N communities to which node <code class="reqn">i</code> belongs, and <code class="reqn">S(j,k)</code> refers to the similarity between community <code class="reqn">j</code> and <code class="reqn">k</code>, calculated as the Jaccard coefficient for the number of shared nodes between each community pair, and this is averaged over the <code class="reqn">m</code> communities paired with community <code class="reqn">j</code> and in which node <code class="reqn">i</code> jointly belongs. <br />
The &quot;commconn&quot; type weights each community that a node belongs to by how many connections the community forms outside of itself relative to how many connections the community has within itself (the inverse of modularity), so that nodes that belong to more highly connecting communitites will receive a higher community centrality score. For node i the community centrality is:
</p>
<p style="text-align: center;"><code class="reqn">C_{c}(i)=\sum_{i \in j}^{N}e_{ij} \frac{\check{e}_{B(j)}}{\check{e}_{W(j)}}</code>
</p>

<p>where <code class="reqn">e_{ij}</code> is the number of edges node <code class="reqn">i</code> has in community <code class="reqn">j</code>, <code class="reqn">\check{e}_{B(j)}=\frac{e_{B(j)}}{n_{j}\bar{d}}</code> is the number of edges community <code class="reqn">j</code> makes outside of itself normalised by the number of nodes in community <code class="reqn">j</code> multiplied by the average degree in the network, and <code class="reqn">\check{e}_{W(j)}=\frac{e_{W(j)}}{n(n-1)/2}</code> is the number of edges within community <code class="reqn">j</code> normalised by the total number possible. <br />
For more detail see 'linkcomm' package and <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Community_Centrality">Community Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Code obtained from 'linkcomm' package.
</p>


<h3>References</h3>

<p>Kalinka, Alex T., and Pavel Tomancak. &quot;linkcomm: an R package for the generation, visualization, and analysis of link communities in networks of arbitrary size and type.&quot; Bioinformatics 27.14 (2011).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g &lt;- random.graph.game(20, 3/10)
communitycent(g)

## End(Not run)
</code></pre>

<hr>
<h2 id='crossclique'>Find the cross-clique connectivity (centrality)</h2><span id='topic+crossclique'></span>

<h3>Description</h3>

<p>The cross-clique connectivity <code class="reqn">X(v)</code> of a node is the number of cliques to which belongs. A node with a high <code class="reqn">X(v)</code> value is called a highly cross-connected node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossclique(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossclique_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="crossclique_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: Directed graph considered as undirected ones and multiple edges and loops are ignored. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Cross-Clique_Connectivity">Cross-Clique Connectivity</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Faghani, M., and U. Nguyen. &quot;A Study of XSS Worm Propagation and Detection Mechanisms in Online Social Networks.&quot; (2013): 1-1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
crossclique(g)
</code></pre>

<hr>
<h2 id='decay'>Find the decay centrality of a given vertex</h2><span id='topic+decay'></span>

<h3>Description</h3>

<p>Decay centrality of a given vertex <code class="reqn">x</code> of a graph G is define as:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{y \in V(G)}\sigma ^{d(x,y)}</code>
</p>

<p>where <code class="reqn">d(x,y)</code> denotes the distance between <code class="reqn">x</code> and <code class="reqn">y</code> and <code class="reqn">\sigma \in (0,1)</code> is a parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL, decay = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="decay_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="decay_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="decay_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
<tr><td><code id="decay_+3A_decay">decay</code></td>
<td>
<p>A decay parameter which the default is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decay centrality is a centrality measure based on the proximity between a choosen vertex and every other vertex weighted by the decay. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Decay_Centrality">Decay Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Jana Hurajova, Silvia Gago and Tomas Madaras, Decay Centrality, 15th Conference of Kosice Mathematicians. Herl'ny 2.-5. aprila 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
decay(g)
</code></pre>

<hr>
<h2 id='diffusion.degree'>Find the variant (Latora) closeness centrality in a disconnected graph</h2><span id='topic+diffusion.degree'></span>

<h3>Description</h3>

<p>The diffusion degree of a node is defined as the cumulative contribution score of the node itself and its neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffusion.degree(graph, vids = V(graph), mode = c("all", "out", "in"),
  loops = TRUE, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffusion.degree_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="diffusion.degree_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="diffusion.degree_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="diffusion.degree_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="diffusion.degree_+3A_lambda">lambda</code></td>
<td>
<p>Possibly a numeric vector giving propagation probability of vertices. The default is 1 for all vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Diffusion degree <code class="reqn">C_{DD}</code> of node <code class="reqn">v</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{DD}(v)=\lambda _{v} * C_{D}(v)+\sum_{i\in neighbors(v)}\lambda _{i} * C_{D}(i)</code>
</p>

<p>where <code class="reqn">C_{D}</code> is degree of of vertex and <code class="reqn">\lambda</code> is propagation probability of vertex. <br />
In a diffusion process, a node <code class="reqn">v</code> with propagation probability <code class="reqn">\lambda _{v}</code>, can activate its neighbor <code class="reqn">u</code> with probability <code class="reqn">\lambda _{v}</code>. <br />
When the diffusion process propagates to the next level, active neighbors of <code class="reqn">v</code> will try to activate their inactive neighbors. Thus the cumulative contribution in the diffusion process by neighbors of <code class="reqn">v</code> will be maximized when all of its neighbors will be activated in the previous step. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Diffusion_Degree">Diffusion Degree</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Pal, Sankar K., Suman Kundu, and C. A. Murthy. &quot;Centrality Measures, Upper Bound, and Influence Maximization in Large Scale Directed Social Networks.&quot; Fundamenta Informaticae 130.3 (2014): 317-342.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
diffusion.degree(g)
</code></pre>

<hr>
<h2 id='dmnc'>Find the density of maximum neighborhood component (DMNC) in a graph</h2><span id='topic+dmnc'></span>

<h3>Description</h3>

<p>The score of node <code class="reqn">v</code>, <code class="reqn">DMNC(v)</code>, is defined to be <code class="reqn">\frac{E}{N^{\epsilon}}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\left|E(MNC(v))\right|}{\left|V(MNC(v))\right|^{\epsilon}}</code>
</p>

<p>where for some <code class="reqn">1 \leq \epsilon \leq 2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnc(graph, vids = V(graph), mode = c("all", "out", "in"), epsilon = 1.67)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmnc_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="dmnc_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="dmnc_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="dmnc_+3A_epsilon">epsilon</code></td>
<td>
<p><code class="reqn">\epsilon</code> parameter which default is 1.67.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Maximum Neighborhood Component (MNC) <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=DMNC-Density_of_Maximum_Neighborhood_Component">DMNC-Density of Maximum Neighborhood Component</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Lin, Chung-Yen, et al. &quot;Hubba: hub objects analyzer-a framework of interactome hubs identification for network biology.&quot; Nucleic acids research 36.suppl 2 (2008): W438-W443.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- random.graph.game(20, 3/10)
dmnc(g)
</code></pre>

<hr>
<h2 id='entropy'>Find the entropy centrality in a graph</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>Entropy centrality measures centrality of nodes depending on their contribution to the entropy of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="entropy_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="entropy_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="entropy_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centrality entropy measures <code class="reqn">H_{ce}</code> of a graph G, defined as:
</p>
<p style="text-align: center;"><code class="reqn">H_{ce}(G)=-\sum_{i=1}^{n}\gamma(v_{i})\times log_{2}\gamma(v_{i})</code>
</p>

<p>where  <code class="reqn">\gamma(v_{i})=\frac{paths(v_{i})}{paths(v_{1}, v_{2}, ..., v_{M})}</code> where <code class="reqn">paths(v_{i})</code> is the number of geodesic paths from node <code class="reqn">v_{i}</code> to all the other nodes in the graph and <code class="reqn">paths(v_{1}, v_{2}, ..., v_{M})</code> is the total number of geodesic paths M that exists across all the nodes in the graph. <br />
The centrality entropy provides information on the degree of centrality for a node in the graph. Those nodes that will split the graph in two or that will reduce substantially the number of paths available to reach other nodes when removed, will have a higher impact in decreasing the total centrality entropy of a graph. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Entropy_Centrality">Entropy Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Ortiz-Arroyo, Daniel, and DM Akbar Hussain. &quot;An information theory approach to identify sets of key players.&quot; Intelligence and Security Informatics. Springer Berlin Heidelberg, 2008. 15-26.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- erdos.renyi.game(10, 1/10)
entropy(g)
</code></pre>

<hr>
<h2 id='epc'>Find the edge percolated component (EPC) in a graph</h2><span id='topic+epc'></span>

<h3>Description</h3>

<p>For a node <code class="reqn">v</code> in G, <code class="reqn">EPC(v)</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">EPC(v)=\frac{1}{\left|v\right|}\sum_{k=1}^{1000}\sum_{t\in e}\delta_{vt}^{k}</code>
</p>

<p>Given a threshold <code class="reqn">(0 \leq the threshold \leq 1)</code>, we create 1000 reduced network by asigning a random number between 0 and 1 to every edge and remove edges if their associated random numbers are less than the threshold. <br />
Let the <code class="reqn">G_{k}</code> be the reduced network generated at the <code class="reqn">k_{th}</code> time reduced process. If nodes <code class="reqn">u</code> and <code class="reqn">v</code> are connected in <code class="reqn">G_{k}</code>, set <code class="reqn">\delta_{vt}^{k}</code> to 1; otherwise <code class="reqn">\delta_{vt}^{k}=0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epc(graph, vids = V(graph), threshold = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epc_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="epc_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="epc_+3A_threshold">threshold</code></td>
<td>
<p>The threshold parameter, for filter graph and create reduced one, which must be between 0 and 1. The default is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an interaction network G, assign a removing probability p to every edge. Let G'be a realization of the random edge removing from G. If nodes <code class="reqn">v</code> and <code class="reqn">w</code> are connected in G', set <code class="reqn">d_{vw}</code> be 1, otherwise set <code class="reqn">d_{vw}</code> be 0. The percolated connectivity of <code class="reqn">v</code> and <code class="reqn">w</code>, <code class="reqn">c_{vw}</code>, is defined to be the average of <code class="reqn">d_{vw}</code> over realizations. The size of percolated component containing node <code class="reqn">v</code>, <code class="reqn">s_{v}</code>, is defined to be the sum of <code class="reqn">c_{vw}</code> over nodes <code class="reqn">w</code>. The score of node <code class="reqn">v</code>, <code class="reqn">EPC(v)</code>, is defined to be <code class="reqn">s_{v}</code>. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=EPC-Edge_Percolated_Component">EPC-Edge Percolated Component</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Lin, Chung-Yen, et al. &quot;Hubba: hub objects analyzer-a framework of interactome hubs identification for network biology.&quot; Nucleic acids research 36.suppl 2 (2008): W438-W443.
</p>
<p>Chen, Shu-Hwa, et al. &quot;cyto-Hubba: A Cytoscape plug-in for hub object analysis in network biology.&quot; 20th International Conference on Genome Informatics. 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
epc(g)
</code></pre>

<hr>
<h2 id='geokpath'>Find the geodesic k-path centrality</h2><span id='topic+geokpath'></span>

<h3>Description</h3>

<p>Geodesic K-path centrality counts neighbours as those that are on a geodesic path less than &quot;k&quot; away.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geokpath(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL, k = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geokpath_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="geokpath_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="geokpath_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="geokpath_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
<tr><td><code id="geokpath_+3A_k">k</code></td>
<td>
<p>The k parameter. The default is 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Geodesic_K-Path_Centrality">Geodesic K-Path Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Borgatti, Stephen P., and Martin G. Everett. &quot;A graph-theoretic perspective on centrality.&quot; Social networks 28.4 (2006): 466-484.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- barabasi.game(100)
geokpath(g)
</code></pre>

<hr>
<h2 id='hubbell'>Find the Hubbell centrality or the Hubbell Index</h2><span id='topic+hubbell'></span>

<h3>Description</h3>

<p>Hubbell centrality defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{h} = E + WC_{h}</code>
</p>

<p>where <code class="reqn">E</code> is some exogeneous input and <code class="reqn">W</code> is a weight matrix derived from the adjancancy matrix <code class="reqn">A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hubbell(graph, vids = V(graph), weights = NULL, weightfactor = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hubbell_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="hubbell_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="hubbell_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
<tr><td><code id="hubbell_+3A_weightfactor">weightfactor</code></td>
<td>
<p>The weight factorLogical which must be greater than 0. The defualt is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This centrality value is defined by means of a weighted and loop allowed network. The weighted adjacency matrix <code class="reqn">W</code> of a network G is asymmetric and contains real-valued weights for each edge. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Hubbell_Index">Hubbell Index</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Algorithm adapted from CentiLib (Grabler, Johannes, 2012).
</p>


<h3>References</h3>

<p>Hubbell, Charles H. &quot;An input-output approach to clique identification.&quot; Sociometry (1965): 377-399.
</p>
<p>Grabler, Johannes, Dirk Koschutzki, and Falk Schreiber. &quot;CentiLib: comprehensive analysis and exploration of network centralities.&quot; Bioinformatics 28.8 (2012): 1178-1179.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- barabasi.game(100)
hubbell(g)
</code></pre>

<hr>
<h2 id='katzcent'>Find the Katz centrality (Katz Status Index)</h2><span id='topic+katzcent'></span>

<h3>Description</h3>

<p>The Katz centrality for node i is:
</p>
<p style="text-align: center;"><code class="reqn">x_{i}=\alpha \sum_{j}A_{ij}x_{j}+\beta</code>
</p>

<p>where <code class="reqn">A</code> is the adjacency matrix of the graph G with eigenvalues <code class="reqn">\lambda</code>. The parameter <code class="reqn">\beta</code> controls the initial centrality and <code class="reqn">\alpha &lt; \frac{1}{\lambda_{max}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>katzcent(graph, vids = V(graph), alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="katzcent_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="katzcent_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="katzcent_+3A_alpha">alpha</code></td>
<td>
<p>The alpha parameter, which must be between 0.0-0.2. The default is 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Katz centrality computes the relative influence of a node within a network by measuring the number of the immediate neighbors (first degree nodes) and also all other nodes in the network that connect to the node under consideration through these immediate neighbors. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Katz_Centrality">Katz Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Algorithm adapted from CentiBin with thanks Dirk Koschutzki. (Junker, Bjorn H. 2006).
</p>


<h3>References</h3>

<p>Newman, Mark. Networks: an introduction. Oxford University Press, 2010.
</p>
<p>Junker, Bjorn H., Dirk Koschutzki, and Falk Schreiber. &quot;Exploration of biological network centralities with CentiBiN.&quot; BMC bioinformatics 7.1 (2006): 219.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- barabasi.game(20)
katzcent(g)
</code></pre>

<hr>
<h2 id='laplacian'>Find the laplacian centrality</h2><span id='topic+laplacian'></span>

<h3>Description</h3>

<p>The Laplacian centrality with respect to v is:
</p>
<p style="text-align: center;"><code class="reqn">C_{v}^{L}=(\Delta E)_{v}=d_{G}^{2}(v)+d_{G}(v)+2\sum_{v_{i}\in N(v)}d_{G}(v_{i})</code>
</p>

<p>where G is a graph of <code class="reqn">n</code> vertices, <code class="reqn">N(v)</code> is the set of neighbors of <code class="reqn">v</code> in G and <code class="reqn">d_{G}(v_{i})</code> is the degree of <code class="reqn">v_{i}</code> in G.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian(graph, vids = V(graph), mode = c("all", "out", "in"),
  loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacian_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="laplacian_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="laplacian_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Laplacian centrality is a simple centrality measure that can be calculated in linear time. It is defined as the drop in the Laplacian energy (i.e. sum of squares of the eigenvalues in the Laplacian matrix) of the graph when the vertex is removed. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Laplacian_Centrality">Laplacian Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Qi, Xingqin, et al. &quot;Laplacian centrality: A new centrality measure for weighted networks.&quot; Information Sciences 194 (2012): 240-253.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
laplacian(g)
</code></pre>

<hr>
<h2 id='leaderrank'>Find the LeaderRank in a directed graph</h2><span id='topic+leaderrank'></span>

<h3>Description</h3>

<p>This function find the LeaderRank in a directed graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaderrank(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaderrank_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="leaderrank_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a network consisting of N nodes and M directed links, a ground node connected with every node by a bidirectional link is added. Then, the network becomes strongly connected and consists of N+1 nodes and M+2N links (a bidirectional link is counted as two links with inverse directions). LeaderRank directly applies the standard random walk process to determine the score of every node. Accordingly, if the score of node <code class="reqn">i</code> at time step <code class="reqn">t</code> is <code class="reqn">si(t)</code>, the dynamics can be described by an iterative process as:
</p>
<p style="text-align: center;"><code class="reqn">s_{i}(t+1)=\sum_{j=1}^{N+1}\frac{a_{ji}}{k_{j}^{out}}s_{j}(t)</code>
</p>

<p>where <code class="reqn">a_{ji}</code> is the element of the corresponding (N + 1)-dimensional adjacency matrix, which equals 1 if there is a directed link from <code class="reqn">j</code> to <code class="reqn">i</code> and 0 otherwise, and <code class="reqn">k_{j}^{out}</code> is the out-degree of node <code class="reqn">j</code>. The process starts with the initialization where all node scores are 1 and will soon converge to a unique steady state denoted as <code class="reqn">s_{i}^{\infty}, (i = 1, 2, ..., N, N+1)</code>. LeaderRank ranks all nodes according to <code class="reqn">s_{i}^{\infty}</code>, and the nodes with larger final scores are considered to be more influential in spreading. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=LeaderRank">LeaderRank</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Lu, Linyuan, et al. &quot;Leaders in social networks, the delicious case.&quot; PloS one 6.6 (2011): e21202.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
leaderrank(g)
</code></pre>

<hr>
<h2 id='leverage'>Find the leverage centrality</h2><span id='topic+leverage'></span>

<h3>Description</h3>

<p>Leverage centrality considers the degree of a node relative to its neighbors and operates under the principle that a node in a network is central if its immediate neighbors rely on that node for information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leverage(graph, vids = V(graph), mode = c("all", "out", "in"),
  loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leverage_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="leverage_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="leverage_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="leverage_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leverage centrality of vertex <code class="reqn">i</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">l_{i}=\frac{1}{k_{i}}\sum_{N_{i}}\frac{k_{i}-k_{j}}{k_{i}+k_{j}}</code>
</p>

<p>where <code class="reqn">k_{i}</code> is degree of a given node <code class="reqn">i</code>, <code class="reqn">k_{j}</code> is degree of each of its neighbors and <code class="reqn">N_{i}</code> is all neighbors. <br />
A node with negative leverage centrality is influenced by its neighbors, as the neighbors connect and interact with far more nodes. A node with positive leverage centrality, on the other hand, influences its neighbors since the neighbors tend to have far fewer connections. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Leverage_Centrality">Leverage Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Joyce, Karen E., et al. &quot;A new measure of centrality for brain networks.&quot; PLoS One 5.8 (2010): e12200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
leverage(g)
</code></pre>

<hr>
<h2 id='lincent'>Find the lin centrality in a graph</h2><span id='topic+lincent'></span>

<h3>Description</h3>

<p>Lin centrality of a node <code class="reqn">x</code> with a nonempty coreachable set is:
</p>
<p style="text-align: center;"><code class="reqn">\frac{\left|\left\{y|d(x,y)&lt;\infty \right\}\right|^2}{\sum_{d(x,y)&lt;\infty}d(x,y)}</code>
</p>

<p>where
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lincent(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lincent_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="lincent_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="lincent_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="lincent_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lin centrality consider closeness not the inverse of a sum of distances, but rather the inverse of the average distance, which entails a first multiplication by the number of coreachable nodes. This change normalizes closeness across the graph. Now, however, we want nodes with a larger coreachable set to be more important, given that the average distance is the same, so we multiply again by the number of coreachable nodes. Nodes with an empty coreachable set have centrality 1 by definition. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Lin_Centrality">Lin Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Lin, Nan. Foundations of social research. New York: McGraw-Hill, 1976.
</p>
<p>Boldi, Paolo, and Sebastiano Vigna. &quot;Axioms for centrality.&quot; Internet Mathematics just-accepted (2014): 00-00.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
lincent(g)
</code></pre>

<hr>
<h2 id='lobby'>Find the lobby index (centrality)</h2><span id='topic+lobby'></span>

<h3>Description</h3>

<p>The l-index or lobby index of a node <code class="reqn">x</code> is the largest integer <code class="reqn">k</code> such that <code class="reqn">x</code> has at least <code class="reqn">k</code> neighbors with a degree of at least <code class="reqn">k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lobby(graph, vids = V(graph), mode = c("all", "out", "in"), loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lobby_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="lobby_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="lobby_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="lobby_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Lobby_Index">Lobby Index</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Korn, A., A. Schubert, and A. Telcs. &quot;Lobby index in networks.&quot; Physica A: Statistical Mechanics and its Applications 388.11 (2009): 2221-2226.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- random.graph.game(20, 3/10)
lobby(g)
</code></pre>

<hr>
<h2 id='markovcent'>Find the markov centrality score</h2><span id='topic+markovcent'></span>

<h3>Description</h3>

<p>The Markov centrality score uses the concept of a random walk through the graph to calculate the centrality of each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markovcent(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markovcent_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="markovcent_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the markov centrality values are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method uses the mean first-passage time from every vertex to every other vertex to produce a score for each vertex. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Markov_Centrality">Markov Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>
<p>Original code from Bioconductor SANTA package (Cornish AJ, 2014)
</p>


<h3>References</h3>

<p>White, S. &amp; Smyth, P. Algorithms for estimating relative importance in networks. Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining, 2003. ACM, 266-275.
</p>
<p>Cornish AJ and Markowetz F (2014). &quot;SANTA: Quantifying the Functional Content of Molecular Networks.&quot; PLOS Computational Biology, 10(9), pp. e1003808. http://dx.doi.org/10.1371/journal.pcbi.1003808.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
markovcent(g)
</code></pre>

<hr>
<h2 id='mnc'>Find the maximum neighborhood component (MNC)</h2><span id='topic+mnc'></span>

<h3>Description</h3>

<p>Maximum Neighborhood Component defined as:
</p>
<p style="text-align: center;"><code class="reqn">MNC(v)=\left|V(MC(v))\right|</code>
</p>

<p>where where MC(v) is a maximum connected component of the <code class="reqn">G[N(v)]</code> and <code class="reqn">G[N(v)]</code> is the induced subgraph of G by <code class="reqn">N(v)</code> and <code class="reqn">N(v)</code> is neighborhoods of node <code class="reqn">v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnc(graph, vids = V(graph), mode = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnc_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="mnc_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="mnc_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The neighborhood of a node <code class="reqn">v</code>, nodes adjacent to <code class="reqn">v</code>, induce a subnetwork <code class="reqn">N(v)</code>. The score of node <code class="reqn">v</code>, <code class="reqn">MNC(v)</code>, is defined to be the size of the maximum connected component of <code class="reqn">N(v)</code>. The neighborhood <code class="reqn">N(v)</code> is the set of nodes adjacent to <code class="reqn">v</code> and does not contain node <code class="reqn">v</code>. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=MNC_Maximum_Neighborhood_Component">MNC-Maximum Neighborhood Component</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Lin, Chung-Yen, et al. &quot;Hubba: hub objects analyzer-a framework of interactome hubs identification for network biology.&quot; Nucleic acids research 36.suppl 2 (2008): W438-W443.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- random.graph.game(20, 3/10)
mnc(g)
</code></pre>

<hr>
<h2 id='pairwisedis'>Find the pairwise disconnectivity index</h2><span id='topic+pairwisedis'></span>

<h3>Description</h3>

<p>The pairwise disconnectivity index of vertex <code class="reqn">v</code>, <code class="reqn">Dis(v)</code> defined as:
</p>
<p style="text-align: center;"><code class="reqn">Dis(v)=\frac{N_{0}-N_{-v}}{N_{0}}=1-\frac{N_{-v}}{N_{0}}</code>
</p>

<p>where <code class="reqn">N_{0}</code> is the total number of ordered pairs of vertices in a network that are connected by at least one directed path of any length. It is supposed that <code class="reqn">N_{0}</code> &gt; 0, i.e., there exists at least one edge in the network that links two different vertices. <code class="reqn">N_{-v}</code> is the number of ordered pairs that are still connected after removing vertex <code class="reqn">v</code> from the network, via alternative paths through other vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwisedis(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwisedis_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="pairwisedis_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pairwise disconnectivity defined as index of vertex <code class="reqn">v</code>, <code class="reqn">Dis(v)</code>, as the fraction of those initially connected pairs of vertices in a network which become disconnected if vertex <code class="reqn">v</code> is removed from the network. The pairwise disconnectivity index quantifies how crucial an individual element is for sustaining the communication ability between connected pairs of vertices in a network that is displayed as a directed graph. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Pairwise_Disconnectivity_Index">Pairwise Disconnectivity Index</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Potapov, Anatolij P., Bjorn Goemann, and Edgar Wingender. &quot;The pairwise disconnectivity index as a new metric for the topological analysis of regulatory networks.&quot; BMC bioinformatics 9.1 (2008): 227.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
pairwisedis(g)
</code></pre>

<hr>
<h2 id='radiality'>Find the radiality centrality in a graph</h2><span id='topic+radiality'></span>

<h3>Description</h3>

<p>The radiality is a node centrality index and will give high centralities to vertices that are a short distance to every other vertex in its reachable neighborhood compared to its diameter. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radiality(graph, vids = V(graph), mode = c("all", "out", "in"),
  weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radiality_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="radiality_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="radiality_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from the given vertices should be calculated for directed graphs. If out then the shortest paths from the vertex, if in then to it will be considered. If all, the default, then the corresponding undirected graph will be used, ie. not directed paths are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="radiality_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is NULL, the default, and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Radiality centrality defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{rad}(v)=\frac{\sum_{w\in V}(d+1-d(v,w))}{n-1}</code>
</p>

<p>where <code class="reqn">d</code> is diameter of graph G with <code class="reqn">n</code> vertices and <code class="reqn">d(v,w)</code> is distance between vertex <code class="reqn">v</code> and <code class="reqn">w</code>. <br />
The radiality of a node <code class="reqn">v</code> is calculated by computing the shortest path between the node <code class="reqn">v</code> and all other nodes in the graph. The value of each path is then subtracted by the value of the diameter +1 (G+1) and the resulting values are summated. Finally, the obtained value is divided for the number of nodes -1 (n-1). The radiality should be always compared to the closeness and to the eccentricity: a node with high eccentricity + high closeness+ high radiality is a consistent indication of a high central position in the graph. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Radiality_Centrality">Radiality Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Wolfram Research, Inc., Mathematica, Version 10.0, Champaign, IL (2014). http://reference.wolfram.com/language/ref/RadialityCentrality.html
</p>
<p>Scardoni, G., Laudanna, C., Tosadori, G., Fabbri, F. &amp; Faizaan, M. CentiScaPe: Network centralities for Cytoscape. http://www.cbmc.it/~scardonig/centiscape/CentiScaPefiles/CentralitiesTutorial.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2))
radiality(g)
</code></pre>

<hr>
<h2 id='salsa'>Find the SALSA as 'hub' or 'authority' score</h2><span id='topic+salsa'></span>

<h3>Description</h3>

<p>The Stochastic Approach for Link-Structure Analysis (SALSA) is combination of HITS and PageRank which creates a neighborhood graph using authority and hub pages and links and create a bipartite graph of the authority and hub pages in the neighborhood graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salsa(graph, vids = V(graph), score = c("hub", "authority"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salsa_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="salsa_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="salsa_+3A_score">score</code></td>
<td>
<p>Character constant, gives which score should be calculated and must be one of 'hub' or 'authority'. The default is 'hub'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=SALSA">SALSA</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Lempel, Ronny, and Shlomo Moran. &quot;SALSA: the stochastic approach for link-structure analysis.&quot; ACM Transactions on Information Systems (TOIS) 19.2 (2001): 131-160.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- barabasi.game(10)
salsa(g)
</code></pre>

<hr>
<h2 id='semilocal'>Find the semi local centrality (or local centrality)</h2><span id='topic+semilocal'></span>

<h3>Description</h3>

<p>The local centrality <code class="reqn">CL(v)</code> of node <code class="reqn">v</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">C_{L}(v)=\sum_{u\in \Gamma (v)}Q(u)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">Q(u)=\sum_{w\in \Gamma (u)}N(w)</code>
</p>

<p>and <code class="reqn">\Gamma (u)</code> is the set of the nearest neighbors of node <code class="reqn">u</code> and <code class="reqn">N(w)</code> is the number of the nearest and the next nearest neighbors of node <code class="reqn">w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semilocal(graph, vids = V(graph), mode = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semilocal_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="semilocal_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
<tr><td><code id="semilocal_+3A_mode">mode</code></td>
<td>
<p>Character constatnt, it specifies how to use the direction of the edges if a directed graph is analyzed. For 'out' only the outgoing edges are followed. For 'in' all vertices from which the source vertex is reachable in at most order steps are counted. 'all' ignores the direction of the edges. This argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local centrality is proposed aiming at identifying the influencers in undirected network, it can be applied to directed network as well with a modified definition of <code class="reqn">N(w)</code>. Of course, for directed network, <code class="reqn">N(w)</code> should be the number of the nearest and next nearest upstream nodes of node <code class="reqn">w</code>. <br />
Local centrality measure is likely to be more effective to identify influential nodes than degree centrality measure as it utilizes more information, while it has much lower computational complexity than the betweenness and closeness centralities. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Semi_Local_Centrality">Semi_Local Centrality</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Chen, Duanbing, et al. &quot;Identifying influential nodes in complex networks.&quot; Physica a: Statistical mechanics and its applications 391.4 (2012): 1777-1787.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- barabasi.game(10)
semilocal(g)
</code></pre>

<hr>
<h2 id='topocoefficient'>Find the topological coefficient of a node in a undirected graph</h2><span id='topic+topocoefficient'></span>

<h3>Description</h3>

<p>The topological coefficient is a relative measure for the extent to which a node shares neighbors with other nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topocoefficient(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topocoefficient_+3A_graph">graph</code></td>
<td>
<p>The input graph as igraph object</p>
</td></tr>
<tr><td><code id="topocoefficient_+3A_vids">vids</code></td>
<td>
<p>Vertex sequence, the vertices for which the centrality values are returned. Default is all vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Topological coefficient <code class="reqn">T_{n}</code> of a node <code class="reqn">n</code> with <code class="reqn">k_{n}</code> neighbors defined as:
</p>
<p style="text-align: center;"><code class="reqn">T_{n}=\frac{avg(J(n,m))}{k_{n}}</code>
</p>

<p>where <code class="reqn">J(n,m)</code> is defined for all nodes <code class="reqn">m</code> that share at least one neighbor with <code class="reqn">n</code>. The value <code class="reqn">J(n,m)</code> is the number of neighbors shared between the nodes <code class="reqn">n</code> and <code class="reqn">m</code>, plus one if there is a direct link between <code class="reqn">n</code> and <code class="reqn">m</code>. <br />
Nodes that have one or no neighbors are assigned a topological coefficient of zero. <br />
More detail at <a href="http://www.centiserver.org/?q1=centrality&amp;q2=Topological_Coefficient">Topological Coefficient</a>
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected vertices.
</p>


<h3>Author(s)</h3>

<p>Mahdi Jalili <a href="mailto:m_jalili@farabi.tums.ac.ir">m_jalili@farabi.tums.ac.ir</a>
</p>


<h3>References</h3>

<p>Assenov, Yassen, et al. &quot;Computing topological parameters of biological networks.&quot; Bioinformatics 24.2 (2008): 282-284.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph(c(1,2,2,3,3,4,4,2), directed=FALSE)
topocoefficient(g)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
