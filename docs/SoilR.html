<!DOCTYPE html><html><head><title>Help for package SoilR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SoilR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SoilR-package'><p>SoilR</p></a></li>
<li><a href='#[,Model,character,missing,missing-method'><p>Experimentally overloaded index operator</p></a></li>
<li><a href='#[,NlModel,character,ANY,ANY-method'><p>automatic title</p></a></li>
<li><a href='#[[,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#[[&lt;-,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#$,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#AbsoluteFractionModern'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#AbsoluteFractionModern_from_Delta14C'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#AbsoluteFractionModern_from_Delta14C,matrix-method'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#AbsoluteFractionModern_from_Delta14C,numeric-method'><p>Conversion of radiocarbon values, from Delta14C to absolute fraction modern</p></a></li>
<li><a href='#AbsoluteFractionModern,BoundFc-method'><p>automatic title</p></a></li>
<li><a href='#AbsoluteFractionModern,ConstFc-method'><p>automatic title</p></a></li>
<li><a href='#add_plot'><p>Add elements to plot</p></a></li>
<li><a href='#add_plot,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#as.character,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#as.numeric,InFluxList_by_PoolName-method'><p>Convert to a numeric vector with the pool names as names</p></a></li>
<li><a href='#as.numeric,InternalFlux_by_PoolName-method'><p>Convert to a numeric value with name of the form 'a-&gt;b'</p></a></li>
<li><a href='#as.numeric,InternalFluxList_by_PoolName-method'><p>Convert to a numeric vector with names of the form 'a-&gt;b'</p></a></li>
<li><a href='#as.numeric,OutFluxList_by_PoolName-method'><p>Convert to a numeric vector with the pool names as names</p></a></li>
<li><a href='#availableParticleProperties'><p>Available particle properties</p></a></li>
<li><a href='#availableParticleProperties,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#availableParticleSets'><p>Available particle sets</p></a></li>
<li><a href='#availableParticleSets,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#availableResidentSets'><p>Available resident sets</p></a></li>
<li><a href='#availableResidentSets,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#AWBmodel'><p>Implementation of the microbial model AWB (Allison, Wallenstein, Bradford,</p>
2010)</a></li>
<li><a href='#bacwaveModel'><p>Implementation of the microbial model Bacwave (bacterial waves)</p></a></li>
<li><a href='#bind.C14curves'><p>Binding of pre- and post-bomb Delta14C curves</p></a></li>
<li><a href='#BoundFc'><p>Bound Fc object</p></a></li>
<li><a href='#BoundFc-class'><p>S4-class to represent atmospheric 14C concentration as</p>
scalar function of time.</a></li>
<li><a href='#BoundFc,character-method'><p>automatic title</p></a></li>
<li><a href='#BoundFc,missing-method'><p>automatic title</p></a></li>
<li><a href='#BoundInFluxes'><p>constructor for BoundInFluxes</p></a></li>
<li><a href='#BoundInFluxes-class'><p>automatic title</p></a></li>
<li><a href='#BoundLinDecompOp'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#BoundLinDecompOp-class'><p>A S4 class to represent a linear compartmental operator</p>
defined on time interval</a></li>
<li><a href='#BoundLinDecompOp,ANY-method'><p>Creates an object of class BoundLinDecompOp</p></a></li>
<li><a href='#BoundLinDecompOp,UnBoundLinDecompOp-method'><p>A converter</p></a></li>
<li><a href='#by_PoolIndex'><p>automatic title</p></a></li>
<li><a href='#by_PoolIndex,ConstantInFluxRate_by_PoolName,ANY,ANY-method'><p>new object with the source pool id converted to a PoolIndex if necessary</p></a></li>
<li><a href='#by_PoolIndex,ConstantInternalFluxRate_by_PoolName,ANY,ANY-method'><p>new object with the source pool id converted to a PoolName if necessary</p></a></li>
<li><a href='#by_PoolIndex,ConstantInternalFluxRateList_by_PoolName,ANY,ANY-method'><p>convert to a list indexed by pool names</p></a></li>
<li><a href='#by_PoolIndex,ConstantOutFluxRate_by_PoolName,ANY,ANY-method'><p>new object with the source pool id converted to a PoolIndex if necessary</p></a></li>
<li><a href='#by_PoolIndex,ConstantOutFluxRateList_by_PoolName,ANY,ANY-method'><p>convert to a list indexed by pool names</p></a></li>
<li><a href='#by_PoolIndex,function,character,character-method'><p>convert a function f of to f_vec</p></a></li>
<li><a href='#by_PoolIndex,InFlux_by_PoolName,character,character-method'><p>Convert the pool names to indices</p></a></li>
<li><a href='#by_PoolIndex,InFluxList_by_PoolName,character,character-method'><p>Transform pool names to indices</p></a></li>
<li><a href='#by_PoolIndex,InternalFlux_by_PoolName,character,character-method'><p>automatic title</p></a></li>
<li><a href='#by_PoolIndex,InternalFluxList_by_PoolName,character,character-method'><p>automatic title</p></a></li>
<li><a href='#by_PoolIndex,OutFlux_by_PoolName,character,character-method'><p>automatic title</p></a></li>
<li><a href='#by_PoolIndex,OutFluxList_by_PoolName,character,character-method'><p>automatic title</p></a></li>
<li><a href='#by_PoolIndex,PoolConnection_by_PoolName,ANY,ANY-method'><p>constructor from strings of the form 'x-&gt;y'</p>
new object with the source pool id and the destination pool id guaranteed to be of class PoolIndex</a></li>
<li><a href='#by_PoolName'><p>automatic title</p></a></li>
<li><a href='#by_PoolName,ConstantInFlux_by_PoolIndex-method'><p>new object with the source pool id converted to a PoolIndex if necessary</p></a></li>
<li><a href='#by_PoolName,ConstantInFluxList_by_PoolIndex-method'><p>convert to a list indexed by pool names</p></a></li>
<li><a href='#by_PoolName,ConstantInFluxRate_by_PoolIndex-method'><p>new object with the source pool id converted to a PoolIndex if necessary</p></a></li>
<li><a href='#by_PoolName,ConstantInternalFluxRateList_by_PoolIndex-method'><p>convert to a list indexed by pool names</p></a></li>
<li><a href='#by_PoolName,ConstantOutFluxRate_by_PoolIndex-method'><p>new object with the source pool id converted to a PoolName if necessary</p></a></li>
<li><a href='#by_PoolName,ConstantOutFluxRateList_by_PoolIndex-method'><p>convert to a list indexed by pool names</p></a></li>
<li><a href='#C14Atm'><p>Atmospheric 14C fraction</p></a></li>
<li><a href='#C14Atm_NH'><p>Post-bomb atmospheric 14C fraction</p></a></li>
<li><a href='#CenturyModel'><p>Implementation of the Century model</p></a></li>
<li><a href='#CenturyModel14'><p>Implementation of a radiocarbon version of the Century model</p></a></li>
<li><a href='#check_duplicate_pool_names'><p>helper function</p></a></li>
<li><a href='#check_id_length'><p>helper function to check that the length of the argument is exactly 1</p></a></li>
<li><a href='#check_pool_ids'><p>Check pool ids</p></a></li>
<li><a href='#check_pool_ids,PoolConnection_by_PoolIndex,integer-method'><p>automatic title</p></a></li>
<li><a href='#computeResults'><p>Computes results</p></a></li>
<li><a href='#computeResults,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#ConstantInFlux_by_PoolIndex-class'><p>class for a constant influx to a single pool identified by index</p></a></li>
<li><a href='#ConstantInFlux_by_PoolName-class'><p>class for a constant influx to a single pool identified by pool name</p></a></li>
<li><a href='#ConstantInFluxList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInFluxList_by_PoolIndex-class'><p>Subclass of list that is guaranteed to contain only elements of type</p>
ConstantInFlux_by_PoolIndex</a></li>
<li><a href='#ConstantInFluxList_by_PoolIndex,ConstInFluxes-method'><p>constructor from ConstInFluxes</p></a></li>
<li><a href='#ConstantInFluxList_by_PoolIndex,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#ConstantInFluxList_by_PoolIndex,numeric-method'><p>constructor from numeric vector</p></a></li>
<li><a href='#ConstantInFluxList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInFluxList_by_PoolName-class'><p>Subclass of list that is guaranteed to contain only elements of type</p>
ConstantInFlux_by_PoolName</a></li>
<li><a href='#ConstantInFluxRate_by_PoolIndex-class'><p>Describes a flux rates.</p></a></li>
<li><a href='#ConstantInFluxRate_by_PoolName'><p>Constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInFluxRate_by_PoolName-class'><p>Describes a flux rates.</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolIndex-class'><p>S4 class representing a constant internal flux rate</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolIndex,numeric,numeric,missing,numeric-method'><p>automatic title</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolName-class'><p>S4-class to represent a constant internal flux rate with source and target indexed by name</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolName,character,character,missing,numeric-method'><p>constructor with argument conversion</p></a></li>
<li><a href='#ConstantInternalFluxRate_by_PoolName,missing,missing,character,numeric-method'><p>constructor from strings of the form 'a-&gt;b'</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolIndex-class'><p>Describes a list of flux rates.</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolIndex,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolIndex,numeric-method'><p>automatic title</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolName-class'><p>Describes a list of flux rates.</p></a></li>
<li><a href='#ConstantInternalFluxRateList_by_PoolName,list-method'><p>Constructor from a normal list of fluxes</p></a></li>
<li><a href='#ConstantOutFluxRate_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantOutFluxRate_by_PoolIndex-class'><p>S4 Class to represent a single constant out-flux rate with the</p>
source pool specified by an index</a></li>
<li><a href='#ConstantOutFluxRate_by_PoolIndex,numeric,numeric-method'><p>automatic title</p></a></li>
<li><a href='#ConstantOutFluxRate_by_PoolName-class'><p>S4 Class to represent a single constant out-flux rate with the</p>
source pool specified by name</a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolIndex-class'><p>Describes a list of flux rates.</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolIndex,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolIndex,numeric-method'><p>automatic title</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolName-class'><p>Describes a list of flux rates.</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolName,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#ConstantOutFluxRateList_by_PoolName,numeric-method'><p>automatic title</p></a></li>
<li><a href='#ConstFc'><p>creates an object containing the initial values for the 14C fraction needed</p>
to create models in SoilR</a></li>
<li><a href='#ConstFc-class'><p>S4 class representing a constant 14C fraction</p></a></li>
<li><a href='#ConstInFluxes'><p>Constant input fluxes</p></a></li>
<li><a href='#ConstInFluxes-class'><p>S4 class for a constant influx vector</p></a></li>
<li><a href='#ConstInFluxes,ConstantInFluxList_by_PoolIndex,numeric-method'><p>automatic title</p></a></li>
<li><a href='#ConstInFluxes,numeric,ANY-method'><p>automatic title</p></a></li>
<li><a href='#ConstLinDecompOp'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstLinDecompOp_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstLinDecompOp-class'><p>A class to represent a constant (=nonautonomous,linear) compartmental matrix</p>
or equivalently a combination of ordered constant internal flux rates and
constant out flux rates.</a></li>
<li><a href='#ConstLinDecompOp,matrix,missing,missing,missing,missing-method'><p>Constructor of object of ConstLinDecompOp class</p></a></li>
<li><a href='#ConstLinDecompOpWithLinearScalarFactor'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#ConstLinDecompOpWithLinearScalarFactor-class'><p>A class to represent a constant (=nonautonomous,linear) compartmental matrix</p>
with a time dependent (linear) scalar pre factor
This is a special case of a linear compartmental operator/matrix</a></li>
<li><a href='#cycling'><p>Cycling analysis of compartmental matrices</p></a></li>
<li><a href='#DecompOp-class'><p>S4-class to represent compartmental operators</p></a></li>
<li><a href='#DecompositionOperator-class'><p>automatic title</p></a></li>
<li><a href='#Delta14C'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#Delta14C_from_AbsoluteFractionModern'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#Delta14C_from_AbsoluteFractionModern,matrix-method'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#Delta14C_from_AbsoluteFractionModern,numeric-method'><p>Conversion of radiocarbon values</p></a></li>
<li><a href='#Delta14C,BoundFc-method'><p>automatic title</p></a></li>
<li><a href='#Delta14C,ConstFc-method'><p>automatic title</p></a></li>
<li><a href='#deSolve.lsoda.wrapper'><p>deSolve.lsoda.wrapper</p></a></li>
<li><a href='#eCO2'>
<p>Soil CO2 efflux from an incubation experiment</p></a></li>
<li><a href='#entropyRatePerJump'><p>Entropy rate per jump</p></a></li>
<li><a href='#entropyRatePerTime'><p>Entropy rate per time</p></a></li>
<li><a href='#euler'><p>euler</p></a></li>
<li><a href='#example.2DBoundInFluxesFromFunction'><p>example.2DBoundInFluxesFromFunction</p></a></li>
<li><a href='#example.2DBoundLinDecompOpFromFunction'><p>example.2DBoundLinDecompOpFromFunction</p></a></li>
<li><a href='#example.2DConstFc.Args'><p>example.2DConstFc.Args</p></a></li>
<li><a href='#example.2DConstInFluxesFromVector'><p>2D example for constant Influx</p></a></li>
<li><a href='#example.2DGeneralDecompOpArgs'><p>example.2DGeneralDecompOpArgs</p></a></li>
<li><a href='#example.2DInFluxes.Args'><p>example.2DInFluxes.Args</p></a></li>
<li><a href='#example.2DUnBoundLinDecompOpFromFunction'><p>example.2DUnBoundLinDecompOpFromFunction</p></a></li>
<li><a href='#example.ConstlinDecompOpFromMatrix'><p>example.ConstlinDecompOpFromMatrix</p></a></li>
<li><a href='#example.nestedTime2DMatrixList'><p>create an example nested list that can be</p></a></li>
<li><a href='#example.Time2DArrayList'><p>create an example TimeMap from 2D array</p></a></li>
<li><a href='#example.Time3DArrayList'><p>create an example TimeFrame from 3D array</p></a></li>
<li><a href='#example.TimeMapFromArray'><p>create an example TimeFrame from 3D array</p></a></li>
<li><a href='#Fc-class'><p>automatic title</p></a></li>
<li><a href='#FcAtm.from.Dataframe'><p>FcAtm.from.Dataframe</p></a></li>
<li><a href='#from_integer_flux_lists_with_defaults'><p>helper function</p></a></li>
<li><a href='#fT.Arrhenius'><p>Effects of temperature on decomposition rates according the Arrhenius</p>
equation</a></li>
<li><a href='#fT.Century1'><p>Effects of temperature on decomposition rates according the the CENTURY</p>
model</a></li>
<li><a href='#fT.Century2'><p>Effects of temperature on decomposition rates according the the CENTURY</p>
model</a></li>
<li><a href='#fT.Daycent1'><p>Effects of temperature on decomposition rates according to the DAYCENT model</p></a></li>
<li><a href='#fT.Daycent2'><p>Effects of temperature on decomposition rates according to the DAYCENT model</p></a></li>
<li><a href='#fT.Demeter'><p>Effects of temperature on decomposition rates according to the DEMETER model</p></a></li>
<li><a href='#fT.KB'><p>Effects of temperature on decomposition rates according to a model proposed</p>
by M. Kirschbaum (1995)</a></li>
<li><a href='#fT.LandT'><p>Effects of temperature on decomposition rates according to a function</p>
proposed by Lloyd and Taylor (1994)</a></li>
<li><a href='#fT.linear'><p>Effects of temperature on decomposition rates according to a linear model</p></a></li>
<li><a href='#fT.Q10'><p>Effects of temperature on decomposition rates according to a Q10 function</p></a></li>
<li><a href='#fT.RothC'><p>Effects of temperature on decomposition rates according to the functions</p>
included in the RothC model</a></li>
<li><a href='#fT.Standcarb'><p>Effects of temperature on decomposition rates according to the StandCarb</p>
model</a></li>
<li><a href='#fW.Candy'><p>Effects of moisture on decomposition rates according to the Candy model</p></a></li>
<li><a href='#fW.Century'><p>Effects of moisture on decomposition rates according to the CENTURY model</p></a></li>
<li><a href='#fW.Daycent1'><p>Effects of moisture on decomposition rates according to the DAYCENT model</p></a></li>
<li><a href='#fW.Daycent2'><p>Effects of moisture on decomposition rates according to the DAYCENT model</p></a></li>
<li><a href='#fW.Demeter'><p>Effects of moisture on decomposition rates according to the DEMETER model</p></a></li>
<li><a href='#fW.Gompertz'><p>Effects of moisture on decomposition rates according to the Gompertz</p>
function</a></li>
<li><a href='#fW.Moyano'><p>Effects of moisture on decomposition rates according to the function</p>
proposed by Moyano et al. (2013)</a></li>
<li><a href='#fW.RothC'><p>Effects of moisture on decomposition rates according to the RothC model</p></a></li>
<li><a href='#fW.Skopp'><p>Effects of moisture on decomposition rates according to the function</p>
proposed by Skopp et al. 1990</a></li>
<li><a href='#fW.Standcarb'><p>Effects of moisture on decomposition rates according to the StandCarb model</p></a></li>
<li><a href='#GaudinskiModel14'><p>Implementation of a the six-pool C14 model proposed by Gaudinski et al. 2000</p></a></li>
<li><a href='#GeneralDecompOp'><p>A generic factory for subclasses of GeneralDecompOp</p></a></li>
<li><a href='#GeneralDecompOp,DecompOp-method'><p>Pass through factory for objects of subclasses of DecompOp</p></a></li>
<li><a href='#GeneralDecompOp,function-method'><p>automatic title</p></a></li>
<li><a href='#GeneralDecompOp,list-method'><p>automatic title</p></a></li>
<li><a href='#GeneralDecompOp,matrix-method'><p>automatic title</p></a></li>
<li><a href='#GeneralDecompOp,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#GeneralModel'><p>additional function to create Models</p></a></li>
<li><a href='#GeneralModel_14'><p>create objects of class Model_14</p></a></li>
<li><a href='#GeneralNlModel'><p>Use this function to create objects of class NlModel.</p></a></li>
<li><a href='#GeneralPoolId'><p>General pool Id</p></a></li>
<li><a href='#GeneralPoolId,character-method'><p>automatic title</p></a></li>
<li><a href='#GeneralPoolId,numeric-method'><p>generic factory for this virtual class</p></a></li>
<li><a href='#getAccumulatedRelease'><p>Accumulated release flux out of the pools</p></a></li>
<li><a href='#getAccumulatedRelease,Model-method'><p>Compute the time integral of the relaese fluxes over time</p></a></li>
<li><a href='#getC'><p>Calculates the content of the pools</p></a></li>
<li><a href='#getC,Model_by_PoolNames-method'><p>Pool Contents for all times</p></a></li>
<li><a href='#getC,Model-method'><p>Pool Contents for all times</p></a></li>
<li><a href='#getC,NlModel-method'><p>Pool Contents for all times</p></a></li>
<li><a href='#getC14'><p>Generic that yields the 14C content for all pools and all times</p></a></li>
<li><a href='#getC14,Model_14-method'><p>automatic title</p></a></li>
<li><a href='#getCompartmentalMatrixFunc'><p>Compartmental matrix function</p></a></li>
<li><a href='#getCompartmentalMatrixFunc,BoundLinDecompOp-method'><p>automatic title</p></a></li>
<li><a href='#getCompartmentalMatrixFunc,ConstLinDecompOp-method'><p>Compartmental matrix function</p></a></li>
<li><a href='#getCompartmentalMatrixFunc,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getCompartmentalMatrixFunc,UnBoundNonLinDecompOp-method'><p>Extract the matrix valued function of time and state vector for the compartmental matrix</p></a></li>
<li><a href='#getConstantCompartmentalMatrix'><p>Constant compartmental matrix</p></a></li>
<li><a href='#getConstantCompartmentalMatrix,ConstLinDecompOp-method'><p>Constant compartmental matrix</p></a></li>
<li><a href='#getConstantCompartmentalMatrix,ConstLinDecompOpWithLinearScalarFactor-method'><p>automatic title</p></a></li>
<li><a href='#getConstantInFluxVector'><p>Input flux vector</p></a></li>
<li><a href='#getConstantInFluxVector,ConstInFluxes-method'><p>automatic title</p></a></li>
<li><a href='#getConstantInternalFluxRateList_by_PoolIndex'><p>Constant internal flux rate list by pool index</p></a></li>
<li><a href='#getConstantInternalFluxRateList_by_PoolIndex,ConstLinDecompOp-method'><p>Constant internal flux rate list by pool index</p></a></li>
<li><a href='#getConstantOutFluxRateList_by_PoolIndex'><p>Constant out flux rate list by pool index</p></a></li>
<li><a href='#getConstantOutFluxRateList_by_PoolIndex,ConstLinDecompOp-method'><p>Constant out flux rate list by pool index</p></a></li>
<li><a href='#getConstLinDecompOp'><p>Constant linear decomposition operator</p></a></li>
<li><a href='#getConstLinDecompOp,ConstLinDecompOpWithLinearScalarFactor-method'><p>automatic title</p></a></li>
<li><a href='#getCumulativeC'><p>Cummulative pool contents</p></a></li>
<li><a href='#getCumulativeC,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getDecompOp'><p>Decomposition operator of a model</p></a></li>
<li><a href='#getDecompOp,Model-method'><p>Extract the Compartmental Operator</p></a></li>
<li><a href='#getDecompOp,NlModel-method'><p>Extract the Compartmental Operator</p></a></li>
<li><a href='#getDotOut'><p>Dot out</p></a></li>
<li><a href='#getDotOut,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getF14'><p>Generic that yields the 14C fraction for the content all pools and all times</p></a></li>
<li><a href='#getF14,Model_14-method'><p>automatic title</p></a></li>
<li><a href='#getF14C'><p>Generic that yields the 14C fraction for the cumulative content of all pools and all times</p></a></li>
<li><a href='#getF14C,Model_14-method'><p>automatic title</p></a></li>
<li><a href='#getF14R'><p>Generic that yields the 14C fraction for the release flux of all pools and all times</p></a></li>
<li><a href='#getF14R,Model_14-method'><p>automatic title</p></a></li>
<li><a href='#getFormat'><p>Get format of SoilR object</p></a></li>
<li><a href='#getFormat,Fc-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition'><p>Function definition of SoilR model</p></a></li>
<li><a href='#getFunctionDefinition,ConstInFluxes-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,ConstLinDecompOp-method'><p>Function describing an object of class ConstLinDecompOp</p></a></li>
<li><a href='#getFunctionDefinition,ConstLinDecompOpWithLinearScalarFactor-method'><p>convert names of  vectors or lists to class ConstantOutFluxRate</p>
convert names of  vectors or lists to class ConstantInternalFluxRate
helper function</a></li>
<li><a href='#getFunctionDefinition,DecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,InFluxList_by_PoolIndex-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,InFluxList_by_PoolName-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,StateDependentInFluxVector-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,UnBoundInFluxes-method'><p>automatic title</p></a></li>
<li><a href='#getFunctionDefinition,UnBoundLinDecompOp-method'><p>Extracts the time dependent matrix valued function (compartmental matrix)</p></a></li>
<li><a href='#getInFluxes'><p>Extract the influxes</p></a></li>
<li><a href='#getInFluxes,Model-method'><p>Extract the InFluxes as provided during creation of the model</p></a></li>
<li><a href='#getInFluxes,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getInitialValues'><p>Initial values of SoilR object</p></a></li>
<li><a href='#getInitialValues,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getLinearScaleFactor'><p>Linear scale factor</p></a></li>
<li><a href='#getLinearScaleFactor,ConstLinDecompOpWithLinearScalarFactor-method'><p>automatic title</p></a></li>
<li><a href='#getMeanTransitTime'><p>Mean transit time for SoilR objects</p></a></li>
<li><a href='#getMeanTransitTime,ConstLinDecompOp-method'><p>Mean transit time obtained through a numerical simulation. It produces an estimate with numerical errors. We recommend to use the function transitTime instead.</p></a></li>
<li><a href='#getNumberOfPools'><p>Number of pools in a model</p></a></li>
<li><a href='#getNumberOfPools,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#getNumberOfPools,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getNumberOfPools,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getOutputFluxes'><p>Generic Function to obtain the fluxes out of of the pools</p></a></li>
<li><a href='#getOutputFluxes,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getOutputReceivers'><p>Pools receiving outputs from other pools</p></a></li>
<li><a href='#getOutputReceivers,TransportDecompositionOperator,numeric-method'><p>automatic title</p></a></li>
<li><a href='#getParticleMonteCarloSimulator'><p>automatic title</p></a></li>
<li><a href='#getParticleMonteCarloSimulator,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getReleaseFlux'><p>Generic Function to obtain the vector of release fluxes out of the pools for all times.</p></a></li>
<li><a href='#getReleaseFlux,Model_by_PoolNames-method'><p>automatic title</p></a></li>
<li><a href='#getReleaseFlux,Model-method'><p>The release fluxes <code class="reqn">\frac{[content]}{[time]}</code> for all pools.</p></a></li>
<li><a href='#getReleaseFlux,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getReleaseFlux14'><p>Generic that yields the 14C fraction in the release flux</p></a></li>
<li><a href='#getReleaseFlux14,Model_14-method'><p>automatic title</p></a></li>
<li><a href='#getRightHandSideOfODE'><p>Right hand side of ODE of a SoilR model</p></a></li>
<li><a href='#getRightHandSideOfODE,Model_by_PoolNames-method'><p>Provide the (vector valued) derivative of the stocks with respect to time</p></a></li>
<li><a href='#getRightHandSideOfODE,Model-method'><p>Derivative of the state variables as function</p></a></li>
<li><a href='#getSolution'><p>Calculates all stocks all fluxes to ,in and out of  the compartment system and also their integrals over time</p></a></li>
<li><a href='#getSolution,Model_by_PoolNames-method'><p>All Fluxes and stocks for all times</p></a></li>
<li><a href='#getTimeRange'><p>Time range of a model simulation</p></a></li>
<li><a href='#getTimeRange,ConstInFluxes-method'><p>automatic title</p></a></li>
<li><a href='#getTimeRange,ConstLinDecompOp-method'><p>Time range of a simulation described in an object of class ConstLinDecompOp</p></a></li>
<li><a href='#getTimeRange,ConstLinDecompOpWithLinearScalarFactor-method'><p>automatic title</p></a></li>
<li><a href='#getTimeRange,DecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getTimeRange,TimeMap-method'><p>The time interval where the function is defined</p></a></li>
<li><a href='#getTimeRange,UnBoundInFluxes-method'><p>automatic title</p></a></li>
<li><a href='#getTimeRange,UnBoundLinDecompOp-method'><p>Extracts the time interval for which the function is valid.</p></a></li>
<li><a href='#getTimes'><p>Time vector of SoilR object</p></a></li>
<li><a href='#getTimes,Model_by_PoolNames-method'><p>Extract the times vector</p></a></li>
<li><a href='#getTimes,Model-method'><p>Extract the times vector</p></a></li>
<li><a href='#getTimes,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getTransferCoefficients'><p>Transfer coefficients</p></a></li>
<li><a href='#getTransferCoefficients,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#getTransferCoefficients,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getTransferMatrix'><p>deprecated, use getTransferMatrixFunc instead</p></a></li>
<li><a href='#getTransferMatrixFunc'><p>Transfer matrix function</p></a></li>
<li><a href='#getTransferMatrixFunc,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#getTransitTimeDistributionDensity'><p>Transit time distribution for SoilR objects</p></a></li>
<li><a href='#getTransitTimeDistributionDensity,ConstLinDecompOp-method'><p>Transit time distribution obtained through a numerical simulation. It introduces numerical errors. We recommend to use the function transitTime instead</p></a></li>
<li><a href='#getValues'><p>Get values of SoilR object</p></a></li>
<li><a href='#getValues,ConstFc-method'><p>automatic title</p></a></li>
<li><a href='#Graven2017'><p>Compiled records of radicarbon in atmospheric CO2 for historical simulations in CMIP6</p></a></li>
<li><a href='#HarvardForest14CO2'><p>Delta14C in soil CO2 efflux from Harvard Forest</p></a></li>
<li><a href='#Hua2013'><p>Atmospheric radiocarbon for the period 1950-2010 from Hua et al. (2013)</p></a></li>
<li><a href='#Hua2021'><p>Atmospheric radiocarbon for the period 1950-2019 from Hua et al. (2021)</p></a></li>
<li><a href='#ICBM_N'><p>Implementation of the ICBM/N model</p></a></li>
<li><a href='#ICBMModel'><p>Implementation of the Introductory Carbon Balance Model (ICBM)</p></a></li>
<li><a href='#incubation_experiment'><p>Soil CO2 efflux from an incubation experiment, along with the soil mass and carbon concentration measurements.</p></a></li>
<li><a href='#InFlux'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InFlux_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InFlux_by_PoolIndex-class'><p>S4 class for the influx to a single pool identified by the index</p></a></li>
<li><a href='#InFlux_by_PoolIndex,function,numeric-method'><p>Constructor from an ordered pair of PoolIndex (integer like) objects</p></a></li>
<li><a href='#InFlux_by_PoolName'><p>Generic constructor for an influx to a single pool from an ordered pair of PoolName (string like) and function  objects</p></a></li>
<li><a href='#InFlux_by_PoolName-class'><p>S4 class for the influx to a single pool identified by the name</p></a></li>
<li><a href='#InFlux_by_PoolName,function,character-method'><p>Constructor from an ordered pair of PoolName (string like) and function  objects</p></a></li>
<li><a href='#InFluxes'><p>A generic factory for subclasses of InFluxes</p></a></li>
<li><a href='#InFluxes-class'><p>A virtual S4-class representing (different subclasses) of in-fluxes to the system</p></a></li>
<li><a href='#InFluxes,ConstantInFluxList_by_PoolIndex-method'><p>automatic title</p></a></li>
<li><a href='#InFluxes,function-method'><p>automatic title</p></a></li>
<li><a href='#InFluxes,InFluxes-method'><p>automatic title</p></a></li>
<li><a href='#InFluxes,list-method'><p>automatic title</p></a></li>
<li><a href='#InFluxes,numeric-method'><p>automatic title</p></a></li>
<li><a href='#InFluxes,StateIndependentInFluxList_by_PoolIndex-method'><p>automatic title</p></a></li>
<li><a href='#InFluxes,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#InFluxList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InFluxList_by_PoolIndex-class'><p>Describes a list of flux rates.</p></a></li>
<li><a href='#InFluxList_by_PoolIndex,list-method'><p>constructor from a normal list</p>
after checking the elements</a></li>
<li><a href='#InFluxList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InFluxList_by_PoolName-class'><p>Class for a list of influxes indexed by the names of the target pools</p></a></li>
<li><a href='#InFluxList_by_PoolName,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#initialize,ConstLinDecompOp-method'><p>automatic title</p></a></li>
<li><a href='#initialize,DecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#initialize,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#initialize,Model_14-method'><p>Internal method to supervise creation of objects of this class</p></a></li>
<li><a href='#initialize,Model_by_PoolNames-method'><p>automatic title</p></a></li>
<li><a href='#initialize,Model-method'><p>Internal method to supervise creation of objects of this class</p></a></li>
<li><a href='#initialize,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#initialize,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#initialize,TransportDecompositionOperator-method'><p>automatic title</p></a></li>
<li><a href='#initialize,UnBoundInFluxes-method'><p>automatic title</p></a></li>
<li><a href='#initialize,UnBoundLinDecompOp-method'><p>automatic title</p></a></li>
<li><a href='#IntCal09'><p>Northern Hemisphere atmospheric radiocarbon for the pre-bomb period</p></a></li>
<li><a href='#IntCal13'><p>Atmospheric radiocarbon for the 0-50,000 yr BP period</p></a></li>
<li><a href='#IntCal20'><p>The IntCal20 northern hemisphere radiocarbon curve for the 0-55,000 yr BP period</p></a></li>
<li><a href='#InternalFlux_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InternalFlux_by_PoolIndex-class'><p>S4-class for a single internal flux with source and destination pools specified by indices</p></a></li>
<li><a href='#InternalFlux_by_PoolIndex,function,numeric,numeric,missing-method'><p>constructor from an ordered pair of PoolIndex (integer like) objects and a function with vector argument</p></a></li>
<li><a href='#InternalFlux_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InternalFlux_by_PoolName-class'><p>S4-class for a single internal flux with source and destination pools specified by name</p></a></li>
<li><a href='#InternalFlux_by_PoolName,function,character,character,missing-method'><p>constructor from an ordered pair of PoolName (string like) objects and a function with the set of formal argument names forming a</p>
subset of the state_variable_names</a></li>
<li><a href='#InternalFlux_by_PoolName,function,missing,missing,character-method'><p>automatic title</p></a></li>
<li><a href='#InternalFluxList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InternalFluxList_by_PoolIndex-class'><p>S4-class for a list of internal fluxes with source and destination pool inidices</p></a></li>
<li><a href='#InternalFluxList_by_PoolIndex,list-method'><p>Constructor from a normal list</p>
after checking the elements</a></li>
<li><a href='#InternalFluxList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#InternalFluxList_by_PoolName-class'><p>S4-class for a list of internal fluxes with indexed by (source and destination pool) names</p></a></li>
<li><a href='#InternalFluxList_by_PoolName,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#linearScalarModel'><p>Implementation of a general model for linear non-autonomous systems with scalar modifiers</p></a></li>
<li><a href='#linesCPool'><p>Add lines with the output of <code>getC14</code>, <code>getC</code>, or</p>
<code>getReleaseFlux</code> to an existing plot</a></li>
<li><a href='#listProduct'><p>tensor product of lists</p></a></li>
<li><a href='#MCSim-class'><p>Experimental Class for a Monte Carlo Simulation of particles leaving the pool</p></a></li>
<li><a href='#Model'><p>Constructor for class Model</p></a></li>
<li><a href='#Model_14'><p>general constructor for class Model_14</p></a></li>
<li><a href='#Model_14-class'><p>S4-class to represent a 14C model run</p></a></li>
<li><a href='#Model_by_PoolNames'><p>Constructor for <code>Model_by_PoolNames</code></p></a></li>
<li><a href='#Model_by_PoolNames-class'><p>A model run based on flux functions</p></a></li>
<li><a href='#Model-class'><p>S4 class representing a model run</p></a></li>
<li><a href='#NlModel-class'><p>deprecated class for a non-linear model run.</p></a></li>
<li><a href='#no_outflux_warning'><p>alternative Constructor with pool names</p>
helper function</a></li>
<li><a href='#OnepModel'><p>Implementation of a one pool model</p></a></li>
<li><a href='#OnepModel14'><p>Implementation of a one-pool C14 model</p></a></li>
<li><a href='#OutFlux'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#OutFlux_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#OutFlux_by_PoolIndex-class'><p>S4 class for a single out-flux with source pool index</p></a></li>
<li><a href='#OutFlux_by_PoolIndex,function,numeric-method'><p>constructor from a PoolIndex (integer like) objects and a function with vector argument</p></a></li>
<li><a href='#OutFlux_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#OutFlux_by_PoolName-class'><p>S4 class for a single out-flux with source pool name</p></a></li>
<li><a href='#OutFlux_by_PoolName,function,character-method'><p>constructor from a PoolName (integer like) object and a function</p></a></li>
<li><a href='#OutFluxList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#OutFluxList_by_PoolIndex-class'><p>A list of outfluxes</p></a></li>
<li><a href='#OutFluxList_by_PoolIndex,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#OutFluxList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#OutFluxList_by_PoolName-class'><p>S4 class for a list of out-fluxes indexed by source pool name</p></a></li>
<li><a href='#OutFluxList_by_PoolName,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#ParallelModel'><p>models for unconnected pools</p></a></li>
<li><a href='#pathEntropy'><p>Path Entropy</p></a></li>
<li><a href='#plot,MCSim-method'><p>automatic title</p></a></li>
<li><a href='#plot,Model_by_PoolNames-method'><p>Plot the graph of pool connections</p></a></li>
<li><a href='#plot,Model-method'><p>Create an overview plot</p></a></li>
<li><a href='#plot,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#plot,TimeMap-method'><p>automatic title</p></a></li>
<li><a href='#plotC14Pool'><p>Plots the output of <code>getF14</code> for each pool over time</p></a></li>
<li><a href='#plotCPool'><p>Plots the output of <code>getC</code> or <code>getReleaseFlux</code> for</p>
each pool over time</a></li>
<li><a href='#plotPoolGraph'><p>Generic plotter</p></a></li>
<li><a href='#plotPoolGraph,SymbolicModel_by_PoolNames-method'><p>Plot the graph of pool connections</p></a></li>
<li><a href='#plotPoolGraphFromTupleLists'><p>Helper function to draw connectivity graphs</p></a></li>
<li><a href='#PoolConnection_by_PoolIndex'><p>Pool connection by pool index</p></a></li>
<li><a href='#PoolConnection_by_PoolIndex-class'><p>Objects that have a source and a destination described by integer like objects  ( of class PoolIndex)</p></a></li>
<li><a href='#PoolConnection_by_PoolIndex,ANY,ANY,missing-method'><p>constructor from an ordered pair of PoolId objects</p></a></li>
<li><a href='#PoolConnection_by_PoolIndex,missing,missing,character-method'><p>constructor from strings of the form '1_to_2'</p></a></li>
<li><a href='#PoolConnection_by_PoolName'><p>Pool connection by pool name</p></a></li>
<li><a href='#PoolConnection_by_PoolName-class'><p>Objects that have a source and a destination determined by a string like object of class PoolName</p></a></li>
<li><a href='#PoolConnection_by_PoolName,ANY,ANY,missing-method'><p>constructor from an ordered pair of PoolName objects</p></a></li>
<li><a href='#PoolId-class'><p>common class for pool ids</p></a></li>
<li><a href='#PoolIndex'><p>Pool index</p></a></li>
<li><a href='#PoolIndex-class'><p>S4 class for pool indices</p></a></li>
<li><a href='#PoolIndex,character-method'><p>construct from number string like '1' or '3'</p></a></li>
<li><a href='#PoolIndex,numeric-method'><p>construct from number</p></a></li>
<li><a href='#PoolIndex,PoolIndex-method'><p>pass through constructor fron an object of the same class</p></a></li>
<li><a href='#PoolIndex,PoolName-method'><p>convert to number like object</p></a></li>
<li><a href='#PoolName'><p>Pool name</p></a></li>
<li><a href='#PoolName-class'><p>class for pool-name-strings</p></a></li>
<li><a href='#PoolName,character-method'><p>construct from string with checks</p></a></li>
<li><a href='#PoolName,PoolIndex-method'><p>convert to string like object</p></a></li>
<li><a href='#PoolName,PoolName-method'><p>pass through constructor fron an object of the same class</p></a></li>
<li><a href='#predefinedModels'><p>PREDEFINED MODELS</p></a></li>
<li><a href='#print,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#RespirationCoefficients'><p>helper function to compute respiration coefficients</p></a></li>
<li><a href='#RothCModel'><p>Implementation of the RothCModel</p></a></li>
<li><a href='#ScalarTimeMap'><p>Constructor for <code>ScalarTimeMap-class</code></p></a></li>
<li><a href='#ScalarTimeMap-class'><p>S4 class for a scalar time dependent function on a finite time interval</p></a></li>
<li><a href='#ScalarTimeMap,data.frame,missing,missing,missing,missing-method'><p>constructor for data given as 2 column data.frame</p></a></li>
<li><a href='#ScalarTimeMap,function,missing,missing,missing,missing-method'><p>manual constructor for just a function</p></a></li>
<li><a href='#ScalarTimeMap,function,numeric,numeric,missing,missing-method'><p>manual constructor for a function and an interval</p></a></li>
<li><a href='#ScalarTimeMap,missing,missing,missing,missing,numeric-method'><p>special case for a time map from a constant</p></a></li>
<li><a href='#ScalarTimeMap,missing,missing,missing,numeric,numeric-method'><p>constructor for data and times given as vectors</p></a></li>
<li><a href='#SeriesLinearModel'><p>General m-pool linear model with series structure</p></a></li>
<li><a href='#SeriesLinearModel14'><p>General m-pool linear C14 model with series structure</p></a></li>
<li><a href='#SHCal20'><p>The SHCal20 southern hemisphere radiocarbon curve for the 0-55,000 yr BP period</p></a></li>
<li><a href='#show,NlModel-method'><p>automatic title</p></a></li>
<li><a href='#SoilR.F0.new'><p>deprecated function that used to create an object of class SoilR.F0</p></a></li>
<li><a href='#state_variable_names'><p>determine the minimum set of statevariables</p></a></li>
<li><a href='#StateDependentInFluxVector-class'><p>Input vector that is a function of the pool contenst and time</p></a></li>
<li><a href='#StateIndependentInFlux_by_PoolIndex-class'><p>Constructor for the class with the same name</p></a></li>
<li><a href='#StateIndependentInFluxList_by_PoolIndex'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#StateIndependentInFluxList_by_PoolIndex-class'><p>Subclass of list that is guaranteed to contain only elements of type</p>
StateIndependentInFlux_by_PoolIndex</a></li>
<li><a href='#StateIndependentInFluxList_by_PoolIndex,list-method'><p>constructor from a normal list</p></a></li>
<li><a href='#StateIndependentInFluxList_by_PoolName'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#SymbolicModel_by_PoolNames-class'><p>A symbolic model description based on flux functions</p></a></li>
<li><a href='#systemAge'><p>System and pool age for constant compartment models</p></a></li>
<li><a href='#ThreepairMMmodel'><p>Implementation of a 6-pool Michaelis-Menten model</p></a></li>
<li><a href='#ThreepFeedbackModel'><p>Implementation of a three pool model with feedback structure</p></a></li>
<li><a href='#ThreepFeedbackModel14'><p>Implementation of a three-pool C14 model with feedback structure</p></a></li>
<li><a href='#ThreepParallelModel'><p>Implementation of a three pool model with parallel structure</p></a></li>
<li><a href='#ThreepParallelModel14'><p>Implementation of a three-pool C14 model with parallel structure</p></a></li>
<li><a href='#ThreepSeriesModel'><p>Implementation of a three pool model with series structure</p></a></li>
<li><a href='#ThreepSeriesModel14'><p>Implementation of a three-pool C14 model with series structure</p></a></li>
<li><a href='#TimeMap'><p>Constructor for <code>TimeMap-class</code></p></a></li>
<li><a href='#TimeMap-class'><p>S4 class for a time dependent function</p></a></li>
<li><a href='#TimeMap,data.frame,missing,missing,missing,missing-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap,function,missing,missing,missing,missing-method'><p>manual constructor for just a function</p></a></li>
<li><a href='#TimeMap,function,numeric,numeric,missing,missing-method'><p>manual constructor for a function and an interval</p></a></li>
<li><a href='#TimeMap,list,missing,missing,missing,missing-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap,missing,missing,missing,numeric,array-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap,missing,missing,missing,numeric,list-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap,missing,missing,missing,numeric,matrix-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap,missing,missing,missing,numeric,numeric-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap,TimeMap,ANY,ANY,ANY,ANY-method'><p>automatic title</p></a></li>
<li><a href='#TimeMap.from.Dataframe'><p>TimeMap.from.Dataframe</p></a></li>
<li><a href='#TimeMap.new'><p>deprecated constructor of the class TimeMap.</p></a></li>
<li><a href='#TimeRangeIntersection'><p>The time interval where both functions are defined</p></a></li>
<li><a href='#transitTime'><p>Transit times for compartment models</p></a></li>
<li><a href='#TransportDecompositionOperator-class'><p>automatic title</p></a></li>
<li><a href='#turnoverFit'><p>Estimation of the turnover time from a radiocarbon sample.</p></a></li>
<li><a href='#TwopFeedbackModel'><p>Implementation of a two pool model with feedback structure</p></a></li>
<li><a href='#TwopFeedbackModel14'><p>Implementation of a two-pool C14 model with feedback structure</p></a></li>
<li><a href='#TwopMMmodel'><p>Implementation of a two-pool Michaelis-Menten model</p></a></li>
<li><a href='#TwopParallelModel'><p>Implementation of a linear two pool model with parallel structure</p></a></li>
<li><a href='#TwopParallelModel14'><p>Implementation of a two-pool C14 model with parallel structure</p></a></li>
<li><a href='#TwopSeriesModel'><p>Implementation of a two pool model with series structure</p></a></li>
<li><a href='#TwopSeriesModel14'><p>Implementation of a two-pool C14 model with series structure</p></a></li>
<li><a href='#UnBoundInFluxes'><p>Unbound input fluxes</p></a></li>
<li><a href='#UnBoundInFluxes-class'><p>automatic title</p></a></li>
<li><a href='#UnBoundInFluxes,function-method'><p>automatic title</p></a></li>
<li><a href='#UnBoundLinDecompOp'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#UnBoundLinDecompOp-class'><p>An S4 class to represent a linear nonautonomous compartmental matrix</p></a></li>
<li><a href='#UnBoundLinDecompOp,function-method'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#UnBoundNonLinDecompOp'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#UnBoundNonLinDecompOp_by_PoolNames'><p>Generic constructor for the class with the same name</p></a></li>
<li><a href='#UnBoundNonLinDecompOp_by_PoolNames-class'><p>An S4 class to represent the of  nonlinear nonautonomous compartmental system independently of the order of state variables</p></a></li>
<li><a href='#UnBoundNonLinDecompOp-class'><p>An S4 class to represent a nonlinear nonautonomous compartmental matrix</p></a></li>
<li><a href='#UnBoundNonLinDecompOp,function,missing,missing,missing-method'><p>Constructor for the class with the same name</p></a></li>
<li><a href='#UnBoundNonLinDecompOp,missing,vector,vector,numeric-method'><p>Constructor for the class with the same name</p></a></li>
<li><a href='#Yasso07Model'><p>Implementation of the Yasso07 model</p></a></li>
<li><a href='#YassoModel'><p>Implementation of the Yasso model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Models of Soil Organic Matter Decomposition</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.107</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Carlos A. Sierra, Markus Mueller</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carlos A. Sierra &lt;csierra@bgc-jena.mpg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for modeling Soil Organic Matter decomposition
        in terrestrial ecosystems with linear and nonlinear systems of differential equations. 
        The package implements
        models according to the compartmental system representation described in 
        Sierra and others (2012) &lt;<a href="https://doi.org/10.5194%2Fgmd-5-1045-2012">doi:10.5194/gmd-5-1045-2012</a>&gt; and Sierra and others (2014)
        &lt;<a href="https://doi.org/10.5194%2Fgmd-7-1919-2014">doi:10.5194/gmd-7-1919-2014</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), deSolve,methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph,assertthat,parallel,expm,sets,purrr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>FME,lattice,MASS,knitr,rmarkdown,getopt,tinytex</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Collate:</td>
<td>setGlobalVariables.R setOldClasses.R genericFunctions.R
S4ClassDefinitions.R TimeMap.R ScalarTimeMap.R PoolId.R
PoolIndex.R PoolName.R InFlux_by_PoolIndex.R
InFlux_by_PoolName.R OutFlux_by_PoolIndex.R
OutFlux_by_PoolName.R InternalFlux_by_PoolIndex.R
InternalFlux_by_PoolName.R PoolConnection_by_PoolIndex.R
PoolConnection_by_PoolName.R ConstantInFluxRate_by_PoolIndex.R
ConstantInFluxRate_by_PoolName.R InFluxes.R ConstInFluxes.R
ConstantInFlux_by_PoolIndex.R
ConstantInternalFluxRate_by_PoolIndex.R
ConstantInternalFluxRate_by_PoolName.R
ConstantOutFluxRate_by_PoolIndex.R
ConstantOutFluxRate_by_PoolName.R InFluxList_by_PoolIndex.R
InFluxList_by_PoolName.R
StateIndependentInFluxList_by_PoolIndex.R
StateDependentInFluxVector.R OutFluxList_by_PoolIndex.R
OutFluxList_by_PoolName.R InternalFluxList_by_PoolIndex.R
InternalFluxList_by_PoolName.R
ConstantInFluxList_by_PoolIndex.R
ConstantInternalFluxRateList_by_PoolIndex.R
ConstantInternalFluxRateList_by_PoolName.R
ConstantOutFluxRateList_by_PoolIndex.R
ConstantOutFluxRateList_by_PoolName.R Fc.R HelperFunctions.R
BoundInFluxes.R deSolve.lsoda.wrapper.R
RespirationCoefficients.R TransportDecompositionOperator.R
SoilR.F0__deprecated_in_1.2.R MCSim.R DecompOp.R
UnboundInflux.R UnBoundLinDecompOp.R BoundLinDecompOp.R
UnBoundNonLinDecompOp.R
DecompositionOperator_deprecated_in_1.2.R Model_by_PoolNames.R
Model.R Model_14.R NlModel.R AutonomousLinearModel.R
NonAutonomousLinearModel.R AWBmodel.R bacwaveModel.R
bind.C14curves.R BoundFc.R CenturyModel.R ConstFc.R
ConstLinDecompOp.R ConstLinDecompOpWithLinearScaleFactor.R
SymbolicModel_by_PoolName.R
UnBoundNonLinDecompOp_by_PoolNames.R cycling.R euler.R
example.2DBoundInFluxesFromFunction.R
example.2DBoundLinDecompOpFromFunction.R
example.2DConstFC.Args.R example.2DConstInFluxesFromVector.R
example.2DGeneralDecompOpArgs.R example.2DInFluxes.Args.R
example.2DUnBoundLinDecompOp.R
example.BoundLinDecompOpFromFunction.R
example.ConstlinDecompOpFromMatrix.R
example.nestedTime2DMatrixList.R
example.nestedTime3DArrayList.R example.Time2DArrayList.R
example.Time3DArrayList.R example.TimeMapFromArray.R
FcAtm_deprecated_in_1.2.R fT.Arrhenius.R fT.Century1.R
fT.Century2.R fT.Daycent1.R fT.Daycent2.R fT.Demeter.R fT.KB.R
fT.LandT.R fT.linear.R fT.Q10.R fT.RothC.R fT.Standcarb.R
function.R fW.Candy.R fW.Century.R fW.Daycent1.R fW.Daycent2.R
fW.Demeter.R fW.Gompertz.R fW.Moyano.R fW.RothC.R fW.Skopp.R
fW.Standcarb.R GeneralModel.R GaudinskiModel14.R
GeneralModel_14.R GeneralNlModel.R ICBMModel.R linesCPool.R
linMaker.R list.R listProduct.R makelink.R MeanAge.R MeanTT.R
NpYdot.R OnepModel.R OnepModel14.R ParallelModel.R
plotC14Pool.R plotCPool.R RothCModel.R SeriesLinearModel.R
SeriesLinearModel14.R solver.R spectralNorm.R systemAge.R
ThreepairMMmodel.R ThreepFeedbackModel.R
ThreepFeedbackModel14.R ThreepParallelModel.R
ThreepParallelModel14.R ThreepSeriesModel.R
ThreepSeriesModel14.R transitTime.R tupelList.R turnoverFit.R
makeListInstance.R pe.R pp.R plotPoolGraphFromTupleLists.R
checkTargetClassOfElements.R TimeRangeIntersection.R
TwopFeedbackModel.R TwopFeedbackModel14.R TwopMMmodel.R
TwopParallelModel.R TwopParallelModel14.R TwopSeriesModel.R
TwopSeriesModel14.R vecFuncMaker.R warnings.R Yasso07Model.R
scalarFuncMaker.R apply_to_state_and_time.R YassoModel.R
C14Atm_NH.R C14Atm.R Hua2013.R IntCal09.R IntCal13.R
Graven2017.R IntCal20.R SHCal20.R incubation_experiment.R
HarvardForest14CO2.R getTransferMatrix.R SoilR-package.R
IVP_maker.R ydot_maker.R ICBM_N.R linearScalarModel.R
CenturyModel14.R pathEntropy.R entropyRatePerJump.R
entropyRatePerTime.R Hua2021.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3.9000</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-13 11:23:22 UTC; csierra</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-13 12:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='SoilR-package'>SoilR</h2><span id='topic+SoilR-package'></span>

<h3>Description</h3>

<p>The package allows you to study compartmental Soil models.
</p>


<h3>Details</h3>

<p>The typical workflow consists of the following steps:
</p>

<ol>
<li><p>Create a model(run)
</p>
</li>
<li><p>Inspect it
</p>
</li></ol>
 
<p>The simplest way of creating a model is to use one of the top level functions for predefined models: <code><a href="#topic+predefinedModels">predefinedModels</a></code>. 
The objects returned by these functions can be of different type, usually either 
</p>

<ol>
<li>  <p><code><a href="#topic+Model-class">Model</a></code> 
</p>
</li>
<li>  <p><code><a href="#topic+Model_14-class">Model_14</a></code> .
</p>
</li></ol>

<p>To inspect the behavior of a model object these classes provide several
methods to be found in their respective descriptions.
If none of the predefined models fits your needs you can assemble your own model.
The functions that create it are the constructors of the above mentioned classes. 
By convention they have the same name as the class and are described here:
</p>

<ol>
<li>  <p><code><a href="#topic+Model">Model</a></code> 
</p>
</li>
<li>  <p><code><a href="#topic+Model_14">Model_14</a></code> .
</p>
</li></ol>


<hr>
<h2 id='+5B+2CModel+2Ccharacter+2Cmissing+2Cmissing-method'>Experimentally overloaded index operator</h2><span id='topic++5B+2CModel+2Ccharacter+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>The method provides shortcuts and a unified interface to some of the
methods that can be applied to a model.
For a given model &lsquo;M' the code 'M[&rsquo;C'] is equivalent to 'getC(M)' and
&lsquo;M[&rsquo;ReleaseFlux']' is equivalent to 'getReleaseFlux(M)'
&lsquo;M[&rsquo;AccumulatedRelease']' is equivalent to 'getAccumulatedRelease(M)'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model,character,missing,missing'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CModel+2B2Ccharacter+2B2Cmissing+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CModel+2B2Ccharacter+2B2Cmissing+2B2Cmissing-method_+3A_i">i</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+2CNlModel+2Ccharacter+2CANY+2CANY-method'>automatic title</h2><span id='topic++5B+2CNlModel+2Ccharacter+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel,character,ANY,ANY'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2CNlModel+2B2Ccharacter+2B2CANY+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B2CNlModel+2B2Ccharacter+2B2CANY+2B2CANY-method_+3A_i">i</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+5B+2CMCSim-method'>automatic title</h2><span id='topic++5B+5B+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B2CMCSim-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2CMCSim-method_+3A_i">i</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+5B+26lt+3B-+2CMCSim-method'>automatic title</h2><span id='topic++5B+5B+3C-+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'MCSim'
x[[i, j, ...]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-+2B2CMCSim-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-+2B2CMCSim-method_+3A_i">i</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-+2B2CMCSim-method_+3A_j">j</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-+2B2CMCSim-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B26lt+2B3B-+2B2CMCSim-method_+3A_value">value</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='+24+2CNlModel-method'>automatic title</h2><span id='topic++24+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24+2B2CNlModel-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="+2B24+2B2CNlModel-method_+3A_name">name</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='AbsoluteFractionModern'>Conversion of radiocarbon values</h2><span id='topic+AbsoluteFractionModern'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AbsoluteFractionModern(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbsoluteFractionModern_+3A_f">F</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='AbsoluteFractionModern_from_Delta14C'>Conversion of radiocarbon values</h2><span id='topic+AbsoluteFractionModern_from_Delta14C'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AbsoluteFractionModern_from_Delta14C(delta14C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbsoluteFractionModern_from_Delta14C_+3A_delta14c">delta14C</code></td>
<td>
<p>Object to be converted to AbsoluteFractionModern</p>
</td></tr>
</table>

<hr>
<h2 id='AbsoluteFractionModern_from_Delta14C+2Cmatrix-method'>Conversion of radiocarbon values</h2><span id='topic+AbsoluteFractionModern_from_Delta14C+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
AbsoluteFractionModern_from_Delta14C(delta14C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbsoluteFractionModern_from_Delta14C+2B2Cmatrix-method_+3A_delta14c">delta14C</code></td>
<td>
<p>Matrix with radiocarbon values in Delta14C</p>
</td></tr>
</table>

<hr>
<h2 id='AbsoluteFractionModern_from_Delta14C+2Cnumeric-method'>Conversion of radiocarbon values, from Delta14C to absolute fraction modern</h2><span id='topic+AbsoluteFractionModern_from_Delta14C+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values, from Delta14C to absolute fraction modern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
AbsoluteFractionModern_from_Delta14C(delta14C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbsoluteFractionModern_from_Delta14C+2B2Cnumeric-method_+3A_delta14c">delta14C</code></td>
<td>
<p>radiocarbon value in Delta14C</p>
</td></tr>
</table>

<hr>
<h2 id='AbsoluteFractionModern+2CBoundFc-method'>automatic title</h2><span id='topic+AbsoluteFractionModern+2CBoundFc-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BoundFc'
AbsoluteFractionModern(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbsoluteFractionModern+2B2CBoundFc-method_+3A_f">F</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='AbsoluteFractionModern+2CConstFc-method'>automatic title</h2><span id='topic+AbsoluteFractionModern+2CConstFc-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstFc'
AbsoluteFractionModern(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AbsoluteFractionModern+2B2CConstFc-method_+3A_f">F</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='add_plot'>Add elements to plot</h2><span id='topic+add_plot'></span>

<h3>Description</h3>

<p>Add elements to plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_plot_+3A_x">x</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="add_plot_+3A_...">...</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='add_plot+2CTimeMap-method'>automatic title</h2><span id='topic+add_plot+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
add_plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_plot+2B2CTimeMap-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="add_plot+2B2CTimeMap-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='as.character+2CTimeMap-method'>automatic title</h2><span id='topic+as.character+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character+2B2CTimeMap-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="as.character+2B2CTimeMap-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='as.numeric+2CInFluxList_by_PoolName-method'>Convert to a numeric vector with the pool names as names</h2><span id='topic+as.numeric+2CInFluxList_by_PoolName-method'></span>

<h3>Description</h3>

<p>Convert to a numeric vector with the pool names as names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InFluxList_by_PoolName'
as.numeric(x, y, t, time_symbol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numeric+2B2CInFluxList_by_PoolName-method_+3A_x">x</code></td>
<td>
<p>The list of fluxes. Every element 
contains a function that depends on a combination of
of state variables and time.</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInFluxList_by_PoolName-method_+3A_y">y</code></td>
<td>
<p>A vector indexed by the names of the state 
variables</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInFluxList_by_PoolName-method_+3A_t">t</code></td>
<td>
<p>a number representing the current point in time</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInFluxList_by_PoolName-method_+3A_time_symbol">time_symbol</code></td>
<td>
<p>The name of the time argument used 
in the definition of the flux functions</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInFluxList_by_PoolName-method_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='as.numeric+2CInternalFlux_by_PoolName-method'>Convert to a numeric value with name of the form 'a-&gt;b'</h2><span id='topic+as.numeric+2CInternalFlux_by_PoolName-method'></span>

<h3>Description</h3>

<p>Convert to a numeric value with name of the form 'a-&gt;b'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InternalFlux_by_PoolName'
as.numeric(x, y, t, time_symbol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numeric+2B2CInternalFlux_by_PoolName-method_+3A_x">x</code></td>
<td>
<p>The list of fluxes. Every element 
contains a function that depends on a combination of
of state variables and time.</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFlux_by_PoolName-method_+3A_y">y</code></td>
<td>
<p>A vector indexed by the names of the state 
variables</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFlux_by_PoolName-method_+3A_t">t</code></td>
<td>
<p>a number representing the current point in time</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFlux_by_PoolName-method_+3A_time_symbol">time_symbol</code></td>
<td>
<p>The name of the time argument used 
in the definition of the flux functions</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFlux_by_PoolName-method_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='as.numeric+2CInternalFluxList_by_PoolName-method'>Convert to a numeric vector with names of the form 'a-&gt;b'</h2><span id='topic+as.numeric+2CInternalFluxList_by_PoolName-method'></span>

<h3>Description</h3>

<p>Convert to a numeric vector with names of the form 'a-&gt;b'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InternalFluxList_by_PoolName'
as.numeric(x, y, t, time_symbol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numeric+2B2CInternalFluxList_by_PoolName-method_+3A_x">x</code></td>
<td>
<p>The list of fluxes. Every element 
contains a function that depends on a combination of
of state variables and time.</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFluxList_by_PoolName-method_+3A_y">y</code></td>
<td>
<p>A vector indexed by the names of the state 
variables</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFluxList_by_PoolName-method_+3A_t">t</code></td>
<td>
<p>a number representing the current point in time</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFluxList_by_PoolName-method_+3A_time_symbol">time_symbol</code></td>
<td>
<p>The name of the time argument used 
in the definition of the flux functions</p>
</td></tr>
<tr><td><code id="as.numeric+2B2CInternalFluxList_by_PoolName-method_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='as.numeric+2COutFluxList_by_PoolName-method'>Convert to a numeric vector with the pool names as names</h2><span id='topic+as.numeric+2COutFluxList_by_PoolName-method'></span>

<h3>Description</h3>

<p>Convert to a numeric vector with the pool names as names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutFluxList_by_PoolName'
as.numeric(x, y, t, time_symbol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numeric+2B2COutFluxList_by_PoolName-method_+3A_x">x</code></td>
<td>
<p>The list of fluxes. Every element 
contains a function that depends on a combination of
of state variables and time.</p>
</td></tr>
<tr><td><code id="as.numeric+2B2COutFluxList_by_PoolName-method_+3A_y">y</code></td>
<td>
<p>A vector indexed by the names of the state 
variables</p>
</td></tr>
<tr><td><code id="as.numeric+2B2COutFluxList_by_PoolName-method_+3A_t">t</code></td>
<td>
<p>a number representing the current point in time</p>
</td></tr>
<tr><td><code id="as.numeric+2B2COutFluxList_by_PoolName-method_+3A_time_symbol">time_symbol</code></td>
<td>
<p>The name of the time argument used 
in the definition of the flux functions</p>
</td></tr>
<tr><td><code id="as.numeric+2B2COutFluxList_by_PoolName-method_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='availableParticleProperties'>Available particle properties</h2><span id='topic+availableParticleProperties'></span>

<h3>Description</h3>

<p>Available particle properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableParticleProperties(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableParticleProperties_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='availableParticleProperties+2CMCSim-method'>automatic title</h2><span id='topic+availableParticleProperties+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
availableParticleProperties(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableParticleProperties+2B2CMCSim-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='availableParticleSets'>Available particle sets</h2><span id='topic+availableParticleSets'></span>

<h3>Description</h3>

<p>Available particle sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableParticleSets(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableParticleSets_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='availableParticleSets+2CMCSim-method'>automatic title</h2><span id='topic+availableParticleSets+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
availableParticleSets(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableParticleSets+2B2CMCSim-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='availableResidentSets'>Available resident sets</h2><span id='topic+availableResidentSets'></span>

<h3>Description</h3>

<p>Available resident sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableResidentSets(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableResidentSets_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='availableResidentSets+2CMCSim-method'>automatic title</h2><span id='topic+availableResidentSets+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
availableResidentSets(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="availableResidentSets+2B2CMCSim-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='AWBmodel'>Implementation of the microbial model AWB (Allison, Wallenstein, Bradford,
2010)</h2><span id='topic+AWBmodel'></span>

<h3>Description</h3>

<p>This function implements the microbial model AWB (Allison, Wallenstein,
Bradford, 2010), a four-pool model with a microbial biomass, enzyme, SOC and
DOC pools. It is a special case of the general nonlinear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AWBmodel(
  t,
  V_M = 1e+08,
  V_m = 1e+08,
  r_B = 2e-04,
  r_E = 5e-06,
  r_L = 0.001,
  a_BS = 0.5,
  epsilon_0 = 0.63,
  epsilon_s = -0.016,
  Km_0 = 500,
  Km_u0 = 0.1,
  Km_s = 0.5,
  Km_us = 0.1,
  Ea = 47,
  R = 0.008314,
  Temp1 = 20,
  Temp2 = 20,
  ival = c(B = 2.19159, E = 0.0109579, S = 111.876, D = 0.00144928),
  I_S = 0.005,
  I_D = 0.005
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AWBmodel_+3A_t">t</code></td>
<td>
<p>vector of times (in hours) to calculate a solution.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_v_m">V_M</code></td>
<td>
<p>a scalar representing the maximum rate of uptake (mg DOC cm-3
h-1). Equivalent to V_maxuptake0 in original paper.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_v_m">V_m</code></td>
<td>
<p>a scalar representing the maximum rate of decomposition of SOM
(mg SOM cm-3 h-1). Equivalent to V_max0 in original paper.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_r_b">r_B</code></td>
<td>
<p>a scalar representing the rate constant of microbial death (h-1).
Equivalent to r_death in original publication.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_r_e">r_E</code></td>
<td>
<p>a scalar representing the rate constant of enzyme production
(h-1). Equivalent to r_EnzProd in original publication.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_r_l">r_L</code></td>
<td>
<p>a scalar representing the rate constant of enzyme loss (h-1).
Equivalent to r_EnzLoss in original publication.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_a_bs">a_BS</code></td>
<td>
<p>a scalar representing the fraction of the dead microbial biomass
incorporated to SOC. MICtoSOC in original publication.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_epsilon_0">epsilon_0</code></td>
<td>
<p>a scalar representing the intercept of the CUE function (mg
mg-1). CUE_0 in original paper.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_epsilon_s">epsilon_s</code></td>
<td>
<p>a scalar representing the slope of the CUE function
(degree-1). CUE_slope in original paper.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_km_0">Km_0</code></td>
<td>
<p>a scalar representing the intercept of the half-saturation
constant of SOC as a function of temperature (mg cm-3).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_km_u0">Km_u0</code></td>
<td>
<p>a scalar representing the intercept of the half saturation
constant of uptake as a function of temperature (mg cm-3).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_km_s">Km_s</code></td>
<td>
<p>a scalar representing the slope of the half saturation constant
of SOC as a function of temperature (mg cm-3 degree-1).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_km_us">Km_us</code></td>
<td>
<p>a scalar representing the slope of the half saturation constant
of uptake as a function of temperature (mg cm-3 degree-1).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_ea">Ea</code></td>
<td>
<p>a scalar representing the activation energy (kJ mol-1).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_r">R</code></td>
<td>
<p>a scalar representing the gas constant (kJ mol-1 degree-1).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_temp1">Temp1</code></td>
<td>
<p>a scalar representing the temperature in the output vector.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_temp2">Temp2</code></td>
<td>
<p>a scalar representing the temperature in the transfer matrix.</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_ival">ival</code></td>
<td>
<p>a vector of length 4 with the initial values for the pools (mg
cm-3).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_i_s">I_S</code></td>
<td>
<p>a scalar with the inputs to the SOC pool (mg cm-3 h-1).</p>
</td></tr>
<tr><td><code id="AWBmodel_+3A_i_d">I_D</code></td>
<td>
<p>a scalar with the inputs to the DOC pool (mg cm-3 h-1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation contains default parameters presented in Allison et al.
(2010).
</p>


<h3>Value</h3>

<p>An object of class NlModel that can be further queried.
</p>


<h3>References</h3>

<p>Allison, S.D., M.D. Wallenstein, M.A. Bradford. 2010.
Soil-carbon response to warming dependent on microbial physiology. Nature
Geoscience 3: 336-340.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hours=seq(0,800,0.1)

#Run the model with default parameter values
bcmodel=AWBmodel(t=hours)
Cpools=getC(bcmodel)
##Time solution
# fixme mm:
# the next line causes trouble on Rforge Windows patched build
# matplot(hours,Cpools,type="l",ylab="Concentrations",xlab="Hours",lty=1,ylim=c(0,max(Cpools)*1.2))
##State-space diagram
plot(as.data.frame(Cpools))
</code></pre>

<hr>
<h2 id='bacwaveModel'>Implementation of the microbial model Bacwave (bacterial waves)</h2><span id='topic+bacwaveModel'></span>

<h3>Description</h3>

<p>This function implements the microbial model Bacwave (bacterial waves), a
two-pool model with a bacterial and a substrate pool. It is a special case
of the general nonlinear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bacwaveModel(
  t,
  umax = 0.063,
  ks = 3,
  theta = 0.23,
  Dmax = 0.26,
  kd = 14.5,
  kr = 0.4,
  Y = 0.44,
  ival = c(S0 = 0.5, X0 = 1.5),
  BGF = 0.15,
  ExuM = 8,
  ExuT = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bacwaveModel_+3A_t">t</code></td>
<td>
<p>vector of times (in hours) to calculate a solution.</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_umax">umax</code></td>
<td>
<p>a scalar representing the maximum relative growth rate of
bacteria (hr-1)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_ks">ks</code></td>
<td>
<p>a scalar representing the substrate constant for growth (ug C /ml
soil solution)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_theta">theta</code></td>
<td>
<p>a scalar representing soil water content (ml solution/cm3 soil)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_dmax">Dmax</code></td>
<td>
<p>a scalar representing the maximal relative death rate of
bacteria (hr-1)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_kd">kd</code></td>
<td>
<p>a scalar representing the substrate constant for death of bacteria
(ug C/ml soil solution)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_kr">kr</code></td>
<td>
<p>a scalar representing the fraction of death biomass recycling to
substrate (unitless)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_y">Y</code></td>
<td>
<p>a scalar representing the yield coefficient for bacteria (ug C/ugC)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_ival">ival</code></td>
<td>
<p>a vector of length 2 with the initial values for the substrate
and the bacterial pools (ug C/cm3)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_bgf">BGF</code></td>
<td>
<p>a scalar representing the constant background flux of substrate
(ug C/cm3 soil/hr)</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_exum">ExuM</code></td>
<td>
<p>a scalar representing the maximal exudation rate (ug C/(hr cm3
soil))</p>
</td></tr>
<tr><td><code id="bacwaveModel_+3A_exut">ExuT</code></td>
<td>
<p>a scalar representing the time constant for exudation,
responsible for duration of exudation (1/hr).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation contains default parameters presented in Zelenev et al.
(2000). It produces nonlinear damped oscillations in the form of a stable
focus.
</p>


<h3>Value</h3>

<p>An object of class NlModel that can be further queried.
</p>


<h3>References</h3>

<p>Zelenev, V.V., A.H.C. van Bruggen, A.M. Semenov. 2000.
&ldquo;BACWAVE,&rdquo; a spatial-temporal model for traveling waves of bacterial
populations in response to a moving carbon source in soil. Microbial Ecology
40: 260-272.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hours=seq(0,800,0.1)
#
#Run the model with default parameter values
bcmodel=bacwaveModel(t=hours)
Cpools=getC(bcmodel)
#
#Time solution
matplot(hours,Cpools,type="l",ylab="Concentrations",xlab="Hours",lty=1,ylim=c(0,max(Cpools)*1.2))
legend("topleft",c("Substrate", "Microbial biomass"),lty=1,col=c(1,2),bty="n")
#
#State-space diagram
plot(Cpools[,2],Cpools[,1],type="l",ylab="Substrate",xlab="Microbial biomass")
#
#Microbial biomass over time
plot(hours,Cpools[,2],type="l",col=2,xlab="Hours",ylab="Microbial biomass")
</code></pre>

<hr>
<h2 id='bind.C14curves'>Binding of pre- and post-bomb Delta14C curves</h2><span id='topic+bind.C14curves'></span>

<h3>Description</h3>

<p>This function takes a pre- and a post-bomb curve, binds them together, and
reports the results back either in years BP or AD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind.C14curves(prebomb, postbomb, time.scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind.C14curves_+3A_prebomb">prebomb</code></td>
<td>
<p>A pre-bomb radiocarbon dataset. They could be either
<code><a href="#topic+IntCal09">IntCal09</a></code> or <code><a href="#topic+IntCal13">IntCal13</a></code>.</p>
</td></tr>
<tr><td><code id="bind.C14curves_+3A_postbomb">postbomb</code></td>
<td>
<p>A post-bomb radiocarbon dataset. They could be any of the
datasets in <code><a href="#topic+Hua2013">Hua2013</a></code>.</p>
</td></tr>
<tr><td><code id="bind.C14curves_+3A_time.scale">time.scale</code></td>
<td>
<p>A character indicating whether to report the results in
years before present <code>BP</code> or anno domini <code>AD</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 3 columns: years in AD or BP, the
atmospheric Delta14C value, the standard deviation of the Delta14C value.
</p>

<hr>
<h2 id='BoundFc'>Bound Fc object</h2><span id='topic+BoundFc'></span>

<h3>Description</h3>

<p>Bound Fc object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoundFc(format, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundFc_+3A_format">format</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="BoundFc_+3A_...">...</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='BoundFc-class'>S4-class to represent atmospheric 14C concentration as
scalar function of time.</h2><span id='topic+BoundFc-class'></span>

<h3>Description</h3>

<p>As time dependent scalar function which remembers its
domain ( see <code><a href="#topic+ScalarTimeMap-class">ScalarTimeMap</a></code>) and its
format.
</p>

<hr>
<h2 id='BoundFc+2Ccharacter-method'>automatic title</h2><span id='topic+BoundFc+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
BoundFc(format, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundFc+2B2Ccharacter-method_+3A_format">format</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="BoundFc+2B2Ccharacter-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='BoundFc+2Cmissing-method'>automatic title</h2><span id='topic+BoundFc+2Cmissing-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
BoundFc(format, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundFc+2B2Cmissing-method_+3A_format">format</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="BoundFc+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='BoundInFluxes'>constructor for BoundInFluxes</h2><span id='topic+BoundInFluxes'></span>

<h3>Description</h3>

<p>The method internally calls <code><a href="#topic+TimeMap">TimeMap</a></code> and expects the same kind
of arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoundInFluxes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundInFluxes_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+TimeMap">TimeMap</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='BoundInFluxes-class'>automatic title</h2><span id='topic+BoundInFluxes-class'></span>

<h3>Description</h3>

<p>automatic title
</p>

<hr>
<h2 id='BoundLinDecompOp'>Generic constructor for the class with the same name</h2><span id='topic+BoundLinDecompOp'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoundLinDecompOp(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundLinDecompOp_+3A_map">map</code></td>
<td>
<p>A map</p>
</td></tr>
<tr><td><code id="BoundLinDecompOp_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to function</p>
</td></tr>
</table>

<hr>
<h2 id='BoundLinDecompOp-class'>A S4 class to represent a linear compartmental operator 
defined on time interval</h2><span id='topic+BoundLinDecompOp-class'></span>

<h3>Description</h3>

<p>A S4 class to represent a linear compartmental operator 
defined on time interval
</p>

<hr>
<h2 id='BoundLinDecompOp+2CANY-method'>Creates an object of class BoundLinDecompOp</h2><span id='topic+BoundLinDecompOp+2CANY-method'></span>

<h3>Description</h3>

<p>Creates an object of class BoundLinDecompOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
BoundLinDecompOp(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundLinDecompOp+2B2CANY-method_+3A_map">map</code></td>
<td>
<p>An object of class different than UnBoundLinDecompOp</p>
</td></tr>
<tr><td><code id="BoundLinDecompOp+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to TimeMap</p>
</td></tr>
</table>

<hr>
<h2 id='BoundLinDecompOp+2CUnBoundLinDecompOp-method'>A converter</h2><span id='topic+BoundLinDecompOp+2CUnBoundLinDecompOp-method'></span>

<h3>Description</h3>

<p>The distinction between the classes BoundLinDecompOp and UnboundLinDecompOp exist for those functions, that should be only defined for objects of class UnBoundLinDecomp.
</p>
<p>Many functions however do not need extra methods for objects of class 
UnBoundLinDecompOp and just treat it as a BoundLinDecompOp which is defined
on the complete timeline (-Inf,+Inf). 
With its default arguments this function converts its map argument to a BoundLinDecompOp with just this domain. 
This is the most frequent internal use case. 
If starttime and endtime are provided the domain of the operator will be restricted [starttime,endtime].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundLinDecompOp'
BoundLinDecompOp(map, starttime = -Inf, endtime = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundLinDecompOp+2B2CUnBoundLinDecompOp-method_+3A_map">map</code></td>
<td>
<p>An object of class UnBoundLinDecompOp</p>
</td></tr>
<tr><td><code id="BoundLinDecompOp+2B2CUnBoundLinDecompOp-method_+3A_starttime">starttime</code></td>
<td>
<p>Begin of time interval map will be restricted to</p>
</td></tr>
<tr><td><code id="BoundLinDecompOp+2B2CUnBoundLinDecompOp-method_+3A_endtime">endtime</code></td>
<td>
<p>End of time interval map will be restricted to</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex'>automatic title</h2><span id='topic+by_PoolIndex'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex_+3A_obj">obj</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="by_PoolIndex_+3A_poolnames">poolNames</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="by_PoolIndex_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CConstantInFluxRate_by_PoolName+2CANY+2CANY-method'>new object with the source pool id converted to a PoolIndex if necessary</h2><span id='topic+by_PoolIndex+2CConstantInFluxRate_by_PoolName+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>new object with the source pool id converted to a PoolIndex if necessary
</p>
<p>new object with the source pool id converted to a PoolIndex if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInFluxRate_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)

## S4 method for signature 'ConstantInFluxRate_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CConstantInFluxRate_by_PoolName+2B2CANY+2B2CANY-method_+3A_obj">obj</code></td>
<td>
<p>and object of class ConstantInFluxRate_by_PoolName</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CConstantInFluxRate_by_PoolName+2B2CANY+2B2CANY-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CConstantInternalFluxRate_by_PoolName+2CANY+2CANY-method'>new object with the source pool id converted to a PoolName if necessary</h2><span id='topic+by_PoolIndex+2CConstantInternalFluxRate_by_PoolName+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>new object with the source pool id converted to a PoolName if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInternalFluxRate_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CConstantInternalFluxRate_by_PoolName+2B2CANY+2B2CANY-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantInternalFluxRate_by_PoolName</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CConstantInternalFluxRate_by_PoolName+2B2CANY+2B2CANY-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of the pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CConstantInternalFluxRateList_by_PoolName+2CANY+2CANY-method'>convert to a list indexed by pool names</h2><span id='topic+by_PoolIndex+2CConstantInternalFluxRateList_by_PoolName+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>convert to a list indexed by pool names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInternalFluxRateList_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CConstantInternalFluxRateList_by_PoolName+2B2CANY+2B2CANY-method_+3A_obj">obj</code></td>
<td>
<p>object of class ConstantInternalFluxRateList_by_PoolName</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CConstantInternalFluxRateList_by_PoolName+2B2CANY+2B2CANY-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CConstantOutFluxRate_by_PoolName+2CANY+2CANY-method'>new object with the source pool id converted to a PoolIndex if necessary</h2><span id='topic+by_PoolIndex+2CConstantOutFluxRate_by_PoolName+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>new object with the source pool id converted to a PoolIndex if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantOutFluxRate_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CConstantOutFluxRate_by_PoolName+2B2CANY+2B2CANY-method_+3A_obj">obj</code></td>
<td>
<p>object of class ConstantOutFluxRate_by_PoolName</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CConstantOutFluxRate_by_PoolName+2B2CANY+2B2CANY-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CConstantOutFluxRateList_by_PoolName+2CANY+2CANY-method'>convert to a list indexed by pool names</h2><span id='topic+by_PoolIndex+2CConstantOutFluxRateList_by_PoolName+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>convert to a list indexed by pool names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantOutFluxRateList_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CConstantOutFluxRateList_by_PoolName+2B2CANY+2B2CANY-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantOutFluxRateList_by_PoolName</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CConstantOutFluxRateList_by_PoolName+2B2CANY+2B2CANY-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of the pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2Cfunction+2Ccharacter+2Ccharacter-method'>convert a function f of to f_vec</h2><span id='topic+by_PoolIndex+2Cfunction+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>convert a function f of to f_vec
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2Cfunction+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>For this method a function, whose formal arguments must have names that are elements of the union of poolNames and timeSymbol</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2Cfunction+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>The ordered poolnames</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2Cfunction+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>The name of the argument of obj that represents time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>f_vec(vec,t)  A new function that extracts the arguments of obj from a complete vector of state variables and the time argument t and applies the original function to these arguments
The ode solvers used by SoilR expect a vector valued function of the state vector and time that represents the derivative.
The components of this vector are scalar functions of a vector argument and time. It is possible for the  user to define such functions directly, but the definition always depends on the order of state variables. Furthermore these functions usually do not use the complete state vector but only some parts of it.
It is much clearer more intuitive and less error prone to be able to define 
functions that have only formal arguments that are used. 
This is what this method is used for.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>leaf_resp=function(leaf_pool_content){leaf_pool_content*4}
leaf_resp(1)
poolNames=c(
   "some_thing"
  ,"some_thing_else"
  ,"some_thing_altogther"
  ,"leaf_pool_content"
)
leaf_resp_vec=by_PoolIndex(leaf_resp,poolNames,timeSymbol='t')
# The result is the same since the only the forth position in the vector
leaf_resp_vec(c(1,27,3,1),5) 
</code></pre>

<hr>
<h2 id='by_PoolIndex+2CInFlux_by_PoolName+2Ccharacter+2Ccharacter-method'>Convert the pool names to indices</h2><span id='topic+by_PoolIndex+2CInFlux_by_PoolName+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Convert the pool names to indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InFlux_by_PoolName,character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CInFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CInFluxList_by_PoolName+2Ccharacter+2Ccharacter-method'>Transform pool names to indices</h2><span id='topic+by_PoolIndex+2CInFluxList_by_PoolName+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Transform pool names to indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InFluxList_by_PoolName,character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CInFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CInternalFlux_by_PoolName+2Ccharacter+2Ccharacter-method'>automatic title</h2><span id='topic+by_PoolIndex+2CInternalFlux_by_PoolName+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InternalFlux_by_PoolName,character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CInternalFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInternalFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInternalFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CInternalFluxList_by_PoolName+2Ccharacter+2Ccharacter-method'>automatic title</h2><span id='topic+by_PoolIndex+2CInternalFluxList_by_PoolName+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InternalFluxList_by_PoolName,character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CInternalFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInternalFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CInternalFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2COutFlux_by_PoolName+2Ccharacter+2Ccharacter-method'>automatic title</h2><span id='topic+by_PoolIndex+2COutFlux_by_PoolName+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutFlux_by_PoolName,character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2COutFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2COutFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2COutFlux_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2COutFluxList_by_PoolName+2Ccharacter+2Ccharacter-method'>automatic title</h2><span id='topic+by_PoolIndex+2COutFluxList_by_PoolName+2Ccharacter+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'OutFluxList_by_PoolName,character,character'
by_PoolIndex(obj, poolNames, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2COutFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2COutFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2COutFluxList_by_PoolName+2B2Ccharacter+2B2Ccharacter-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolIndex+2CPoolConnection_by_PoolName+2CANY+2CANY-method'>constructor from strings of the form 'x-&gt;y'
new object with the source pool id and the destination pool id guaranteed to be of class PoolIndex</h2><span id='topic+by_PoolIndex+2CPoolConnection_by_PoolName+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>converts the ids if necessary otherwise returns an 
identical object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PoolConnection_by_PoolName,ANY,ANY'
by_PoolIndex(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolIndex+2B2CPoolConnection_by_PoolName+2B2CANY+2B2CANY-method_+3A_obj">obj</code></td>
<td>
<p>an object of class PoolConnection_by_PoolName</p>
</td></tr>
<tr><td><code id="by_PoolIndex+2B2CPoolConnection_by_PoolName+2B2CANY+2B2CANY-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName'>automatic title</h2><span id='topic+by_PoolName'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName_+3A_obj">obj</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="by_PoolName_+3A_poolnames">poolNames</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName+2CConstantInFlux_by_PoolIndex-method'>new object with the source pool id converted to a PoolIndex if necessary</h2><span id='topic+by_PoolName+2CConstantInFlux_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>new object with the source pool id converted to a PoolIndex if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInFlux_by_PoolIndex'
by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName+2B2CConstantInFlux_by_PoolIndex-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantInFlux_by_PoolIndex</p>
</td></tr>
<tr><td><code id="by_PoolName+2B2CConstantInFlux_by_PoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName+2CConstantInFluxList_by_PoolIndex-method'>convert to a list indexed by pool names</h2><span id='topic+by_PoolName+2CConstantInFluxList_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>convert to a list indexed by pool names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInFluxList_by_PoolIndex'
by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName+2B2CConstantInFluxList_by_PoolIndex-method_+3A_obj">obj</code></td>
<td>
<p>object of class ConstantInFluxList_by_PoolIndex</p>
</td></tr>
<tr><td><code id="by_PoolName+2B2CConstantInFluxList_by_PoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName+2CConstantInFluxRate_by_PoolIndex-method'>new object with the source pool id converted to a PoolIndex if necessary</h2><span id='topic+by_PoolName+2CConstantInFluxRate_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>new object with the source pool id converted to a PoolIndex if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInFluxRate_by_PoolIndex'
by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName+2B2CConstantInFluxRate_by_PoolIndex-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantInFluxRate_by_PoolIndex</p>
</td></tr>
<tr><td><code id="by_PoolName+2B2CConstantInFluxRate_by_PoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName+2CConstantInternalFluxRateList_by_PoolIndex-method'>convert to a list indexed by pool names</h2><span id='topic+by_PoolName+2CConstantInternalFluxRateList_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>convert to a list indexed by pool names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInternalFluxRateList_by_PoolIndex'
by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName+2B2CConstantInternalFluxRateList_by_PoolIndex-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantInternalFluxRateList_by_PoolIndex</p>
</td></tr>
<tr><td><code id="by_PoolName+2B2CConstantInternalFluxRateList_by_PoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName+2CConstantOutFluxRate_by_PoolIndex-method'>new object with the source pool id converted to a PoolName if necessary</h2><span id='topic+by_PoolName+2CConstantOutFluxRate_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>This method exists only for classes that do not contain functions of 
the state_variables since we cannot automatically translate functions 
with a state vector arguments to functions of the respective state variables
which would require symbolic computations.
The reverse direction is always possible and is therefore 
the preferred way to input 
rate functions that depend on state variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantOutFluxRate_by_PoolIndex'
by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName+2B2CConstantOutFluxRate_by_PoolIndex-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantOutFluxRate_by_PoolIndex</p>
</td></tr>
<tr><td><code id="by_PoolName+2B2CConstantOutFluxRate_by_PoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='by_PoolName+2CConstantOutFluxRateList_by_PoolIndex-method'>convert to a list indexed by pool names</h2><span id='topic+by_PoolName+2CConstantOutFluxRateList_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>convert to a list indexed by pool names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantOutFluxRateList_by_PoolIndex'
by_PoolName(obj, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="by_PoolName+2B2CConstantOutFluxRateList_by_PoolIndex-method_+3A_obj">obj</code></td>
<td>
<p>an object of class ConstantOutFluxRateList_by_PoolIndex</p>
</td></tr>
<tr><td><code id="by_PoolName+2B2CConstantOutFluxRateList_by_PoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='C14Atm'>Atmospheric 14C fraction</h2><span id='topic+C14Atm'></span>

<h3>Description</h3>

<p>Atmospheric 14C fraction in units of Delta14C for the bomb period in the
northern hemisphere.
</p>
<p>@note
This dataset will be deprecated soon. Please use <a href="#topic+C14Atm_NH">C14Atm_NH</a> or
<a href="#topic+Hua2013">Hua2013</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C14Atm)
</code></pre>


<h3>Format</h3>

<p>A data frame with 108 observations on the following 2 variables.
</p>
 
<ol>
<li><p> V1 a numeric vector 
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#Notice that C14Atm is a shorter version of C14Atm_NH
require("SoilR")
data("C14Atm_NH")
plot(C14Atm_NH,type="l")
lines(C14Atm,col=2)

</code></pre>

<hr>
<h2 id='C14Atm_NH'>Post-bomb atmospheric 14C fraction</h2><span id='topic+C14Atm_NH'></span>

<h3>Description</h3>

<p>Atmospheric 14C concentrations for the post-bomb period expressed as Delta 14C in per mile. This dataset contains a combination of observations from locations in Europe and North America. It is representative for the Northern Hemisphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(C14Atm_NH)
</code></pre>


<h3>Format</h3>

<p>A data frame with 111 observations on the following 2 variables.
</p>
 
<ol>
<li><p> YEAR a numeric vector with year of measurement.
</p>
</li>
<li><p> Atmosphere
a numeric vector with the Delta 14 value of atmospheric CO2 in per mil.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>plot(C14Atm_NH,type="l")
</code></pre>

<hr>
<h2 id='CenturyModel'>Implementation of the Century model</h2><span id='topic+CenturyModel'></span>

<h3>Description</h3>

<p>This function implements the Century model as described in Parton et al.
(1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CenturyModel(
  t,
  ks = c(STR.surface = 0.076, MET.surface = 0.28, STR.belowgroun = 0.094, MET.belowground
    = 0.35, ACT = 0.14, SLW = 0.0038, PAS = 0.00013),
  C0 = rep(0, 7),
  surfaceIn,
  soilIn,
  LN,
  Ls,
  clay = 0.2,
  silt = 0.45,
  xi = 1,
  xi_lag = 0,
  solver = deSolve.lsoda.wrapper
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CenturyModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 7 containing the values of the decomposition
rates for the different pools. Units in per week.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 7 containing the initial amount of carbon for
the 7 pools.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_surfacein">surfaceIn</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of aboveground litter
inputs to the soil surface by time (mass per area per week).</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_soilin">soilIn</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of belowground litter
inputs to the soil by time (mass per area per week).</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_ln">LN</code></td>
<td>
<p>A scalar representing the lignin to nitrogen ratio of the plant
residue inputs.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_ls">Ls</code></td>
<td>
<p>A scalar representing the fraction of structural material that is
lignin.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_clay">clay</code></td>
<td>
<p>Proportion of clay in mineral soil.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_silt">silt</code></td>
<td>
<p>Proportion of silt in mineral soil.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_xi">xi</code></td>
<td>
<p>A scalar, data.frame, function or anything that can be converted
to a scalar function of time <code><a href="#topic+ScalarTimeMap-class">ScalarTimeMap</a></code>  object
specifying the external (environmental and/or edaphic) effects on
decomposition rates.</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_xi_lag">xi_lag</code></td>
<td>
<p>A time shift/delay  for the automatically 
created time dependent function xi(t)</p>
</td></tr>
<tr><td><code id="CenturyModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is one of the few examples that internally make use of
the new infrastructure for flux based descriptions of models (see examples).
</p>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Parton, W.J, D.S. Schimel, C.V. Cole, and D.S. Ojima. 1987.
Analysis of factors controlling soil organic matter levels in Great Plain
grasslands. Soil Science Society of America Journal 51: 1173&ndash;1179. Sierra,
C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil organic matter
decomposition: the SoilR package version 1.0. Geoscientific Model
Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RothCModel">RothCModel</a></code>. There are other
<code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more general functions like
<code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mnths=seq(0,100)
APPT=50 # Assume 50 cm annual precipitation
Pmax=-40+7.7*APPT # Max aboveground production
Rmax=100+7.0*APPT # Max belowground production
abvgIn=Pmax/(Pmax+Rmax)
blgIn=Rmax/(Pmax+Rmax)

cm=CenturyModel(t=mnths, surfaceIn = abvgIn, soilIn = blgIn, LN=0.5, Ls=0.1)
Ct=getC(cm)

poolNames=c("Surface structural", "Surface metabolic", "Belowground structural",
               "Belowground metabolic", "Active SOM", "Slow SOM", "Passive SOM")
matplot(mnths,Ct, type="l", lty=1, col=1:7, xlab="Time (months)", ylab="Carbon stock ")
legend("topleft", poolNames, lty=1, col=1:7, bty="n")
</code></pre>

<hr>
<h2 id='CenturyModel14'>Implementation of a radiocarbon version of the Century model</h2><span id='topic+CenturyModel14'></span>

<h3>Description</h3>

<p>This function implements a radiocarbon version of the Century model as described in Parton et al.
(1987).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CenturyModel14(
  t,
  ks = 52 * c(STR.surface = 0.076, MET.surface = 0.28, STR.belowgroun = 0.094,
    MET.belowground = 0.35, ACT = 0.14, SLW = 0.0038, PAS = 0.00013),
  C0 = rep(0, 7),
  surfaceIn,
  soilIn,
  F0_Delta14C,
  LN,
  Ls,
  clay = 0.2,
  silt = 0.45,
  xi = 1,
  inputFc,
  lag = 0,
  lambda = -0.0001209681,
  xi_lag = 0,
  solver = deSolve.lsoda.wrapper
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CenturyModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 7 containing the values of the decomposition
rates for the different pools. Units in per year.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 7 containing the initial amount of carbon for
the 7 pools.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_surfacein">surfaceIn</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of aboveground litter
inputs to the soil surface by time (mass per area per year).</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_soilin">soilIn</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of belowground litter
inputs to the soil by time (mass per area per year).</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 7 containing the initial fraction of
radiocarbon for the 7 pools in Delta14C format.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_ln">LN</code></td>
<td>
<p>A scalar representing the lignin to nitrogen ratio of the plant
residue inputs.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_ls">Ls</code></td>
<td>
<p>A scalar representing the fraction of structural material that is
lignin.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_clay">clay</code></td>
<td>
<p>Proportion of clay in mineral soil.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_silt">silt</code></td>
<td>
<p>Proportion of silt in mineral soil.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar, data.frame, function or anything that can be converted
to a scalar function of time <code><a href="#topic+ScalarTimeMap-class">ScalarTimeMap</a></code>  object
specifying the external (environmental and/or edaphic) effects on
decomposition rates.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_lag">lag</code></td>
<td>
<p>A time shift/delay for the radiocarbon inputs</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_xi_lag">xi_lag</code></td>
<td>
<p>A time shift/delay  for the automatically 
created time dependent function xi(t)</p>
</td></tr>
<tr><td><code id="CenturyModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Parton, W.J, D.S. Schimel, C.V. Cole, and D.S. Ojima. 1987.
Analysis of factors controlling soil organic matter levels in Great Plain
grasslands. Soil Science Society of America Journal 51: 1173&ndash;1179. Sierra,
C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil organic matter
decomposition: the SoilR package version 1.0. Geoscientific Model
Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RothCModel">RothCModel</a></code>. There are other
<code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more general functions like
<code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cal_yrs=seq(1900,2015, by=1/12)
APPT=50 # Assume 50 cm annual precipitation
Pmax=-40+7.7*APPT # Max aboveground production
Rmax=100+7.0*APPT # Max belowground production
abvgIn=52*Pmax/(Pmax+Rmax)
blgIn=52*Rmax/(Pmax+Rmax)
AtmC14=Graven2017[,c("Year.AD", "NH")]

cm=CenturyModel14(t=cal_yrs, surfaceIn = abvgIn, soilIn = blgIn, 
                  F0_Delta14C=rep(0,7), inputFc=AtmC14, LN=0.5, Ls=0.1)
C14t=getF14(cm)

poolNames=c("Surface structural", "Surface metabolic", "Belowground structural",
               "Belowground metabolic", "Active SOM", "Slow SOM", "Passive SOM")
plot(AtmC14, type="l", ylab="Delta 14C (per mil)")
matlines(cal_yrs,C14t, lty=1, col=2:8)
legend("topleft", poolNames, lty=1, col=2:8, bty="n")
</code></pre>

<hr>
<h2 id='check_duplicate_pool_names'>helper function</h2><span id='topic+check_duplicate_pool_names'></span>

<h3>Description</h3>

<p>Check that poolNames are unique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_duplicate_pool_names(poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_duplicate_pool_names_+3A_poolnames">poolNames</code></td>
<td>
<p>character vector which will be tested for duplicats</p>
</td></tr>
</table>

<hr>
<h2 id='check_id_length'>helper function to check that the length of the argument is exactly 1</h2><span id='topic+check_id_length'></span>

<h3>Description</h3>

<p>helper function to check that the length of the argument is exactly 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_id_length(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_id_length_+3A_id">id</code></td>
<td>
<p>Either a string or a number</p>
</td></tr>
</table>

<hr>
<h2 id='check_pool_ids'>Check pool ids</h2><span id='topic+check_pool_ids'></span>

<h3>Description</h3>

<p>Check pool ids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pool_ids(obj, pools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pool_ids_+3A_obj">obj</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="check_pool_ids_+3A_pools">pools</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='check_pool_ids+2CPoolConnection_by_PoolIndex+2Cinteger-method'>automatic title</h2><span id='topic+check_pool_ids+2CPoolConnection_by_PoolIndex+2Cinteger-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PoolConnection_by_PoolIndex,integer'
check_pool_ids(obj, pools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pool_ids+2B2CPoolConnection_by_PoolIndex+2B2Cinteger-method_+3A_obj">obj</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="check_pool_ids+2B2CPoolConnection_by_PoolIndex+2B2Cinteger-method_+3A_pools">pools</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='computeResults'>Computes results</h2><span id='topic+computeResults'></span>

<h3>Description</h3>

<p>Computes results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeResults(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeResults_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='computeResults+2CMCSim-method'>automatic title</h2><span id='topic+computeResults+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
computeResults(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeResults+2B2CMCSim-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInFlux_by_PoolIndex-class'>class for a constant influx to a single pool identified by index</h2><span id='topic+ConstantInFlux_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>class for a constant influx to a single pool identified by index
</p>

<hr>
<h2 id='ConstantInFlux_by_PoolName-class'>class for a constant influx to a single pool identified by pool name</h2><span id='topic+ConstantInFlux_by_PoolName-class'></span>

<h3>Description</h3>

<p>class for a constant influx to a single pool identified by pool name
</p>

<hr>
<h2 id='ConstantInFluxList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+ConstantInFluxList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInFluxList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInFluxList_by_PoolIndex-class'>Subclass of list that is guaranteed to contain only elements of type
<a href="#topic+ConstantInFlux_by_PoolIndex-class">ConstantInFlux_by_PoolIndex</a></h2><span id='topic+ConstantInFluxList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>Subclass of list that is guaranteed to contain only elements of type
<a href="#topic+ConstantInFlux_by_PoolIndex-class">ConstantInFlux_by_PoolIndex</a>
</p>

<hr>
<h2 id='ConstantInFluxList_by_PoolIndex+2CConstInFluxes-method'>constructor from ConstInFluxes</h2><span id='topic+ConstantInFluxList_by_PoolIndex+2CConstInFluxes-method'></span>

<h3>Description</h3>

<p>constructor from ConstInFluxes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstInFluxes'
ConstantInFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInFluxList_by_PoolIndex+2B2CConstInFluxes-method_+3A_object">object</code></td>
<td>
<p>An object of class <a href="#topic+ConstInFluxes-class">ConstInFluxes</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+ConstantInFluxList_by_PoolIndex-class">ConstantInFluxList_by_PoolIndex</a>
</p>

<hr>
<h2 id='ConstantInFluxList_by_PoolIndex+2Clist-method'>constructor from a normal list</h2><span id='topic+ConstantInFluxList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ConstantInFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInFluxList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+ConstantInFlux_by_PoolIndex-class">ConstantInFlux_by_PoolIndex</a> or 
a list where the names of the elements are strings of the form
'1-&gt;3' (for the flux rate from pool 1 to 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantInFluxList_by_PoolIndex-class">ConstantInFluxList_by_PoolIndex</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='ConstantInFluxList_by_PoolIndex+2Cnumeric-method'>constructor from numeric vector</h2><span id='topic+ConstantInFluxList_by_PoolIndex+2Cnumeric-method'></span>

<h3>Description</h3>

<p>constructor from numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
ConstantInFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInFluxList_by_PoolIndex+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInFluxList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+ConstantInFluxList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInFluxList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInFluxList_by_PoolName-class'>Subclass of list that is guaranteed to contain only elements of type
<a href="#topic+ConstantInFlux_by_PoolName-class">ConstantInFlux_by_PoolName</a></h2><span id='topic+ConstantInFluxList_by_PoolName-class'></span>

<h3>Description</h3>

<p>Subclass of list that is guaranteed to contain only elements of type
<a href="#topic+ConstantInFlux_by_PoolName-class">ConstantInFlux_by_PoolName</a>
</p>

<hr>
<h2 id='ConstantInFluxRate_by_PoolIndex-class'>Describes a flux rates.</h2><span id='topic+ConstantInFluxRate_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of negative rates
or in accidental confusion with fluxes.
Instances are usually automatically created from data.
If the state variables are known indices can be converted to pool names.
</p>

<hr>
<h2 id='ConstantInFluxRate_by_PoolName'>Constructor for the class with the same name</h2><span id='topic+ConstantInFluxRate_by_PoolName'></span>

<h3>Description</h3>

<p>Constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInFluxRate_by_PoolName(destinationName, rate_constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInFluxRate_by_PoolName_+3A_destinationname">destinationName</code></td>
<td>
<p>Index of the receiving pool (positive integer)</p>
</td></tr>
<tr><td><code id="ConstantInFluxRate_by_PoolName_+3A_rate_constant">rate_constant</code></td>
<td>
<p>Rate (Flux/content) positive real number</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInFluxRate_by_PoolName-class'>Describes a flux rates.</h2><span id='topic+ConstantInFluxRate_by_PoolName-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of negative rates
or in accidental confusion with fluxes.
Instances are usually automatically created from data.
If the state variables are known indices can be converted to pool names.
</p>
<p>The purpose is to avoid creation of negative rates
or in accidental confusion with fluxes.
Instances are usually automatically created from data.
If the state variables are known indices can be converted to pool names.
</p>
<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>
<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+ConstantInternalFluxRate_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInternalFluxRate_by_PoolIndex(
  sourceIndex,
  destinationIndex,
  src_to_dest,
  rate_constant
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>index of source pool</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex_+3A_destinationindex">destinationIndex</code></td>
<td>
<p>index of destination pool</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>flux rate</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex_+3A_rate_constant">rate_constant</code></td>
<td>
<p>rate constant</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolIndex-class'>S4 class representing a constant internal flux rate</h2><span id='topic+ConstantInternalFluxRate_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>The class is used to dispatch specific methods for the creation of the compartmental matrix which is simplified in case of constant rates.
</p>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolIndex+2Cnumeric+2Cnumeric+2Cmissing+2Cnumeric-method'>automatic title</h2><span id='topic+ConstantInternalFluxRate_by_PoolIndex+2Cnumeric+2Cnumeric+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric,missing,numeric'
ConstantInternalFluxRate_by_PoolIndex(
  sourceIndex,
  destinationIndex,
  rate_constant
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cnumeric-method_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cnumeric-method_+3A_destinationindex">destinationIndex</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolIndex+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cnumeric-method_+3A_rate_constant">rate_constant</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+ConstantInternalFluxRate_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInternalFluxRate_by_PoolName(
  sourceName,
  destinationName,
  src_to_dest,
  rate_constant
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName_+3A_sourcename">sourceName</code></td>
<td>
<p>name of the source pool</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName_+3A_destinationname">destinationName</code></td>
<td>
<p>name of the destination pool</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>flux rate</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName_+3A_rate_constant">rate_constant</code></td>
<td>
<p>rate constant</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolName-class'>S4-class to represent a constant internal flux rate with source and target indexed by name</h2><span id='topic+ConstantInternalFluxRate_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4-class to represent a constant internal flux rate with source and target indexed by name
</p>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolName+2Ccharacter+2Ccharacter+2Cmissing+2Cnumeric-method'>constructor with argument conversion</h2><span id='topic+ConstantInternalFluxRate_by_PoolName+2Ccharacter+2Ccharacter+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>constructor with argument conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character,character,missing,numeric'
ConstantInternalFluxRate_by_PoolName(
  sourceName,
  destinationName,
  rate_constant
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName+2B2Ccharacter+2B2Ccharacter+2B2Cmissing+2B2Cnumeric-method_+3A_sourcename">sourceName</code></td>
<td>
<p>name of source pool</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName+2B2Ccharacter+2B2Ccharacter+2B2Cmissing+2B2Cnumeric-method_+3A_destinationname">destinationName</code></td>
<td>
<p>name of destination pool</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName+2B2Ccharacter+2B2Ccharacter+2B2Cmissing+2B2Cnumeric-method_+3A_rate_constant">rate_constant</code></td>
<td>
<p>a value of the rate constant</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRate_by_PoolName+2Cmissing+2Cmissing+2Ccharacter+2Cnumeric-method'>constructor from strings of the form 'a-&gt;b'</h2><span id='topic+ConstantInternalFluxRate_by_PoolName+2Cmissing+2Cmissing+2Ccharacter+2Cnumeric-method'></span>

<h3>Description</h3>

<p>constructor from strings of the form 'a-&gt;b'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,character,numeric'
ConstantInternalFluxRate_by_PoolName(src_to_dest, rate_constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName+2B2Cmissing+2B2Cmissing+2B2Ccharacter+2B2Cnumeric-method_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>a string indicating the source to destination pools</p>
</td></tr>
<tr><td><code id="ConstantInternalFluxRate_by_PoolName+2B2Cmissing+2B2Cmissing+2B2Ccharacter+2B2Cnumeric-method_+3A_rate_constant">rate_constant</code></td>
<td>
<p>a value of the rate constant</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+ConstantInternalFluxRateList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInternalFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRateList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolIndex-class'>Describes a list of flux rates.</h2><span id='topic+ConstantInternalFluxRateList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolIndex+2Clist-method'>constructor from a normal list</h2><span id='topic+ConstantInternalFluxRateList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ConstantInternalFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRateList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+ConstantInternalFluxRate_by_PoolIndex-class">ConstantInternalFluxRate_by_PoolIndex</a> or 
a list where the names of the elements are strings of the form
'1-&gt;3' (for the flux rate from pool 1 to 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantInternalFluxRateList_by_PoolIndex-class">ConstantInternalFluxRateList_by_PoolIndex</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolIndex+2Cnumeric-method'>automatic title</h2><span id='topic+ConstantInternalFluxRateList_by_PoolIndex+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
ConstantInternalFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRateList_by_PoolIndex+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+ConstantInternalFluxRateList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantInternalFluxRateList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRateList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolName-class'>Describes a list of flux rates.</h2><span id='topic+ConstantInternalFluxRateList_by_PoolName-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>

<hr>
<h2 id='ConstantInternalFluxRateList_by_PoolName+2Clist-method'>Constructor from a normal list of fluxes</h2><span id='topic+ConstantInternalFluxRateList_by_PoolName+2Clist-method'></span>

<h3>Description</h3>

<p>Constructor from a normal list of fluxes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ConstantInternalFluxRateList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantInternalFluxRateList_by_PoolName+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+ConstantInternalFluxRate_by_PoolName-class">ConstantInternalFluxRate_by_PoolName</a> or 
a list where the names of the elements are strings of the form
'somePool-&gt;someOtherPool' (for the flux rate from pool somePool to
someOtherPool)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantInternalFluxRateList_by_PoolName-class">ConstantInternalFluxRateList_by_PoolName</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='ConstantOutFluxRate_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+ConstantOutFluxRate_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantOutFluxRate_by_PoolIndex(sourceIndex, rate_constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRate_by_PoolIndex_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>index of the source pool</p>
</td></tr>
<tr><td><code id="ConstantOutFluxRate_by_PoolIndex_+3A_rate_constant">rate_constant</code></td>
<td>
<p>rate of output flux</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantOutFluxRate_by_PoolIndex-class'>S4 Class to represent a single constant out-flux rate with the 
source pool specified by an index</h2><span id='topic+ConstantOutFluxRate_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>S4 Class to represent a single constant out-flux rate with the 
source pool specified by an index
</p>

<hr>
<h2 id='ConstantOutFluxRate_by_PoolIndex+2Cnumeric+2Cnumeric-method'>automatic title</h2><span id='topic+ConstantOutFluxRate_by_PoolIndex+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,numeric'
ConstantOutFluxRate_by_PoolIndex(sourceIndex, rate_constant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRate_by_PoolIndex+2B2Cnumeric+2B2Cnumeric-method_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="ConstantOutFluxRate_by_PoolIndex+2B2Cnumeric+2B2Cnumeric-method_+3A_rate_constant">rate_constant</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantOutFluxRate_by_PoolName-class'>S4 Class to represent a single constant out-flux rate with the 
source pool specified by name</h2><span id='topic+ConstantOutFluxRate_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4 Class to represent a single constant out-flux rate with the 
source pool specified by name
</p>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+ConstantOutFluxRateList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantOutFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRateList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolIndex-class'>Describes a list of flux rates.</h2><span id='topic+ConstantOutFluxRateList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolIndex+2Clist-method'>constructor from a normal list</h2><span id='topic+ConstantOutFluxRateList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ConstantOutFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRateList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+ConstantOutFluxRate_by_PoolIndex-class">ConstantOutFluxRate_by_PoolIndex</a> or 
a list where the names of the elements are integer strings of the form
'3' (for the flux rate from pool 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantOutFluxRateList_by_PoolIndex-class">ConstantOutFluxRateList_by_PoolIndex</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolIndex+2Cnumeric-method'>automatic title</h2><span id='topic+ConstantOutFluxRateList_by_PoolIndex+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
ConstantOutFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRateList_by_PoolIndex+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+ConstantOutFluxRateList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstantOutFluxRateList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRateList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolName-class'>Describes a list of flux rates.</h2><span id='topic+ConstantOutFluxRateList_by_PoolName-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolName+2Clist-method'>constructor from a normal list</h2><span id='topic+ConstantOutFluxRateList_by_PoolName+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
ConstantOutFluxRateList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRateList_by_PoolName+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+ConstantOutFluxRate_by_PoolName-class">ConstantOutFluxRate_by_PoolName</a> or 
a list where the names of the elements are integer strings of the form
'3' (for the flux rate from pool 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantOutFluxRateList_by_PoolName-class">ConstantOutFluxRateList_by_PoolName</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='ConstantOutFluxRateList_by_PoolName+2Cnumeric-method'>automatic title</h2><span id='topic+ConstantOutFluxRateList_by_PoolName+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
ConstantOutFluxRateList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstantOutFluxRateList_by_PoolName+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstFc'>creates an object containing the initial values for the 14C fraction needed
to create models in SoilR</h2><span id='topic+ConstFc'></span>

<h3>Description</h3>

<p>The function returns an object of class ConstFc which is a building block
for any 14C model in SoilR. The building blocks of a model have to keep
information about the formats their data are in, because the high level
function dealing with the models have to know. This function is actually a
convenient wrapper for a call to R's standard constructor new, to hide its
complexity from the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstFc(values = c(0), format = "Delta14C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstFc_+3A_values">values</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="ConstFc_+3A_format">format</code></td>
<td>
<p>a character string describing the format e.g. &quot;Delta14C&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class ConstFc that contains data and a format
description that can later be used to convert the data into other formats if
the conversion is implemented.
</p>

<hr>
<h2 id='ConstFc-class'>S4 class representing a constant 14C fraction</h2><span id='topic+ConstFc-class'></span>

<h3>Description</h3>

<p>S4 class representing a constant 14C fraction
</p>

<hr>
<h2 id='ConstInFluxes'>Constant input fluxes</h2><span id='topic+ConstInFluxes'></span>

<h3>Description</h3>

<p>Constant input fluxes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstInFluxes(map, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstInFluxes_+3A_map">map</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ConstInFluxes_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='ConstInFluxes-class'>S4 class for a constant influx vector</h2><span id='topic+ConstInFluxes-class'></span>

<h3>Description</h3>

<p>It is mainly used to dispatch S4-methods for computations that 
are valid only if the influx is constant.
This knowledge can either be used to speed up computations or to decide if they are
possible at all.
E.g. the computation of equilibria for a model run requires autonomy of the model which 
requires the influxes to be time independent. If the model is linear  
and compartmental then the (unique) equilibrium can be computed.
Accordingly a method with ConstInFluxes in the signature can be implemented, whereas 
none would be available for a general InFluxes argument.
</p>

<hr>
<h2 id='ConstInFluxes+2CConstantInFluxList_by_PoolIndex+2Cnumeric-method'>automatic title</h2><span id='topic+ConstInFluxes+2CConstantInFluxList_by_PoolIndex+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInFluxList_by_PoolIndex,numeric'
ConstInFluxes(map, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstInFluxes+2B2CConstantInFluxList_by_PoolIndex+2B2Cnumeric-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="ConstInFluxes+2B2CConstantInFluxList_by_PoolIndex+2B2Cnumeric-method_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstInFluxes+2Cnumeric+2CANY-method'>automatic title</h2><span id='topic+ConstInFluxes+2Cnumeric+2CANY-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric,ANY'
ConstInFluxes(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstInFluxes+2B2Cnumeric+2B2CANY-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='ConstLinDecompOp'>Generic constructor for the class with the same name</h2><span id='topic+ConstLinDecompOp'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstLinDecompOp(
  mat,
  internal_flux_rates,
  out_flux_rates,
  numberOfPools,
  poolNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstLinDecompOp_+3A_mat">mat</code></td>
<td>
<p>a square compartmental matrix</p>
</td></tr>
<tr><td><code id="ConstLinDecompOp_+3A_internal_flux_rates">internal_flux_rates</code></td>
<td>
<p>rates of internal transfers among pools</p>
</td></tr>
<tr><td><code id="ConstLinDecompOp_+3A_out_flux_rates">out_flux_rates</code></td>
<td>
<p>rates of transfer out of poolss</p>
</td></tr>
<tr><td><code id="ConstLinDecompOp_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>total number of pools in the system</p>
</td></tr>
<tr><td><code id="ConstLinDecompOp_+3A_poolnames">poolNames</code></td>
<td>
<p>names of all pools</p>
</td></tr>
</table>

<hr>
<h2 id='ConstLinDecompOp_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+ConstLinDecompOp_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstLinDecompOp_by_PoolName(internal_flux_rates, out_flux_rates, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstLinDecompOp_by_PoolName_+3A_internal_flux_rates">internal_flux_rates</code></td>
<td>
<p>rates of transfer among pools</p>
</td></tr>
<tr><td><code id="ConstLinDecompOp_by_PoolName_+3A_out_flux_rates">out_flux_rates</code></td>
<td>
<p>rates out of pools</p>
</td></tr>
<tr><td><code id="ConstLinDecompOp_by_PoolName_+3A_poolnames">poolNames</code></td>
<td>
<p>names of the pools</p>
</td></tr>
</table>

<hr>
<h2 id='ConstLinDecompOp-class'>A class to represent a constant (=nonautonomous,linear) compartmental matrix 
or equivalently a combination of ordered constant internal flux rates and 
constant out flux rates.</h2><span id='topic+ConstLinDecompOp-class'></span>

<h3>Description</h3>

<p>A class to represent a constant (=nonautonomous,linear) compartmental matrix 
or equivalently a combination of ordered constant internal flux rates and 
constant out flux rates.
</p>

<hr>
<h2 id='ConstLinDecompOp+2Cmatrix+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'>Constructor of object of ConstLinDecompOp class</h2><span id='topic+ConstLinDecompOp+2Cmatrix+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Constructor of object of ConstLinDecompOp class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,missing,missing,missing,missing'
ConstLinDecompOp(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstLinDecompOp+2B2Cmatrix+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_mat">mat</code></td>
<td>
<p>a compartmental matrix</p>
</td></tr>
</table>

<hr>
<h2 id='ConstLinDecompOpWithLinearScalarFactor'>Generic constructor for the class with the same name</h2><span id='topic+ConstLinDecompOpWithLinearScalarFactor'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConstLinDecompOpWithLinearScalarFactor(
  mat,
  internal_flux_rates,
  out_flux_rates,
  numberOfPools,
  xi
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConstLinDecompOpWithLinearScalarFactor_+3A_mat">mat</code></td>
<td>
<p>a square compartmental matrix</p>
</td></tr>
<tr><td><code id="ConstLinDecompOpWithLinearScalarFactor_+3A_internal_flux_rates">internal_flux_rates</code></td>
<td>
<p>internal transfer rates among pools</p>
</td></tr>
<tr><td><code id="ConstLinDecompOpWithLinearScalarFactor_+3A_out_flux_rates">out_flux_rates</code></td>
<td>
<p>rates out of pools</p>
</td></tr>
<tr><td><code id="ConstLinDecompOpWithLinearScalarFactor_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>number of pools in the system</p>
</td></tr>
<tr><td><code id="ConstLinDecompOpWithLinearScalarFactor_+3A_xi">xi</code></td>
<td>
<p>rate modifier for the entire matrix</p>
</td></tr>
</table>

<hr>
<h2 id='ConstLinDecompOpWithLinearScalarFactor-class'>A class to represent a constant (=nonautonomous,linear) compartmental matrix 
with a time dependent (linear) scalar pre factor 
This is a special case of a linear compartmental operator/matrix</h2><span id='topic+ConstLinDecompOpWithLinearScalarFactor-class'></span>

<h3>Description</h3>

<p>A class to represent a constant (=nonautonomous,linear) compartmental matrix 
with a time dependent (linear) scalar pre factor 
This is a special case of a linear compartmental operator/matrix
</p>

<hr>
<h2 id='cycling'>Cycling analysis of compartmental matrices</h2><span id='topic+cycling'></span>

<h3>Description</h3>

<p>Computes the fundamental matrix N, and the expected number of steps from a
compartmental matrix A
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycling(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycling_+3A_a">A</code></td>
<td>
<p>A compartmental linear square matrix with cycling rates in the
diagonal and transfer rates in the off-diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 objects: the fundamental matrix N, and the expected
number of steps Et.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+systemAge">systemAge</a></code>
</p>

<hr>
<h2 id='DecompOp-class'>S4-class to represent compartmental operators</h2><span id='topic+DecompOp-class'></span>

<h3>Description</h3>

<p>S4-class to represent compartmental operators
</p>

<hr>
<h2 id='DecompositionOperator-class'>automatic title</h2><span id='topic+DecompositionOperator-class'></span>

<h3>Description</h3>

<p>automatic title
</p>

<hr>
<h2 id='Delta14C'>Conversion of radiocarbon values</h2><span id='topic+Delta14C'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delta14C(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta14C_+3A_f">F</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='Delta14C_from_AbsoluteFractionModern'>Conversion of radiocarbon values</h2><span id='topic+Delta14C_from_AbsoluteFractionModern'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Delta14C_from_AbsoluteFractionModern(AbsoluteFractionModern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta14C_from_AbsoluteFractionModern_+3A_absolutefractionmodern">AbsoluteFractionModern</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='Delta14C_from_AbsoluteFractionModern+2Cmatrix-method'>Conversion of radiocarbon values</h2><span id='topic+Delta14C_from_AbsoluteFractionModern+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
Delta14C_from_AbsoluteFractionModern(AbsoluteFractionModern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta14C_from_AbsoluteFractionModern+2B2Cmatrix-method_+3A_absolutefractionmodern">AbsoluteFractionModern</code></td>
<td>
<p>Matrix of radiocarbon values in absolute fraction modern</p>
</td></tr>
</table>

<hr>
<h2 id='Delta14C_from_AbsoluteFractionModern+2Cnumeric-method'>Conversion of radiocarbon values</h2><span id='topic+Delta14C_from_AbsoluteFractionModern+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Conversion of radiocarbon values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
Delta14C_from_AbsoluteFractionModern(AbsoluteFractionModern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta14C_from_AbsoluteFractionModern+2B2Cnumeric-method_+3A_absolutefractionmodern">AbsoluteFractionModern</code></td>
<td>
<p>radiocarbon value in absolute fraction modern</p>
</td></tr>
</table>

<hr>
<h2 id='Delta14C+2CBoundFc-method'>automatic title</h2><span id='topic+Delta14C+2CBoundFc-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BoundFc'
Delta14C(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta14C+2B2CBoundFc-method_+3A_f">F</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='Delta14C+2CConstFc-method'>automatic title</h2><span id='topic+Delta14C+2CConstFc-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstFc'
Delta14C(F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Delta14C+2B2CConstFc-method_+3A_f">F</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='deSolve.lsoda.wrapper'>deSolve.lsoda.wrapper</h2><span id='topic+deSolve.lsoda.wrapper'></span>

<h3>Description</h3>

<p>The function serves as a wrapper for lsoda using a much simpler interface
which allows the use of matrices in the definition of the derivative.  To
use lsoda we have to convert our vectors to lists, define tolerances and so
on. This function does this for us , so we don't need to bother about it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deSolve.lsoda.wrapper(t, ydot, startValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deSolve.lsoda.wrapper_+3A_t">t</code></td>
<td>
<p>A row vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="deSolve.lsoda.wrapper_+3A_ydot">ydot</code></td>
<td>
<p>The function of y and t that computes the derivative for a given
point in time and a column vector y.</p>
</td></tr>
<tr><td><code id="deSolve.lsoda.wrapper_+3A_startvalues">startValues</code></td>
<td>
<p>A column vector with the starting values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. Every column represents a pool and every row a point in
time
</p>

<hr>
<h2 id='eCO2'>
Soil CO2 efflux from an incubation experiment
</h2><span id='topic+eCO2'></span>

<h3>Description</h3>

<p>A dataset with soil CO2 efflux measurements from a laboratory incubation at controlled temperature and moisture conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eCO2)</code></pre>


<h3>Format</h3>

<p>A data frame with the following 3 variables.
</p>

<dl>
<dt><code>Days</code></dt><dd><p>A numeric vector with the day of measurement after the experiment started.</p>
</dd>
<dt><code>eCO2mean</code></dt><dd><p>A numeric vector with the release flux of CO2. Units in ug C g-1 soil day-1.</p>
</dd>
<dt><code>eCO2sd</code></dt><dd><p>A numeric vector with the standard deviation of the release flux of CO2-C. Units in ug C g-1 soil day-1.</p>
</dd>
</dl>



<h3>Details</h3>

<p>A laboratory incubation experiment was performed in March 2014 for a period of 35 days under controlled conditions of temperature (15 degrees Celsius), moisture (30 percent soil water content), and oxygen levels (20 percent). Soil CO2 measurements were taken using an automated system for gas sampling connected to an infrared gas analyzer. The soil was sampled at a boreal forest site (Caribou Poker Research Watershed, Alaska, USA). This dataset presents the mean and standard deviation of 4 replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(eCO2)

plot(eCO2[,1:2],type="o",ylim=c(0,50),ylab="CO2 efflux (ug C g-1 soil day-1)")
arrows(eCO2[,1],eCO2[,2]-eCO2[,3],eCO2[,1],eCO2[,2]+eCO2[,3], angle=90,length=0.3,code=3)

</code></pre>

<hr>
<h2 id='entropyRatePerJump'>Entropy rate per jump</h2><span id='topic+entropyRatePerJump'></span>

<h3>Description</h3>

<p>Computes the entropy rate per jump of the Markov chain generated by the compartmental system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropyRatePerJump(A, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropyRatePerJump_+3A_a">A</code></td>
<td>
<p>A constant compartmental square matrix with cycling rates in the
diagonal and transfer rates in the off-diagonal.</p>
</td></tr>
<tr><td><code id="entropyRatePerJump_+3A_u">u</code></td>
<td>
<p>A one-column matrix defining the amount of inputs per compartment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value with the entropy rate per jump
</p>


<h3>References</h3>

<p>Metzler, H. (2020). Compartmental systems as Markov chains : age, 
transit time, and entropy (T. Oertel-Jaeger, I. Pavlyukevich, and C. Sierra, 
Eds.) 
[PhD thesis](https://suche.thulb.uni-jena.de/Record/1726091651)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B6=matrix(c(-1,1,0,0,-1,1,0,0,-1),3,3); u6=matrix(c(1,0,0))
entropyRatePerJump(A=B6, u=u6)
</code></pre>

<hr>
<h2 id='entropyRatePerTime'>Entropy rate per time</h2><span id='topic+entropyRatePerTime'></span>

<h3>Description</h3>

<p>Computes the entropy rate per time of the Markov chain generated by the compartmental system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropyRatePerTime(A, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropyRatePerTime_+3A_a">A</code></td>
<td>
<p>A constant compartmental square matrix with cycling rates in the
diagonal and transfer rates in the off-diagonal.</p>
</td></tr>
<tr><td><code id="entropyRatePerTime_+3A_u">u</code></td>
<td>
<p>A one-column matrix defining the amount of inputs per compartment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value with the entropy rate per time
</p>


<h3>References</h3>

<p>Metzler, H. (2020). Compartmental systems as Markov chains : age, 
transit time, and entropy (T. Oertel-Jaeger, I. Pavlyukevich, and C. Sierra, 
Eds.) 
[PhD thesis](https://suche.thulb.uni-jena.de/Record/1726091651)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B6=matrix(c(-1,1,0,0,-1,1,0,0,-1),3,3); u6=matrix(c(1,0,0))
entropyRatePerTime(A=B6, u=u6)
</code></pre>

<hr>
<h2 id='euler'>euler</h2><span id='topic+euler'></span>

<h3>Description</h3>

<p>This function can solve arbitrary first order ode systems with the euler
forward method and an adaptive time-step size control given a tolerance for
the deviation of a coarse and fine estimate of the change in y for the next
time step. It is an alternative to <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> and
has the same interface. It is much slower than ode and should probably be
considered less capable in solving stiff ode systems. However it has one
main advantage, which consists in its simplicity. It is quite easy to see
what is going on inside it. Whenever you don't trust your implementation of
another (more efficient but probably also more complex) ode solver, just
compare the result to what this method computes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler(times, ydot, startValues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euler_+3A_times">times</code></td>
<td>
<p>A row vector containing the points in time where the solution
is sought.</p>
</td></tr>
<tr><td><code id="euler_+3A_ydot">ydot</code></td>
<td>
<p>The function of y and t that computes the derivative for a given
point in time and a column vector y.</p>
</td></tr>
<tr><td><code id="euler_+3A_startvalues">startValues</code></td>
<td>
<p>A column vector with the initial values.</p>
</td></tr>
</table>

<hr>
<h2 id='example.2DBoundInFluxesFromFunction'>example.2DBoundInFluxesFromFunction</h2><span id='topic+example.2DBoundInFluxesFromFunction'></span>

<h3>Description</h3>

<p>Create a 2-dimensional example of a BoundInFluxes object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DBoundInFluxesFromFunction()
</code></pre>


<h3>Value</h3>

<p>The returned object represents a time dependent Influx into a two
pool model.
</p>

<hr>
<h2 id='example.2DBoundLinDecompOpFromFunction'>example.2DBoundLinDecompOpFromFunction</h2><span id='topic+example.2DBoundLinDecompOpFromFunction'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DBoundLinDecompOpFromFunction()
</code></pre>

<hr>
<h2 id='example.2DConstFc.Args'>example.2DConstFc.Args</h2><span id='topic+example.2DConstFc.Args'></span>

<h3>Description</h3>

<p>Create a 2-dimensional examples of a Influx objects from different
arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DConstFc.Args()
</code></pre>

<hr>
<h2 id='example.2DConstInFluxesFromVector'>2D example for constant Influx</h2><span id='topic+example.2DConstInFluxesFromVector'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DConstInFluxesFromVector()
</code></pre>


<h3>Value</h3>

<p>The returned object represents a time invariant constant influx into
a two pool model.
</p>

<hr>
<h2 id='example.2DGeneralDecompOpArgs'>example.2DGeneralDecompOpArgs</h2><span id='topic+example.2DGeneralDecompOpArgs'></span>

<h3>Description</h3>

<p>We present all possibilities to define a 2D <code><a href="#topic+DecompOp-class">DecompOp-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DGeneralDecompOpArgs()
</code></pre>

<hr>
<h2 id='example.2DInFluxes.Args'>example.2DInFluxes.Args</h2><span id='topic+example.2DInFluxes.Args'></span>

<h3>Description</h3>

<p>Create a 2-dimensional examples of a Influx objects from different
arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DInFluxes.Args()
</code></pre>

<hr>
<h2 id='example.2DUnBoundLinDecompOpFromFunction'>example.2DUnBoundLinDecompOpFromFunction</h2><span id='topic+example.2DUnBoundLinDecompOpFromFunction'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2DUnBoundLinDecompOpFromFunction()
</code></pre>

<hr>
<h2 id='example.ConstlinDecompOpFromMatrix'>example.ConstlinDecompOpFromMatrix</h2><span id='topic+example.ConstlinDecompOpFromMatrix'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.ConstlinDecompOpFromMatrix()
</code></pre>

<hr>
<h2 id='example.nestedTime2DMatrixList'>create an example nested list that can be</h2><span id='topic+example.nestedTime2DMatrixList'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.nestedTime2DMatrixList()
</code></pre>

<hr>
<h2 id='example.Time2DArrayList'>create an example TimeMap from 2D array</h2><span id='topic+example.Time2DArrayList'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.Time2DArrayList()
</code></pre>

<hr>
<h2 id='example.Time3DArrayList'>create an example TimeFrame from 3D array</h2><span id='topic+example.Time3DArrayList'></span>

<h3>Description</h3>

<p>An example used in tests and other examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.Time3DArrayList()
</code></pre>

<hr>
<h2 id='example.TimeMapFromArray'>create an example TimeFrame from 3D array</h2><span id='topic+example.TimeMapFromArray'></span>

<h3>Description</h3>

<p>The function creates an example TimeMap that is used in other examples and
tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.TimeMapFromArray()
</code></pre>

<hr>
<h2 id='Fc-class'>automatic title</h2><span id='topic+Fc-class'></span>

<h3>Description</h3>

<p>automatic title
</p>

<hr>
<h2 id='FcAtm.from.Dataframe'>FcAtm.from.Dataframe</h2><span id='topic+FcAtm.from.Dataframe'></span>

<h3>Description</h3>

<p>This function is deprecated constructor of the deprecated class FcAtm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FcAtm.from.Dataframe(dframe, lag = 0, interpolation = splinefun, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FcAtm.from.Dataframe_+3A_dframe">dframe</code></td>
<td>
<p>A data frame containing exactly two columns: the first one is
interpreted as time the second one is interpreted as atmospheric C14 fraction
in the format mentioned</p>
</td></tr>
<tr><td><code id="FcAtm.from.Dataframe_+3A_lag">lag</code></td>
<td>
<p>a scalar describing the time lag. Positive Values shift the
argument of the interpolation function forward in time. (retard its effect)</p>
</td></tr>
<tr><td><code id="FcAtm.from.Dataframe_+3A_interpolation">interpolation</code></td>
<td>
<p>A function that returns a function the default is
splinefun. Other possible values are the linear interpolation approxfun or
any self made function with the same interface.</p>
</td></tr>
<tr><td><code id="FcAtm.from.Dataframe_+3A_format">format</code></td>
<td>
<p>a string that specifies the format used to represent the
atmospheric fraction. Possible values are &quot;Delta14C&quot; which is the default or
&quot;afn&quot; the Absolute Fraction Normal representation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the new class BoundFc that replaces FcAtm
</p>

<hr>
<h2 id='from_integer_flux_lists_with_defaults'>helper function</h2><span id='topic+from_integer_flux_lists_with_defaults'></span>

<h3>Description</h3>

<p>helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_integer_flux_lists_with_defaults(
  internal_flux_rates = list(),
  out_flux_rates = list(),
  numberOfPools
)
</code></pre>

<hr>
<h2 id='fT.Arrhenius'>Effects of temperature on decomposition rates according the Arrhenius
equation</h2><span id='topic+fT.Arrhenius'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the Arrhenius equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Arrhenius(Temp, A = 1000, Ea = 75000, Re = 8.3144621)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Arrhenius_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature (in degrees
Kelvin) for which the effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fT.Arrhenius_+3A_a">A</code></td>
<td>
<p>A scalar defining the pre-exponential factor.</p>
</td></tr>
<tr><td><code id="fT.Arrhenius_+3A_ea">Ea</code></td>
<td>
<p>A scalar defining the activation energy in units of J mol^-1.</p>
</td></tr>
<tr><td><code id="fT.Arrhenius_+3A_re">Re</code></td>
<td>
<p>A scalar defining the universal gas contents in units of J K^-1
mol^-1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>

<hr>
<h2 id='fT.Century1'>Effects of temperature on decomposition rates according the the CENTURY
model</h2><span id='topic+fT.Century1'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the CENTURY model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Century1(Temp, Tmax = 45, Topt = 35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Century1_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fT.Century1_+3A_tmax">Tmax</code></td>
<td>
<p>A scalar defining the maximum temperature in degrees C.</p>
</td></tr>
<tr><td><code id="fT.Century1_+3A_topt">Topt</code></td>
<td>
<p>A scalar defining the optimum temperature for the decomposition
process in degrees C.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Burke, I. C., J. P. Kaye, S. P. Bird, S. A. Hall, R. L.
McCulley, and G. L. Sommerville. 2003.  Evaluating and testing models of
terrestrial biogeochemistry: the role of temperature in controlling
decomposition.  Pages 235-253 in C. D. Canham, J. J. Cole, and W. K.
Lauenroth, editors. Models in ecosystem science. Princeton University Press,
Princeton.
</p>

<hr>
<h2 id='fT.Century2'>Effects of temperature on decomposition rates according the the CENTURY
model</h2><span id='topic+fT.Century2'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the CENTURY model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Century2(Temp, Tmax = 45, Topt = 35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Century2_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fT.Century2_+3A_tmax">Tmax</code></td>
<td>
<p>A scalar defining the maximum temperature in degrees C.</p>
</td></tr>
<tr><td><code id="fT.Century2_+3A_topt">Topt</code></td>
<td>
<p>A scalar defining the optimum temperature for the decomposition
process in degrees C.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Adair, E. C., W. J. Parton, S. J. D. Grosso, W. L. Silver, M. E.
Harmon, S. A. Hall, I. C. Burke, and S. C. Hart. 2008.  Simple three-pool
model accurately describes patterns of long-term litter decomposition in
diverse climates. Global Change Biology 14:2636-2660.
</p>

<hr>
<h2 id='fT.Daycent1'>Effects of temperature on decomposition rates according to the DAYCENT model</h2><span id='topic+fT.Daycent1'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the DAYCENT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Daycent1(Temp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Daycent1_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of soil temperature for
which the effects on decomposition rates are calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Kelly, R. H., W. J. Parton, M. D. Hartman, L. K. Stretch, D. S.
Ojima, and D. S. Schimel (2000), Intra-annual and interannual variability of
ecosystem processes in shortgrass steppe, J. Geophys. Res., 105.
</p>

<hr>
<h2 id='fT.Daycent2'>Effects of temperature on decomposition rates according to the DAYCENT model</h2><span id='topic+fT.Daycent2'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the Daycent/Century models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Daycent2(Temp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Daycent2_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of soil temperature for
which the effects on decomposition rates are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Del Grosso, S. J., W. J. Parton, A. R. Mosier, E. A. Holland, E.
Pendall, D. S. Schimel, and D. S. Ojima (2005), Modeling soil CO2 emissions
from ecosystems, Biogeochemistry, 73(1), 71-91.
</p>

<hr>
<h2 id='fT.Demeter'>Effects of temperature on decomposition rates according to the DEMETER model</h2><span id='topic+fT.Demeter'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the DEMETER model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Demeter(Temp, Q10 = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Demeter_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated</p>
</td></tr>
<tr><td><code id="fT.Demeter_+3A_q10">Q10</code></td>
<td>
<p>A scalar. Temperature coefficient Q10</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Foley, J. A. (1995), An equilibrium model of the terrestrial
carbon budget, Tellus B, 47(3), 310-319.
</p>

<hr>
<h2 id='fT.KB'>Effects of temperature on decomposition rates according to a model proposed
by M. Kirschbaum (1995)</h2><span id='topic+fT.KB'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to a
model proposed by Kirschbaum (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.KB(Temp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.KB_+3A_temp">Temp</code></td>
<td>
<p>a scalar or vector containing values of soil temperature for
which the effects on decomposition rates are calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Kirschbaum, M. U. F. (1995), The temperature dependence of soil
organic matter decomposition, and the effect of global warming on soil
organic C storage, Soil Biology and Biochemistry, 27(6), 753-760.
</p>

<hr>
<h2 id='fT.LandT'>Effects of temperature on decomposition rates according to a function
proposed by Lloyd and Taylor (1994)</h2><span id='topic+fT.LandT'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to a
function proposed by Lloyd and Taylor (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.LandT(Temp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.LandT_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of soil temperature for
which the effects on decomposition rates are calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Lloyd, J., and J. A. Taylor (1994), On the Temperature
Dependence of Soil Respiration, Functional Ecology, 8(3), 315-323.
</p>

<hr>
<h2 id='fT.linear'>Effects of temperature on decomposition rates according to a linear model</h2><span id='topic+fT.linear'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to a
linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.linear(Temp, a = 0.198306, b = 0.036337)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.linear_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fT.linear_+3A_a">a</code></td>
<td>
<p>A scalar defining the intercept of the linear function.</p>
</td></tr>
<tr><td><code id="fT.linear_+3A_b">b</code></td>
<td>
<p>A scalar defining the slope of the linear function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Adair, E. C., W. J. Parton, S. J. D. Grosso, W. L. Silver, M. E.
Harmon, S. A. Hall, I. C. Burke, and S. C. Hart. 2008.  Simple three-pool
model accurately describes patterns of long-term litter decomposition in
diverse climates. Global Change Biology 14:2636-2660.
</p>

<hr>
<h2 id='fT.Q10'>Effects of temperature on decomposition rates according to a Q10 function</h2><span id='topic+fT.Q10'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the modified Van't Hoff function (Q10 function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Q10(Temp, k_ref = 1, T_ref = 10, Q10 = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Q10_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fT.Q10_+3A_k_ref">k_ref</code></td>
<td>
<p>A scalar representing the value of the decomposition rate at a
reference temperature value.</p>
</td></tr>
<tr><td><code id="fT.Q10_+3A_t_ref">T_ref</code></td>
<td>
<p>A scalar representing the reference temperature.</p>
</td></tr>
<tr><td><code id="fT.Q10_+3A_q10">Q10</code></td>
<td>
<p>A scalar. Temperature coefficient Q10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>

<hr>
<h2 id='fT.RothC'>Effects of temperature on decomposition rates according to the functions
included in the RothC model</h2><span id='topic+fT.RothC'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the functions included in the RothC model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.RothC(Temp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.RothC_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>Note</h3>

<p>This function returns NA for Temp &lt;= -18.3
</p>


<h3>References</h3>

<p>Jenkinson, D. S., S. P. S. Andrew, J. M. Lynch, M. J. Goss, and
P. B. Tinker (1990), The Turnover of Organic Carbon and Nitrogen in Soil,
Philosophical Transactions: Biological Sciences, 329(1255), 361-368.
</p>

<hr>
<h2 id='fT.Standcarb'>Effects of temperature on decomposition rates according to the StandCarb
model</h2><span id='topic+fT.Standcarb'></span>

<h3>Description</h3>

<p>Calculates the effects of temperature on decomposition rates according to
the StandCarb model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fT.Standcarb(Temp, Topt = 45, Tlag = 4, Tshape = 15, Q10 = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fT.Standcarb_+3A_temp">Temp</code></td>
<td>
<p>A scalar or vector containing values of temperature for which
the effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fT.Standcarb_+3A_topt">Topt</code></td>
<td>
<p>A scalar representing the optimum temperature for decomposition.</p>
</td></tr>
<tr><td><code id="fT.Standcarb_+3A_tlag">Tlag</code></td>
<td>
<p>A scalar that determines the lag of the response curve.</p>
</td></tr>
<tr><td><code id="fT.Standcarb_+3A_tshape">Tshape</code></td>
<td>
<p>A scalar that determines the shape of the response curve.</p>
</td></tr>
<tr><td><code id="fT.Standcarb_+3A_q10">Q10</code></td>
<td>
<p>A scalar. Temperature coefficient Q10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of temperature on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Harmon, M. E., and J. B. Domingo (2001), A users guide to
STANDCARB version 2.0: A model to simulate carbon stores in forest stands.
Oregon State University, Corvallis.
</p>

<hr>
<h2 id='fW.Candy'>Effects of moisture on decomposition rates according to the Candy model</h2><span id='topic+fW.Candy'></span>

<h3>Description</h3>

<p>Calculates the effects of water content and pore volume on decomposition
rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Candy(theta, PV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Candy_+3A_theta">theta</code></td>
<td>
<p>A scalar or vector containing values of volumetric soil water
content.</p>
</td></tr>
<tr><td><code id="fW.Candy_+3A_pv">PV</code></td>
<td>
<p>A scalar or vector containing values of pore volume.</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Bauer, M. Herbst, J.A. Huisman, L. Weiherm\&quot;uller, H.
Vereecken. 2008. Sensitivity of simulated soil heterotrophic respiration to
temperature and moisture reduction functions. Geoderma, Volume 145, Issues
1-2, 15 May 2008, Pages 17-27.
</p>

<hr>
<h2 id='fW.Century'>Effects of moisture on decomposition rates according to the CENTURY model</h2><span id='topic+fW.Century'></span>

<h3>Description</h3>

<p>Calculates the effects of precipitation and potential evapotranspiration on
decomposition rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Century(PPT, PET)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Century_+3A_ppt">PPT</code></td>
<td>
<p>A scalar or vector containing values of monthly precipitation.</p>
</td></tr>
<tr><td><code id="fW.Century_+3A_pet">PET</code></td>
<td>
<p>A scalar or vector containing values of potential
evapotranspiration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of precipitation and
potential evapotranspiration on decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Adair, E. C., W. J. Parton, S. J. D. Grosso, W. L. Silver, M. E.
Harmon, S. A. Hall, I. C. Burke, and S. C. Hart (2008), Simple three-pool
model accurately describes patterns of long-term litter decomposition in
diverse climates, Global Change Biology, 14(11), 2636-2660.  Parton,
W. J., J. A. Morgan, R. H. Kelly, and D. S. Ojima (2001), Modeling soil C
responses to environmental change in grassland systems, in The potential of
U.S. grazing lands to sequester carbon and mitigate the greenhouse effect,
edited by R. F. Follett, J. M. Kimble and R. Lal, pp. 371-398, Lewis
Publishers, Boca Raton.
</p>

<hr>
<h2 id='fW.Daycent1'>Effects of moisture on decomposition rates according to the DAYCENT model</h2><span id='topic+fW.Daycent1'></span>

<h3>Description</h3>

<p>Calculates the effects of Soil Water Content on decomposition rates
according to the Daycent Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Daycent1(
  swc,
  a = 0.6,
  b = 1.27,
  c = 0.0012,
  d = 2.84,
  partd = 2.65,
  bulkd = 1,
  width = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Daycent1_+3A_swc">swc</code></td>
<td>
<p>A scalar or vector with soil water content of a soil layer (cm).</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_a">a</code></td>
<td>
<p>Empirical coefficient. For fine textured soils a = 0.6. For coarse
textured soils a = 0.55.</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_b">b</code></td>
<td>
<p>Empirical coefficient. For fine textured soils b = 1.27. For coarse
textured soils b = 1.70.</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_c">c</code></td>
<td>
<p>Empirical coefficient. For fine textured soils c = 0.0012. For
coarse textured soils c = -0.007.</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_d">d</code></td>
<td>
<p>Empirical coefficient. For fine textured soils d = 2.84. For coarse
textured soils d = 3.22.</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_partd">partd</code></td>
<td>
<p>Particle density of soil layer.</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_bulkd">bulkd</code></td>
<td>
<p>Bulk density of soil layer (g/cm^3).</p>
</td></tr>
<tr><td><code id="fW.Daycent1_+3A_width">width</code></td>
<td>
<p>Thickness of a soil layer (cm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with values of water filled pore space (wfps) and
effects of soil water content on decomposition rates. Both vectors are
unitless.
</p>


<h3>References</h3>

<p>Kelly, R. H., W. J. Parton, M. D. Hartman, L. K. Stretch, D. S.
Ojima, and D. S. Schimel (2000), Intra-annual and interannual variability of
ecosystem processes in shortgrass steppe, J. Geophys. Res., 105.
</p>

<hr>
<h2 id='fW.Daycent2'>Effects of moisture on decomposition rates according to the DAYCENT model</h2><span id='topic+fW.Daycent2'></span>

<h3>Description</h3>

<p>Calculates the effects of volumetric water content on decomposition rates
according to the Daycent/Century models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Daycent2(W, WP = 0, FC = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Daycent2_+3A_w">W</code></td>
<td>
<p>A scalar or vector of volumetric water content in percentage.</p>
</td></tr>
<tr><td><code id="fW.Daycent2_+3A_wp">WP</code></td>
<td>
<p>A scalar representing the wilting point in percentage.</p>
</td></tr>
<tr><td><code id="fW.Daycent2_+3A_fc">FC</code></td>
<td>
<p>A scalar representing the field capacity in percentage.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with values of relative water content (RWC) and the
effects of RWC on decomposition rates (fRWC).
</p>


<h3>References</h3>

<p>Del Grosso, S. J., W. J. Parton, A. R. Mosier, E. A. Holland, E.
Pendall, D. S. Schimel, and D. S. Ojima (2005), Modeling soil CO2 emissions
from ecosystems, Biogeochemistry, 73(1), 71-91.
</p>

<hr>
<h2 id='fW.Demeter'>Effects of moisture on decomposition rates according to the DEMETER model</h2><span id='topic+fW.Demeter'></span>

<h3>Description</h3>

<p>Calculates the effects of soil moisture on decomposition rates according to
the DEMETER model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Demeter(M, Msat = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Demeter_+3A_m">M</code></td>
<td>
<p>A scalar or vector containing values of soil moisture for which the
effects on decomposition rates are calculated.</p>
</td></tr>
<tr><td><code id="fW.Demeter_+3A_msat">Msat</code></td>
<td>
<p>A scalar representing saturated soil moisture.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar or a vector containing the effects of moisture on
decomposition rates (unitless).
</p>


<h3>References</h3>

<p>Foley, J. A. (1995), An equilibrium model of the terrestrial
carbon budget, Tellus B, 47(3), 310-319.
</p>

<hr>
<h2 id='fW.Gompertz'>Effects of moisture on decomposition rates according to the Gompertz
function</h2><span id='topic+fW.Gompertz'></span>

<h3>Description</h3>

<p>Calculates the effects of water content on decomposition rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Gompertz(theta, a = 0.824, b = 0.308)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Gompertz_+3A_theta">theta</code></td>
<td>
<p>A scalar or vector containing values of volumetric soil water
content.</p>
</td></tr>
<tr><td><code id="fW.Gompertz_+3A_a">a</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
<tr><td><code id="fW.Gompertz_+3A_b">b</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
</table>


<h3>References</h3>

<p>I. Janssens, S. Dore, D. Epron, H. Lankreijer, N. Buchmann, B.
Longdoz, J. Brossaud, L. Montagnani. 2003. Climatic Influences on Seasonal
and Spatial Differences in Soil CO2 Efflux. In Valentini, R. (Ed.) Fluxes of
Carbon, Water and Energy of European Forests. pp 235-253. Springer.
</p>

<hr>
<h2 id='fW.Moyano'>Effects of moisture on decomposition rates according to the function
proposed by Moyano et al. (2013)</h2><span id='topic+fW.Moyano'></span>

<h3>Description</h3>

<p>Calculates the effects of water content on decomposition rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Moyano(theta, a = 3.11, b = 2.42)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Moyano_+3A_theta">theta</code></td>
<td>
<p>A scalar or vector containing values of volumetric soil water
content.</p>
</td></tr>
<tr><td><code id="fW.Moyano_+3A_a">a</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
<tr><td><code id="fW.Moyano_+3A_b">b</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
</table>


<h3>References</h3>

<p>F. E. Moyano, S. Manzoni, C. Chenu. 2013 Responses of soil
heterotrophic respiration to moisture availability: An exploration of
processes and models.  Soil Biology and Biochemistry, Volume 59, April 2013,
Pages 72-85
</p>

<hr>
<h2 id='fW.RothC'>Effects of moisture on decomposition rates according to the RothC model</h2><span id='topic+fW.RothC'></span>

<h3>Description</h3>

<p>Calculates the effects of moisture (precipitation and pan evaporation) on
decomposition rates according to the RothC model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.RothC(P, E, S.Thick = 23, pClay = 23.4, pE = 0.75, bare = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.RothC_+3A_p">P</code></td>
<td>
<p>A vector with monthly precipitation (mm).</p>
</td></tr>
<tr><td><code id="fW.RothC_+3A_e">E</code></td>
<td>
<p>A vector with same length with open pan evaporation or
evapotranspiration (mm).</p>
</td></tr>
<tr><td><code id="fW.RothC_+3A_s.thick">S.Thick</code></td>
<td>
<p>Soil thickness in cm. Default for Rothamsted is 23 cm.</p>
</td></tr>
<tr><td><code id="fW.RothC_+3A_pclay">pClay</code></td>
<td>
<p>Percent clay.</p>
</td></tr>
<tr><td><code id="fW.RothC_+3A_pe">pE</code></td>
<td>
<p>Evaporation coefficient. If open pan evaporation is used pE=0.75.
If Potential evaporation is used, pE=1.0.</p>
</td></tr>
<tr><td><code id="fW.RothC_+3A_bare">bare</code></td>
<td>
<p>Logical. Under bare soil conditions, bare=TRUE. Default is set
under vegetated soil.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with accumulated top soil moisture deficit (Acc.TSMD)
and the rate modifying factor b.
</p>


<h3>References</h3>

<p>Coleman, K., and D. S. Jenkinson (1999), RothC-26.3 A model for
the turnover of carbon in soil: model description and windows user guide
(modified 2008), 47 pp, IACR Rothamsted, Harpenden.
</p>

<hr>
<h2 id='fW.Skopp'>Effects of moisture on decomposition rates according to the function
proposed by Skopp et al. 1990</h2><span id='topic+fW.Skopp'></span>

<h3>Description</h3>

<p>Calculates the effects of relative soil water content on decomposition
rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Skopp(rwc, alpha = 2, beta = 2, f = 1.3, g = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Skopp_+3A_rwc">rwc</code></td>
<td>
<p>relative water content</p>
</td></tr>
<tr><td><code id="fW.Skopp_+3A_alpha">alpha</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
<tr><td><code id="fW.Skopp_+3A_beta">beta</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
<tr><td><code id="fW.Skopp_+3A_f">f</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
<tr><td><code id="fW.Skopp_+3A_g">g</code></td>
<td>
<p>Empirical parameter</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Skopp, M. D. Jawson, and J. W. Doran. 1990. Steady-state
aerobic microbial activity as a function of soil water content. Soil Sci.
Soc. Am. J., 54(6):1619-1625
</p>

<hr>
<h2 id='fW.Standcarb'>Effects of moisture on decomposition rates according to the StandCarb model</h2><span id='topic+fW.Standcarb'></span>

<h3>Description</h3>

<p>Calculates the effects of moisture on decomposition rates according to the
StandCarb model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fW.Standcarb(
  Moist,
  MatricShape = 5,
  MatricLag = 0,
  MoistMin = 30,
  MoistMax = 350,
  DiffuseShape = 15,
  DiffuseLag = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fW.Standcarb_+3A_moist">Moist</code></td>
<td>
<p>A scalar or vector containing values of moisture content of a
litter or soil pool (%).</p>
</td></tr>
<tr><td><code id="fW.Standcarb_+3A_matricshape">MatricShape</code></td>
<td>
<p>A scalar that determines when matric limit is reduced to
the point that decay can begin to occur.</p>
</td></tr>
<tr><td><code id="fW.Standcarb_+3A_matriclag">MatricLag</code></td>
<td>
<p>A scalar used to offset the curve to the left or right.</p>
</td></tr>
<tr><td><code id="fW.Standcarb_+3A_moistmin">MoistMin</code></td>
<td>
<p>A scalar determining the minimum moisture content.</p>
</td></tr>
<tr><td><code id="fW.Standcarb_+3A_moistmax">MoistMax</code></td>
<td>
<p>A scalar determining the maximum moisture content without
diffusion limitations.</p>
</td></tr>
<tr><td><code id="fW.Standcarb_+3A_diffuseshape">DiffuseShape</code></td>
<td>
<p>A scalar that determines the range of moisture contents
where diffusion is not limiting.</p>
</td></tr>
<tr><td><code id="fW.Standcarb_+3A_diffuselag">DiffuseLag</code></td>
<td>
<p>A scalar used to shift the point when moisture begins to
limit diffusion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with limitation due to water potential (MatricLimit),
limitation due to oxygen diffusion (DiffuseLimit), and the overall
limitation of moisture on decomposition rates (MoistDecayIndex).
</p>


<h3>References</h3>

<p>Harmon, M. E., and J. B. Domingo (2001), A users guide to
STANDCARB version 2.0: A model to simulate carbon stores in forest stands.
Oregon State University, Corvallis.
</p>

<hr>
<h2 id='GaudinskiModel14'>Implementation of a the six-pool C14 model proposed by Gaudinski et al. 2000</h2><span id='topic+GaudinskiModel14'></span>

<h3>Description</h3>

<p>This function creates a model as described in Gaudinski et al. 2000.  It is
a wrapper for the more general functions <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> that
can handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaudinskiModel14(
  t,
  ks = c(kr = 1/1.5, koi = 1/1.5, koeal = 1/4, koeah = 1/80, kA1 = 1/3, kA2 = 1/75, kM =
    1/110),
  C0 = c(FR0 = 390, C10 = 220, C20 = 390, C30 = 1370, C40 = 90, C50 = 1800, C60 = 560),
  F0_Delta14C = rep(0, 7),
  LI = 150,
  RI = 255,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaudinskiModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 7 containing the decomposition rates for the 6
soil pools plus the fine-root pool.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 7 containing the initial amount of carbon for
the 6 pools plus the fine-root pool.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 7 containing the initial amount of the
radiocarbon fraction for the 7 pools as Delta14C values in per mil.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_li">LI</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_ri">RI</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of root
inputs by time.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_lag">lag</code></td>
<td>
<p>A positive integer representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. An alternative to
the default is <code><a href="#topic+euler">euler</a></code> or any other user provided function with
the same interface.</p>
</td></tr>
<tr><td><code id="GaudinskiModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Gaudinski JB, Trumbore SE, Davidson EA, Zheng S (2000) Soil
carbon cycling in a temperate forest: radiocarbon-based estimates of
residence times, sequestration rates and partitioning fluxes.
Biogeochemistry 51: 33-69
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1901,2010,by=0.5)

Ex=GaudinskiModel14(
t=years,
ks=c(kr=1/3, koi=1/1.5, koeal=1/4, koeah=1/80, kA1=1/3, kA2=1/75, kM=1/110),
inputFc=C14Atm_NH
)
R14m=getF14R(Ex)
C14m=getF14C(Ex)

plot(
C14Atm_NH,
type="l",
xlab="Year",
ylab=expression(paste(Delta^14,"C (per mille)")),
xlim=c(1940,2010)
) 
lines(years,C14m,col=4)
points(HarvardForest14CO2[1:11,1],HarvardForest14CO2[1:11,2],pch=19,cex=0.5)
points(HarvardForest14CO2[12:173,1],HarvardForest14CO2[12:173,2],pch=19,col=2,cex=0.5)
points(HarvardForest14CO2[158,1],HarvardForest14CO2[158,2],pch=19,cex=0.5)
lines(years,R14m,col=2)
legend(
"topright",
c("Delta 14C Atmosphere",
"Delta 14C SOM", 
"Delta 14C Respired"
),
lty=c(1,1,1), 
col=c(1,4,2),
bty="n"
)
## We now show how to bypass soilR s parameter sanity check if nacessary 
## (e.g in for parameter estimation ) in functions
## which might call it with unreasonable parameters
years=seq(1800,2010,by=0.5)
Ex=GaudinskiModel14(
t=years,
ks=c(kr=1/3,koi=1/1.5,koeal=1/4,koeah=1/80,kA1=1/3,kA2=1/75,kM=1/110),
inputFc=C14Atm_NH,
pass=TRUE
)
</code></pre>

<hr>
<h2 id='GeneralDecompOp'>A generic factory for subclasses of GeneralDecompOp</h2><span id='topic+GeneralDecompOp'></span>

<h3>Description</h3>

<p>A generic factory for subclasses of GeneralDecompOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralDecompOp_+3A_object">object</code></td>
<td>
<p>A SoilR object</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralDecompOp+2CDecompOp-method'>Pass through factory for objects of subclasses of <a href="#topic+DecompOp-class">DecompOp</a></h2><span id='topic+GeneralDecompOp+2CDecompOp-method'></span>

<h3>Description</h3>

<p>This method takes and returns an (identical) object that inherits 
from <a href="#topic+DecompOp-class">DecompOp</a>.
It's purpose it to be able to call the generic function on arguments that are already
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DecompOp'
GeneralDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralDecompOp+2B2CDecompOp-method_+3A_object">object</code></td>
<td>
<p>An object that already is of class <code>DecompOp</code></p>
</td></tr>
</table>

<hr>
<h2 id='GeneralDecompOp+2Cfunction-method'>automatic title</h2><span id='topic+GeneralDecompOp+2Cfunction-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function''
GeneralDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralDecompOp+2B2Cfunction-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralDecompOp+2Clist-method'>automatic title</h2><span id='topic+GeneralDecompOp+2Clist-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
GeneralDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralDecompOp+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralDecompOp+2Cmatrix-method'>automatic title</h2><span id='topic+GeneralDecompOp+2Cmatrix-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
GeneralDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralDecompOp+2B2Cmatrix-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralDecompOp+2CTimeMap-method'>automatic title</h2><span id='topic+GeneralDecompOp+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
GeneralDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralDecompOp+2B2CTimeMap-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralModel'>additional function to create Models</h2><span id='topic+GeneralModel'></span>

<h3>Description</h3>

<p>In previous SoilR Version GeneralModel was the function to create linear
models, a task now fulfilled by the function <code><a href="#topic+Model">Model</a></code>. To ensure
backward compatibility this function remains as a wrapper. In future
versions it might take on the role of an abstract factory that produces
several classes of models (i.e autonomous or non-autonomous and linear or non-linear) depending on different
combinations of arguments. It creates a Model object from any combination of
arguments that can be converted into the required set of building blocks for
a model for n arbitrarily connected pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralModel(
  t,
  A,
  ivList,
  inputFluxes,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE,
  timeSymbol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="GeneralModel_+3A_a">A</code></td>
<td>
<p>Anything that can be converted by <a href="#topic+GeneralDecompOp">GeneralDecompOp</a> to any of
the available DecompositionOperator classes</p>
</td></tr>
<tr><td><code id="GeneralModel_+3A_ivlist">ivList</code></td>
<td>
<p>A vector containing the initial amount of carbon for the n
pools. The length of this vector is equal to the number of pools and thus
equal to the length of k. This is checked by an internal function.</p>
</td></tr>
<tr><td><code id="GeneralModel_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>something that can be converted to any of the available
InFluxes classes</p>
</td></tr>
<tr><td><code id="GeneralModel_+3A_solverfunc">solverfunc</code></td>
<td>
<p>The function used by to actually solve the ODE system.
This can be <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user provided
function with the same interface.</p>
</td></tr>
<tr><td><code id="GeneralModel_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it is invalid</p>
</td></tr>
<tr><td><code id="GeneralModel_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>A string (character vector of length 1) identifying the variable name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object that can be further queried.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwopParallelModel">TwopParallelModel</a></code>, <code><a href="#topic+TwopSeriesModel">TwopSeriesModel</a></code>,
<code><a href="#topic+TwopFeedbackModel">TwopFeedbackModel</a></code>
</p>

<hr>
<h2 id='GeneralModel_14'>create objects of class <a href="#topic+Model_14-class">Model_14</a></h2><span id='topic+GeneralModel_14'></span>

<h3>Description</h3>

<p>At the moment this is just a wrapper for the actual constructor
<a href="#topic+Model_14">Model_14</a> with additional support for some now deprecated parameters
for backward compatibility. This role may change in the future to an
abstract factory where the actual class of the created model will be
determined by the supplied parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralModel_14(
  t,
  A,
  ivList,
  initialValF,
  inputFluxes,
  Fc = NULL,
  inputFc = Fc,
  di = -0.0001209681,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralModel_14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_a">A</code></td>
<td>
<p>something that can be converted by <a href="#topic+GeneralDecompOp">GeneralDecompOp</a> to any of
the available subclasses of <code><a href="#topic+DecompOp-class">DecompOp</a></code>.</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_ivlist">ivList</code></td>
<td>
<p>A vector containing the initial amount of carbon for the n
pools. The length of this vector is equal to the number of pools and thus
equal to the length of k. This is checked by an internal function.</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_initialvalf">initialValF</code></td>
<td>
<p>An object equal or equivalent to class ConstFc containing
a vector with the initial values of the radiocarbon fraction for each pool
and a format string describing in which format the values are given.</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>something that can be converted by <a href="#topic+InFluxes">InFluxes</a>
to any of the available subclasses of <a href="#topic+InFluxes-class">InFluxes</a>.</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_fc">Fc</code></td>
<td>
<p>deprecated keyword argument, please use inputFc instead</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_inputfc">inputFc</code></td>
<td>
<p>An object describing the fraction of C_14 in per mille
(different formats are possible)</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_di">di</code></td>
<td>
<p>the rate at which C_14 decays radioactively. If you don't provide a
value here we assume the following value: k=-0.0001209681 y^-1 . This has
the side effect that all your time related data are treated as if the time
unit was year. Thus beside time itself it also affects decay rates the
inputrates and the output</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_solverfunc">solverfunc</code></td>
<td>
<p>The function used by to actually solve the ODE system.
This can be <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user provided
function with the same interface.</p>
</td></tr>
<tr><td><code id="GeneralModel_14_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it is invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object that can be further queried.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwopParallelModel">TwopParallelModel</a></code>, <code><a href="#topic+TwopSeriesModel">TwopSeriesModel</a></code>,
<code><a href="#topic+TwopFeedbackModel">TwopFeedbackModel</a></code>
</p>

<hr>
<h2 id='GeneralNlModel'>Use this function to create objects of class NlModel.</h2><span id='topic+GeneralNlModel'></span>

<h3>Description</h3>

<p>The function creates a numerical model for n arbitrarily connected pools. It
is one of the constructors of class NlModel.  It is used by some more
specialized wrapper functions, but can also be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralNlModel(
  t,
  TO,
  ivList,
  inputFluxes,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralNlModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="GeneralNlModel_+3A_to">TO</code></td>
<td>
<p>A object describing the model decay rates for the n pools,
connection and feedback coefficients. The number of pools n must be
consistent with the number of initial values and input fluxes.</p>
</td></tr>
<tr><td><code id="GeneralNlModel_+3A_ivlist">ivList</code></td>
<td>
<p>A numeric vector containing the initial amount of carbon for
the n pools. The length of this vector is equal to the number of pools.</p>
</td></tr>
<tr><td><code id="GeneralNlModel_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>A TimeMap object consisting of a vector valued function
describing the inputs to the pools as functions of time
<code><a href="#topic+TimeMap.new">TimeMap.new</a></code>.</p>
</td></tr>
<tr><td><code id="GeneralNlModel_+3A_solverfunc">solverfunc</code></td>
<td>
<p>The function used by to actually solve the ODE system.</p>
</td></tr>
<tr><td><code id="GeneralNlModel_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it is
invalid. If set to TRUE, does not enforce the requirements for a
biologically meaningful model, e.g. does not check if negative values of
respiration are calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tr=getTransferMatrix(Anl) #this is a function of C and t
</p>
<p>#################################################################################
# build the two models (linear and nonlinear) mod=GeneralModel( t, A,iv,
inputrates, deSolve.lsoda.wrapper) modnl=GeneralNlModel( t, Anl, iv,
inputrates, deSolve.lsoda.wrapper)
</p>
<p>Ynonlin=getC(modnl) lt1=2 lt2=4 plot(t,Ynonlin[,1],type=&quot;l&quot;,lty=lt1,col=1,
ylab=&quot;Concentrations&quot;,xlab=&quot;Time&quot;,ylim=c(min(Ynonlin),max(Ynonlin)))
lines(t,Ynonlin[,2],type=&quot;l&quot;,lty=lt2,col=2) legend(&quot;topleft&quot;,c(&quot;Pool 1&quot;,
&quot;Pool 2&quot;),lty=c(lt1,lt2),col=c(1,2))
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0
t_end=20
tn=100
timestep=(t_end-t_start)/tn
t=seq(t_start,t_end,timestep)
k1=1/2
k2=1/3
Km=0.5
nr=2

alpha=list()
alpha[["1_to_2"]]=function(C,t){
1/5
}
alpha[["2_to_1"]]=function(C,t){
1/6
}

f=function(C,t){
# The only thing to take care of is that we release a vector of the same
# size as C
S=C[[1]]
M=C[[2]]
O=matrix(byrow=TRUE,nrow=2,c(k1*M*(S/(Km+S)),
k2*M))
return(O)
}
Anl=new("TransportDecompositionOperator",t_start,Inf,nr,alpha,f)


c01=3
c02=2
iv=c(c01,c02)
inputrates=new("TimeMap",t_start,t_end,function(t){return(matrix(
nrow=nr,
ncol=1,
c( 2,  2)
))})
#################################################################################
# we check if we can reproduce the linear decomposition operator from the
# nonlinear one
</code></pre>

<hr>
<h2 id='GeneralPoolId'>General pool Id</h2><span id='topic+GeneralPoolId'></span>

<h3>Description</h3>

<p>General pool Id
</p>
<p>General pool Id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeneralPoolId(id)

GeneralPoolId(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralPoolId_+3A_id">id</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralPoolId+2Ccharacter-method'>automatic title</h2><span id='topic+GeneralPoolId+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
GeneralPoolId(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralPoolId+2B2Ccharacter-method_+3A_id">id</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='GeneralPoolId+2Cnumeric-method'>generic factory for this virtual class</h2><span id='topic+GeneralPoolId+2Cnumeric-method'></span>

<h3>Description</h3>

<p>the class returned depends on the method dispatched depending on the supplied arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
GeneralPoolId(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GeneralPoolId+2B2Cnumeric-method_+3A_id">id</code></td>
<td>
<p>a numerical id</p>
</td></tr>
</table>

<hr>
<h2 id='getAccumulatedRelease'>Accumulated release flux out of the pools</h2><span id='topic+getAccumulatedRelease'></span>

<h3>Description</h3>

<p>Accumulated release flux out of the pools
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAccumulatedRelease(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAccumulatedRelease_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getAccumulatedRelease+2CModel-method'>Compute the time integral of the relaese fluxes over time</h2><span id='topic+getAccumulatedRelease+2CModel-method'></span>

<h3>Description</h3>

<p>The definite integral of the vector 
of release fluxes over time from  start to t, computed for all t in the
<code>times</code> argument the modelrun has been created with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getAccumulatedRelease(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAccumulatedRelease+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many columns as there are pools 
and as many rows as there are entries in the <code>times</code> argument the model has been build with.
</p>

<hr>
<h2 id='getC'>Calculates the content of the pools</h2><span id='topic+getC'></span>

<h3>Description</h3>

<p>This function computes the content of the pools as function of time.
In the original (and most of the present) Models these are Carbon pools hence the name.
Have a look at the methods for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getC(object, as.closures = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getC_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getC_+3A_as.closures">as.closures</code></td>
<td>
<p>a logical variable. Default to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with m columns representing where m is the number of pools, and n rows where n is the number times 
as specified by the <code>times</code> of the model.
</p>

<hr>
<h2 id='getC+2CModel_by_PoolNames-method'>Pool Contents for all times</h2><span id='topic+getC+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>Pool Contents for all times
</p>
<p>The solution of the initial value problem (IVP) for the pool contents.
Since the first models in SoilR had only Carbon pools 
the function name <code>getC</code> could be interpreted as 
referring to the C content. If the model includes other 
element cycles e.g. N or P this interpretation is no longer 
valid. In this case the C in 'getC' stands for 'content' 
since the function will always return the solution for 
all pools, regardless of the chemical element the author of 
the model associated them with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
getC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getC+2B2CModel_by_PoolNames-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many columns as there are pools 
and as many rows as there are entries in the <code>times</code> argument the model has been build with.
</p>

<hr>
<h2 id='getC+2CModel-method'>Pool Contents for all times</h2><span id='topic+getC+2CModel-method'></span>

<h3>Description</h3>

<p>Pool Contents for all times
</p>
<p>The solution of the initial value problem (IVP) for the pool contents.
Since the first models in SoilR had only Carbon pools 
the function name <code>getC</code> could be interpreted as 
referring to the C content. If the model includes other 
element cycles e.g. N or P this interpretation is no longer 
valid. In this case the C in 'getC' stands for 'content' 
since the function will always return the solution for 
all pools, regardless of the chemical element the author of 
the model associated them with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getC+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many columns as there are pools 
and as many rows as there are entries in the <code>times</code> argument the model has been build with.
</p>

<hr>
<h2 id='getC+2CNlModel-method'>Pool Contents for all times</h2><span id='topic+getC+2CNlModel-method'></span>

<h3>Description</h3>

<p>Pool Contents for all times
</p>
<p>The solution of the initial value problem (IVP) for the pool contents.
Since the first models in SoilR had only Carbon pools 
the function name <code>getC</code> could be interpreted as 
referring to the C content. If the model includes other 
element cycles e.g. N or P this interpretation is no longer 
valid. In this case the C in 'getC' stands for 'content' 
since the function will always return the solution for 
all pools, regardless of the chemical element the author of 
the model associated them with.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getC(object, as.closures = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getC+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getC+2B2CNlModel-method_+3A_as.closures">as.closures</code></td>
<td>
<p>If <code>TRUE</code> will return the result as a list of
approximating functions of time indexed by the pool number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>as.closures</code> is <code>FALSE</code> (the default) the return value is a matrix with as many columns as there are pools 
and as many rows as there are entries in the <code>times</code> 
argument the model has been built with.
</p>

<hr>
<h2 id='getC14'>Generic that yields the 14C content for all pools and all times</h2><span id='topic+getC14'></span>

<h3>Description</h3>

<p>Generic that yields the 14C content for all pools and all times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getC14(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getC14_+3A_object">object</code></td>
<td>
<p>a SoilR object</p>
</td></tr>
</table>

<hr>
<h2 id='getC14+2CModel_14-method'>automatic title</h2><span id='topic+getC14+2CModel_14-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_14'
getC14(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getC14+2B2CModel_14-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getCompartmentalMatrixFunc'>Compartmental matrix function</h2><span id='topic+getCompartmentalMatrixFunc'></span>

<h3>Description</h3>

<p>Compartmental matrix function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCompartmentalMatrixFunc(object, timeSymbol, state_variable_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCompartmentalMatrixFunc_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getCompartmentalMatrixFunc_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getCompartmentalMatrixFunc_+3A_state_variable_names">state_variable_names</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getCompartmentalMatrixFunc+2CBoundLinDecompOp-method'>automatic title</h2><span id='topic+getCompartmentalMatrixFunc+2CBoundLinDecompOp-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'BoundLinDecompOp'
getCompartmentalMatrixFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCompartmentalMatrixFunc+2B2CBoundLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getCompartmentalMatrixFunc+2CConstLinDecompOp-method'>Compartmental matrix function</h2><span id='topic+getCompartmentalMatrixFunc+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Compartmental matrix function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getCompartmentalMatrixFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCompartmentalMatrixFunc+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>a ConstLinDecompOp object</p>
</td></tr>
</table>

<hr>
<h2 id='getCompartmentalMatrixFunc+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+getCompartmentalMatrixFunc+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
getCompartmentalMatrixFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCompartmentalMatrixFunc+2B2CTransportDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getCompartmentalMatrixFunc+2CUnBoundNonLinDecompOp-method'>Extract the matrix valued function of time and state vector for the compartmental matrix</h2><span id='topic+getCompartmentalMatrixFunc+2CUnBoundNonLinDecompOp-method'></span>

<h3>Description</h3>

<p>Extract the matrix valued function of time and state vector for the compartmental matrix
</p>
<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundNonLinDecompOp'
getCompartmentalMatrixFunc(object)

## S4 method for signature 'UnBoundNonLinDecompOp'
getCompartmentalMatrixFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCompartmentalMatrixFunc+2B2CUnBoundNonLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantCompartmentalMatrix'>Constant compartmental matrix</h2><span id='topic+getConstantCompartmentalMatrix'></span>

<h3>Description</h3>

<p>Constant compartmental matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConstantCompartmentalMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantCompartmentalMatrix_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantCompartmentalMatrix+2CConstLinDecompOp-method'>Constant compartmental matrix</h2><span id='topic+getConstantCompartmentalMatrix+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Constant compartmental matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getConstantCompartmentalMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantCompartmentalMatrix+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>a ConstLinDecompOp object</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantCompartmentalMatrix+2CConstLinDecompOpWithLinearScalarFactor-method'>automatic title</h2><span id='topic+getConstantCompartmentalMatrix+2CConstLinDecompOpWithLinearScalarFactor-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOpWithLinearScalarFactor'
getConstantCompartmentalMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantCompartmentalMatrix+2B2CConstLinDecompOpWithLinearScalarFactor-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantInFluxVector'>Input flux vector</h2><span id='topic+getConstantInFluxVector'></span>

<h3>Description</h3>

<p>Input flux vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConstantInFluxVector(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantInFluxVector_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantInFluxVector+2CConstInFluxes-method'>automatic title</h2><span id='topic+getConstantInFluxVector+2CConstInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstInFluxes'
getConstantInFluxVector(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantInFluxVector+2B2CConstInFluxes-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantInternalFluxRateList_by_PoolIndex'>Constant internal flux rate list by pool index</h2><span id='topic+getConstantInternalFluxRateList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Constant internal flux rate list by pool index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConstantInternalFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantInternalFluxRateList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantInternalFluxRateList_by_PoolIndex+2CConstLinDecompOp-method'>Constant internal flux rate list by pool index</h2><span id='topic+getConstantInternalFluxRateList_by_PoolIndex+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Constant internal flux rate list by pool index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getConstantInternalFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantInternalFluxRateList_by_PoolIndex+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>a ConstLinDecomOp object</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantOutFluxRateList_by_PoolIndex'>Constant out flux rate list by pool index</h2><span id='topic+getConstantOutFluxRateList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Constant out flux rate list by pool index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConstantOutFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantOutFluxRateList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getConstantOutFluxRateList_by_PoolIndex+2CConstLinDecompOp-method'>Constant out flux rate list by pool index</h2><span id='topic+getConstantOutFluxRateList_by_PoolIndex+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Constant out flux rate list by pool index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getConstantOutFluxRateList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstantOutFluxRateList_by_PoolIndex+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>a ConstLinDecompOp object</p>
</td></tr>
</table>

<hr>
<h2 id='getConstLinDecompOp'>Constant linear decomposition operator</h2><span id='topic+getConstLinDecompOp'></span>

<h3>Description</h3>

<p>Constant linear decomposition operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConstLinDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstLinDecompOp_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getConstLinDecompOp+2CConstLinDecompOpWithLinearScalarFactor-method'>automatic title</h2><span id='topic+getConstLinDecompOp+2CConstLinDecompOpWithLinearScalarFactor-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOpWithLinearScalarFactor'
getConstLinDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getConstLinDecompOp+2B2CConstLinDecompOpWithLinearScalarFactor-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getCumulativeC'>Cummulative pool contents</h2><span id='topic+getCumulativeC'></span>

<h3>Description</h3>

<p>Cummulative pool contents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCumulativeC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCumulativeC_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getCumulativeC+2CNlModel-method'>automatic title</h2><span id='topic+getCumulativeC+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getCumulativeC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCumulativeC+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getDecompOp'>Decomposition operator of a model</h2><span id='topic+getDecompOp'></span>

<h3>Description</h3>

<p>Decomposition operator of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDecompOp_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getDecompOp+2CModel-method'>Extract the Compartmental Operator</h2><span id='topic+getDecompOp+2CModel-method'></span>

<h3>Description</h3>

<p>The method is usually used internally by other methods operating on 
models. The information it yields has either been provided by the user in
creating the modelrun or can be obtained by directly transforming the
arguments that were used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDecompOp+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The actual class of the result can vary. 
It will be a subclass of <code><a href="#topic+DecompOp-class">DecompOp</a></code>. 
These objects are an abstraction for a complete description of the fluxes in
the pool system regardless of the form it is provided in.
The information contained in these objects is equivalent to the set of internal and outward fluxes as
functions of pool contents and time and sufficient to infer
the &quot;Compartmental Matrix&quot; as a matrix valued function of the same arguments.
In the general case of a nonautonomous nonlinear Model this function
is a true function of  both, the pool contents and time.
In the case of an non-autonomous linear model it is a function of time only,
and in case of a autonomous linear model it is a constant matrix.
The vector valued function can be inferred by the generic  
function <code><a href="#topic+getFunctionDefinition">getFunctionDefinition</a></code>.
</p>

<hr>
<h2 id='getDecompOp+2CNlModel-method'>Extract the Compartmental Operator</h2><span id='topic+getDecompOp+2CNlModel-method'></span>

<h3>Description</h3>

<p>Extract the Compartmental Operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getDecompOp(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDecompOp+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The actual class of the result can vary. 
It will be a subclass of <code><a href="#topic+DecompOp-class">DecompOp</a></code>. 
These objects are an abstraction for a complete description of the fluxes in
the pool system regardless of the form it is provided in.
The information contained in these objects is equivalent to the set of internal and outward fluxes as
functions of pool contents and time and sufficient to infer
the &quot;Compartmental Matrix&quot; as a matrix valued function of the same arguments.
In the general case of a nonautonomous nonlinear Model this function
is a true function of  both, the pool contents and time.
In the case of an non-autonomous linear model it is a function of time only,
and in case of a autonomous linear model it is a constant matrix.
The vector valued function can be inferred by the generic  
function <code><a href="#topic+getFunctionDefinition">getFunctionDefinition</a></code>.
</p>

<hr>
<h2 id='getDotOut'>Dot out</h2><span id='topic+getDotOut'></span>

<h3>Description</h3>

<p>Dot out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDotOut(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDotOut_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getDotOut+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+getDotOut+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
getDotOut(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDotOut+2B2CTransportDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getF14'>Generic that yields the 14C fraction for the content all pools and all times</h2><span id='topic+getF14'></span>

<h3>Description</h3>

<p>Generic that yields the 14C fraction for the content all pools and all times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF14(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF14_+3A_object">object</code></td>
<td>
<p>A SoilR object of class Model14</p>
</td></tr>
</table>

<hr>
<h2 id='getF14+2CModel_14-method'>automatic title</h2><span id='topic+getF14+2CModel_14-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_14'
getF14(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF14+2B2CModel_14-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getF14C'>Generic that yields the 14C fraction for the cumulative content of all pools and all times</h2><span id='topic+getF14C'></span>

<h3>Description</h3>

<p>Generic that yields the 14C fraction for the cumulative content of all pools and all times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF14C(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF14C_+3A_object">object</code></td>
<td>
<p>a SoilR object of class Model 14</p>
</td></tr>
</table>

<hr>
<h2 id='getF14C+2CModel_14-method'>automatic title</h2><span id='topic+getF14C+2CModel_14-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_14'
getF14C(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF14C+2B2CModel_14-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getF14R'>Generic that yields the 14C fraction for the release flux of all pools and all times</h2><span id='topic+getF14R'></span>

<h3>Description</h3>

<p>Generic that yields the 14C fraction for the release flux of all pools and all times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getF14R(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF14R_+3A_object">object</code></td>
<td>
<p>a SoilR object of class Model14</p>
</td></tr>
</table>

<hr>
<h2 id='getF14R+2CModel_14-method'>automatic title</h2><span id='topic+getF14R+2CModel_14-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_14'
getF14R(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getF14R+2B2CModel_14-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFormat'>Get format of SoilR object</h2><span id='topic+getFormat'></span>

<h3>Description</h3>

<p>Get format of SoilR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFormat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFormat_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getFormat+2CFc-method'>automatic title</h2><span id='topic+getFormat+2CFc-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Fc'
getFormat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFormat+2B2CFc-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition'>Function definition of SoilR model</h2><span id='topic+getFunctionDefinition'></span>

<h3>Description</h3>

<p>Function definition of SoilR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFunctionDefinition(object, timeSymbol, poolNames, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getFunctionDefinition_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getFunctionDefinition_+3A_poolnames">poolNames</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getFunctionDefinition_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CConstInFluxes-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CConstInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstInFluxes'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CConstInFluxes-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CConstLinDecompOp-method'>Function describing an object of class ConstLinDecompOp</h2><span id='topic+getFunctionDefinition+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Function describing an object of class ConstLinDecompOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>object of class ConstLinDecompOp</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CConstLinDecompOpWithLinearScalarFactor-method'>convert names of  vectors or lists to class ConstantOutFluxRate 
convert names of  vectors or lists to class ConstantInternalFluxRate 
helper function</h2><span id='topic+getFunctionDefinition+2CConstLinDecompOpWithLinearScalarFactor-method'></span>

<h3>Description</h3>

<p>convert names of  vectors or lists to class ConstantOutFluxRate 
convert names of  vectors or lists to class ConstantInternalFluxRate 
helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOpWithLinearScalarFactor'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CConstLinDecompOpWithLinearScalarFactor-method_+3A_object">object</code></td>
<td>
<p>an object of class ConstLinDecompOpWithLinearScalarFactor</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CDecompositionOperator-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DecompositionOperator'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CInFluxList_by_PoolIndex-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CInFluxList_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InFluxList_by_PoolIndex'
getFunctionDefinition(object, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CInFluxList_by_PoolIndex-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getFunctionDefinition+2B2CInFluxList_by_PoolIndex-method_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CInFluxList_by_PoolName-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CInFluxList_by_PoolName-method'></span>

<h3>Description</h3>

<p>automatic title
</p>
<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InFluxList_by_PoolName'
getFunctionDefinition(object, timeSymbol, poolNames)

## S4 method for signature 'InFluxList_by_PoolName'
getFunctionDefinition(object, timeSymbol, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CInFluxList_by_PoolName-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getFunctionDefinition+2B2CInFluxList_by_PoolName-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getFunctionDefinition+2B2CInFluxList_by_PoolName-method_+3A_poolnames">poolNames</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CStateDependentInFluxVector-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CStateDependentInFluxVector-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'StateDependentInFluxVector'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CStateDependentInFluxVector-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CTimeMap-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CTimeMap-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CTransportDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CUnBoundInFluxes-method'>automatic title</h2><span id='topic+getFunctionDefinition+2CUnBoundInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundInFluxes'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CUnBoundInFluxes-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getFunctionDefinition+2CUnBoundLinDecompOp-method'>Extracts the time dependent matrix valued function (compartmental matrix)</h2><span id='topic+getFunctionDefinition+2CUnBoundLinDecompOp-method'></span>

<h3>Description</h3>

<p>Extracts the time dependent matrix valued function (compartmental matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundLinDecompOp'
getFunctionDefinition(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFunctionDefinition+2B2CUnBoundLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other UnBoundLinDecompOp_constructor: 
<code><a href="#topic+UnBoundLinDecompOp+2Cfunction-method">UnBoundLinDecompOp,function-method</a></code>
</p>

<hr>
<h2 id='getInFluxes'>Extract the influxes</h2><span id='topic+getInFluxes'></span>

<h3>Description</h3>

<p>Extract the influxes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInFluxes_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getInFluxes+2CModel-method'>Extract the InFluxes as provided during creation of the model</h2><span id='topic+getInFluxes+2CModel-method'></span>

<h3>Description</h3>

<p>Since the influxes had to be provided to create the model this method
yields no new information that can not be obtained simpler.  
It is usually called internally by other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getInFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInFluxes+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='getInFluxes+2CNlModel-method'>automatic title</h2><span id='topic+getInFluxes+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getInFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInFluxes+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getInitialValues'>Initial values of SoilR object</h2><span id='topic+getInitialValues'></span>

<h3>Description</h3>

<p>Initial values of SoilR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInitialValues(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInitialValues_+3A_object">object</code></td>
<td>
<p>a SoilR object</p>
</td></tr>
</table>

<hr>
<h2 id='getInitialValues+2CNlModel-method'>automatic title</h2><span id='topic+getInitialValues+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getInitialValues(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInitialValues+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getLinearScaleFactor'>Linear scale factor</h2><span id='topic+getLinearScaleFactor'></span>

<h3>Description</h3>

<p>Linear scale factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLinearScaleFactor(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLinearScaleFactor_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getLinearScaleFactor+2CConstLinDecompOpWithLinearScalarFactor-method'>automatic title</h2><span id='topic+getLinearScaleFactor+2CConstLinDecompOpWithLinearScalarFactor-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOpWithLinearScalarFactor'
getLinearScaleFactor(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLinearScaleFactor+2B2CConstLinDecompOpWithLinearScalarFactor-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getMeanTransitTime'>Mean transit time for SoilR objects</h2><span id='topic+getMeanTransitTime'></span>

<h3>Description</h3>

<p>Mean transit time for SoilR objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMeanTransitTime(object, inputDistribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeanTransitTime_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getMeanTransitTime_+3A_inputdistribution">inputDistribution</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getMeanTransitTime+2CConstLinDecompOp-method'>Mean transit time obtained through a numerical simulation. It produces an estimate with numerical errors. We recommend to use the function transitTime instead.</h2><span id='topic+getMeanTransitTime+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Mean transit time obtained through a numerical simulation. It produces an estimate with numerical errors. We recommend to use the function transitTime instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getMeanTransitTime(object, inputDistribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMeanTransitTime+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>a ConstLinDecompOp object</p>
</td></tr>
<tr><td><code id="getMeanTransitTime+2B2CConstLinDecompOp-method_+3A_inputdistribution">inputDistribution</code></td>
<td>
<p>a distribution of input contents among pools</p>
</td></tr>
</table>

<hr>
<h2 id='getNumberOfPools'>Number of pools in a model</h2><span id='topic+getNumberOfPools'></span>

<h3>Description</h3>

<p>Number of pools in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNumberOfPools(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfPools_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getNumberOfPools+2CMCSim-method'>automatic title</h2><span id='topic+getNumberOfPools+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
getNumberOfPools(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfPools+2B2CMCSim-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getNumberOfPools+2CNlModel-method'>automatic title</h2><span id='topic+getNumberOfPools+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getNumberOfPools(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfPools+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getNumberOfPools+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+getNumberOfPools+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
getNumberOfPools(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumberOfPools+2B2CTransportDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getOutputFluxes'>Generic Function to obtain the fluxes out of of the pools</h2><span id='topic+getOutputFluxes'></span>

<h3>Description</h3>

<p>Generic Function to obtain the fluxes out of of the pools
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOutputFluxes(object, as.closures = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutputFluxes_+3A_object">object</code></td>
<td>
<p>a SoilR object</p>
</td></tr>
<tr><td><code id="getOutputFluxes_+3A_as.closures">as.closures</code></td>
<td>
<p>a logical variable. Default to FALSE</p>
</td></tr>
</table>

<hr>
<h2 id='getOutputFluxes+2CNlModel-method'>automatic title</h2><span id='topic+getOutputFluxes+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getOutputFluxes(object, as.closures = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutputFluxes+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getOutputFluxes+2B2CNlModel-method_+3A_as.closures">as.closures</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getOutputReceivers'>Pools receiving outputs from other pools</h2><span id='topic+getOutputReceivers'></span>

<h3>Description</h3>

<p>Pools receiving outputs from other pools
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOutputReceivers(object, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutputReceivers_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getOutputReceivers_+3A_i">i</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getOutputReceivers+2CTransportDecompositionOperator+2Cnumeric-method'>automatic title</h2><span id='topic+getOutputReceivers+2CTransportDecompositionOperator+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator,numeric'
getOutputReceivers(object, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutputReceivers+2B2CTransportDecompositionOperator+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getOutputReceivers+2B2CTransportDecompositionOperator+2B2Cnumeric-method_+3A_i">i</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getParticleMonteCarloSimulator'>automatic title</h2><span id='topic+getParticleMonteCarloSimulator'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParticleMonteCarloSimulator(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParticleMonteCarloSimulator_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getParticleMonteCarloSimulator+2CNlModel-method'>automatic title</h2><span id='topic+getParticleMonteCarloSimulator+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getParticleMonteCarloSimulator(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParticleMonteCarloSimulator+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getReleaseFlux'>Generic Function to obtain the vector of release fluxes out of the pools for all times.</h2><span id='topic+getReleaseFlux'></span>

<h3>Description</h3>

<p>Generic Function to obtain the vector of release fluxes out of the pools for all times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReleaseFlux(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReleaseFlux_+3A_object">object</code></td>
<td>
<p>A SoilR object</p>
</td></tr>
</table>

<hr>
<h2 id='getReleaseFlux+2CModel_by_PoolNames-method'>automatic title</h2><span id='topic+getReleaseFlux+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
getReleaseFlux(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReleaseFlux+2B2CModel_by_PoolNames-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='getReleaseFlux+2CModel-method'>The release fluxes <code class="reqn">\frac{[content]}{[time]}</code> for all pools.</h2><span id='topic+getReleaseFlux+2CModel-method'></span>

<h3>Description</h3>

<p>The release fluxes <code class="reqn">\frac{[content]}{[time]}</code> for all pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getReleaseFlux(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReleaseFlux+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many columns as there are pools 
and as many rows as there are entries in the <code>times</code> argument the model has been build with.
</p>

<hr>
<h2 id='getReleaseFlux+2CNlModel-method'>automatic title</h2><span id='topic+getReleaseFlux+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getReleaseFlux(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReleaseFlux+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getReleaseFlux14'>Generic that yields the 14C fraction in the release flux</h2><span id='topic+getReleaseFlux14'></span>

<h3>Description</h3>

<p>Generic that yields the 14C fraction in the release flux
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReleaseFlux14(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReleaseFlux14_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getReleaseFlux14+2CModel_14-method'>automatic title</h2><span id='topic+getReleaseFlux14+2CModel_14-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_14'
getReleaseFlux14(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReleaseFlux14+2B2CModel_14-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getRightHandSideOfODE'>Right hand side of ODE of a SoilR model</h2><span id='topic+getRightHandSideOfODE'></span>

<h3>Description</h3>

<p>Right hand side of ODE of a SoilR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRightHandSideOfODE(object, timeSymbol, poolNames, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRightHandSideOfODE_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getRightHandSideOfODE_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getRightHandSideOfODE_+3A_poolnames">poolNames</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getRightHandSideOfODE_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getRightHandSideOfODE+2CModel_by_PoolNames-method'>Provide the (vector valued) derivative of the stocks with respect to time</h2><span id='topic+getRightHandSideOfODE+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>This function is required by the ODE solvers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
getRightHandSideOfODE(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRightHandSideOfODE+2B2CModel_by_PoolNames-method_+3A_object">object</code></td>
<td>
<p>The model</p>
</td></tr>
</table>

<hr>
<h2 id='getRightHandSideOfODE+2CModel-method'>Derivative of the state variables as function</h2><span id='topic+getRightHandSideOfODE+2CModel-method'></span>

<h3>Description</h3>

<p>For non-linear models or models with state dependent influxes 
the returned function is a true function of state and time
For linear models with state independent influxes the returned 
function is in fact a function of time only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getRightHandSideOfODE(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRightHandSideOfODE+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function <code class="reqn">f(t)</code>
</p>

<hr>
<h2 id='getSolution'>Calculates all stocks all fluxes to ,in and out of  the compartment system and also their integrals over time</h2><span id='topic+getSolution'></span>

<h3>Description</h3>

<p>Have a look at the methods for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSolution(object, params, as.closures = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSolution_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getSolution_+3A_params">params</code></td>
<td>
<p>parameter values</p>
</td></tr>
<tr><td><code id="getSolution_+3A_as.closures">as.closures</code></td>
<td>
<p>a logical variable. Default to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns representing the name of the statevariable, flux and accumulated flux for every time
</p>
<p>as specified by the <code>times</code> of the model.
</p>

<hr>
<h2 id='getSolution+2CModel_by_PoolNames-method'>All Fluxes and stocks for all times</h2><span id='topic+getSolution+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>All Fluxes and stocks for all times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
getSolution(object, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSolution+2B2CModel_by_PoolNames-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
<tr><td><code id="getSolution+2B2CModel_by_PoolNames-method_+3A_params">params</code></td>
<td>
<p>parameter values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many columns as there are pools 
and as many rows as there are entries in the <code>times</code> argument the model has been build with.
</p>

<hr>
<h2 id='getTimeRange'>Time range of a model simulation</h2><span id='topic+getTimeRange'></span>

<h3>Description</h3>

<p>Time range of a model simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CConstInFluxes-method'>automatic title</h2><span id='topic+getTimeRange+2CConstInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstInFluxes'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CConstInFluxes-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CConstLinDecompOp-method'>Time range of a simulation described in an object of class ConstLinDecompOp</h2><span id='topic+getTimeRange+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Time range of a simulation described in an object of class ConstLinDecompOp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CConstLinDecompOpWithLinearScalarFactor-method'>automatic title</h2><span id='topic+getTimeRange+2CConstLinDecompOpWithLinearScalarFactor-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOpWithLinearScalarFactor'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CConstLinDecompOpWithLinearScalarFactor-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CDecompositionOperator-method'>automatic title</h2><span id='topic+getTimeRange+2CDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DecompositionOperator'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CTimeMap-method'>The time interval where the function is defined</h2><span id='topic+getTimeRange+2CTimeMap-method'></span>

<h3>Description</h3>

<p>The time interval where the function is defined
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CTimeMap-method_+3A_object">object</code></td>
<td>
<p>a TimeMap object</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CUnBoundInFluxes-method'>automatic title</h2><span id='topic+getTimeRange+2CUnBoundInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundInFluxes'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CUnBoundInFluxes-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTimeRange+2CUnBoundLinDecompOp-method'>Extracts the time interval for which the function is valid.</h2><span id='topic+getTimeRange+2CUnBoundLinDecompOp-method'></span>

<h3>Description</h3>

<p>Extracts the time interval for which the function is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundLinDecompOp'
getTimeRange(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimeRange+2B2CUnBoundLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTimes'>Time vector of SoilR object</h2><span id='topic+getTimes'></span>

<h3>Description</h3>

<p>Time vector of SoilR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTimes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes_+3A_object">object</code></td>
<td>
<p>a SoilR object</p>
</td></tr>
</table>

<hr>
<h2 id='getTimes+2CModel_by_PoolNames-method'>Extract the times vector</h2><span id='topic+getTimes+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>Since the <code>times</code> had to be provided to create the model this method
yields no new information. 
It is usually called internally by other functions that deal with models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
getTimes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes+2B2CModel_by_PoolNames-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='getTimes+2CModel-method'>Extract the times vector</h2><span id='topic+getTimes+2CModel-method'></span>

<h3>Description</h3>

<p>Since the <code>times</code> had to be provided to create the model this method
yields no new information. 
It is usually called internally by other functions that deal with models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
getTimes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes+2B2CModel-method_+3A_object">object</code></td>
<td>
<p>A modelrun as produced by the constructors: 
<code><a href="#topic+Model">Model</a></code>,
<code><a href="#topic+Model_by_PoolNames">Model_by_PoolNames</a></code>,
<code><a href="#topic+Model_14">Model_14</a></code>
the function <code><a href="#topic+GeneralModel">GeneralModel</a></code> or the functions listed in 
<code><a href="#topic+predefinedModels">predefinedModels</a></code>. <br />
A model represents the initial value problem (IVP)  
for the contents of the pool consisting of 
</p>

<ul>
<li><p> The initial values of the pool content
</p>
</li>
<li><p> The system of ordinary differential equations, as dictated by the fluxes
</p>
</li>
<li><p> The times for which the solution of the IVP is evaluated.
</p>
</li></ul>
</td></tr>
</table>

<hr>
<h2 id='getTimes+2CNlModel-method'>automatic title</h2><span id='topic+getTimes+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getTimes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTimes+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTransferCoefficients'>Transfer coefficients</h2><span id='topic+getTransferCoefficients'></span>

<h3>Description</h3>

<p>Transfer coefficients
</p>
<p>Transfer coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransferCoefficients(object, as.closures = F)

getTransferCoefficients(object, as.closures = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransferCoefficients_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getTransferCoefficients_+3A_as.closures">as.closures</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getTransferCoefficients+2CNlModel-method'>automatic title</h2><span id='topic+getTransferCoefficients+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
getTransferCoefficients(object, as.closures = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransferCoefficients+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="getTransferCoefficients+2B2CNlModel-method_+3A_as.closures">as.closures</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTransferCoefficients+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+getTransferCoefficients+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
getTransferCoefficients(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransferCoefficients+2B2CTransportDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTransferMatrix'>deprecated, use getTransferMatrixFunc instead</h2><span id='topic+getTransferMatrix'></span>

<h3>Description</h3>

<p>deprecated, use getTransferMatrixFunc instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransferMatrix(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransferMatrix_+3A_object">object</code></td>
<td>
<p>A compartmental operator</p>
</td></tr>
</table>

<hr>
<h2 id='getTransferMatrixFunc'>Transfer matrix function</h2><span id='topic+getTransferMatrixFunc'></span>

<h3>Description</h3>

<p>Transfer matrix function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransferMatrixFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransferMatrixFunc_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getTransferMatrixFunc+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+getTransferMatrixFunc+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
getTransferMatrixFunc(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransferMatrixFunc+2B2CTransportDecompositionOperator-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='getTransitTimeDistributionDensity'>Transit time distribution for SoilR objects</h2><span id='topic+getTransitTimeDistributionDensity'></span>

<h3>Description</h3>

<p>Transit time distribution for SoilR objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransitTimeDistributionDensity(object, inputDistribution, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransitTimeDistributionDensity_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getTransitTimeDistributionDensity_+3A_inputdistribution">inputDistribution</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="getTransitTimeDistributionDensity_+3A_times">times</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getTransitTimeDistributionDensity+2CConstLinDecompOp-method'>Transit time distribution obtained through a numerical simulation. It introduces numerical errors. We recommend to use the function transitTime instead</h2><span id='topic+getTransitTimeDistributionDensity+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>Transit time distribution obtained through a numerical simulation. It introduces numerical errors. We recommend to use the function transitTime instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
getTransitTimeDistributionDensity(object, inputDistribution, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransitTimeDistributionDensity+2B2CConstLinDecompOp-method_+3A_object">object</code></td>
<td>
<p>a ConstLinDecompOp object</p>
</td></tr>
<tr><td><code id="getTransitTimeDistributionDensity+2B2CConstLinDecompOp-method_+3A_inputdistribution">inputDistribution</code></td>
<td>
<p>an input distribution among pools</p>
</td></tr>
<tr><td><code id="getTransitTimeDistributionDensity+2B2CConstLinDecompOp-method_+3A_times">times</code></td>
<td>
<p>a variable with times to obtain the distribution</p>
</td></tr>
</table>

<hr>
<h2 id='getValues'>Get values of SoilR object</h2><span id='topic+getValues'></span>

<h3>Description</h3>

<p>Get values of SoilR object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getValues(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues_+3A_object">object</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='getValues+2CConstFc-method'>automatic title</h2><span id='topic+getValues+2CConstFc-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstFc'
getValues(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getValues+2B2CConstFc-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='Graven2017'>Compiled records of radicarbon in atmospheric CO2 for historical simulations in CMIP6</h2><span id='topic+Graven2017'></span>

<h3>Description</h3>

<p>Historical Delta-14C in atmospheric CO2 used as forcing dataset for CMIP6 simulation experiments. 
Data is reported for three hemispheric zones, for the period 1850-2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Graven2017)
</code></pre>


<h3>Format</h3>

<p>A data frame with 166 rows and 4 variables.
</p>

<dl>
<dt><code>Year.AD</code></dt><dd><p>Year (AD).</p>
</dd>
<dt><code>NH</code></dt><dd><p>Delta14C for the northern hemisphere, betwen 30N to 90N latitude. Values in per mil.</p>
</dd>
<dt><code>Tropics</code></dt><dd><p>Delta14C for the tropics, between 30N to 30S latitude. Values in per mil.</p>
</dd>
<dt><code>SH</code></dt><dd><p>Delta14C for the southern hemisphere, between 30S to 90S latitude. Values in per mil.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All details about the derivation of this dataset are provided in Graven et al. (2017)
</p>


<h3>Author(s)</h3>

<p>Carlos Sierra <a href="mailto:csierra@bgc-jena.mpg.de">csierra@bgc-jena.mpg.de</a>
</p>


<h3>Source</h3>

<p>&lt;https://doi.org/10.22033/ESGF/input4MIPs.1602&gt;
</p>


<h3>References</h3>

<p>Graven, Heather; Allison, Colin; Etheridge, David; Hammer, Samuel; Keeling, Ralph; Levin, Ingeborg; 
Meijer, Harro A. J.; Rubino, Mauro; Tans, Pieter; Trudinger, Cathy; Vaughn, Bruce; White, James (2017). 
Compiled Historical Record of Atmospheric Delta14CO2 version 2.0. Earth System Grid Federation. 
https://doi.org/10.22033/ESGF/input4MIPs.1602
</p>
<p>Graven, H., Allison, C. E., Etheridge, D. M., Hammer, S., Keeling, R. F., Levin, I., Meijer, 
H. A. J., Rubino, M., Tans, P. P., Trudinger, C. M., Vaughn, B. H., and White, J. W. C. 2017. 
Compiled records of carbon isotopes in atmospheric CO2 for historical simulations in CMIP6, 
Geosci. Model Dev., 10, 4405–4417, https://doi.org/10.5194/gmd-10-4405-2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matplot(Graven2017[,1], Graven2017[,-1],type="l",
       lty=1, xlab="Year AD", ylab="Delta14C (per mil)", bty="n")
legend("topleft",names(Graven2017[,-1]), lty=1, col=1:3, bty="n")

</code></pre>

<hr>
<h2 id='HarvardForest14CO2'>Delta14C in soil CO2 efflux from Harvard Forest</h2><span id='topic+HarvardForest14CO2'></span>

<h3>Description</h3>

<p>Measurements of Delta14C in soil CO2 efflux conducted at Harvard Forest,
USA, between 1996 and 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HarvardForest14CO2
</code></pre>


<h3>Format</h3>

<p>A data frame with the following 3 variables.  
</p>

<ol>
<li><p> Year 
A numeric vector with the date of measurement in years
</p>
</li>
<li><p> D14C 
A numeric vector with the value of the Delta 14C value measured in CO2 efflux in per mil
</p>
</li>
<li><p> Site 
A factor indicating the site where measurements were 
made. NWN: Northwest Near, Drydown:
Rainfall exclusion experiment. 
</p>
</li></ol>



<h3>Details</h3>

<p>Samples for isotopic measurements of soil CO2 efflux were collected from
chambers that enclosed an air headspace in contact with the soil surface in
the absence of vegetation using a closed dynamic chamber system to collect
accumulated CO2 in stainless steel traps with a molecular sieve inside. See
Sierra et al. (2012) for additional details.
</p>


<h3>References</h3>

<p>Sierra, C. A., Trumbore, S. E., Davidson, E. A., Frey, S. D.,
Savage, K. E., and Hopkins, F. M. 2012. Predicting decadal trends and
transient responses of radiocarbon storage and fluxes in a temperate forest
soil, Biogeosciences, 9, 3013-3028, doi:10.5194/bg-9-3013-2012
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(HarvardForest14CO2[,1:2])

</code></pre>

<hr>
<h2 id='Hua2013'>Atmospheric radiocarbon for the period 1950-2010 from Hua et al. (2013)</h2><span id='topic+Hua2013'></span>

<h3>Description</h3>

<p>Atmospheric radiocarbon for the period 1950-2010 reported by Hua et al. (2013) for 5 atmospheric zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hua2013)
</code></pre>


<h3>Format</h3>

<p>A <a href="base.html#topic+list">list</a> containing 5 data frames, each representing an atmospheric zone. The zones are: 
NHZone1: northern hemisphere zone 1, NHZone2: northern hemisphere zone 2,
NHZone3: northern hemisphere zone 3, SHZone12: southern hemisphere zones 1 and 2, 
SHZone3: southern hemisphere zone 3. Each data frame contains a variable number of observations 
on the following 5 variables.
</p>

<dl>
<dt><code>Year.AD</code></dt><dd><p>Year AD</p>
</dd>
<dt><code>mean.Delta14C</code></dt><dd><p>mean value of atmospheric radiocarbon reported as Delta14C</p>
</dd>
<dt><code>sd.Delta14C</code></dt><dd><p>standard deviation of atmospheric radiocarbon reported as Delta14C</p>
</dd>
<dt><code>mean.F14C</code></dt><dd><p>mean value of atmospheric radiocarbon reported as fraction modern F14C</p>
</dd>
<dt><code>sd.F14</code></dt><dd><p>standard deviation of atmospheric radiocarbon reported as fraction modern F14C</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset corresponds to Table S3 from Hua et al. (2013). For additional details see the original publication.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.2458/azu_js_rc.v55i2.16177">doi:10.2458/azu_js_rc.v55i2.16177</a>
</p>


<h3>References</h3>

<p>Hua Q., M. Barbetti, A. Z. Rakowski. 2013. Atmospheric radiocarbon for the period 1950-2010. Radiocarbon 55(4):2059-2072.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Hua2013$NHZone1$Year.AD, Hua2013$NHZone1$mean.Delta14C, 
     type="l",xlab="Year AD",ylab=expression(paste(Delta^14,"C (per mille)")))
lines(Hua2013$NHZone2$Year.AD,Hua2013$NHZone2$mean.Delta14C,col=2)
lines(Hua2013$NHZone3$Year.AD,Hua2013$NHZone3$mean.Delta14C,col=3)
lines(Hua2013$SHZone12$Year.AD,Hua2013$SHZone12$mean.Delta14C,col=4)
lines(Hua2013$SHZone3$Year.AD,Hua2013$SHZone3$mean.Delta14C,col=5)
legend(
	"topright",
	c(
		"Norther hemisphere zone 1",
		"Norther hemisphere zone 2",
		"Norther hemisphere zone 3",
                "Southern hemisphere zones 1 and 2",
		"Southern Hemispher zone 3"
	),
	lty=1,
	col=1:5,
	bty="n"
)

</code></pre>

<hr>
<h2 id='Hua2021'>Atmospheric radiocarbon for the period 1950-2019 from Hua et al. (2021)</h2><span id='topic+Hua2021'></span>

<h3>Description</h3>

<p>Atmospheric radiocarbon for the period 1950-2019 reported by Hua et al. (2020) for 5 atmospheric zones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Hua2013)
</code></pre>


<h3>Format</h3>

<p>A <a href="base.html#topic+list">list</a> containing 5 data frames, each representing an atmospheric zone. The zones are: 
NHZone1: northern hemisphere zone 1, NHZone2: northern hemisphere zone 2,
NHZone3: northern hemisphere zone 3, SHZone1-2: southern hemisphere zones 1 and 2, 
SHZone3: southern hemisphere zone 3. Each data frame contains a variable number of observations 
on the following 5 variables.
</p>

<dl>
<dt><code>Year</code></dt><dd><p>Year AD</p>
</dd>
<dt><code>mean.Delta14C</code></dt><dd><p>mean value of atmospheric radiocarbon reported as Delta14C</p>
</dd>
<dt><code>sd.Delta14C</code></dt><dd><p>standard deviation of atmospheric radiocarbon reported as Delta14C</p>
</dd>
<dt><code>mean.F14C</code></dt><dd><p>mean value of atmospheric radiocarbon reported as fraction modern F14C</p>
</dd>
<dt><code>sd.F14C</code></dt><dd><p>standard deviation of atmospheric radiocarbon reported as fraction modern F14C</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset corresponds to Supplementary Material 2 from Hua et al. (2021). For additional details see the original publication.
</p>


<h3>Author(s)</h3>

<p>Carlos A. Sierra <a href="mailto:csierra@bgc-jena.mpg.de">csierra@bgc-jena.mpg.de</a>
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1017/RDC.2021.95">doi:10.1017/RDC.2021.95</a>
</p>


<h3>References</h3>

<p>Hua, Q., Turnbull, J., Santos, G., Rakowski, A., Ancapichun, S., De Pol-Holz, R., . . . Turney, C. (2021). ATMOSPHERIC RADIOCARBON FOR THE PERIOD 1950–2019. Radiocarbon, 1-23. doi:10.1017/RDC.2021.95
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(Hua2021$NHZone1[,1:2],type="l")
lines(Hua2021$NHZone2[,1:2],col=2)
lines(Hua2021$NHZone3[,1:2],col=3)
lines(Hua2021$`SHZone1-2`[,1:2],col=4)
lines(Hua2021$SHZone3[,1:2],col=5)
legend("topright",names(Hua2021), col=1:5,lty=1,bty="n")

</code></pre>

<hr>
<h2 id='ICBM_N'>Implementation of the ICBM/N model</h2><span id='topic+ICBM_N'></span>

<h3>Description</h3>

<p>This implementations follows the description in Katterer and Andren (2001, Eco Mod 136:191).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICBM_N(
  i = 0.47,
  k_Y = 0.259,
  k_O = 0.0154,
  r_e = 1,
  e_Y = 0.362,
  h = 0.243,
  q_i = 18.8,
  q_b = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICBM_N_+3A_i">i</code></td>
<td>
<p>carbon input to the soil from plant production</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_k_y">k_Y</code></td>
<td>
<p>decomposition rate of young pool Y</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_k_o">k_O</code></td>
<td>
<p>decomposition rate of old pool O</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_r_e">r_e</code></td>
<td>
<p>external effects on decomposition rates</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_e_y">e_Y</code></td>
<td>
<p>yield efficiency of the soil organism community</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_h">h</code></td>
<td>
<p>humification coefficient. Fraction of outflux from Y that is not respired and enters O</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_q_i">q_i</code></td>
<td>
<p>C:N ratio of plant inputs</p>
</td></tr>
<tr><td><code id="ICBM_N_+3A_q_b">q_b</code></td>
<td>
<p>C:N ratio of soil organism biomass</p>
</td></tr>
</table>

<hr>
<h2 id='ICBMModel'>Implementation of the Introductory Carbon Balance Model (ICBM)</h2><span id='topic+ICBMModel'></span>

<h3>Description</h3>

<p>This function is an implementation of the Introductory Carbon Balance Model
(ICBM). This is simply a two pool model connected in series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICBMModel(
  t,
  ks = c(k1 = 0.8, k2 = 0.00605),
  h = 0.13,
  r = 1.32,
  c0 = c(Y0 = 0.3, O0 = 3.96),
  In = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICBMModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 with the decomposition rates for the young
and the old pool.</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_h">h</code></td>
<td>
<p>Humufication coefficient (transfer rate from young to old pool).</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_r">r</code></td>
<td>
<p>External (environmental or edaphic) factor.</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_c0">c0</code></td>
<td>
<p>A vector of length 2 with the initial value of carbon stocks in
the young and old pool.</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_in">In</code></td>
<td>
<p>Mean annual carbon input to the soil.</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ICBMModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Andren, O. and T. Katterer. 1997. ICBM: The Introductory Carbon
Balance Model for Exploration of Soil Carbon Balances. Ecological
Applications 7:1226-1236.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples from external files
# inst/examples/exICBMModel.R exICBMModel_paper:

    # This example reproduces the simulations 
    # presented in Table 1 of Andren and Katterer (1997).
    # First, the model is run for different values of the 
    # parameters representing different field experiments. 
    times=seq(0,20,by=0.1)
    Bare=ICBMModel(t=times) #Bare fallow
    pNpS=ICBMModel(t=times, h=0.125, r=1,    c0=c(0.3,4.11),  In=0.19+0.095) #+N +Straw
    mNpS=ICBMModel(t=times, h=0.125, r=1.22, c0=c(0.3, 4.05), In=0.19+0.058) #-N +Straw
    mNmS=ICBMModel(t=times, h=0.125, r=1.17, c0=c(0.3, 3.99), In=0.057) #-N -Straw
    pNmS=ICBMModel(t=times, h=0.125, r=1.07, c0=c(0.3, 4.02), In=0.091) #+N -Straw
    FM=ICBMModel(t=times, h=0.250, r=1.10, c0=c(0.3, 3.99), In=0.19+0.082) #Manure
    SwS=ICBMModel(t=times, h=0.340, r=0.97, c0=c(0.3, 4.14), In=0.19+0.106) #Sewage Sludge
    SS=ICBMModel(t=times, h=0.125, r=1.00, c0=c(0.25, 4.16), In=0.2)  #Steady State

    #The amount of carbon for each simulation is recovered with the function getC
    CtBare=getC(Bare)
    CtpNpS=getC(pNpS)
    CtmNpS=getC(mNpS)
    CtmNmS=getC(mNmS)
    CtpNmS=getC(pNmS)
    CtFM=getC(FM)
    CtSwS=getC(SwS)
    CtSS=getC(SS)

    #This plot reproduces Figure 1 in Andren and Katterer (1997)
    plot(times,
      rowSums(CtBare),
      type="l",
      ylim=c(0,8),
      xlim=c(0,20),
      ylab="Topsoil carbon mass (kg m-2)",
      xlab="Time (years)"
    )
    lines(times,rowSums(CtpNpS),lty=2)
    lines(times,rowSums(CtmNpS),lty=3)
    lines(times,rowSums(CtmNmS),lty=4)
    lines(times,rowSums(CtpNmS),lwd=2)
    lines(times,rowSums(CtFM),lty=2,lwd=2)
    lines(times,rowSums(CtSwS),lty=3,lwd=2)
    #lines(times,rowSums(CtSS),lty=4,lwd=2)
    legend("topleft",
      c("Bare fallow",
        "+N +Straw",
        "-N +Straw",
        "-N -Straw",
        "+N -Straw",
        "Manure",
       "Sludge"
      ),
      lty=c(1,2,3,4,1,2,3),
      lwd=c(1,1,1,1,2,2,2),
      bty="n"
    )

</code></pre>

<hr>
<h2 id='incubation_experiment'>Soil CO2 efflux from an incubation experiment, along with the soil mass and carbon concentration measurements.</h2><span id='topic+incubation_experiment'></span>

<h3>Description</h3>

<p>A dataset with soil CO2 efflux measurements from a laboratory incubation at controlled temperature and moisture conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(incubation_experiment)
</code></pre>


<h3>Format</h3>

<p>A list with 3 variables.
</p>

<dl>
<dt><code>eCO2</code></dt><dd><p>A data.frame with the flux data.</p>
</dd>
<dt><code>c_concentrations</code></dt><dd><p>a vector with 3 measurement of the concentration of carbon in the soil.</p>
</dd>
<dt><code>soil_mass</code></dt><dd><p>the mass of the soil column in g</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data.frame incubation_experiment$eCO2 has 3 columns.
</p>

<dl>
<dt><code>Days</code></dt><dd><p>A numeric vector with the day of measurement after the experiment started.</p>
</dd>
<dt><code>eCO2mean</code></dt><dd><p>A numeric vector with the release flux of CO2. Units in ug C g-1 soil day-1.</p>
</dd>
<dt><code>eCO2sd</code></dt><dd><p>A numeric vector with the standard deviation of the release flux of CO2-C. Units in ug C g-1 soil day-1.</p>
</dd>
</dl>

<p>A laboratory incubation experiment was performed in March 2014 for a period of 35 days under controlled conditions of temperature (15 degrees Celsius), moisture (30 percent soil water content), and oxygen levels (20 percent). Soil CO2 measurements were taken using an automated system for gas sampling connected to an infrared gas analyzer. The soil was sampled at a boreal forest site (Caribou Poker Research Watershed, Alaska, USA). This dataset presents the mean and standard deviation of 4 replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eCO2=incubation_experiment$eCO2
head(eCO2)

plot(eCO2[,1:2],type="o",ylim=c(0,50),ylab="CO2 efflux (ug C g-1 soil day-1)")
arrows(eCO2[,1],eCO2[,2]-eCO2[,3],eCO2[,1],eCO2[,2]+eCO2[,3], angle=90,length=0.3,code=3)

</code></pre>

<hr>
<h2 id='InFlux'>Generic constructor for the class with the same name</h2><span id='topic+InFlux'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InFlux(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFlux_+3A_map">map</code></td>
<td>
<p>a SoilR map</p>
</td></tr>
<tr><td><code id="InFlux_+3A_...">...</code></td>
<td>
<p>additional arguments to function</p>
</td></tr>
</table>

<hr>
<h2 id='InFlux_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+InFlux_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InFlux_by_PoolIndex(func, destinationIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFlux_by_PoolIndex_+3A_func">func</code></td>
<td>
<p>function with influx</p>
</td></tr>
<tr><td><code id="InFlux_by_PoolIndex_+3A_destinationindex">destinationIndex</code></td>
<td>
<p>index of destination pool</p>
</td></tr>
</table>

<hr>
<h2 id='InFlux_by_PoolIndex-class'>S4 class for the influx to a single pool identified by the index</h2><span id='topic+InFlux_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>S4 class for the influx to a single pool identified by the index
</p>

<hr>
<h2 id='InFlux_by_PoolIndex+2Cfunction+2Cnumeric-method'>Constructor from an ordered pair of PoolIndex (integer like) objects</h2><span id='topic+InFlux_by_PoolIndex+2Cfunction+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Constructor from an ordered pair of PoolIndex (integer like) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',numeric'
InFlux_by_PoolIndex(func, destinationIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric-method_+3A_func">func</code></td>
<td>
<p>A function f(X,t) where X is a vector of the state variables.</p>
</td></tr>
<tr><td><code id="InFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric-method_+3A_destinationindex">destinationIndex</code></td>
<td>
<p>index of destination pool
This form is required internally by the solvers and supported for backward compatibility with earlier versions of SoilR.
Note that the function func given in this form can not be transformed to a different ordering of state variables, since the location of a state variable in the vector argument depends on a specific order and will be 'hardcoded' into your function. 
See <code><a href="#topic+InFlux_by_PoolName">InFlux_by_PoolName</a></code> for the new, more powerful interface which allows subsequent reordering of the state variables by using the names of the state variables as formal arguments for <code>func</code>. In this case SoilR can infer (and later adapt) the
vector argument form needed for the solvers.</p>
</td></tr>
</table>

<hr>
<h2 id='InFlux_by_PoolName'>Generic constructor for an influx to a single pool from an ordered pair of PoolName (string like) and function  objects</h2><span id='topic+InFlux_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for an influx to a single pool from an ordered pair of PoolName (string like) and function  objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InFlux_by_PoolName(func, destinationName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFlux_by_PoolName_+3A_func">func</code></td>
<td>
<p>function with input flux</p>
</td></tr>
<tr><td><code id="InFlux_by_PoolName_+3A_destinationname">destinationName</code></td>
<td>
<p>name of the destination pool</p>
</td></tr>
</table>

<hr>
<h2 id='InFlux_by_PoolName-class'>S4 class for the influx to a single pool identified by the name</h2><span id='topic+InFlux_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4 class for the influx to a single pool identified by the name
</p>

<hr>
<h2 id='InFlux_by_PoolName+2Cfunction+2Ccharacter-method'>Constructor from an ordered pair of PoolName (string like) and function  objects</h2><span id='topic+InFlux_by_PoolName+2Cfunction+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Constructor from an ordered pair of PoolName (string like) and function  objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',character'
InFlux_by_PoolName(func, destinationName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFlux_by_PoolName+2B2Cfunction+2B2Ccharacter-method_+3A_func">func</code></td>
<td>
<p>A function. The names of the formal arguments have to be a subset of the state variable names and the time symbol 
This allows subsequent automatic reordering of the state variables.
In the presence of a vector of state-variable-names the formulation can 
automatically be transformed to a function of a state VECTOR argument and 
time</p>
</td></tr>
<tr><td><code id="InFlux_by_PoolName+2B2Cfunction+2B2Ccharacter-method_+3A_destinationname">destinationName</code></td>
<td>
<p>PoolName (string like) object and a function</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes'>A generic factory for subclasses of <a href="#topic+InFluxes-class">InFluxes</a></h2><span id='topic+InFluxes'></span>

<h3>Description</h3>

<p>A generic factory for subclasses of <a href="#topic+InFluxes-class">InFluxes</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InFluxes(object, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes_+3A_object">object</code></td>
<td>
<p>a SoilR object</p>
</td></tr>
<tr><td><code id="InFluxes_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>number of pools in the model</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes-class'>A virtual S4-class representing (different subclasses) of in-fluxes to the system</h2><span id='topic+InFluxes-class'></span>

<h3>Description</h3>

<p>A virtual S4-class representing (different subclasses) of in-fluxes to the system
</p>

<hr>
<h2 id='InFluxes+2CConstantInFluxList_by_PoolIndex-method'>automatic title</h2><span id='topic+InFluxes+2CConstantInFluxList_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstantInFluxList_by_PoolIndex'
InFluxes(object, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2CConstantInFluxList_by_PoolIndex-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="InFluxes+2B2CConstantInFluxList_by_PoolIndex-method_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes+2Cfunction-method'>automatic title</h2><span id='topic+InFluxes+2Cfunction-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function''
InFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2Cfunction-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes+2CInFluxes-method'>automatic title</h2><span id='topic+InFluxes+2CInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'InFluxes'
InFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2CInFluxes-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes+2Clist-method'>automatic title</h2><span id='topic+InFluxes+2Clist-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
InFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes+2Cnumeric-method'>automatic title</h2><span id='topic+InFluxes+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
InFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2Cnumeric-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes+2CStateIndependentInFluxList_by_PoolIndex-method'>automatic title</h2><span id='topic+InFluxes+2CStateIndependentInFluxList_by_PoolIndex-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'StateIndependentInFluxList_by_PoolIndex'
InFluxes(object, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2CStateIndependentInFluxList_by_PoolIndex-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="InFluxes+2B2CStateIndependentInFluxList_by_PoolIndex-method_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>no manual documentation
basically produces a vector valued function from a list of scalar functions</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxes+2CTimeMap-method'>automatic title</h2><span id='topic+InFluxes+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
InFluxes(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxes+2B2CTimeMap-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+InFluxList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxList_by_PoolIndex-class'>Describes a list of flux rates.</h2><span id='topic+InFluxList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>The purpose is to avoid creation of lists that contain negative rates
or in accidental confusion with list of fluxes.
Instances are usually automatically created from data
</p>

<hr>
<h2 id='InFluxList_by_PoolIndex+2Clist-method'>constructor from a normal list
after checking the elements</h2><span id='topic+InFluxList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
after checking the elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
InFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>list</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+InFluxList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='InFluxList_by_PoolName-class'>Class for a list of influxes indexed by the names of the target pools</h2><span id='topic+InFluxList_by_PoolName-class'></span>

<h3>Description</h3>

<p>Class for a list of influxes indexed by the names of the target pools
</p>

<hr>
<h2 id='InFluxList_by_PoolName+2Clist-method'>constructor from a normal list</h2><span id='topic+InFluxList_by_PoolName+2Clist-method'></span>

<h3>Description</h3>

<p>after checking the elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
InFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InFluxList_by_PoolName+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>no documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CConstLinDecompOp-method'>automatic title</h2><span id='topic+initialize+2CConstLinDecompOp-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ConstLinDecompOp'
initialize(.Object, mat = matrix())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CConstLinDecompOp-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CConstLinDecompOp-method_+3A_mat">mat</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CDecompositionOperator-method'>automatic title</h2><span id='topic+initialize+2CDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DecompositionOperator'
initialize(
  .Object,
  starttime = numeric(),
  endtime = numeric(),
  map = function(t) {
     t
 },
  lag = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CDecompositionOperator-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CDecompositionOperator-method_+3A_starttime">starttime</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CDecompositionOperator-method_+3A_endtime">endtime</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CDecompositionOperator-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CDecompositionOperator-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CMCSim-method'>automatic title</h2><span id='topic+initialize+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
initialize(.Object, model = new(Class = "NlModel"), tasklist = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CMCSim-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CMCSim-method_+3A_model">model</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CMCSim-method_+3A_tasklist">tasklist</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CModel_14-method'>Internal method to supervise creation of objects of this class</h2><span id='topic+initialize+2CModel_14-method'></span>

<h3>Description</h3>

<p>It is usually not necessary for user code to call this method.
It's purpose is to enforce some sanity checks since it gets automatically
called by <code>new</code> whenever an object of this class is created
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_14'
initialize(
  .Object,
  times = c(0, 1),
  mat = ConstLinDecompOp(matrix(nrow = 1, ncol = 1, 0)),
  initialValues = numeric(),
  initialValF = ConstFc(values = c(0), format = "Delta14C"),
  inputFluxes = BoundInFluxes(function(t) {
     return(matrix(nrow = 1, ncol = 1, 1))

    }, 0, 1),
  c14Fraction = BoundFc(function(t) {
     return(matrix(nrow = 1, ncol = 1, 1))
 }, 0,
    1),
  c14DecayRate = 0,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_mat">mat</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_initialvalues">initialValues</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_initialvalf">initialValF</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_c14fraction">c14Fraction</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_c14decayrate">c14DecayRate</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_solverfunc">solverfunc</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_14-method_+3A_pass">pass</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CModel_by_PoolNames-method'>automatic title</h2><span id='topic+initialize+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
initialize(
  .Object,
  times,
  mat,
  initialValues,
  inputFluxes,
  timeSymbol,
  pass = FALSE,
  solverfunc = deSolve.lsoda.wrapper
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_mat">mat</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_initialvalues">initialValues</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_pass">pass</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel_by_PoolNames-method_+3A_solverfunc">solverfunc</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CModel-method'>Internal method to supervise creation of objects of this class</h2><span id='topic+initialize+2CModel-method'></span>

<h3>Description</h3>

<p>It is usually not necessary for user code to call this method.
It's purpose is to enforce some sanity checks since it gets automatically
called by <code>new</code> whenever an object of this class is created
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
initialize(
  .Object,
  times = c(0, 1),
  mat = ConstLinDecompOp(matrix(nrow = 1, ncol = 1, 0)),
  initialValues = numeric(),
  inputFluxes = BoundInFluxes(function(t) {
     return(matrix(nrow = 1, ncol = 1, 1))

    }, 0, 1),
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CModel-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel-method_+3A_mat">mat</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel-method_+3A_initialvalues">initialValues</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel-method_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel-method_+3A_solverfunc">solverfunc</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CModel-method_+3A_pass">pass</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CNlModel-method'>automatic title</h2><span id='topic+initialize+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
initialize(
  .Object,
  times = c(0, 1),
  DepComp = new(Class = "TransportDecompositionOperator", 0, 1, function(t) {
    
    return(matrix(nrow = 1, ncol = 1, 0))
 }, function(t) {
     return(matrix(nrow = 1,
    ncol = 1, 0))
 }),
  initialValues = numeric(),
  inputFluxes = BoundInFluxes(function(t) {
     return(matrix(nrow = 1, ncol = 1, 1))

    }, 0, 1),
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_depcomp">DepComp</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_initialvalues">initialValues</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_solverfunc">solverfunc</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CNlModel-method_+3A_pass">pass</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CTimeMap-method'>automatic title</h2><span id='topic+initialize+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
initialize(
  .Object,
  starttime = numeric(),
  endtime = numeric(),
  map = function(t) {
     t
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CTimeMap-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTimeMap-method_+3A_starttime">starttime</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTimeMap-method_+3A_endtime">endtime</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTimeMap-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CTransportDecompositionOperator-method'>automatic title</h2><span id='topic+initialize+2CTransportDecompositionOperator-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TransportDecompositionOperator'
initialize(
  .Object,
  starttime = numeric(),
  endtime = numeric(),
  numberOfPools = 1,
  alpha = list(),
  f = function(t, O) {
     t
 },
  lag = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_starttime">starttime</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_endtime">endtime</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_alpha">alpha</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_f">f</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CTransportDecompositionOperator-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CUnBoundInFluxes-method'>automatic title</h2><span id='topic+initialize+2CUnBoundInFluxes-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundInFluxes'
initialize(
  .Object,
  map = function() {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CUnBoundInFluxes-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CUnBoundInFluxes-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='initialize+2CUnBoundLinDecompOp-method'>automatic title</h2><span id='topic+initialize+2CUnBoundLinDecompOp-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'UnBoundLinDecompOp'
initialize(
  .Object,
  matFunc = function() {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2CUnBoundLinDecompOp-method_+3A_.object">.Object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="initialize+2B2CUnBoundLinDecompOp-method_+3A_matfunc">matFunc</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='IntCal09'>Northern Hemisphere atmospheric radiocarbon for the pre-bomb period</h2><span id='topic+IntCal09'></span>

<h3>Description</h3>

<p>Northern Hemisphere atmospheric radiocarbon calibration curve for the period 0 to 50,000 yr BP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IntCal09)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3522 observations on the following 5 variables.
</p>

<dl>
<dt><code>CAL.BP</code></dt><dd><p>Calibrated age in years Before Present (BP).</p>
</dd>
<dt><code>C14.age</code></dt><dd><p>C14 age in years BP.</p>
</dd>
<dt><code>Error</code></dt><dd><p>Error estimate for <code>C14.age</code>.</p>
</dd>
<dt><code>Delta.14C</code></dt><dd><p>Delta.14C value in per mil.</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>Standard deviation of <code>Delta.14C</code> in per mil.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>Deltal.14C</code> is age-corrected as per Stuiver and Polach (1977). All details about the derivation of this dataset are provided in Reimer et al. (2009).
</p>


<h3>References</h3>

<p>P. Reimer, M.Baillie, E. Bard, A. Bayliss, J. Beck, P. Blackwell, C. Ramsey, C. Buck, G. Burr, R. Edwards, et al. 2009. IntCal09 and Marine09 radiocarbon age calibration curves, 0 - 50,000 years cal bp. Radiocarbon, 51(4):1111 - 1150.
</p>
<p>M. Stuiver and H. A. Polach. 1977. Rerporting of C-14 data. Radiocarbon, 19(3):355 - 363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow=c(2,1))
plot(IntCal09$CAL.BP, IntCal09$C14.age, type="l")
polygon(x=c(IntCal09$CAL.BP,rev(IntCal09$CAL.BP)),
	y=c(IntCal09$C14.age+IntCal09$Error,rev(IntCal09$C14.age-IntCal09$Error)),
	col="gray",border=NA)
lines(IntCal09$CAL.BP,IntCal09$C14.age)

plot(IntCal09$CAL.BP,IntCal09$Delta.14C,type="l")
polygon(x=c(IntCal09$CAL.BP,rev(IntCal09$CAL.BP)),
	y=c(IntCal09$Delta.14C+IntCal09$Sigma,rev(IntCal09$Delta.14C-IntCal09$Sigma)),
	col="gray",border=NA)
lines(IntCal09$CAL.BP,IntCal09$Delta.14C)
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='IntCal13'>Atmospheric radiocarbon for the 0-50,000 yr BP period</h2><span id='topic+IntCal13'></span>

<h3>Description</h3>

<p>Atmospheric radiocarbon calibration curve for the period 0 to 50,000 yr BP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IntCal13)
</code></pre>


<h3>Format</h3>

<p>A data frame with 5140 observations on the following 5 variables.
</p>

<dl>
<dt><code>CAL.BP</code></dt><dd><p>Calibrated age in years Before Present (BP).</p>
</dd>
<dt><code>C14.age</code></dt><dd><p>C14 age in years BP.</p>
</dd>
<dt><code>Error</code></dt><dd><p>Error estimate for <code>C14.age</code>.</p>
</dd>
<dt><code>Delta.14C</code></dt><dd><p>Delta.14C value in per mil.</p>
</dd>
<dt><code>Sigma</code></dt><dd><p>Standard deviation of <code>Delta.14C</code> in per mil.</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>Deltal.14C</code> is age-corrected as per Stuiver and Polach (1977). All details about the derivation of this dataset are provided in Reimer et al. (2013).
</p>


<h3>References</h3>

<p>Reimer PJ, Bard E, Bayliss A, Beck JW, Blackwell PG, Bronk Ramsey C, Buck CE,
Cheng H, Edwards RL, Friedrich M, Grootes PM, Guilderson TP, Haflidason H, 
Hajdas I, Hatte C, Heaton TJ, Hogg AG, Hughen KA, Kaiser KF, Kromer B, 
Manning SW, Niu M, Reimer RW, Richards DA, Scott EM, Southon JR, Turney CSM,
van der Plicht J. 2013. IntCal13 and MARINE13 radiocarbon age calibration curves 0-50000 years calBP. Radiocarbon 55(4): 1869-1887. DOI: 10.2458/azu_js_rc.55.16947
</p>
<p>M. Stuiver and H. A. Polach. 1977. Rerporting of C-14 data. Radiocarbon, 19(3):355 - 363.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     plot(IntCal13$CAL.BP,IntCal13$C14.age-IntCal13$Error,type="l",col=2,
          xlab="cal BP",ylab="14C BP")
     lines(IntCal13$CAL.BP,IntCal13$C14.age+IntCal13$Error,col=2)

     plot(IntCal13$CAL.BP,IntCal13$Delta.14C+IntCal13$Sigma,type="l",col=2,
          xlab="cal BP",ylab="Delta14C")
     lines(IntCal13$CAL.BP,IntCal13$Delta.14C-IntCal13$Sigma,col=2)

</code></pre>

<hr>
<h2 id='IntCal20'>The IntCal20 northern hemisphere radiocarbon curve for the 0-55,000 yr BP period</h2><span id='topic+IntCal20'></span>

<h3>Description</h3>

<p>Atmospheric radiocarbon calibration curve for the period 0 to 55,000 yr BP for the northern hemosphere. This is the most recent update to the internationally agreed calibration curve and supersedes <code><a href="#topic+IntCal13">IntCal13</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IntCal20)
</code></pre>


<h3>Format</h3>

<p>A data frame with 9501 rows and 5 variables.
</p>

<dl>
<dt><code>CAL.BP</code></dt><dd><p>Calibrated age in years Before Present (BP).</p>
</dd>
<dt><code>C14.age</code></dt><dd><p>C14 age in years BP.</p>
</dd>
<dt><code>Sigma.C14.age</code></dt><dd><p>Standard deviation for <code>C14.age</code>.</p>
</dd>
<dt><code>Delta.14C</code></dt><dd><p>Delta.14C value in per mil.</p>
</dd>
<dt><code>Sigma.Delta.14C</code></dt><dd><p>Standard deviation of <code>Delta.14C</code> in per mil.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All details about the derivation of this dataset are provided in Reimer et al. (2020).
</p>


<h3>Author(s)</h3>

<p>Ingrid Chanca <a href="mailto:ichanca@bgc-jena.mpg.de">ichanca@bgc-jena.mpg.de</a>
</p>


<h3>Source</h3>

<p>&lt;https://doi.org/10.1017/RDC.2020.41&gt;
</p>


<h3>References</h3>

<p>Reimer, P., Austin, W., Bard, E., Bayliss, A., Blackwell, P., Bronk Ramsey, C., . . . Talamo, S. (2020). 
The IntCal20 Northern Hemisphere Radiocarbon Age Calibration Curve (0–55 cal kBP). 
Radiocarbon, 62(4), 725-757. doi:10.1017/RDC.2020.41
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    plot(IntCal20$CAL.BP, IntCal20$Delta.14C, type="l", 
         xlab="cal BP", ylab="Delta14C (per mil)")

</code></pre>

<hr>
<h2 id='InternalFlux_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+InternalFlux_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InternalFlux_by_PoolIndex(func, sourceIndex, destinationIndex, src_to_dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFlux_by_PoolIndex_+3A_func">func</code></td>
<td>
<p>function with flux rate</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolIndex_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>index of the source pool</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolIndex_+3A_destinationindex">destinationIndex</code></td>
<td>
<p>index of the destination pool</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolIndex_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>source to destination</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFlux_by_PoolIndex-class'>S4-class for a single internal flux with source and destination pools specified by indices</h2><span id='topic+InternalFlux_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>S4-class for a single internal flux with source and destination pools specified by indices
</p>

<hr>
<h2 id='InternalFlux_by_PoolIndex+2Cfunction+2Cnumeric+2Cnumeric+2Cmissing-method'>constructor from an ordered pair of PoolIndex (integer like) objects and a function with vector argument</h2><span id='topic+InternalFlux_by_PoolIndex+2Cfunction+2Cnumeric+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>constructor from an ordered pair of PoolIndex (integer like) objects and a function with vector argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',numeric,numeric,missing'
InternalFlux_by_PoolIndex(func, sourceIndex, destinationIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing-method_+3A_func">func</code></td>
<td>
<p>function</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing-method_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>index of source pool</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing-method_+3A_destinationindex">destinationIndex</code></td>
<td>
<p>index of destination pool</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFlux_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+InternalFlux_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InternalFlux_by_PoolName(func, sourceName, destinationName, src_to_dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFlux_by_PoolName_+3A_func">func</code></td>
<td>
<p>function with flux rate</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolName_+3A_sourcename">sourceName</code></td>
<td>
<p>name of source pool</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolName_+3A_destinationname">destinationName</code></td>
<td>
<p>name of destination pool</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolName_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>source to destination</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFlux_by_PoolName-class'>S4-class for a single internal flux with source and destination pools specified by name</h2><span id='topic+InternalFlux_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4-class for a single internal flux with source and destination pools specified by name
</p>

<hr>
<h2 id='InternalFlux_by_PoolName+2Cfunction+2Ccharacter+2Ccharacter+2Cmissing-method'>constructor from an ordered pair of PoolName (string like) objects and a function with the set of formal argument names forming a 
subset of the state_variable_names</h2><span id='topic+InternalFlux_by_PoolName+2Cfunction+2Ccharacter+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>constructor from an ordered pair of PoolName (string like) objects and a function with the set of formal argument names forming a 
subset of the state_variable_names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',character,character,missing'
InternalFlux_by_PoolName(func, sourceName, destinationName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFlux_by_PoolName+2B2Cfunction+2B2Ccharacter+2B2Ccharacter+2B2Cmissing-method_+3A_func">func</code></td>
<td>
<p>A real valued function describing the flux (mass/time)
as function of (some of ) the state variables and time.</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolName+2B2Cfunction+2B2Ccharacter+2B2Ccharacter+2B2Cmissing-method_+3A_sourcename">sourceName</code></td>
<td>
<p>A string identifying the source pool of the flux</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolName+2B2Cfunction+2B2Ccharacter+2B2Ccharacter+2B2Cmissing-method_+3A_destinationname">destinationName</code></td>
<td>
<p>A string identifying the destination pool of the flux</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFlux_by_PoolName+2Cfunction+2Cmissing+2Cmissing+2Ccharacter-method'>automatic title</h2><span id='topic+InternalFlux_by_PoolName+2Cfunction+2Cmissing+2Cmissing+2Ccharacter-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',missing,missing,character'
InternalFlux_by_PoolName(func, src_to_dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFlux_by_PoolName+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Ccharacter-method_+3A_func">func</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="InternalFlux_by_PoolName+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Ccharacter-method_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFluxList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+InternalFluxList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InternalFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFluxList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFluxList_by_PoolIndex-class'>S4-class for a list of internal fluxes with source and destination pool inidices</h2><span id='topic+InternalFluxList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>S4-class for a list of internal fluxes with source and destination pool inidices
</p>

<hr>
<h2 id='InternalFluxList_by_PoolIndex+2Clist-method'>Constructor from a normal list
after checking the elements</h2><span id='topic+InternalFluxList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>Constructor from a normal list
after checking the elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
InternalFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFluxList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>a list</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFluxList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+InternalFluxList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InternalFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFluxList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='InternalFluxList_by_PoolName-class'>S4-class for a list of internal fluxes with indexed by (source and destination pool) names</h2><span id='topic+InternalFluxList_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4-class for a list of internal fluxes with indexed by (source and destination pool) names
</p>

<hr>
<h2 id='InternalFluxList_by_PoolName+2Clist-method'>constructor from a normal list</h2><span id='topic+InternalFluxList_by_PoolName+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
InternalFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InternalFluxList_by_PoolName+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+InternalFlux_by_PoolName-class">InternalFlux_by_PoolName</a> or 
a list where the names of the elements are strings of the form
'1-&gt;3' (for the flux rate from pool 1 to 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantInFluxList_by_PoolIndex-class">ConstantInFluxList_by_PoolIndex</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='linearScalarModel'>Implementation of a general model for linear non-autonomous systems with scalar modifiers</h2><span id='topic+linearScalarModel'></span>

<h3>Description</h3>

<p>This function implements a linear model with scalar modifier for inputs
and compartmental matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearScalarModel(
  t,
  A,
  C0,
  u,
  gamma,
  xi,
  xi_lag = 0,
  solver = deSolve.lsoda.wrapper
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearScalarModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_a">A</code></td>
<td>
<p>A square (n x n) matrix with compartmental structure</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length n containing the initial amount of carbon for
the n pools.</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_u">u</code></td>
<td>
<p>A vector of length n with constant mass inputs for the n pools.</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_gamma">gamma</code></td>
<td>
<p>A scalar or data.frame object specifying the modifier for the
mass inputs.</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_xi">xi</code></td>
<td>
<p>A scalar, data.frame, function or anything that can be 
converted to a scalar function of time <code><a href="#topic+ScalarTimeMap-class">ScalarTimeMap</a></code> 
object  specifying the external  (environmental and/or edaphic) effects on
decomposition rates.</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_xi_lag">xi_lag</code></td>
<td>
<p>A time shift/delay  for the automatically 
created time dependent function xi(t)</p>
</td></tr>
<tr><td><code id="linearScalarModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil organic
matter decomposition: the SoilR package version 1.0. Geoscientific Model
Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RothCModel">RothCModel</a></code>. There are other
<code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more general functions like
<code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t=seq(0,52*200,1) # Fix me! Add an example.  
</code></pre>

<hr>
<h2 id='linesCPool'>Add lines with the output of <code><a href="#topic+getC14">getC14</a></code>, <code><a href="#topic+getC">getC</a></code>, or
<code><a href="#topic+getReleaseFlux">getReleaseFlux</a></code> to an existing plot</h2><span id='topic+linesCPool'></span>

<h3>Description</h3>

<p>This function adds lines to a plot with the C content, the C release, or
Delta 14C value of each pool over time. Needs as input a matrix obtained
after a call to <code><a href="#topic+getC14">getC14</a></code>, <code><a href="#topic+getC">getC</a></code>, or
<code><a href="#topic+getReleaseFlux">getReleaseFlux</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesCPool(t, mat, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linesCPool_+3A_t">t</code></td>
<td>
<p>A vector containing the time points for plotting.</p>
</td></tr>
<tr><td><code id="linesCPool_+3A_mat">mat</code></td>
<td>
<p>A matrix object obtained after a call to <code><a href="#topic+getC14">getC14</a></code>,
<code><a href="#topic+getC">getC</a></code>, or <code><a href="#topic+getReleaseFlux">getReleaseFlux</a></code>.</p>
</td></tr>
<tr><td><code id="linesCPool_+3A_col">col</code></td>
<td>
<p>A color palette specifying color lines for each pool (columns of
<code>mat</code>).</p>
</td></tr>
<tr><td><code id="linesCPool_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>plot</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='listProduct'>tensor product of lists</h2><span id='topic+listProduct'></span>

<h3>Description</h3>

<p>Creates a list of all combinations of the elements of the inputlists (like a
&quot;tensor product list &quot; The list elements can be of any class. The function
is used in examples and tests to produce all possible combinations of
arguments to a function. look at the tests for example usage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listProduct(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listProduct_+3A_...">...</code></td>
<td>
<p>lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists each containing one combinations of the elements of
the input lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>listProduct(list('a','b'),list(1,2))
</code></pre>

<hr>
<h2 id='MCSim-class'>Experimental Class for a Monte Carlo Simulation of particles leaving the pool</h2><span id='topic+MCSim-class'></span>

<h3>Description</h3>

<p>Experimental Class for a Monte Carlo Simulation of particles leaving the pool
</p>

<hr>
<h2 id='Model'>Constructor for class <a href="#topic+Model-class">Model</a></h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>This function creates an object of class <a href="#topic+Model-class">Model</a>, The arguments
can be given in different form as long as they can be converted to the
necessary internal building blocks.  (See the links)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model(
  t,
  A,
  ivList,
  inputFluxes,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="Model_+3A_a">A</code></td>
<td>
<p>something that can be converted by <a href="#topic+GeneralDecompOp">GeneralDecompOp</a> to any of
the available subclasses of <code><a href="#topic+DecompOp-class">DecompOp</a></code>.</p>
</td></tr>
<tr><td><code id="Model_+3A_ivlist">ivList</code></td>
<td>
<p>A numeric vector containing the initial amount of carbon for
the n pools. The length of this vector is equal to the number of pools. This
is checked by an internal function.</p>
</td></tr>
<tr><td><code id="Model_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>something that can be converted by <a href="#topic+InFluxes">InFluxes</a>
to any of the available subclasses of <a href="#topic+InFluxes-class">InFluxes</a>.</p>
</td></tr>
<tr><td><code id="Model_+3A_solverfunc">solverfunc</code></td>
<td>
<p>The function used to actually solve the ODE system. The
default is <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> but you can also provide your
own function that the same interface.</p>
</td></tr>
<tr><td><code id="Model_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it does not
pass internal sanity checks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>Model</code> wraps the internal constructor of class
<a href="#topic+Model-class">Model</a>. The internal constructor requires the argument <code>A</code>
to be of class <a href="#topic+DecompOp-class">DecompOp</a> and argument <code>inputFluxes</code> to be
of class <a href="#topic+InFluxes-class">InFluxes</a>. Before calling the internal constructor
<code>Model</code> calls <a href="#topic+GeneralDecompOp">GeneralDecompOp</a> on its argument <code>A</code> and
<a href="#topic+InFluxes">InFluxes</a> on its argument <code>inputFluxes</code> to convert them into
the required classes. Both are generic functions. Follow the links to see
for which kind of inputs conversion methods are available. The attempted
conversion allows great flexibility with respect to arguments and
independence from the actual implementation. However if your code uses the
wrong argument the error will most likely occur in the delegate functions.
If this happens inspect the error message (or use <code>traceback()</code>) to see
which function was called and try to call the constructor of the desired
subclass explicitly with your arguments.  The subclasses are linked in the
class documentation <a href="#topic+DecompOp-class">DecompOp</a> or <a href="#topic+InFluxes-class">InFluxes</a>
respectively.
</p>
<p>Note also that this function checks its arguments quite elaborately and
tries to detect accidental unreasonable combinations, especially concerning
two kinds of errors. 
</p>
 
<ol>
<li><p> unintended extrapolation of time series data 
</p>
</li>
<li><p> violations of mass balance by the DecompOp argument. 
</p>
</li></ol>

<p>SoilR has a lot of unit tests which are installed with the package and are
sometimes instructive as examples.  To see example scenarios for parameter
check look at:

</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+Model-class">Model</a> that can be queried by many
methods to be found there.
</p>


<h3>See Also</h3>

<p>This function is called by many of the <a href="#topic+predefinedModels">predefinedModels</a>. <br />
Package functions called in the examples:<br />
<code><a href="#topic+example.2DInFluxes.Args">example.2DInFluxes.Args</a></code>,<br />
<code><a href="#topic+example.2DGeneralDecompOpArgs">example.2DGeneralDecompOpArgs</a></code>,<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vim:set ff=unix expandtab ts=2 sw=2:
test.all.possible.Model.arguments &lt;- function(){
  # This example shows different kinds of arguments to the function Model.
  # The model objects we will build will share some common features.
  #  - two pools 
  #  - initial values 

  iv&lt;-  c(5,6)
  times &lt;- seq(1,10,by=0.1)

  # The other parameters A and inputFluxes will be different
  # The function Model will transform these arguments 
  # into objects of the classes required by the internal constructor.
  # This leads to a number of possible argument types. 
  # We demonstrate some of the possibilities here.
  # Let us first look at the choeices for argument 'A'.
  
  #) 
  possibleAs  &lt;- example.2DGeneralDecompOpArgs()
  
  # Since "Model" will call "InFluxes" on its "inputFluxes" 
  # argument there are again different choices
  # we have included a function in SoilR that produces 2D examples
  
  possibleInfluxes &lt;- example.2DInFluxes.Args()
 print(possibleInfluxes$I.vec)
  # We can build a lot of  models from the possible combinations
  # for instance   
  #m1 &lt;- Model(
  #        t=times,
  #        A=matrix(nrow=2,byrow=TRUE,c(-0.1,0,0,-0.2)),
  #        ivList=iv,
  #        inputFluxes=possibleInfluxes$I.vec) 
  ## We now produce all combinations of As and InputFluxes
  combinations &lt;- listProduct(possibleAs,possibleInfluxes)
  print(length(combinations))
  # and a Model for each
  models &lt;- lapply(
              combinations,
              function(combi){
                #Model(t=times,A=combi$A,ivList=iv,inputFluxes=combi$I)
                Model(t=times,A=combi[[1]],ivList=iv,inputFluxes=combi[[2]])
              }
            )
  ## lets check that we can compute something# 
  lapply(models,getC)
}
</code></pre>

<hr>
<h2 id='Model_14'>general constructor for class Model_14</h2><span id='topic+Model_14'></span>

<h3>Description</h3>

<p>This method tries to create an object from any combination of arguments that
can be converted into the required set of building blocks for the Model_14
for n arbitrarily connected pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model_14(
  t,
  A,
  ivList,
  initialValF,
  inputFluxes,
  inputFc,
  c14DecayRate = -0.0001209681,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model_14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="Model_14_+3A_a">A</code></td>
<td>
<p>something that can be converted by <a href="#topic+GeneralDecompOp">GeneralDecompOp</a> to any of
the available subclasses of <code><a href="#topic+DecompOp-class">DecompOp</a></code>.</p>
</td></tr>
<tr><td><code id="Model_14_+3A_ivlist">ivList</code></td>
<td>
<p>A vector containing the initial amount of carbon for the n
pools. The length of this vector is equal to the number of pools and thus
equal to the length of k. This is checked by an internal function.</p>
</td></tr>
<tr><td><code id="Model_14_+3A_initialvalf">initialValF</code></td>
<td>
<p>An object equal or equivalent to class ConstFc containing
a vector with the initial values of the radiocarbon fraction for each pool
and a format string describing in which format the values are given.</p>
</td></tr>
<tr><td><code id="Model_14_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>something that can be converted by <a href="#topic+InFluxes">InFluxes</a>
to any of the available subclasses of <a href="#topic+InFluxes-class">InFluxes</a>.</p>
</td></tr>
<tr><td><code id="Model_14_+3A_inputfc">inputFc</code></td>
<td>
<p>An object describing the fraction of C_14 in per mille
(different formats are possible)</p>
</td></tr>
<tr><td><code id="Model_14_+3A_c14decayrate">c14DecayRate</code></td>
<td>
<p>the rate at which C_14 decays radioactively. If you don't
provide a value here we assume the following value: k=-0.0001209681 y^-1 .
This has the side effect that all your time related data are treated as if
the time unit was year. Thus beside time itself it also affects decay rates
the inputrates and the output</p>
</td></tr>
<tr><td><code id="Model_14_+3A_solverfunc">solverfunc</code></td>
<td>
<p>The function used by to actually solve the ODE system.
This can be <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user provided
function with the same interface.</p>
</td></tr>
<tr><td><code id="Model_14_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it is invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model object that can be further queried.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TwopParallelModel">TwopParallelModel</a></code>, <code><a href="#topic+TwopSeriesModel">TwopSeriesModel</a></code>,
<code><a href="#topic+TwopFeedbackModel">TwopFeedbackModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples from external files
# inst/tests/requireSoilR/runit.all.possible.Model.arguments.R test.all.possible.Model.arguments:

  # This example shows different kinds of arguments to the function Model.
  # The model objects we will build will share some common features.
  #  - two pools 
  #  - initial values 

       iv&lt;-  c(5,6)

  #  - times 

       times &lt;- seq(1,10,by=0.1)

  # The other parameters A and inputFluxes will be different
  # The function Model will transform these arguments 
  # into objects of the classes required by the internal constructor.
  # This leads to a number of possible argument types. 
  # We demonstrate some of the possibilities here.
  # Let us first look at the choeices for argument 'A'.
  
  #) 
  possibleAs  &lt;- example.2DGeneralDecompOpArgs()
  
  # Since "Model" will call "InFluxes" on its "inputFluxes" 
  # argument there are again different choices
  # we have included a function in SoilR that produces 2D examples
  
  possibleInfluxes &lt;- example.2DInFluxes.Args()
 print(possibleInfluxes$I.vec)
  # We can build a lot of  models from the possible combinations
  # for instance   
  #m1 &lt;- Model(
  #        t=times,
  #        A=matrix(nrow=2,byrow=TRUE,c(-0.1,0,0,-0.2)),
  #        ivList=iv,
  #        inputFluxes=possibleInfluxes$I.vec) 
  ## We now produce that all combinations of As and InputFluxes
  combinations &lt;- listProduct(possibleAs,possibleInfluxes)
  print(length(combinations))
  # an a Model for each
  models &lt;- lapply(
              combinations,
              function(combi){
                #Model(t=times,A=combi$A,ivList=iv,inputFluxes=combi$I)
                Model(t=times,A=combi[[1]],ivList=iv,inputFluxes=combi[[2]])
              }
            )
  ## lets check that we can compute something# 
  lapply(models,getC)

# inst/examples/ModelExamples.R CorrectNonautonomousLinearModelExplicit:

  # This example describes the creation and use of a Model object that 
  # is defined by time dependent functions for decomposition and influx.
  # The constructor of the Model-class  (see  ?Model) 
  # works for different combinations of 
  # arguments.
  # Although Model (the constructor function for objects of this class 
  # accepts many many more convenient kinds of arguments,
  # we will in this example call the constructor whith arguments which 
  # are of the same type as one of hte current internal 
  # representations in the 
  # Model object and create these arguments explicitly beforehand 
  # to demonstrate the approach with the most flexibility.
  # We start with the Decomposition Operator.
  # For this example we assume that we are able to describe the
  # decomposition ofperator  by explicit R functions that are valid 
  # for a finite time interval.
  # Therefore we choose the appropriate  sub class BoundLinDecompOp
  # of DecompOp explicitly.  (see ?'BoundLinDecompOp-class') 
  A=BoundLinDecompOp(
    ## We call the generic constructor (see ?BoundLindDcompOp) 
    ## which has a method  
    ## that takes a matrix-valued function of time as its first argument.
    ## (Although Model accepts time series data directly and 
    ## will derive the internally used interpolating for you, 
    ## the function argument could for instance represent the result
    ## of a very sophisticated interpolation performed by yourself)
    function(t){
      matrix(nrow=3,ncol=3,byrow=TRUE,
         c(
           -1,    0,        0,
          0.5,   -2,        0,
            0,    1, sin(t)-1 
        )
      )    
    },
    ## The other two arguments describe the time interval where the 
    ## function is valid (the domain of the function)
    ## The interval will be checked against the domain of the InFlux
    ## argument of Model and against its 't' argument to avoid 
    ## invalid computations outside the domain. 
    ## (Inf and -Inf are possible values, but should only be used 
    ## if the function is really valid for all times, which is 
    ## especially untrue for functions resulting from interpolations,
    ## which are usually extremely misleading for arguments outside the 
    ## domain covered by the data that has been used for the interpolation.)
    ## This is a safety net against wrong results origination from unitendet EXTRApolation )
    starttime=0,
    endtime=20
  )  
  I=BoundInFluxes(
     ## The first argument is a vector-valued function of time
     function(t){
       matrix(nrow=3,ncol=1,byrow=TRUE,
           c(-1,    0,    0)
       )
     },
     ## The other two arguments describe the time interval where the 
     ## function is valid (the domain of the function)
     starttime=0,
     endtime=40
  )
  ## No we specify the points in time where we want 
  ## to compute results
  t_start=0 
  t_end=10 
  tn=50
  timestep &lt;- (t_end-t_start)/tn 
  times &lt;- seq(t_start,t_end,timestep) 
  ## and the start values
  sv=c(0,0,0)
  mod=Model(t=times,A,sv,I)

  ## No we use the model to compute some results
  getC(mod)
  getReleaseFlux(mod)
  #also look at the methods section of Model-class 

</code></pre>

<hr>
<h2 id='Model_14-class'>S4-class to represent a 14C model run</h2><span id='topic+Model_14-class'></span>

<h3>Description</h3>

<p>S4-class to represent a 14C model run
</p>

<hr>
<h2 id='Model_by_PoolNames'>Constructor for <code><a href="#topic+Model_by_PoolNames-class">Model_by_PoolNames</a></code></h2><span id='topic+Model_by_PoolNames'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+Model_by_PoolNames-class">Model_by_PoolNames</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model_by_PoolNames(
  smod,
  times,
  mat,
  initialValues,
  inputFluxes,
  internal_fluxes,
  out_fluxes,
  timeSymbol,
  solverfunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model_by_PoolNames_+3A_smod">smod</code></td>
<td>
<p>see methods</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_times">times</code></td>
<td>
<p>a vector of times</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_mat">mat</code></td>
<td>
<p>a compartmental matrix</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_initialvalues">initialValues</code></td>
<td>
<p>a vector of initial values</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_inputfluxes">inputFluxes</code></td>
<td>
<p>a vector of input fluxes</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_internal_fluxes">internal_fluxes</code></td>
<td>
<p>flux rate among pools</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_out_fluxes">out_fluxes</code></td>
<td>
<p>flux rates out of pools</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>character symbol used to represent time</p>
</td></tr>
<tr><td><code id="Model_by_PoolNames_+3A_solverfunc">solverfunc</code></td>
<td>
<p>function used to solve system of ODEs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A possibly nonlinear Model(run) that contains information about the
pool names and connectivity of the pools and is therefore the preferred
representation for new code.
</p>

<hr>
<h2 id='Model_by_PoolNames-class'>A model run based on flux functions</h2><span id='topic+Model_by_PoolNames-class'></span>

<h3>Description</h3>

<p>A model run based on flux functions
</p>

<hr>
<h2 id='Model-class'>S4 class representing a model run</h2><span id='topic+Model-class'></span>

<h3>Description</h3>

<p>S4 class representing a model run
</p>

<hr>
<h2 id='NlModel-class'>deprecated class for a non-linear model run.</h2><span id='topic+NlModel-class'></span>

<h3>Description</h3>

<p>deprecated class for a non-linear model run.
</p>

<hr>
<h2 id='no_outflux_warning'>alternative Constructor with pool names 
helper function</h2><span id='topic+no_outflux_warning'></span>

<h3>Description</h3>

<p>alternative Constructor with pool names 
helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no_outflux_warning()
</code></pre>

<hr>
<h2 id='OnepModel'>Implementation of a one pool model</h2><span id='topic+OnepModel'></span>

<h3>Description</h3>

<p>This function creates a model for one pool. It is a wrapper for the more
general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OnepModel(t, k, C0, In, xi = 1, solver = deSolve.lsoda.wrapper, pass = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OnepModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="OnepModel_+3A_k">k</code></td>
<td>
<p>A scalar with the decomposition rate of the pool.</p>
</td></tr>
<tr><td><code id="OnepModel_+3A_c0">C0</code></td>
<td>
<p>A scalar containing the initial amount of carbon in the pool.</p>
</td></tr>
<tr><td><code id="OnepModel_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="OnepModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="OnepModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="OnepModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
k=0.8
C0=100
In = 30


Ex=OnepModel(t,k,C0,In)
Ct=getC(Ex)
Rt=getReleaseFlux(Ex)
Rc=getAccumulatedRelease(Ex)

plot(
t,
Ct,
type="l",
ylab="Carbon stocks (arbitrary units)",
xlab="Time (arbitrary units)",
lwd=2
) 

plot(
t,
Rt,
type="l",
ylab="Carbon released (arbitrary units)",
xlab="Time (arbitrary units)",
lwd=2
) 

plot(
t,
Rc,
type="l",
ylab="Cummulative carbon released (arbitrary units)",
xlab="Time (arbitrary units)",
lwd=2
) 
</code></pre>

<hr>
<h2 id='OnepModel14'>Implementation of a one-pool C14 model</h2><span id='topic+OnepModel14'></span>

<h3>Description</h3>

<p>This function creates a model for one pool. It is a wrapper for the more
general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OnepModel14(
  t,
  k,
  C0,
  F0_Delta14C,
  In,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OnepModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_k">k</code></td>
<td>
<p>A scalar with the decomposition rate of the pool.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_c0">C0</code></td>
<td>
<p>A scalar containing the initial amount of carbon in the pool.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A scalar containing the initial amount of the radiocarbon
fraction in the pool in Delta_14C format.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object consisting of a function describing the
fraction of C_14 in per mille. The first column will be assumed to contain
the times.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_lag">lag</code></td>
<td>
<p>A (positive) scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="OnepModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1901,2009,by=0.5)
LitterInput=700 

Ex=OnepModel14(t=years,k=1/10,C0=500, F0=0,In=LitterInput, inputFc=C14Atm_NH)
C14t=getF14(Ex)

plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
legend(
"topright",
c("Delta 14C Atmosphere", "Delta 14C in SOM"),
lty=c(1,1),
col=c(1,4),
lwd=c(1,1),
bty="n"
)
</code></pre>

<hr>
<h2 id='OutFlux'>Generic constructor for the class with the same name</h2><span id='topic+OutFlux'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutFlux(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFlux_+3A_map">map</code></td>
<td>
<p>a SoilR map</p>
</td></tr>
<tr><td><code id="OutFlux_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='OutFlux_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+OutFlux_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutFlux_by_PoolIndex(func, sourceIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFlux_by_PoolIndex_+3A_func">func</code></td>
<td>
<p>function with output flux</p>
</td></tr>
<tr><td><code id="OutFlux_by_PoolIndex_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>index of the source pool</p>
</td></tr>
</table>

<hr>
<h2 id='OutFlux_by_PoolIndex-class'>S4 class for a single out-flux with source pool index</h2><span id='topic+OutFlux_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>S4 class for a single out-flux with source pool index
</p>

<hr>
<h2 id='OutFlux_by_PoolIndex+2Cfunction+2Cnumeric-method'>constructor from a PoolIndex (integer like) objects and a function with vector argument</h2><span id='topic+OutFlux_by_PoolIndex+2Cfunction+2Cnumeric-method'></span>

<h3>Description</h3>

<p>constructor from a PoolIndex (integer like) objects and a function with vector argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',numeric'
OutFlux_by_PoolIndex(func, sourceIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric-method_+3A_func">func</code></td>
<td>
<p>A function f(X,t) where X is a vector of the state variables.</p>
</td></tr>
<tr><td><code id="OutFlux_by_PoolIndex+2B2Cfunction+2B2Cnumeric-method_+3A_sourceindex">sourceIndex</code></td>
<td>
<p>index of source pool
This form is required internally by the solvers and supported for backward compatibility with earlier versions of SoilR.
Note that the function func given in this form can not be transformed to a different ordering of state variables, since the location of a state variable in the vector argument depends on a specific order and will be 'hardcoded' into your function. 
See <code><a href="#topic+OutFlux_by_PoolName">OutFlux_by_PoolName</a></code> for the new, more powerful interface which allows subsequent reordering of the state variables by using the names of the state variables as formal arguments for <code>func</code>. In this case SoilR can infer (and later adapt) the
vector argument form needed for the solvers.
constructor from an ordered pair of PoolIndex (integer like) objects</p>
</td></tr>
</table>

<hr>
<h2 id='OutFlux_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+OutFlux_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutFlux_by_PoolName(func, sourceName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFlux_by_PoolName_+3A_func">func</code></td>
<td>
<p>function with output flux</p>
</td></tr>
<tr><td><code id="OutFlux_by_PoolName_+3A_sourcename">sourceName</code></td>
<td>
<p>name of the source pool</p>
</td></tr>
</table>

<hr>
<h2 id='OutFlux_by_PoolName-class'>S4 class for a single out-flux with source pool name</h2><span id='topic+OutFlux_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4 class for a single out-flux with source pool name
</p>

<hr>
<h2 id='OutFlux_by_PoolName+2Cfunction+2Ccharacter-method'>constructor from a PoolName (integer like) object and a function</h2><span id='topic+OutFlux_by_PoolName+2Cfunction+2Ccharacter-method'></span>

<h3>Description</h3>

<p>constructor from a PoolName (integer like) object and a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',character'
OutFlux_by_PoolName(func, sourceName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFlux_by_PoolName+2B2Cfunction+2B2Ccharacter-method_+3A_func">func</code></td>
<td>
<p>A function. The names of the formal arguments have to be a subset of the state variable names and the time symbol</p>
</td></tr>
<tr><td><code id="OutFlux_by_PoolName+2B2Cfunction+2B2Ccharacter-method_+3A_sourcename">sourceName</code></td>
<td>
<p>the name of the source pool
This allows subsequent automatic reordering of the state variables.
In the presence of a vector of stave variable names the formulation can 
automatically be transformed to a function of a state VECTOR argument and #' time
constructor from an ordered pair of PoolName (integer like) objects</p>
</td></tr>
</table>

<hr>
<h2 id='OutFluxList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+OutFluxList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFluxList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='OutFluxList_by_PoolIndex-class'>A list of outfluxes</h2><span id='topic+OutFluxList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>A list of outfluxes
</p>

<hr>
<h2 id='OutFluxList_by_PoolIndex+2Clist-method'>constructor from a normal list</h2><span id='topic+OutFluxList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>after checking the elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
OutFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFluxList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>a list</p>
</td></tr>
</table>

<hr>
<h2 id='OutFluxList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+OutFluxList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFluxList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='OutFluxList_by_PoolName-class'>S4 class for a list of out-fluxes indexed by source pool name</h2><span id='topic+OutFluxList_by_PoolName-class'></span>

<h3>Description</h3>

<p>S4 class for a list of out-fluxes indexed by source pool name
</p>

<hr>
<h2 id='OutFluxList_by_PoolName+2Clist-method'>constructor from a normal list</h2><span id='topic+OutFluxList_by_PoolName+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
OutFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OutFluxList_by_PoolName+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+OutFlux_by_PoolName-class">OutFlux_by_PoolName</a> or 
a list where the names of the elements are integer strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+ConstantInFluxList_by_PoolIndex-class">ConstantInFluxList_by_PoolIndex</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='ParallelModel'>models for unconnected pools</h2><span id='topic+ParallelModel'></span>

<h3>Description</h3>

<p>This function creates a (linear) numerical model for n independent
(parallel) pools that can be queried afterwards.  It is used by the
convenient wrapper functions <code><a href="#topic+TwopParallelModel">TwopParallelModel</a></code> and
<code><a href="#topic+ThreepParallelModel">ThreepParallelModel</a></code> but can also be used independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ParallelModel(
  times,
  coeffs_tm,
  startvalues,
  inputrates,
  solverfunc = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ParallelModel_+3A_times">times</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="ParallelModel_+3A_coeffs_tm">coeffs_tm</code></td>
<td>
<p>A TimeMap object consisting of a vector valued function
containing the decay rates for the n pools as function of time and the time
range where this function is valid. The length of the vector is equal to the
number of pools.</p>
</td></tr>
<tr><td><code id="ParallelModel_+3A_startvalues">startvalues</code></td>
<td>
<p>A vector containing the initial amount of carbon for the
n pools. &lt;&lt;The length of this vector is equal to the number of pools and
thus equal to the length of k. This is checked by the function.</p>
</td></tr>
<tr><td><code id="ParallelModel_+3A_inputrates">inputrates</code></td>
<td>
<p>An object consisting of a vector valued function
describing the inputs to the pools as functions of time
<code><a href="#topic+TimeMap.new">TimeMap.new</a></code></p>
</td></tr>
<tr><td><code id="ParallelModel_+3A_solverfunc">solverfunc</code></td>
<td>
<p>The function used to actually solve the ODE system. This
can be <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user provided
function with the same interface.</p>
</td></tr>
<tr><td><code id="ParallelModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
k=TimeMap(
function(times){c(-0.5,-0.2,-0.3)},
t_start,
t_end
)
c0=c(1, 2, 3)
#constant inputrates
inputrates=BoundInFluxes(
function(t){matrix(nrow=3,ncol=1,c(1,1,1))},
t_start,
t_end
) 
mod=ParallelModel(t,k,c0,inputrates)
Y=getC(mod)
lt1=1 ;lt2=2 ;lt3=3 
col1=1; col2=2; col3=3
plot(t,Y[,1],type="l",lty=lt1,col=col1,
ylab="C stocks",xlab="Time") 
lines(t,Y[,2],type="l",lty=lt2,col=col2) 
lines(t,Y[,3],type="l",lty=lt3,col=col3) 
legend(
"topleft",
c("C in pool 1",
"C in 2",
"C in pool 3"
),
lty=c(lt1,lt2,lt3),
col=c(col1,col2,col3)
)
Y=getAccumulatedRelease(mod)
plot(t,Y[,1],type="l",lty=lt1,col=col1,ylab="C release",xlab="Time") 
lines(t,Y[,2],lt2,type="l",lty=lt2,col=col2) 
lines(t,Y[,3],type="l",lty=lt3,col=col3) 
legend("topright",c("R1","R2","R3"),lty=c(lt1,lt2,lt3),col=c(col1,col2,col3))
</code></pre>

<hr>
<h2 id='pathEntropy'>Path Entropy</h2><span id='topic+pathEntropy'></span>

<h3>Description</h3>

<p>Computes the entropy of particles passing through the whole network of
compartments for a model at equilibrium
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathEntropy(A, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathEntropy_+3A_a">A</code></td>
<td>
<p>A constant compartmental square matrix with cycling rates in the
diagonal and transfer rates in the off-diagonal.</p>
</td></tr>
<tr><td><code id="pathEntropy_+3A_u">u</code></td>
<td>
<p>A one-column matrix defining the amount of inputs per compartment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar value with the path entropy
</p>


<h3>References</h3>

<p>Metzler, H. (2020). Compartmental systems as Markov chains : age, 
transit time, and entropy (T. Oertel-Jaeger, I. Pavlyukevich, and C. Sierra, 
Eds.) 
[PhD thesis](https://suche.thulb.uni-jena.de/Record/1726091651)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B6=matrix(c(-1,1,0,0,-1,1,0,0,-1),3,3); u6=matrix(c(1,0,0))
pathEntropy(A=B6, u=u6)
</code></pre>

<hr>
<h2 id='plot+2CMCSim-method'>automatic title</h2><span id='topic+plot+2CMCSim-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MCSim'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CMCSim-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="plot+2B2CMCSim-method_+3A_y">y</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="plot+2B2CMCSim-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CModel_by_PoolNames-method'>Plot the graph of pool connections</h2><span id='topic+plot+2CModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>Plot the graph of pool connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model_by_PoolNames'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CModel_by_PoolNames-method_+3A_x">x</code></td>
<td>
<p>a model</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CModel-method'>Create an overview plot</h2><span id='topic+plot+2CModel-method'></span>

<h3>Description</h3>

<p>The method solves the model and plots the solutions
It is intended to provide a quick overview.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Model'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CModel-method_+3A_x">x</code></td>
<td>
<p>The model (run) the results of which are plotted</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CNlModel-method'>automatic title</h2><span id='topic+plot+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CNlModel-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='plot+2CTimeMap-method'>automatic title</h2><span id='topic+plot+2CTimeMap-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CTimeMap-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="plot+2B2CTimeMap-method_+3A_y">y</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="plot+2B2CTimeMap-method_+3A_...">...</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='plotC14Pool'>Plots the output of <code><a href="#topic+getF14">getF14</a></code> for each pool over time</h2><span id='topic+plotC14Pool'></span>

<h3>Description</h3>

<p>This function produces a plot with the Delta14C in the atmosphere and the
Delta14C of each pool obtained after a call to <code><a href="#topic+getF14">getF14</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotC14Pool(t, mat, inputFc, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotC14Pool_+3A_t">t</code></td>
<td>
<p>A vector containing the time points for plotting.</p>
</td></tr>
<tr><td><code id="plotC14Pool_+3A_mat">mat</code></td>
<td>
<p>A matrix object obtained after a call to <code><a href="#topic+getF14">getF14</a></code></p>
</td></tr>
<tr><td><code id="plotC14Pool_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="plotC14Pool_+3A_col">col</code></td>
<td>
<p>A color palette specifying color lines for each pool (columns of
<code>mat</code>).</p>
</td></tr>
<tr><td><code id="plotC14Pool_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>plot</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotCPool'>Plots the output of <code><a href="#topic+getC">getC</a></code> or <code><a href="#topic+getReleaseFlux">getReleaseFlux</a></code> for
each pool over time</h2><span id='topic+plotCPool'></span>

<h3>Description</h3>

<p>This function produces a plot with the C content or released C for each pool
over time. Needs as input a matrix obtained after a call to
<code><a href="#topic+getC">getC</a></code> or <code><a href="#topic+getReleaseFlux">getReleaseFlux</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCPool(t, mat, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCPool_+3A_t">t</code></td>
<td>
<p>A vector containing the time points for plotting.</p>
</td></tr>
<tr><td><code id="plotCPool_+3A_mat">mat</code></td>
<td>
<p>A matrix object obtained after a call to <code><a href="#topic+getC">getC</a></code> or
<code><a href="#topic+getReleaseFlux">getReleaseFlux</a></code></p>
</td></tr>
<tr><td><code id="plotCPool_+3A_col">col</code></td>
<td>
<p>A color palette specifying color lines for each pool (columns of
<code>mat</code>).</p>
</td></tr>
<tr><td><code id="plotCPool_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>link{plot}</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotPoolGraph'>Generic plotter</h2><span id='topic+plotPoolGraph'></span>

<h3>Description</h3>

<p>Generic plotter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPoolGraph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoolGraph_+3A_x">x</code></td>
<td>
<p>An argument containing sufficient information about the connections between the pools as well as from and to the exterior.</p>
</td></tr>
</table>

<hr>
<h2 id='plotPoolGraph+2CSymbolicModel_by_PoolNames-method'>Plot the graph of pool connections</h2><span id='topic+plotPoolGraph+2CSymbolicModel_by_PoolNames-method'></span>

<h3>Description</h3>

<p>Plot the graph of pool connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SymbolicModel_by_PoolNames'
plotPoolGraph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoolGraph+2B2CSymbolicModel_by_PoolNames-method_+3A_x">x</code></td>
<td>
<p>The modelrun the connection graph of which is plotted</p>
</td></tr>
</table>

<hr>
<h2 id='plotPoolGraphFromTupleLists'>Helper function to draw connectivity graphs</h2><span id='topic+plotPoolGraphFromTupleLists'></span>

<h3>Description</h3>

<p>Helper function to draw connectivity graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPoolGraphFromTupleLists(
  internalConnections,
  inBoundConnections,
  outBoundConnections
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoolGraphFromTupleLists_+3A_internalconnections">internalConnections</code></td>
<td>
<p>A list of tuples(source,dest) where
src and dest are either both integers or both strings(poolnames)</p>
</td></tr>
<tr><td><code id="plotPoolGraphFromTupleLists_+3A_inboundconnections">inBoundConnections</code></td>
<td>
<p>A list of either integers or strings (poolnames)</p>
</td></tr>
<tr><td><code id="plotPoolGraphFromTupleLists_+3A_outboundconnections">outBoundConnections</code></td>
<td>
<p>A list of either integers or strings (poolnames)
The function is used by the <code><a href="#topic+plotPoolGraph">plotPoolGraph</a></code> generic of the 
newer model classes <code><a href="#topic+SymbolicModel_by_PoolNames-class">SymbolicModel_by_PoolNames</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='PoolConnection_by_PoolIndex'>Pool connection by pool index</h2><span id='topic+PoolConnection_by_PoolIndex'></span>

<h3>Description</h3>

<p>Pool connection by pool index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolConnection_by_PoolIndex(source, destination, src_to_dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolConnection_by_PoolIndex_+3A_source">source</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="PoolConnection_by_PoolIndex_+3A_destination">destination</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="PoolConnection_by_PoolIndex_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='PoolConnection_by_PoolIndex-class'>Objects that have a source and a destination described by integer like objects  ( of class PoolIndex)</h2><span id='topic+PoolConnection_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>Examples are internal Fluxes and Fluxrates
Their 'topologic' part and many related sanity checks are implemented here rather than 
in every function that uses fluxes or rates
The methods are also essential for the translation from (internal) 
flux lists
to the respective parts of compartmental matrices and back
</p>

<hr>
<h2 id='PoolConnection_by_PoolIndex+2CANY+2CANY+2Cmissing-method'>constructor from an ordered pair of PoolId objects</h2><span id='topic+PoolConnection_by_PoolIndex+2CANY+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>constructor from an ordered pair of PoolId objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,ANY,missing'
PoolConnection_by_PoolIndex(source, destination)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolConnection_by_PoolIndex+2B2CANY+2B2CANY+2B2Cmissing-method_+3A_source">source</code></td>
<td>
<p>index of source pool</p>
</td></tr>
<tr><td><code id="PoolConnection_by_PoolIndex+2B2CANY+2B2CANY+2B2Cmissing-method_+3A_destination">destination</code></td>
<td>
<p>index of destination pool</p>
</td></tr>
</table>

<hr>
<h2 id='PoolConnection_by_PoolIndex+2Cmissing+2Cmissing+2Ccharacter-method'>constructor from strings of the form '1_to_2'</h2><span id='topic+PoolConnection_by_PoolIndex+2Cmissing+2Cmissing+2Ccharacter-method'></span>

<h3>Description</h3>

<p>constructor from strings of the form '1_to_2'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,character'
PoolConnection_by_PoolIndex(src_to_dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolConnection_by_PoolIndex+2B2Cmissing+2B2Cmissing+2B2Ccharacter-method_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>charcter string describing the source to destination pools</p>
</td></tr>
</table>

<hr>
<h2 id='PoolConnection_by_PoolName'>Pool connection by pool name</h2><span id='topic+PoolConnection_by_PoolName'></span>

<h3>Description</h3>

<p>Pool connection by pool name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolConnection_by_PoolName(source, destination, src_to_dest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolConnection_by_PoolName_+3A_source">source</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="PoolConnection_by_PoolName_+3A_destination">destination</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="PoolConnection_by_PoolName_+3A_src_to_dest">src_to_dest</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='PoolConnection_by_PoolName-class'>Objects that have a source and a destination determined by a string like object of class PoolName</h2><span id='topic+PoolConnection_by_PoolName-class'></span>

<h3>Description</h3>

<p>Examples are internal Fluxes and Fluxrates
Their 'topologic' part and many related sanity checks are implemented here rather than 
in every function that uses fluxes or rates
The methods are also essential for the translation from (internal) 
flux lists
to the respective parts of compartmental matrices and back
</p>

<hr>
<h2 id='PoolConnection_by_PoolName+2CANY+2CANY+2Cmissing-method'>constructor from an ordered pair of PoolName objects</h2><span id='topic+PoolConnection_by_PoolName+2CANY+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>constructor from an ordered pair of PoolName objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY,ANY,missing'
PoolConnection_by_PoolName(source, destination)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolConnection_by_PoolName+2B2CANY+2B2CANY+2B2Cmissing-method_+3A_source">source</code></td>
<td>
<p>name of source pool</p>
</td></tr>
<tr><td><code id="PoolConnection_by_PoolName+2B2CANY+2B2CANY+2B2Cmissing-method_+3A_destination">destination</code></td>
<td>
<p>name of destination pool</p>
</td></tr>
</table>

<hr>
<h2 id='PoolId-class'>common class for pool ids</h2><span id='topic+PoolId-class'></span>

<h3>Description</h3>

<p>examples for ids are index or name
</p>

<hr>
<h2 id='PoolIndex'>Pool index</h2><span id='topic+PoolIndex'></span>

<h3>Description</h3>

<p>Pool index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolIndex(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolIndex_+3A_id">id</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="PoolIndex_+3A_...">...</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='PoolIndex-class'>S4 class for pool indices</h2><span id='topic+PoolIndex-class'></span>

<h3>Description</h3>

<p>used to dispatch pool index specific methods like conversion to names.
</p>

<hr>
<h2 id='PoolIndex+2Ccharacter-method'>construct from number string like '1' or '3'</h2><span id='topic+PoolIndex+2Ccharacter-method'></span>

<h3>Description</h3>

<p>construct from number string like '1' or '3'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
PoolIndex(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolIndex+2B2Ccharacter-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
</table>

<hr>
<h2 id='PoolIndex+2Cnumeric-method'>construct from number</h2><span id='topic+PoolIndex+2Cnumeric-method'></span>

<h3>Description</h3>

<p>construct from number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
PoolIndex(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolIndex+2B2Cnumeric-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
</table>

<hr>
<h2 id='PoolIndex+2CPoolIndex-method'>pass through constructor fron an object of the same class</h2><span id='topic+PoolIndex+2CPoolIndex-method'></span>

<h3>Description</h3>

<p>This is here to be able to call PoolIndex on a PoolIndex object without
having to check before if it is necessary.
the unnecessary poolNames argument will be ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PoolIndex'
PoolIndex(id, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolIndex+2B2CPoolIndex-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
<tr><td><code id="PoolIndex+2B2CPoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='PoolIndex+2CPoolName-method'>convert to number like object</h2><span id='topic+PoolIndex+2CPoolName-method'></span>

<h3>Description</h3>

<p>convert to number like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PoolName'
PoolIndex(id, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolIndex+2B2CPoolName-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
<tr><td><code id="PoolIndex+2B2CPoolName-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='PoolName'>Pool name</h2><span id='topic+PoolName'></span>

<h3>Description</h3>

<p>Pool name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PoolName(id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolName_+3A_id">id</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="PoolName_+3A_...">...</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='PoolName-class'>class for pool-name-strings</h2><span id='topic+PoolName-class'></span>

<h3>Description</h3>

<p>used to control the creation of PoolName objects which have to be valid R identifiers 
and to dispatch pool name specific methods like conversion to pool indices
</p>

<hr>
<h2 id='PoolName+2Ccharacter-method'>construct from string with checks</h2><span id='topic+PoolName+2Ccharacter-method'></span>

<h3>Description</h3>

<p>construct from string with checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
PoolName(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolName+2B2Ccharacter-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
</table>

<hr>
<h2 id='PoolName+2CPoolIndex-method'>convert to string like object</h2><span id='topic+PoolName+2CPoolIndex-method'></span>

<h3>Description</h3>

<p>convert to string like object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PoolIndex'
PoolName(id, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolName+2B2CPoolIndex-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
<tr><td><code id="PoolName+2B2CPoolIndex-method_+3A_poolnames">poolNames</code></td>
<td>
<p>name of pools</p>
</td></tr>
</table>

<hr>
<h2 id='PoolName+2CPoolName-method'>pass through constructor fron an object of the same class</h2><span id='topic+PoolName+2CPoolName-method'></span>

<h3>Description</h3>

<p>This is here to be able to call PoolName on a PoolName object without
having to test before if we have to. 
This makes the calling code easier to read.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PoolName'
PoolName(id, poolNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoolName+2B2CPoolName-method_+3A_id">id</code></td>
<td>
<p>pool id</p>
</td></tr>
<tr><td><code id="PoolName+2B2CPoolName-method_+3A_poolnames">poolNames</code></td>
<td>
<p>names of pools</p>
</td></tr>
</table>

<hr>
<h2 id='predefinedModels'>PREDEFINED MODELS</h2><span id='topic+predefinedModels'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+GaudinskiModel14">GaudinskiModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ICBMModel">ICBMModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+OnepModel">OnepModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+OnepModel14">OnepModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+RothCModel">RothCModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepFeedbackModel">ThreepFeedbackModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepFeedbackModel14">ThreepFeedbackModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepParallelModel">ThreepParallelModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepParallelModel14">ThreepParallelModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepSeriesModel">ThreepSeriesModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepSeriesModel14">ThreepSeriesModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopFeedbackModel">TwopFeedbackModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopFeedbackModel14">TwopFeedbackModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopParallelModel">TwopParallelModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopParallelModel14">TwopParallelModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopMMmodel">TwopMMmodel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+ThreepairMMmodel">ThreepairMMmodel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopSeriesModel">TwopSeriesModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+TwopSeriesModel14">TwopSeriesModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+YassoModel">YassoModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+bacwaveModel">bacwaveModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+Yasso07Model">Yasso07Model</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+SeriesLinearModel">SeriesLinearModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+SeriesLinearModel14">SeriesLinearModel14</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
		<code><a href="#topic+CenturyModel">CenturyModel</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>


<hr>
<h2 id='print+2CNlModel-method'>automatic title</h2><span id='topic+print+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CNlModel-method_+3A_x">x</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='RespirationCoefficients'>helper function to compute respiration coefficients</h2><span id='topic+RespirationCoefficients'></span>

<h3>Description</h3>

<p>This function computes the respiration coefficients as function of time for
all pools according to the given matrix function  A(t)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RespirationCoefficients(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RespirationCoefficients_+3A_a">A</code></td>
<td>
<p>A matrix valued function representing the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector valued function of time containing the respiration
coefficients for all pools.
</p>

<hr>
<h2 id='RothCModel'>Implementation of the RothCModel</h2><span id='topic+RothCModel'></span>

<h3>Description</h3>

<p>This function implements the RothC model of Jenkinson et al. It is a wrapper
for the more general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RothCModel(
  t,
  ks = c(k.DPM = 10, k.RPM = 0.3, k.BIO = 0.66, k.HUM = 0.02, k.IOM = 0),
  C0 = c(0, 0, 0, 0, 2.7),
  In = 1.7,
  FYM = 0,
  DR = 1.44,
  clay = 23.4,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RothCModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 5 containing the values of the decomposition
rates for the different pools</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 5 containing the initial amount of carbon for
the 5 pools.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_in">In</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_fym">FYM</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of Farm Yard
Manure inputs by time.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_dr">DR</code></td>
<td>
<p>A scalar representing the ratio of decomposable plant material to
resistant plant material (DPM/RPM).</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_clay">clay</code></td>
<td>
<p>Percent clay in mineral soil.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="RothCModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Jenkinson, D. S., S. P. S. Andrew, J. M. Lynch, M. J. Goss, and
P. B. Tinker. 1990. The Turnover of Organic Carbon and Nitrogen in Soil.
Philosophical Transactions: Biological Sciences 329:361-368. Sierra, C.A.,
M. Mueller, S.E. Trumbore. 2012. Models of soil organic matter
decomposition: the SoilR package version 1.0. Geoscientific Model
Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t=0:500 
Ex=RothCModel(t)
Ct=getC(Ex)
Rt=getReleaseFlux(Ex)

matplot(t,Ct,type="l",col=1:5, ylim=c(0,25),
ylab=expression(paste("Carbon stores (Mg C ", ha^-1,")")),
xlab="Time (years)", lty=1)
lines(t,rowSums(Ct),lwd=2)
legend("topleft",
c("Pool 1, DPM",
"Pool 2, RPM",
"Pool 3, BIO",
"Pool 4, HUM",
"Pool 5, IOM",
"Total Carbon"),
lty=1,
lwd=c(rep(1,5),2),
col=c(1:5,1),
bty="n"
)
</code></pre>

<hr>
<h2 id='ScalarTimeMap'>Constructor for <code><a href="#topic+ScalarTimeMap-class">ScalarTimeMap-class</a></code></h2><span id='topic+ScalarTimeMap'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+ScalarTimeMap-class">ScalarTimeMap-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScalarTimeMap(
  map,
  starttime,
  endtime,
  times,
  data,
  lag = 0,
  interpolation = splinefun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalarTimeMap_+3A_map">map</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_starttime">starttime</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_endtime">endtime</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_times">times</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_data">data</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_lag">lag</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_interpolation">interpolation</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="ScalarTimeMap_+3A_...">...</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='ScalarTimeMap-class'>S4 class for a scalar time dependent function on a finite time interval</h2><span id='topic+ScalarTimeMap-class'></span>

<h3>Description</h3>

<p>S4 class for a scalar time dependent function on a finite time interval
</p>

<hr>
<h2 id='ScalarTimeMap+2Cdata.frame+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'>constructor for data given as 2 column data.frame</h2><span id='topic+ScalarTimeMap+2Cdata.frame+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>constructor for data given as 2 column data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame,missing,missing,missing,missing'
ScalarTimeMap(map, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalarTimeMap+2B2Cdata.frame+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>In this case a data.frame. Only the first two columns will be
used</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cdata.frame+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>a (scalar) delay</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cdata.frame+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_interpolation">interpolation</code></td>
<td>
<p>the interpolation, usually splinefun or approxfun</p>
</td></tr>
</table>

<hr>
<h2 id='ScalarTimeMap+2Cfunction+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'>manual constructor for just a function</h2><span id='topic+ScalarTimeMap+2Cfunction+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>The interval will be set to [-Inf,Inf]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',missing,missing,missing,missing'
ScalarTimeMap(map, lag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalarTimeMap+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>a time lag</p>
</td></tr>
</table>

<hr>
<h2 id='ScalarTimeMap+2Cfunction+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing-method'>manual constructor for a function and an interval</h2><span id='topic+ScalarTimeMap+2Cfunction+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>manual constructor for a function and an interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',numeric,numeric,missing,missing'
ScalarTimeMap(map, starttime, endtime, lag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalarTimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_starttime">starttime</code></td>
<td>
<p>initial time of simulation</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_endtime">endtime</code></td>
<td>
<p>end time of simulation</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>a time lag</p>
</td></tr>
</table>

<hr>
<h2 id='ScalarTimeMap+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cnumeric-method'>special case for a time map from a constant</h2><span id='topic+ScalarTimeMap+2Cmissing+2Cmissing+2Cmissing+2Cmissing+2Cnumeric-method'></span>

<h3>Description</h3>

<p>special case for a time map from a constant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,missing,missing,numeric'
ScalarTimeMap(starttime = -Inf, endtime = +Inf, data, lag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric-method_+3A_starttime">starttime</code></td>
<td>
<p>initial time of simulation</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric-method_+3A_endtime">endtime</code></td>
<td>
<p>end time of simulation</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric-method_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric-method_+3A_lag">lag</code></td>
<td>
<p>a time lag</p>
</td></tr>
</table>

<hr>
<h2 id='ScalarTimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Cnumeric-method'>constructor for data and times given as vectors</h2><span id='topic+ScalarTimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>constructor for data and times given as vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,missing,numeric,numeric'
ScalarTimeMap(times, data, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_times">times</code></td>
<td>
<p>(the times for the values in data)</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_data">data</code></td>
<td>
<p>the values at times</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_lag">lag</code></td>
<td>
<p>a (scalar) delay</p>
</td></tr>
<tr><td><code id="ScalarTimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_interpolation">interpolation</code></td>
<td>
<p>the interpolation, usually splinefun or approxfun</p>
</td></tr>
</table>

<hr>
<h2 id='SeriesLinearModel'>General m-pool linear model with series structure</h2><span id='topic+SeriesLinearModel'></span>

<h3>Description</h3>

<p>This function creates a model for m number of pools connected in series. It
is a wrapper for the more general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeriesLinearModel(
  t,
  m.pools,
  ki,
  Tij,
  C0,
  In,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeriesLinearModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_m.pools">m.pools</code></td>
<td>
<p>An integer with the total number of pools in the model.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_ki">ki</code></td>
<td>
<p>A vector of length m containing the values of the decomposition
rates for each pool i.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_tij">Tij</code></td>
<td>
<p>A vector of length m-1 with the transfer coefficients from pool j
to pool i. The value of these coefficients must be in the range [0, 1].</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length m containing the initial amount of carbon for
the m pools.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_in">In</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#A five-pool model
t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
ks=c(k1=0.8,k2=0.4,k3=0.2, k4=0.1,k5=0.05)
Ts=c(0.5,0.2,0.2,0.1)
C0=c(C10=100,C20=150, C30=50, C40=50, C50=10)
In = 50
#
Ex1=SeriesLinearModel(t=t,m.pools=5,ki=ks,Tij=Ts,C0=C0,In=In,xi=fT.Q10(15))
Ct=getC(Ex1)
#
matplot(t,Ct,type="l",col=2:6,lty=1,ylim=c(0,sum(C0)))
lines(t,rowSums(Ct),lwd=2)
legend("topright",c("Total C","C in pool 1", "C in pool 2","C in pool 3",
"C in pool 4","C in pool 5"),
lty=1,col=1:6,lwd=c(2,rep(1,5)),bty="n")
</code></pre>

<hr>
<h2 id='SeriesLinearModel14'>General m-pool linear C14 model with series structure</h2><span id='topic+SeriesLinearModel14'></span>

<h3>Description</h3>

<p>This function creates a radiocarbon model for m number of pools connected in
series. It is a wrapper for the more general function
<code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeriesLinearModel14(
  t,
  m.pools,
  ki,
  Tij,
  C0,
  F0_Delta14C,
  In,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SeriesLinearModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_m.pools">m.pools</code></td>
<td>
<p>An integer with the total number of pools in the model.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_ki">ki</code></td>
<td>
<p>A vector of length m containing the values of the decomposition
rates for each pool i.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_tij">Tij</code></td>
<td>
<p>A vector of length m-1 with the transfer coefficients from pool j
to pool i. The value of these coefficients must be in the range [0, 1].</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length m containing the initial amount of carbon for
the m pools.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length m containing the initial amount of the
radiocarbon fraction for the m pools.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_in">In</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_lag">lag</code></td>
<td>
<p>A positive scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="SeriesLinearModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2014. Modeling
radiocarbon dynamics in soils: SoilR version 1.1. Geoscientific Model
Development 7, 1919-1931.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1901,2009,by=0.5)
LitterInput=700 

Ex=SeriesLinearModel14(
t=years,ki=c(k1=1/2.8, k2=1/35, k3=1/100), m.pools=3,
C0=c(200,5000,500), F0_Delta14C=c(0,0,0),
In=LitterInput, Tij=c(0.5, 0.1),inputFc=C14Atm_NH
)
R14m=getF14R(Ex)
C14m=getF14C(Ex)
C14t=getF14(Ex)

par(mfrow=c(2,1))
plot(C14Atm_NH,type="l",xlab="Year",
ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
lines(years, C14t[,2],col=4,lwd=2)
lines(years, C14t[,3],col=4,lwd=3)
legend(
"topright",
c("Delta 14C Atmosphere", "Delta 14C pool 1", "Delta 14C pool 2", "Delta 14C pool 3"),
lty=rep(1,4),col=c(1,4,4,4),lwd=c(1,1,2,3),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years,C14m,col=4)
lines(years,R14m,col=2)
legend("topright",c("Delta 14C Atmosphere","Delta 14C SOM", "Delta 14C Respired"),
lty=c(1,1,1), col=c(1,4,2),bty="n")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='SHCal20'>The SHCal20 southern hemisphere radiocarbon curve for the 0-55,000 yr BP period</h2><span id='topic+SHCal20'></span>

<h3>Description</h3>

<p>Atmospheric radiocarbon calibration curve for the period 0 to 55,000 yr BP for the southern hemisphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SHCal20)
</code></pre>


<h3>Format</h3>

<p>A data frame with 9501 rows and 5 variables.
</p>

<dl>
<dt><code>CAL.BP</code></dt><dd><p>Calibrated age in years Before Present (BP).</p>
</dd>
<dt><code>C14.age</code></dt><dd><p>C14 age in years BP.</p>
</dd>
<dt><code>Sigma.C14.age</code></dt><dd><p>Standard deviation for <code>C14.age</code>.</p>
</dd>
<dt><code>Delta.14C</code></dt><dd><p>Delta.14C value in per mil.</p>
</dd>
<dt><code>Sigma.Delta.14C</code></dt><dd><p>Standard deviation of <code>Delta.14C</code> in per mil.</p>
</dd>
</dl>



<h3>Details</h3>

<p>All details about the derivation of this dataset are provided in Hogg et al. (2020).
</p>


<h3>Author(s)</h3>

<p>Ingrid Chanca <a href="mailto:ichanca@bgc-jena.mpg.de">ichanca@bgc-jena.mpg.de</a>
</p>


<h3>Source</h3>

<p>&lt;https://doi.org/10.1017/RDC.2020.59&gt;
</p>


<h3>References</h3>

<p>Hogg, A., Heaton, T., Hua, Q., Palmer, J., Turney, C., Southon, J., . . . Wacker, L. (2020). 
SHCal20 Southern Hemisphere Calibration, 0–55,000 Years cal BP. Radiocarbon, 62(4), 759-778. 
doi:10.1017/RDC.2020.59
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    plot(SHCal20$CAL.BP, SHCal20$Delta.14C, type="l", 
         xlab="cal BP", ylab="Delta14C (per mil)")

</code></pre>

<hr>
<h2 id='show+2CNlModel-method'>automatic title</h2><span id='topic+show+2CNlModel-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NlModel'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CNlModel-method_+3A_object">object</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='SoilR.F0.new'>deprecated function that used to create an object of class SoilR.F0</h2><span id='topic+SoilR.F0.new'></span>

<h3>Description</h3>

<p>The function internally calls the constructor of the replacement class
<code><a href="#topic+ConstFc-class">ConstFc-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SoilR.F0.new(values = c(0), format = "Delta14C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SoilR.F0.new_+3A_values">values</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="SoilR.F0.new_+3A_format">format</code></td>
<td>
<p>a character string describing the format e.g. &quot;Delta14C&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ConstFc-class">ConstFc-class</a></code> that contains data
and a format description that can later be used to convert the data into
other formats if the conversion is implemented.
</p>

<hr>
<h2 id='state_variable_names'>determine the minimum set of statevariables</h2><span id='topic+state_variable_names'></span>

<h3>Description</h3>

<p>determine the minimum set of statevariables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state_variable_names(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_variable_names_+3A_object">object</code></td>
<td>
<p>The symbolic model description</p>
</td></tr>
</table>

<hr>
<h2 id='StateDependentInFluxVector-class'>Input vector that is a function of the pool contenst and time</h2><span id='topic+StateDependentInFluxVector-class'></span><span id='topic+StateDependentInFluxVector'></span>

<h3>Description</h3>

<p>Input vector that is a function of the pool contenst and time
</p>

<hr>
<h2 id='StateIndependentInFlux_by_PoolIndex-class'>Constructor for the class with the same name</h2><span id='topic+StateIndependentInFlux_by_PoolIndex-class'></span><span id='topic+StateIndependentInFlux_by_PoolIndex'></span>

<h3>Description</h3>

<p>Constructor for the class with the same name
</p>


<h3>Slots</h3>


<dl>
<dt><code>destinationIndex</code></dt><dd></dd>
<dt><code>flux</code></dt><dd></dd>
</dl>

<hr>
<h2 id='StateIndependentInFluxList_by_PoolIndex'>Generic constructor for the class with the same name</h2><span id='topic+StateIndependentInFluxList_by_PoolIndex'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StateIndependentInFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StateIndependentInFluxList_by_PoolIndex_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='StateIndependentInFluxList_by_PoolIndex-class'>Subclass of list that is guaranteed to contain only elements of type
<a href="#topic+StateIndependentInFlux_by_PoolIndex-class">StateIndependentInFlux_by_PoolIndex</a></h2><span id='topic+StateIndependentInFluxList_by_PoolIndex-class'></span>

<h3>Description</h3>

<p>Subclass of list that is guaranteed to contain only elements of type
<a href="#topic+StateIndependentInFlux_by_PoolIndex-class">StateIndependentInFlux_by_PoolIndex</a>
</p>

<hr>
<h2 id='StateIndependentInFluxList_by_PoolIndex+2Clist-method'>constructor from a normal list</h2><span id='topic+StateIndependentInFluxList_by_PoolIndex+2Clist-method'></span>

<h3>Description</h3>

<p>constructor from a normal list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list'
StateIndependentInFluxList_by_PoolIndex(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StateIndependentInFluxList_by_PoolIndex+2B2Clist-method_+3A_object">object</code></td>
<td>
<p>A list. Either a list of elements of type
<a href="#topic+StateIndependentInFlux_by_PoolIndex-class">StateIndependentInFlux_by_PoolIndex</a> or 
a list where the names of the elements are strings of the form
'3' (for an in flux connected to pool 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class
<a href="#topic+StateIndependentInFluxList_by_PoolIndex-class">StateIndependentInFluxList_by_PoolIndex</a> 
</p>
<p>The function checks if the elements are of the desired type or can be
converted to it. It is mainly used internally and usually called 
by the front end functions to convert the user supplied arguments.
</p>

<hr>
<h2 id='StateIndependentInFluxList_by_PoolName'>Generic constructor for the class with the same name</h2><span id='topic+StateIndependentInFluxList_by_PoolName'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StateIndependentInFluxList_by_PoolName(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StateIndependentInFluxList_by_PoolName_+3A_object">object</code></td>
<td>
<p>see methods</p>
</td></tr>
</table>

<hr>
<h2 id='SymbolicModel_by_PoolNames-class'>A symbolic model description based on flux functions</h2><span id='topic+SymbolicModel_by_PoolNames-class'></span><span id='topic+SymbolicModel_by_PoolNames'></span>

<h3>Description</h3>

<p>The set of flux functions along with the timesymbol
is complete description of the structure
</p>

<hr>
<h2 id='systemAge'>System and pool age for constant compartment models</h2><span id='topic+systemAge'></span>

<h3>Description</h3>

<p>Computes the density distribution and mean for the system and pool ages of a
constant compartmental model in matrix representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>systemAge(A, u, a = seq(0, 100), q = c(0.05, 0.5, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="systemAge_+3A_a">A</code></td>
<td>
<p>A constant compartmental square matrix with cycling rates in the
diagonal and transfer rates in the off-diagonal.</p>
</td></tr>
<tr><td><code id="systemAge_+3A_u">u</code></td>
<td>
<p>A one-column matrix defining the amount of inputs per compartment.</p>
</td></tr>
<tr><td><code id="systemAge_+3A_a">a</code></td>
<td>
<p>A sequence of ages to calculate density functions</p>
</td></tr>
<tr><td><code id="systemAge_+3A_q">q</code></td>
<td>
<p>A vector of probabilities to calculate quantiles of the system age
distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 5 objects: mean system age, system age distribution,
quantiles of system age distribution, mean pool-age, and pool-age
distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transitTime">transitTime</a></code>
</p>

<hr>
<h2 id='ThreepairMMmodel'>Implementation of a 6-pool Michaelis-Menten model</h2><span id='topic+ThreepairMMmodel'></span>

<h3>Description</h3>

<p>This function implements a 6-pool Michaelis-Meneten model with pairs of
microbial biomass and substrate pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepairMMmodel(t, ks, kb, Km, r, Af = 1, ADD, ival)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepairMMmodel_+3A_t">t</code></td>
<td>
<p>vector of times to calculate a solution.</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_ks">ks</code></td>
<td>
<p>a vector of length 3 representing SOM decomposition rate (m3 d-1
(gCB)-1)</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_kb">kb</code></td>
<td>
<p>a vector of length 3 representing microbial decay rate (d-1)</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_km">Km</code></td>
<td>
<p>a vector of length 3 representing the Michaelis constant (g m-3)</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_r">r</code></td>
<td>
<p>a vector of length 3 representing the respired carbon fraction
(unitless)</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_af">Af</code></td>
<td>
<p>a scalar representing the Activity factor; i.e. a temperature and
moisture modifier (unitless)</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_add">ADD</code></td>
<td>
<p>a vector of length 3 representing the annual C input to the soil
(g m-3 d-1)</p>
</td></tr>
<tr><td><code id="ThreepairMMmodel_+3A_ival">ival</code></td>
<td>
<p>a vector of length 6 with the initial values of the SOM pools
and the microbial biomass pools (g m-3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class NlModel that can be further queried.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>days=seq(0,1000)
#Run the model with default parameter values
MMmodel=ThreepairMMmodel(t=days,ival=rep(c(100,10),3),ks=c(0.1,0.05,0.01),
kb=c(0.005,0.001,0.0005),Km=c(100,150,200),r=c(0.9,0.9,0.9),
ADD=c(3,1,0.5))
Cpools=getC(MMmodel)
#Time solution
matplot(days,Cpools,type="l",ylab="Concentrations",xlab="Days",lty=rep(1:2,3),
ylim=c(0,max(Cpools)*1.2),col=rep(1:3,each=2),
main="Multi-substrate microbial model")
legend("topright",c("Substrate 1", "Microbial biomass 1", 
"Substrate 2", "Microbial biomass 2",
"Substrate 3", "Microbial biomass 3"),
lty=rep(1:2,3),col=rep(1:3,each=2),
bty="n")
#State-space diagram
plot(Cpools[,2],Cpools[,1],type="l",ylab="Substrate",xlab="Microbial biomass")
lines(Cpools[,4],Cpools[,3],col=2)
lines(Cpools[,6],Cpools[,5],col=3)
legend("topright",c("Substrate-Enzyme pair 1","Substrate-Enzyme pair 2",
"Substrate-Enzyme pair 3"),col=1:3,lty=1,bty="n")
#Microbial biomass over time
plot(days,Cpools[,2],type="l",col=2,xlab="Days",ylab="Microbial biomass")
</code></pre>

<hr>
<h2 id='ThreepFeedbackModel'>Implementation of a three pool model with feedback structure</h2><span id='topic+ThreepFeedbackModel'></span>

<h3>Description</h3>

<p>This function creates a model for three pools connected with feedback. It is
a wrapper for the more general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepFeedbackModel(
  t,
  ks,
  a21,
  a12,
  a32,
  a23,
  C0,
  In,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepFeedbackModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 3 containing the values of the decomposition
rates for pools 1, 2, and 3.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_a12">a12</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
1.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_a32">a32</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
3.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_a23">a23</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 3 to pool
2.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_c0">C0</code></td>
<td>
<p>A vector containing the initial concentrations for the 3 pools.
The length of this vector is 3</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_in">In</code></td>
<td>
<p>A data.frame object specifying the amount of litter inputs by
time.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
ks=c(k1=0.8,k2=0.4,k3=0.2)
C0=c(C10=100,C20=150, C30=50)
In = 60

Temp=rnorm(t,15,1)
TempEffect=data.frame(t,fT.Daycent1(Temp))

Ex1=ThreepFeedbackModel(t=t,ks=ks,a21=0.5,a12=0.1,a32=0.2,a23=0.1,C0=C0,In=In,xi=TempEffect)
Ct=getC(Ex1)
Rt=getReleaseFlux(Ex1)

plot(
t,
rowSums(Ct),
type="l",
ylab="Carbon stocks (arbitrary units)",
xlab="Time (arbitrary units)",
lwd=2,
ylim=c(0,sum(Ct[51,]))
) 
lines(t,Ct[,1],col=2)
lines(t,Ct[,2],col=4)
lines(t,Ct[,3],col=3)
legend(
"topleft",
c("Total C","C in pool 1", "C in pool 2","C in pool 3"),
lty=c(1,1,1,1),
col=c(1,2,4,3),
lwd=c(2,1,1,1),
bty="n"
)

plot(
t,
rowSums(Rt),
type="l",
ylab="Carbon released (arbitrary units)",
xlab="Time (arbitrary units)",
lwd=2,
ylim=c(0,sum(Rt[51,]))
) 
lines(t,Rt[,1],col=2)
lines(t,Rt[,2],col=4)
lines(t,Rt[,3],col=3)
legend(
"topleft",
c("Total C release",
"C release from pool 1",
"C release from pool 2",
"C release from pool 3"),
lty=c(1,1,1,1),
col=c(1,2,4,3),
lwd=c(2,1,1,1),
bty="n"
)

Inr=data.frame(t,Random.inputs=rnorm(length(t),50,10))
plot(Inr,type="l")

Ex2=ThreepFeedbackModel(t=t,ks=ks,a21=0.5,a12=0.1,a32=0.2,a23=0.1,C0=C0,In=Inr)
Ctr=getC(Ex2)
Rtr=getReleaseFlux(Ex2)

plot(
t,
rowSums(Ctr),
type="l",
ylab="Carbon stocks (arbitrary units)",
xlab="Time (arbitrary units)",
lwd=2,
ylim=c(0,sum(Ctr[51,]))
) 
lines(t,Ctr[,1],col=2)
lines(t,Ctr[,2],col=4)
lines(t,Ctr[,3],col=3)
legend("topright",c("Total C","C in pool 1", "C in pool 2","C in pool 3"),
lty=c(1,1,1,1),col=c(1,2,4,3),lwd=c(2,1,1,1),bty="n")

plot(t,rowSums(Rtr),type="l",ylab="Carbon released (arbitrary units)",
xlab="Time (arbitrary units)",lwd=2,ylim=c(0,sum(Rtr[51,]))) 
lines(t,Rtr[,1],col=2)
lines(t,Rtr[,2],col=4)
lines(t,Rtr[,3],col=3)
legend(
"topright",
c("Total C release",
"C release from pool 1",
"C release from pool 2",
"C release from pool 3"
),
lty=c(1,1,1,1),
col=c(1,2,4,3),
lwd=c(2,1,1,1),
bty="n")
</code></pre>

<hr>
<h2 id='ThreepFeedbackModel14'>Implementation of a three-pool C14 model with feedback structure</h2><span id='topic+ThreepFeedbackModel14'></span>

<h3>Description</h3>

<p>This function creates a model for three pools connected with feedback.  It
is a wrapper for the more general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code>
that can handle an arbitrary number of pools with arbitrary connections.
<code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> can also handle input data in different
formats, while this function requires its input as Delta14C. Look at it as
an example how to use the more powerful tool <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code>
or as a shortcut for a standard task!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepFeedbackModel14(
  t,
  ks,
  C0,
  F0_Delta14C,
  In,
  a21,
  a12,
  a32,
  a23,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepFeedbackModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 3 containing the decomposition rates for the 3
pools.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 3 containing the initial amount of carbon for
the 3 pools.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 3 containing the initial fraction of
radiocarbon for the 3 pools in Delta14C format. The format will be assumed
to be Delta14C, so please take care that it is.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_a12">a12</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
1.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_a32">a32</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
3.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_a23">a23</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 3 to pool
2.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_lag">lag</code></td>
<td>
<p>A positive scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ThreepFeedbackModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid. This is sometimes useful when SoilR is used by external packages
for parameter estimation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#years=seq(1901,2009,by=0.5)
years=seq(1904,2009,by=0.5)
LitterInput=100
k1=1/2; k2=1/10; k3=1/50
a21=0.9*k1
a12=0.4*k2
a32=0.4*k2
a23=0.7*k3

Feedback=ThreepFeedbackModel14(
t=years,
ks=c(k1=k1, k2=k2, k3=k3),
C0=c(100,500,1000),
F0_Delta14C=c(0,0,0),
In=LitterInput,
a21=a21,
a12=a12,
a32=a32,
a23=a23,
inputFc=C14Atm_NH
)
F.R14m=getF14R(Feedback)
F.C14m=getF14C(Feedback)
F.C14t=getF14(Feedback)

Series=ThreepSeriesModel14(
t=years,
ks=c(k1=k1, k2=k2, k3=k3),
C0=c(100,500,1000),
F0_Delta14C=c(0,0,0),
In=LitterInput,
a21=a21,
a32=a32,
inputFc=C14Atm_NH
)
S.R14m=getF14R(Series)
S.C14m=getF14C(Series)
S.C14t=getF14(Series)

Parallel=ThreepParallelModel14(
t=years,
ks=c(k1=k1, k2=k2, k3=k3),
C0=c(100,500,1000),
F0_Delta14C=c(0,0,0),
In=LitterInput,
gam1=0.6,
gam2=0.2,
inputFc=C14Atm_NH,
lag=2
)
P.R14m=getF14R(Parallel)
P.C14m=getF14C(Parallel)
P.C14t=getF14(Parallel)

par(mfrow=c(3,2))
plot(
C14Atm_NH,
type="l",
xlab="Year",
ylab=expression(paste(Delta^14,"C ","(per mille)")),
xlim=c(1940,2010)
) 
lines(years, P.C14t[,1], col=4)
lines(years, P.C14t[,2],col=4,lwd=2)
lines(years, P.C14t[,3],col=4,lwd=3)
legend(
"topright",
c("Atmosphere", "Pool 1", "Pool 2", "Pool 3"),
lty=rep(1,4),
col=c(1,4,4,4),
lwd=c(1,1,2,3),
bty="n"
)

plot(C14Atm_NH,type="l",xlab="Year",
ylab=expression(paste(Delta^14,"C ","(per mille)")),xlim=c(1940,2010)) 
lines(years,P.C14m,col=4)
lines(years,P.R14m,col=2)
legend("topright",c("Atmosphere","Bulk SOM", "Respired C"),
lty=c(1,1,1), col=c(1,4,2),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",
ylab=expression(paste(Delta^14,"C ","(per mille)")),xlim=c(1940,2010)) 
lines(years, S.C14t[,1], col=4)
lines(years, S.C14t[,2],col=4,lwd=2)
lines(years, S.C14t[,3],col=4,lwd=3)
legend("topright",c("Atmosphere", "Pool 1", "Pool 2", "Pool 3"),
lty=rep(1,4),col=c(1,4,4,4),lwd=c(1,1,2,3),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",
ylab=expression(paste(Delta^14,"C ","(per mille)")),xlim=c(1940,2010)) 
lines(years,S.C14m,col=4)
lines(years,S.R14m,col=2)
legend("topright",c("Atmosphere","Bulk SOM", "Respired C"),
lty=c(1,1,1), col=c(1,4,2),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",
ylab=expression(paste(Delta^14,"C ","(per mille)")),xlim=c(1940,2010)) 
lines(years, F.C14t[,1], col=4)
lines(years, F.C14t[,2],col=4,lwd=2)
lines(years, F.C14t[,3],col=4,lwd=3)
legend("topright",c("Atmosphere", "Pool 1", "Pool 2", "Pool 3"),
lty=rep(1,4),col=c(1,4,4,4),lwd=c(1,1,2,3),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",
ylab=expression(paste(Delta^14,"C ","(per mille)")),xlim=c(1940,2010)) 
lines(years,F.C14m,col=4)
lines(years,F.R14m,col=2)
legend("topright",c("Atmosphere","Bulk SOM", "Respired C"),
lty=c(1,1,1), col=c(1,4,2),bty="n")


par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='ThreepParallelModel'>Implementation of a three pool model with parallel structure</h2><span id='topic+ThreepParallelModel'></span>

<h3>Description</h3>

<p>The function creates a model for three independent (parallel) pools. It is a
wrapper for the more general function <code><a href="#topic+ParallelModel">ParallelModel</a></code> that can
handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepParallelModel(
  t,
  ks,
  C0,
  In,
  gam1,
  gam2,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepParallelModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 3 containing the decomposition rates for the 3
pools.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 3 containing the initial amount of carbon for
the 3 pools.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_gam1">gam1</code></td>
<td>
<p>A scalar representing the partitioning coefficient, i.e. the
proportion from the total amount of inputs that goes to pool 1.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_gam2">gam2</code></td>
<td>
<p>A scalar representing the partitioning coefficient, i.e. the
proportion from the total amount of inputs that goes to pool 2.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel_+3A_pass">pass</code></td>
<td>
<p>Logical that forces the Model to be created even if the chect
suggest problems.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 

Ex=ThreepParallelModel(t,ks=c(k1=0.5,k2=0.2,k3=0.1),
C0=c(c10=100, c20=150,c30=50),In=20,gam1=0.7,gam2=0.1,xi=0.5)
Ct=getC(Ex)

plot(t,rowSums(Ct),type="l",lwd=2,
ylab="Carbon stocks (arbitrary units)",xlab="Time",ylim=c(0,sum(Ct[1,]))) 
lines(t,Ct[,1],col=2)
lines(t,Ct[,2],col=4)
lines(t,Ct[,3],col=3)
legend("topright",c("Total C","C in pool 1", "C in pool 2","C in pool 3"),
lty=c(1,1,1,1),col=c(1,2,4,3),lwd=c(2,1,1,1),bty="n")

Rt=getReleaseFlux(Ex)
plot(t,rowSums(Rt),type="l",ylab="Carbon released (arbitrary units)",
xlab="Time",lwd=2,ylim=c(0,sum(Rt[1,]))) 
lines(t,Rt[,1],col=2)
lines(t,Rt[,2],col=4)
lines(t,Rt[,3],col=3)
legend("topright",c("Total C release","C release from pool 1",
"C release from pool 2","C release from pool 3"),
lty=c(1,1,1,1),col=c(1,2,4,3),lwd=c(2,1,1,1),bty="n")
</code></pre>

<hr>
<h2 id='ThreepParallelModel14'>Implementation of a three-pool C14 model with parallel structure</h2><span id='topic+ThreepParallelModel14'></span>

<h3>Description</h3>

<p>This function creates a model for two independent (parallel) pools.  It is a
wrapper for the more general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> that can
handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepParallelModel14(
  t,
  ks,
  C0,
  F0_Delta14C,
  In,
  gam1,
  gam2,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepParallelModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 3 containing the decomposition rates for the 3
pools.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 3 containing the initial amount of carbon for
the 3 pools.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 3 containing the initial amount of the
radiocarbon fraction for the 3 pools in Delta14C values in per mil.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_gam1">gam1</code></td>
<td>
<p>A scalar representing the partitioning coefficient, i.e. the
proportion from the total amount of inputs that goes to pool 1.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_gam2">gam2</code></td>
<td>
<p>A scalar representing the partitioning coefficient, i.e. the
proportion from the total amount of inputs that goes to pool 2.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_lag">lag</code></td>
<td>
<p>A positive scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ThreepParallelModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1903,2009,by=0.5) # note that we 
LitterInput=700 

Ex=ThreepParallelModel14(
t=years,
ks=c(k1=1/2.8, k2=1/35, k3=1/100),
C0=c(200,5000,500),
F0_Delta14C=c(0,0,0),
In=LitterInput,
gam1=0.7,
gam2=0.1,
inputFc=C14Atm_NH,
lag=2
)
R14m=getF14R(Ex)
C14m=getF14C(Ex)
C14t=getF14(Ex)

par(mfrow=c(2,1))
plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
lines(years, C14t[,2],col=4,lwd=2)
lines(years, C14t[,3],col=4,lwd=3)
legend(
"topright",
c(
"Delta 14C Atmosphere", 
"Delta 14C pool 1",
"Delta 14C pool 2", 
"Delta 14C pool 3"
),
lty=rep(1,4),
col=c(1,4,4,4),
lwd=c(1,1,2,3),
bty="n"
)

plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years,C14m,col=4)
lines(years,R14m,col=2)
legend("topright",c("Delta 14C Atmosphere","Delta 14C SOM", "Delta 14C Respired"),
lty=c(1,1,1), col=c(1,4,2),bty="n")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='ThreepSeriesModel'>Implementation of a three pool model with series structure</h2><span id='topic+ThreepSeriesModel'></span>

<h3>Description</h3>

<p>This function creates a model for three pools connected in series. It is a
wrapper for the more general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepSeriesModel(
  t,
  ks,
  a21,
  a32,
  C0,
  In,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepSeriesModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 3 containing the values of the decomposition
rates for pools 1, 2, and 3.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_a32">a32</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
3.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 3 containing the initial amount of carbon for
the 3 pools.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_in">In</code></td>
<td>
<p>A scalar or data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
ks=c(k1=0.8,k2=0.4,k3=0.2)
C0=c(C10=100,C20=150, C30=50)
In = 50

Ex1=ThreepSeriesModel(t=t,ks=ks,a21=0.5,a32=0.2,C0=C0,In=In,xi=fT.Q10(15))
Ct=getC(Ex1)
Rt=getReleaseFlux(Ex1)

plot(t,rowSums(Ct),type="l",ylab="Carbon stocks (arbitrary units)",
xlab="Time (arbitrary units)",lwd=2,ylim=c(0,sum(Ct[1,]))) 
lines(t,Ct[,1],col=2)
lines(t,Ct[,2],col=4)
lines(t,Ct[,3],col=3)
legend("topright",c("Total C","C in pool 1", "C in pool 2","C in pool 3"),
lty=c(1,1,1,1),col=c(1,2,4,3),lwd=c(2,1,1,1),bty="n")
</code></pre>

<hr>
<h2 id='ThreepSeriesModel14'>Implementation of a three-pool C14 model with series structure</h2><span id='topic+ThreepSeriesModel14'></span>

<h3>Description</h3>

<p>This function creates a model for three pools connected in series.  It is a
wrapper for the more general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> that can
handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreepSeriesModel14(
  t,
  ks,
  C0,
  F0_Delta14C,
  In,
  a21,
  a32,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreepSeriesModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 3 containing the decomposition rates for the 3
pools.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 3 containing the initial amount of carbon for
the 3 pools.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 3 containing the initial amount of the
radiocarbon fraction for the 3 pools.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_a32">a32</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
3 as Delta14C values in per mil.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_lag">lag</code></td>
<td>
<p>A positive scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="ThreepSeriesModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1901,2009,by=0.5)
LitterInput=700 

Ex=ThreepSeriesModel14(
t=years,ks=c(k1=1/2.8, k2=1/35, k3=1/100),
C0=c(200,5000,500), F0_Delta14C=c(0,0,0),
In=LitterInput, a21=0.1, a32=0.01,inputFc=C14Atm_NH
)
R14m=getF14R(Ex)
C14m=getF14C(Ex)
C14t=getF14(Ex)

par(mfrow=c(2,1))
plot(C14Atm_NH,type="l",xlab="Year",
ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
lines(years, C14t[,2],col=4,lwd=2)
lines(years, C14t[,3],col=4,lwd=3)
legend(
"topright",
c("Delta 14C Atmosphere", "Delta 14C pool 1", "Delta 14C pool 2", "Delta 14C pool 3"),
lty=rep(1,4),col=c(1,4,4,4),lwd=c(1,1,2,3),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years,C14m,col=4)
lines(years,R14m,col=2)
legend("topright",c("Delta 14C Atmosphere","Delta 14C SOM", "Delta 14C Respired"),
lty=c(1,1,1), col=c(1,4,2),bty="n")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='TimeMap'>Constructor for <code><a href="#topic+TimeMap-class">TimeMap-class</a></code></h2><span id='topic+TimeMap'></span>

<h3>Description</h3>

<p>Constructor for <code><a href="#topic+TimeMap-class">TimeMap-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TimeMap(
  map,
  starttime,
  endtime,
  times,
  data,
  lag = 0,
  interpolation = splinefun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap_+3A_map">map</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_starttime">starttime</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_endtime">endtime</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_times">times</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_data">data</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_lag">lag</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_interpolation">interpolation</code></td>
<td>
<p>see method arguments</p>
</td></tr>
<tr><td><code id="TimeMap_+3A_...">...</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap-class'>S4 class for a time dependent function</h2><span id='topic+TimeMap-class'></span>

<h3>Description</h3>

<p>The class represents functions which are defined on a (possibly infinite) 
interval from [starttime,endtime]
Instances are usually created internally from data frames or lists provided by the user in the high level interfaces.
</p>


<h3>Details</h3>

<p>The class is necessary to be able to detect unwanted extrapolation of 
time line data which might otherwise occur for some of the following 
reasons:
SoilR allows to specify measured data for many of its arguments
and computes the interpolating functions automatically.
The functions returned by the standard R interpolation mechanisms
like <code>splinefun</code> or <code>approxfun</code> do not provide a safeguard 
against accidental extrapolation.  
Internally SoilR converts nearly all data to time dependent functions 
e.g. to be used in ode solvers. So the information of the domain of the
function has to be kept.
</p>

<hr>
<h2 id='TimeMap+2Cdata.frame+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'>automatic title</h2><span id='topic+TimeMap+2Cdata.frame+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'data.frame,missing,missing,missing,missing'
TimeMap(map, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cdata.frame+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cdata.frame+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cdata.frame+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_interpolation">interpolation</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Cfunction+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'>manual constructor for just a function</h2><span id='topic+TimeMap+2Cfunction+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>The interval will be set to [-Inf,Inf]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',missing,missing,missing,missing'
TimeMap(map, lag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>a time lag</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Cfunction+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing-method'>manual constructor for a function and an interval</h2><span id='topic+TimeMap+2Cfunction+2Cnumeric+2Cnumeric+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>manual constructor for a function and an interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',numeric,numeric,missing,missing'
TimeMap(map, starttime, endtime, lag = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_starttime">starttime</code></td>
<td>
<p>start time of simulation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_endtime">endtime</code></td>
<td>
<p>end time of simulation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cfunction+2B2Cnumeric+2B2Cnumeric+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>a time lag</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Clist+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'>automatic title</h2><span id='topic+TimeMap+2Clist+2Cmissing+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'list,missing,missing,missing,missing'
TimeMap(map, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Clist+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_map">map</code></td>
<td>
<p>A nested list of the form list(times=l1,data=l2)
where l1 is a vector or list of the time values
and l2 is a list of numbers, vectors, matrices or arrays.</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Clist+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_lag">lag</code></td>
<td>
<p>Time delay for the created function of time</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Clist+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_interpolation">interpolation</code></td>
<td>
<p>The function used to compute the interpolation e.g splinefun
</p>
<p>Interprets the received list as value table of a time dependent function</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Carray-method'>automatic title</h2><span id='topic+TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Carray-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,missing,numeric,array'
TimeMap(times, data, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Carray-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Carray-method_+3A_data">data</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Carray-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Carray-method_+3A_interpolation">interpolation</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Clist-method'>automatic title</h2><span id='topic+TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Clist-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,missing,numeric,list'
TimeMap(times, data, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Clist-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Clist-method_+3A_data">data</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Clist-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Clist-method_+3A_interpolation">interpolation</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Cmatrix-method'>automatic title</h2><span id='topic+TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Cmatrix-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,missing,numeric,matrix'
TimeMap(times, data, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cmatrix-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cmatrix-method_+3A_data">data</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cmatrix-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cmatrix-method_+3A_interpolation">interpolation</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Cnumeric-method'>automatic title</h2><span id='topic+TimeMap+2Cmissing+2Cmissing+2Cmissing+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,missing,missing,numeric,numeric'
TimeMap(times, data, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_times">times</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_data">data</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_lag">lag</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
<tr><td><code id="TimeMap+2B2Cmissing+2B2Cmissing+2B2Cmissing+2B2Cnumeric+2B2Cnumeric-method_+3A_interpolation">interpolation</code></td>
<td>
<p>no manual documentation
</p>
<p>Interpolates the data as function of times and remembers the limits
of the time domain.</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap+2CTimeMap+2CANY+2CANY+2CANY+2CANY-method'>automatic title</h2><span id='topic+TimeMap+2CTimeMap+2CANY+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TimeMap,ANY,ANY,ANY,ANY'
TimeMap(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap+2B2CTimeMap+2B2CANY+2B2CANY+2B2CANY+2B2CANY-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='TimeMap.from.Dataframe'>TimeMap.from.Dataframe</h2><span id='topic+TimeMap.from.Dataframe'></span>

<h3>Description</h3>

<p>This function is a deprecated constructor of the class TimeMap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TimeMap.from.Dataframe(dframe, lag = 0, interpolation = splinefun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap.from.Dataframe_+3A_dframe">dframe</code></td>
<td>
<p>A data frame containing exactly two columns: the first one is
interpreted as time</p>
</td></tr>
<tr><td><code id="TimeMap.from.Dataframe_+3A_lag">lag</code></td>
<td>
<p>a scalar describing the time lag. Positive Values shift the
argument of the interpolation function forward in time. (retard its effect)</p>
</td></tr>
<tr><td><code id="TimeMap.from.Dataframe_+3A_interpolation">interpolation</code></td>
<td>
<p>A function that returns a function the default is
splinefun. Other possible values are the linear interpolation approxfun or
any self made function with the same interface.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class TimeMap that contains the interpolation function
and the limits of the time range where the function is valid. Note that the
limits change according to the time lag this serves as a saveguard for Model
which thus can check that all involved functions of time are actually
defined for the times of interest
</p>

<hr>
<h2 id='TimeMap.new'>deprecated constructor of the class TimeMap.</h2><span id='topic+TimeMap.new'></span>

<h3>Description</h3>

<p>deprecated functions #################### use the generic TimeMap(...)
instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TimeMap.new(t_start, t_end, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeMap.new_+3A_t_start">t_start</code></td>
<td>
<p>A number marking the begin of the time domain where the
function is valid</p>
</td></tr>
<tr><td><code id="TimeMap.new_+3A_t_end">t_end</code></td>
<td>
<p>A number the end of the time domain where the function is valid</p>
</td></tr>
<tr><td><code id="TimeMap.new_+3A_f">f</code></td>
<td>
<p>The time dependent function definition (a function in R's sense)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class TimeMap that can be used to describe models.
</p>

<hr>
<h2 id='TimeRangeIntersection'>The time interval where both functions are defined</h2><span id='topic+TimeRangeIntersection'></span>

<h3>Description</h3>

<p>The time interval where both functions are defined
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TimeRangeIntersection(obj1, obj2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TimeRangeIntersection_+3A_obj1">obj1</code></td>
<td>
<p>An object on which getTimeRange can be called</p>
</td></tr>
<tr><td><code id="TimeRangeIntersection_+3A_obj2">obj2</code></td>
<td>
<p>An object on which getTimeRange can be called</p>
</td></tr>
</table>

<hr>
<h2 id='transitTime'>Transit times for compartment models</h2><span id='topic+transitTime'></span>

<h3>Description</h3>

<p>Computes the density distribution and mean for the transit time of a
constant compartmental model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitTime(A, u, a = seq(0, 100), q = c(0.05, 0.5, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitTime_+3A_a">A</code></td>
<td>
<p>A constant compartmental square matrix with cycling rates in the
diagonal and transfer rates in the off-diagonal.</p>
</td></tr>
<tr><td><code id="transitTime_+3A_u">u</code></td>
<td>
<p>A one-column matrix defining the amount of inputs per compartment.</p>
</td></tr>
<tr><td><code id="transitTime_+3A_a">a</code></td>
<td>
<p>A sequence of ages to calculate density functions</p>
</td></tr>
<tr><td><code id="transitTime_+3A_q">q</code></td>
<td>
<p>Vector of probabilities to calculate quantiles of the transit time
distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 objects: mean transit time, transit time density
distribution, and quantiles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+systemAge">systemAge</a></code>
</p>

<hr>
<h2 id='TransportDecompositionOperator-class'>automatic title</h2><span id='topic+TransportDecompositionOperator-class'></span>

<h3>Description</h3>

<p>automatic title
</p>

<hr>
<h2 id='turnoverFit'>Estimation of the turnover time from a radiocarbon sample.</h2><span id='topic+turnoverFit'></span>

<h3>Description</h3>

<p>This function finds two possible values of turnover time from 
radiocarbon sample assuming a one pool model with carbon at equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnoverFit(obsC14, obsyr, yr0, Fatm, plot = TRUE, by = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="turnoverFit_+3A_obsc14">obsC14</code></td>
<td>
<p>a scalar with the observed radiocarbon value in Delta14C</p>
</td></tr>
<tr><td><code id="turnoverFit_+3A_obsyr">obsyr</code></td>
<td>
<p>a scalar with the year in which the sample was taken.</p>
</td></tr>
<tr><td><code id="turnoverFit_+3A_yr0">yr0</code></td>
<td>
<p>The year at which simulations will start.</p>
</td></tr>
<tr><td><code id="turnoverFit_+3A_fatm">Fatm</code></td>
<td>
<p>an atmospheric radiocarbon curve as data.frame. First column 
must be time.</p>
</td></tr>
<tr><td><code id="turnoverFit_+3A_plot">plot</code></td>
<td>
<p>logical. Should the function produce a plot?</p>
</td></tr>
<tr><td><code id="turnoverFit_+3A_by">by</code></td>
<td>
<p>numeric. The increment of the sequence of years used in the
simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm takes an observed radiocarbon value and 
runs <code><a href="#topic+OnepModel14">OnepModel14</a></code>, calculates the squared difference
between predictions and observations, and uses <code><a href="stats.html#topic+optimize">optimize</a></code> to
find the minimum difference.
</p>


<h3>Value</h3>

<p>A numeric vector with two values of the turnover time that minimize the
difference between the prediction of a one pool model and the observed
radiocarbon value.
</p>

<hr>
<h2 id='TwopFeedbackModel'>Implementation of a two pool model with feedback structure</h2><span id='topic+TwopFeedbackModel'></span>

<h3>Description</h3>

<p>This function creates a model for two pools connected with feedback. It is a
wrapper for the more general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopFeedbackModel(
  t,
  ks,
  a21,
  a12,
  C0,
  In,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopFeedbackModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 with the values of the decomposition rate for
pools 1 and 2.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_a12">a12</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
1.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 2 containing the initial amount of carbon for
the 2 pools.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_in">In</code></td>
<td>
<p>A data.frame object specifying the amount of litter inputs by
time.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This example show the difference between the three types of two-pool models  
times=seq(0,20,by=0.1)
ks=c(k1=0.8,k2=0.00605)
C0=c(C10=5,C20=5)

Temp=rnorm(times,15,2)
WC=runif(times,10,20)
TempEffect=data.frame(times,fT=fT.Daycent1(Temp))
MoistEffect=data.frame(times, fW=fW.Daycent2(WC)[2])

Inmean=1
InRand=data.frame(times,Random.inputs=rnorm(length(times),Inmean,0.2))
InSin=data.frame(times,Inmean+0.5*sin(times*pi*2))

Parallel=TwopParallelModel(t=times,ks=ks,C0=C0,In=Inmean,gam=0.9,
xi=(fT.Daycent1(15)*fW.Demeter(15)))
Series=TwopSeriesModel(t=times,ks=ks,a21=0.2*ks[1],C0=C0,In=InSin,
xi=(fT.Daycent1(15)*fW.Demeter(15)))
Feedback=TwopFeedbackModel(t=times,ks=ks,a21=0.2*ks[1],a12=0.5*ks[2],C0=C0,
In=InRand,xi=MoistEffect)

CtP=getC(Parallel)
CtS=getC(Series)
CtF=getC(Feedback)

RtP=getReleaseFlux(Parallel)
RtS=getReleaseFlux(Series)
RtF=getReleaseFlux(Feedback)

par(mfrow=c(2,1),mar=c(4,4,1,1))
plot(times,rowSums(CtP),type="l",ylim=c(0,20),ylab="Carbon stocks (arbitrary units)",xlab=" ")
lines(times,rowSums(CtS),col=2)
lines(times,rowSums(CtF),col=3)
legend("topleft",c("Two-pool Parallel","Two-pool Series","Two-pool Feedback"),
lty=c(1,1,1),col=c(1,2,3),bty="n")

plot(times,rowSums(RtP),type="l",ylim=c(0,3),ylab="Carbon release (arbitrary units)", xlab="Time")
lines(times,rowSums(RtS),col=2)
lines(times,rowSums(RtF),col=3)
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='TwopFeedbackModel14'>Implementation of a two-pool C14 model with feedback structure</h2><span id='topic+TwopFeedbackModel14'></span>

<h3>Description</h3>

<p>This function creates a model for two pools connected with feedback.  It is
a wrapper for the more general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> that
can handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopFeedbackModel14(
  t,
  ks,
  C0,
  F0_Delta14C,
  In,
  a21,
  a12,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopFeedbackModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 containing the decomposition rates for the 2
pools.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 2 containing the initial amount of carbon for
the 2 pools.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 2 containing the initial amount of the
radiocarbon fraction for the 2 pools as Delta14C values in per mil.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_a12">a12</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 2 to pool
1.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_lag">lag</code></td>
<td>
<p>A positive integer representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="TwopFeedbackModel14_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it is invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1901,2009,by=0.5)
LitterInput=700 

Ex=TwopFeedbackModel14(t=years,ks=c(k1=1/2.8, k2=1/35),C0=c(200,5000), 
F0_Delta14C=c(0,0),In=LitterInput, a21=0.1,a12=0.01,inputFc=C14Atm_NH)
R14m=getF14R(Ex)
C14m=getF14C(Ex)
C14t=getF14(Ex)

par(mfrow=c(2,1))
plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
lines(years, C14t[,2],col=4,lwd=2)
legend("topright",c("Delta 14C Atmosphere", "Delta 14C pool 1", "Delta 14C pool 2"),
lty=c(1,1,1),col=c(1,4,4),lwd=c(1,1,2),bty="n")

plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years,C14m,col=4)
lines(years,R14m,col=2)
legend("topright",c("Delta 14C Atmosphere","Delta 14C SOM", "Delta 14C Respired"),
lty=c(1,1,1), col=c(1,4,2),bty="n")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='TwopMMmodel'>Implementation of a two-pool Michaelis-Menten model</h2><span id='topic+TwopMMmodel'></span>

<h3>Description</h3>

<p>This function implements a two-pool Michaelis-Meneten model with a microbial
biomass and a substrate pool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopMMmodel(
  t,
  ks = 1.8e-05,
  kb = 0.007,
  Km = 900,
  r = 0.6,
  Af = 1,
  ADD = 3.2,
  ival
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopMMmodel_+3A_t">t</code></td>
<td>
<p>vector of times (in days) to calculate a solution.</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_ks">ks</code></td>
<td>
<p>a scalar representing SOM decomposition rate (m3 d-1 (gCB)-1)</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_kb">kb</code></td>
<td>
<p>a scalar representing microbial decay rate (d-1)</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_km">Km</code></td>
<td>
<p>a scalar representing the Michaelis constant (g m-3)</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_r">r</code></td>
<td>
<p>a scalar representing the respired carbon fraction (unitless)</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_af">Af</code></td>
<td>
<p>a scalar representing the Activity factor; i.e. a temperature and
moisture modifier (unitless)</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_add">ADD</code></td>
<td>
<p>a scalar representing the annual C input to the soil (g m-3 d-1)</p>
</td></tr>
<tr><td><code id="TwopMMmodel_+3A_ival">ival</code></td>
<td>
<p>a vector of length 2 with the initial values of the SOM pool and
the microbial biomass pool (g m-3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is similar to the model described in Manzoni and
Porporato (2007).
</p>


<h3>Value</h3>

<p>Microbial biomass over time
</p>


<h3>References</h3>

<p>Manzoni, S, A. Porporato (2007). A theoretical analysis of
nonlinearities and feedbacks in soil carbon and nitrogen cycles. Soil
Biology and Biochemistry 39: 1542-1556.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>days=seq(0,1000,0.5)
MMmodel=TwopMMmodel(t=days,ival=c(100,10))
Cpools=getC(MMmodel)
matplot(days,Cpools,type="l",ylab="Concentrations",xlab="Days",lty=1,ylim=c(0,max(Cpools)*1.2))
legend("topleft",c("SOM-C", "Microbial biomass"),lty=1,col=c(1,2),bty="n")
ks=0.000018
kb=0.007
r=0.6
ADD=3.2
#Analytical solution of fixed points
#Cs_=kb/((1-r)*ks) wrong look at the sympy test print twopMModel.pdf
Km=900
Af=1
Cs=kb*Km/(Af*ks*(1-r)-kb)
abline(h=Cs,lty=2)
Cb=(ADD*(1-r))/(r*kb)
abline(h=Cb,lty=2,col=2)
#State-space diagram
plot(Cpools[,2],Cpools[,1],type="l",ylab="SOM-C",xlab="Microbial biomass")
plot(days,Cpools[,2],type="l",col=2,xlab="Days",ylab="Microbial biomass")

#The default parameterization exhaust the microbial biomass.
#A different behavior is obtained by increasing ks and decreasing kb
MMmodel=TwopMMmodel(t=days,ival=c(972,304) ,Af=3,kb=0.0000001)
Cpools=getC(MMmodel)

matplot(days,Cpools,type="l",ylab="Concentrations",xlab="Days",lty=1,ylim=c(0,max(Cpools)*1.2))
legend("topleft",c("SOM-C", "Microbial biomass"),lty=1,col=c(1,2),bty="n")

plot(Cpools[,2],Cpools[,1],type="l",ylab="SOM-C",xlab="Microbial biomass")

plot(days,Cpools[,2],type="l",col=2,xlab="Days",ylab="Microbial biomass")
</code></pre>

<hr>
<h2 id='TwopParallelModel'>Implementation of a linear two pool model with parallel structure</h2><span id='topic+TwopParallelModel'></span>

<h3>Description</h3>

<p>This function creates a model for two independent (parallel) pools.  It is a
wrapper for the more general function <code><a href="#topic+ParallelModel">ParallelModel</a></code> that can
handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopParallelModel(
  t,
  ks,
  C0,
  In,
  gam,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopParallelModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 containing the decomposition rates for the 2
pools.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 2 containing the initial amount of carbon for
the 2 pools.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_gam">gam</code></td>
<td>
<p>A scalar representing the partitioning coefficient, i.e. the
proportion from the total amount of inputs that goes to pool 1.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="TwopParallelModel_+3A_pass">pass</code></td>
<td>
<p>Forces the constructor to create the model even if it is invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
Ex=TwopParallelModel(t,ks=c(k1=0.5,k2=0.2),C0=c(c10=100, c20=150),In=10,gam=0.7,xi=0.5)
Ct=getC(Ex)
plot(t,rowSums(Ct),type="l",lwd=2,
ylab="Carbon stocks (arbitrary units)",xlab="Time",ylim=c(0,sum(Ct[1,]))) 
lines(t,Ct[,1],col=2)
lines(t,Ct[,2],col=4)
legend("topright",c("Total C","C in pool 1", "C in pool 2"),
lty=c(1,1,1),col=c(1,2,4),lwd=c(2,1,1),bty="n")

Rt=getReleaseFlux(Ex)
plot(t,rowSums(Rt),type="l",ylab="Carbon released (arbitrary units)",
xlab="Time",lwd=2,ylim=c(0,sum(Rt[1,]))) 
lines(t,Rt[,1],col=2)
lines(t,Rt[,2],col=4) 
legend("topleft",c("Total C release","C release from pool 1", "C release from pool 2"),
lty=c(1,1,1),col=c(1,2,4),lwd=c(2,1,1),bty="n")
</code></pre>

<hr>
<h2 id='TwopParallelModel14'>Implementation of a two-pool C14 model with parallel structure</h2><span id='topic+TwopParallelModel14'></span>

<h3>Description</h3>

<p>This function creates a model for two independent (parallel) pools.  It is a
wrapper for the more general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> that can
handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopParallelModel14(
  t,
  ks,
  C0,
  F0_Delta14C,
  In,
  gam,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopParallelModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 containing the decomposition rates for the 2
pools.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 2 containing the initial amount of carbon for
the 2 pools.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 2 containing the initial amount of the
fraction of radiocarbon for the 2 pools as Delta14C values in per mil.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_gam">gam</code></td>
<td>
<p>A scalar representing the partitioning coefficient, i.e. the
proportion from the total amount of inputs that goes to pool 1.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_lag">lag</code></td>
<td>
<p>A positive scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="TwopParallelModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lag &lt;- 2
years=seq(1901+lag,2009,by=0.5)
LitterInput=700 
Ex=TwopParallelModel14(t=years,ks=c(k1=1/2.8, k2=1/35),C0=c(200,5000), 
F0_Delta14C=c(0,0),In=LitterInput, gam=0.7,inputFc=C14Atm_NH,lag=lag)
R14m=getF14R(Ex)
C14m=getF14C(Ex)
C14t=getF14(Ex)
par(mfrow=c(2,1))
plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
lines(years, C14t[,2],col=4,lwd=2)
legend("topright",c("Delta 14C Atmosphere", "Delta 14C pool 1", "Delta 14C pool 2"),
lty=c(1,1,1),col=c(1,4,4),lwd=c(1,1,2),bty="n")
plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years,C14m,col=4)
lines(years,R14m,col=2)
legend("topright",c("Delta 14C Atmosphere","Delta 14C SOM", "Delta 14C Respired"),
lty=c(1,1,1), col=c(1,4,2),bty="n")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='TwopSeriesModel'>Implementation of a two pool model with series structure</h2><span id='topic+TwopSeriesModel'></span>

<h3>Description</h3>

<p>This function creates a model for two pools connected in series. It is a
wrapper for the more general function <code><a href="#topic+GeneralModel">GeneralModel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopSeriesModel(
  t,
  ks,
  a21,
  C0,
  In,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopSeriesModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 with the values of the decomposition rate for
pools 1 and 2.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_c0">C0</code></td>
<td>
<p>A vector of length 2 containing the initial amount of carbon for
the 2 pools.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Sierra, C.A., M. Mueller, S.E. Trumbore. 2012. Models of soil
organic matter decomposition: the SoilR package version 1.0. Geoscientific
Model Development 5, 1045-1060.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t_start=0 
t_end=10 
tn=50
timestep=(t_end-t_start)/tn 
t=seq(t_start,t_end,timestep) 
ks=c(k1=0.8,k2=0.4)
a21=0.5
C0=c(C10=100,C20=150)
In = 30
#
Temp=rnorm(t,15,1)
TempEffect=data.frame(t,fT.Daycent1(Temp))
#
Ex1=TwopSeriesModel(t,ks,a21,C0,In,xi=TempEffect)
Ct=getC(Ex1)
Rt=getReleaseFlux(Ex1)
#
plot(t,rowSums(Ct),type="l",ylab="Carbon stocks (arbitrary units)",
xlab="Time (arbitrary units)",lwd=2,ylim=c(0,sum(Ct[1,]))) 
lines(t,Ct[,1],col=2)
lines(t,Ct[,2],col=4) 
legend("bottomright",c("Total C","C in pool 1", "C in pool 2"),
lty=c(1,1,1),col=c(1,2,4),lwd=c(2,1,1),bty="n")
</code></pre>

<hr>
<h2 id='TwopSeriesModel14'>Implementation of a two-pool C14 model with series structure</h2><span id='topic+TwopSeriesModel14'></span>

<h3>Description</h3>

<p>This function creates a model for two pools connected in series.  It is a
wrapper for the more general function <code><a href="#topic+GeneralModel_14">GeneralModel_14</a></code> that can
handle an arbitrary number of pools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwopSeriesModel14(
  t,
  ks,
  C0,
  F0_Delta14C,
  In,
  a21,
  xi = 1,
  inputFc,
  lambda = -0.0001209681,
  lag = 0,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwopSeriesModel14_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought. It must be specified within the same period for which the Delta 14 C
of the atmosphere is provided. The default period in the provided dataset
<code><a href="#topic+C14Atm_NH">C14Atm_NH</a></code> is 1900-2010.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_ks">ks</code></td>
<td>
<p>A vector of length 2 containing the decomposition rates for the 2
pools.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_c0">C0</code></td>
<td>
<p>A vector of length 2 containing the initial amount of carbon for
the 2 pools.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_f0_delta14c">F0_Delta14C</code></td>
<td>
<p>A vector of length 2 containing the initial amount of the
radiocarbon fraction for the 2 pools as Delta14C values in per mil.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_in">In</code></td>
<td>
<p>A scalar or a data.frame object specifying the amount of litter
inputs by time.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_a21">a21</code></td>
<td>
<p>A scalar with the value of the transfer rate from pool 1 to pool
2.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_xi">xi</code></td>
<td>
<p>A scalar or a data.frame specifying the external (environmental
and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_inputfc">inputFc</code></td>
<td>
<p>A Data Frame object containing values of atmospheric Delta14C
per time. First column must be time values, second column must be Delta14C
values in per mil.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_lambda">lambda</code></td>
<td>
<p>Radioactive decay constant. By default lambda=-0.0001209681
y^-1 . This has the side effect that all your time related data are treated
as if the time unit was year.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_lag">lag</code></td>
<td>
<p>A (positive) scalar representing a time lag for radiocarbon to
enter the system.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="TwopSeriesModel14_+3A_pass">pass</code></td>
<td>
<p>if TRUE Forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model_14">Model_14</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(1901,2009,by=0.5)
LitterInput=700 
#
Ex=TwopSeriesModel14(t=years,ks=c(k1=1/2.8, k2=1/35),
C0=c(200,5000), F0_Delta14C=c(0,0),
In=LitterInput, a21=0.1,inputFc=C14Atm_NH)
R14m=getF14R(Ex)
C14m=getF14C(Ex)
C14t=getF14(Ex)
#
par(mfrow=c(2,1))
plot(C14Atm_NH,type="l",xlab="Year",
ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years, C14t[,1], col=4)
lines(years, C14t[,2],col=4,lwd=2)
legend("topright",c("Delta 14C Atmosphere", "Delta 14C pool 1", "Delta 14C pool 2"),
lty=c(1,1,1),col=c(1,4,4),lwd=c(1,1,2),bty="n")
#
plot(C14Atm_NH,type="l",xlab="Year",ylab="Delta 14C (per mil)",xlim=c(1940,2010)) 
lines(years,C14m,col=4)
lines(years,R14m,col=2)
legend("topright",c("Delta 14C Atmosphere","Delta 14C SOM", "Delta 14C Respired"),
lty=c(1,1,1), col=c(1,4,2),bty="n")
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='UnBoundInFluxes'>Unbound input fluxes</h2><span id='topic+UnBoundInFluxes'></span>

<h3>Description</h3>

<p>Unbound input fluxes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnBoundInFluxes(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundInFluxes_+3A_map">map</code></td>
<td>
<p>see method arguments</p>
</td></tr>
</table>

<hr>
<h2 id='UnBoundInFluxes-class'>automatic title</h2><span id='topic+UnBoundInFluxes-class'></span>

<h3>Description</h3>

<p>automatic title
</p>

<hr>
<h2 id='UnBoundInFluxes+2Cfunction-method'>automatic title</h2><span id='topic+UnBoundInFluxes+2Cfunction-method'></span>

<h3>Description</h3>

<p>automatic title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function''
UnBoundInFluxes(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundInFluxes+2B2Cfunction-method_+3A_map">map</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>

<hr>
<h2 id='UnBoundLinDecompOp'>Generic constructor for the class with the same name</h2><span id='topic+UnBoundLinDecompOp'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnBoundLinDecompOp(matFunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundLinDecompOp_+3A_matfunc">matFunc</code></td>
<td>
<p>function providing a compartmental matrix</p>
</td></tr>
</table>

<hr>
<h2 id='UnBoundLinDecompOp-class'>An S4 class to represent a linear nonautonomous compartmental matrix</h2><span id='topic+UnBoundLinDecompOp-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a linear nonautonomous compartmental matrix
</p>

<hr>
<h2 id='UnBoundLinDecompOp+2Cfunction-method'>Generic constructor for the class with the same name</h2><span id='topic+UnBoundLinDecompOp+2Cfunction-method'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function''
UnBoundLinDecompOp(matFunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundLinDecompOp+2B2Cfunction-method_+3A_matfunc">matFunc</code></td>
<td>
<p>no manual documentation</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other UnBoundLinDecompOp_constructor: 
<code><a href="#topic+getFunctionDefinition+2CUnBoundLinDecompOp-method">getFunctionDefinition,UnBoundLinDecompOp-method</a></code>
</p>

<hr>
<h2 id='UnBoundNonLinDecompOp'>Generic constructor for the class with the same name</h2><span id='topic+UnBoundNonLinDecompOp'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnBoundNonLinDecompOp(
  matFunc,
  internal_fluxes,
  out_fluxes,
  numberOfPools,
  state_variable_names,
  timeSymbol,
  operator
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_matfunc">matFunc</code></td>
<td>
<p>function providing a compartmental matrix</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_internal_fluxes">internal_fluxes</code></td>
<td>
<p>fluxes among pools</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_out_fluxes">out_fluxes</code></td>
<td>
<p>fluxes out of the pools</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>number of pools in the system</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_state_variable_names">state_variable_names</code></td>
<td>
<p>names of the pools</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>character used to represent time</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_+3A_operator">operator</code></td>
<td>
<p>a SoilR operator</p>
</td></tr>
</table>

<hr>
<h2 id='UnBoundNonLinDecompOp_by_PoolNames'>Generic constructor for the class with the same name</h2><span id='topic+UnBoundNonLinDecompOp_by_PoolNames'></span>

<h3>Description</h3>

<p>Generic constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnBoundNonLinDecompOp_by_PoolNames(internal_fluxes, out_fluxes, timeSymbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundNonLinDecompOp_by_PoolNames_+3A_internal_fluxes">internal_fluxes</code></td>
<td>
<p>flux rates among pools</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_by_PoolNames_+3A_out_fluxes">out_fluxes</code></td>
<td>
<p>output flux rates from pools</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp_by_PoolNames_+3A_timesymbol">timeSymbol</code></td>
<td>
<p>character used to represent time</p>
</td></tr>
</table>

<hr>
<h2 id='UnBoundNonLinDecompOp_by_PoolNames-class'>An S4 class to represent the of  nonlinear nonautonomous compartmental system independently of the order of state variables</h2><span id='topic+UnBoundNonLinDecompOp_by_PoolNames-class'></span>

<h3>Description</h3>

<p>An S4 class to represent the of  nonlinear nonautonomous compartmental system independently of the order of state variables
</p>

<hr>
<h2 id='UnBoundNonLinDecompOp-class'>An S4 class to represent a nonlinear nonautonomous compartmental matrix</h2><span id='topic+UnBoundNonLinDecompOp-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a nonlinear nonautonomous compartmental matrix
</p>

<hr>
<h2 id='UnBoundNonLinDecompOp+2Cfunction+2Cmissing+2Cmissing+2Cmissing-method'>Constructor for the class with the same name</h2><span id='topic+UnBoundNonLinDecompOp+2Cfunction+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature ''function',missing,missing,missing'
UnBoundNonLinDecompOp(matFunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundNonLinDecompOp+2B2Cfunction+2B2Cmissing+2B2Cmissing+2B2Cmissing-method_+3A_matfunc">matFunc</code></td>
<td>
<p>A matrix valued function of the state vector and time</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other UnBoundNonLinDecompOp_constructor: 
<code><a href="#topic+UnBoundNonLinDecompOp+2Cmissing+2Cvector+2Cvector+2Cnumeric-method">UnBoundNonLinDecompOp,missing,vector,vector,numeric-method</a></code>
</p>

<hr>
<h2 id='UnBoundNonLinDecompOp+2Cmissing+2Cvector+2Cvector+2Cnumeric-method'>Constructor for the class with the same name</h2><span id='topic+UnBoundNonLinDecompOp+2Cmissing+2Cvector+2Cvector+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Constructor for the class with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing,vector,vector,numeric'
UnBoundNonLinDecompOp(internal_fluxes, out_fluxes, numberOfPools)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnBoundNonLinDecompOp+2B2Cmissing+2B2Cvector+2B2Cvector+2B2Cnumeric-method_+3A_internal_fluxes">internal_fluxes</code></td>
<td>
<p>vector of elements of type InternalFlux_by_PoolName</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp+2B2Cmissing+2B2Cvector+2B2Cvector+2B2Cnumeric-method_+3A_out_fluxes">out_fluxes</code></td>
<td>
<p>vector of elements of type OutFlux_by_PoolName</p>
</td></tr>
<tr><td><code id="UnBoundNonLinDecompOp+2B2Cmissing+2B2Cvector+2B2Cvector+2B2Cnumeric-method_+3A_numberofpools">numberOfPools</code></td>
<td>
<p>number of pools in a model</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other UnBoundNonLinDecompOp_constructor: 
<code><a href="#topic+UnBoundNonLinDecompOp+2Cfunction+2Cmissing+2Cmissing+2Cmissing-method">UnBoundNonLinDecompOp,function,missing,missing,missing-method</a></code>
</p>

<hr>
<h2 id='Yasso07Model'>Implementation of the Yasso07 model</h2><span id='topic+Yasso07Model'></span>

<h3>Description</h3>

<p>This function creates a model for five pools as described in Tuomi et al.
(2009)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Yasso07Model(
  t,
  ks = c(kA = 0.66, kW = 4.3, kE = 0.35, kN = 0.22, kH = 0.0033),
  p = c(p1 = 0.32, p2 = 0.01, p3 = 0.93, p4 = 0.34, p5 = 0, p6 = 0, p7 = 0.035, p8 =
    0.005, p9 = 0.01, p10 = 5e-04, p11 = 0.03, p12 = 0.92, pH = 0.04),
  C0,
  In,
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Yasso07Model_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_ks">ks</code></td>
<td>
<p>A vector of length 5 containing the values of the decomposition
rates for each pool.</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_p">p</code></td>
<td>
<p>A vector of length 13 containing transfer coefficients among
different pools.</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_c0">C0</code></td>
<td>
<p>A vector containing the initial amount of carbon for the 5 pools.
The length of this vector must be 5.</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_in">In</code></td>
<td>
<p>A single scalar or data.frame object specifying the amount of
litter inputs by time</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="Yasso07Model_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Tuomi, M., Thum, T., Jarvinen, H., Fronzek, S., Berg, B.,
Harmon, M., Trofymow, J., Sevanto, S., and Liski, J. (2009). Leaf litter
decomposition-estimates of global variability based on Yasso07 model.
Ecological Modelling, 220:3362 - 3371.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(0,50,0.1) 
C0=rep(100,5)
In=0

Ex1=Yasso07Model(t=years,C0=C0,In=In)
Ct=getC(Ex1)
Rt=getReleaseFlux(Ex1)

plotCPool(years,Ct,col=1:5,xlab="years",ylab="C pool",
ylim=c(0,max(Ct)))
legend("topright",c("xA","xW","xE","xN","xH"),lty=1,col=1:5,bty="n")

plotCPool(years,Rt,col=1:5,xlab="years",ylab="Respiration",ylim=c(0,50))
legend("topright",c("xA","xW","xE","xN","xH"),lty=1,col=1:5,bty="n")
</code></pre>

<hr>
<h2 id='YassoModel'>Implementation of the Yasso model.</h2><span id='topic+YassoModel'></span>

<h3>Description</h3>

<p>This function creates a model for seven pools as described in Liski et al.
(2005). Model not yet implemented due to lack of data in original
publication: values of vector p not completely described in paper. 0.1 was
assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YassoModel(
  t,
  ks = c(a_fwl = 0.54, a_cwl = 0.03, k_ext = 0.48, k_cel = 0.3, k_lig = 0.22, k_hum1 =
    0.012, k_hum2 = 0.0012),
  p = c(fwl_ext = 0.1, cwl_ext = 0.1, fwl_cel = 0.1, cwl_cel = 0.1, fwl_lig = 0.1,
    cwl_lig = 0.1, pext = 0.05, pcel = 0.24, plig = 0.77, phum1 = 0.51),
  C0,
  In = c(u_fwl = 0.0758, u_cwl = 0.0866, u_nwl_cnwl_ext = 0.251 * 0.3, u_nwl_cnwl_cel =
    0.251 * 0.3, u_nwl_cnwl_lig = 0.251 * 0.3, 0, 0),
  xi = 1,
  solver = deSolve.lsoda.wrapper,
  pass = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YassoModel_+3A_t">t</code></td>
<td>
<p>A vector containing the points in time where the solution is
sought.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_ks">ks</code></td>
<td>
<p>A vector of length 7 containing the values of the exposure and
decomposition rates for each pool.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_p">p</code></td>
<td>
<p>A vector of containing transfer coefficients among different pools.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_c0">C0</code></td>
<td>
<p>A vector containing the initial amount of carbon for the 7 pools.
The length of this vector must be 7.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_in">In</code></td>
<td>
<p>A vector of constant litter inputs.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_xi">xi</code></td>
<td>
<p>A scalar or data.frame object specifying the external
(environmental and/or edaphic) effects on decomposition rates.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_solver">solver</code></td>
<td>
<p>A function that solves the system of ODEs. This can be
<code><a href="#topic+euler">euler</a></code> or <code><a href="#topic+deSolve.lsoda.wrapper">deSolve.lsoda.wrapper</a></code> or any other user
provided function with the same interface.</p>
</td></tr>
<tr><td><code id="YassoModel_+3A_pass">pass</code></td>
<td>
<p>if TRUE forces the constructor to create the model even if it is
invalid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Model Object that can be further queried
</p>


<h3>References</h3>

<p>Liski, J., Palosuo, T., Peltoniemi, M., and Sievanen, R. (2005).
Carbon and decomposition model Yasso for forest soils. Ecological Modelling,
189:168-182.
</p>


<h3>See Also</h3>

<p>There are other <code><a href="#topic+predefinedModels">predefinedModels</a></code> and also more
general functions like <code><a href="#topic+Model">Model</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>years=seq(0,500,0.5) 
C0=rep(100,7)
#
Ex1=YassoModel(t=years,C0=C0)
Ct=getC(Ex1)
Rt=getReleaseFlux(Ex1)
#
plotCPool(years,Ct,col=1:7,xlab="years",ylab="C pool",ylim=c(0,200))
legend("topright",c("fwl","cwl","ext","cel","lig","hum1","hum2"),lty=1,col=1:7,bty="n")
#
plotCPool(years,Rt,col=1:7,xlab="years",ylab="Respiration",ylim=c(0,50))
legend("topright",c("fwl","cwl","ext","cel","lig","hum1","hum2"),lty=1,col=1:7,bty="n")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
