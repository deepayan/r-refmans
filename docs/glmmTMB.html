<!DOCTYPE html><html><head><title>Help for package glmmTMB</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmmTMB}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.adjustX'><p>Adjust a model matrix</p>
When not rank deficient, do nothing.
When rank deficient matrix, drop columns.</a></li>
<li><a href='#.checkRankX'><p>Check for identifiability of fixed effects matrices X, Xzi, Xd.</p>
When rank_check='adjust', drop columns in X and remove associated parameters.</a></li>
<li><a href='#.collectDuplicates'><p>collapse duplicated observations</p></a></li>
<li><a href='#Anova.glmmTMB'><p>Downstream methods</p></a></li>
<li><a href='#checkDepPackageVersion'><p>Check for version mismatch in dependent binary packages</p></a></li>
<li><a href='#confint.glmmTMB'><p>Calculate confidence intervals</p></a></li>
<li><a href='#diagnose'><p>diagnose model problems</p></a></li>
<li><a href='#dtruncated_nbinom2'><p>truncated distributions</p></a></li>
<li><a href='#epil2'><p>Seizure Counts for Epileptics - Extended</p></a></li>
<li><a href='#expandDoubleVert'><p>expand double-bar RE notation by splitting</p></a></li>
<li><a href='#expandGrpVar'><p>apply</p></a></li>
<li><a href='#family_params'><p>Retrieve family-specific parameters</p></a></li>
<li><a href='#findReTrmClasses'><p>list of specials &ndash; taken from enum.R</p></a></li>
<li><a href='#fitTMB'><p>Optimize TMB models and package results, modularly</p></a></li>
<li><a href='#fixef'><p>Extract fixed-effects estimates</p></a></li>
<li><a href='#formatVC'><p>Format the 'VarCorr' Matrix of Random Effects</p></a></li>
<li><a href='#formula.glmmTMB'><p>Extract the formula of a glmmTMB object</p></a></li>
<li><a href='#get_cor'><p>translate vector of correlation parameters to correlation values</p></a></li>
<li><a href='#getCapabilities'><p>List model options that glmmTMB knows about</p></a></li>
<li><a href='#getGrpVar'><p>Get Grouping Variable</p></a></li>
<li><a href='#getME.glmmTMB'><p>Extract or Get Generalize Components from a Fitted Mixed Effects Model</p></a></li>
<li><a href='#getReStruc'><p>Calculate random effect structure</p>
Calculates number of random effects, number of parameters,
block size and number of blocks.  Mostly for internal use.</a></li>
<li><a href='#getXReTrms'><p>Create X and random effect terms from formula</p></a></li>
<li><a href='#glmmTMB'><p>Fit Models with TMB</p></a></li>
<li><a href='#glmmTMBControl'><p>Control parameters for glmmTMB optimization</p></a></li>
<li><a href='#isLMM.glmmTMB'><p>support methods for parametric bootstrapping</p></a></li>
<li><a href='#mkTMBStruc'><p>Extract info from formulas, reTrms, etc., format for TMB</p></a></li>
<li><a href='#nbinom2'><p>Family functions for glmmTMB</p></a></li>
<li><a href='#numFactor'><p>Factor with numeric interpretable levels.</p></a></li>
<li><a href='#omp_check'><p>Check OpenMP status</p></a></li>
<li><a href='#Owls'><p>Begging by Owl Nestlings</p></a></li>
<li><a href='#predict.glmmTMB'><p>prediction</p></a></li>
<li><a href='#print.VarCorr.glmmTMB'><p>Printing The Variance and Correlation Parameters of a <code>glmmTMB</code></p></a></li>
<li><a href='#priors'><p>use of priors in glmmTMB</p></a></li>
<li><a href='#profile.glmmTMB'><p>Compute likelihood profiles for a fitted model</p></a></li>
<li><a href='#ranef.glmmTMB'><p>Extract Random Effects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reinstalling'><p>Reinstalling binary dependencies</p></a></li>
<li><a href='#residuals.glmmTMB'><p>Compute residuals for a glmmTMB object</p></a></li>
<li><a href='#RHSForm'><p>extract right-hand side of a formula</p></a></li>
<li><a href='#Salamanders'><p>Repeated counts of salamanders in streams</p></a></li>
<li><a href='#sigma.glmmTMB'><p>Extract residual standard deviation or dispersion parameter</p></a></li>
<li><a href='#simulate_new'><p>Simulate from covariate/metadata in the absence of a real data set (EXPERIMENTAL)</p></a></li>
<li><a href='#simulate.glmmTMB'><p>Simulate from a glmmTMB fitted model</p></a></li>
<li><a href='#splitForm'><p>Split formula containing special random effect terms</p></a></li>
<li><a href='#startParams'><p>Change starting parameters, either by residual method or by user input (start)</p></a></li>
<li><a href='#sub_specials'><p>Substitute safe chars (+) for specials (for use in <code>model.frame</code>)</p>
(Generalized from <code>lme4</code>'s <code>subbars</code> function.)</a></li>
<li><a href='#terms.glmmTMB'><p>Methods for extracting developer-level information from <code>glmmTMB</code> models</p></a></li>
<li><a href='#up2date'><p>conditionally update glmmTMB object fitted with an old TMB version</p></a></li>
<li><a href='#VarCorr.glmmTMB'><p>Extract variance and correlation components</p></a></li>
<li><a href='#vcov.glmmTMB'><p>Calculate Variance-Covariance Matrix for a Fitted glmmTMB model</p></a></li>
<li><a href='#weights.glmmTMB'><p>Extract weights from a glmmTMB object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Linear Mixed Models using Template Model Builder</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit linear and generalized linear mixed models with various
    extensions, including zero-inflation. The models are fitted using maximum
    likelihood estimation via 'TMB' (Template Model Builder). Random effects are
    assumed to be Gaussian on the scale of the linear predictor and are integrated
    out using the Laplace approximation. Gradients are calculated using automatic
    differentiation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, TMB (&ge; 1.9.0), lme4 (&ge; 1.1-18.9000), Matrix, nlme,
numDeriv, mgcv</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, MASS, lattice, ggplot2 (&ge;
2.2.1), mlmRev, bbmle (&ge; 1.0.19), pscl, coda, reshape2, car
(&ge; 3.0.6), emmeans (&ge; 1.4), estimability, DHARMa, multcomp,
MuMIn, effects (&ge; 4.0-1), dotwhisker, broom, broom.mixed,
plyr, png, boot, texreg, xtable, huxtable, mvabund, parallel,
blme, purrr, dplyr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/glmmTMB/glmmTMB">https://github.com/glmmTMB/glmmTMB</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/glmmTMB/glmmTMB/issues">https://github.com/glmmTMB/glmmTMB/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 14:55:58 UTC; molliebrooks</td>
</tr>
<tr>
<td>Author:</td>
<td>Mollie Brooks <a href="https://orcid.org/0000-0001-6963-8326"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ben Bolker <a href="https://orcid.org/0000-0002-2127-0443"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kasper Kristensen [aut],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Arni Magnusson <a href="https://orcid.org/0000-0003-2769-6741"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Maeve McGillycuddy [ctb],
  Hans Skaug <a href="https://orcid.org/0000-0003-4235-2592"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Anders Nielsen <a href="https://orcid.org/0000-0001-9683-9262"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Casper Berg <a href="https://orcid.org/0000-0002-3812-5269"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Koen van Bentham [aut],
  Nafis Sadat <a href="https://orcid.org/0000-0001-5715-616X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Daniel LÃ¼decke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Russ Lenth [ctb],
  Joseph O'Brien <a href="https://orcid.org/0000-0001-9851-5077"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Charles J. Geyer [ctb],
  Mikael Jagan <a href="https://orcid.org/0000-0002-3542-2938"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Brenton Wiernik <a href="https://orcid.org/0000-0001-9560-6336"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Daniel B. Stouffer
    <a href="https://orcid.org/0000-0001-9436-9674"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mollie Brooks &lt;mollieebrooks@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 16:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='.adjustX'>Adjust a model matrix
When not rank deficient, do nothing.
When rank deficient matrix, drop columns.</h2><span id='topic+.adjustX'></span>

<h3>Description</h3>

<p>Adjust a model matrix
When not rank deficient, do nothing.
When rank deficient matrix, drop columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.adjustX(X, tol = NULL, why_dropped = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".adjustX_+3A_x">X</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code id=".adjustX_+3A_tol">tol</code></td>
<td>
<p>non-negative tolerance for testing for &quot;practically zero&quot; singular values (passed to Matrix::rankMatrix())</p>
</td></tr>
<tr><td><code id=".adjustX_+3A_why_dropped">why_dropped</code></td>
<td>
<p>logical indicating whether or not to provide information about sets of collinear predictors (not yet implemented)</p>
</td></tr>
</table>

<hr>
<h2 id='.checkRankX'>Check for identifiability of fixed effects matrices X, Xzi, Xd.
When rank_check='adjust', drop columns in X and remove associated parameters.</h2><span id='topic+.checkRankX'></span>

<h3>Description</h3>

<p>Check for identifiability of fixed effects matrices X, Xzi, Xd.
When rank_check='adjust', drop columns in X and remove associated parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.checkRankX(TMBStruc, rank_check = c("warning", "adjust", "stop", "skip"))
</code></pre>

<hr>
<h2 id='.collectDuplicates'>collapse duplicated observations</h2><span id='topic+.collectDuplicates'></span>

<h3>Description</h3>

<p>collapse duplicated observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.collectDuplicates(data.tmb)
</code></pre>

<hr>
<h2 id='Anova.glmmTMB'>Downstream methods</h2><span id='topic+Anova.glmmTMB'></span><span id='topic+Effect.glmmTMB'></span><span id='topic+downstream_methods'></span><span id='topic+emmeans.glmmTMB'></span>

<h3>Description</h3>

<p>Methods have been written that allow <code>glmmTMB</code> objects to be used with
several downstream packages that enable different forms of inference.
For some methods (<code>Anova</code> and <code>emmeans</code>, but <em>not</em> <code>effects</code> at present),
set the <code>component</code> argument
to &quot;cond&quot; (conditional, the default), &quot;zi&quot; (zero-inflation) or &quot;disp&quot; (dispersion) in order to produce results
for the corresponding part of a <code>glmmTMB</code> model. 
Support for <span class="pkg">emmeans</span> also allows additional options 
<code>component = "response"</code> (response means taking both the <code>cond</code> and
<code>zi</code> components into account), and <code>component = "cmean"</code> (mean of the 
[possibly truncated] conditional distribution). 
</p>
<p>In particular,
</p>

<ul>
<li> <p><code>car::Anova</code> constructs type-II and type-III Anova tables
for the fixed effect parameters of any component
</p>
</li>
<li><p> the <code>emmeans</code> package computes estimated marginal means (previously known as least-squares means)
for the fixed effects of any component, or predictions with <code>type = "response"</code> or
<code>type = "component"</code>. Note: In hurdle models, 
<code>component = "cmean"</code> produces means
of the truncated conditional distribution, while 
<code>component = "cond", type = "response"</code> produces means of the <em>untruncated</em>
conditional distribution.
</p>
</li>
<li><p> the <code>effects</code> package computes graphical tabular effect displays
(only for the fixed effects of the conditional component)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>Anova.glmmTMB(
  mod,
  type = c("II", "III", 2, 3),
  test.statistic = c("Chisq", "F"),
  component = "cond",
  vcov. = vcov(mod)[[component]],
  singular.ok,
  include.rankdef.cols = FALSE,
  ...
)

Effect.glmmTMB(focal.predictors, mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Anova.glmmTMB_+3A_mod">mod</code></td>
<td>
<p>a glmmTMB model</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_type">type</code></td>
<td>
<p>type of test, <code>"II"</code>, <code>"III"</code>, <code>2</code>, or <code>3</code>.  Roman numerals are equivalent to the corresponding Arabic numerals. See <code><a href="car.html#topic+Anova">Anova</a></code> for details.</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_test.statistic">test.statistic</code></td>
<td>
<p>unused: only valid choice is &quot;Chisq&quot; (i.e., Wald chi-squared test)</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_component">component</code></td>
<td>
<p>which component of the model to test/analyze (&quot;cond&quot;, &quot;zi&quot;, or &quot;disp&quot;)
or, in <span class="pkg">emmeans</span> only, &quot;response&quot; or &quot;cmean&quot; as described in Details.</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_vcov.">vcov.</code></td>
<td>
<p>variance-covariance matrix (usually extracted automatically)</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_singular.ok">singular.ok</code></td>
<td>
<p>OK to do ANOVA with singular models (unused) ?</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_include.rankdef.cols">include.rankdef.cols</code></td>
<td>
<p>include all columns of a rank-deficient model matrix?</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_...">...</code></td>
<td>
<p>Additional parameters that may be supported by the method.</p>
</td></tr>
<tr><td><code id="Anova.glmmTMB_+3A_focal.predictors">focal.predictors</code></td>
<td>
<p>a character vector of one or more predictors in the
model in any order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the examples below are disabled for earlier versions of
R, they may still work; it may be necessary to refer to private
versions of methods, e.g. <code>glmmTMB:::Anova.glmmTMB(model, ...)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>warp.lm &lt;- glmmTMB(breaks ~ wool * tension, data = warpbreaks)
salamander1 &lt;- up2date(readRDS(system.file("example_files","salamander1.rds",package="glmmTMB")))
if (require(emmeans)) withAutoprint({
    emmeans(warp.lm, poly ~ tension | wool)
    emmeans(salamander1, ~ mined, type="response")  # conditional means
    emmeans(salamander1, ~ mined, component="cmean")     # same as above, but re-gridded
    emmeans(salamander1, ~ mined, component="zi", type="response")  # zero probabilities
    emmeans(salamander1, ~ mined, component="response")  # response means including both components
})
if (getRversion() &gt;= "3.6.0") {
   if (require(car)) withAutoprint({
       Anova(warp.lm,type="III")
       Anova(salamander1)
       Anova(salamander1, component="zi")
   })
   if (require(effects)) withAutoprint({
       plot(allEffects(warp.lm))
       plot(allEffects(salamander1))
   })
}
</code></pre>

<hr>
<h2 id='checkDepPackageVersion'>Check for version mismatch in dependent binary packages</h2><span id='topic+checkDepPackageVersion'></span>

<h3>Description</h3>

<p>Check for version mismatch in dependent binary packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDepPackageVersion(
  dep_pkg = "TMB",
  this_pkg = "glmmTMB",
  write_file = FALSE,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDepPackageVersion_+3A_dep_pkg">dep_pkg</code></td>
<td>
<p>upstream package</p>
</td></tr>
<tr><td><code id="checkDepPackageVersion_+3A_this_pkg">this_pkg</code></td>
<td>
<p>downstream package</p>
</td></tr>
<tr><td><code id="checkDepPackageVersion_+3A_write_file">write_file</code></td>
<td>
<p>(logical) write version file and quit?</p>
</td></tr>
<tr><td><code id="checkDepPackageVersion_+3A_warn">warn</code></td>
<td>
<p>give warning?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: TRUE if the binary versions match
</p>

<hr>
<h2 id='confint.glmmTMB'>Calculate confidence intervals</h2><span id='topic+confint.glmmTMB'></span>

<h3>Description</h3>

<p>Calculate confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
confint(
  object,
  parm = NULL,
  level = 0.95,
  method = c("wald", "Wald", "profile", "uniroot"),
  component = c("all", "cond", "zi", "other"),
  estimate = TRUE,
  include_nonest = FALSE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("profile.ncpus", 1L),
  cl = NULL,
  full = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.glmmTMB_+3A_object">object</code></td>
<td>
<p><code>glmmTMB</code> fitted object.</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_parm">parm</code></td>
<td>
<p>which parameters to profile, specified
</p>

<ul>
<li><p> by index (position) [<em>after</em> component selection for <code>confint</code>, if any]
</p>
</li>
<li><p> by name (matching the row/column names of <code>vcov(object,full=TRUE)</code>)
</p>
</li>
<li><p> as <code>"theta_"</code> (random-effects variance-covariance parameters), <code>"beta_"</code> (conditional and zero-inflation parameters), or <code>"disp_"</code> or <code>"sigma"</code> (dispersion parameters)
</p>
</li></ul>

<p>Parameter indexing by number may give unusual results when
some parameters have been fixed using the <code>map</code> argument:
please report surprises to the package maintainers.</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_level">level</code></td>
<td>
<p>Confidence level.</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_method">method</code></td>
<td>
<p>'wald', 'profile', or 'uniroot': see Details
function)</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_component">component</code></td>
<td>
<p>Which of the three components 'cond', 'zi' or
'other' to select. Default is to select 'all'.</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_estimate">estimate</code></td>
<td>
<p>(logical) add a third column with estimate ?</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_include_nonest">include_nonest</code></td>
<td>
<p>include dummy rows for non-estimated (mapped, rank-deficient) parameters?</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_parallel">parallel</code></td>
<td>
<p>method (if any) for parallel computation</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_ncpus">ncpus</code></td>
<td>
<p>number of CPUs/cores to use for parallel computation</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_cl">cl</code></td>
<td>
<p>cluster to use for parallel computation</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_full">full</code></td>
<td>
<p>CIs for all parameters (including dispersion) ?</p>
</td></tr>
<tr><td><code id="confint.glmmTMB_+3A_...">...</code></td>
<td>
<p>arguments may be passed to <code><a href="#topic+profile.glmmTMB">profile.glmmTMB</a></code> (and possibly from there to <code><a href="TMB.html#topic+tmbprofile">tmbprofile</a></code>) or
<code><a href="TMB.html#topic+tmbroot">tmbroot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available methods are
</p>

<dl>
<dt>&quot;wald&quot;</dt><dd><p>These intervals are based on the standard errors
calculated for parameters on the scale
of their internal parameterization depending on the family. Derived
quantities such as standard deviation parameters and dispersion
parameters are back-transformed. It follows that confidence
intervals for these derived quantities are typically asymmetric.</p>
</dd>
<dt>&quot;profile&quot;</dt><dd><p>This method computes a likelihood profile
for the specified parameter(s) using <code>profile.glmmTMB</code>;
fits a spline function to each half of the profile; and
inverts the function to find the specified confidence interval.</p>
</dd>
<dt>&quot;uniroot&quot;</dt><dd><p>This method uses the <code><a href="stats.html#topic+uniroot">uniroot</a></code>
function to find critical values of one-dimensional profile
functions for each specified parameter.</p>
</dd>
</dl>

<p>At present, &quot;wald&quot; returns confidence intervals for variance
parameters on the standard deviation/correlation scale, while
&quot;profile&quot; and &quot;uniroot&quot; report them on the underlying (&quot;theta&quot;)
scale: for each random effect, the first set of parameter values
are standard deviations on the log scale, while remaining parameters
represent correlations on the scaled Cholesky scale. For a random
effects model with two elements (such as a random-slopes model,
or a random effect of factor with two levels), there is a single
correlation parameter <code class="reqn">\theta</code>; the correlation is
equal to <code class="reqn">\rho = \theta/\sqrt{1+\theta^2}</code>.
For random-effects terms with more than two elements, the mapping
is more complicated: see https://github.com/glmmTMB/glmmTMB/blob/master/misc/glmmTMB_corcalcs.ipynb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sleepstudy, package="lme4")
model &lt;- glmmTMB(Reaction ~ Days + (1|Subject), sleepstudy)
model2 &lt;- glmmTMB(Reaction ~ Days + (1|Subject), sleepstudy,
    dispformula= ~I(Days&gt;8))
confint(model)  ## Wald/delta-method CIs
confint(model,parm="theta_")  ## Wald/delta-method CIs
confint(model,parm=1,method="profile")
</code></pre>

<hr>
<h2 id='diagnose'>diagnose model problems</h2><span id='topic+diagnose'></span>

<h3>Description</h3>

<p><strong>EXPERIMENTAL</strong>. For a given model, this function attempts to isolate
potential causes of convergence problems. It checks (1) whether there are
any unusually large coefficients; (2) whether there are any unusually
scaled predictor variables; (3) if the Hessian (curvature of the
negative log-likelihood surface at the MLE) is positive definite
(i.e., whether the MLE really represents an optimum). For each
case it tries to isolate the particular parameters that are problematic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnose(
  fit,
  eval_eps = 1e-05,
  evec_eps = 0.01,
  big_coef = 10,
  big_sd_log10 = 3,
  big_zstat = 5,
  check_coefs = TRUE,
  check_zstats = TRUE,
  check_hessian = TRUE,
  check_scales = TRUE,
  explain = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnose_+3A_fit">fit</code></td>
<td>
<p>a <code>glmmTMB</code> fit</p>
</td></tr>
<tr><td><code id="diagnose_+3A_eval_eps">eval_eps</code></td>
<td>
<p>numeric tolerance for 'bad' eigenvalues</p>
</td></tr>
<tr><td><code id="diagnose_+3A_evec_eps">evec_eps</code></td>
<td>
<p>numeric tolerance for 'bad' eigenvector elements</p>
</td></tr>
<tr><td><code id="diagnose_+3A_big_coef">big_coef</code></td>
<td>
<p>numeric tolerance for large coefficients</p>
</td></tr>
<tr><td><code id="diagnose_+3A_big_sd_log10">big_sd_log10</code></td>
<td>
<p>numeric tolerance for badly scaled parameters (log10 scale), i.e. for default value of 3, predictor variables with sd less than 1e-3 or greater than 1e3 will be flagged)</p>
</td></tr>
<tr><td><code id="diagnose_+3A_big_zstat">big_zstat</code></td>
<td>
<p>numeric tolerance for Z-statistic</p>
</td></tr>
<tr><td><code id="diagnose_+3A_check_coefs">check_coefs</code></td>
<td>
<p>identify large-magnitude coefficients? (Only checks conditional-model parameters if a (log, logit, cloglog, probit) link is used. Always checks zero-inflation, dispersion, and random-effects parameters. May produce false positives if predictor variables have extremely large scales.)</p>
</td></tr>
<tr><td><code id="diagnose_+3A_check_zstats">check_zstats</code></td>
<td>
<p>identify parameters with unusually large Z-statistics (ratio of standard error to mean)? Identifies likely failures of Wald confidence intervals/p-values.</p>
</td></tr>
<tr><td><code id="diagnose_+3A_check_hessian">check_hessian</code></td>
<td>
<p>identify non-positive-definite Hessian components?</p>
</td></tr>
<tr><td><code id="diagnose_+3A_check_scales">check_scales</code></td>
<td>
<p>identify predictors with unusually small or large scales?</p>
</td></tr>
<tr><td><code id="diagnose_+3A_explain">explain</code></td>
<td>
<p>provide detailed explanation of each test?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Problems in one category (e.g. complete separation) will generally
also appear in &quot;downstream&quot; categories (e.g. non-positive-definite
Hessians).
Therefore, it is generally
advisable to try to deal with problems in order, e.g. address problems with
complete separation first, then re-run the diagnostics to see whether
Hessian problems persist.
</p>


<h3>Value</h3>

<p>a logical value based on whether anything questionable was found
</p>

<hr>
<h2 id='dtruncated_nbinom2'>truncated distributions</h2><span id='topic+dtruncated_nbinom2'></span><span id='topic+dtruncated_poisson'></span><span id='topic+dtruncated_nbinom1'></span>

<h3>Description</h3>

<p>Probability functions for k-truncated Poisson and negative binomial distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtruncated_nbinom2(x, size, mu, k = 0, log = FALSE)

dtruncated_poisson(x, lambda, k = 0, log = FALSE)

dtruncated_nbinom1(x, phi, mu, k = 0, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtruncated_nbinom2_+3A_x">x</code></td>
<td>
<p>value</p>
</td></tr>
<tr><td><code id="dtruncated_nbinom2_+3A_size">size</code></td>
<td>
<p>number of trials/overdispersion parameter</p>
</td></tr>
<tr><td><code id="dtruncated_nbinom2_+3A_mu">mu</code></td>
<td>
<p>mean parameter</p>
</td></tr>
<tr><td><code id="dtruncated_nbinom2_+3A_k">k</code></td>
<td>
<p>truncation parameter</p>
</td></tr>
<tr><td><code id="dtruncated_nbinom2_+3A_log">log</code></td>
<td>
<p>(logical) return log-probability?</p>
</td></tr>
<tr><td><code id="dtruncated_nbinom2_+3A_lambda">lambda</code></td>
<td>
<p>mean parameter</p>
</td></tr>
<tr><td><code id="dtruncated_nbinom2_+3A_phi">phi</code></td>
<td>
<p>overdispersion parameter</p>
</td></tr>
</table>

<hr>
<h2 id='epil2'>Seizure Counts for Epileptics - Extended</h2><span id='topic+epil2'></span>

<h3>Description</h3>

<p>Extended version of the <code>epil</code> dataset of the <span class="pkg">MASS</span> package.
The three transformed variables <code>Visit</code>, <code>Base</code>, and
<code>Age</code> used by Booth et al. (2003) have been added to <code>epil</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epil2</code></pre>


<h3>Format</h3>

<p>A data frame with 236 observations on the following 12 variables:
</p>

<dl>
<dt><code>y</code></dt><dd><p>an integer vector.</p>
</dd>
<dt><code>trt</code></dt><dd><p>a factor with levels <code>"placebo"</code> and
<code>"progabide"</code>.</p>
</dd>
<dt><code>base</code></dt><dd><p>an integer vector.</p>
</dd>
<dt><code>age</code></dt><dd><p>an integer vector.</p>
</dd>
<dt><code>V4</code></dt><dd><p>an integer vector.</p>
</dd>
<dt><code>subject</code></dt><dd><p>an integer vector.</p>
</dd>
<dt><code>period</code></dt><dd><p>an integer vector.</p>
</dd>
<dt><code>lbase</code></dt><dd><p>a numeric vector.</p>
</dd>
<dt><code>lage</code></dt><dd><p>a numeric vector.</p>
</dd>
<dt>Visit</dt><dd><p><code>(rep(1:4,59) - 2.5) / 5</code>.</p>
</dd>
<dt>Base</dt><dd><p><code>log(base/4)</code>.</p>
</dd>
<dt>Age</dt><dd><p><code>log(age)</code>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Booth, J.G., G. Casella, H. Friedl, and J.P. Hobert. (2003)
Negative binomial loglinear mixed models.
<em>Statistical Modelling</em> <b>3</b>, 179&ndash;191.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
epil2$subject &lt;- factor(epil2$subject)
op &lt;- options(digits=3)
(fm &lt;- glmmTMB(y ~ Base*trt + Age + Visit + (Visit|subject),
              data=epil2, family=nbinom2))
meths &lt;- methods(class = class(fm))
if((Rv &lt;- getRversion()) &gt; "3.1.3") {
  funs &lt;- attr(meths, "info")[, "generic"]
  funs &lt;- setdiff(funs, "profile")  ## too slow! pkgdown is trying to run this??
  for(fun in funs[is.na(match(funs, "getME"))]) {
        cat(sprintf("%s:\n-----\n", fun))
        r &lt;- tryCatch( get(fun)(fm), error=identity)
        if (inherits(r, "error")) cat("** Error:", r$message,"\n")
        else tryCatch( print(r) )
        cat(sprintf("---end{%s}--------------\n\n", fun))
  }
}
options(op)

</code></pre>

<hr>
<h2 id='expandDoubleVert'>expand double-bar RE notation by splitting</h2><span id='topic+expandDoubleVert'></span><span id='topic+RHSForm+3C-'></span><span id='topic+sumTerms'></span><span id='topic+reOnly'></span><span id='topic+makeOp'></span><span id='topic+addForm0'></span><span id='topic+addForm'></span><span id='topic+expandAllGrpVar'></span><span id='topic+findbars_x'></span><span id='topic+inForm'></span><span id='topic+extractForm'></span><span id='topic+dropHead'></span><span id='topic+drop.special'></span><span id='topic+replaceForm'></span>

<h3>Description</h3>

<p>Modeled after lme4:::expandSlash, by Doug Bates. However,
all formula operators that apply to factors (<code>*</code>, <code>/</code>, <code>+</code>)
are applicable: the results are expanded into a list of independent (additive)
random effect terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandDoubleVert(term)

RHSForm(formula) &lt;- value

sumTerms(termList)

reOnly(f, response = FALSE, bracket = TRUE)

makeOp(x, y, op = NULL)

addForm0(f1, f2)

addForm(...)

expandAllGrpVar(bb)

findbars_x(
  term,
  debug = FALSE,
  specials = character(0),
  default.special = "us",
  target = "|",
  expand_doublevert_method = c("diag_special", "split")
)

inForm(form, value)

extractForm(term, value)

dropHead(term, value)

drop.special(x, value = quote(offset), preserve = NULL)

replaceForm(term, target, repl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandDoubleVert_+3A_term">term</code></td>
<td>
<p>expression/formula</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_formula">formula</code></td>
<td>
<p>a formula object</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_value">value</code></td>
<td>
<p>term to remove from formula</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_termlist">termList</code></td>
<td>
<p>a list of formula terms</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_f">f</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_response">response</code></td>
<td>
<p>include response variable?</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_bracket">bracket</code></td>
<td>
<p>bracket-protect terms?</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_x">x</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_y">y</code></td>
<td>
<p>a formula term (or an operator)</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_op">op</code></td>
<td>
<p>an operator</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_f1">f1</code></td>
<td>
<p>formula #1</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_f2">f2</code></td>
<td>
<p>formula #2</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_...">...</code></td>
<td>
<p>arguments to pass through to <code>addForm0</code></p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_bb">bb</code></td>
<td>
<p>a list of naked grouping variables, i.e. 1 | f</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_debug">debug</code></td>
<td>
<p>(logical) debug?</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_specials">specials</code></td>
<td>
<p>list of special terms</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_default.special">default.special</code></td>
<td>
<p>character: special to use for parenthesized terms - i.e. random effects terms with unspecified structure</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_expand_doublevert_method">expand_doublevert_method</code></td>
<td>
<p>method for handling <code>||</code> operator: split into separate terms or replace by <code>diag</code>? Inherited from <em>previous call where it was specified</em>.
1. atom (not a call or an expression): NULL
2. special, i.e. foo(...) where &quot;foo&quot; is in specials: return term
3. parenthesized term: <em>if</em> the head of the head is | (i.e.
it is of the form (xx|gg), then convert it to the default
special type; we won't allow pathological cases like
((xx|gg)) ... [can we detect them?]</p>
</td></tr>
<tr><td><code id="expandDoubleVert_+3A_preserve">preserve</code></td>
<td>
<p>(integer) retain the specified occurrence of &quot;value&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of expressions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>addForm0(y~x,~1)
addForm0(~x,~y)
ff &lt;- lme4::findbars(y~1+(x|f/g))
expandAllGrpVar(ff)
expandAllGrpVar(quote(1|(f/g)/h))
expandAllGrpVar(quote(1|f/g/h))
expandAllGrpVar(quote(1|f*g))
expandAllGrpVar(quote(1|f+g))
expandAllGrpVar(quote(a+b|f+g+h*i))
## wish list ... this should be (1|a) + (1|a:b) + (1|a:b:c) + (1|a:b:d) ...
## expandAllGrpVar(quote(a/b/(c+d)))
expandAllGrpVar(quote(s(log(d), k = 4)))
expandAllGrpVar(quote(s(log(d+1))))
splitForm(quote(us(x,n=2)))
findbars_x(~ 1 + (x + y || g), expand_doublevert_method = "diag_special")
findbars_x(~ 1 + (x + y || g), expand_doublevert_method = "split")
findbars_x(~ 1 + (1 | f) + (1 | g))
findbars_x(~ 1 + (1 | f) + (1 | g))
findbars_x(~ 1 + (1|h) + (x + y || g), expand_doublevert_method = "split")
findbars_x(~ 1 + (1|Subject))
findbars_x(~ (1||Subject))
findbars_x(~ (1|Subject))
findbars_x(~ (1|Subject), default.special = NULL)
findbars_x(~ 1 + x)
findbars_x(~ s(x, bs = "tp"))
findbars_x(y ~ a + log(b) + s(x, bs = "tp") + s(y, bs = "gp"),
   target = "s", default.special = NULL)
inForm(z~.,quote(.))
inForm(z~y,quote(.))
inForm(z~a+b+c,quote(c))
inForm(z~a+b+(d+e),quote(c))
f &lt;- ~ a + offset(x)
f2 &lt;- z ~ a
inForm(f,quote(offset))
inForm(f2,quote(offset))
extractForm(~a+offset(b),quote(offset))
extractForm(~c,quote(offset))
extractForm(~a+offset(b)+offset(c),quote(offset))
extractForm(~offset(x),quote(offset))
dropHead(~a+offset(b),quote(offset))
dropHead(~a+poly(x+z,3)+offset(b),quote(offset))
drop.special(x~a + b+ offset(z))
replaceForm(quote(a(b+x*c(y,z))),quote(y),quote(R))
ss &lt;- ~(1 | cask:batch) + (1 | batch)
replaceForm(ss,quote(cask:batch),quote(batch:cask))
replaceForm(ss, quote(`:`), quote(`%:%`))
</code></pre>

<hr>
<h2 id='expandGrpVar'>apply</h2><span id='topic+expandGrpVar'></span>

<h3>Description</h3>

<p>apply
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandGrpVar(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandGrpVar_+3A_f">f</code></td>
<td>
<p>a language object (an atom of a formula)
expandGrpVar(quote(x*y))
expandGrpVar(quote(x/y))</p>
</td></tr>
</table>

<hr>
<h2 id='family_params'>Retrieve family-specific parameters</h2><span id='topic+family_params'></span>

<h3>Description</h3>

<p>Most conditional distributions have only parameters governing their location
(retrieved via <code>predict</code>) and scale (<code>sigma</code>). A few (e.g. Tweedie, Student t, ordered beta)
are characterized by one or more additional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>family_params(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family_params_+3A_object">object</code></td>
<td>
<p>glmmTMB object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named numeric vector
</p>

<hr>
<h2 id='findReTrmClasses'>list of specials &ndash; taken from enum.R</h2><span id='topic+findReTrmClasses'></span>

<h3>Description</h3>

<p>list of specials &ndash; taken from enum.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findReTrmClasses()
</code></pre>

<hr>
<h2 id='fitTMB'>Optimize TMB models and package results, modularly</h2><span id='topic+fitTMB'></span><span id='topic+finalizeTMB'></span>

<h3>Description</h3>

<p>These functions (called internally by <code><a href="#topic+glmmTMB">glmmTMB</a></code>) perform
the actual model optimization, after all of the appropriate structures
have been set up (<code>fitTMB</code>), and finalize the model after
optimization (<code>finalizeTMB</code>). It can be useful to run <code><a href="#topic+glmmTMB">glmmTMB</a></code> with
<code>doFit=FALSE</code>, adjust the components as required, and then
finish the fitting process with <code>fitTMB</code> (however, it is the
user's responsibility to make sure that any modifications
create an internally consistent final fitted object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitTMB(TMBStruc, doOptim = TRUE)

finalizeTMB(TMBStruc, obj, fit, h = NULL, data.tmb.old = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitTMB_+3A_tmbstruc">TMBStruc</code></td>
<td>
<p>a list containing lots of stuff ...</p>
</td></tr>
<tr><td><code id="fitTMB_+3A_dooptim">doOptim</code></td>
<td>
<p>logical; do optimization? If FALSE, return TMB object</p>
</td></tr>
<tr><td><code id="fitTMB_+3A_obj">obj</code></td>
<td>
<p>object created by <code>fitTMB(., doOptim = FALSE)</code></p>
</td></tr>
<tr><td><code id="fitTMB_+3A_fit">fit</code></td>
<td>
<p>a fitted object returned from <code>nlminb</code>, or more generally
a similar list (i.e. containing elements <code>par</code>, <code>objective</code>, <code>convergence</code>,
<code>message</code>, <code>iterations</code>, <code>evaluations</code>)</p>
</td></tr>
<tr><td><code id="fitTMB_+3A_h">h</code></td>
<td>
<p>Hessian matrix for fit, if computed in previous step</p>
</td></tr>
<tr><td><code id="fitTMB_+3A_data.tmb.old">data.tmb.old</code></td>
<td>
<p>stored TMB data, if computed in previous step</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## regular (non-modular) model fit
m0 &lt;- glmmTMB(count ~ mined + (1|site),
             family=poisson, data=Salamanders)
## construct model structures
m1 &lt;- update(m0, doFit=FALSE)
names(m0)
m2 &lt;- fitTMB(m1, doOptim = FALSE)
## could modify the components of m1$env$data at this point ...
## rebuild TMB structure (*may* be necessary)
m2 &lt;- with(m2$env,
               TMB::MakeADFun(data,
                               parameters,
                               map = map,
                               random = random,
                               silent = silent,
                               DLL = "glmmTMB"))
m3 &lt;- with(m2, nlminb(par, objective = fn, gr = gr))
m4 &lt;- finalizeTMB(m1, m2, m3)
</code></pre>

<hr>
<h2 id='fixef'>Extract fixed-effects estimates</h2><span id='topic+fixef'></span><span id='topic+fixef.glmmTMB'></span>

<h3>Description</h3>

<p>Extract Fixed Effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef_+3A_object">object</code></td>
<td>
<p>any fitted model object from which fixed effects estimates can
be extracted.</p>
</td></tr>
<tr><td><code id="fixef_+3A_...">...</code></td>
<td>
<p>optional additional arguments. Currently none are used in any
methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract fixed effects from a fitted <code>glmmTMB</code> model.
</p>
<p>The print method for <code>fixef.glmmTMB</code> object <em>only displays non-trivial components</em>: in particular, the dispersion parameter estimate is not printed for models with a single (intercept) dispersion parameter (see examples)
</p>


<h3>Value</h3>

<p>an object of class <code>fixef.glmmTMB</code> comprising a list of components (<code>cond</code>, <code>zi</code>, <code>disp</code>), each containing a (possibly zero-length) numeric vector of coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sleepstudy, package = "lme4")
fm1 &lt;- glmmTMB(Reaction ~ Days, sleepstudy)
(f1 &lt;- fixef(fm1))
f1$cond
## show full coefficients, including empty z-i model and
## constant dispersion parameter
print(f1, print_trivials = TRUE)
</code></pre>

<hr>
<h2 id='formatVC'>Format the 'VarCorr' Matrix of Random Effects</h2><span id='topic+formatVC'></span>

<h3>Description</h3>

<p>&quot;format()&quot; the 'VarCorr' matrix of the random effects &ndash; for
print()ing and show()ing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatVC(
  varcor,
  digits = max(3, getOption("digits") - 2),
  comp = "Std.Dev.",
  formatter = format,
  useScale = attr(varcor, "useSc"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatVC_+3A_varcor">varcor</code></td>
<td>
<p>a <code><a href="#topic+VarCorr">VarCorr</a></code> (-like) matrix with attributes.</p>
</td></tr>
<tr><td><code id="formatVC_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits.</p>
</td></tr>
<tr><td><code id="formatVC_+3A_comp">comp</code></td>
<td>
<p>character vector of length one or two indicating which
columns out of &quot;Variance&quot; and &quot;Std.Dev.&quot; should be shown in the
formatted output.</p>
</td></tr>
<tr><td><code id="formatVC_+3A_formatter">formatter</code></td>
<td>
<p>the <code><a href="base.html#topic+function">function</a></code> to be used for
formatting the standard deviations and or variances (but
<em>not</em> the correlations which (currently) are always formatted
as &quot;0.nnn&quot;</p>
</td></tr>
<tr><td><code id="formatVC_+3A_usescale">useScale</code></td>
<td>
<p>whether to report a scale parameter (e.g. residual standard deviation)</p>
</td></tr>
<tr><td><code id="formatVC_+3A_...">...</code></td>
<td>
<p>optional arguments for <code>formatter(*)</code> in addition
to the first (numeric vector) and <code>digits</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character matrix of formatted VarCorr entries from <code>varc</code>.
</p>

<hr>
<h2 id='formula.glmmTMB'>Extract the formula of a glmmTMB object</h2><span id='topic+formula.glmmTMB'></span>

<h3>Description</h3>

<p>Extract the formula of a glmmTMB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
formula(x, fixed.only = FALSE, component = c("cond", "zi", "disp"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.glmmTMB_+3A_x">x</code></td>
<td>
<p>a <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="formula.glmmTMB_+3A_fixed.only">fixed.only</code></td>
<td>
<p>(logical) drop random effects, returning only the fixed-effect component of the formula?</p>
</td></tr>
<tr><td><code id="formula.glmmTMB_+3A_component">component</code></td>
<td>
<p>formula for which component of the model to return (conditional, zero-inflation, or dispersion)</p>
</td></tr>
<tr><td><code id="formula.glmmTMB_+3A_...">...</code></td>
<td>
<p>unused, for generic consistency</p>
</td></tr>
</table>

<hr>
<h2 id='get_cor'>translate vector of correlation parameters to correlation values</h2><span id='topic+get_cor'></span><span id='topic+put_cor'></span>

<h3>Description</h3>

<p>translate vector of correlation parameters to correlation values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cor(theta)

put_cor(C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cor_+3A_theta">theta</code></td>
<td>
<p>vector of internal correlation parameters (elements of scaled Cholesky factor, in <em>row-major</em> order)</p>
</td></tr>
<tr><td><code id="get_cor_+3A_c">C</code></td>
<td>
<p>a correlation matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions follow the definition at <a href="http://kaskr.github.io/adcomp/classdensity_1_1UNSTRUCTURED__CORR__t.html">http://kaskr.github.io/adcomp/classdensity_1_1UNSTRUCTURED__CORR__t.html</a>:
if <code class="reqn">L</code> is the lower-triangular matrix with 1 on the diagonal and the correlation parameters in the lower triangle, then the correlation matrix is defined as <code class="reqn">\Sigma = D^{-1/2} L L^\top D^{-1/2}</code>, where <code class="reqn">D = \textrm{diag}(L L^\top)</code>. For a single correlation parameter <code class="reqn">\theta_0</code>, this works out to <code class="reqn">\rho = \theta_0/\sqrt{1+\theta_0^2}</code>. The <code>get_cor</code> function returns the elements of the lower triangle of the correlation matrix, in column-major order.
</p>


<h3>Value</h3>

<p>a vector of correlation values (<code>get_cor</code>) or glmmTMB scaled-correlation parameters (<code>put_cor</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>th0 &lt;- 0.5
stopifnot(all.equal(get_cor(th0),th0/sqrt(1+th0^2)))
get_cor(c(0.5,0.2,0.5))
C &lt;- matrix(c(1,  0.2,  0.1,
             0.2,  1, -0.2,
             0.1,-0.2,   1),
           3, 3)
## test: round-trip (almostl results in lower triangle only)
stopifnot(all.equal(get_cor(put_cor(C)),
                   C[lower.tri(C)]))
</code></pre>

<hr>
<h2 id='getCapabilities'>List model options that glmmTMB knows about</h2><span id='topic+getCapabilities'></span>

<h3>Description</h3>

<p>List model options that glmmTMB knows about
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCapabilities(what = "all", check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCapabilities_+3A_what">what</code></td>
<td>
<p>(character) which type of model structure to report on
(&quot;all&quot;,&quot;family&quot;,&quot;link&quot;,&quot;covstruct&quot;)</p>
</td></tr>
<tr><td><code id="getCapabilities_+3A_check">check</code></td>
<td>
<p>(logical) do brute-force checking to test whether families are really implemented (only available for <code>what="family"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>check==FALSE</code>, returns a vector of the names (or a list of name vectors) of allowable entries; if <code>check==TRUE</code>, returns a logical vector of working families
</p>


<h3>Note</h3>

<p>these are all the options that are <em>defined</em> internally; they have not necessarily all been <em>implemented</em> (FIXME!)
</p>

<hr>
<h2 id='getGrpVar'>Get Grouping Variable</h2><span id='topic+getGrpVar'></span>

<h3>Description</h3>

<p>Extract grouping variables for random effect terms from a factor list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGrpVar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGrpVar_+3A_x">x</code></td>
<td>
<p>&quot;flist&quot; object; a data frame of factors including an <code>assign</code> attribute
matching columns to random effect terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of grouping variables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cbpp,package="lme4")
cbpp$obs &lt;- factor(seq(nrow(cbpp)))
rt &lt;- lme4::glFormula(cbind(size,incidence-size)~(1|herd)+(1|obs),
  data=cbpp,family=binomial)$reTrms
getGrpVar(rt$flist)
</code></pre>

<hr>
<h2 id='getME.glmmTMB'>Extract or Get Generalize Components from a Fitted Mixed Effects Model</h2><span id='topic+getME.glmmTMB'></span><span id='topic+getME'></span>

<h3>Description</h3>

<p>Extract or Get Generalize Components from a Fitted Mixed Effects Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
getME(
  object,
  name = c("X", "Xzi", "Z", "Zzi", "Xd", "theta", "beta", "b"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getME.glmmTMB_+3A_object">object</code></td>
<td>
<p>a fitted <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="getME.glmmTMB_+3A_name">name</code></td>
<td>
<p>of the component to be retrieved</p>
</td></tr>
<tr><td><code id="getME.glmmTMB_+3A_...">...</code></td>
<td>
<p>ignored, for method compatibility</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+getME">getME</a></code>
Get generic and re-export:
</p>

<hr>
<h2 id='getReStruc'>Calculate random effect structure
Calculates number of random effects, number of parameters,
block size and number of blocks.  Mostly for internal use.</h2><span id='topic+getReStruc'></span>

<h3>Description</h3>

<p>Calculate random effect structure
Calculates number of random effects, number of parameters,
block size and number of blocks.  Mostly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReStruc(reTrms, ss = NULL, aa = NULL, reXterms = NULL, fr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReStruc_+3A_retrms">reTrms</code></td>
<td>
<p>random-effects terms list</p>
</td></tr>
<tr><td><code id="getReStruc_+3A_ss">ss</code></td>
<td>
<p>a character string indicating a valid covariance structure.
Must be one of <code>names(glmmTMB:::.valid_covstruct)</code>;
default is to use an unstructured  variance-covariance
matrix (<code>"us"</code>) for all blocks).</p>
</td></tr>
<tr><td><code id="getReStruc_+3A_aa">aa</code></td>
<td>
<p>additional arguments (i.e. rank)</p>
</td></tr>
<tr><td><code id="getReStruc_+3A_rexterms">reXterms</code></td>
<td>
<p>terms objects corresponding to each RE term</p>
</td></tr>
<tr><td><code id="getReStruc_+3A_fr">fr</code></td>
<td>
<p>model frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>
<table>
<tr><td><code>blockNumTheta</code></td>
<td>
<p>number of variance covariance parameters per term</p>
</td></tr>
<tr><td><code>blockSize</code></td>
<td>
<p>size (dimension) of one block</p>
</td></tr>
<tr><td><code>blockReps</code></td>
<td>
<p>number of times the blocks are repeated (levels)</p>
</td></tr>
<tr><td><code>covCode</code></td>
<td>
<p>structure code</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(sleepstudy, package="lme4")
rt &lt;- lme4::lFormula(Reaction~Days+(1|Subject)+(0+Days|Subject),
                    sleepstudy)$reTrms
rt2 &lt;- lme4::lFormula(Reaction~Days+(Days|Subject),
                    sleepstudy)$reTrms
getReStruc(rt)
</code></pre>

<hr>
<h2 id='getXReTrms'>Create X and random effect terms from formula</h2><span id='topic+getXReTrms'></span>

<h3>Description</h3>

<p>Create X and random effect terms from formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getXReTrms(
  formula,
  mf,
  fr,
  ranOK = TRUE,
  type = "",
  contrasts,
  sparse = FALSE,
  old_smooths = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getXReTrms_+3A_formula">formula</code></td>
<td>
<p>current formula, containing both fixed &amp; random effects</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_mf">mf</code></td>
<td>
<p>matched call</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_fr">fr</code></td>
<td>
<p>full model frame</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_ranok">ranOK</code></td>
<td>
<p>random effects allowed here?</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_type">type</code></td>
<td>
<p>label for model type</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_contrasts">contrasts</code></td>
<td>
<p>a list of contrasts (see ?glmmTMB)</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_sparse">sparse</code></td>
<td>
<p>(logical) return sparse model matrix?</p>
</td></tr>
<tr><td><code id="getXReTrms_+3A_old_smooths">old_smooths</code></td>
<td>
<p>smooth information from a prior model fit (for prediction)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list composed of
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>design matrix for fixed effects</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>design matrix for random effects</p>
</td></tr>
<tr><td><code>reTrms</code></td>
<td>
<p>output from <code><a href="lme4.html#topic+mkReTrms">mkReTrms</a></code> from <span class="pkg">lme4</span>, possibly augmented with information about <code>mgcv</code>-style smooth terms</p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>splitform of the formula</p>
</td></tr>
<tr><td><code>aa</code></td>
<td>
<p>additional arguments, used to obtain rank</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>terms for the fixed effects</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>offset vector, or vector of zeros if offset not specified</p>
</td></tr>
<tr><td><code>reXterms</code></td>
<td>
<p>terms for the model matrix in each RE term</p>
</td></tr>
</table>

<hr>
<h2 id='glmmTMB'>Fit Models with TMB</h2><span id='topic+glmmTMB'></span>

<h3>Description</h3>

<p>Fit a generalized linear mixed model (GLMM) using Template Model Builder (TMB).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmTMB(
  formula,
  data = NULL,
  family = gaussian(),
  ziformula = ~0,
  dispformula = ~1,
  weights = NULL,
  offset = NULL,
  contrasts = NULL,
  na.action,
  se = TRUE,
  verbose = FALSE,
  doFit = TRUE,
  control = glmmTMBControl(),
  REML = FALSE,
  start = NULL,
  map = NULL,
  sparseX = NULL,
  priors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmTMB_+3A_formula">formula</code></td>
<td>
<p>combined fixed and random effects formula, following lme4 syntax.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_data">data</code></td>
<td>
<p>data frame (tibbles are OK) containing model variables. Not required, but strongly recommended; if <code>data</code> is not specified, downstream methods such as prediction with new data (<code>predict(fitted_model, newdata = ...)</code>) will fail. If it is necessary to call <code>glmmTMB</code> with model variables taken from the environment rather than from a data frame, specifying <code>data=NULL</code> will suppress the warning message.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_family">family</code></td>
<td>
<p>a family function, a character string naming a family function, or the result of a call to a family function (variance/link function) information. See <code><a href="stats.html#topic+family">family</a></code> for a generic discussion of families or <code><a href="#topic+family_glmmTMB">family_glmmTMB</a></code> for details of <code>glmmTMB</code>-specific families.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_ziformula">ziformula</code></td>
<td>
<p>a <em>one-sided</em> (i.e., no response variable) formula for zero-inflation combining fixed and random effects: the default <code>~0</code> specifies no zero-inflation. Specifying <code>~.</code> sets the zero-inflation formula identical to the right-hand side of <code>formula</code> (i.e., the conditional effects formula); terms can also be added or subtracted. <strong>When using <code>~.</code> as the zero-inflation formula in models where the conditional effects formula contains an offset term, the offset term will automatically be dropped</strong>. The zero-inflation model uses a logit link.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_dispformula">dispformula</code></td>
<td>
<p>a <em>one-sided</em> formula for dispersion containing only fixed effects: the default <code>~1</code> specifies the standard dispersion given any family. The argument is ignored for families that do not have a dispersion parameter. For an explanation of the dispersion parameter for each family, see <code><a href="#topic+sigma">sigma</a></code>. The dispersion model uses a log link. In Gaussian mixed models, <code>dispformula=~0</code> fixes the residual variance to be 0 (actually a small non-zero value), forcing variance into the random effects. The precise value can be controlled via <code>control=glmmTMBControl(zero_dispval=...)</code>; the default value is <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_weights">weights</code></td>
<td>
<p>weights, as in <code>glm</code>. Not automatically scaled to have sum 1.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_offset">offset</code></td>
<td>
<p>offset for conditional model (only).</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list, e.g., <code>list(fac1="contr.sum")</code>. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_na.action">na.action</code></td>
<td>
<p>a function that specifies how to handle observations
containing <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the 'factory fresh' value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables. Using <code>na.action = na.exclude</code>
will similarly drop observations with missing values while fitting the model,
but will fill in <code>NA</code> values for the predicted and residual
values for cases that were excluded during the fitting process
because of missingness.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_se">se</code></td>
<td>
<p>whether to return standard errors.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_verbose">verbose</code></td>
<td>
<p>whether progress indication should be printed to the console.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_dofit">doFit</code></td>
<td>
<p>whether to fit the full model, or (if FALSE) return the preprocessed data and parameter objects, without fitting the model.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_control">control</code></td>
<td>
<p>control parameters, see <code><a href="#topic+glmmTMBControl">glmmTMBControl</a></code>.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_reml">REML</code></td>
<td>
<p>whether to use REML estimation rather than maximum likelihood.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_start">start</code></td>
<td>
<p>starting values, expressed as a list with possible components <code>beta</code>, <code>betazi</code>, <code>betad</code> (fixed-effect parameters for conditional, zero-inflation, dispersion models); <code>b</code>, <code>bzi</code> (conditional modes for conditional and zero-inflation models); <code>theta</code>, <code>thetazi</code> (random-effect parameters, on the standard deviation/Cholesky scale, for conditional and z-i models); <code>psi</code> (extra family parameters, e.g., shape for Tweedie models).</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_map">map</code></td>
<td>
<p>a list specifying which parameter values should be fixed to a constant value rather than estimated. <code>map</code> should be a named list containing factors corresponding to a subset of the internal parameter names (see <code>start</code> parameter). Distinct factor values are fitted as separate parameter values, <code>NA</code> values are held fixed: e.g., <code>map=list(beta=factor(c(1,2,3,NA)))</code> would fit the first three fixed-effect parameters of the conditional model and fix the fourth parameter to its starting value. In general, users will probably want to use <code>start</code> to specify non-default starting values for fixed parameters. See <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code> for more details.</p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_sparsex">sparseX</code></td>
<td>
<p>a named logical vector containing (possibly) elements named &quot;cond&quot;, &quot;zi&quot;, &quot;disp&quot; to indicate whether fixed-effect model matrices for particular model components should be generated as sparse matrices, e.g. <code>c(cond=TRUE)</code>. Default is all <code>FALSE</code></p>
</td></tr>
<tr><td><code id="glmmTMB_+3A_priors">priors</code></td>
<td>
<p>a data frame of priors, in a similar format to that accepted by the <code>brms</code> package; see <code><a href="#topic+priors">priors</a></code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Binomial models with more than one trial (i.e., not binary/Bernoulli) can either be specified in the form <code>prob ~ ..., weights = N</code>, or in the more typical two-column matrix <code>cbind(successes,failures)~...</code> form.
</p>
</li>
<li><p> Behavior of <code>REML=TRUE</code> for Gaussian responses matches <code>lme4::lmer</code>. It may also be useful in some cases with non-Gaussian responses (Millar 2011). Simulations should be done first to verify.
</p>
</li>
<li><p> Because the <code><a href="stats.html#topic+df.residual">df.residual</a></code> method for <code>glmmTMB</code> currently counts the dispersion parameter, users should multiply this value by <code>sqrt(nobs(fit) / (1+df.residual(fit)))</code> when comparing with <code>lm</code>.
</p>
</li>
<li><p> Although models can be fitted without specifying a <code>data</code> argument, its use is strongly recommended; drawing model components from the global environment, or using <code>df$var</code> notation within model formulae, can lead to confusing (and sometimes hard-to-detect) errors.
</p>
</li>
<li><p> By default, vector-valued random effects are fitted with unstructured (general symmetric positive definite) variance-covariance matrices. Structured variance-covariance matrices can be specified in the form <code>struc(terms|group)</code>, where <code>struc</code> is one of
</p>

<ul>
<li> <p><code>diag</code> (diagonal, heterogeneous variance)
</p>
</li>
<li> <p><code>ar1</code> (autoregressive order-1, homogeneous variance)
</p>
</li>
<li> <p><code>cs</code> (compound symmetric, heterogeneous variance)
</p>
</li>
<li> <p><code>ou</code> (* Ornstein-Uhlenbeck, homogeneous variance)
</p>
</li>
<li> <p><code>exp</code> (* exponential autocorrelation)
</p>
</li>
<li> <p><code>gau</code> (* Gaussian autocorrelation)
</p>
</li>
<li> <p><code>mat</code> (* MatÃ©rn process correlation)
</p>
</li>
<li> <p><code>toep</code> (* Toeplitz)
</p>
</li>
<li> <p><code>rr</code> (reduced rank/factor-analytic model)
</p>
</li>
<li> <p><code>homdiag</code> (diagonal, homogeneous variance)
</p>
</li></ul>

<p>Structures marked with * are experimental/untested. See <code>vignette("covstruct", package = "glmmTMB")</code> for more information.
</p>
</li>
<li><p> For backward compatibility, the <code>family</code> argument can also be specified as a list comprising the name of the distribution and the link function (e.g. <code>list(family="binomial", link="logit")</code>). However, <strong>this alternative is now deprecated</strong>; it produces a warning and will be removed at some point in the future. Furthermore, certain capabilities such as Pearson residuals or predictions on the data scale will only be possible if components such as <code>variance</code> and <code>linkfun</code> are present, see <code><a href="stats.html#topic+family">family</a></code>.
</p>
</li>
<li><p> Smooths taken from the <code>mgcv</code> package can be included in <code>glmmTMB</code> formulas using <code>s</code>; these terms will appear as additional components in both the fixed and the random-effects terms. This functionality is <em>experimental</em> for now. We recommend using <code>REML=TRUE</code>. See <code><a href="mgcv.html#topic+s">s</a></code> for details of specifying smooths (and <code><a href="mgcv.html#topic+smooth2random">smooth2random</a></code> and the appendix of Wood (2004) for technical details).
</p>
</li></ul>



<h3>Note</h3>

<p>For more information about the <span class="pkg">glmmTMB</span> package, see Brooks et al. (2017) and the <code>vignette(package="glmmTMB")</code> collection. For the underlying <span class="pkg">TMB</span> package that performs the model estimation, see Kristensen et al. (2016).
</p>


<h3>References</h3>

<p>Brooks, M. E., Kristensen, K., van Benthem, K. J., Magnusson, A., Berg, C. W., Nielsen, A., Skaug, H. J., MÃ¤chler, M. and Bolker, B. M. (2017). glmmTMB balances speed and flexibility among packages for zero-inflated generalized linear mixed modeling. <em>The R Journal</em>, <b>9</b>(2), 378&ndash;400.
</p>
<p>Kristensen, K., Nielsen, A., Berg, C. W., Skaug, H. and Bell, B. (2016). TMB: Automatic differentiation and Laplace approximation. <em>Journal of Statistical Software</em>, <b>70</b>, 1&ndash;21.
</p>
<p>Millar, R. B. (2011). <em>Maximum Likelihood Estimation and Inference: With Examples in R, SAS and ADMB.</em> Wiley, New York.
Wood, S. N. (2004) Stable and Efficient Multiple Smoothing Parameter Estimation for Generalized Additive Models. <em>Journal of the American Statistical Association</em> <b>99</b>(467): 673â86. <a href="https://doi.org/10.1198/016214504000000980">doi:10.1198/016214504000000980</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
(m1 &lt;- glmmTMB(count ~ mined + (1|site),
  zi=~mined,
  family=poisson, data=Salamanders))
summary(m1)
##' ## Zero-inflated negative binomial model
(m2 &lt;- glmmTMB(count ~ spp + mined + (1|site),
  zi=~spp + mined,
  family=nbinom2, data=Salamanders))

## Hurdle Poisson model
(m3 &lt;- glmmTMB(count ~ spp + mined + (1|site),
  zi=~spp + mined,
  family=truncated_poisson, data=Salamanders))

## Binomial model
data(cbpp, package="lme4")
(bovine &lt;- glmmTMB(cbind(incidence, size-incidence) ~ period + (1|herd),
  family=binomial, data=cbpp))

## Dispersion model
sim1 &lt;- function(nfac=40, nt=100, facsd=0.1, tsd=0.15, mu=0, residsd=1)
{
  dat &lt;- expand.grid(fac=factor(letters[1:nfac]), t=1:nt)
  n &lt;- nrow(dat)
  dat$REfac &lt;- rnorm(nfac, sd=facsd)[dat$fac]
  dat$REt &lt;- rnorm(nt, sd=tsd)[dat$t]
  dat$x &lt;- rnorm(n, mean=mu, sd=residsd) + dat$REfac + dat$REt
  dat
}
set.seed(101)
d1 &lt;- sim1(mu=100, residsd=10)
d2 &lt;- sim1(mu=200, residsd=5)
d1$sd &lt;- "ten"
d2$sd &lt;- "five"
dat &lt;- rbind(d1, d2)
m0 &lt;- glmmTMB(x ~ sd + (1|t), dispformula=~sd, data=dat)
fixef(m0)$disp
c(log(5), log(10)-log(5)) # expected dispersion model coefficients


## Using 'map' to fix random-effects SD to 10
m1_map &lt;- update(m1, map=list(theta=factor(NA)),
                 start=list(theta=log(10)))
VarCorr(m1_map)

## smooth terms
data("Nile")
ndat &lt;- data.frame(time = c(time(Nile)), val = c(Nile))
sm1 &lt;- glmmTMB(val ~ s(time), data = ndat,
               REML = TRUE, start = list(theta = 5))
plot(val ~ time, data = ndat)
lines(ndat$time, predict(sm1))

</code></pre>

<hr>
<h2 id='glmmTMBControl'>Control parameters for glmmTMB optimization</h2><span id='topic+glmmTMBControl'></span>

<h3>Description</h3>

<p>Control parameters for glmmTMB optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmmTMBControl(
  optCtrl = NULL,
  optArgs = list(),
  optimizer = nlminb,
  profile = FALSE,
  collect = FALSE,
  parallel = getOption("glmmTMB.cores", 1L),
  eigval_check = TRUE,
  zerodisp_val = log(.Machine$double.eps)/4,
  start_method = list(method = NULL, jitter.sd = 0),
  rank_check = c("adjust", "warning", "stop", "skip"),
  conv_check = c("warning", "skip")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmmTMBControl_+3A_optctrl">optCtrl</code></td>
<td>
<p>Passed as argument <code>control</code> to optimizer. Default value (if default <code>nlminb</code> optimizer is used): <code>list(iter.max=300, eval.max=400)</code></p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_optargs">optArgs</code></td>
<td>
<p>additional arguments to be passed to optimizer function (e.g.: <code>list(method="BFGS")</code> when <code>optimizer=optim</code>)</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_optimizer">optimizer</code></td>
<td>
<p>Function to use in model fitting. See <code>Details</code> for required properties of this function.</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_profile">profile</code></td>
<td>
<p>(logical) Experimental option to improve speed and
robustness when a model has many fixed effects</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_collect">collect</code></td>
<td>
<p>(logical) Experimental option to improve speed by
recognizing duplicated observations.</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_parallel">parallel</code></td>
<td>
<p>(integer) Set number of OpenMP threads to evaluate
the negative log-likelihood in parallel. The default is to evaluate
models serially (i.e. single-threaded); users can set a default value
for an R session via <code>options(glmmTMB.cores=&lt;value&gt;)</code>. At present
reduced-rank models (i.e., a covariance structure using <code>rr(...)</code>)
cannot be fitted in parallel; the number of threads will be automatically
set to 1, with a warning if this overrides the user-specified value.</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_eigval_check">eigval_check</code></td>
<td>
<p>Check eigenvalues of variance-covariance matrix? (This test may be very slow for models with large numbers of fixed-effect parameters.)</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_zerodisp_val">zerodisp_val</code></td>
<td>
<p>value of the dispersion parameter when <code>dispformula=~0</code> is specified</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_start_method">start_method</code></td>
<td>
<p>(list) Options to initialize the starting values when fitting models with reduced-rank (<code>rr</code>) covariance structures; <code>jitter.sd</code> adds variation to the starting values of latent variables when <code>method = "res"</code>.</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_rank_check">rank_check</code></td>
<td>
<p>Check whether all parameters in fixed-effects models are identifiable? This test may be slow for models with large numbers of fixed-effect parameters, therefore default value is 'warning'. Alternatives include 'skip' (no check), 'stop' (throw an error), and 'adjust' (drop redundant columns from the fixed-effect model matrix).</p>
</td></tr>
<tr><td><code id="glmmTMBControl_+3A_conv_check">conv_check</code></td>
<td>
<p>Do basic checks of convergence (check for non-positive definite Hessian and non-zero convergence code from optimizer). Default is 'warning'; 'skip' ignores these tests (not recommended for general use!)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code><a href="#topic+glmmTMB">glmmTMB</a></code> uses the nonlinear optimizer
<code><a href="stats.html#topic+nlminb">nlminb</a></code> for parameter estimation. Users may sometimes
need to adjust optimizer settings in order to get models to
converge. For instance, the warning &lsquo;iteration limit reached
without convergence&rsquo; may be fixed by increasing the number of
iterations using (e.g.)
</p>
<p><code>glmmTMBControl(optCtrl=list(iter.max=1e3,eval.max=1e3))</code>.
</p>
<p>Setting <code>profile=TRUE</code> allows <code>glmmTMB</code> to use some special
properties of the optimization problem in order to speed up estimation
in cases with many fixed effects.
</p>
<p>Control parameters may depend on the model specification. The value
of the controls is evaluated inside an R object that is derived from
the output of the <code><a href="#topic+mkTMBStruc">mkTMBStruc</a></code> function. For example,
to specify that <code>profile</code> should be enabled if the model has
more than 5 fixed-effect parameters, specify
</p>
<p><code>profile=quote(length(parameters$beta)&gt;=5)</code>
</p>
<p>The <code>optimizer</code> argument can be any optimization (minimizing) function, provided that:
</p>

<ul>
<li><p> the first three arguments, in order, are the starting values, objective function, and gradient function;
</p>
</li>
<li><p> the function also takes a <code>control</code> argument;
</p>
</li>
<li><p> the function returns a list with elements (at least) <code>par</code>, <code>objective</code>, <code>convergence</code> (0 if convergence is successful) and <code>message</code>
(<code>glmmTMB</code> automatically handles output from <code>optim()</code>, by renaming the <code>value</code> component to <code>objective</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## fit with default (nlminb) and alternative (optim/BFGS) optimizer
m1 &lt;- glmmTMB(count~ mined, family=poisson, data=Salamanders)
m1B &lt;- update(m1, control=glmmTMBControl(optimizer=optim,
               optArgs=list(method="BFGS")))
## estimates are *nearly* identical:
all.equal(fixef(m1), fixef(m1B))
</code></pre>

<hr>
<h2 id='isLMM.glmmTMB'>support methods for parametric bootstrapping</h2><span id='topic+isLMM.glmmTMB'></span><span id='topic+refit.glmmTMB'></span>

<h3>Description</h3>

<p>see <code><a href="lme4.html#topic+refit">refit</a></code> and <code><a href="lme4.html#topic+isREML">isLMM</a></code> for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
isLMM(x, ...)

## S3 method for class 'glmmTMB'
refit(object, newresp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isLMM.glmmTMB_+3A_x">x</code></td>
<td>
<p>a fitted glmmTMB object</p>
</td></tr>
<tr><td><code id="isLMM.glmmTMB_+3A_...">...</code></td>
<td>
<p>additional arguments (for generic consistency; ignored)</p>
</td></tr>
<tr><td><code id="isLMM.glmmTMB_+3A_object">object</code></td>
<td>
<p>a fitted glmmTMB object</p>
</td></tr>
<tr><td><code id="isLMM.glmmTMB_+3A_newresp">newresp</code></td>
<td>
<p>a new response vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods are still somewhat experimental (check your results carefully!), but they should allow parametric bootstrapping.  They work by copying and replacing the original response column in the data frame passed to <code>glmmTMB</code>, so they will only work properly if (1) the data frame is still available in the environment and (2) the response variable is specified as a single symbol (e.g. <code>proportion</code> or a two-column matrix constructed on the fly with <code>cbind()</code>. Untested with binomial models where the response is specified as a factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("lme4")) {
## Not run: 
   fm1 &lt;- glmmTMB(count~mined+(1|spp),
                  ziformula=~mined,
                  data=Salamanders,
                  family=nbinom1)
   ## single parametric bootstrap step: refit with data simulated from original model
   fm1R &lt;- refit(fm1, simulate(fm1)[[1]])
   ## the bootMer function from lme4 provides a wrapper for doing multiple refits
   ##   with a specified summary function
   b1 &lt;- lme4::bootMer(fm1, FUN=function(x) fixef(x)$zi, nsim=20, .progress="txt")
   if (requireNamespace("boot")) {
      boot.ci(b1,type="perc")
    }
   ## can run in parallel: may need to set up cluster explicitly,
   ## use clusterEvalQ() to load packages on workers
   if (requireNamespace("parallel")) {
      cl &lt;- parallel::makeCluster(2)
      parallel::clusterEvalQ(cl, library("lme4"))
      parallel::clusterEvalQ(cl, library("glmmTMB"))
      b2 &lt;- lme4::bootMer(fm1, FUN = function(x) fixef(x)$cond,
              nsim = 10, ncpus = 2, cl = cl, parallel = "snow")
   }

## End(Not run)
}
</code></pre>

<hr>
<h2 id='mkTMBStruc'>Extract info from formulas, reTrms, etc., format for TMB</h2><span id='topic+mkTMBStruc'></span>

<h3>Description</h3>

<p>Extract info from formulas, reTrms, etc., format for TMB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkTMBStruc(
  formula,
  ziformula,
  dispformula,
  combForm,
  mf,
  fr,
  yobs,
  respCol,
  weights = NULL,
  contrasts,
  family,
  se = NULL,
  call = NULL,
  verbose = NULL,
  ziPredictCode = "corrected",
  doPredict = 0,
  whichPredict = integer(0),
  REML = FALSE,
  start = NULL,
  map = NULL,
  sparseX = NULL,
  control = glmmTMBControl(),
  old_smooths = NULL,
  priors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkTMBStruc_+3A_formula">formula</code></td>
<td>
<p>combined fixed and random effects formula, following lme4 syntax.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_ziformula">ziformula</code></td>
<td>
<p>a <em>one-sided</em> (i.e., no response variable) formula for zero-inflation combining fixed and random effects: the default <code>~0</code> specifies no zero-inflation. Specifying <code>~.</code> sets the zero-inflation formula identical to the right-hand side of <code>formula</code> (i.e., the conditional effects formula); terms can also be added or subtracted. <strong>When using <code>~.</code> as the zero-inflation formula in models where the conditional effects formula contains an offset term, the offset term will automatically be dropped</strong>. The zero-inflation model uses a logit link.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_dispformula">dispformula</code></td>
<td>
<p>a <em>one-sided</em> formula for dispersion containing only fixed effects: the default <code>~1</code> specifies the standard dispersion given any family. The argument is ignored for families that do not have a dispersion parameter. For an explanation of the dispersion parameter for each family, see <code><a href="#topic+sigma">sigma</a></code>. The dispersion model uses a log link. In Gaussian mixed models, <code>dispformula=~0</code> fixes the residual variance to be 0 (actually a small non-zero value), forcing variance into the random effects. The precise value can be controlled via <code>control=glmmTMBControl(zero_dispval=...)</code>; the default value is <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_combform">combForm</code></td>
<td>
<p>combined formula</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_mf">mf</code></td>
<td>
<p>call to model frame</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_fr">fr</code></td>
<td>
<p>model frame</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_yobs">yobs</code></td>
<td>
<p>observed y</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_respcol">respCol</code></td>
<td>
<p>response column</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_weights">weights</code></td>
<td>
<p>model weights (for binomial-type models, used as size/number of trials)</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list, e.g., <code>list(fac1="contr.sum")</code>. See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_family">family</code></td>
<td>
<p>family object</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_se">se</code></td>
<td>
<p>(logical) compute standard error?</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_call">call</code></td>
<td>
<p>original <code>glmmTMB</code> call</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_verbose">verbose</code></td>
<td>
<p>whether progress indication should be printed to the console.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_zipredictcode">ziPredictCode</code></td>
<td>
<p>zero-inflation code</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_dopredict">doPredict</code></td>
<td>
<p>flag to enable sds of predictions</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_whichpredict">whichPredict</code></td>
<td>
<p>which observations in model frame represent predictions</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_reml">REML</code></td>
<td>
<p>whether to use REML estimation rather than maximum likelihood.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_start">start</code></td>
<td>
<p>starting values, expressed as a list with possible components <code>beta</code>, <code>betazi</code>, <code>betad</code> (fixed-effect parameters for conditional, zero-inflation, dispersion models); <code>b</code>, <code>bzi</code> (conditional modes for conditional and zero-inflation models); <code>theta</code>, <code>thetazi</code> (random-effect parameters, on the standard deviation/Cholesky scale, for conditional and z-i models); <code>psi</code> (extra family parameters, e.g., shape for Tweedie models).</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_map">map</code></td>
<td>
<p>a list specifying which parameter values should be fixed to a constant value rather than estimated. <code>map</code> should be a named list containing factors corresponding to a subset of the internal parameter names (see <code>start</code> parameter). Distinct factor values are fitted as separate parameter values, <code>NA</code> values are held fixed: e.g., <code>map=list(beta=factor(c(1,2,3,NA)))</code> would fit the first three fixed-effect parameters of the conditional model and fix the fourth parameter to its starting value. In general, users will probably want to use <code>start</code> to specify non-default starting values for fixed parameters. See <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code> for more details.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_sparsex">sparseX</code></td>
<td>
<p>see <code><a href="#topic+glmmTMB">glmmTMB</a></code></p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_control">control</code></td>
<td>
<p>control parameters, see <code><a href="#topic+glmmTMBControl">glmmTMBControl</a></code>.</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_old_smooths">old_smooths</code></td>
<td>
<p>(optional) smooth components from a previous fit: used when constructing a new model structure for prediction
from an existing model. A list of smooths for each model component (only cond and zi at present); each smooth has sm and re elements</p>
</td></tr>
<tr><td><code id="mkTMBStruc_+3A_priors">priors</code></td>
<td>
<p>see <code><a href="#topic+priors">priors</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='nbinom2'>Family functions for glmmTMB</h2><span id='topic+nbinom2'></span><span id='topic+family_glmmTMB'></span><span id='topic+nbinom1'></span><span id='topic+compois'></span><span id='topic+truncated_compois'></span><span id='topic+genpois'></span><span id='topic+truncated_genpois'></span><span id='topic+truncated_poisson'></span><span id='topic+truncated_nbinom2'></span><span id='topic+truncated_nbinom1'></span><span id='topic+beta_family'></span><span id='topic+betabinomial'></span><span id='topic+tweedie'></span><span id='topic+lognormal'></span><span id='topic+ziGamma'></span><span id='topic+t_family'></span><span id='topic+ordbeta'></span>

<h3>Description</h3>

<p>Family functions for glmmTMB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbinom2(link = "log")

nbinom1(link = "log")

compois(link = "log")

truncated_compois(link = "log")

genpois(link = "log")

truncated_genpois(link = "log")

truncated_poisson(link = "log")

truncated_nbinom2(link = "log")

truncated_nbinom1(link = "log")

beta_family(link = "logit")

betabinomial(link = "logit")

tweedie(link = "log")

lognormal(link = "log")

ziGamma(link = "inverse")

t_family(link = "identity")

ordbeta(link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbinom2_+3A_link">link</code></td>
<td>
<p>(character) link function for the conditional mean (&quot;log&quot;, &quot;logit&quot;, &quot;probit&quot;, &quot;inverse&quot;, &quot;cloglog&quot;, &quot;identity&quot;, or &quot;sqrt&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If specified, the dispersion model uses a log link. Denoting the variance as <code class="reqn">V</code>, the dispersion parameter
as <code class="reqn">\phi=\exp(\eta)</code> (where <code class="reqn">\eta</code> is the linear predictor from the dispersion model),
and the predicted mean as <code class="reqn">\mu</code>:
</p>

<dl>
<dt>gaussian</dt><dd><p>(from base R): constant <code class="reqn">V=\phi^2</code></p>
</dd>
<dt>Gamma</dt><dd><p>(from base R) phi is the shape parameter. <code class="reqn">V=\mu\phi</code></p>
</dd>
<dt>ziGamma</dt><dd><p>a modified version of <code>Gamma</code> that skips checks for zero values, allowing it to be used to fit hurdle-Gamma models</p>
</dd>
<dt>nbinom2</dt><dd><p>Negative binomial distribution: quadratic parameterization (Hardin &amp; Hilbe 2007). <code class="reqn">V=\mu(1+\mu/\phi) = \mu+\mu^2/\phi</code>.</p>
</dd>
<dt>nbinom1</dt><dd><p>Negative binomial distribution: linear parameterization (Hardin &amp; Hilbe 2007). <code class="reqn">V=\mu(1+\phi)</code>. <em>Note</em> that the <code class="reqn">phi</code> parameter has opposite meanings in the <code>nbinom1</code> and <code>nbinom2</code> families. In <code>nbinom1</code> overdispersion increases with increasing <code>phi</code> (the Poisson limit is <code>phi=0</code>); in <code>nbinom2</code> overdispersion decreases with increasing <code>phi</code> (the Poisson limit is reached as <code>phi</code> goes to infinity).</p>
</dd>
<dt>truncated_nbinom2</dt><dd><p>Zero-truncated version of nbinom2: variance expression from Shonkwiler 2016. Simulation code (for this and the other truncated count distributions) is taken from C. Geyer's functions in the <code>aster</code> package; the algorithms are described in <a href="https://cran.r-project.org/package=aster/vignettes/trunc.pdf">this vignette</a>.</p>
</dd>
<dt>compois</dt><dd><p>Conway-Maxwell Poisson distribution: parameterized with the exact mean (Huang 2017), which differs from the parameterization used in the <span class="pkg">COMPoissonReg</span> package (Sellers &amp; Shmueli 2010, Sellers &amp; Lotze 2015). <code class="reqn">V=\mu\phi</code>.</p>
</dd>
<dt>genpois</dt><dd><p>Generalized Poisson distribution (Consul &amp; Famoye 1992). <code class="reqn">V=\mu\exp(\eta)</code>. (Note that Consul &amp; Famoye (1992) define <code class="reqn">\phi</code> differently.) Our implementation is taken from the <code>HMMpa</code> package, based on Joe and Zhu (2005) and implemented by Vitali Witowski.</p>
</dd>
<dt>beta</dt><dd><p>Beta distribution: parameterization of Ferrari and Cribari-Neto (2004)
and the <span class="pkg">betareg</span> package (Cribari-Neto and Zeileis 2010); <code class="reqn">V=\mu(1-\mu)/(\phi+1)</code></p>
</dd>
<dt>betabinomial</dt><dd><p>Beta-binomial distribution: parameterized according to Morris (1997). <code class="reqn">V=\mu(1-\mu)(n(\phi+n)/(\phi+1))</code></p>
</dd>
<dt>tweedie</dt><dd><p>Tweedie distribution: <code class="reqn">V=\phi\mu^power</code>. The power parameter is restricted to the interval <code class="reqn">1&lt;power&lt;2</code>. Code taken from the <code>tweedie</code> package, written by Peter Dunn.</p>
</dd>
<dt>t_family</dt><dd><p>Student-t distribution with adjustable scale and location parameters (also called a <a href="https://en.wikipedia.org/wiki/Pearson_distribution#The_Pearson_type_VII_distribution">Pearson type VII distribution</a>). The shape (degrees of freedom parameter) is fitted with a log link; it may be often be useful to fix the shape parameter using <code>start = list(psi = log(fixed_df)), map = list(psi = factor(NA))</code>.</p>
</dd>
<dt>ordbeta</dt><dd><p>Ordered beta regression from Kubinec (2022); fits continuous (e.g. proportion) data in the <em>closed</em> interval [0,1].</p>
</dd>
<dt>lognormal</dt><dd><p>Log-normal, parameterized by the mean and standard deviation <em>on the data scale</em></p>
</dd>
</dl>



<h3>Value</h3>

<p>returns a list with (at least) components
</p>
<table>
<tr><td><code>family</code></td>
<td>
<p>length-1 character vector giving the family name</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>length-1 character vector specifying the link function</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>a function of either 1 (mean) or 2 (mean and dispersion
parameter) arguments giving a value proportional to the
predicted variance (scaled by <code>sigma(.)</code>)
</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Consul PC &amp; Famoye F (1992). &quot;Generalized Poisson regression model.&quot; Communications in Statistics: Theory and Methods 21:89â109.
</p>
</li>
<li><p> Ferrari SLP, Cribari-Neto F (2004). &quot;Beta Regression for Modelling Rates and Proportions.&quot; <em>J. Appl. Stat.</em>  31(7), 799-815.
</p>
</li>
<li><p> Hardin JW &amp; Hilbe JM (2007). &quot;Generalized linear models and extensions.&quot; Stata Press.
</p>
</li>
<li><p> Huang A (2017). &quot;Mean-parametrized ConwayâMaxwellâPoisson regression models for dispersed counts.&quot; <em>Statistical Modelling</em> 17(6), 1-22.
</p>
</li>
<li><p> Joe H, Zhu R (2005). &quot;Generalized Poisson Distribution: The Property of Mixture of Poisson and Comparison with Negative Binomial Distribution.&quot; <em>Biometrical Journal</em> 47(2): 219â29. <a href="https://doi.org/10.1002/bimj.200410102">doi:10.1002/bimj.200410102</a>.
</p>
</li>
<li><p> Morris  W (1997). &quot;Disentangling Effects of Induced Plant Defenses and Food Quantity on Herbivores by Fitting Nonlinear Models.&quot; <em>American Naturalist</em> 150:299-327.
</p>
</li>
<li><p> Kubinec R (2022). &quot;Ordered Beta Regression: A Parsimonious, Well-Fitting Model for Continuous Data with Lower and Upper Bounds.&quot; <em>Political Analysis</em>. doi:10.1017/pan.2022.20.
</p>
</li>
<li><p> Sellers K &amp; Lotze T (2015). &quot;COMPoissonReg: Conway-Maxwell Poisson (COM-Poisson) Regression&quot;. R package version 0.3.5. https://CRAN.R-project.org/package=COMPoissonReg
</p>
</li>
<li><p> Sellers K &amp; Shmueli G (2010) &quot;A Flexible Regression Model for Count Data.&quot; <em>Annals of Applied Statistics</em> 4(2), 943â61. <a href="https://doi.org/10.1214/09-AOAS306">doi:10.1214/09-AOAS306</a>.
</p>
</li>
<li><p> Shonkwiler, J. S. (2016). &quot;Variance of the truncated negative binomial distribution.&quot; <em>Journal of Econometrics</em> 195(2), 209â210. <a href="https://doi.org/10.1016/j.jeconom.2016.09.002">doi:10.1016/j.jeconom.2016.09.002</a>.
</p>
</li></ul>


<hr>
<h2 id='numFactor'>Factor with numeric interpretable levels.</h2><span id='topic+numFactor'></span><span id='topic+parseNumLevels'></span>

<h3>Description</h3>

<p>Create a factor with numeric interpretable factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numFactor(x, ...)

parseNumLevels(levels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numFactor_+3A_x">x</code></td>
<td>
<p>Vector, matrix or data.frame that constitute the
coordinates.</p>
</td></tr>
<tr><td><code id="numFactor_+3A_...">...</code></td>
<td>
<p>Additional vectors, matrices or data.frames that
constitute the coordinates.</p>
</td></tr>
<tr><td><code id="numFactor_+3A_levels">levels</code></td>
<td>
<p>Character vector to parse into numeric values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some <code>glmmTMB</code> covariance structures require extra
information, such as temporal or spatial
coordinates. <code>numFactor</code> allows to associate such extra
information as part of a factor via the factor levels. The
original numeric coordinates are recoverable without loss of
precision using the function <code>parseNumLevels</code>.  Factor levels
are sorted coordinate wise from left to right: first coordinate is
fastest running.
</p>


<h3>Value</h3>

<p>Factor with specialized coding of levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1D example
numFactor(sample(1:5,20,TRUE))
## 2D example
coords &lt;- cbind( sample(1:5,20,TRUE), sample(1:5,20,TRUE) )
(f &lt;- numFactor(coords))
parseNumLevels(levels(f)) ## Sorted
## Used as part of a model.matrix
model.matrix( ~f )
## parseNumLevels( colnames(model.matrix( ~f )) )
## Error: 'Failed to parse numeric levels: (Intercept)'
parseNumLevels( colnames(model.matrix( ~ f-1 )) )
</code></pre>

<hr>
<h2 id='omp_check'>Check OpenMP status</h2><span id='topic+omp_check'></span>

<h3>Description</h3>

<p>Checks whether OpenMP has been successfully enabled for this
installation of the package. (Use the <code>parallel</code> argument
to <code><a href="#topic+glmmTMBControl">glmmTMBControl</a></code>, or set <code>options(glmmTMB.cores=[value])</code>,
to specify that computations should be done in parallel.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omp_check()
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> depending on availability of OpenMP
</p>


<h3>See Also</h3>

<p><code><a href="TMB.html#topic+benchmark">benchmark</a></code>, <code><a href="#topic+glmmTMBControl">glmmTMBControl</a></code>
</p>

<hr>
<h2 id='Owls'>Begging by Owl Nestlings</h2><span id='topic+Owls'></span><span id='topic+OwlModel'></span><span id='topic+OwlModel_nb1_bs'></span><span id='topic+OwlModel_nb1_bs_mcmc'></span>

<h3>Description</h3>

<p>Begging by owl nestlings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Owls)</code></pre>


<h3>Format</h3>

<p>The <code>Owls</code> data set is a data frame with
599 observations on the following variables:
</p>

<dl>
<dt><code>Nest</code></dt><dd><p>a factor describing individual nest locations</p>
</dd>
<dt><code>FoodTreatment</code></dt><dd><p>(factor) food treatment: <code>Deprived</code>
or <code>Satiated</code></p>
</dd>
<dt><code>SexParent</code></dt><dd><p>(factor) sex of provisioning parent: <code>Female</code> or <code>Male</code></p>
</dd>
<dt><code>ArrivalTime</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SiblingNegotiation</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>BroodSize</code></dt><dd><p>brood size</p>
</dd>
<dt><code>NegPerChick</code></dt><dd><p>number of negotations per chick</p>
</dd>
</dl>



<h3>Note</h3>

<p>Access to data kindly provided by Alain Zuur</p>


<h3>Source</h3>

<p>Roulin, A. and L. Bersier (2007)
Nestling barn owls beg more intensely in the presence of their mother
than in the presence of their father.
<em>Animal Behaviour</em> <b>74</b> 1099&ndash;1106.
<a href="https://doi.org/10.1016/j.anbehav.2007.01.027">doi:10.1016/j.anbehav.2007.01.027</a>;
<a href="http://www.highstat.com/Books/Book2/ZuurDataMixedModelling.zip">http://www.highstat.com/Books/Book2/ZuurDataMixedModelling.zip</a>
</p>


<h3>References</h3>

<p>Zuur, A. F., E. N. Ieno, N. J. Walker, A. A. Saveliev, and G. M. Smith (2009)
<em>Mixed Effects Models and Extensions in Ecology with R</em>; Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Owls, package = "glmmTMB")
require("lattice")
bwplot(reorder(Nest,NegPerChick) ~ NegPerChick | FoodTreatment:SexParent,
       data=Owls)
dotplot(reorder(Nest,NegPerChick) ~ NegPerChick| FoodTreatment:SexParent,
        data=Owls)
## Not run: 
## Fit negative binomial model with "constant" Zero Inflation :
owls_nb1 &lt;- glmmTMB(SiblingNegotiation ~ FoodTreatment*SexParent +
                                    (1|Nest)+offset(log(BroodSize)),
              family = nbinom1(), zi = ~1, data=Owls)
owls_nb1_bs &lt;- update(owls_nb1,
                      . ~ . - offset(log(BroodSize)) + log(BroodSize))
fixef(owls_nb1_bs)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.glmmTMB'>prediction</h2><span id='topic+predict.glmmTMB'></span>

<h3>Description</h3>

<p>prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
predict(
  object,
  newdata = NULL,
  newparams = NULL,
  se.fit = FALSE,
  cov.fit = FALSE,
  re.form = NULL,
  allow.new.levels = FALSE,
  type = c("link", "response", "conditional", "zprob", "zlink", "disp"),
  zitype = NULL,
  na.action = na.pass,
  fast = NULL,
  debug = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.glmmTMB_+3A_object">object</code></td>
<td>
<p>a <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_newdata">newdata</code></td>
<td>
<p>new data for prediction</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_newparams">newparams</code></td>
<td>
<p>new parameters for prediction</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_se.fit">se.fit</code></td>
<td>
<p>return the standard errors of the predicted values?</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_cov.fit">cov.fit</code></td>
<td>
<p>return the covariance matrix of the predicted values?</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_re.form">re.form</code></td>
<td>
<p><code>NULL</code> to specify individual-level predictions; <code>~0</code> or <code>NA</code> to specify population-level predictions (i.e., setting all random effects to zero)</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_allow.new.levels">allow.new.levels</code></td>
<td>
<p>allow previously unobserved levels in random-effects variables? see details.</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_type">type</code></td>
<td>
<p>Denoting <code class="reqn">mu</code> as the mean of the conditional distribution and
<code>p</code> as the zero-inflation probability,
the possible choices are:
</p>

<dl>
<dt>&quot;link&quot;</dt><dd><p>conditional mean on the scale of the link function,
or equivalently the linear predictor of the conditional model</p>
</dd>
<dt>&quot;response&quot;</dt><dd><p>expected value; this is <code class="reqn">mu*(1-p)</code> for zero-inflated models
and <code>mu</code> otherwise</p>
</dd>
<dt>&quot;conditional&quot;</dt><dd><p>mean of the conditional response; <code>mu</code> for all models
(i.e., synonymous with <code>"response"</code> in the absence of zero-inflation</p>
</dd>
<dt>&quot;zprob&quot;</dt><dd><p>the probability of a structural zero (returns 0 for non-zero-inflated models)</p>
</dd>
<dt>&quot;zlink&quot;</dt><dd><p>predicted zero-inflation probability on the scale of
the logit link function (returns <code>-Inf</code> for non-zero-inflated models)</p>
</dd>
<dt>&quot;disp&quot;</dt><dd><p>dispersion parameter however it is defined for that particular family as described in  <code><a href="#topic+sigma.glmmTMB">sigma.glmmTMB</a></code></p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_zitype">zitype</code></td>
<td>
<p>deprecated: formerly used to specify type of zero-inflation probability. Now synonymous with <code>type</code></p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_na.action">na.action</code></td>
<td>
<p>how to handle missing values in <code>newdata</code> (see <code><a href="stats.html#topic+na.action">na.action</a></code>);
the default (<code>na.pass</code>) is to predict <code>NA</code></p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_fast">fast</code></td>
<td>
<p>predict without expanding memory (default is TRUE if <code>newdata</code> and <code>newparams</code> are NULL and population-level prediction is not being done)</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_debug">debug</code></td>
<td>
<p>(logical) return the <code>TMBStruc</code> object that will be
used internally for debugging?</p>
</td></tr>
<tr><td><code id="predict.glmmTMB_+3A_...">...</code></td>
<td>
<p>unused - for method compatibility</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> To compute population-level predictions for a given grouping variable (i.e., setting all random effects for that grouping variable to zero), set the grouping variable values to <code>NA</code>. Finer-scale control of conditioning (e.g. allowing variation among groups in intercepts but not slopes when predicting from a random-slopes model) is not currently possible.
</p>
</li>
<li><p> Prediction of new random effect levels is possible as long as the model specification (fixed effects and parameters) is kept constant.
However, to ensure intentional usage, a warning is triggered if <code>allow.new.levels=FALSE</code> (the default).
</p>
</li>
<li><p> Prediction using &quot;data-dependent bases&quot; (variables whose scaling or transformation depends on the original data, e.g. <code><a href="stats.html#topic+poly">poly</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>, or <code><a href="stats.html#topic+poly">poly</a></code>) should work properly; however, users are advised to check results extra-carefully when using such variables. Models with different versions of the same data-dependent basis type in different components (e.g. <code>formula= y ~ poly(x,3), dispformula= ~poly(x,2)</code>) will probably <em>not</em> produce correct predictions.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(sleepstudy,package="lme4")
g0 &lt;- glmmTMB(Reaction~Days+(Days|Subject),sleepstudy)
predict(g0, sleepstudy)
## Predict new Subject
nd &lt;- sleepstudy[1,]
nd$Subject &lt;- "new"
predict(g0, newdata=nd, allow.new.levels=TRUE)
## population-level prediction
nd_pop &lt;- data.frame(Days=unique(sleepstudy$Days),
                     Subject=NA)
predict(g0, newdata=nd_pop)
</code></pre>

<hr>
<h2 id='print.VarCorr.glmmTMB'>Printing The Variance and Correlation Parameters of a <code>glmmTMB</code></h2><span id='topic+print.VarCorr.glmmTMB'></span>

<h3>Description</h3>

<p>Printing The Variance and Correlation Parameters of a <code>glmmTMB</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VarCorr.glmmTMB'
print(
  x,
  digits = max(3, getOption("digits") - 2),
  comp = "Std.Dev.",
  formatter = format,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.VarCorr.glmmTMB_+3A_x">x</code></td>
<td>
<p>a result of <code><a href="#topic+VarCorr">VarCorr</a>(&lt;glmmTMB&gt;)</code>.</p>
</td></tr>
<tr><td><code id="print.VarCorr.glmmTMB_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use.</p>
</td></tr>
<tr><td><code id="print.VarCorr.glmmTMB_+3A_comp">comp</code></td>
<td>
<p>a string specifying the component to format and print.</p>
</td></tr>
<tr><td><code id="print.VarCorr.glmmTMB_+3A_formatter">formatter</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code>.</p>
</td></tr>
<tr><td><code id="print.VarCorr.glmmTMB_+3A_...">...</code></td>
<td>
<p>optional further arguments, passed the next <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
</table>

<hr>
<h2 id='priors'>use of priors in glmmTMB</h2><span id='topic+priors'></span>

<h3>Description</h3>

<p>(EXPERIMENTAL/subject to change)
</p>


<h3>Details</h3>

<p><code>glmmTMB</code> can accept prior specifications, for doing maximum <em>a posteriori</em> (MAP) estimation (or Hamiltonian MC with the <code>tmbstan</code> package), or (outside of a Bayesian framework) for the purposes of regularizing parameter estimates  
</p>
<p>The <code>priors</code> argument to <code>glmmTMB</code> must (if not NULL) be a data frame with columns
</p>

<dl>
<dt><code>prior</code></dt><dd><p>character; the prior specification, e.g. &quot;normal(0,2)&quot;</p>
</dd>
<dt><code>class</code></dt><dd><p>the name of the underlying parameter vector on which to impose the prior (&quot;fixef&quot;, &quot;fixef_zi&quot;, &quot;fixef_disp&quot;, &quot;ranef&quot;, &quot;ranef_zi&quot;, &quot;psi&quot;)</p>
</dd>
<dt><code>coef</code></dt><dd><p>(optional) a string (if present) specifying the particular elements of the parameter vector to apply the prior to. <code>coef</code> should specify an integer parameter index, a column name from the fixed effect model matrix or a grouping variable for a random effect (the behaviour is currently undefined if there is more one than random effect term with the same grouping variable in a model ...); one can also append &quot;_cor&quot; or &quot;_sd&quot; to a random-effects <code>class</code> specification to denote the correlation parameters, or all of the standard deviation parameters, corresponding to a particular random effect term. If the <code>class</code> element is missing, or a particular element is blank, then all of the elements of the specified parameter vector use independent priors with the given specification. The exception is for fixed-effect parameter vectors, where the intercept (if present) is not included; the prior on the intercept must be set explicitly.</p>
</dd>
</dl>

<p>'The available prior distributions are:
</p>

<ul>
<li><p> &quot;normal&quot; (mean/sd parameterization)
</p>
</li>
<li><p> &quot;t&quot; (mean/sd/df)
</p>
</li>
<li><p> &quot;cauchy&quot; (location/scale)
</p>
</li>
<li><p> &quot;gamma&quot; (mean/shape); applied on the SD (<em>not</em> the log-SD) scale
</p>
</li>
<li><p> &quot;lkj&quot; (correlation) [WARNING, maybe buggy at present!]
</p>
</li></ul>

<p>The first three are typically used for fixed effect parameters; the fourth for standard deviation parameters; and the last for correlation structures. See the &quot;priors&quot; vignette for examples and further information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package = "lme4")
prior1 &lt;- data.frame(prior = c("normal(250,3)","t(0,3,3)","gamma(10,1)"),
                     class = c("fixef", "fixef", "ranef_sd"),
                     coef = c("(Intercept)", "Days", "Subject"))
g1 &lt;- glmmTMB(Reaction ~ 1 + Days + (1 + Days |Subject), sleepstudy)
update(g1, prior = prior1)
prior2 &lt;- data.frame(prior = c("t(0,3,3)","gamma(10,1)"),
                     class = c("fixef", "ranef_sd"),
                     coef = c("", "Subject"))
update(g1, prior = prior2) 
</code></pre>

<hr>
<h2 id='profile.glmmTMB'>Compute likelihood profiles for a fitted model</h2><span id='topic+profile.glmmTMB'></span><span id='topic+confint.profile.glmmTMB'></span>

<h3>Description</h3>

<p>Compute likelihood profiles for a fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
profile(
  fitted,
  parm = NULL,
  level_max = 0.99,
  npts = 8,
  stepfac = 1/4,
  stderr = NULL,
  trace = FALSE,
  parallel = c("no", "multicore", "snow"),
  ncpus = getOption("profile.ncpus", 1L),
  cl = NULL,
  ...
)

## S3 method for class 'profile.glmmTMB'
confint(object, parm = NULL, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.glmmTMB_+3A_fitted">fitted</code></td>
<td>
<p>a fitted <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_parm">parm</code></td>
<td>
<p>which parameters to profile, specified
</p>

<ul>
<li><p> by index (position)
</p>
</li>
<li><p> by name (matching the row/column names of <code>vcov(object,full=TRUE)</code>)
</p>
</li>
<li><p> as <code>"theta_"</code> (random-effects variance-covariance parameters) or <code>"beta_"</code> (conditional and zero-inflation parameters)
</p>
</li></ul>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_level_max">level_max</code></td>
<td>
<p>maximum confidence interval target for profile</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_npts">npts</code></td>
<td>
<p>target number of points in (each half of) the profile (<em>approximate</em>)</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_stepfac">stepfac</code></td>
<td>
<p>initial step factor (fraction of estimated standard deviation)</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_stderr">stderr</code></td>
<td>
<p>standard errors to use as a scaling factor when picking step
sizes to compute the profile; by default (if <code>stderr</code> is
<code>NULL</code>, or <code>NA</code> for a particular element),
uses the estimated (Wald) standard errors of the parameters</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_trace">trace</code></td>
<td>
<p>print tracing information? If <code>trace=FALSE</code> or 0,
no tracing; if <code>trace=1</code>, print names of parameters currently
being profiled; if <code>trace&gt;1</code>, turn on tracing for the
underlying <code><a href="TMB.html#topic+tmbprofile">tmbprofile</a></code> function</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_parallel">parallel</code></td>
<td>
<p>method (if any) for parallel computation</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_ncpus">ncpus</code></td>
<td>
<p>number of CPUs/cores to use for parallel computation</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_cl">cl</code></td>
<td>
<p>cluster to use for parallel computation</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="TMB.html#topic+tmbprofile">tmbprofile</a></code></p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_object">object</code></td>
<td>
<p>a fitted profile (<code>profile.glmmTMB</code>) object</p>
</td></tr>
<tr><td><code id="profile.glmmTMB_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits natural splines separately to the points from each half of the profile for each
specified parameter (i.e., values above and below the MLE), then finds the inverse functions
to estimate the endpoints of the confidence interval
</p>


<h3>Value</h3>

<p>An object of class <code>profile.glmmTMB</code>, which is also a
data frame, with columns <code>.par</code> (parameter being profiled),
<code>.focal</code> (value of focal parameter), value (negative log-likelihood).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m1 &lt;- glmmTMB(count~ mined + (1|site),
       zi=~mined, family=poisson, data=Salamanders)
salamander_prof1 &lt;- profile(m1, parallel="multicore",
                            ncpus=2, trace=1)
## testing
salamander_prof1 &lt;- profile(m1, trace=1,parm=1)
salamander_prof1M &lt;- profile(m1, trace=1,parm=1, npts = 4)
salamander_prof2 &lt;- profile(m1, parm="theta_")


## End(Not run)
salamander_prof1 &lt;- readRDS(system.file("example_files","salamander_prof1.rds",package="glmmTMB"))
if (require("ggplot2")) {
    ggplot(salamander_prof1,aes(.focal,sqrt(value))) +
        geom_point() + geom_line()+
        facet_wrap(~.par,scale="free_x")+
    geom_hline(yintercept=1.96,linetype=2)
}
salamander_prof1 &lt;- readRDS(system.file("example_files","salamander_prof1.rds",package="glmmTMB"))
confint(salamander_prof1)
confint(salamander_prof1,level=0.99)
</code></pre>

<hr>
<h2 id='ranef.glmmTMB'>Extract Random Effects</h2><span id='topic+ranef.glmmTMB'></span><span id='topic+ranef'></span><span id='topic+as.data.frame.ranef.glmmTMB'></span><span id='topic+coef.glmmTMB'></span>

<h3>Description</h3>

<p>Extract random effects from a fitted <code>glmmTMB</code> model, both
for the conditional model and zero inflation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
ranef(object, condVar = TRUE, ...)

## S3 method for class 'ranef.glmmTMB'
as.data.frame(x, ...)

## S3 method for class 'glmmTMB'
coef(object, condVar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.glmmTMB_+3A_object">object</code></td>
<td>
<p>a <code>glmmTMB</code> model.</p>
</td></tr>
<tr><td><code id="ranef.glmmTMB_+3A_condvar">condVar</code></td>
<td>
<p>whether to include conditional variances in result.</p>
</td></tr>
<tr><td><code id="ranef.glmmTMB_+3A_...">...</code></td>
<td>
<p>some methods for this generic function require additional
arguments (they are unused here and will trigger an error)</p>
</td></tr>
<tr><td><code id="ranef.glmmTMB_+3A_x">x</code></td>
<td>
<p>a <code>ranef.glmmTMB</code> object (i.e., the result of running <code>ranef</code> on a fitted <code>glmmTMB</code> model)</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>ranef</code>, an object of class <code>ranef.glmmTMB</code> with two components:
</p>

<dl>
<dt>cond</dt><dd><p>a list of data frames, containing random effects
for the conditional model.</p>
</dd>
<dt>zi</dt><dd><p>a list of data frames, containing random effects for
the zero inflation.</p>
</dd>
</dl>

<p>If <code>condVar=TRUE</code>, the individual list elements within the
<code>cond</code> and <code>zi</code> components (corresponding to individual
random effects terms) will have associated <code>condVar</code> attributes
giving the conditional variances of the random effects values.
These are in the form of three-dimensional arrays: see
<code><a href="lme4.html#topic+ranef.merMod">ranef.merMod</a></code> for details. The only difference between
the packages is that the attributes are called &lsquo;postVar&rsquo;
in <span class="pkg">lme4</span>, vs. &lsquo;condVar&rsquo; in <span class="pkg">glmmTMB</span>.
</p>
</li>
<li><p> For <code>coef.glmmTMB</code>: a similar list, but containing
the overall coefficient value for each level, i.e., the sum of
the fixed effect estimate and the random effect value for that
level. <em>Conditional variances are not yet available as
an option for</em> <code>coef.glmmTMB</code>.
</p>
</li>
<li><p> For <code>as.data.frame</code>: a data frame with components
</p>

<dl>
<dt>component</dt><dd><p>part of the model to which the random effects apply (conditional or zero-inflation)</p>
</dd>
<dt>grpvar</dt><dd><p>grouping variable</p>
</dd>
<dt>term</dt><dd><p>random-effects term (e.g., intercept or slope)</p>
</dd>
<dt>grp</dt><dd><p>group, or level of the grouping variable</p>
</dd>
<dt>condval</dt><dd><p>value of the conditional mode</p>
</dd>
<dt>condsd</dt><dd><p>conditional standard deviation</p>
</dd>
</dl>

</li></ul>



<h3>Note</h3>

<p>When a model has no zero inflation, the
<code>ranef</code> and <code>coef</code> print methods simplify the
structure shown, by default. To show the full list structure, use
<code>print(ranef(model),simplify=FALSE)</code> or the analogous
code for <code>coef</code>.
In all cases, the full list structure is used to access
the data frames, see example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixef.glmmTMB">fixef.glmmTMB</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("lme4")) {
   data(sleepstudy, package="lme4")
   model &lt;- glmmTMB(Reaction ~ Days + (1|Subject), sleepstudy)
   rr &lt;- ranef(model)
   print(rr, simplify=FALSE)
   ## extract Subject conditional modes for conditional model
   rr$cond$Subject
   as.data.frame(rr)
}
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+refit'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lme4</dt><dd><p><code><a href="lme4.html#topic+refit">refit</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reinstalling'>Reinstalling binary dependencies</h2><span id='topic+reinstalling'></span>

<h3>Description</h3>

<p>The <code>glmmTMB</code> package depends on several upstream packages, which it
uses in a way that depends heavily on their internal (binary) structure.
Sometimes, therefore, installing an update to one of these packages will
require that you re-install a <em>binary-compatible</em> version of <code>glmmTMB</code>,
i.e. a version that has been compiled with the updated version of the upstream
package.
</p>

<ul>
<li><p> If you have development tools (compilers etc.) installed, you
should be able to re-install a binary-compatible version of the package by running
<code>install.packages("glmmTMB", type="source")</code>. If you want to install
the development version of <code>glmmTMB</code> instead, you can use
<code>remotes::install_github("glmmTMB/glmmTMB/glmmTMB")</code>.
(On Windows, you can install development tools following the instructions at
<a href="https://cran.r-project.org/bin/windows/Rtools/">https://cran.r-project.org/bin/windows/Rtools/</a>; on MacOS, see
<a href="https://mac.r-project.org/tools/">https://mac.r-project.org/tools/</a>.)
</p>
</li>
<li><p> If you do <em>not</em> have development tools and can't/don't want to
install them (and so can't install packages with compiled code from source),
you have two choices:
</p>

<ul>
<li><p> revert the upstream package(s) to their previous binary version. For example, using the
<code>checkpoint</code> package:
</p>
<pre>
## load (installing if necessary) the checkpoint package
while (!require("checkpoint")) install.packages("checkpoint")
## retrieve build date of installed version of glmmTMB
bd &lt;- as.character(asDateBuilt(
      packageDescription("glmmTMB",fields="Built")))
oldrepo &lt;- getOption("repos")
use_mran_snapshot(bd) ## was setSnapshot() pre-checkpoint v1.0.0
install.packages("TMB")
options(repos=oldrepo) ## restore original repo
</pre>
<p>A similar recipe (substituting <code>Matrix</code> for <code>TMB</code> and <code>TMB</code> for <code>glmmTMB</code>)
can be used if you get warnings about an incompatibility between <code>TMB</code> and <code>Matrix</code>.
</p>
</li>
<li><p> hope that the glmmTMB maintainers have posted a binary
version of the package that works with your system; try installing it via
<code>install.packages("glmmTMB",repos="https://glmmTMB.github.io/glmmTMB/repos",type="binary")</code>
If this doesn't work, please file an issue (with full details about your
operating system and R version) asking the maintainers to build and
post an appropriate binary version of the package.
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='residuals.glmmTMB'>Compute residuals for a glmmTMB object</h2><span id='topic+residuals.glmmTMB'></span><span id='topic+deviance.glmmTMB'></span>

<h3>Description</h3>

<p>Compute residuals for a glmmTMB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
residuals(object, type = c("response", "pearson", "working", "deviance"), ...)

## S3 method for class 'glmmTMB'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.glmmTMB_+3A_object">object</code></td>
<td>
<p>a &ldquo;glmmTMB&rdquo; object</p>
</td></tr>
<tr><td><code id="residuals.glmmTMB_+3A_type">type</code></td>
<td>
<p>(character) residual type</p>
</td></tr>
<tr><td><code id="residuals.glmmTMB_+3A_...">...</code></td>
<td>
<p>for method compatibility (unused arguments will throw an error)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Residuals are computed based on predictions of type &quot;response&quot;,
i.e. equal to the conditional mean for non-zero-inflated models and to <code>mu*(1-p)</code>
for zero-inflated models
</p>
</li>
<li><p> Computing deviance residuals depends on the implementation of the <code>dev.resids</code>
function from the object's <code>family</code> component; at present this returns <code>NA</code> for most
&quot;exotic&quot; families (i.e. deviance residuals are currently only
implemented for families built into base R plus <code>nbinom1</code>, <code>nbinom2</code>). Deviance residuals are based on the conditional distributions only, i.e. ignoring zero-inflation components.
</p>
</li>
<li><p> Deviance is computed as the sum of squared deviance residuals, so is available only
for the families listed in the bullet point above. See <a href="lme4.html#topic+deviance.merMod">deviance.merMod</a> for more
details on the definition of the deviance for GLMMs.
</p>
</li></ul>


<hr>
<h2 id='RHSForm'>extract right-hand side of a formula</h2><span id='topic+RHSForm'></span>

<h3>Description</h3>

<p>extract right-hand side of a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RHSForm(form, as.form = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RHSForm_+3A_form">form</code></td>
<td>
<p>a formula object</p>
</td></tr>
<tr><td><code id="RHSForm_+3A_as.form">as.form</code></td>
<td>
<p>(logical) return a formula (TRUE) or as a call/symbolic object (FALSE) ?</p>
</td></tr>
</table>

<hr>
<h2 id='Salamanders'>Repeated counts of salamanders in streams</h2><span id='topic+Salamanders'></span>

<h3>Description</h3>

<p>A data set containing counts of salamanders with site covariates and sampling covariates. Each of 23 sites was sampled 4 times.
When using this data set, please cite Price et al. (2016) as well as the Dryad data package (Price et al. 2015). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Salamanders)</code></pre>


<h3>Format</h3>

<p>A data frame with 644 observations on the following 10 variables:
</p>

<dl>
<dt>site</dt><dd><p>name of a location where repeated samples were taken</p>
</dd>
<dt>mined</dt><dd><p>factor indicating whether the site was affected by mountain top removal coal mining</p>
</dd> 
<dt>cover</dt><dd><p>amount of cover objects in the stream (scaled)</p>
</dd> 
<dt>sample</dt><dd><p>repeated sample</p>
</dd>
<dt>DOP</dt><dd><p>Days since precipitation (scaled)</p>
</dd>
<dt>Wtemp</dt><dd><p>water temperature (scaled)</p>
</dd>
<dt>DOY</dt><dd><p>day of year (scaled)</p>
</dd>
<dt>spp</dt><dd><p>abbreviated species name, possibly also life stage</p>
</dd>
<dt>count</dt><dd><p>number of salamanders observed</p>
</dd>
</dl>



<h3>References</h3>

<p>Price SJ, Muncy BL, Bonner SJ, Drayer AN, Barton CD (2016) Effects of mountaintop removal mining and valley filling on the occupancy and abundance of stream salamanders. <em>Journal of Applied Ecology</em> <b>53</b> 459&ndash;468. <a href="https://doi.org/10.1111/1365-2664.12585">doi:10.1111/1365-2664.12585</a>
</p>
<p>Price SJ, Muncy BL, Bonner SJ, Drayer AN, Barton CD (2015) Data from: Effects of mountaintop removal mining and valley filling on the occupancy and abundance of stream salamanders. <em>Dryad Digital Repository</em>. <a href="https://doi.org/10.5061/dryad.5m8f6">doi:10.5061/dryad.5m8f6</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("glmmTMB")
data(Salamanders)

zipm3 = glmmTMB(count~spp * mined + (1|site), zi=~spp * mined, Salamanders, family="poisson")

</code></pre>

<hr>
<h2 id='sigma.glmmTMB'>Extract residual standard deviation or dispersion parameter</h2><span id='topic+sigma.glmmTMB'></span><span id='topic+sigma'></span>

<h3>Description</h3>

<p>For Gaussian models, <code>sigma</code> returns the value of the residual
standard deviation; for other families, it returns the
dispersion parameter, <em>however it is defined for that
particular family</em>. See details for each family below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.glmmTMB_+3A_object">object</code></td>
<td>
<p>a &ldquo;glmmTMB&rdquo; fitted object</p>
</td></tr>
<tr><td><code id="sigma.glmmTMB_+3A_...">...</code></td>
<td>
<p>(ignored; for method compatibility)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned varies by family:
</p>

<dl>
<dt>gaussian</dt><dd><p>returns the <em>maximum likelihood</em> estimate
of the standard deviation (i.e., smaller than the results of
<code>sigma(lm(...))</code> by a factor of (n-1)/n)</p>
</dd>
<dt>nbinom1</dt><dd><p>returns a dispersion parameter
(usually denoted <code class="reqn">\alpha</code> as in Hardin and Hilbe (2007)):
such that the variance equals <code class="reqn">\mu(1+\alpha)</code>.</p>
</dd>
<dt>nbinom2</dt><dd><p>returns a dispersion parameter
(usually denoted <code class="reqn">\theta</code> or <code class="reqn">k</code>); in contrast to
most other families, larger <code class="reqn">\theta</code> corresponds to a <em>lower</em>
variance which is <code class="reqn">\mu(1+\mu/\theta)</code>.</p>
</dd>
<dt>Gamma</dt><dd><p>Internally, glmmTMB fits Gamma responses by fitting a mean
and a shape parameter; sigma is estimated as (1/sqrt(shape)),
which will typically be close (but not identical to) that estimated
by <code>stats:::sigma.default</code>, which uses sqrt(deviance/df.residual)</p>
</dd>
<dt>beta</dt><dd><p>returns the value of <code class="reqn">\phi</code>,
where the conditional variance is <code class="reqn">\mu(1-\mu)/(1+\phi)</code>
(i.e., increasing <code class="reqn">\phi</code> decreases the variance.)
This parameterization follows Ferrari and Cribari-Neto (2004)
(and the <code>betareg</code> package):</p>
</dd>
<dt>betabinomial</dt><dd><p>This family uses the same parameterization (governing
the Beta distribution that underlies the binomial probabilities) as <code>beta</code>.</p>
</dd>
<dt>genpois</dt><dd><p>returns the index of dispersion <code class="reqn">\phi^2</code>,
where the variance is <code class="reqn">\mu\phi^2</code> (Consul &amp; Famoye 1992)</p>
</dd>
<dt>compois</dt><dd><p>returns the value of <code class="reqn">1/\nu</code>;
when <code class="reqn">\nu=1</code>, compois is equivalent to the Poisson distribution.
There is no closed form equation for the variance, but
it is approximately underdispersed when <code class="reqn">1/\nu &lt;1</code>
and approximately overdispersed when <code class="reqn">1/\nu &gt;1</code>.
In this implementation, <code class="reqn">\mu</code> is exactly equal to the mean (Huang 2017), which
differs from the COMPoissonReg package (Sellers &amp; Lotze 2015).</p>
</dd>
<dt>tweedie</dt><dd><p>returns the value of <code class="reqn">\phi</code>,
where the variance is <code class="reqn">\phi\mu^p</code>.
The value of <code class="reqn">p</code> can be extracted using <code>family_params</code>
</p>
</dd>
</dl>

<p>The most commonly used GLM families
(<code>binomial</code>, <code>poisson</code>) have fixed dispersion parameters which are
internally ignored.
</p>


<h3>References</h3>


<ul>
<li><p> Consul PC, and Famoye F (1992). &quot;Generalized Poisson regression model. Communications in Statistics: Theory and Methods&quot; 21:89â109.
</p>
</li>
<li><p> Ferrari SLP, Cribari-Neto F (2004). &quot;Beta Regression for Modelling Rates and Proportions.&quot; <em>J. Appl. Stat.</em>  31(7), 799-815.
</p>
</li>
<li><p> Hardin JW &amp; Hilbe JM (2007). &quot;Generalized linear models and extensions.&quot; Stata press.
</p>
</li>
<li><p> Huang A (2017). &quot;Mean-parametrized ConwayâMaxwellâPoisson regression models for dispersed counts. &quot; <em>Statistical Modelling</em> 17(6), 1-22.
</p>
</li>
<li><p> Sellers K &amp; Lotze T (2015). &quot;COMPoissonReg: Conway-Maxwell Poisson (COM-Poisson) Regression&quot;. R package version 0.3.5. https://CRAN.R-project.org/package=COMPoissonReg
</p>
</li></ul>


<hr>
<h2 id='simulate_new'>Simulate from covariate/metadata in the absence of a real data set (EXPERIMENTAL)</h2><span id='topic+simulate_new'></span>

<h3>Description</h3>

<p>See <code>vignette("sim", package = "glmmTMB")</code> for more details and examples,
and <code>vignette("covstruct", package = "glmmTMB")</code>
for more information on the parameterization of different covariance structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_new(
  object,
  nsim = 1,
  seed = NULL,
  family = gaussian,
  newdata,
  newparams,
  ...,
  show_pars = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_new_+3A_object">object</code></td>
<td>
<p>a <em>one-sided</em> model formula (e.g. <code>~ a + b + c</code>
(peculiar naming is for consistency with the generic function, which typically
takes a fitted model object)</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_seed">seed</code></td>
<td>
<p>random-number seed</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_family">family</code></td>
<td>
<p>a family function, a character string naming a family function, or the result of a call to a family function (variance/link function) information. See <code><a href="stats.html#topic+family">family</a></code> for a generic discussion of families or <code><a href="#topic+family_glmmTMB">family_glmmTMB</a></code> for details of <code>glmmTMB</code>-specific families.</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing all variables listed in the formula,
<em>including</em> the response variable (which needs to fall within
the domain of the conditional distribution, and should probably not
be all zeros, but whose value is otherwise irrelevant)</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_newparams">newparams</code></td>
<td>
<p>a list of parameters containing sub-vectors
(<code>beta</code>, <code>betazi</code>, <code>betad</code>, <code>theta</code>, etc.) to
be used in the model</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_...">...</code></td>
<td>
<p>other arguments to <code>glmmTMB</code> (e.g. <code>family</code>)</p>
</td></tr>
<tr><td><code id="simulate_new_+3A_show_pars">show_pars</code></td>
<td>
<p>(logical) print structure of parameter vector and stop without simulating?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## use Salamanders data for structure/covariates
simulate_new(~ mined + (1|site),
             zi = ~ mined,
             newdata = Salamanders, show_pars  = TRUE)
sim_count &lt;- simulate_new(~ mined + (1|site),
             newdata = Salamanders,
             zi = ~ mined,
             family = nbinom2,
             newparams = list(beta = c(2, 1),
                         betazi = c(-0.5, 0.5), ## logit-linear model for zi
                         betad = log(2), ## log(NB dispersion)
                         theta = log(1)) ## log(among-site SD)
)
head(sim_count[[1]])
</code></pre>

<hr>
<h2 id='simulate.glmmTMB'>Simulate from a glmmTMB fitted model</h2><span id='topic+simulate.glmmTMB'></span>

<h3>Description</h3>

<p>Simulate from a glmmTMB fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.glmmTMB_+3A_object">object</code></td>
<td>
<p>glmmTMB fitted model</p>
</td></tr>
<tr><td><code id="simulate.glmmTMB_+3A_nsim">nsim</code></td>
<td>
<p>number of response lists to simulate. Defaults to 1.</p>
</td></tr>
<tr><td><code id="simulate.glmmTMB_+3A_seed">seed</code></td>
<td>
<p>random number seed</p>
</td></tr>
<tr><td><code id="simulate.glmmTMB_+3A_...">...</code></td>
<td>
<p>extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Random effects are also simulated from their estimated distribution.
Currently, it is not possible to condition on estimated random effects.
</p>


<h3>Value</h3>

<p>returns a list of vectors. The list has length <code>nsim</code>.
Each simulated vector of observations is the same size as the vector of response variables in the original data set.
In the binomial family case each simulation is a two-column matrix with success/failure.
</p>

<hr>
<h2 id='splitForm'>Split formula containing special random effect terms</h2><span id='topic+splitForm'></span><span id='topic+noSpecials'></span>

<h3>Description</h3>

<p>Parse a formula into fixed formula and random effect terms,
treating 'special' terms (of the form foo(x|g[,m])) appropriately
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitForm(
  formula,
  defaultTerm = "us",
  allowFixedOnly = TRUE,
  allowNoSpecials = TRUE,
  debug = FALSE,
  specials = findReTrmClasses()
)

noSpecials(term, delete = TRUE, debug = FALSE, specials = findReTrmClasses())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitForm_+3A_formula">formula</code></td>
<td>
<p>a formula containing special random effect terms</p>
</td></tr>
<tr><td><code id="splitForm_+3A_defaultterm">defaultTerm</code></td>
<td>
<p>default type for non-special RE terms</p>
</td></tr>
<tr><td><code id="splitForm_+3A_allowfixedonly">allowFixedOnly</code></td>
<td>
<p>(logical) are formulas with no RE terms OK?</p>
</td></tr>
<tr><td><code id="splitForm_+3A_allownospecials">allowNoSpecials</code></td>
<td>
<p>(logical) are formulas with only standard RE terms OK?</p>
</td></tr>
<tr><td><code id="splitForm_+3A_debug">debug</code></td>
<td>
<p>debugging mode (print stuff)?</p>
</td></tr>
<tr><td><code id="splitForm_+3A_term">term</code></td>
<td>
<p>language object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taken from Steve Walker's lme4ord,
ultimately from the flexLambda branch of lme4
&lt;https://github.com/stevencarlislewalker/lme4ord/blob/master/R/formulaParsing.R&gt;.  Mostly for internal use.
</p>


<h3>Value</h3>

<p>a list containing elements <code>fixedFormula</code>;
<code>reTrmFormulas</code> list of <code>x | g</code> formulas for each term;
<code>reTrmAddArgs</code> list of function+additional arguments, i.e. <code>list()</code> (non-special), <code>foo()</code> (no additional arguments), <code>foo(addArgs)</code> (additional arguments); <code>reTrmClasses</code> (vector of special functions/classes, as character)
</p>


<h3>Author(s)</h3>

<p>Steve Walker
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splitForm(~x+y)                     ## no specials or RE
splitForm(~x+y+(f|g))               ## no specials
splitForm(~x+y+diag(f|g))           ## one special
splitForm(~x+y+(diag(f|g)))         ## 'hidden' special
splitForm(~x+y+(f|g)+cs(1|g))       ## combination
splitForm(~x+y+(1|f/g))             ## 'slash'; term
splitForm(~x+y+(1|f/g/h))             ## 'slash'; term
splitForm(~x+y+(1|(f/g)/h))             ## 'slash'; term
splitForm(~x+y+(f|g)+cs(1|g)+cs(a|b,stuff))  ## complex special
splitForm(~(((x+y))))               ## lots of parentheses
splitForm(~1+rr(f|g,n=2))
splitForm(~1+s(x, bs = "tp"))

noSpecials(y~1+us(1|f))
noSpecials(y~1+us(1|f),delete=FALSE)
noSpecials(y~us(1|f))
noSpecials(y~us(1|f), delete=FALSE)
noSpecials(y~us(1|f), debug=TRUE)
noSpecials(y~us+1)  ## should *not* delete unless head of a function
noSpecials(~us(1|f)+1)   ## should work on a one-sided formula!
noSpecials(~s(stuff) + a + b, specials = "s")
</code></pre>

<hr>
<h2 id='startParams'>Change starting parameters, either by residual method or by user input (start)</h2><span id='topic+startParams'></span>

<h3>Description</h3>

<p>Change starting parameters, either by residual method or by user input (start)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startParams(
  parameters,
  formula,
  ziformula,
  dispformula,
  fr,
  yobs,
  weights,
  size = NULL,
  Xd = NULL,
  XdS = NULL,
  family,
  condReStruc,
  start = NULL,
  sparseX = NULL,
  start_method = list(method = NULL, jitter.sd = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startParams_+3A_formula">formula</code></td>
<td>
<p>current formula, containing both fixed &amp; random effects</p>
</td></tr>
<tr><td><code id="startParams_+3A_ziformula">ziformula</code></td>
<td>
<p>a <em>one-sided</em> (i.e., no response variable) formula for zero-inflation combining fixed and random effects: the default <code>~0</code> specifies no zero-inflation. Specifying <code>~.</code> sets the zero-inflation formula identical to the right-hand side of <code>formula</code> (i.e., the conditional effects formula); terms can also be added or subtracted. <strong>When using <code>~.</code> as the zero-inflation formula in models where the conditional effects formula contains an offset term, the offset term will automatically be dropped</strong>. The zero-inflation model uses a logit link.</p>
</td></tr>
<tr><td><code id="startParams_+3A_dispformula">dispformula</code></td>
<td>
<p>a <em>one-sided</em> formula for dispersion containing only fixed effects: the default <code>~1</code> specifies the standard dispersion given any family. The argument is ignored for families that do not have a dispersion parameter. For an explanation of the dispersion parameter for each family, see <code><a href="#topic+sigma">sigma</a></code>. The dispersion model uses a log link. In Gaussian mixed models, <code>dispformula=~0</code> fixes the residual variance to be 0 (actually a small non-zero value), forcing variance into the random effects. The precise value can be controlled via <code>control=glmmTMBControl(zero_dispval=...)</code>; the default value is <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="startParams_+3A_fr">fr</code></td>
<td>
<p>model frame</p>
</td></tr>
<tr><td><code id="startParams_+3A_yobs">yobs</code></td>
<td>
<p>observed y</p>
</td></tr>
<tr><td><code id="startParams_+3A_weights">weights</code></td>
<td>
<p>model weights (for binomial-type models, used as size/number of trials)</p>
</td></tr>
<tr><td><code id="startParams_+3A_size">size</code></td>
<td>
<p>number of trials in binomial and betabinomial families</p>
</td></tr>
<tr><td><code id="startParams_+3A_family">family</code></td>
<td>
<p>family object</p>
</td></tr>
<tr><td><code id="startParams_+3A_start">start</code></td>
<td>
<p>starting values, expressed as a list with possible components <code>beta</code>, <code>betazi</code>, <code>betad</code> (fixed-effect parameters for conditional, zero-inflation, dispersion models); <code>b</code>, <code>bzi</code> (conditional modes for conditional and zero-inflation models); <code>theta</code>, <code>thetazi</code> (random-effect parameters, on the standard deviation/Cholesky scale, for conditional and z-i models); <code>psi</code> (extra family parameters, e.g., shape for Tweedie models).</p>
</td></tr>
<tr><td><code id="startParams_+3A_sparsex">sparseX</code></td>
<td>
<p>see <code><a href="#topic+glmmTMB">glmmTMB</a></code></p>
</td></tr>
<tr><td><code id="startParams_+3A_start_method">start_method</code></td>
<td>
<p>Options to initialise the starting values for rr parameters; jitter.sd adds variation to the starting values of latent variables when start = &quot;res&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='sub_specials'>Substitute safe chars (+) for specials (for use in <code>model.frame</code>)
(Generalized from <code>lme4</code>'s <code>subbars</code> function.)</h2><span id='topic+sub_specials'></span>

<h3>Description</h3>

<p>Substitute safe chars (+) for specials (for use in <code>model.frame</code>)
(Generalized from <code>lme4</code>'s <code>subbars</code> function.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_specials(
  term,
  specials = c("|", "||", "s"),
  keep_args = c(2L, 2L, NA_integer_)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_specials_+3A_term">term</code></td>
<td>
<p>formula or term in a formula</p>
</td></tr>
<tr><td><code id="sub_specials_+3A_specials">specials</code></td>
<td>
<p>names of specials to process</p>
</td></tr>
<tr><td><code id="sub_specials_+3A_keep_args">keep_args</code></td>
<td>
<p>number of arguments to retain (matching <code>specials</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a term or formula with specials replaced by <code>+</code> (and extra arguments dropped)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sub_specials( ~ s(a, k=4))
sub_specials( ~ (1|x) + (a + b || y) + s(a, k=4))
sub_specials(Reaction ~ s(Days) + (1 + Subject))
sub_specials(~ s(cos((y^2*3)/2), bs = "tp"))
</code></pre>

<hr>
<h2 id='terms.glmmTMB'>Methods for extracting developer-level information from <code>glmmTMB</code> models</h2><span id='topic+terms.glmmTMB'></span><span id='topic+model.matrix.glmmTMB'></span>

<h3>Description</h3>

<p>Methods for extracting developer-level information from <code>glmmTMB</code> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
terms(x, component = "cond", part = "fixed", ...)

## S3 method for class 'glmmTMB'
model.matrix(
  object,
  component = "cond",
  part = "fixed",
  include_rankdef = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.glmmTMB_+3A_x">x</code></td>
<td>
<p>a fitted <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="terms.glmmTMB_+3A_component">component</code></td>
<td>
<p>model component (&quot;cond&quot;, &quot;zi&quot;, or &quot;disp&quot;; not all models contain all components)</p>
</td></tr>
<tr><td><code id="terms.glmmTMB_+3A_part">part</code></td>
<td>
<p>whether to return results for the fixed or random effect part of the model (at present only <code>part="fixed"</code> is implemented for most methods)</p>
</td></tr>
<tr><td><code id="terms.glmmTMB_+3A_...">...</code></td>
<td>
<p>additional arguments (ignored or passed to <code><a href="stats.html#topic+model.frame">model.frame</a></code>)</p>
</td></tr>
<tr><td><code id="terms.glmmTMB_+3A_object">object</code></td>
<td>
<p>a fitted <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="terms.glmmTMB_+3A_include_rankdef">include_rankdef</code></td>
<td>
<p>include all columns of a rank-deficient model matrix?</p>
</td></tr>
</table>

<hr>
<h2 id='up2date'>conditionally update glmmTMB object fitted with an old TMB version</h2><span id='topic+up2date'></span><span id='topic+gt_load'></span>

<h3>Description</h3>

<p>conditionally update glmmTMB object fitted with an old TMB version
</p>
<p>Load data from system file, updating glmmTMB objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>up2date(oldfit, update_gauss_disp = FALSE)

gt_load(fn, verbose = FALSE, mustWork = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="up2date_+3A_oldfit">oldfit</code></td>
<td>
<p>a fitted glmmTMB object</p>
</td></tr>
<tr><td><code id="up2date_+3A_update_gauss_disp">update_gauss_disp</code></td>
<td>
<p>update <code>betad</code> from variance to SD parameterization?</p>
</td></tr>
<tr><td><code id="up2date_+3A_fn">fn</code></td>
<td>
<p>partial path to system file (e.g. test_data/foo.rda)</p>
</td></tr>
<tr><td><code id="up2date_+3A_verbose">verbose</code></td>
<td>
<p>print names of updated objects?</p>
</td></tr>
<tr><td><code id="up2date_+3A_mustwork">mustWork</code></td>
<td>
<p>fail if file not found?</p>
</td></tr>
<tr><td><code id="up2date_+3A_...">...</code></td>
<td>
<p>values passed through to <code>up2date</code></p>
</td></tr>
</table>

<hr>
<h2 id='VarCorr.glmmTMB'>Extract variance and correlation components</h2><span id='topic+VarCorr.glmmTMB'></span><span id='topic+VarCorr'></span>

<h3>Description</h3>

<p>Extract variance and correlation components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
VarCorr(x, sigma = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarCorr.glmmTMB_+3A_x">x</code></td>
<td>
<p>a fitted <code>glmmTMB</code> model</p>
</td></tr>
<tr><td><code id="VarCorr.glmmTMB_+3A_sigma">sigma</code></td>
<td>
<p>residual standard deviation (usually set automatically from internal information)</p>
</td></tr>
<tr><td><code id="VarCorr.glmmTMB_+3A_...">...</code></td>
<td>
<p>extra arguments (for consistency with generic method)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an unstructured variance-covariance matrix, the internal parameters
are structured as follows: the first n parameters are the log-standard-deviations,
while the remaining n(n-1)/2 parameters are the elements of the Cholesky factor
of the correlation matrix, filled in column-wise order
(see the <a href="http://kaskr.github.io/adcomp/classdensity_1_1UNSTRUCTURED__CORR__t.html">TMB documentation</a>
for further details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Comparing variance-covariance matrix with manual computation
data("sleepstudy",package="lme4")
fm4 &lt;- glmmTMB(Reaction ~ Days + (Days|Subject), sleepstudy)
VarCorr(fm4)[[c("cond","Subject")]]
## hand calculation
pars &lt;- getME(fm4,"theta")
## construct cholesky factor
L &lt;- diag(2)
L[lower.tri(L)] &lt;- pars[-(1:2)]
C &lt;- crossprod(L)
diag(C) &lt;- 1
sdvec &lt;- exp(pars[1:2])
(V &lt;- outer(sdvec,sdvec) * C)
</code></pre>

<hr>
<h2 id='vcov.glmmTMB'>Calculate Variance-Covariance Matrix for a Fitted glmmTMB model</h2><span id='topic+vcov.glmmTMB'></span>

<h3>Description</h3>

<p>Calculate Variance-Covariance Matrix for a Fitted glmmTMB model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
vcov(object, full = FALSE, include_nonest = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.glmmTMB_+3A_object">object</code></td>
<td>
<p>a &ldquo;glmmTMB&rdquo; fit</p>
</td></tr>
<tr><td><code id="vcov.glmmTMB_+3A_full">full</code></td>
<td>
<p>return a full variance-covariance matrix?</p>
</td></tr>
<tr><td><code id="vcov.glmmTMB_+3A_include_nonest">include_nonest</code></td>
<td>
<p>include variables that are mapped <em>or</em> dropped due to rank-deficiency? (these will be given variances and covariances of NA)</p>
</td></tr>
<tr><td><code id="vcov.glmmTMB_+3A_...">...</code></td>
<td>
<p>ignored, for method compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default (<code>full==FALSE</code>), a list of separate variance-covariance matrices for each model component (conditional, zero-inflation, dispersion).  If <code>full==TRUE</code>, a single square variance-covariance matrix for <em>all</em> top-level model parameters (conditional, dispersion, and variance-covariance parameters)
</p>

<hr>
<h2 id='weights.glmmTMB'>Extract weights from a glmmTMB object</h2><span id='topic+weights.glmmTMB'></span>

<h3>Description</h3>

<p>Extract weights from a glmmTMB object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glmmTMB'
weights(object, type = "prior", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.glmmTMB_+3A_object">object</code></td>
<td>
<p>a fitted <code>glmmTMB</code> object</p>
</td></tr>
<tr><td><code id="weights.glmmTMB_+3A_type">type</code></td>
<td>
<p>weights type</p>
</td></tr>
<tr><td><code id="weights.glmmTMB_+3A_...">...</code></td>
<td>
<p>additional arguments (not used; for methods compatibility)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At present only explicitly specified
<em>prior weights</em> (i.e., weights specified
in the <code>weights</code> argument) can be extracted from a fitted model.
</p>

<ul>
<li><p> Unlike other GLM-type models such as <code><a href="stats.html#topic+glm">glm</a></code> or
<code><a href="lme4.html#topic+glmer">glmer</a></code>, <code>weights()</code> does not currently return
the total number of trials when binomial responses are specified
as a two-column matrix.
</p>
</li>
<li><p> Since <code>glmmTMB</code> does not fit models via iteratively
weighted least squares, <code>working weights</code> (see <code><a href="stats.html#topic+glm">weights.glm</a></code>) are unavailable.
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
