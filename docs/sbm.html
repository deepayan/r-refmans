<!DOCTYPE html><html><head><title>Help for package sbm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sbm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sbm-package'><p>sbm: Stochastic Blockmodels</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#BipartiteSBM'><p>R6 class for Bipartite SBM</p></a></li>
<li><a href='#BipartiteSBM_fit'><p>R6 Class definition of an Bipartite SBM fit</p></a></li>
<li><a href='#coef.SBM'><p>Extract model coefficients</p></a></li>
<li><a href='#defineSBM'><p>Define a network</p></a></li>
<li><a href='#estimateBipartiteSBM'><p>Estimation of Bipartite SBMs</p></a></li>
<li><a href='#estimateMultipartiteSBM'><p>Estimation for multipartite SBM</p></a></li>
<li><a href='#estimateMultiplexSBM'><p>Estimation for Multiplex SBM</p></a></li>
<li><a href='#estimateSimpleSBM'><p>Estimation of Simple SBMs</p></a></li>
<li><a href='#fitted.SBM'><p>Extract model fitted values</p></a></li>
<li><a href='#fungusTreeNetwork'><p>fungus-tree interaction network</p></a></li>
<li><a href='#is_SBM'><p>Auxiliary function to check the given class of an object</p></a></li>
<li><a href='#multipartiteEcologicalNetwork'><p>Ecological multipartite interaction network</p></a></li>
<li><a href='#MultipartiteSBM'><p>R6 Class definition of a Multipartite SBM</p></a></li>
<li><a href='#MultipartiteSBM_fit'><p>R6 Class definition of a Multipartite SBM fit</p></a></li>
<li><a href='#MultiplexSBM_fit'><p>R6 Class definition of a Multiplex SBM fit</p></a></li>
<li><a href='#plot.SBM'><p>SBM Plot</p></a></li>
<li><a href='#plotAlluvial'><p>Plot an alluvial plot between  clusterings</p></a></li>
<li><a href='#plotMyMatrix'><p>Plot an adjacency or incidence Matrix</p></a></li>
<li><a href='#plotMyMultipartiteMatrix'><p>Plot the matrices corresponding to a Multipartite Network</p></a></li>
<li><a href='#plotMyMultiplexMatrix'><p>Plot the matrices corresponding to a Multiplex Network</p></a></li>
<li><a href='#predict.SBM'><p>Model Predictions</p></a></li>
<li><a href='#sampleBipartiteSBM'><p>Sampling of Bipartite SBMs</p></a></li>
<li><a href='#sampleMultipartiteSBM'><p>Sampling of Multipartite SBMs</p></a></li>
<li><a href='#sampleMultiplexSBM'><p>Sampling of Multiplex SBMs</p></a></li>
<li><a href='#sampleSimpleSBM'><p>Sampling of Simple SBMs</p></a></li>
<li><a href='#SBM'><p>R6 virtual class for SBM representation (mother class of SimpleSBM, BipartiteSBM, MultipartiteSBM)</p></a></li>
<li><a href='#SimpleSBM'><p>R6 class for Simple SBM</p></a></li>
<li><a href='#SimpleSBM_fit'><p>R6 Class definition of a Simple SBM fit</p></a></li>
<li><a href='#war'><p>War data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stochastic Blockmodels</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools and functions to adjust a variety of stochastic blockmodels (SBM). 
  Supports at the moment Simple, Bipartite, 'Multipartite' and Multiplex SBM (undirected or directed with Bernoulli,
  Poisson or Gaussian emission laws on the edges, and possibly covariate for Simple and Bipartite SBM).
  See Léger (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1602.07587">doi:10.48550/arXiv.1602.07587</a>&gt;, 'Barbillon et al.' (2020) &lt;<a href="https://doi.org/10.1111%2Frssa.12193">doi:10.1111/rssa.12193</a>&gt; and 
  'Bar-Hen et al.' (2020) &lt;<a href="https://doi.org/10.48550/arXiv.1807.10138">doi:10.48550/arXiv.1807.10138</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://grosssbm.github.io/sbm/">https://grosssbm.github.io/sbm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GrossSBM/sbm/issues">https://github.com/GrossSBM/sbm/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, spelling, knitr, rmarkdown, aricode, covr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>alluvial, magrittr, dplyr, purrr, blockmodels, R6, Rcpp,
igraph, ggplot2, GREMLINS, stringr, rlang, reshape2, prodlim</td>
</tr>
<tr>
<td>Collate:</td>
<td>'R6Class-SBM.R' 'R6Class-BipartiteSBM.R'
'R6Class-BipartiteSBM_fit.R' 'R6Class-MultipartiteSBM.R'
'R6Class-MultipartiteSBM_fit.R' 'R6Class-MultiplexSBM_fit.R'
'R6Class-SimpleSBM.R' 'R6Class-SimpleSBM_fit.R' 'RcppExports.R'
'defineSBM.R' 'estimate.R' 'fungusTreeNetwork.R'
'multipartiteEcologicalNetwork.R' 'plotAlluvial.R'
'plotMyMatrix.R' 'plotMyMultipartiteMatrix.R'
'plotMyMultiplexMatrix.R' 'sample.R' 'sbm-package.R'
'utils-pipe.R' 'utils.R' 'utils_plot.R' 'war.R'</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 08:58:52 UTC; jchiquet</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Chiquet <a href="https://orcid.org/0000-0002-3629-3429"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sophie Donnet <a href="https://orcid.org/0000-0003-4370-7316"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  großBM team [ctb],
  Pierre Barbillon <a href="https://orcid.org/0000-0002-7766-7693"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Chiquet &lt;julien.chiquet@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sbm-package'>sbm: Stochastic Blockmodels</h2><span id='topic+sbm'></span><span id='topic+sbm-package'></span>

<h3>Description</h3>

<p>A collection of tools and functions to adjust a variety of stochastic blockmodels (SBM). Supports at the moment Simple, Bipartite, 'Multipartite' and Multiplex SBM (undirected or directed with Bernoulli, Poisson or Gaussian emission laws on the edges, and possibly covariate for Simple and Bipartite SBM). See Léger (2016) <a href="https://arxiv.org/abs/1602.07587">arXiv:1602.07587</a>, 'Barbillon et al.' (2020) <a href="https://doi.org/10.1111/rssa.12193">doi:10.1111/rssa.12193</a> and 'Bar-Hen et al.' (2020) <a href="https://arxiv.org/abs/1807.10138">arXiv:1807.10138</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Julien Chiquet <a href="mailto:julien.chiquet@inrae.fr">julien.chiquet@inrae.fr</a> (<a href="https://orcid.org/0000-0002-3629-3429">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sophie Donnet <a href="mailto:sophie.donnet@inrae.fr">sophie.donnet@inrae.fr</a> (<a href="https://orcid.org/0000-0003-4370-7316">ORCID</a>)
</p>
</li>
<li><p> Pierre Barbillon <a href="mailto:pierre.barbillon@agroparistech.fr">pierre.barbillon@agroparistech.fr</a> (<a href="https://orcid.org/0000-0002-7766-7693">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> großBM team [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://grosssbm.github.io/sbm/">https://grosssbm.github.io/sbm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/GrossSBM/sbm/issues">https://github.com/GrossSBM/sbm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='BipartiteSBM'>R6 class for Bipartite SBM</h2><span id='topic+BipartiteSBM'></span>

<h3>Description</h3>

<p>R6 class for Bipartite SBM
</p>
<p>R6 class for Bipartite SBM
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code>BipartiteSBM</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>dimLabels</code></dt><dd><p>vector of two characters giving the label of each connected dimension (row, col)</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>list of two vectors of block proportions (aka prior probabilities of each block)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>parameters associated to the connectivity of the SBM, e.g. matrix of inter/inter block probabilities when model is Bernoulli</p>
</dd>
<dt><code>probMemberships</code></dt><dd><p>matrix of estimated probabilities for block memberships for all nodes</p>
</dd>
<dt><code>nbBlocks</code></dt><dd><p>vector of size 2: number of blocks (rows, columns)</p>
</dd>
<dt><code>nbDyads</code></dt><dd><p>number of dyads (potential edges in the network)</p>
</dd>
<dt><code>nbConnectParam</code></dt><dd><p>number of parameter used for the connectivity</p>
</dd>
<dt><code>memberships</code></dt><dd><p>list of size 2: vector of memberships in row, in column.</p>
</dd>
<dt><code>indMemberships</code></dt><dd><p>matrix for clustering memberships</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BipartiteSBM-new"><code>BipartiteSBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM-rMemberships"><code>BipartiteSBM$rMemberships()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM-rEdges"><code>BipartiteSBM$rEdges()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM-predict"><code>BipartiteSBM$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM-show"><code>BipartiteSBM$show()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM-plot"><code>BipartiteSBM$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM-clone"><code>BipartiteSBM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="print"><a href='../../sbm/html/SBM.html#method-SBM-print'><code>sbm::SBM$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-BipartiteSBM-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$new(
  model,
  nbNodes,
  blockProp,
  connectParam,
  dimLabels = c(row = "row", col = "col"),
  covarParam = numeric(length(covarList)),
  covarList = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>character describing the type of model</p>
</dd>
<dt><code>nbNodes</code></dt><dd><p>number of nodes in each dimension of the network</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>parameters for block proportions (vector of list of vectors)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>list of parameters for connectivity with a matrix of means 'mean' and an optional scalar for the variance 'var'. The dimensions of mu must match <code>blockProp</code> lengths</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>optional labels of each dimension (in row, in column)</p>
</dd>
<dt><code>covarParam</code></dt><dd><p>optional vector of covariates effect</p>
</dd>
<dt><code>covarList</code></dt><dd><p>optional list of covariates data</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM-rMemberships"></a>



<h4>Method <code>rMemberships()</code></h4>

<p>a method to sample new block memberships for the current SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$rMemberships(store = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>store</code></dt><dd><p>should the sampled blocks be stored (and overwrite the existing data)? Default to FALSE</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the sampled blocks
</p>


<hr>
<a id="method-BipartiteSBM-rEdges"></a>



<h4>Method <code>rEdges()</code></h4>

<p>a method to sample a network data (edges) for the current SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$rEdges(store = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>store</code></dt><dd><p>should the sampled edges be stored (and overwrite the existing data)? Default to FALSE</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the sampled network
</p>


<hr>
<a id="method-BipartiteSBM-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>prediction under the current parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$predict(covarList = self$covarList, theta_p0 = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covarList</code></dt><dd><p>a list of covariates. By default, we use the covariates with which the model was estimated.</p>
</dd>
<dt><code>theta_p0</code></dt><dd><p>double for thresholding...</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM-show"></a>



<h4>Method <code>show()</code></h4>

<p>show method
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$show(type = "Bipartite Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character used to specify the type of SBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>basic matrix plot method for BipartiteSBM object or mesoscopic plot
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$plot(
  type = c("data", "expected", "meso"),
  ordered = TRUE,
  plotOptions = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character for the type of plot: either 'data' (true connection), 'expected' (fitted connection) or 'meso' (mesoscopic view). Default to 'data'.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>logical: should the rows and columns be reordered according to the clustering? Default to <code>TRUE</code>.</p>
</dd>
<dt><code>plotOptions</code></dt><dd><p>list with the parameters for the plot. See help of the corresponding S3 method for details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a ggplot2 object for the <code>'data'</code> and <code>'expected'</code>, a list with the igraph object <code>g</code>, the <code>layout</code> and the <code>plotOptions</code> for the <code>'meso'</code>
</p>


<hr>
<a id="method-BipartiteSBM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='BipartiteSBM_fit'>R6 Class definition of an Bipartite SBM fit</h2><span id='topic+BipartiteSBM_fit'></span>

<h3>Description</h3>

<p>R6 Class definition of an Bipartite SBM fit
</p>
<p>R6 Class definition of an Bipartite SBM fit
</p>


<h3>Details</h3>

<p>This class is designed to give a representation and adjust an LBM fitted with blockmodels.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code><a href="#topic+BipartiteSBM">sbm::BipartiteSBM</a></code> -&gt; <code>BipartiteSBM_fit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loglik</code></dt><dd><p>double: approximation of the log-likelihood (variational lower bound) reached</p>
</dd>
<dt><code>ICL</code></dt><dd><p>double: value of the integrated classification log-likelihood</p>
</dd>
<dt><code>penalty</code></dt><dd><p>double, value of the penalty term in ICL</p>
</dd>
<dt><code>entropy</code></dt><dd><p>double, value of the entropy due to the clustering distribution</p>
</dd>
<dt><code>storedModels</code></dt><dd><p>data.frame of all models fitted (and stored) during the optimization</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BipartiteSBM_fit-new"><code>BipartiteSBM_fit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM_fit-optimize"><code>BipartiteSBM_fit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM_fit-setModel"><code>BipartiteSBM_fit$setModel()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM_fit-reorder"><code>BipartiteSBM_fit$reorder()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM_fit-show"><code>BipartiteSBM_fit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-BipartiteSBM_fit-clone"><code>BipartiteSBM_fit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="print"><a href='../../sbm/html/SBM.html#method-SBM-print'><code>sbm::SBM$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="BipartiteSBM" data-id="plot"><a href='../../sbm/html/BipartiteSBM.html#method-BipartiteSBM-plot'><code>sbm::BipartiteSBM$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="BipartiteSBM" data-id="predict"><a href='../../sbm/html/BipartiteSBM.html#method-BipartiteSBM-predict'><code>sbm::BipartiteSBM$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="BipartiteSBM" data-id="rEdges"><a href='../../sbm/html/BipartiteSBM.html#method-BipartiteSBM-rEdges'><code>sbm::BipartiteSBM$rEdges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="BipartiteSBM" data-id="rMemberships"><a href='../../sbm/html/BipartiteSBM.html#method-BipartiteSBM-rMemberships'><code>sbm::BipartiteSBM$rMemberships()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-BipartiteSBM_fit-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for a Bipartite SBM fit
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM_fit$new(
  incidenceMatrix,
  model,
  dimLabels = c(row = "row", col = "col"),
  covarList = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>incidenceMatrix</code></dt><dd><p>rectangular (weighted) matrix</p>
</dd>
<dt><code>model</code></dt><dd><p>character (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>)</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>labels of each dimension (in row, in columns)</p>
</dd>
<dt><code>covarList</code></dt><dd><p>and optional list of covariates, each of whom must have the same dimension as <code>incidenceMatrix</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM_fit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>function to perform optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM_fit$optimize(estimOptions = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>estimOptions</code></dt><dd><p>a list of parameters controlling the inference algorithm and model selection. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM_fit-setModel"></a>



<h4>Method <code>setModel()</code></h4>

<p>method to select a specific model among the ones fitted during the optimization.
Fields of the current SBM_fit will be updated accordingly.
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM_fit$setModel(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>integer, the index of the model to be selected (row number in storedModels)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM_fit-reorder"></a>



<h4>Method <code>reorder()</code></h4>

<p>permute group labels by order of decreasing probability
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM_fit$reorder()</pre></div>


<hr>
<a id="method-BipartiteSBM_fit-show"></a>



<h4>Method <code>show()</code></h4>

<p>show method
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM_fit$show(type = "Fit of a Bipartite Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character used to specify the type of SBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BipartiteSBM_fit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BipartiteSBM_fit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='coef.SBM'>Extract model coefficients</h2><span id='topic+coef.SBM'></span>

<h3>Description</h3>

<p>Extracts model coefficients from objects with class <code><a href="#topic+SBM">SBM</a></code> and children (<code><a href="#topic+SimpleSBM_fit">SimpleSBM_fit</a></code>,
<code><a href="#topic+BipartiteSBM_fit">BipartiteSBM_fit</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SBM'
coef(object, type = c("connectivity", "block", "covariates"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.SBM_+3A_object">object</code></td>
<td>
<p>an R6 object inheriting from class SBM_fit (like SimpleSBM_fit or BipartiteSBM_fit)</p>
</td></tr>
<tr><td><code id="coef.SBM_+3A_type">type</code></td>
<td>
<p>type of parameter that should be extracted. Either 'block' for </p>
<p style="text-align: center;"><code class="reqn">\pi</code>
</p>
<p>, 'connectivity' for </p>
<p style="text-align: center;"><code class="reqn">\theta</code>
</p>
<p>,
or &quot;covariates&quot; for </p>
<p style="text-align: center;"><code class="reqn">\beta</code>
</p>
<p>. Default is 'connectivity'.</p>
</td></tr>
<tr><td><code id="coef.SBM_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or list of parameters.
</p>

<hr>
<h2 id='defineSBM'>Define a network</h2><span id='topic+defineSBM'></span>

<h3>Description</h3>

<p>Define a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineSBM(
  netMat,
  model = "bernoulli",
  type = ifelse(ncol(netMat) == nrow(netMat), "simple", "bipartite"),
  directed = !isSymmetric(netMat),
  dimLabels = c(row = "row", col = "col"),
  covariates = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineSBM_+3A_netmat">netMat</code></td>
<td>
<p>a matrix describing the network: either an adjacency (square) or incidence matrix with possibly weighted entries.</p>
</td></tr>
<tr><td><code id="defineSBM_+3A_model">model</code></td>
<td>
<p>character describing the model for the relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, ...). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="defineSBM_+3A_type">type</code></td>
<td>
<p>Type of the matrix, choice between 'simple' and 'bipartite'</p>
</td></tr>
<tr><td><code id="defineSBM_+3A_directed">directed</code></td>
<td>
<p>logical: is the network directed or not? Only relevant when <code>type</code> is <code>'Simple'</code>. Default is <code>TRUE</code> if <code>netMat</code> is symmetric, <code>FALSE</code> otherwise</p>
</td></tr>
<tr><td><code id="defineSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional vector of labels for each dimension (in row, in column). Default value = c('row' = row,'col'= col)</p>
</td></tr>
<tr><td><code id="defineSBM_+3A_covariates">covariates</code></td>
<td>
<p>a list of matrices with same dimension as mat describing covariates at the edge level. No covariate per Default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object SimpleSBM or BipartiteSBM with the informations required to define a future multipartite network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rbinom(100,1,.2), 10, 10)
myNet &lt;- defineSBM(A, "poisson", "simple", TRUE, "Actor")
</code></pre>

<hr>
<h2 id='estimateBipartiteSBM'>Estimation of Bipartite SBMs</h2><span id='topic+estimateBipartiteSBM'></span>

<h3>Description</h3>

<p>This function performs variational inference of bipartite Stochastic Block Models, with various model
for the distribution of the edges:  Bernoulli, Poisson, or Gaussian models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateBipartiteSBM(
  netMat,
  model = "bernoulli",
  dimLabels = c(row = "row", col = "col"),
  covariates = list(),
  estimOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateBipartiteSBM_+3A_netmat">netMat</code></td>
<td>
<p>a matrix describing the network: either an adjacency (square) or incidence matrix with possibly weighted entries.</p>
</td></tr>
<tr><td><code id="estimateBipartiteSBM_+3A_model">model</code></td>
<td>
<p>character describing the model for the relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, ...). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="estimateBipartiteSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional vector of labels for each dimension (in row, in column)</p>
</td></tr>
<tr><td><code id="estimateBipartiteSBM_+3A_covariates">covariates</code></td>
<td>
<p>a list of matrices with same dimension as mat describing covariates at the edge level. No covariate per Default.</p>
</td></tr>
<tr><td><code id="estimateBipartiteSBM_+3A_estimoptions">estimOptions</code></td>
<td>
<p>a list of parameters controlling the inference algorithm and model selection. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>estimOptions</code> essentially tunes the optimization process and the variational EM algorithm, with the following parameters
</p>

<ul>
<li><p> &quot;nbCores integer for number of cores used. Default is 2
</p>
</li>
<li><p> &quot;verbosity&quot; integer for verbosity (0, 1). Default is 1
</p>
</li>
<li><p> &quot;plot&quot; boolean, should the ICL by dynamically plotted or not. Default is TRUE
</p>
</li>
<li><p> &quot;exploreFactor&quot; control the exploration of the number of groups
</p>
</li>
<li><p> &quot;exploreMin&quot; explore at least until exploreMin even if the exploration factor rule is achieved. Default 4. See the package blockmodels for details.
</p>
</li>
<li><p> &quot;exploreMax&quot; Stop exploration at exploreMax  even if the exploration factor rule is not achieved. Default Inf. See the package blockmodels for details.
</p>
</li>
<li><p> &quot;nbBlocksRange&quot; minimal and maximal number or blocks explored
</p>
</li>
<li><p> &quot;fast&quot; logical: should approximation be used for Bernoulli model with covariates. Default to <code>TRUE</code>
</p>
</li></ul>



<h3>Value</h3>

<p>a list with the estimated parameters. See details...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### =======================================
### BIPARTITE BINARY SBM (Bernoulli model)

## Graph parameters and Sampling
nbNodes &lt;- c(60, 80)
blockProp &lt;- list(c(.5, .5), c(1/3, 1/3, 1/3)) # group proportions
means &lt;- matrix(runif(6), 2, 3)  # connectivity matrix
# In Bernoulli SBM, parameters is a list with a
# matrix of means 'mean' which are probabilities of connection
connectParam &lt;- list(mean = means)
mySampler &lt;- sampleBipartiteSBM(nbNodes, blockProp, connectParam, model = 'bernoulli')

## Estimation
myBipartiteSBM &lt;- estimateBipartiteSBM(mySampler$networkData, estimOptions = list(plot = FALSE))
plot(myBipartiteSBM, 'expected')

### =======================================
### BIPARTITE POISSON SBM

## Graph parameters &amp; Sampling
nbNodes &lt;- c(60, 80)
blockProp &lt;- list(c(.5, .5), c(1/3, 1/3, 1/3)) # group proportions
means &lt;- matrix(rbinom(6, 30, 0.25), 2, 3)  # connectivity matrix
connectParam &lt;- list(mean = means)
mySampler &lt;- sampleBipartiteSBM(nbNodes, blockProp, connectParam, model = 'poisson')

## Estimation
myBipartiteSBM &lt;-
  estimateBipartiteSBM(mySampler$networkData, 'poisson', estimOptions = list(plot = FALSE))
plot(myBipartiteSBM, 'expected')

### =======================================
### BIPARTITE GAUSSIAN SBM
## Graph parameters &amp; sampling
nbNodes &lt;- c(60, 80)
blockProp &lt;- list(c(.5, .5), c(1/3, 1/3, 1/3)) # group proportions
means &lt;- 20 * matrix(runif(6), 2, 3)  # connectivity matrix
connectParam &lt;- list(mean = means, var = 1)
mySampler &lt;- sampleBipartiteSBM(nbNodes, blockProp, connectParam, model = 'gaussian')

## Estimation
myBipartiteSBM &lt;-
  estimateBipartiteSBM(mySampler$networkData, 'gaussian', estimOptions = list(plot = FALSE))
plot(myBipartiteSBM, 'expected')

</code></pre>

<hr>
<h2 id='estimateMultipartiteSBM'>Estimation for multipartite SBM</h2><span id='topic+estimateMultipartiteSBM'></span>

<h3>Description</h3>

<p>Estimation for multipartite SBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateMultipartiteSBM(listSBM, estimOptions = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateMultipartiteSBM_+3A_listsbm">listSBM</code></td>
<td>
<p>list of networks that were defined by the <code>defineSBM</code> function</p>
</td></tr>
<tr><td><code id="estimateMultipartiteSBM_+3A_estimoptions">estimOptions</code></td>
<td>
<p>options for the inference procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>estimOptions</code> essentially tunes the optimization process and the variational EM algorithm, with the following parameters
</p>

<ul>
<li><p> &quot;nbCores&quot; integer for number of cores used.  Default is 2
</p>
</li>
<li><p> &quot;verbosity&quot; integer for verbosity (0, 1). Default is 1
</p>
</li>
<li><p> &quot;nbBlocksRange&quot; List of length the number of functional groups, each element supplying the minimal and maximal number of blocks to be explored. The names of the list must be the names of the functional groups.  Default value is from 1 to 10)
</p>
</li>
<li><p> &quot;initBM&quot; Boolean. True if using simple and bipartite SBM as initialisations. Default value  = TRUE
</p>
</li>
<li><p> &quot;maxiterVEM&quot; Number of max. number of iterations in  the VEM. Default value  = 100
</p>
</li>
<li><p> &quot;maxiterVE&quot; Number of max. number of iterations in  the VE. Default value  = 100
</p>
</li></ul>



<h3>Value</h3>

<p>a MultipartiteSBM_fit object with the estimated parameters and the blocks in each Functional Group
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## About the Parts/Functional Groups (FG)
blockProp &lt;- list(c(0.16 ,0.40 ,0.44),c(0.3,0.7)) # prop of blocks in each FG
archiMultipartite &lt;-  rbind(c(1,2),c(2,2),c(1,1)) # architecture of the multipartite net.
nbNodes &lt;- c(60,50)
## About the connection matrices
directed &lt;- c(NA, TRUE, FALSE) # type of each network
model &lt;- c('gaussian','bernoulli','poisson')
C1 &lt;-
 list(mean = matrix(c(6.1, 8.9, 6.6, 9.8, 2.6, 1.0), 3, 2),
      var  = matrix(c(1.6, 1.6, 1.8, 1.7 ,2.3, 1.5),3, 2))
C2 &lt;- list(mean = matrix(c(0.7,1.0, 0.4, 0.6),2, 2))
m3 &lt;- matrix(c(2.5, 2.6 ,2.2 ,2.2, 2.7 ,3.0 ,3.6, 3.5, 3.3),3,3 )
C3 &lt;- list(mean = .5 * (m3 + t(m3)))
connectParam &lt;- list(C1, C2, C3)
## Graph Sampling
mySampleMSBM &lt;- sampleMultipartiteSBM(nbNodes, blockProp,
                                      archiMultipartite, connectParam, model,
                                      directed, dimLabels = c('A','B'), seed = 2)
listSBM &lt;- mySampleMSBM$listSBM
estimOptions &lt;- list(initBM = FALSE, nbCores  = 2)
myMSBM &lt;- estimateMultipartiteSBM(listSBM, estimOptions)
plot(myMSBM, type = "data")
plot(myMSBM, type = "expected")
plot(myMSBM, type = "meso")

## End(Not run)
</code></pre>

<hr>
<h2 id='estimateMultiplexSBM'>Estimation for Multiplex SBM</h2><span id='topic+estimateMultiplexSBM'></span>

<h3>Description</h3>

<p>Estimation for Multiplex SBM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateMultiplexSBM(listSBM, dependent = FALSE, estimOptions = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateMultiplexSBM_+3A_listsbm">listSBM</code></td>
<td>
<p>list of networks that were defined by the <code>defineSBM</code> function</p>
</td></tr>
<tr><td><code id="estimateMultiplexSBM_+3A_dependent">dependent</code></td>
<td>
<p>logical parameter indicating whether the networks in the multiplex structure are dependent beyond the latent variables,</p>
</td></tr>
<tr><td><code id="estimateMultiplexSBM_+3A_estimoptions">estimOptions</code></td>
<td>
<p>options for the inference procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>estimOptions</code> essentially tunes the optimization process and the variational EM algorithm, with the following parameters
</p>

<ul>
<li><p> &quot;nbCores&quot; integer for number of cores used.  Default is 2
</p>
</li>
<li><p> &quot;verbosity&quot; integer for verbosity (0, 1). Default is 1
</p>
</li>
<li><p> &quot;nbBlocksRange&quot; List of length the number of functional groups, each element supplying the minimal and maximal number of blocks to be explored. The names of the list must be the names of the functional groups.  Default value is from 1 to 10)
</p>
</li>
<li><p> &quot;initBM&quot; Boolean. True if using simple and bipartite SBM as initialisations. Default value  = TRUE
</p>
</li>
<li><p> &quot;maxiterVEM&quot; Number of max. number of iterations in  the VEM. Default value  = 100
</p>
</li>
<li><p> &quot;maxiterVE&quot; Number of max. number of iterations in  the VE. Default value  = 100
</p>
</li>
<li><p> &quot;plot&quot; boolean, should the ICL by dynamically plotted or not. Default is TRUE. For dependent networks
</p>
</li>
<li><p> &quot;exploreFactor&quot; control the exploration of the number of groups. For dependent networks
</p>
</li>
<li><p> &quot;exploreMin&quot; explore at least until exploreMin even if the exploration factor rule is achieved. Default 4. See the package blockmodels for details. For dependent networks
</p>
</li>
<li><p> &quot;exploreMax&quot; Stop exploration at exploreMax  even if the exploration factor rule is not achieved. Default Inf. See the package blockmodels for details. For dependent networks
</p>
</li>
<li><p> &quot;nbBlocksRange&quot; minimal and maximal number or blocks explored. For dependent networks
</p>
</li>
<li><p> &quot;fast&quot; logical: should approximation be used for Bernoulli model with covariates. Default to <code>TRUE</code>. For dependent networks
</p>
</li></ul>



<h3>Value</h3>

<p>a MultiplexSBM_fit object with the estimated parameters and the blocks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### =======================================
### MULTIPLEX SBM without dependence between layers
##
Nnodes &lt;- 40
blockProp &lt;- c(.4,.6)
nbLayers &lt;- 2
connectParam &lt;- list(list(mean=matrix(rbeta(4,.5,.5),2,2)),list(mean=matrix(rexp(4,.5),2,2)))
model &lt;- c("bernoulli","poisson")
type &lt;- "directed"
mySampleMultiplexSBM &lt;-
   sampleMultiplexSBM(
   nbNodes = Nnodes,
    blockProp = blockProp,
   nbLayers = nbLayers,
   connectParam = connectParam,
   model=model,
   type=type)
listSBM &lt;- mySampleMultiplexSBM$listSBM
estimOptions &lt;- list(initBM = FALSE, nbCores  = 2)
myMultiplexSBM &lt;- estimateMultiplexSBM(listSBM,estimOptions,dependent=FALSE)
### =======================================
### MULTIPLEX SBM Gaussian with dependence
##
Q &lt;- 3
nbLayers &lt;- 2
connectParam &lt;- list()
connectParam$mu &lt;- vector("list",nbLayers)
connectParam$mu[[1]] &lt;-  matrix(.1,Q,Q) + diag(1:Q)
connectParam$mu[[2]] &lt;- matrix(-2,Q,Q) + diag(rev(Q:1))
connectParam$Sigma &lt;- matrix(c(2,1,1,4),nbLayers,nbLayers)
model &lt;- rep("gaussian",2)
type &lt;- "directed"
Nnodes &lt;- 80
blockProp &lt;- c(.3,.3,.4)
mySampleMultiplexSBM &lt;-
  sampleMultiplexSBM(
     nbNodes = Nnodes,
     blockProp = blockProp,
     nbLayers = nbLayers,
     connectParam = connectParam,
     model=model,
     type="undirected",
     dependent=TRUE)
listSBM &lt;- mySampleMultiplexSBM$listSBM
myMultiplexSBM &lt;- estimateMultiplexSBM(listSBM,estimOptions,dependent=TRUE)
## MultiplexSBM Bernoulli with dependence
Q &lt;- 2
P00&lt;-matrix(runif(Q*Q),Q,Q)
P10&lt;-matrix(runif(Q*Q),Q,Q)
P01&lt;-matrix(runif(Q*Q),Q,Q)
P11&lt;-matrix(runif(Q*Q),Q,Q)
SumP&lt;-P00+P10+P01+P11
P00&lt;-P00/SumP
P01&lt;-P01/SumP
P10&lt;-P10/SumP
P11&lt;-P11/SumP
connectParam &lt;- list()
connectParam$prob00 &lt;- P00
connectParam$prob01 &lt;- P01
connectParam$prob10 &lt;- P10
connectParam$prob11 &lt;- P11
model &lt;- rep("bernoulli",2)
type &lt;- "directed"
nbLayers &lt;- 2
Nnodes &lt;- 40
blockProp &lt;- c(.6,.4)
mySampleMultiplexSBM &lt;-
   sampleMultiplexSBM(
     nbNodes = Nnodes,
     blockProp = blockProp,
     nbLayers = nbLayers,
     connectParam = connectParam,
     model=model,
     type=type,
     dependent=TRUE)
listSBM &lt;- mySampleMultiplexSBM$listSBM
myMultiplexSBM &lt;- estimateMultiplexSBM(listSBM,estimOptions,dependent=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='estimateSimpleSBM'>Estimation of Simple SBMs</h2><span id='topic+estimateSimpleSBM'></span>

<h3>Description</h3>

<p>This function performs variational inference of simple Stochastic Block Models, with various model
for the distribution of the edges:  Bernoulli, Poisson, or Gaussian models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateSimpleSBM(
  netMat,
  model = "bernoulli",
  directed = !isSymmetric(netMat),
  dimLabels = c("node"),
  covariates = list(),
  estimOptions = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateSimpleSBM_+3A_netmat">netMat</code></td>
<td>
<p>a matrix describing the network: either an adjacency (square) or incidence matrix with possibly weighted entries.</p>
</td></tr>
<tr><td><code id="estimateSimpleSBM_+3A_model">model</code></td>
<td>
<p>character describing the model for the relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, ...). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="estimateSimpleSBM_+3A_directed">directed</code></td>
<td>
<p>logical: is the network directed or not? Only relevant when <code>type</code> is <code>'Simple'</code>. Default is <code>TRUE</code> if <code>netMat</code> is symmetric, <code>FALSE</code> otherwise</p>
</td></tr>
<tr><td><code id="estimateSimpleSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional label for referring to the nodes</p>
</td></tr>
<tr><td><code id="estimateSimpleSBM_+3A_covariates">covariates</code></td>
<td>
<p>a list of matrices with same dimension as mat describing covariates at the edge level. No covariate per Default.</p>
</td></tr>
<tr><td><code id="estimateSimpleSBM_+3A_estimoptions">estimOptions</code></td>
<td>
<p>a list of parameters controlling the inference algorithm and model selection. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>estimOptions</code> essentially tunes the optimization process and the variational EM algorithm, with the following parameters
</p>

<ul>
<li><p> &quot;nbCores integer for number of cores used. Default is 2
</p>
</li>
<li><p> &quot;verbosity&quot; integer for verbosity (0, 1). Default is 1
</p>
</li>
<li><p> &quot;plot&quot; boolean, should the ICL by dynamically plotted or not. Default is TRUE
</p>
</li>
<li><p> &quot;exploreFactor&quot; control the exploration of the number of groups
</p>
</li>
<li><p> &quot;exploreMin&quot; explore at least until exploreMin even if the exploration factor rule is achieved. Default 4. See the package blockmodels for details.
</p>
</li>
<li><p> &quot;exploreMax&quot; Stop exploration at exploreMax  even if the exploration factor rule is not achieved. Default Inf. See the package blockmodels for details.
</p>
</li>
<li><p> &quot;nbBlocksRange&quot; minimal and maximal number or blocks explored
</p>
</li>
<li><p> &quot;fast&quot; logical: should approximation be used for Bernoulli model with covariates. Default to <code>TRUE</code>
</p>
</li></ul>



<h3>Value</h3>

<p>a list with the estimated parameters. See details...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### =======================================
### SIMPLE BINARY SBM (Bernoulli model)

## Graph parameters &amp; Sampling
nbNodes  &lt;- 90
blockProp &lt;- c(.5, .25, .25) # group proportions
means &lt;- diag(.4, 3) + 0.05  # connectivity matrix: affiliation network
connectParam &lt;- list(mean = means)
mySampler &lt;- sampleSimpleSBM(nbNodes, blockProp, connectParam)
adjacencyMatrix &lt;- mySampler$networkData

## Estimation
mySimpleSBM &lt;-
  estimateSimpleSBM(adjacencyMatrix, 'bernoulli', estimOptions = list(plot = FALSE))
plot(mySimpleSBM, 'data', ordered = FALSE)
plot(mySimpleSBM, 'data')
plot(mySimpleSBM, 'expected', ordered = FALSE)
plot(mySimpleSBM, 'expected')
plot(mySimpleSBM, 'meso')

### =======================================
### SIMPLE POISSON SBM

## Graph parameters &amp; Sampling
nbNodes  &lt;- 90
blockProp &lt;- c(.5, .25, .25) # group proportions
means &lt;- diag(15., 3) + 5    # connectivity matrix: affiliation network
connectParam &lt;- list(mean = means)
mySampler &lt;- sampleSimpleSBM(nbNodes, blockProp, list(mean = means), model = "poisson")
adjacencyMatrix &lt;- mySampler$networkData

## Estimation
mySimpleSBM &lt;- estimateSimpleSBM(adjacencyMatrix, 'poisson',
   estimOptions = list(plot = FALSE))
plot(mySimpleSBM, 'data', ordered = FALSE)
plot(mySimpleSBM, 'data')
plot(mySimpleSBM, 'expected', ordered = FALSE)
plot(mySimpleSBM, 'expected')

### =======================================
### SIMPLE GAUSSIAN SBM

## Graph parameters &amp; Sampling
nbNodes  &lt;- 90
blockProp &lt;- c(.5, .25, .25)      # group proportions
means &lt;- diag(15., 3) + 5 # connectivity matrix: affiliation network
connectParam &lt;- list(mean = means, var = 2)
mySampler &lt;- sampleSimpleSBM(nbNodes, blockProp, connectParam, model = "gaussian")

## Estimation
mySimpleSBM &lt;-
   estimateSimpleSBM(mySampler$networkData, 'gaussian', estimOptions = list(plot = FALSE))
plot(mySimpleSBM, 'data', ordered = FALSE)
plot(mySimpleSBM, 'data')
plot(mySimpleSBM, 'expected', ordered = FALSE)
plot(mySimpleSBM, 'expected')

</code></pre>

<hr>
<h2 id='fitted.SBM'>Extract model fitted values</h2><span id='topic+fitted.SBM'></span>

<h3>Description</h3>

<p>Extracts fitted values for object with class (<code><a href="#topic+SimpleSBM_fit">SimpleSBM_fit</a></code>,
<code><a href="#topic+BipartiteSBM_fit">BipartiteSBM_fit</a></code>) or <code><a href="#topic+MultipartiteSBM_fit">multipartitepartiteSBM_fit</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SBM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.SBM_+3A_object">object</code></td>
<td>
<p>an R6 object inheriting from SimpleSBM_fit,  BipartiteSBM_fit or MultipartiteSBM_fit</p>
</td></tr>
<tr><td><code id="fitted.SBM_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of expected fitted values for each dyad
</p>

<hr>
<h2 id='fungusTreeNetwork'>fungus-tree interaction network</h2><span id='topic+fungusTreeNetwork'></span>

<h3>Description</h3>

<p>This data set provides information about $154$ fungi sampled on $51$ tree species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fungusTreeNetwork
</code></pre>


<h3>Format</h3>

<p>A list with the following entries:
</p>

<ul>
<li><p> fungi_list list of the fungus species names
</p>
</li>
<li><p> tree_list list of the tree species names
</p>
</li>
<li><p> fungus_tree binary fungus-tree interactions
</p>
</li>
<li><p> tree_tree weighted tree-tree interactions (number of common fungal species two tree species host)
</p>
</li>
<li><p> covar_tree covariates associated to pairs of trees (namely genetic, taxonomic and geographic distances)
</p>
</li></ul>



<h3>Source</h3>

<p>Vacher, Corinne, Dominique Piou, and Marie-Laure Desprez-Loustau. &quot;Architecture of an antagonistic tree/fungus network: the asymmetric influence of past evolutionary history.&quot; PloS one 3.3 (2008): e1740.
</p>

<hr>
<h2 id='is_SBM'>Auxiliary function to check the given class of an object</h2><span id='topic+is_SBM'></span>

<h3>Description</h3>

<p>Auxiliary function to check the given class of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_SBM(Robject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_SBM_+3A_robject">Robject</code></td>
<td>
<p>an R6 object inheriting from class SBM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='multipartiteEcologicalNetwork'>Ecological multipartite interaction network</h2><span id='topic+multipartiteEcologicalNetwork'></span>

<h3>Description</h3>

<p>Multipartite network of mutualistic interactions between   plants and pollinators, plants and birds  and plants and ants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipartiteEcologicalNetwork
</code></pre>


<h3>Format</h3>

<p>A list a 3 binary  incidence matrices
</p>

<ul>
<li><p> Inc_plant_ant Interactions between plants (rows) and ants (cols). Matrix with 141 rows and 30 columns
</p>
</li>
<li><p> Inc_plant_bird Interactions between plants (rows) and birds (cols). Matrix with141 rows and 46 columns
</p>
</li>
<li><p> Inc_plant_flovis Interactions between plants (rows) and pollinators (cols). Matrix with 141 rows and 173 columns
</p>
</li></ul>



<h3>Source</h3>

<p>Dataset  compiled and conducted at Centro de Investigaciones Costeras La Mancha (CICOLMA), located on the central
coast of the Gulf of Mexico, Veracruz, Mexico. see <a href="https://doi.org/10.1098/rspb.2016.1564">doi:10.1098/rspb.2016.1564</a> and
<a href="https://github.com/lucaspdmedeiros/multi-network_core_removal/tree/master/data">https://github.com/lucaspdmedeiros/multi-network_core_removal/tree/master/data</a>
</p>

<hr>
<h2 id='MultipartiteSBM'>R6 Class definition of a Multipartite SBM</h2><span id='topic+MultipartiteSBM'></span>

<h3>Description</h3>

<p>R6 Class definition of a Multipartite SBM
</p>
<p>R6 Class definition of a Multipartite SBM
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code>MultipartiteSBM</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>dimLabels</code></dt><dd><p>vector of characters giving the label of each connected dimension</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>list of two vectors of block proportions (aka prior probabilities of each block)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>parameters associated to the connectivity of the SBM, e.g. matrix of inter/inter block probabilities when model is Bernoulli</p>
</dd>
<dt><code>probMemberships</code></dt><dd><p>matrix of estimated probabilities for block memberships for all nodes</p>
</dd>
<dt><code>nbBlocks</code></dt><dd><p>: vector with the number of blocks in each FG</p>
</dd>
<dt><code>nbConnectParam</code></dt><dd><p>number of parameter used for the connectivity</p>
</dd>
<dt><code>architecture</code></dt><dd><p>organization of the multipartite network</p>
</dd>
<dt><code>nbNetworks</code></dt><dd><p>number of networks in the multipartite network</p>
</dd>
<dt><code>memberships</code></dt><dd><p>list of size 2: vector of memberships in all parts of the network</p>
</dd>
<dt><code>indMemberships</code></dt><dd><p>matrix for clustering memberships</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MultipartiteSBM-new"><code>MultipartiteSBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM-show"><code>MultipartiteSBM$show()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM-print"><code>MultipartiteSBM$print()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM-plot"><code>MultipartiteSBM$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM-clone"><code>MultipartiteSBM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MultipartiteSBM-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for Multipartite SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM$new(
  model = character(0),
  architecture = matrix(NA, 0, 2),
  directed = logical(0),
  nbNodes = numeric(0),
  dimLabels = character(0),
  blockProp = list(),
  connectParam = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>character describing the type of model</p>
</dd>
<dt><code>architecture</code></dt><dd><p>a 2-column matrix describing interactions between the networks</p>
</dd>
<dt><code>directed</code></dt><dd><p>vector of logical: are the network directed or not?</p>
</dd>
<dt><code>nbNodes</code></dt><dd><p>number of nodes in each dimension/part of the network</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>labels of each par of the network</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>parameters for block proportions (vector of list of vectors)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>parameters of connectivity (vector of list of vectors)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM-show"></a>



<h4>Method <code>show()</code></h4>

<p>print method
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM$show(type = "Multipartite Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character to tune the displayed name</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM$print()</pre></div>


<hr>
<a id="method-MultipartiteSBM-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>plot Multipartite Network
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM$plot(
  type = c("data", "expected", "meso"),
  ordered = TRUE,
  plotOptions = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character for the type of plot: either 'data' (true connection), 'expected' (fitted connection) or 'meso' (mesoscopic view). Default to 'data'.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>TRUE is the matrices are plotted after reorganization with the blocks. Default value = TRUE</p>
</dd>
<dt><code>plotOptions</code></dt><dd><p>list of plot options for the mesoscopic view or matrix view</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='MultipartiteSBM_fit'>R6 Class definition of a Multipartite SBM fit</h2><span id='topic+MultipartiteSBM_fit'></span>

<h3>Description</h3>

<p>R6 Class definition of a Multipartite SBM fit
</p>
<p>R6 Class definition of a Multipartite SBM fit
</p>


<h3>Details</h3>

<p>This class is designed to give a representation and adjust a Multipartite SBM fitted with GREMLIN.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code><a href="#topic+MultipartiteSBM">sbm::MultipartiteSBM</a></code> -&gt; <code>MultipartiteSBM_fit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loglik</code></dt><dd><p>double: approximation of the log-likelihood (variational lower bound) reached</p>
</dd>
<dt><code>ICL</code></dt><dd><p>double: value of the integrated classification log-likelihood</p>
</dd>
<dt><code>storedModels</code></dt><dd><p>data.frame of all models fitted (and stored) during the optimization</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MultipartiteSBM_fit-new"><code>MultipartiteSBM_fit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM_fit-optimize"><code>MultipartiteSBM_fit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM_fit-predict"><code>MultipartiteSBM_fit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM_fit-setModel"><code>MultipartiteSBM_fit$setModel()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM_fit-show"><code>MultipartiteSBM_fit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-MultipartiteSBM_fit-clone"><code>MultipartiteSBM_fit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="MultipartiteSBM" data-id="plot"><a href='../../sbm/html/MultipartiteSBM.html#method-MultipartiteSBM-plot'><code>sbm::MultipartiteSBM$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="MultipartiteSBM" data-id="print"><a href='../../sbm/html/MultipartiteSBM.html#method-MultipartiteSBM-print'><code>sbm::MultipartiteSBM$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MultipartiteSBM_fit-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for Multipartite SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM_fit$new(netList)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>netList</code></dt><dd><p>list of SBM objects</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM_fit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>estimation of multipartiteSBM via GREMLINS
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM_fit$optimize(estimOptions)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>estimOptions</code></dt><dd><p>options for MultipartiteBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM_fit-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>prediction under the currently estimated model
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM_fit$predict()</pre></div>



<h5>Returns</h5>

<p>a list of matrices matrix of expected values for each dyad
</p>


<hr>
<a id="method-MultipartiteSBM_fit-setModel"></a>



<h4>Method <code>setModel()</code></h4>

<p>method to select a specific model among the ones fitted during the optimization.
Fields of the current MultipartiteSBM_fit will be updated accordingly.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM_fit$setModel(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>integer, the index of the model to be selected (row number in storedModels)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM_fit-show"></a>



<h4>Method <code>show()</code></h4>

<p>show method
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM_fit$show(type = "Fit of a Multipartite Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character used to specify the type of SBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultipartiteSBM_fit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultipartiteSBM_fit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='MultiplexSBM_fit'>R6 Class definition of a Multiplex SBM fit</h2><span id='topic+MultiplexSBM_fit'></span>

<h3>Description</h3>

<p>R6 Class definition of a Multiplex SBM fit
</p>
<p>R6 Class definition of a Multiplex SBM fit
</p>


<h3>Details</h3>

<p>This class is designed to give a representation and adjust a Multiplex SBM fitted with GREMLIN.
</p>
<p>The list of parameters <code>estimOptions</code> essentially tunes the optimization process and the variational EM algorithm, with the following parameters
</p>

<ul>
<li><p> &quot;nbCores&quot; integer for number of cores used.  Default is 2
</p>
</li>
<li><p> &quot;verbosity&quot; integer for verbosity (0, 1). Default is 1
</p>
</li>
<li><p> &quot;nbBlocksRange&quot; List of length the number of functional groups, each element supplying the minimal and maximal number of blocks to be explored. The names of the list must be the names of the functional groups.  Default value is from 1 to 10)
</p>
</li>
<li><p> &quot;initBM&quot; Boolean. True if using simple and bipartite SBM as initialisations. Default value  = TRUE
</p>
</li>
<li><p> &quot;maxiterVEM&quot; Number of max. number of iterations in  the VEM. Default value  = 100
</p>
</li>
<li><p> &quot;maxiterVE&quot; Number of max. number of iterations in  the VE. Default value  = 100
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code><a href="#topic+MultipartiteSBM">sbm::MultipartiteSBM</a></code> -&gt; <code><a href="#topic+MultipartiteSBM_fit">sbm::MultipartiteSBM_fit</a></code> -&gt; <code>MultiplexSBM_fit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>nbBlocks</code></dt><dd><p>vector of size 2: number of blocks (rows, columns)</p>
</dd>
<dt><code>dependentNetwork</code></dt><dd><p>: connection parameters in each network</p>
</dd>
<dt><code>storedModels</code></dt><dd><p>data.frame of all models fitted (and stored) during the optimization</p>
</dd>
<dt><code>namesLayers</code></dt><dd><p>: names of the various Networks</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MultiplexSBM_fit-new"><code>MultiplexSBM_fit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MultiplexSBM_fit-optimize"><code>MultiplexSBM_fit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-MultiplexSBM_fit-plot"><code>MultiplexSBM_fit$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-MultiplexSBM_fit-show"><code>MultiplexSBM_fit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-MultiplexSBM_fit-predict"><code>MultiplexSBM_fit$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-MultiplexSBM_fit-clone"><code>MultiplexSBM_fit$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="MultipartiteSBM" data-id="print"><a href='../../sbm/html/MultipartiteSBM.html#method-MultipartiteSBM-print'><code>sbm::MultipartiteSBM$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="MultipartiteSBM_fit" data-id="setModel"><a href='../../sbm/html/MultipartiteSBM_fit.html#method-MultipartiteSBM_fit-setModel'><code>sbm::MultipartiteSBM_fit$setModel()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MultiplexSBM_fit-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for Multiplex SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>MultiplexSBM_fit$new(netList, dependentNet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>netList</code></dt><dd><p>list of SBM object with</p>
</dd>
<dt><code>dependentNet</code></dt><dd><p>boolean indicating whether dependence is assumed between networks beyond the common dependence on the latent variables</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultiplexSBM_fit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>estimation of multipartiteSBM via GREMLINS
</p>


<h5>Usage</h5>

<div class="r"><pre>MultiplexSBM_fit$optimize(estimOptions)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>estimOptions</code></dt><dd><p>options for MultipartiteBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultiplexSBM_fit-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>plot Multiplex Network
</p>


<h5>Usage</h5>

<div class="r"><pre>MultiplexSBM_fit$plot(
  type = c("data", "expected"),
  ordered = TRUE,
  plotOptions = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character for the type of plot: either 'data' (true connection), 'expected' (fitted connection). Default to 'data'.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>TRUE is the matrices are plotted after reorganization with the blocks. Default value = TRUE</p>
</dd>
<dt><code>plotOptions</code></dt><dd><p>list of plot options for the matrix view</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultiplexSBM_fit-show"></a>



<h4>Method <code>show()</code></h4>

<p>show method
</p>


<h5>Usage</h5>

<div class="r"><pre>MultiplexSBM_fit$show(type = "Fit of a Multiplex Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character used to specify the type of SBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MultiplexSBM_fit-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>prediction under the currently estimated model
</p>


<h5>Usage</h5>

<div class="r"><pre>MultiplexSBM_fit$predict()</pre></div>



<h5>Returns</h5>

<p>a list of matrices matrix of expected values for each dyad
</p>


<hr>
<a id="method-MultiplexSBM_fit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultiplexSBM_fit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='plot.SBM'>SBM Plot</h2><span id='topic+plot.SBM'></span>

<h3>Description</h3>

<p>Basic matrix plot method for SBM object or mesoscopic view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SBM'
plot(
  x,
  type = c("data", "expected", "meso"),
  ordered = TRUE,
  plotOptions = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SBM_+3A_x">x</code></td>
<td>
<p>an object inheriting from class SBM</p>
</td></tr>
<tr><td><code id="plot.SBM_+3A_type">type</code></td>
<td>
<p>character for the type of plot: either 'data' (true connection),  'expected' (fitted connection) or 'meso' (mesoscopic). Default to 'data'.</p>
</td></tr>
<tr><td><code id="plot.SBM_+3A_ordered">ordered</code></td>
<td>
<p>logical: should the rows and columns be ordered according to the clustering? Default to <code>TRUE</code> (not taken into account for 'meso').</p>
</td></tr>
<tr><td><code id="plot.SBM_+3A_plotoptions">plotOptions</code></td>
<td>
<p>list with parameters for 'meso' type plot and data type plot. Details are given below</p>
</td></tr>
<tr><td><code id="plot.SBM_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code>  for the mesoscopic plot is:
</p>

<dl>
<dt>&quot;seed&quot;: </dt><dd><p>seed to control the layout</p>
</dd>
<dt>&quot;title&quot;: </dt><dd><p>character string for the title. Default value is NULL</p>
</dd>
<dt>&quot;layout&quot;: </dt><dd><p>Default value = NULL</p>
</dd>
<dt>&quot;vertex.color&quot;: </dt><dd><p>Default value is &quot;salmon2&quot;</p>
</dd>
<dt>&quot;vertex.frame.color&quot;: </dt><dd><p>Node border color.Default value is &quot;black&quot; </p>
</dd>
<dt>&quot;vertex.shape&quot;: </dt><dd><p>One of &quot;none&quot;, &quot;circle&quot;, &quot;square&quot;, &quot;csquare&quot;, &quot;rectangle&quot; &quot;crectangle&quot;, &quot;vrectangle&quot;, &quot;pie&quot;, &quot;raster&quot;, or &quot;sphere&quot;. Default value = &quot;circle&quot;</p>
</dd>
<dt>&quot;vertex.size&quot;: </dt><dd><p>Size of the node (default is 2)</p>
</dd>
<dt>&quot;vertex.size2&quot;: </dt><dd><p>The second size of the node (e.g. for a rectangle)</p>
</dd>
<dt>&quot;vertex.label.name&quot;: </dt><dd><p>Names of the vertices. Default value is the label of the nodes</p>
</dd>
<dt>&quot;vertex.label.color&quot;: </dt><dd><p>Default value is  &quot;black&quot;</p>
</dd>
<dt>&quot;vertex.label.font&quot;: </dt><dd><p>Default value is 2. Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol</p>
</dd>
<dt>&quot;vertex.label.cex&quot;: </dt><dd><p>Font size (multiplication factor, device-dependent).Default value is  0.9.</p>
</dd>
<dt>&quot;vertex.label.dist&quot;: </dt><dd><p>Distance between the label and the vertex. Default value is  0</p>
</dd>
<dt>&quot;vertex.label.degree&quot;: </dt><dd><p>The position of the label in relation to the vertex. default value is 0</p>
</dd>
<dt>&quot;edge.threshold&quot;: </dt><dd><p>Threshold under which the edge is not plotted. Default value is = -Inf</p>
</dd>
<dt>&quot;edge.color&quot;: </dt><dd><p>Default value is &quot;gray&quot;</p>
</dd>
<dt>&quot;edge.width&quot;: </dt><dd><p>Factor parameter. Default value is 10</p>
</dd>
<dt>&quot;edge.arrow.size&quot;: </dt><dd><p>Default value is 1</p>
</dd>
<dt>&quot;edge.arrow.width&quot;: </dt><dd><p>Default value is 2</p>
</dd>
<dt>&quot;edge.lty&quot;: </dt><dd><p>Line type, could be 0 or &quot;blank&quot;, 1 or &quot;solid&quot;, 2 or &quot;dashed&quot;, 3 or &quot;dotted&quot;, 4 or &quot;dotdash&quot;, 5 or &quot;longdash&quot;, 6 or &quot;twodash&quot;. Default value is &quot;solid&quot;</p>
</dd>
<dt>&quot;edge.curved&quot;: </dt><dd><p>Default value is = 0.3.</p>
</dd>
</dl>

<p>For type = 'data' or 'expected plot', the list of parameters <code>plotOptions</code> is
</p>

<dl>
<dt>&quot;legend&quot;: </dt><dd><p>Boolean. Set TRUE if you want to see the legend. Default value is FALSE</p>
</dd>
<dt>&quot;legend.title&quot;:</dt><dd><p>Boolean. Set TRUE if you want to print the title of the legend. Default value is FALSE</p>
</dd>
<dt>&quot;legend.position&quot;:</dt><dd><p>Position of the legend. Possible values are 'bottom', 'top','left,'right'. Default value is 'bottom'</p>
</dd>
<dt>&quot;rowNames&quot;:</dt><dd><p>Set true if the rownames must be plotted. Default value is FALSE</p>
</dd>
<dt>&quot;colNames&quot;:</dt><dd><p>Set true if the colNames must be plotted. Default value is FALSE</p>
</dd>
<dt>&quot;line.color&quot;: </dt><dd><p>Chain of character. The color of the lines to separate groups if a clustering is provided. Default value is red</p>
</dd>
<dt>&quot;line.width&quot;: </dt><dd><p>Numeric. Width  of the lines to separate groups. Default value is NULL, automatically chosen</p>
</dd>
<dt>&quot;title&quot;: </dt><dd><p>Chain of character. Title of the plot. Default value is NULL</p>
</dd>
</dl>



<h3>Value</h3>

<p>a ggplot2 object for the <code>'data'</code> and <code>'expected'</code>, a list with the igraph object <code>g</code> and the <code>layout</code> for the <code>'meso'</code>
</p>

<hr>
<h2 id='plotAlluvial'>Plot an alluvial plot between  clusterings</h2><span id='topic+plotAlluvial'></span>

<h3>Description</h3>

<p>Plot an alluvial plot between  clusterings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAlluvial(listMemberships, plotOptions = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAlluvial_+3A_listmemberships">listMemberships</code></td>
<td>
<p>: a list vectors containing the memberships</p>
</td></tr>
<tr><td><code id="plotAlluvial_+3A_plotoptions">plotOptions</code></td>
<td>
<p>: a list containing the options for Alluvial plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code> provides the following options
</p>

<ul>
<li><p> &quot;curvy&quot; numeric, controls the curvature of the alluvial. Default value = 0.3
</p>
</li>
<li><p> &quot;alpha numeric, vector of transparency of the stripes. Default value = 0.8
</p>
</li>
<li><p> &quot;gap.width&quot; numeric, relative width of inter-category gaps. Default value = 0.1
</p>
</li>
<li><p> &quot;col&quot; vector of colors of the stripes. Default value = &quot;darkolivegreen3&quot;
</p>
</li>
<li><p> &quot;border&quot; vector of border colors for the stripes. Default is white
</p>
</li></ul>



<h3>Value</h3>

<p>display the alluvial plot, returns the plotOptions as a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>listMemberships &lt;- list(C1 = rep(c('A','B','C'),each=10),C2 = rep(c(1,2,4),10))
plotAlluvial(listMemberships)
</code></pre>

<hr>
<h2 id='plotMyMatrix'>Plot an adjacency or incidence Matrix</h2><span id='topic+plotMyMatrix'></span>

<h3>Description</h3>

<p>Plot an adjacency or incidence Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMyMatrix(
  Mat,
  dimLabels = c(row = "row", col = "col"),
  clustering = NULL,
  plotOptions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMyMatrix_+3A_mat">Mat</code></td>
<td>
<p>: a matrix representing the network</p>
</td></tr>
<tr><td><code id="plotMyMatrix_+3A_dimlabels">dimLabels</code></td>
<td>
<p>: a vector of length 1 or 2 specifying the types of nodes in row and col  (functional group) (Default is <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plotMyMatrix_+3A_clustering">clustering</code></td>
<td>
<p>: a list of length 2 specifying a clustering on row and col</p>
</td></tr>
<tr><td><code id="plotMyMatrix_+3A_plotoptions">plotOptions</code></td>
<td>
<p>: a list providing options. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list of parameters <code>plotOptions</code> for the matrix plot is
</p>

<ul>
<li><p> &quot;legend&quot;:  Boolean. Set TRUE if you want to see the legend. Default value is FALSE
</p>
</li>
<li><p> &quot;legend.title&quot;:  Boolean. Set TRUE if you want to print the title of the legend. Default value is FALSE
</p>
</li>
<li><p> &quot;legend.position&quot;:  Position of the legend. Possible values are 'bottom', 'top','left,'right'. Default value is 'bottom'
</p>
</li>
<li><p> &quot;rowNames&quot;:  Set true if the rownames must be plotted. Default value is FALSE
</p>
</li>
<li><p> &quot;colNames&quot;:  Set true if the colNames must be plotted. Default value is FALSE
</p>
</li>
<li><p> &quot;line.color&quot;:  Chain of character. The color of the lines to separate groups if a clustering is provided. Default value is red
</p>
</li>
<li><p> &quot;line.width&quot;:  Numeric. Width  of the lines to separate groups. Default value is NULL, automatically chosen
</p>
</li>
<li><p> &quot;title&quot;:  Chain of character. Title of the plot. Default value is NULL
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(sample(c(0,1),900,replace=TRUE),30,30)
plotMyMatrix(M, dimLabels = c('individulals'), plotOptions= list(legend = FALSE))
M2 &lt;- matrix( rpois(800,10),40,20)
plotMyMatrix(M2, dimLabels = c(row = 'reader',col = 'book'), plotOptions = list(legend = TRUE))

</code></pre>

<hr>
<h2 id='plotMyMultipartiteMatrix'>Plot the matrices corresponding to a Multipartite Network</h2><span id='topic+plotMyMultipartiteMatrix'></span>

<h3>Description</h3>

<p>Plot the matrices corresponding to a Multipartite Network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMyMultipartiteMatrix(listSBM, memberships = NULL, plotOptions = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMyMultipartiteMatrix_+3A_listsbm">listSBM</code></td>
<td>
<p>: a list of objects representing the multipartite network (see)</p>
</td></tr>
<tr><td><code id="plotMyMultipartiteMatrix_+3A_memberships">memberships</code></td>
<td>
<p>: a list of length equal to the number of Functional Groups providing the clusterings inside each group.</p>
</td></tr>
<tr><td><code id="plotMyMultipartiteMatrix_+3A_plotoptions">plotOptions</code></td>
<td>
<p>: a list containing the options. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotOptions is a list containing the following items
</p>

<ul>
<li><p> &quot;normalized&quot;: Boolean. TRUE if the various matrices are presented in the same scale (between O and 1). FALSE otherwise. Default value FALSE
</p>
</li>
<li><p> &quot;compact&quot;: Boolean. Default value is TRUE if you ask for the matrices to be transposed to have a more compact view
</p>
</li>
<li><p> &quot;legend&quot;:  Boolean. Set TRUE if you   want to see the legend. Default value is FALSE
</p>
</li>
<li><p> &quot;legend.title&quot;:  Boolean. Set TRUE if you want to print the title of the legend. Default value is FALSE
</p>
</li>
<li><p> &quot;legend.position&quot;:  Position of the legend. Possible values are 'bottom', 'top','left,'right'. Default value is 'bottom'
</p>
</li>
<li><p> &quot;nodeNames&quot;:  Set true if the node Names must be plotted. Default value is FALSE
</p>
</li>
<li><p> &quot;line.color&quot;: The color of the lines to separate groups. Default value is red
</p>
</li>
<li><p> &quot;line.width&quot;: Width  of the lines to separate groups. Default value is NULL, automatically chosen
</p>
</li>
<li><p> &quot;title&quot;:  Title of the plot. Default value is NULL
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("multipartiteEcologicalNetwork")
Net &lt;- multipartiteEcologicalNetwork
type='bipartite'
model = 'bernoulli'
directed = FALSE
listNet &lt;- list()
listNet[[1]] = defineSBM(Net$Inc_plant_ant,
                         model,type,directed,
                         dimLabels = c(row = "Plants", col = "Ants"))
listNet[[2]] = defineSBM(Net$Inc_plant_bird,model,type,directed,
                      dimLabels =c(row = "Plants",col = "Birds"))
plotMyMultipartiteMatrix(listNet,plotOptions=list(legend = TRUE,title='Ecology'))

listNet &lt;- list()
listNet[[1]] &lt;- defineSBM(matrix(rbinom(1000,1,0.5),20,50),
                   model = 'bernoulli',
                   type  ='bipartite', directed = NA,
                   dimLabels = c(row="Questions",col="Students"))
listNet[[2]] &lt;- defineSBM(matrix(rpois(20*30,8),30,20),
                   model = 'poisson',
                   type  ='bipartite',directed = NA,
                   dimLabels = c(row="Competences",col="Questions"))
plotMyMultipartiteMatrix(listNet,plotOptions=list(legend = TRUE,compact = FALSE))
plotMyMultipartiteMatrix(listNet,plotOptions=list(legend = TRUE,normalized =  TRUE))



</code></pre>

<hr>
<h2 id='plotMyMultiplexMatrix'>Plot the matrices corresponding to a Multiplex Network</h2><span id='topic+plotMyMultiplexMatrix'></span>

<h3>Description</h3>

<p>Plot the matrices corresponding to a Multiplex Network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMyMultiplexMatrix(listSBM, memberships = NULL, plotOptions = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMyMultiplexMatrix_+3A_listsbm">listSBM</code></td>
<td>
<p>: a list of objects representing the multiplex network (see)</p>
</td></tr>
<tr><td><code id="plotMyMultiplexMatrix_+3A_memberships">memberships</code></td>
<td>
<p>: a list of length equal to the number of Functional Groups providing the clusterings inside each group.</p>
</td></tr>
<tr><td><code id="plotMyMultiplexMatrix_+3A_plotoptions">plotOptions</code></td>
<td>
<p>: a list containing the options. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotOptions is a list containing the following items
</p>

<ul>
<li><p> &quot;normalized&quot;: Boolean. TRUE if the various matrices are presented in the same scale (between O and 1). FALSE otherwise. Default value FALSE
</p>
</li>
<li><p> &quot;compact&quot;: Boolean. Default value is TRUE if you ask for the matrices to be transposed to have a more compact view
</p>
</li>
<li><p> &quot;legend&quot;:  Boolean. Set TRUE if you   want to see the legend. Default value is FALSE
</p>
</li>
<li><p> &quot;legend.title&quot;:  Boolean. Set TRUE if you want to print the title of the legend. Default value is FALSE
</p>
</li>
<li><p> &quot;legend.position&quot;:  Position of the legend. Possible values are 'bottom', 'top','left,'right'. Default value is 'bottom'
</p>
</li>
<li><p> &quot;nodeNames&quot;:  Set true if the node Names must be plotted. Default value is FALSE
</p>
</li>
<li><p> &quot;line.color&quot;: The color of the lines to separate groups. Default value is red
</p>
</li>
<li><p> &quot;line.width&quot;: Width  of the lines to separate groups. Default value is NULL, automatically chosen
</p>
</li>
<li><p> &quot;title&quot;:  Title of the plot. Default value is NULL
</p>
</li></ul>



<h3>Value</h3>

<p>a ggplot object corresponding to the plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Nnodes &lt;- c(40,30)
blockProp &lt;- list(c(.4,.6),c(0.5,0.5))
nbLayers &lt;- 2
connectParam &lt;- list(list(mean=matrix(rbeta(4,.5,.5),2,2)),list(mean=matrix(rexp(4,.5),2,2)))
names(connectParam) &lt;- c('Read','Score')
model &lt;- c("bernoulli","poisson")
type &lt;- "bipartite"
mySampleMultiplexSBM &lt;-
 sampleMultiplexSBM(
   nbNodes = Nnodes,
   blockProp = blockProp,
   nbLayers = nbLayers,
   connectParam = connectParam,
   model=model,
   dimLabels =  c('readers','books'),
   type=type)
listNet &lt;- mySampleMultiplexSBM$listSBM
names(listNet) &lt;- c("Read","Affinity")
plotMyMultiplexMatrix(listNet,plotOptions=list(legend = TRUE))



</code></pre>

<hr>
<h2 id='predict.SBM'>Model Predictions</h2><span id='topic+predict.SBM'></span>

<h3>Description</h3>

<p>Make predictions from an SBM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SBM'
predict(object, covarList = object$covarList, theta_p0 = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.SBM_+3A_object">object</code></td>
<td>
<p>an R6 object inheriting from class SBM_fit (like SimpleSBM_fit or BipartiteSBM_fit)</p>
</td></tr>
<tr><td><code id="predict.SBM_+3A_covarlist">covarList</code></td>
<td>
<p>a list of covariates. By default, we use the covariates associated with the model.</p>
</td></tr>
<tr><td><code id="predict.SBM_+3A_theta_p0">theta_p0</code></td>
<td>
<p>a threshold...</p>
</td></tr>
<tr><td><code id="predict.SBM_+3A_...">...</code></td>
<td>
<p>additional parameters for S3 compatibility. Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of expected values for each dyad
</p>

<hr>
<h2 id='sampleBipartiteSBM'>Sampling of Bipartite SBMs</h2><span id='topic+sampleBipartiteSBM'></span>

<h3>Description</h3>

<p>This function samples a simple Stochastic Block Models, with various model
for the distribution of the edges:  Bernoulli, Poisson, or Gaussian models, and possibly with covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleBipartiteSBM(
  nbNodes,
  blockProp,
  connectParam,
  model = "bernoulli",
  dimLabels = c(row = "row", col = "col"),
  covariates = list(),
  covariatesParam = numeric(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleBipartiteSBM_+3A_nbnodes">nbNodes</code></td>
<td>
<p>number of nodes in the network</p>
</td></tr>
<tr><td><code id="sampleBipartiteSBM_+3A_blockprop">blockProp</code></td>
<td>
<p>parameters for block proportions: list of size two with row and column block proportions</p>
</td></tr>
<tr><td><code id="sampleBipartiteSBM_+3A_connectparam">connectParam</code></td>
<td>
<p>list of parameters for connectivity with a matrix of means 'mean' and an optional matrix of variances 'var', the sizes of which must match <code>blockProp</code> length (in row, respectively in column)</p>
</td></tr>
<tr><td><code id="sampleBipartiteSBM_+3A_model">model</code></td>
<td>
<p>character describing the model for the relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, <code>'ZIgaussian'</code>). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="sampleBipartiteSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional list of labels for each dimension (in row, in column)</p>
</td></tr>
<tr><td><code id="sampleBipartiteSBM_+3A_covariates">covariates</code></td>
<td>
<p>a list of matrices with same dimension as mat describing covariates at the edge level. No covariate per Default.</p>
</td></tr>
<tr><td><code id="sampleBipartiteSBM_+3A_covariatesparam">covariatesParam</code></td>
<td>
<p>optional vector of covariates effect. A zero length numeric vector by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object with class <code><a href="#topic+BipartiteSBM">BipartiteSBM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### =======================================
### BIPARTITE BERNOULLI SBM
## Graph parameters
nbNodes &lt;- c(100, 120)
blockProp &lt;- list(c(.5, .5), c(1/3, 1/3, 1/3)) # group proportions
means &lt;- matrix(runif(6), 2, 3)  # connectivity matrix
# In Bernoulli SBM, parameters is a list with
# a matrix of means 'mean' which are probabilities of connection
connectParam &lt;- list(mean = means)

## Graph Sampling
dimLabels = c(row='Reader',col='Book')
mySampler &lt;- sampleBipartiteSBM(nbNodes, blockProp, connectParam, model = 'bernoulli',dimLabels)
plot(mySampler)
plot(mySampler,type='meso',plotOptions = list(vertex.label.name=list(row='Reader',col='Book')))
plot(mySampler,type='meso',plotOptions = list(vertex.label.name=c('A','B'),vertex.size = 1.4))
mySampler$rMemberships() # sample new memberships
mySampler$rEdges()   # sample new edges
mySampler$rNetwork()   # sample a new networrk (blocks and edges)
### =======================================
### BIPARTITE POISSON SBM
## Graph parameters
nbNodes &lt;- c(100, 120)
blockProp &lt;- list(c(.5, .5), c(1/3, 1/3, 1/3)) # group proportions
means &lt;- matrix(rbinom(6, 30, 0.25), 2, 3)  # connectivity matrix
# In Poisson SBM, parameters is a list with a matrix of
# means 'mean' which are a mean integer value taken by edges
connectParam &lt;- list(mean = means)

## Graph Sampling
dimLabels = c(row = 'Ind', col = 'Service')
mySampler &lt;- sampleBipartiteSBM(nbNodes, blockProp, connectParam, model = 'poisson', dimLabels)
plot(mySampler,type='expected')
plotOptions = list(vertex.label.name=c('U','V'),vertex.size = c(1.4,1.3))
plot(mySampler, type='meso', plotOptions = plotOptions)
hist(mySampler$networkData)

### =======================================
### BIPARTITE GAUSSIAN SBM
## Graph parameters
nbNodes &lt;- c(100, 120)
blockProp &lt;- list(c(.5, .5), c(1/3, 1/3, 1/3)) # group proportions
means &lt;- 20 * matrix(runif(6), 2, 3)  # connectivity matrix
# In Gaussian SBM, parameters is a list with a matrix
# of means 'mean' and a matrix of variances 'var'
connectParam &lt;- list(mean = means, var = 1)

## Graph Sampling
mySampler &lt;- sampleBipartiteSBM(nbNodes, blockProp, connectParam, model = 'gaussian')
plot(mySampler)
hist(mySampler$networkData)

</code></pre>

<hr>
<h2 id='sampleMultipartiteSBM'>Sampling of Multipartite SBMs</h2><span id='topic+sampleMultipartiteSBM'></span>

<h3>Description</h3>

<p>This function samples a Multipartite Stochastic Block Models, with various model
for the distribution of the edges:  Bernoulli, Poisson, or Gaussian models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMultipartiteSBM(
  nbNodes,
  blockProp,
  archiMultipartite,
  connectParam,
  model,
  directed,
  dimLabels = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleMultipartiteSBM_+3A_nbnodes">nbNodes</code></td>
<td>
<p>number of nodes in each functional group involved in the multipartite network</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_blockprop">blockProp</code></td>
<td>
<p>a list of parameters for block proportions  in each functional group</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_archimultipartite">archiMultipartite</code></td>
<td>
<p>a matrix with two columns and nbNetworks lines, each line specifying the index of the functional groups in interaction.</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_connectparam">connectParam</code></td>
<td>
<p>list of parameters for connectivity (of length nbNetworks). Each element is a list of one or two elements: a matrix of means 'mean' and an optional matrix of variances 'var', the sizes of which must match <code>blockProp</code> length</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_model">model</code></td>
<td>
<p>a vector of characters describing the model for  each network of the Multipartite relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, ...). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_directed">directed</code></td>
<td>
<p>a vector of logical, directed network or not for each network. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional list of labels for functional group involved in the network</p>
</td></tr>
<tr><td><code id="sampleMultipartiteSBM_+3A_seed">seed</code></td>
<td>
<p>numeric to set the seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements : <code>simulatedMemberships</code> are the clustering of each node in each Functional Group,
<code>multipartiteNetwork</code> is the list of the simulated networks (each one being  a simple or bipartite network)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### =======================================
### MULTIPARTITE SBM  : 4 networks between 3 Functional Groups
## Graph parameters
# About the Functional Groups (FG)
nbNodes &lt;-  c(100,50,40)
blockProp &lt;- vector("list", 3)  # parameters of clustering in each functional group
blockProp[[1]] &lt;- c(0.4,0.3,0.3) # in Functional Group 1
blockProp[[2]] &lt;- c(0.6,0.4) # in Functional Group 2
blockProp[[3]]  &lt;- c(0.6,0.4) # in Functional Group 3
# About the interactions between the FG
archiMultipartite  &lt;-  rbind(c(1,2),c(2,3),c(2,2),c(1,3)) #
model &lt;- c('bernoulli','poisson','gaussian','gaussian') # type of distribution in each network
# for each network : directed or not (not required for an interaction between two different FG)
directed &lt;- c( NA, NA  ,  FALSE , NA)
connectParam &lt;- list()
connectParam[[1]] &lt;- list(mean = matrix(c(0.3, 0.3, 0.5, 0.2, 0.6, 0.6),3,2))
connectParam[[2]] &lt;- list(mean = matrix(c(1000 , 500,  400 , 950),2,2))
connectParam[[3]] &lt;- list(mean = matrix(c(10, 0, -10, 20), 2,2), var = matrix(1,2,2))
connectParam[[4]] &lt;- list(mean = matrix(c(3, 23 ,11 ,16 , 2 ,25), 3,2))
connectParam[[4]]$var &lt;- matrix(c(10,20,1,5,0.1,10), 3,2)
dimLabels &lt;- c('A','B','C')
## Graph Sampling
mySampleMBM &lt;- sampleMultipartiteSBM(nbNodes, blockProp,
                                     archiMultipartite,
                                     connectParam, model, directed,
                                     dimLabels,seed = 3)
listSBM &lt;- mySampleMBM$listSBM
memberships &lt;- mySampleMBM$memberships
plotMyMultipartiteMatrix(listSBM)
plotMyMultipartiteMatrix(listSBM,plotOptions = list(normalized = TRUE))
plotMyMultipartiteMatrix(listSBM,memberships = memberships,plotOptions = list(normalized = TRUE))
</code></pre>

<hr>
<h2 id='sampleMultiplexSBM'>Sampling of Multiplex SBMs</h2><span id='topic+sampleMultiplexSBM'></span>

<h3>Description</h3>

<p>This function samples a Multiplex Stochastic Block Models, with various model
for the distribution of the edges:  Bernoulli, Poisson, or Gaussian models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMultiplexSBM(
  nbNodes,
  blockProp,
  nbLayers,
  connectParam,
  model,
  type = c("directed", "undirected", "bipartite"),
  dependent = FALSE,
  dimLabels = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleMultiplexSBM_+3A_nbnodes">nbNodes</code></td>
<td>
<p>number of nodes in each functional group involved in the Multiplex network</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_blockprop">blockProp</code></td>
<td>
<p>a vector for block proportion if the networks are simple, a list of parameters for block proportions for both functional groups if the networks are bipartite</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_nblayers">nbLayers</code></td>
<td>
<p>a matrix with two columns and nbNetworks lines, each line specifying the index of the functional groups in interaction.</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_connectparam">connectParam</code></td>
<td>
<p>list of parameters for connectivity (of length nbNetworks). Each element is a list of one or two elements: a matrix of means 'mean' and an optional matrix of variances 'var', the sizes of which must match <code>blockProp</code> length</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_model">model</code></td>
<td>
<p>a vector of characters describing the model for  each network of the Multiplex relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, ...). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_type">type</code></td>
<td>
<p>a string of character indicating whether the networks are directed, undirected or bipartite</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_dependent">dependent</code></td>
<td>
<p>connection parameters in each network</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional list of labels for functional group involved in the network</p>
</td></tr>
<tr><td><code id="sampleMultiplexSBM_+3A_seed">seed</code></td>
<td>
<p>numeric to set the seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements : <code>simulatedMemberships</code> are the clustering of each node in each Functional Group,  <code>MultiplexNetwork</code> is the list of the simulated networks (each one being  a simple or bipartite network)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nbLayers &lt;- 2

## MultiplexSBM without dependence between layers
Nnodes &lt;- 40
blockProp &lt;- c(.4,.6)
connectParam &lt;- list(list(mean=matrix(rbeta(4,.5,.5),2,2)),list(mean=matrix(rexp(4,.5),2,2)))
model &lt;- c("bernoulli","poisson")
type &lt;- "directed"
mySampleMultiplexSBM &lt;-
   sampleMultiplexSBM(
   nbNodes = Nnodes,
    blockProp = blockProp,
   nbLayers = nbLayers,
   connectParam = connectParam,
   model=model,
   type=type)
listSBM &lt;- mySampleMultiplexSBM$listSBM

## MultiplexSBM Gaussian with dependence
Q &lt;- 3
nbLayers &lt;- 2
connectParam &lt;- list()
connectParam$mu &lt;- vector("list",nbLayers)
connectParam$mu[[1]] &lt;-  matrix(.1,Q,Q) + diag(1:Q)
connectParam$mu[[2]] &lt;- matrix(-2,Q,Q) + diag(rev(Q:1))
connectParam$Sigma &lt;- matrix(c(2,1,1,4),nbLayers,nbLayers)
model &lt;- rep("gaussian",2)
type &lt;- "directed"
Nnodes &lt;- 80
blockProp &lt;- c(.3,.3,.4)
mySampleMultiplexSBM &lt;-
  sampleMultiplexSBM(
     nbNodes = Nnodes,
     blockProp = blockProp,
     nbLayers = nbLayers,
     connectParam = connectParam,
     model=model,
     type="undirected",
     dependent=TRUE)
listSBM &lt;- mySampleMultiplexSBM$listSBM
## MultiplexSBM Bernoulli with dependence
Q &lt;- 2
P00&lt;-matrix(runif(Q*Q),Q,Q)
P10&lt;-matrix(runif(Q*Q),Q,Q)
P01&lt;-matrix(runif(Q*Q),Q,Q)
P11&lt;-matrix(runif(Q*Q),Q,Q)
SumP&lt;-P00+P10+P01+P11
P00&lt;-P00/SumP
P01&lt;-P01/SumP
P10&lt;-P10/SumP
P11&lt;-P11/SumP
connectParam &lt;- list()
connectParam$prob00 &lt;- P00
connectParam$prob01 &lt;- P01
connectParam$prob10 &lt;- P10
connectParam$prob11 &lt;- P11
model &lt;- rep("bernoulli",2)
type &lt;- "directed"
nbLayers &lt;- 2
Nnodes &lt;- 40
blockProp &lt;- c(.6,.4)
mySampleMultiplexSBM &lt;-
   sampleMultiplexSBM(
     nbNodes = Nnodes,
     blockProp = blockProp,
     nbLayers = nbLayers,
     connectParam = connectParam,
     model=model,
     type=type,
     dependent=TRUE)
listSBM_BB &lt;- mySampleMultiplexSBM$listSBM

</code></pre>

<hr>
<h2 id='sampleSimpleSBM'>Sampling of Simple SBMs</h2><span id='topic+sampleSimpleSBM'></span>

<h3>Description</h3>

<p>This function samples a simple Stochastic Block Models, with various model
for the distribution of the edges:  Bernoulli, Poisson, or Gaussian models, and possibly with covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSimpleSBM(
  nbNodes,
  blockProp,
  connectParam,
  model = "bernoulli",
  directed = FALSE,
  dimLabels = c("node"),
  covariates = list(),
  covariatesParam = numeric(0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleSimpleSBM_+3A_nbnodes">nbNodes</code></td>
<td>
<p>number of nodes in the network</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_blockprop">blockProp</code></td>
<td>
<p>parameters for block proportions</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_connectparam">connectParam</code></td>
<td>
<p>list of parameters for connectivity with a matrix of means 'mean' and an optional matrix of variances 'var', the sizes of which must match <code>blockProp</code> length</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_model">model</code></td>
<td>
<p>character describing the model for the relation between nodes (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>, ...). Default is <code>'bernoulli'</code>.</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_directed">directed</code></td>
<td>
<p>logical, directed network or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_dimlabels">dimLabels</code></td>
<td>
<p>an optional list of labels for each dimension (in row, in column)</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_covariates">covariates</code></td>
<td>
<p>a list of matrices with same dimension as mat describing covariates at the edge level. No covariate per Default.</p>
</td></tr>
<tr><td><code id="sampleSimpleSBM_+3A_covariatesparam">covariatesParam</code></td>
<td>
<p>optional vector of covariates effect. A zero length numeric vector by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object with class <code><a href="#topic+SimpleSBM">SimpleSBM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### =======================================
### SIMPLE BINARY SBM (Bernoulli model)
## Graph parameters
nbNodes  &lt;- 90
blockProp &lt;- c(.5, .25, .25) # group proportions
means &lt;- diag(.4, 3) + 0.05  # connectivity matrix: affiliation network
# In Bernoulli SBM, parameters is a list with a
# matrix of means 'mean' which are probabilities of connection
connectParam &lt;- list(mean = means)

## Graph Sampling
mySampler &lt;- sampleSimpleSBM(nbNodes, blockProp, connectParam, model = 'bernoulli')
plot(mySampler)
plot(mySampler)
plot(mySampler,type='meso')
hist(mySampler$networkData)

### =======================================
### SIMPLE POISSON SBM
## Graph parameters
nbNodes  &lt;- 90
blockProp &lt;- c(.5, .25, .25) # group proportions
means &lt;- diag(15., 3) + 5    # connectivity matrix: affiliation network
# In Poisson SBM, parameters is a list with
# a matrix of means 'mean' which are a mean integer value taken by edges
connectParam &lt;- list(mean = means)

## Graph Sampling
mySampler &lt;- sampleSimpleSBM(nbNodes, blockProp, list(mean = means), model = "poisson")
plot(mySampler)
plot(mySampler,type='meso')
hist(mySampler$networkData)

### =======================================
### SIMPLE GAUSSIAN SBM
## Graph parameters
nbNodes  &lt;- 90
blockProp &lt;- c(.5, .25, .25)      # group proportions
means &lt;- diag(15., 3) + 5 # connectivity matrix: affiliation network
# In Gaussian SBM, parameters is a list with
# a matrix of means 'mean' and a matrix of variances 'var'
connectParam &lt;- list(mean = means, var = 2)

## Graph Sampling
mySampler &lt;- sampleSimpleSBM(nbNodes, blockProp, connectParam, model = "gaussian",dimLabels='Tree')
plot(mySampler)
plot(mySampler,type='meso')
hist(mySampler$networkData)
</code></pre>

<hr>
<h2 id='SBM'>R6 virtual class for SBM representation (mother class of SimpleSBM, BipartiteSBM, MultipartiteSBM)</h2><span id='topic+SBM'></span>

<h3>Description</h3>

<p>R6 virtual class for SBM representation (mother class of SimpleSBM, BipartiteSBM, MultipartiteSBM)
</p>
<p>R6 virtual class for SBM representation (mother class of SimpleSBM, BipartiteSBM, MultipartiteSBM)
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>modelName</code></dt><dd><p>character, the family of model for the distribution of the edges</p>
</dd>
<dt><code>directed</code></dt><dd><p>mode of the network data (directed or not or not applicable)</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>vector or list of characters, the label of each dimension</p>
</dd>
<dt><code>nbNodes</code></dt><dd><p>vector describing the number of the successive elements connecting the network</p>
</dd>
<dt><code>nbCovariates</code></dt><dd><p>integer, the number of covariates</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>block proportions (aka prior probabilities of each block)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>parameters associated to the connectivity of the SBM, e.g. matrix of inter/inter block probabilities when model is Bernoulli</p>
</dd>
<dt><code>covarParam</code></dt><dd><p>vector of regression parameters associated with the covariates.</p>
</dd>
<dt><code>covarList</code></dt><dd><p>list of matrices of covariates</p>
</dd>
<dt><code>covarArray</code></dt><dd><p>the array of covariates</p>
</dd>
<dt><code>covarEffect</code></dt><dd><p>effect of covariates</p>
</dd>
<dt><code>networkData</code></dt><dd><p>the network data (adjacency or incidence matrix or list of such object)</p>
</dd>
<dt><code>expectation</code></dt><dd><p>expected values of connection under the current model</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SBM-new"><code>SBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SBM-rNetwork"><code>SBM$rNetwork()</code></a>
</p>
</li>
<li> <p><a href="#method-SBM-show"><code>SBM$show()</code></a>
</p>
</li>
<li> <p><a href="#method-SBM-print"><code>SBM$print()</code></a>
</p>
</li>
<li> <p><a href="#method-SBM-clone"><code>SBM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SBM-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>SBM$new(
  model = vector("character", 0),
  directed = vector("logical", 0),
  dimension = vector("numeric", 0),
  dimLabels = vector("character", 0),
  blockProp = vector("numeric", 0),
  connectParam = vector("list", 0),
  covarParam = numeric(length(covarList)),
  covarList = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>character describing the type of model</p>
</dd>
<dt><code>directed</code></dt><dd><p>logical describing if the network data is directed or not</p>
</dd>
<dt><code>dimension</code></dt><dd><p>dimension of the network data</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>labels of each dimension</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>parameters for block proportions (vector or list of vectors)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>list of parameters for connectivity</p>
</dd>
<dt><code>covarParam</code></dt><dd><p>optional vector of covariates effect</p>
</dd>
<dt><code>covarList</code></dt><dd><p>optional list of covariates data</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SBM-rNetwork"></a>



<h4>Method <code>rNetwork()</code></h4>

<p>a method to sample a network data for the current SBM (blocks and edges)
</p>


<h5>Usage</h5>

<div class="r"><pre>SBM$rNetwork(store = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>store</code></dt><dd><p>should the sampled network be stored (and overwrite the existing data)? Default to FALSE</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a list with the sampled block and network
</p>


<hr>
<a id="method-SBM-show"></a>



<h4>Method <code>show()</code></h4>

<p>print method
</p>


<h5>Usage</h5>

<div class="r"><pre>SBM$show(type = "Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character to tune the displayed name</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SBM-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method
</p>


<h5>Usage</h5>

<div class="r"><pre>SBM$print()</pre></div>


<hr>
<a id="method-SBM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='SimpleSBM'>R6 class for Simple SBM</h2><span id='topic+SimpleSBM'></span>

<h3>Description</h3>

<p>R6 class for Simple SBM
</p>
<p>R6 class for Simple SBM
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code>SimpleSBM</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>dimLabels</code></dt><dd><p>a single character giving the label of the nodes</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>vector of block proportions (aka prior probabilities of each block)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>parameters associated to the connectivity of the SBM, e.g. matrix of inter/inter block probabilities when model is Bernoulli</p>
</dd>
<dt><code>probMemberships</code></dt><dd><p>matrix of estimated probabilities for block memberships for all nodes</p>
</dd>
<dt><code>nbBlocks</code></dt><dd><p>number of blocks</p>
</dd>
<dt><code>nbDyads</code></dt><dd><p>number of dyads (potential edges in the network)</p>
</dd>
<dt><code>nbConnectParam</code></dt><dd><p>number of parameter used for the connectivity</p>
</dd>
<dt><code>memberships</code></dt><dd><p>vector of clustering</p>
</dd>
<dt><code>indMemberships</code></dt><dd><p>matrix for clustering memberships</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimpleSBM-new"><code>SimpleSBM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM-rMemberships"><code>SimpleSBM$rMemberships()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM-rEdges"><code>SimpleSBM$rEdges()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM-predict"><code>SimpleSBM$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM-show"><code>SimpleSBM$show()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM-plot"><code>SimpleSBM$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM-clone"><code>SimpleSBM$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="print"><a href='../../sbm/html/SBM.html#method-SBM-print'><code>sbm::SBM$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimpleSBM-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$new(
  model,
  nbNodes,
  directed,
  blockProp,
  connectParam,
  dimLabels = c("node"),
  covarParam = numeric(length(covarList)),
  covarList = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>character describing the type of model</p>
</dd>
<dt><code>nbNodes</code></dt><dd><p>number of nodes in the network</p>
</dd>
<dt><code>directed</code></dt><dd><p>logical, directed network or not.</p>
</dd>
<dt><code>blockProp</code></dt><dd><p>parameters for block proportions (vector of list of vectors)</p>
</dd>
<dt><code>connectParam</code></dt><dd><p>list of parameters for connectivity with a matrix of means 'mean' and an optional scalar for the variance 'var'. The size of mu must match <code>blockProp</code> length</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>optional label for the node (default is &quot;nodeName&quot;)</p>
</dd>
<dt><code>covarParam</code></dt><dd><p>optional vector of covariates effect</p>
</dd>
<dt><code>covarList</code></dt><dd><p>optional list of covariates data</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleSBM-rMemberships"></a>



<h4>Method <code>rMemberships()</code></h4>

<p>a method to sample new block memberships for the current SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$rMemberships(store = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>store</code></dt><dd><p>should the sampled blocks be stored (and overwrite the existing data)? Default to FALSE</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the sampled blocks
</p>


<hr>
<a id="method-SimpleSBM-rEdges"></a>



<h4>Method <code>rEdges()</code></h4>

<p>a method to sample a network data (edges) for the current SBM
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$rEdges(store = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>store</code></dt><dd><p>should the sampled edges be stored (and overwrite the existing data)? Default to FALSE</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>the sampled network
</p>


<hr>
<a id="method-SimpleSBM-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>prediction under the currently parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$predict(covarList = self$covarList, theta_p0 = 0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covarList</code></dt><dd><p>a list of covariates. By default, we use the covariates with which the model was estimated</p>
</dd>
<dt><code>theta_p0</code></dt><dd><p>a threshold...</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a matrix of expected values for each dyad
</p>


<hr>
<a id="method-SimpleSBM-show"></a>



<h4>Method <code>show()</code></h4>

<p>show method
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$show(type = "Simple Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character used to specify the type of SBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleSBM-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>basic matrix plot method for SimpleSBM object or mesoscopic plot
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$plot(
  type = c("data", "expected", "meso"),
  ordered = TRUE,
  plotOptions = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character for the type of plot: either 'data' (true connection), 'expected' (fitted connection) or 'meso' (mesoscopic view). Default to 'data'.</p>
</dd>
<dt><code>ordered</code></dt><dd><p>logical: should the rows and columns be reordered according to the clustering? Default to <code>TRUE</code>.</p>
</dd>
<dt><code>plotOptions</code></dt><dd><p>list with the parameters for the plot. See help of the corresponding S3 method for details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a ggplot2 object for the <code>'data'</code> and <code>'expected'</code>, a list with the igraph object <code>g</code>, the <code>layout</code> and the <code>plotOptions</code> for the <code>'meso'</code>
</p>


<hr>
<a id="method-SimpleSBM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='SimpleSBM_fit'>R6 Class definition of a Simple SBM fit</h2><span id='topic+SimpleSBM_fit'></span>

<h3>Description</h3>

<p>R6 Class definition of a Simple SBM fit
</p>
<p>R6 Class definition of a Simple SBM fit
</p>


<h3>Details</h3>

<p>This class is designed to give a representation and adjust an SBM fitted with blockmodels.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+SBM">sbm::SBM</a></code> -&gt; <code><a href="#topic+SimpleSBM">sbm::SimpleSBM</a></code> -&gt; <code>SimpleSBM_fit</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>loglik</code></dt><dd><p>double: approximation of the log-likelihood (variational lower bound) reached</p>
</dd>
<dt><code>ICL</code></dt><dd><p>double: value of the integrated classification log-likelihood</p>
</dd>
<dt><code>penalty</code></dt><dd><p>double, value of the penalty term in ICL</p>
</dd>
<dt><code>entropy</code></dt><dd><p>double, value of the entropy due to the clustering distribution</p>
</dd>
<dt><code>storedModels</code></dt><dd><p>data.frame of all models fitted (and stored) during the optimization</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimpleSBM_fit-new"><code>SimpleSBM_fit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM_fit-optimize"><code>SimpleSBM_fit$optimize()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM_fit-setModel"><code>SimpleSBM_fit$setModel()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM_fit-reorder"><code>SimpleSBM_fit$reorder()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM_fit-show"><code>SimpleSBM_fit$show()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleSBM_fit-clone"><code>SimpleSBM_fit$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="print"><a href='../../sbm/html/SBM.html#method-SBM-print'><code>sbm::SBM$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SBM" data-id="rNetwork"><a href='../../sbm/html/SBM.html#method-SBM-rNetwork'><code>sbm::SBM$rNetwork()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SimpleSBM" data-id="plot"><a href='../../sbm/html/SimpleSBM.html#method-SimpleSBM-plot'><code>sbm::SimpleSBM$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SimpleSBM" data-id="predict"><a href='../../sbm/html/SimpleSBM.html#method-SimpleSBM-predict'><code>sbm::SimpleSBM$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SimpleSBM" data-id="rEdges"><a href='../../sbm/html/SimpleSBM.html#method-SimpleSBM-rEdges'><code>sbm::SimpleSBM$rEdges()</code></a></span></li>
<li><span class="pkg-link" data-pkg="sbm" data-topic="SimpleSBM" data-id="rMemberships"><a href='../../sbm/html/SimpleSBM.html#method-SimpleSBM-rMemberships'><code>sbm::SimpleSBM$rMemberships()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimpleSBM_fit-new"></a>



<h4>Method <code>new()</code></h4>

<p>constructor for a Simple SBM fit
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM_fit$new(
  adjacencyMatrix,
  model,
  directed,
  dimLabels = c(node = "nodeName"),
  covarList = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>adjacencyMatrix</code></dt><dd><p>square (weighted) matrix</p>
</dd>
<dt><code>model</code></dt><dd><p>character (<code>'bernoulli'</code>, <code>'poisson'</code>, <code>'gaussian'</code>)</p>
</dd>
<dt><code>directed</code></dt><dd><p>logical, directed network or not. In not, <code>adjacencyMatrix</code> must be symmetric.</p>
</dd>
<dt><code>dimLabels</code></dt><dd><p>list of labels of each dimension (in row, in columns)</p>
</dd>
<dt><code>covarList</code></dt><dd><p>and optional list of covariates, each of whom must have the same dimension as <code>adjacencyMatrix</code></p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleSBM_fit-optimize"></a>



<h4>Method <code>optimize()</code></h4>

<p>function to perform optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM_fit$optimize(estimOptions = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>estimOptions</code></dt><dd><p>a list of parameters controlling the inference algorithm and model selection. See details.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleSBM_fit-setModel"></a>



<h4>Method <code>setModel()</code></h4>

<p>method to select a specific model among the ones fitted during the optimization.
Fields of the current SBM_fit will be updated accordingly.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM_fit$setModel(index)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>index</code></dt><dd><p>integer, the index of the model to be selected (row number in storedModels)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleSBM_fit-reorder"></a>



<h4>Method <code>reorder()</code></h4>

<p>permute group labels by order of decreasing probability
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM_fit$reorder()</pre></div>


<hr>
<a id="method-SimpleSBM_fit-show"></a>



<h4>Method <code>show()</code></h4>

<p>show method
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM_fit$show(type = "Fit of a Simple Stochastic Block Model")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>character used to specify the type of SBM</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleSBM_fit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleSBM_fit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='war'>War data set</h2><span id='topic+war'></span>

<h3>Description</h3>

<p>This dataset contains two networks where the nodes are countries and an
edge in network &quot;belligerent&quot; means that the two countries have been at
least once at war between years 1816 to 2007 while an edge in network &quot;alliance&quot;
means that the two countries have had a formal alliance between years 1816 to 2012.
The network <code>belligerent</code> have less nodes since countries which have not been at
war are not considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>war
</code></pre>


<h3>Format</h3>

<p>A list with 2 two igraph objects, <code>alliance</code> and <code>belligerent</code>.
Each graph have three attributes: 'name' (the country name), 'power' (a score related to military power: the higher, the better) and
'trade' (a score related to the trade effort between pairs of countries).
</p>


<h3>Source</h3>

<p>networks were extracted from <a href="https://correlatesofwar.org/">https://correlatesofwar.org/</a>
</p>


<h3>References</h3>

<p>Sarkees, Meredith Reid and Frank Wayman (2010). Resort to War: 1816 - 2007. Washington DC: CQ Press.
</p>
<p>Gibler, Douglas M. 2009. International military alliances, 1648-2008. CQ Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(war)
class(war$belligerent)
igraph::gorder(war$alliance)
igraph::gorder(war$belligerent)
igraph::edges(war$alliance)
igraph::get.graph.attribute(war$alliance)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
