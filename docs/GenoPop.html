<!DOCTYPE html><html lang="en"><head><title>Help for package GenoPop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GenoPop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculateAlleleFreqs'><p>Calculate Allele Frequencies from Genotype Matrix</p></a></li>
<li><a href='#Dxy'><p>Dxy</p></a></li>
<li><a href='#FixedSites'><p>FixedSites</p></a></li>
<li><a href='#Fst'><p>Fst</p></a></li>
<li><a href='#GenoPop_Impute'><p>GenoPop-Impute</p></a></li>
<li><a href='#Heterozygosity'><p>Heterozygosity Rate</p></a></li>
<li><a href='#OneDimSFS'><p>OneDimSFS</p></a></li>
<li><a href='#Pi'><p>Pi</p></a></li>
<li><a href='#PrivateAlleles'><p>PrivateAlleles</p></a></li>
<li><a href='#SegregatingSites'><p>SegregatingSites</p></a></li>
<li><a href='#separateByPopulations'><p>Separate Genotype Matrix by Populations</p></a></li>
<li><a href='#SingletonSites'><p>SingletonSites</p></a></li>
<li><a href='#TajimasD'><p>TajimasD</p></a></li>
<li><a href='#TwoDimSFS'><p>TwoDimSFS</p></a></li>
<li><a href='#WattersonsTheta'><p>WattersonsTheta</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Genotype Imputation and Population Genomics Efficiently from
Variant Call Formatted (VCF) Files</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for efficient processing of large, whole genome genotype data sets in variant call format (VCF). It includes several functions to calculate commonly used population genomic metrics and a method for reference panel free genotype imputation, which is described in the preprint Gurke &amp; Mayer (2024) &lt;<a href="https://doi.org/10.22541%2Fau.172515591.10119928%2Fv1">doi:10.22541/au.172515591.10119928/v1</a>&gt;.</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-25</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rsamtools, GenomicRanges, foreach, doParallel, parallel,
missForest, IRanges</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-25 10:03:28 UTC; mick</td>
</tr>
<tr>
<td>Author:</td>
<td>Marie Gurke <a href="https://orcid.org/0000-0001-9901-424X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marie Gurke &lt;margurke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-25 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculateAlleleFreqs'>Calculate Allele Frequencies from Genotype Matrix</h2><span id='topic+calculateAlleleFreqs'></span>

<h3>Description</h3>

<p>This function calculates allele frequencies from a genotype matrix (sep_gt) for each variant.
It is designed to be used within the batch or window processing framework of <code>process_vcf_in_batches</code> and <code>process_vcf_in_windows</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateAlleleFreqs(sep_gt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateAlleleFreqs_+3A_sep_gt">sep_gt</code></td>
<td>
<p>Genotype matrix similar to the <code style="white-space: pre;">&#8288;@sep_gt&#8288;</code> slot of a <code>vcfR</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing allele frequencies for each variant.
</p>

<hr>
<h2 id='Dxy'>Dxy</h2><span id='topic+Dxy'></span>

<h3>Description</h3>

<p>This function calculates the average number of nucleotide differences per site (Dxy) between two populations from a VCF file (Nei &amp; Li, 1979 (https://doi.org/10.1073/pnas.76.10.5269)).
Handling missing alleles at one site is equivalent to Korunes &amp; Samuk, 2021 ( https://doi.org/10.1111/1755-0998.13326).
The function calculates the number of monomorphic sites using the sequence length and the number of variants in the VCF file. This assumes, that all sites not present in the VCF file are invariant sites, which will underestimate the metric, because of commonly done (and necessary) variant filtering. However, otherwise this calculation would only work with VCF files that include all monomorphic sites, which is quite unpractical for common use cases and will increase computational demands significantly.
If you happen to know the number of filtered our sites vs the number of monomorphic sites, please use the number of monomorphic + the number of polymorphic (number of variants in your VCF) sites as the sequence length to get the most accurate estimation of the metric. (This does not work for the window mode of this function, which assumes the sequence length to be the window size.)
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dxy(
  vcf_path,
  pop1_individuals,
  pop2_individuals,
  seq_length,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  window_size = NULL,
  skip_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dxy_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_pop1_individuals">pop1_individuals</code></td>
<td>
<p>Vector of individual names belonging to the first population.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_pop2_individuals">pop2_individuals</code></td>
<td>
<p>Vector of individual names belonging to the second population.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_seq_length">seq_length</code></td>
<td>
<p>Length of the sequence in number of bases, including monomorphic sites (used in batch mode only).</p>
</td></tr>
<tr><td><code id="Dxy_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="Dxy_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="Dxy_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): The average number of nucleotide substitutions per site between the individuals of two populations (Dxy).
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'Dxy', representing the average nucleotide differences within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
pop1_individuals &lt;- c("tsk_0", "tsk_1", "tsk_2")
pop2_individuals &lt;- c("tsk_3", "tsk_4", "tsk_5")
total_sequence_length &lt;- 999299  # Total length of the sequence
# Batch mode example
dxy_value &lt;- Dxy(vcf_file, pop1_individuals, pop2_individuals, total_sequence_length)
# Window mode example
dxy_windows &lt;- Dxy(vcf_file, pop1_individuals, pop2_individuals, seq_length = total_sequence_length,
                   window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='FixedSites'>FixedSites</h2><span id='topic+FixedSites'></span>

<h3>Description</h3>

<p>This function counts the number of sites fixed for the alternative allele (&quot;1&quot;) in a VCF file.
It processes the file in two modes: the entire file at once or in specified windows across the genome.
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach but tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixedSites(
  vcf_path,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  batch_size = 10000,
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FixedSites_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="FixedSites_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function has two modes of operation:
</p>

<ol>
<li><p> Batch Mode: Processes the entire VCF file in batches to count the total number of fixed sites for the alternative allele. Suitable for a general overview of the entire dataset.
</p>
</li>
<li><p> Window Mode: Processes the VCF file in windows of a specified size and skip distance. This mode is useful for identifying regions with high numbers of fixed sites, which could indicate selective sweeps or regions of low recombination.
</p>
</li></ol>



<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): A single integer representing the total number of fixed sites for the alternative allele across the entire VCF file.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'FixedSites', representing the count of fixed sites within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Batch mode example
vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
num_fixed_sites &lt;- FixedSites(vcf_file)

# Window mode example
fixed_sites_df &lt;- FixedSites(vcf_file, window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='Fst'>Fst</h2><span id='topic+Fst'></span>

<h3>Description</h3>

<p>This function calculates the fixation index (Fst) between two populations from a VCF file using the method of Weir and Cockerham (1984).
The formula used for this is equivalent to the one used in vcftools &ndash;weir-fst-pop (https://vcftools.sourceforge.net/man_latest.html).
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fst(
  vcf_path,
  pop1_individuals,
  pop2_individuals,
  weighted = FALSE,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  window_size = NULL,
  skip_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fst_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="Fst_+3A_pop1_individuals">pop1_individuals</code></td>
<td>
<p>Vector of individual names belonging to the first population.</p>
</td></tr>
<tr><td><code id="Fst_+3A_pop2_individuals">pop2_individuals</code></td>
<td>
<p>Vector of individual names belonging to the second population.</p>
</td></tr>
<tr><td><code id="Fst_+3A_weighted">weighted</code></td>
<td>
<p>Logical, whether weighted Fst or mean Fst is returned (Default = FALSE (mean Fst is returned)).</p>
</td></tr>
<tr><td><code id="Fst_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="Fst_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="Fst_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="Fst_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="Fst_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="Fst_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): Fst value (either mean or weighted).
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'Fst', representing the fixation index within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
pop1_individuals &lt;- c("tsk_0", "tsk_1", "tsk_2")
pop2_individuals &lt;- c("tsk_3", "tsk_4", "tsk_5")
# Batch mode example
fst_value &lt;- Fst(vcf_file, pop1_individuals, pop2_individuals, weighted = TRUE)
# Window mode example
fst_windows &lt;- Fst(vcf_file, pop1_individuals, pop2_individuals, weighted = TRUE,
                   window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='GenoPop_Impute'>GenoPop-Impute</h2><span id='topic+GenoPop_Impute'></span>

<h3>Description</h3>

<p>Performs imputation of missing genomic data in batches using the missForest (Stekhoven &amp; BÃ¼hlmanm, 2012) algorithm. This function reads VCF files, divides it into batches of a fixed number of SNPs, applies the missForest algorithm to each batch, and writes the results to a new VCF file, which will be returned bgzipped and tabix indexed. The choice of the batch size is critical for balancing accuracy and computational demand. We found that a batch size of 500 SNPs is the most accurate for recombination rates typical of mammalians. For on average higher recombination rates (&gt; 5 cM/Mb) we recommend a batch size of 100 SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenoPop_Impute(
  vcf_path,
  output_vcf,
  batch_size = 1000,
  maxiter = 10,
  ntree = 100,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenoPop_Impute_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the input VCF file.</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_output_vcf">output_vcf</code></td>
<td>
<p>Path for the output VCF file with imputed data.</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_batch_size">batch_size</code></td>
<td>
<p>Number of SNPs to process per batch (default: 500).</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_maxiter">maxiter</code></td>
<td>
<p>Number of improvement iterations for the random forest algorithm (default: 10).</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_ntree">ntree</code></td>
<td>
<p>Number of decision trees in the random forest (default: 100).</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_threads">threads</code></td>
<td>
<p>Number of threads used for computation (default: 1).</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_write_log">write_log</code></td>
<td>
<p>If TRUE, writes a log file of the process (advised for large datasets).</p>
</td></tr>
<tr><td><code id="GenoPop_Impute_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file, used if <code>write_log</code> is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to the output VCF file with imputed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> vcf_file &lt;- system.file("tests/testthat/sim_miss.vcf.gz", package = "GenoPop")
 index_file &lt;- system.file("tests/testthat/sim_miss.vcf.gz.tbi", package = "GenoPop")
 output_file &lt;- tempfile(fileext = ".vcf")
 GenoPop_Impute(vcf_file, output_vcf = output_file, batch_size = 500)
</code></pre>

<hr>
<h2 id='Heterozygosity'>Heterozygosity Rate</h2><span id='topic+Heterozygosity'></span>

<h3>Description</h3>

<p>This function calculates the rate of heterozygosity for samples in a VCF file. (The proportion of heterozygote genotypes.)
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Heterozygosity(
  vcf_path,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Heterozygosity_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="Heterozygosity_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): Observed heterozygosity rate averaged over all loci.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'Ho', representing the observed heterozygosity rate within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
# Batch mode example
Ho &lt;- Heterozygosity(vcf_file)
# Window mode example
Ho_windows &lt;- Heterozygosity(vcf_file, window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='OneDimSFS'>OneDimSFS</h2><span id='topic+OneDimSFS'></span>

<h3>Description</h3>

<p>This function calculates a one-dimensional site frequency spectrum from a VCF file. It processes the file in batches for efficient memory usage.
The user can decide between a folded or unfolded spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OneDimSFS(
  vcf_path,
  folded = FALSE,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OneDimSFS_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="OneDimSFS_+3A_folded">folded</code></td>
<td>
<p>Logical, deciding if folded (TRUE) or unfolded (FALSE) SFS is returned.</p>
</td></tr>
<tr><td><code id="OneDimSFS_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="OneDimSFS_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="OneDimSFS_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="OneDimSFS_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="OneDimSFS_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Site frequency spectrum as a named vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
sfs &lt;- OneDimSFS(vcf_file, folded = FALSE)

</code></pre>

<hr>
<h2 id='Pi'>Pi</h2><span id='topic+Pi'></span>

<h3>Description</h3>

<p>This function calculates the nucleotide diversity (Pi) for a sample in a VCF file as defined by Nei &amp; Li, 1979 (https://doi.org/10.1073/pnas.76.10.5269).
The formula used for this is equivalent to the one used in vcftools &ndash;window-pi (https://vcftools.sourceforge.net/man_latest.html).
Handling missing alleles at one site is equivalent to Korunes &amp; Samuk, 2021 ( https://doi.org/10.1111/1755-0998.13326).
The function calculates the number of monomorphic sites using the sequence length and the number of variants in the VCF file. This assumes, that all sites not present in the VCF file are invariant sites, which will underestimate the metric, because of commonly done (and necessary) variant filtering. However, otherwise this calculation would only work with VCF files that include all monomorphic sites, which is quite unpractical for common use cases and will increase computational demands significantly.
If you happen to know the number of filtered our sites vs the number of monomorphic sites, please use the number of monomorphic + the number of polymorphic (number of variants in your VCF) sites as the sequence length to get the most accurate estimation of the metric. (This does not work for the window mode of this function, which assumes the sequence length to be the window size.)
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pi(
  vcf_path,
  seq_length,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pi_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="Pi_+3A_seq_length">seq_length</code></td>
<td>
<p>Total length of the sequence in number of bases (used in batch mode only).</p>
</td></tr>
<tr><td><code id="Pi_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="Pi_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="Pi_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="Pi_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="Pi_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="Pi_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="Pi_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): Nucleotide diversity (Pi) across the sequence.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'Pi', representing the nucleotide diversity within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
total_sequence_length &lt;- 999299  # Total length of the sequence in vcf
# Batch mode example
pi_value &lt;- Pi(vcf_file, total_sequence_length)
# Window mode example
pi_windows &lt;- Pi(vcf_file, seq_length = total_sequence_length,
                 window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='PrivateAlleles'>PrivateAlleles</h2><span id='topic+PrivateAlleles'></span>

<h3>Description</h3>

<p>This function calculates the number of private alleles in two populations from a VCF file. (Alleles which are not present in the other popualtion.)
It processes the file in batches or specified windows across the genome.
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrivateAlleles(
  vcf_path,
  pop1_individuals,
  pop2_individuals,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  batch_size = 10000,
  window_size = NULL,
  skip_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PrivateAlleles_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_pop1_individuals">pop1_individuals</code></td>
<td>
<p>Vector of individual names belonging to the first population.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_pop2_individuals">pop2_individuals</code></td>
<td>
<p>Vector of individual names belonging to the second population.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="PrivateAlleles_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): A list containing the number of private alleles for each population.
In window mode (window_size and skip_size provided): A list of data frames, each with columns 'Chromosome', 'Start', 'End', 'PrivateAllelesPop1', and 'PrivateAllelesPop2', representing the count of private alleles within each window for each population.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Batch mode example
vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
pop1_individuals &lt;- c("tsk_0", "tsk_1", "tsk_2")
pop2_individuals &lt;- c("tsk_3", "tsk_4", "tsk_5")
private_alleles &lt;- PrivateAlleles(vcf_file, pop1_individuals, pop2_individuals)

# Window mode example
private_alleles_windows &lt;- PrivateAlleles(vcf_file, pop1_individuals, pop2_individuals,
                                          window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='SegregatingSites'>SegregatingSites</h2><span id='topic+SegregatingSites'></span>

<h3>Description</h3>

<p>This function counts the number of polymorphic or segregating sites (sites not fixed for the alternative allele)
in a VCF file. It processes the file in batches or specified windows across the genome.
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SegregatingSites(
  vcf_path,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  batch_size = 10000,
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SegregatingSites_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="SegregatingSites_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): A single integer representing the total number of polymorphic sites across the entire VCF file.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'PolymorphicSites', representing the count of polymorphic sites within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Batch mode example
vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
num_polymorphic_sites &lt;- SegregatingSites(vcf_file)

# Window mode example
polymorphic_sites_df &lt;- SegregatingSites(vcf_file, window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='separateByPopulations'>Separate Genotype Matrix by Populations</h2><span id='topic+separateByPopulations'></span>

<h3>Description</h3>

<p>This function separates a genotype matrix into two data frames based on population assignments.
It's designed to work with the batches or windows processed by <code>process_vcf_in_batches</code> and <code>process_vcf_in_windows</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separateByPopulations(
  sep_gt,
  pop1_names,
  pop2_names,
  ploidy = 2,
  rm_ref_alleles = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="separateByPopulations_+3A_sep_gt">sep_gt</code></td>
<td>
<p>A genotype matrix similar to the <code style="white-space: pre;">&#8288;@sep_gt&#8288;</code> slot of a <code>vcfR</code> object.</p>
</td></tr>
<tr><td><code id="separateByPopulations_+3A_pop1_names">pop1_names</code></td>
<td>
<p>A character vector of individual names for the first population.</p>
</td></tr>
<tr><td><code id="separateByPopulations_+3A_pop2_names">pop2_names</code></td>
<td>
<p>A character vector of individual names for the second population.</p>
</td></tr>
<tr><td><code id="separateByPopulations_+3A_rm_ref_alleles">rm_ref_alleles</code></td>
<td>
<p>Logical, whether variants that only have the reference allele
should be removed from the respective subpopulations data frame. (Default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two data frames, one for each population.
</p>

<hr>
<h2 id='SingletonSites'>SingletonSites</h2><span id='topic+SingletonSites'></span>

<h3>Description</h3>

<p>This function counts the number of singleton sites (sites where a minor allele occurs only once in the sample)
in a VCF file. It processes the file in batches or specified windows across the genome.
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingletonSites(
  vcf_path,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  batch_size = 10000,
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SingletonSites_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="SingletonSites_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): A single integer representing the total number of singleton sites across the entire VCF file.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'SingletonSites', representing the count of singleton sites within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Batch mode example
vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
num_singleton_sites &lt;- SingletonSites(vcf_file)

# Window mode example
vcf_path &lt;- "path/to/vcf/file"
singleton_sites_df &lt;- SingletonSites(vcf_file, window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='TajimasD'>TajimasD</h2><span id='topic+TajimasD'></span>

<h3>Description</h3>

<p>This function calculates Tajima's D statistic for a given dataset (Tajima, 1989 (10.1093/genetics/123.3.585)).
The formula used for this is equivalent to the one used in vcftools &ndash;TajimaD (https://vcftools.sourceforge.net/man_latest.html).
The function calculates the number of monomorphic sites using the sequence length and the number of variants in the VCF file. This assumes, that all sites not present in the VCF file are invariant sites, which will underestimate the metric, because of commonly done (and necessary) variant filtering. However, otherwise this calculation would only work with VCF files that include all monomorphic sites, which is quite unpractical for common use cases and will increase computational demands significantly.
If you happen to know the number of filtered our sites vs the number of monomorphic sites, please use the number of monomorphic + the number of polymorphic (number of variants in your VCF) sites as the sequence length to get the most accurate estimation of the metric. (This does not work for the window mode of this function, which assumes the sequence length to be the window size.)
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TajimasD(
  vcf_path,
  seq_length,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TajimasD_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_seq_length">seq_length</code></td>
<td>
<p>Total length of the sequence in number of bases (used in batch mode only).</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="TajimasD_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): Tajima's D value.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'TajimasD', representing Tajima's D within each window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
total_sequence_length &lt;- 999299  # Total length of the sequence
# Batch mode example
tajimas_d &lt;- TajimasD(vcf_file, total_sequence_length)
# Window mode example
tajimas_d_windows &lt;- TajimasD(vcf_file, seq_length = total_sequence_length,
                              window_size = 100000, skip_size = 50000)

</code></pre>

<hr>
<h2 id='TwoDimSFS'>TwoDimSFS</h2><span id='topic+TwoDimSFS'></span>

<h3>Description</h3>

<p>This function calculates a two-dimensional site frequency spectrum from a VCF file for two populations. It processes the file in batches for efficient memory usage.
The user can decide between a folded or unfolded spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoDimSFS(
  vcf_path,
  pop1_individuals,
  pop2_individuals,
  folded = FALSE,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TwoDimSFS_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_pop1_individuals">pop1_individuals</code></td>
<td>
<p>Vector of individual names belonging to the first population.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_pop2_individuals">pop2_individuals</code></td>
<td>
<p>Vector of individual names belonging to the second population.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_folded">folded</code></td>
<td>
<p>Logical, deciding if folded (TRUE) or unfolded (FALSE) SFS is returned.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="TwoDimSFS_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two-dimensional site frequency spectrum as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
pop1_individuals &lt;- c("tsk_0", "tsk_1", "tsk_2")
pop2_individuals &lt;- c("tsk_3", "tsk_4", "tsk_5")
sfs_2d &lt;- TwoDimSFS(vcf_file, pop1_individuals, pop2_individuals, folded = TRUE)

</code></pre>

<hr>
<h2 id='WattersonsTheta'>WattersonsTheta</h2><span id='topic+WattersonsTheta'></span>

<h3>Description</h3>

<p>This function calculates Watterson's Theta, a measure for neutrality, from a VCF file (Watterson, 1975 (https://doi.org/10.1016/0040-5809(75)90020-9)).
The function calculates the number of monomorphic sites using the sequence length and the number of variants in the VCF file. This assumes, that all sites not present in the VCF file are invariant sites, which will underestimate the metric, because of commonly done (and necessary) variant filtering. However, otherwise this calculation would only work with VCF files that include all monomorphic sites, which is quite unpractical for common use cases and will increase computational demands significantly.
If you happen to know the number of filtered our sites vs the number of monomorphic sites, please use the number of monomorphic + the number of polymorphic (number of variants in your VCF) sites as the sequence length to get the most accurate estimation of the metric. (This does not work for the window mode of this function, which assumes the sequence length to be the window size.)
For batch processing, it uses <code>process_vcf_in_batches</code>. For windowed analysis, it uses a similar
approach tailored to process specific genomic windows (<code>process_vcf_in_windows</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WattersonsTheta(
  vcf_path,
  seq_length,
  batch_size = 10000,
  threads = 1,
  write_log = FALSE,
  logfile = "log.txt",
  window_size = NULL,
  skip_size = NULL,
  exclude_ind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WattersonsTheta_+3A_vcf_path">vcf_path</code></td>
<td>
<p>Path to the VCF file.</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_seq_length">seq_length</code></td>
<td>
<p>The length of the sequence in the data set (used in batch mode only).</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of variants to be processed in each batch
(used in batch mode only, default of 10,000 should be suitable for most use cases).</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_threads">threads</code></td>
<td>
<p>Number of threads to use for parallel processing.</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_write_log">write_log</code></td>
<td>
<p>Logical, indicating whether to write progress logs.</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_logfile">logfile</code></td>
<td>
<p>Path to the log file where progress will be logged.</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_window_size">window_size</code></td>
<td>
<p>Size of the window for windowed analysis in base pairs (optional).
When specified, <code>skip_size</code> must also be provided.</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_skip_size">skip_size</code></td>
<td>
<p>Number of base pairs to skip between windows (optional).
Used in conjunction with <code>window_size</code> for windowed analysis.</p>
</td></tr>
<tr><td><code id="WattersonsTheta_+3A_exclude_ind">exclude_ind</code></td>
<td>
<p>Optional vector of individual IDs to exclude from the analysis.
If provided, the function will remove these individuals from the genotype matrix
before applying the custom function. Default is NULL, meaning no individuals are excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In batch mode (no window_size or skip_size provided): Watterson's theta value normalized by the sequence length.
In window mode (window_size and skip_size provided): A data frame with columns 'Chromosome', 'Start', 'End', and 'WattersonsTheta', representing Watterson's theta within each window normalized by the window length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vcf_file &lt;- system.file("tests/testthat/sim.vcf.gz", package = "GenoPop")
index_file &lt;- system.file("tests/testthat/sim.vcf.gz.tbi", package = "GenoPop")
total_sequence_length &lt;- 999299  # Total length of the sequence
# Batch mode example
wattersons_theta &lt;- WattersonsTheta(vcf_file, total_sequence_length)
# Window mode example
wattersons_theta_windows &lt;- WattersonsTheta(vcf_file, seq_length = total_sequence_length,
                                            window_size = 100000, skip_size = 50000)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
